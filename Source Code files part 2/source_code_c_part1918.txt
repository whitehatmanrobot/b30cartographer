*****************
//
// Function: NV3Load16x16CursorData()
//
// Routine Description:
//
//   C version for IA64 only.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//*****************************************************************************

VOID NV3Load16x16CursorData(
BYTE*   pjSrcScan,
BYTE*   pjDstScan
)
    {
    UCHAR*    AndMaskPtr;
    UCHAR*     MonoMaskPtr;
    ULONG*     DstPtr;
    UCHAR      AndMask;
    UCHAR      MonoMask;
    LONG       i, j, k;

    AndMaskPtr = (UCHAR *)pjSrcScan;
    MonoMaskPtr = (UCHAR *)(pjSrcScan + 64);
    DstPtr = (ULONG *)pjDstScan;

   //***************************************************************************
   // Iterate through 16 rows of data
   //***************************************************************************
    for (i = 0; i < 16; i++)
        {
        //**********************************************************************
        // Load 16bpp pels - uses tables to convert ones to 0x7fff and zeros to
        // 0x0000.  Also uses table to add transparency bit from AND mask.
        // Zero in AND mask converts to 0x8000, ones to 0x0000.
        //**********************************************************************
        

        for (j = 0; j < 2; j++)
            {
            AndMask = *AndMaskPtr++;
            MonoMask = *MonoMaskPtr++;
            for (k = 0; k < 4; k++)
                {
                *DstPtr++ = AndTable[(AndMask >> 6) & 0x3] |
                            MonoTable[(MonoMask >> 6) & 0x3];
                AndMask <<= 2;
                MonoMask <<= 2;
                }
            }
            AndMaskPtr += 2;
            MonoMaskPtr += 2;

        //**********************************************************************
        // Blank out remaining 'width' portion of 32x32 cursor (clear 16 pels)
        //**********************************************************************
        for (j = 0; j < 8; j++)
            *DstPtr++ = 0x0;
            }

    //**************************************************************************
    // Blank out remaining 'height' portion of 32x32 cursor
    // (clear out 16 lines * 32 pels = 512 pels = 256 dwords)
    //**************************************************************************
    for (i = 0; i < 256; i++)
        *DstPtr++ = 0x0;
    }
#endif // _WIN64
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3ddrw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV3DDRW.C
//
// Abstract:
//
//     Implements all NV3 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#ifdef NV3

#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"
#include "nv3a_ref.h"

#include "nvsubch.h"
#include "nvalpha.h"
#include "nvapi.h"

#undef DEBUG_MSG_CHANNEL_WAIT

//******************************************************************************
// Forward Declarations
//******************************************************************************
VOID NV3_FlipBuffer(PDEV *, ULONG);

#define OFFSET_NV_PFIFO_BASE                        (0x2000)
#define OFFSET_NV_PFIFO_CACHE1_PUSH0_REG            (0x3200-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA0_REG             (0x3220-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_INTR_0                      (0x2100-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHES                      (0x2500-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PULL0                (0x3240-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PUSH1                (0x3204-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_STATUS               (0x3214-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CONFIG_0                    (0x2200-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PT_BASE      (0x3238-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_TAG          (0x3230-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PTE          (0x3234-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA3                 (0x322C-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_STATUS           (0x3218-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA1                 (0x3224-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA2                 (0x3228-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA0                 (0x3220-OFFSET_NV_PFIFO_BASE)

#define OFFSET_PRMCIO_INP0_COLOR_REG                0x3da

#define OFFSET_PRMCIO_CRX__COLOR_REG                0x3d4
#define OFFSET_PRMCIO_CR__COLOR_REG                 0x3d5

#define OFFSET_PRMVIO_SRX_REG                       0x3c4
#define OFFSET_PRMVIO_SR_LOCK_REG                   0x3c5
#define OFFSET_PRMVIO_MISC_READ_REG                 0x3cc
#define OFFSET_PRAMDAC_CU_START_POS_REG             0x0

#define NV_SR_UNLOCK_VALUE                          0x00000057
#define NV_SR_LOCK_VALUE                            0x00000099

//******************************************************************************
// Forward Declarations
//******************************************************************************

ULONG NV3_VBlankIsActive(PDEV *);
ULONG NV3_DisplayIsActive(PDEV *);
ULONG NV3_GraphicsEngineBusy(PDEV *);
VOID NV3_WaitWhileVBlankActive(PDEV * );
VOID NV3_WaitWhileDisplayActive(PDEV * );
VOID NV3_SetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_WaitForFifoAndEngineIdle(PDEV* ppdev);


//******************************************************************************
//
// Function: NV3_VBlankIsActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV3_VBlankIsActive(PDEV*   ppdev)

    {
    return (!(ppdev->pfnGetScanline(ppdev)));
    }


//******************************************************************************
//
// Function: NV3_DisplayIsActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV3_DisplayIsActive(PDEV*   ppdev)

    {
    return (ppdev->pfnGetScanline(ppdev));
    }


//******************************************************************************
//
// Function: NV3_WaitForFifoAndEngineIdle()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitForFifoAndEngineIdle(PDEV* ppdev)

    {
    volatile ULONG *Intr0Reg;
    volatile ULONG *CachesReg;
    volatile ULONG *Cache1Pull0Reg;
    ULONG cache1Pull0Value, cachesValue, intr;
    volatile ULONG *GrStatusReg;
    volatile ULONG *Cache1Dma0Reg;
    volatile ULONG *Cache1StatusReg;

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "NV3_WaitForFifoAndEngineIdle: Entry"));
#endif
    //**************************************************************************
    // Wait for pending interrupts to be completed...
    //**************************************************************************
    Intr0Reg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_INTR_0);
    intr = READ_REGISTER_ULONG(Intr0Reg) & 0x10111;
    while (intr)
    {
        // just look at cache_error, runout_pending, overflow_pending, and DMA PTE pending
        intr = READ_REGISTER_ULONG(Intr0Reg) & 0x10111;
    }

    //**************************************************************************
    // Wait for the FIFO to be enabled by potential RM operations...
    //**************************************************************************
    CachesReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHES);
    cachesValue = READ_REGISTER_ULONG(CachesReg);
    while ((cachesValue & 0x1) == 0)
        {
        cachesValue = READ_REGISTER_ULONG(CachesReg);
        }

    Cache1Pull0Reg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PULL0);
    cache1Pull0Value = READ_REGISTER_ULONG(Cache1Pull0Reg);
    while ((cache1Pull0Value & 0x1) == 0)
        {
        cache1Pull0Value = READ_REGISTER_ULONG(Cache1Pull0Reg);
        }

    //**************************************************************************
    // Wait for DMA pusher to be complete...
    //**************************************************************************
    Cache1Dma0Reg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA0_REG);
    while (READ_REGISTER_ULONG(Cache1Dma0Reg) > 0); // wait for idle status

    //**************************************************************************
    // Make sure that the FIFO is really empty.
    //**************************************************************************
    Cache1StatusReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_STATUS);
    while ((READ_REGISTER_ULONG(Cache1StatusReg) & 0x10) != 0x10);

    //**************************************************************************
    // Wait for the graphics engine to complete the last command
    //**************************************************************************
    GrStatusReg = ppdev->GrStatusReg;
    while (READ_REGISTER_ULONG(GrStatusReg) & (NV_PGRAPH_STATUS_STATE_BUSY | 0x80000000));

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "NV3_WaitForFifoAndEngineIdle: Exit"));
#endif
    }

//******************************************************************************
//
// Function: NV3_WaitForChannelSwitch()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitForChannelSwitch(PDEV*   ppdev)

    {
    Nv3ChannelPio  *nv  = (Nv3ChannelPio*) ppdev->pjMmBase;
    USHORT         FreeCount;
    NvNotification *pSyncNotifier = (NvNotification *)ppdev->Notifiers->Sync;

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "WaitForChannelSwitch: Entry"));
#endif

    if (!nv) return;

    NV3_WaitForFifoAndEngineIdle(ppdev);

    //**************************************************************************
    // Here, we make sure the Resource Manager has completed the switch from
    // Channel 1 (DMA Pusher/OpenGL) to Channel 0 (PIO)
    //**************************************************************************

    //**************************************************************************
    // Send dummy methods down the FIFO
    // If Channel 1 was previously active (OpenGL/ICD), writing this
    // method will generate a channel exception in the resource manager,
    // causing it to switch to channel 0.
    //**************************************************************************

    if (nv)
        {
#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "WaitForChannelSwitch: Punch PIO channel"));
#endif

        FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free ;
        while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
            FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.Free ;

        //***********************************************************************
        // Ensure graphics engine has completed all processing by waiting for
        // method notification.
        //***********************************************************************
        pSyncNotifier->status = NV_IN_PROGRESS;
        nv->subchannel[DD_ROP_RECT_AND_TEXT].nvRenderGdi0RectangleAndText.SetNotify = 0;
        nv->subchannel[DD_ROP_RECT_AND_TEXT].nvRenderGdi0RectangleAndText.Color1A = 0;
        while ((volatile)pSyncNotifier->status == NV_IN_PROGRESS); // wait for notification
        ppdev->NVFreeCount = NvGetFreeCount(nv, DD_ROP_RECT_AND_TEXT);

#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "WaitForChannelSwitch: Punch PIO channel complete"));
#endif

        }

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "WaitForChannelSwitch: Exit"));
#endif
    }



//******************************************************************************
//
// Function: NV3_GraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV3_GraphicsEngineBusy(PDEV*   ppdev)

    {
    Nv3ChannelPio *nv  = (Nv3ChannelPio*) ppdev->pjMmBase;
    USHORT FreeCount;
    BOOL   bReleaseOpenGLSemaphore = FALSE;

    if (!nv) return(FALSE);

    //**************************************************************************
    // If OpenGL is enabled, then wait for access to PIO FIFO and Semaphore lock
    // out any other processes.
    //**************************************************************************

    if (OglIsEnabled(ppdev))
        {
        ppdev->pfnAcquireOglMutex(ppdev);
        bReleaseOpenGLSemaphore = TRUE;

        ppdev->NVFreeCount = 0;

        //**********************************************************************
        // We need to make absolutely sure that the Channel switch
        // from the DMA pusher to the PIO channel has been completed
        //**********************************************************************

        ppdev->pfnWaitForChannelSwitch(ppdev);
        }

    //**************************************************************************
    // Init the cached free count
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Here, we use a notifier to make sure the engine is no longer busy.
    // We'll just send a NO-OP (using the RECT_AND_TEXT object) and
    // wait for the notifier to complete.
    //**************************************************************************

    while (FreeCount < 2*4)
         FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
    FreeCount -= 2*4;

    ((NvNotification *) (ppdev->Notifiers->Sync))->status = NV_STATUS_IN_PROGRESS;

    //**************************************************************************
    // Send the NO-OP on thru
    //**************************************************************************

    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.SetNotify = 0;
    nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nvRenderGdi0RectangleAndText.Color1A = 0;

    //**************************************************************************
    // Wait for completion...
    //**************************************************************************
    while ((volatile)((NvNotification *) ppdev->Notifiers->Sync)->status == NV_IN_PROGRESS); // wait for notification

    //**************************************************************************
    // Make sure to update the free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    if (bReleaseOpenGLSemaphore == TRUE)
        {
        ppdev->pfnReleaseOglMutex(ppdev);

        bReleaseOpenGLSemaphore = FALSE;
        }

    return(FALSE);
    }


//******************************************************************************
//
// Function: NV3_WaitWhileVBlankActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitWhileVBlankActive(PDEV*   ppdev)

    {
    while (NV3_VBlankIsActive(ppdev))
        ;
    }

//******************************************************************************
//
// Function: NV3_WaitWhileDisplayActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitWhileDisplayActive(PDEV*   ppdev)

    {
    while (NV3_DisplayIsActive(ppdev))
        ;
    }


//******************************************************************************
//
// Function: NV3_WaitWhileGraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_WaitWhileGraphicsEngineBusy(PDEV*   ppdev)

    {
    while (NV3_GraphicsEngineBusy(ppdev))
        ;
    }

//******************************************************************************
//
// Function: NV3_FlipBuffer()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_FlipBuffer(PDEV*   ppdev, ULONG MemoryOffset)

    {
    volatile UCHAR *PRMCIO_CRX_COLOR_Reg;
    volatile UCHAR *PRMCIO_CR_COLOR_Reg;
    volatile UCHAR *PRMVIO_SRX_Reg;
    volatile UCHAR *PRMVIO_SR_LOCK_Reg;
    volatile UCHAR *PRMVIO_MISC_READ_Reg;
    UCHAR i;
    UCHAR lock;

    //**************************************************************************
    // Get pointers to CRTC registers
    //
    //  ???? Should be BYTE writes or DWORDS writes ????
    //  ???? Should be BYTE? but CRTC_WR macro outputs in DWORDS???
    //
    //  #define CRTC_WR(i,d)    {PRMCIO_REG_WR32(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
    //                        PRMCIO_REG_WR32(PRMCIO_Base,NV_PRMCIO_CR__COLOR, (d));}
    //  #define CRTC_RD(i,d)    {PRMCIO_REG_WR32(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
    //                        (d) = PRMCIO_REG_RD32(PRMCIO_Base,NV_PRMCIO_CR__COLOR);}
    //**************************************************************************

    PRMCIO_CRX_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
    PRMCIO_CRX_COLOR_Reg += OFFSET_PRMCIO_CRX__COLOR_REG;

    PRMCIO_CR_COLOR_Reg = (volatile CHAR *)ppdev->PRMCIORegs;
    PRMCIO_CR_COLOR_Reg += OFFSET_PRMCIO_CR__COLOR_REG;

    //**************************************************************************
    // Init access to extended registers
    //**************************************************************************

    PRMVIO_SRX_Reg = (volatile UCHAR *)ppdev->PRMVIORegs;
    PRMVIO_SRX_Reg += OFFSET_PRMVIO_SRX_REG;

    PRMVIO_SR_LOCK_Reg = (volatile UCHAR *)ppdev->PRMVIORegs;
    PRMVIO_SR_LOCK_Reg += OFFSET_PRMVIO_SR_LOCK_REG;

    PRMVIO_MISC_READ_Reg = (volatile UCHAR *)ppdev->PRMVIORegs;
    PRMVIO_MISC_READ_Reg += OFFSET_PRMVIO_MISC_READ_REG;

    //**************************************************************************
    // Set new frame buffer address (21-bit address)
    //
    //      NV_CIO_CR_SA_HI_INDEX
    //
    //          Bits [7:0]  -> Bits [15:8] of 21-bit display buffer address
    //
    //      NV_CIO_CR_SA_LO_INDEX
    //
    //          Bits [7:0]  -> Bits [7:0] of 21-bit display buffer address
    //
    //      NV_CIO_CRE_RPC0_INDEX
    //
    //          Bits[4:0]   -> Bits [20:16] of 21-bit display buffer address
    //          Bits[7:5]   -> Bits [10:8] of the CRTC offset register
    //
    // ?? Why bother with 0x3f ??
    //**************************************************************************

    //**************************************************************************
    // Need to shift down memory offset by 2 to account for granularity
    //**************************************************************************

    MemoryOffset>>=2;

    *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CR_SA_LO_INDEX & 0x3f);
    *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)(MemoryOffset & 0xff);

    *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CR_SA_HI_INDEX & 0x3f);
    *PRMCIO_CR_COLOR_Reg  = (volatile UCHAR)((MemoryOffset >> 8) & 0xff);

    //**************************************************************************
    // Unlock CRTC extended regs
    //
    // NV_PRMVIO_SRX            = Sequencer Index Register (3c4)
    // NV_PRMVIO_SR_LOCK        = Data is written/ readm from register (3c5)
    // NV_PRMVIO_SR_LOCK_INDEX  = This indexed register (5) locks/unlocks
    //                            all extended registers.  When written with
    //                            value of 57, all extended registers are UNLOCKED.
    //                            Otherwise, all extended registers are LOCKED.
    //
    //                            When value = 0, extended register are in a locked state
    //                            When value = 1, extended registers are in an unlocked state
    //
    //**************************************************************************

    *PRMVIO_SRX_Reg = NV_PRMVIO_SR_LOCK_INDEX;
    lock = *PRMVIO_SR_LOCK_Reg;
    *PRMVIO_SR_LOCK_Reg = NV_SR_UNLOCK_VALUE;

    //**************************************************************************
    // Fix high address bit in extended CRTC reg
    //
    //      NV_CIO_CRE_RPC0_INDEX
    //
    //          Bits[4:0]   -> Bits [20:16] of 21-bit display buffer address
    //
    //          We preserve bits [7:5]   (i & 0xe0) and
    //          just modify the botom 5 bits (0x1f)
    //
    //**************************************************************************

    *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_RPC0_INDEX & 0x3f);
    i = *PRMCIO_CR_COLOR_Reg;       // Get current value

    *PRMCIO_CRX_COLOR_Reg = (NV_CIO_CRE_RPC0_INDEX & 0x3f);
    *PRMCIO_CR_COLOR_Reg = (i & 0xe0) | (volatile UCHAR)((MemoryOffset >> 16) & 0x1f) ;

    //**************************************************************************
    // Lockup CRTC extended regs
    //**************************************************************************

    *PRMVIO_SRX_Reg = NV_PRMVIO_SR_LOCK_INDEX;
    if (lock == 0)
        *PRMVIO_SR_LOCK_Reg = NV_SR_LOCK_VALUE;

    }

//******************************************************************************
//
// Function: NV3_DmaPushGo()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     chID - Pointer to channel ID for resource manager
//     tlbPtBase - Base of context DMA
//     busAddressSpace - PCI, AGP or other memory base for context DMA
//     getOffset - Offset from start of context DMA where push data starts
//     putOffset - Offset from start of context DMA where push data ends
//
// Return Value:
//
//     TRUE means it kicked off FALSE means it did not.
//
//******************************************************************************

#if 0
#undef WRITE_REGISTER_ULONG
#define WRITE_REGISTER_ULONG NV3_WRITE_REGISTER_ULONG
NV3_WRITE_REGISTER_ULONG(ULONG *addr, ULONG val)
{
ULONG tmp;
tmp = *addr;
*addr = val;
tmp = *addr;
_asm lock or tmp,0x5f5f5f5f
}
#endif


ULONG NV3_DmaPushGo(PDEV* ppdev, ULONG chID, ULONG tlbPtBase, ULONG busAddressSpace, ULONG getOffset, ULONG putOffset, ULONG hClient, ULONG hDevice)

    {
    volatile ULONG *CachesReg;
    volatile ULONG *Cache1Pull0Reg;
    volatile ULONG *Cache1Dma0Reg;
    volatile ULONG *Cache1Push0Reg;
    volatile ULONG *Cache1Push1Reg;
    volatile ULONG *Config0Reg;
    volatile ULONG *cache1DmaTlbPtBaseReg;
    volatile ULONG *cache1DmaTlbTagReg;
    volatile ULONG *cache1DmaTlbPteReg;
    volatile ULONG *cache1Dma3Reg;
    volatile ULONG *cache1Dma2Reg;
    volatile ULONG *cache1Dma1Reg;
    volatile ULONG *cache1Dma0Reg;
    volatile ULONG *cache1DmaStatusReg;
    ULONG status, numDmaBytes;
    extern  ULONG RmFifoFlushContext(PDEV *ppdev, ULONG chID, ULONG hDevice, ULONG hClient);

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "DmaPushGo: Entry"));
#endif

    if (!ppdev)
    {
#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "DmaPushGo: NULL pdev Exit"));
#endif
        return (ULONG)FALSE;
    }

    if (!(ppdev->pjMmBase))
    {
#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "DmaPushGo: NULL pdev->pjMmBase Exit"));
#endif
        return (ULONG)FALSE;
    }

    if (ppdev->bEnabled == FALSE)
    {
#ifdef DEBUG_MSG_CHANNEL_WAIT
        DISPDBG((2, "DmaPushGo: pdev NOT ENABLED Exit"));
#endif
        return (ULONG)FALSE;
    }

    numDmaBytes = (long)putOffset - (long)getOffset;
    if (numDmaBytes > 0)
        {
        ppdev->pfnAcquireOglMutex(ppdev);

        NV3_WaitForFifoAndEngineIdle(ppdev);

        CachesReg           = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHES);
        Cache1Pull0Reg      = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PULL0);
        Cache1Dma0Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA0_REG);
        Cache1Push0Reg      = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PUSH0_REG);
        Config0Reg          = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CONFIG_0);
        Cache1Push1Reg      = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PUSH1);
        cache1DmaTlbTagReg  = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_TLB_TAG);
        cache1DmaTlbPteReg  = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PTE);
        cache1DmaStatusReg  = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_STATUS);
        cache1Dma3Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA3);
        cache1Dma2Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA2);
        cache1Dma1Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA1);
        cache1Dma0Reg       = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA0);

        WRITE_REGISTER_ULONG(CachesReg, 0);
        WRITE_REGISTER_ULONG(Cache1Pull0Reg, 0);
        WRITE_REGISTER_ULONG(Cache1Push0Reg, 0);
        WRITE_REGISTER_ULONG(Cache1Dma0Reg, 0);

        if (READ_REGISTER_ULONG(Cache1Push1Reg) != chID)
            {
            status = RmFifoFlushContext(ppdev, chID, hClient, hDevice);
            if (status)
                {
                WRITE_REGISTER_ULONG(Cache1Pull0Reg, 1);
                WRITE_REGISTER_ULONG(Cache1Push0Reg, 1);
                WRITE_REGISTER_ULONG(CachesReg, 1);

                ppdev->pfnReleaseOglMutex(ppdev);

#ifdef DEBUG_MSG_CHANNEL_WAIT
                DISPDBG((2, "DmaPushGo: RmFifoFlushContext ERROR: Exit"));
#endif
                return (ULONG)FALSE;
                }
            }

        WRITE_REGISTER_ULONG(Cache1Push1Reg, chID);

        WRITE_REGISTER_ULONG(Config0Reg, (3 << 8) | (0x1F << 18));

        cache1DmaTlbPtBaseReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PT_BASE);
        WRITE_REGISTER_ULONG(cache1DmaTlbPtBaseReg, tlbPtBase);

        WRITE_REGISTER_ULONG(cache1DmaTlbTagReg, 0xFFFFFFFF);

        WRITE_REGISTER_ULONG(cache1DmaTlbPteReg, 1);

        WRITE_REGISTER_ULONG(cache1Dma3Reg, busAddressSpace);

        WRITE_REGISTER_ULONG(cache1DmaStatusReg, 0);

        WRITE_REGISTER_ULONG(cache1Dma2Reg, getOffset);

        WRITE_REGISTER_ULONG(cache1Dma1Reg, numDmaBytes);

        WRITE_REGISTER_ULONG(Cache1Pull0Reg, 1);
        WRITE_REGISTER_ULONG(Cache1Push0Reg, 1);
        WRITE_REGISTER_ULONG(CachesReg, 1);

        WRITE_REGISTER_ULONG(Cache1Dma0Reg, 1);

        ppdev->pfnReleaseOglMutex(ppdev);
        }

#ifdef DEBUG_MSG_CHANNEL_WAIT
    DISPDBG((2, "DmaPushGo: Exit"));
#endif

    return (ULONG)TRUE;
}

//******************************************************************************
//
// Function: NV3_RmFifoFlushContext
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     chID - Pointer to channel ID for resource manager
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG RmFifoFlushContext(PDEV *ppdev, ULONG chID, ULONG hClient, ULONG hDevice)
{
    DWORD   rmInfo[3];
    DWORD   *rmInfoPtr;

    rmInfo[0] = chID;
    rmInfo[1] = hClient;
    rmInfo[2] = hDevice;
    rmInfoPtr = &rmInfo[0];

// IA64 - NvDmaFlowControl needs to be modified so that the put/get can be
//        64 bit pointers (if we really want NV3 to work under IA64)

#ifndef _WIN64
    if (NvDmaFlowControl(ppdev->hDriver, (ULONG)0xFFFFFFFF, (ULONG)0, (ULONG)&rmInfoPtr, (ULONG)&rmInfoPtr))
        {
        DISPDBG((2, "RmFifoFlushContext FAILED!"));
        return(TRUE);
        }
#endif

    return(FALSE);
}

//******************************************************************************
//
// Function: NV3_AcquireOglMutex
//
// Routine Description:
//
//     Acquire the mutex that keeps OpenGL off the hardware.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_AcquireOglMutex(PDEV *ppdev)
{
    if (0 == ppdev->bReleaseOglMutex)
        {
        EngAcquireSemaphore(ppdev->csFifo);
        }
    ppdev->bReleaseOglMutex++;
}

//******************************************************************************
//
// Function: NV3_ReleaseOglMutex
//
// Routine Description:
//
//     Release the mutex that keeps OpenGL off the hardware.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_ReleaseOglMutex(PDEV *ppdev)
{
    if (1 == ppdev->bReleaseOglMutex)
        {
        EngReleaseSemaphore(ppdev->csFifo);
        }
    ppdev->bReleaseOglMutex--;
}
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3lines.c ===
//******************************************************************************
//
// Module Name: NV3LINES.C
// 
// Contains most of the required GDI line support.  Supports drawing
// lines in short 'strips' when clipping is complex or coordinates
// are too large to be drawn by the line hardware.
// 
// Copyright (c) 1990-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#include "oldnv332.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// NV:   Currently, we'll be using the NV1 line functions for NV3 since
//       they're compatible.  We can add the NV3 specific versions later...
//******************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3hw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV3HW.C
//
// Abstract:
//
//     Implements NV3 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"

#ifdef NV3
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"

#include "nv3a_ref.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// Useful defines (taken from NV.H).  Need to cleanup NV.H so we can include
// it without compiler failing, but don't have time right now....
//******************************************************************************

#define DEVICE_BASE(d)          (0?d)


#define OFFSET_PGRAPH_BOFFSET0_REG      (NV_PGRAPH_BOFFSET0 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BOFFSET1_REG      (NV_PGRAPH_BOFFSET1 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BOFFSET3_REG      (NV_PGRAPH_BOFFSET3 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BPITCH0_REG       (NV_PGRAPH_BPITCH0 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BPITCH1_REG       (NV_PGRAPH_BPITCH1 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_BPITCH3_REG       (NV_PGRAPH_BPITCH3 - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_FIFO_REG          (NV_PGRAPH_FIFO - DEVICE_BASE(NV_PGRAPH))
#define OFFSET_PGRAPH_DEBUG_3_REG       (NV_PGRAPH_DEBUG_3 - DEVICE_BASE(NV_PGRAPH))


#define OFFSET_PRMCIO_INP0_COLOR_REG                0x3da

#define OFFSET_PRMCIO_CRX__COLOR_REG                0x3d4
#define OFFSET_PRMCIO_CR__COLOR_REG                 0x3d5

#define OFFSET_PRMVIO_SRX_REG                       0x3c4
#define OFFSET_PRMVIO_SR_LOCK_REG                   0x3c5
#define OFFSET_PRMVIO_MISC_READ_REG                 0x3cc
#define OFFSET_PRAMDAC_CU_START_POS_REG             0x0

#define NV_SR_UNLOCK_VALUE                          0x00000057
#define NV_SR_LOCK_VALUE                            0x00000099

//******************************************************************************
// Forward Declarations
//******************************************************************************

VOID NV3_ClearZ(PDEV *ppdev ,ULONG x,ULONG y,ULONG Width, ULONG Height, ULONG zvalue);
VOID NV3_ClearSurface(PDEV *ppdev ,ULONG x,ULONG y,ULONG Width, ULONG Height, ULONG color);
VOID NV3_BlitSurface(PDEV *ppdev ,RECTL *Src, RECTL *Dst);

VOID NV3_SetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_SetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_OGLSetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_OGLSetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV3_SetZBufferBase(PDEV*   ppdev, ULONG MemoryOffset, LONG Stride);

VOID NV3_SetDisplayBase(PDEV*   ppdev, ULONG MemoryOffset);

VOID NV3_SetClipRect(PDEV *ppdev, RECTL *pClip);
VOID NV3_SetDitherMode(PDEV *ppdev, BOOL enableDither);
VOID NV3_SynchronizeHW(PDEV*   ppdev);
VOID NV3_SwapDisplaySurface(PDEV *ppdev, ULONG displaybase, ULONG renderbase, BOOL waitforVSync);

VOID NV3_VerifyFunctions(PDEV*   ppdev);
VOID NV3_RestoreState(PDEV*   ppdev, ULONG ZBufferOffset);
VOID NV3_VerifyTriangleWithZBuffer(PDEV *ppdev,ULONG,ULONG);


//******************************Public*Routine**********************************
//
// Function: NV3_ClearZ
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_ClearZ(PDEV *ppdev ,ULONG x,ULONG y,ULONG Width, ULONG Height, ULONG zvalue)

    {
    ULONG SavedDestOffset;
    ULONG SavedDestPitch;
    Nv3ChannelPio *nv  = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Fill Z buffer with specified value
    //**************************************************************************

    while (FreeCount < 3*4)
       FreeCount = NvGetFreeCount(nv, CLEARZ_SUBCHANNEL);
    FreeCount -= 3*4;

    nv->subchannel[CLEARZ_SUBCHANNEL].nv1RenderSolidRectangle.Color = zvalue;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].point = ((y << 16) | (x & 0xffff));
    nv->subchannel[CLEARZ_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].size = ((Height << 16) | (Width & 0xffff) );

    ppdev->NVFreeCount = FreeCount;

    }




//******************************Public*Routine**********************************
//
// Function: NV3_ClearSurface
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_ClearSurface(PDEV *ppdev ,ULONG x,ULONG y,ULONG Width, ULONG Height, ULONG color)

    {
    ULONG Pitch;
    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Fill Z buffer with specified value
    //**************************************************************************

    while (FreeCount < 5*4)
       FreeCount = NvGetFreeCount(nv, RECTANGLE_SUBCHANNEL);
    FreeCount -= 5*4;

    //**************************************************************************
    // We'll need to temporarily replace the ROP solid object,
    // because OpenGL currently uses this subchannel to contain
    // the D3DTriangle object with textures in System Memory.
    //**************************************************************************

    nv->subchannel[ROP_SOLID_SUBCHANNEL].SetObject             = DD_ROP5_SOLID; //MY_ROP_SOLID;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = 0xcc ;
    nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Color = color;
    nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].point = ((y << 16) | (x & 0xffff));
    nv->subchannel[RECTANGLE_SUBCHANNEL].nv1RenderSolidRectangle.Rectangle[0].size = ((Height << 16) | (Width & 0xffff) );

    //**************************************************************************
    // We need to restore the D3D Triangle (SYSMEM) object
    // because OpenGL expects this subchannel to contain
    // the D3DTriangle object with textures in System Memory.
    //**************************************************************************

    // nv->subchannel[D3DTRIANGLE_SYSMEM_SUBCHANNEL].SetObject     = MY_RENDER_D3D_TRIANGLE_SYSMEM;

    ppdev->NVFreeCount = FreeCount;

    }



//******************************Public*Routine**********************************
//
// Function: NV3_BlitSurface
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV3_BlitSurface(PDEV *ppdev ,RECTL *Src, RECTL *Dst)

    {
    ULONG   srcX,srcY;
    ULONG   dstX,dstY;
    ULONG   dstWidth,dstHeight;

    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Get source coordinates
    //**************************************************************************

    srcX = Src->left;
    srcY = Src->top;

    //**************************************************************************
    // Get destination coordinates
    //**************************************************************************

    dstX = Dst->left;
    dstY = Dst->top;

    //**************************************************************************
    // Get width and height
    //**************************************************************************

    dstWidth = Src->right - Src->left;
    dstHeight = Src->bottom - Src->top;

    //**************************************************************************
    // Wait for FIFO to be ready, then draw
    // We know that this is a straight SOLID FILL with no
    // pattern or source.  So just set ROP to SRCCOPY.
    //**************************************************************************

    while (FreeCount < 5*4)
       FreeCount = NvGetFreeCount(nv, BLIT_SUBCHANNEL);
    FreeCount -= 5*4;

    //**************************************************************************
    // We'll need to temporarily replace the ROP solid object,
    // because OpenGL currently uses this subchannel to contain
    // the D3DTriangle object with textures in System Memory.
    //**************************************************************************

    nv->subchannel[ROP_SOLID_SUBCHANNEL].SetObject             = DD_ROP5_SOLID; //MY_ROP_SOLID;


    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = NV_SRCCOPY ;

    nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointIn = ( (srcY << 16) | ((srcX) & 0xffff) );
    nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.ControlPointOut = ( (dstY << 16) | ((dstX) & 0xffff) );
    nv->subchannel[BLIT_SUBCHANNEL].nv1ImageBlit.Size = ( (dstHeight << 16) | ((dstWidth) & 0xffff) );

    //**************************************************************************
    // We need to restore the D3D Triangle (SYSMEM) object
    // because OpenGL expects this subchannel to contain
    // the D3DTriangle object with textures in System Memory.
    //**************************************************************************

    // nv->subchannel[D3DTRIANGLE_SYSMEM_SUBCHANNEL].SetObject     = MY_RENDER_D3D_TRIANGLE_SYSMEM;

    ppdev->NVFreeCount = FreeCount;
    }



//******************************************************************************
//
// Function: NV3_SetSourceBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_SetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    USHORT  FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Performance optimization, check if offset and pitch
    // are already up to date
    //**************************************************************************

    if ( (Offset == ppdev->CurrentSourceOffset)  &&  (Stride == (LONG)ppdev->CurrentSourcePitch))
        return;

    //**************************************************************************
    // Setup SRCIMAGE_IN_MEMORY object.
    //**************************************************************************
    while (FreeCount < 4*4)
        FreeCount = NvGetFreeCount(nv, SRCIMAGE_IN_MEMORY_SUBCHANNEL);
    FreeCount -= 4*4;


    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].SetObject =
         DD_SRC_IMAGE_IN_MEMORY;
    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].nv3ContextSurface1.SetImageOffset =
        Offset;
    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].nv3ContextSurface1.SetImagePitch =
        Stride;

    //**************************************************************************
    // Restore the original object in the subchannel
    //**************************************************************************
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].SetObject = DD_IMAGE_PATTERN;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentSourceOffset = Offset;
    ppdev->CurrentSourcePitch  = Stride;

    //**************************************************************************
    // NOTE: This function is currently used by the 2d display driver ONLY.
    //       So update the global free count for the DISPLAY driver
    //**************************************************************************
    ppdev->NVFreeCount = FreeCount;


    }


//******************************************************************************
//
// Function: NV3_SetDestBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_SetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Performance optimization, check if offset and pitch
    // are already up to date
    //**************************************************************************

    if ( (Offset == ppdev->CurrentDestOffset)  &&  (Stride == (LONG)ppdev->CurrentDestPitch))
        return;

    //**************************************************************************
    // Setup DSTIMAGE_IN_MEMORY object.
    //**************************************************************************
    while (FreeCount < 4*4)
        FreeCount = NvGetFreeCount(nv, DD_SPARE);
    FreeCount -= 4*4;

    if (ppdev->dDrawSpareSubchannelObject != DD_PRIMARY_IMAGE_IN_MEMORY)
        {
        nv->subchannel[DD_SPARE].SetObject = DD_PRIMARY_IMAGE_IN_MEMORY;
        ppdev->dDrawSpareSubchannelObject     = DD_PRIMARY_IMAGE_IN_MEMORY;
        }

    nv->subchannel[DD_SPARE].nv3ContextSurface0.SetImageOffset =
        Offset;
    nv->subchannel[DD_SPARE].nv3ContextSurface0.SetImagePitch =
        Stride;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentDestOffset = Offset;
    ppdev->CurrentDestPitch  = Stride;

    //**************************************************************************
    // NOTE: This function is currently used by the 2d display driver ONLY.
    //       So update the global free count for the DISPLAY driver
    //**************************************************************************
    ppdev->NVFreeCount = FreeCount;


    }



//******************************************************************************
//
// Function: NV3_OGLSetSourceBase()
//
// Routine Description:
//
//          This version of SetSourceBase requires the IMAGE_IN_MEMORY objects
//          to be present in the NV user channel.  This occurs whenever
//          OpenGL is initialized, which means that this function is NOT AVAILABLE
//          for the 2D Display driver to use (because all 8 subchannels stay
//          constant when the 2D Display driver is running)
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_OGLSetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    Nv3ChannelPio           *nv = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Set offset and stride
    //**************************************************************************

    while (FreeCount < 2*4)
       FreeCount = NvGetFreeCount(nv, SRCIMAGE_IN_MEMORY_SUBCHANNEL);
    FreeCount -= 2*4;

    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].nv3ContextSurface1.SetImagePitch = Stride;
    nv->subchannel[SRCIMAGE_IN_MEMORY_SUBCHANNEL].nv3ContextSurface1.SetImageOffset = Offset;

    ppdev->NVFreeCount = FreeCount;
    }


//******************************************************************************
//
// Function: NV3_OGLSetDestBase()
//
// Routine Description:
//
//          This version of SetDestBase requires the IMAGE_IN_MEMORY objects
//          to be present in the NV user channel.  This occurs whenever
//          OpenGL is initialized, which means that this function is NOT AVAILABLE
//          for the 2D Display driver to use (because all 8 subchannels stay
//          constant when the 2D Display driver is running)
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_OGLSetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio   *nv = (Nv3ChannelPio*) ppdev->pjMmBase;

    //**************************************************************************
    //Set offset and stride
    //**************************************************************************

    while (FreeCount < 2*4)
       FreeCount = NvGetFreeCount(nv, DD_SPARE);
    FreeCount -= 2*4;

    nv->subchannel[DD_SPARE].nv3ContextSurface0.SetImagePitch = Stride;
    nv->subchannel[DD_SPARE].nv3ContextSurface0.SetImageOffset = Offset;

    ppdev->NVFreeCount = FreeCount;
    }


//******************************************************************************
//
// Function: NV3_SetDisplayBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_SetDisplayBase(PDEV*   ppdev, ULONG Offset)

    {
    NV3_FlipBuffer(ppdev,Offset);

    //**************************************************************************
    // Save the updated offset
    //**************************************************************************

    ppdev->CurrentDisplayOffset = Offset;

    }


//******************************************************************************
//
// Function: NV3_SetZBufferBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV3_SetZBufferBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio   *nv = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Setup ZETA_BUFFER_IN_MEMORY object.
    //**************************************************************************
    while (FreeCount < 7*4)
        FreeCount = NvGetFreeCount(nv, CLEARZ_SUBCHANNEL);
    FreeCount -= 7*4;

    nv->subchannel[CLEARZ_SUBCHANNEL].SetObject = DD_ZETA_BUFFER;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv3ContextSurface3.SetImagePitch = Stride;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv3ContextSurface3.SetImageOffset = Offset;

    nv->subchannel[CLEARZ_SUBCHANNEL].SetObject = DD_ZBUFFER_IMAGE_IN_MEMORY;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv3ContextSurface3.SetImagePitch = Stride;
    nv->subchannel[CLEARZ_SUBCHANNEL].nv3ContextSurface3.SetImageOffset = Offset;
    nv->subchannel[CLEARZ_SUBCHANNEL].SetObject = MY_CLEARZ_RECTANGLE;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentZOffset = Offset;
    ppdev->CurrentZPitch  = Stride;
    ppdev->NVFreeCount = FreeCount;
    }




//******************************************************************************
//
//  Function:   NV3_SetClipRect
//
//  Routine Description:
//
//      Hardware-specific utility functions:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3_SetClipRect(PDEV *ppdev, RECTL *pClip)

    {
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio  *nv  = (Nv3ChannelPio *)ppdev->pjMmBase;

    while (FreeCount < 2*4)
       FreeCount = NvGetFreeCount(nv, CLIP_SUBCHANNEL);
    FreeCount -= 2*4;

    nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetPoint = (( (pClip->top) << 16) | pClip->left );
    nv->subchannel[CLIP_SUBCHANNEL].nv1ImageBlackRectangle.SetSize = (( (pClip->bottom - pClip->top)<<16) | (pClip->right - pClip->left));

    ppdev->NVClipResetFlag=1;       // Notify rest of driver that next guy needs
                                    // to restore it
    ppdev->NVFreeCount = FreeCount;
    }


//******************************************************************************
//
//  Function:   NV3_SetDitherMode
//
//  Routine Description:
//
//      Hardware-specific utility functions:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3_SetDitherMode(PDEV *ppdev, BOOL enableDither)

    {
    volatile DWORD *PGRAPH_DEBUG_3_Reg;
    volatile DWORD *PGRAPH_STATUS_Reg;
    volatile DWORD *PGRAPH_FIFO_Reg;
    ULONG value;

    //**************************************************************************
    // 1st make sure the engine is not busy
    //**************************************************************************

    NV3_SynchronizeHW(ppdev);

//    //**************************************************************************
//    // 2nd make sure the FIFO is disabled
//    // NV_PGRAPH_FIFO_ACCESS_DISABLED --> Clear bit 0
//    //**************************************************************************
//
//    PGRAPH_FIFO_Reg = (volatile DWORD *)ppdev->PGRAPHRegs;
//    PGRAPH_FIFO_Reg += OFFSET_PGRAPH_FIFO_REG/4;
//    *PGRAPH_FIFO_Reg &= 0xfffffffe;

    //**************************************************************************
    // Set the dither state
    //**************************************************************************

    PGRAPH_DEBUG_3_Reg = (volatile DWORD *)ppdev->PGRAPHRegs;
    PGRAPH_DEBUG_3_Reg += OFFSET_PGRAPH_DEBUG_3_REG/4;

    //**************************************************************************
    // WARNING: Do NOT 'or' values directly with HARDWARE registers because
    //          the compiler will optimize and do 'Byte' or's, which will
    //          cause the hardware to hang !!  Instead, read the hardware register
    //          first (read a dword), then modify the value, then output
    //          as a dword.
    //**************************************************************************

    value = *PGRAPH_DEBUG_3_Reg;                // Get current DWORD value

    if (enableDither)
        value |= (DWORD)0x00008000;             // Set Bit 15 to enable dithering
    else
        value &= (DWORD)0xffff7fff;             // Clear bit 15 to disable dithering

    *PGRAPH_DEBUG_3_Reg = value;                // Output new value


    //**************************************************************************
    // Save the updated dither state
    //**************************************************************************

    ppdev->CurrentDitherState = enableDither;

//    //**************************************************************************
//    // Re-enable the FIFO
//    //**************************************************************************
//
//    *PGRAPH_FIFO_Reg |= 0x00000001;


    }


//******************************************************************************
//
//  Function:   NV3_SynchronizeHW
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


void NV3_SynchronizeHW(PDEV*   ppdev)

    {

    //**************************************************************************
    // Loop until the engine is not busy
    //**************************************************************************

    while (NV3_GraphicsEngineBusy(ppdev))
        ;
    }



//******************************************************************************
//
//  Function:   NV3_SwapDisplaySurface
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3_SwapDisplaySurface(PDEV *ppdev, ULONG NewDisplayOffset, ULONG NewRenderOffset, BOOL waitforVSync)

    {
    if (waitforVSync)
        NV3_WaitWhileDisplayActive(ppdev);

    //**************************************************************************
    // Swap render(destination) and display base
    //**************************************************************************

    NV3_SetDisplayBase(ppdev,NewDisplayOffset);
    NV3_SetDestBase(ppdev,NewRenderOffset,ppdev->lDelta);


    }


//******************************************************************************
//
//  Function:   NV3_VerifyFunctions
//
//  Routine Description:
//
//      This functions tests the functionality of the above functions
//      It assumes the display driver is currently running at 640x480 16bpp
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3_VerifyFunctions(PDEV*   ppdev)

    {
    RECTL SrcRect,DstRect,ClipRect;

    //**************************************************************************
    // !! SET DISPLAY MODE to 640x480 at 16bpp to view this test properly !!!
    //**************************************************************************

    //**************************************************************************
    // Source = 0
    // Destination = at 3Mb
    // pitch = 640 at 16bpp
    //**************************************************************************

    NV3_SetDisplayBase(ppdev,0x300000);
    NV3_SetSourceBase(ppdev,0,640*2 );
    NV3_SetDestBase(ppdev,0x300000,640*2);

    ClipRect.left=0;                            // Restore clip rect to full screen
    ClipRect.top=0;
    ClipRect.right=ppdev->cxMemory;
    ClipRect.bottom=ppdev->cyMemory;
    NV3_SetClipRect(ppdev,&ClipRect);

    //**************************************************************************
    // Verify clear surface works (Currently only 15 bit, 16th bit is don't care)
    //**************************************************************************

    NV3_ClearSurface(ppdev,0,0,640,480,0xffff);
    NV3_ClearSurface(ppdev,0,0,320,240,0x7c00);     // red
    NV3_ClearSurface(ppdev,0,240,320,480,0x03e0);   // green
    NV3_ClearSurface(ppdev,320,0,640,240,0x001f);   // blue
    NV3_ClearSurface(ppdev,320,240,640,480,0x0000); // black

    //**************************************************************************
    // Specify blit from buffer 0 (top left quadrant) to buffer 1 (bottom right)
    //**************************************************************************

    SrcRect.left=0;
    SrcRect.top=0;
    SrcRect.right=320;
    SrcRect.bottom=240;

    DstRect.left=320;
    DstRect.top=240;
    DstRect.right=640;
    DstRect.bottom=480;

    //**************************************************************************
    // Verify source and destination offsets were set correctly
    // Blit top left quadrant of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Verifies a different source offset for blit (same pitch)
    // Blit bottom left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,640*2*240,640*2);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

//    //**************************************************************************
//    // Verify FIFO versions of SetSourceBase and SetDestBase
//    // These are ONLY available if OpenGL is running
//    //**************************************************************************
//
//    NV3_OGLSetSourceBase(ppdev,0, 640*2);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetSourceBase(ppdev,20, 640*2);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetSourceBase(ppdev,20, 640);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetSourceBase(ppdev,0, 640*2);
//    NV3_OGLSetDestBase(ppdev,0x300000, 640*2);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetDestBase(ppdev,0x300010, 640*2);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetDestBase(ppdev,0x300000, 640);
//    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//
//    NV3_OGLSetDestBase(ppdev,0x300000, 640*2);

    //**************************************************************************
    // Restore Source Offset to point to windows desktop
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that we can change the source pitch (Specify it twice as long
    // so that the destination blit should be 'scrunched')
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2 * 2);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that we can change the source pitch (Specify it half as long
    // so that the destination blit should show an 'interleaved' image)
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that we can change the destination pitch (Specify it half as long
    // so that the destination blit should be 'scrunched')
    // Blit top left of windows desktop to bottom right of buffer 1
    // NOTE: Since we decreased the pitch by half, the blit will occur higher
    //       up in the visible screen, instead of where it would appear
    //       if the pitch had not changed.
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that we can blit from a source to a destination pitch and back
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640);

    DstRect.left=0;
    DstRect.top=0;
    DstRect.right=320;
    DstRect.bottom=240;

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);

    NV3_SetSourceBase(ppdev,0x300000, 640);
    NV3_SetDestBase(ppdev,0x300000, 640*2);

    DstRect.left=320;
    DstRect.top=240;
    DstRect.right=640;
    DstRect.bottom=480;

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);

    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check an unusual pitch value . (Specify default_pitch + 16 bytes)
    // The destination blit should be 'skewed'
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640*2 + 16);
    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that clipping rectangle is working
    // Blit clipped portion of desktop to buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640*2);

    ClipRect.left=100;
    ClipRect.top=50;
    ClipRect.right=640-100;
    ClipRect.bottom=480-50;
    NV3_SetClipRect(ppdev,&ClipRect);

    SrcRect.left=0;
    SrcRect.top=0;
    SrcRect.right=640;
    SrcRect.bottom=480;

    DstRect.left=0;
    DstRect.top=0;
    DstRect.right=640;
    DstRect.bottom=480;

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    //**************************************************************************
    // Check that clipping rectangle is affected by the destination offset and pitch
    // Blit top left of windows desktop to bottom right of buffer 1
    //**************************************************************************

    NV3_SetSourceBase(ppdev,0, 640*2);
    NV3_SetDestBase(ppdev,0x300000, 640*2);

    ClipRect.left=320;                          // Blit entire quadrant
    ClipRect.top=240;
    ClipRect.right=640;
    ClipRect.bottom=480;
    NV3_SetClipRect(ppdev,&ClipRect);

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    ClipRect.left=320;                          // Only top left of quadrant should appear
    ClipRect.top=240;
    ClipRect.right=320 + 160;
    ClipRect.bottom=240 + 120;
    NV3_SetClipRect(ppdev,&ClipRect);

    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);

    NV3_SetDestBase(ppdev,0x300000, 640);       // Change the destination pitch

    ClipRect.left=320;
    ClipRect.top=240;
    ClipRect.right=320+160;
    ClipRect.bottom=240+120;
    NV3_SetClipRect(ppdev,&ClipRect);


    NV3_BlitSurface(ppdev,&SrcRect,&DstRect);
    NV3_ClearSurface(ppdev,0,0,640,480,0x0);


//    //**************************************************************************
//    // Verify Z Buffer functions (using the D3D Triangle)
//    // (Z buffer should appear halfway down the screen (y=240)
//    //**************************************************************************
//
//    NV3_SetSourceBase(ppdev,0, 640*2);
//    NV3_SetDestBase(ppdev,0x300000, 640*2);
//    NV3_SetZBufferBase(ppdev,0x300000 + 640*2 *240, 640*2);
//
//    ClipRect.left=50;                           // Test specific clipping rectangle
//    ClipRect.top=50;
//    ClipRect.right=200;
//    ClipRect.bottom=200;
//    NV3_SetClipRect(ppdev,&ClipRect);
//
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    ClipRect.left=0;                            // Restore clip rect to full screen
//    ClipRect.top=0;
//    ClipRect.right=640;
//    ClipRect.bottom=480;
//    NV3_SetClipRect(ppdev,&ClipRect);
//
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify dithering
//    //**************************************************************************
//
//    NV3_SetDitherMode(ppdev,FALSE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,TRUE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,FALSE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,TRUE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify Clear Z function
//    //**************************************************************************
//
//    NV3_ClearZ(ppdev,0,0,320,10, 0);            // Just clear a portion of Z buffer
//    NV3_ClearZ(ppdev,0,0,320,10,0xffff );       // Just clear a portion of Z buffer
//    NV3_ClearZ(ppdev,320,0,320,10,0x0000 );     // Just clear a portion of Z buffer
//    NV3_ClearZ(ppdev,320,0,320,10,0xffff );     // Just clear a portion of Z buffer
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify dithering
//    //**************************************************************************
//
//    NV3_SetDitherMode(ppdev,FALSE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,TRUE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify Swap buffer function
//    // 1st setup display to be front buffer at offset = 0, and
//    // destination to be 'back' buffer at offset = 0x100000
//    //**************************************************************************
//
//    NV3_SwapDisplaySurface(ppdev,0x00000000,0x00300000, FALSE);
//    NV3_SwapDisplaySurface(ppdev,0x00300000,0x00000000, TRUE);
//
//    //**************************************************************************
//    // Verify Synchronize function
//    //**************************************************************************
//
//    NV3_SynchronizeHW(ppdev);
//
//    //**************************************************************************
//    // Verify dithering
//    //**************************************************************************
//
//    NV3_SetDestBase(ppdev,0x300000, 640*2);
//
//    NV3_SetDitherMode(ppdev,FALSE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_SetDitherMode(ppdev,TRUE);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    //**************************************************************************
//    // Verify D3D triangle Zeta values are stored according to the specified destination
//    //**************************************************************************
//
//    ClipRect.left=0;                            // Restore clip rect to full screen
//    ClipRect.top=0;
//    ClipRect.right=ppdev->cxMemory;
//    ClipRect.bottom=ppdev->cyMemory;
//    NV3_SetClipRect(ppdev,&ClipRect);
//
//    NV3_SetDisplayBase(ppdev,0x300000);
//    NV3_SetSourceBase(ppdev,0,640*2 );
//    NV3_SetDestBase(ppdev,0x300000,640*2);
//    NV3_SetZBufferBase(ppdev,0x300000 + 640*2 *240, 640*2);
//
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
//    NV3_ClearSurface(ppdev,0,0,640,480,0x0);
//    NV3_ClearZ(ppdev,0,0,640,480,0x0000 );      // Clear entire Z Buffer
//    NV3_SetZBufferBase(ppdev,0x300000 + 640*2 *240, 640);
//    NV3_VerifyTriangleWithZBuffer(ppdev);       // Draw a solid D3D triangle
//
    //**************************************************************************
    // Restore 640x480 16bpp display screen
    //**************************************************************************

    NV3_SetDisplayBase(ppdev,0x0);
    NV3_SetSourceBase(ppdev,0,640*2);
    NV3_SetDestBase(ppdev,0,640*2);

    ClipRect.left=0;                            // Restore clip rect to full screen
    ClipRect.top=0;
    ClipRect.right=ppdev->cxMemory;
    ClipRect.bottom=ppdev->cyMemory;
    NV3_SetClipRect(ppdev,&ClipRect);


    }





//******************************************************************************
//
//  Function:   NV3_RestoreState
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3_RestoreState(PDEV*   ppdev, ULONG ZBufferOffset)

    {
    RECTL ClipRect;

    //**************************************************************************
    // Restore display , source, destination, and Z Buffer bases
    //**************************************************************************

    NV3_SetDisplayBase(ppdev,0);
    NV3_SetSourceBase(ppdev,0,640*2);
    NV3_SetDestBase(ppdev,0,640*2);
    NV3_SetZBufferBase(ppdev, ZBufferOffset, 640*2);

    ClipRect.left=0;                            // Restore clip rect to full screen
    ClipRect.top=0;
    ClipRect.right=ppdev->cxMemory;
    ClipRect.bottom=ppdev->cyMemory;
    NV3_SetClipRect(ppdev,&ClipRect);

    }




//******************************************************************************
//
//  Function:   NV3_VerifyTriangleWithZBuffer
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3_VerifyTriangleWithZBuffer(PDEV *ppdev, ULONG TextureOffset, ULONG D3DSubChannel)

    {
    ULONG TextureFormat;
    ULONG ControlOut;
    ULONG red,green,blue,alpha;
    USHORT FreeCount = ppdev->NVFreeCount;
    Nv3ChannelPio *nv = (Nv3ChannelPio *) ppdev->pjMmBase;

    //**************************************************************************
    // Specify texture offset
    //**************************************************************************

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;


    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.TextureOffset = TextureOffset;

    //**************************************************************************
    // Texture format
    //      Color Mask                              Specify 0 for now
    //      Color Key Enable/Disable                Specify DISABLED for now
    //      Actual color format                     Specify X1R5G5B5 for now
    //      Min size of mip map levels (bits   .    Select 4x4 for now
    //      Max size of mip map levels (bits   .    Select 4x4 for now
    //**************************************************************************

    TextureFormat = NV_D3D0_TEXTURE_FORMAT_COLOR_KEY_DISABLED    |
                    NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5 |
                    NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_4X4          |
                    NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_4X4          ;

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.TextureFormat = TextureFormat;

    //**************************************************************************
    // Specify FILTER consists of several components OR'ed together:
    //
    //      Filter_Spread_X
    //      Filter_Spread_Y
    //      Filter_MipMap
    //      Filter_Turbo
    //
    //**************************************************************************

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.TextureFilter = 0x00000000;

    //**************************************************************************
    // Specify FOG COLOR, in X8R8G8B8 format
    //**************************************************************************

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.FogColor = 0x00000000;

    //**************************************************************************
    // Specify CONTROL OUT OPTIONS
    //
    // See NV3 reference for description of this register.
    //
    //  INTERPOLATOR    (filter from discrete image to continuous image)
    //  WRAP_U          (cylindrical, wrap, mirror, clamp)
    //  WRAP_V          (cylindrical, wrap, mirror, clamp)
    //  COLOR_FORMAT    (X8R8G8B8 or A8R8G8B8)
    //  CULLING         (None, Clockwise, Counterclockwise);
    //  ZBUFFER         (SCREEN using controlpoint[].z values, or LINEAR using 1/m
    //  ZETA_COMPARE    (conditional types = LT,EQ,LE,GT,NE,GE,TRUE)
    //  ZETA_WRITE      (NEVER,ALPHA,ZETA,ALPHA_ZETA, ALWAYS)
    //  COLOR_WRITE     (NEVER,ALPHA,ALPHA_ZETA)
    //  ROP             (BLEND_AND or ADD_WITH_SATURATION)
    //
    //**************************************************************************

    //**************************************************************************
    // Send the ControlOut value to hardware
    //**************************************************************************

    ControlOut                  = NV_D3D0_CONTROL0_INTERPOLATOR_ZOH         ;
    ControlOut                 |= NV_D3D0_CONTROL0_WRAP_U_WRAP              ;
    ControlOut                 |= NV_D3D0_CONTROL0_WRAP_V_WRAP              ;
    ControlOut                 |= NV_D3D0_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8 ;
    ControlOut                 |= NV_D3D0_CONTROL0_CULLING_NONE             ;
    ControlOut                 |= NV_D3D0_CONTROL0_ZETA_BUFFER_SCREEN       ;
    ControlOut                 |= NV_D3D0_CONTROL0_ZETA_COMPARE_TRUE        ;
    ControlOut                 |= NV_D3D0_CONTROL0_ZETA_WRITE_ALPHA_ZETA    ;
    ControlOut                 |= NV_D3D0_CONTROL0_COLOR_WRITE_ALPHA_ZETA   ;
    ControlOut                 |= NV_D3D0_CONTROL0_ROP_BLEND_AND            ;

    while (FreeCount < 1*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Control0 = ControlOut;

    //**************************************************************************
    // Vertex 1
    //**************************************************************************

    red     = 0xff;
    green   = 0x00;
    blue    = 0x00;
    alpha   = 0xff;

    alpha   <<=24;
    red     <<=16;
    green   <<=8 ;
    blue    <<=0 ;

    while (FreeCount < 8*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 8*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].specular = 0x00000000;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].color    = (alpha | red | green | blue);
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].sx       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].sy       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].sz       = (float)0.9999;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].rhw      = (float)0.1127;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].tu       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[0].tv       = (float)0.0;


    //**************************************************************************
    // Vertex 2
    //**************************************************************************

    red     = 0x00;
    green   = 0xff;
    blue    = 0x00;
    alpha   = 0xff;

    alpha   <<=24;
    red     <<=16;
    green   <<=8 ;
    blue    <<=0 ;

    while (FreeCount < 8*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 8*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].specular = 0x00000001;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].color    = (alpha | red | green | blue);
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].sx       = (float)320.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].sy       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].sz       = (float)0.9999;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].rhw      = (float)0.1127;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].tu       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[1].tv       = (float)0.0;


    //**************************************************************************
    // Vertex 3
    //**************************************************************************

    red     = 0x00;
    green   = 0x00;
    blue    = 0xff;
    alpha   = 0xff;

    alpha   <<=24;
    red     <<=16;
    green   <<=8 ;
    blue    <<=0 ;

    while (FreeCount < 8*4)
       FreeCount = nv->subchannel[D3DSubChannel].control.Free;
    FreeCount -= 8*4;

    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].specular = 0x00000102;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].color    = (alpha | red | green | blue);
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].sx       = (float)320.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].sy       = (float)240.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].sz       = (float)0.9999;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].rhw      = (float)0.1127;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].tu       = (float)0.0;
    nv->subchannel[D3DSubChannel].nv3Dx3TexturedTriangle.Tlvertex[2].tv       = (float)0.0;

    ppdev->NVFreeCount = FreeCount;

    }
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3pal.c ===
//******************************Module*Header***********************************
// 
// Module Name: NV3PAL.C
// 
// Copyright (c) 1992-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#ifdef NV3
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// Extern declarations
//******************************************************************************

//******************************************************************************
//
//  Function:   NV3SetPalette
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV3SetPalette(
PDEV *ppdev,
ULONG start, 
ULONG length)

    {
    Nv3ChannelPio *nv = (Nv3ChannelPio *) ppdev->pjMmBase;
    USHORT FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Setup the palette via PIO
    //**************************************************************************

    while (FreeCount < 4*4)
        FreeCount = NvGetFreeCount(nv, 0);
    FreeCount -= 4*4;

    nv->subchannel[0].SetObject = DD_COLORMAP;
    nv->subchannel[0].nvVideoColorMap.ColormapDirtyStart = start;
    nv->subchannel[0].nvVideoColorMap.ColormapDirtyLength = length;
    nv->subchannel[0].SetObject = DD_IMAGE_FROM_CPU;

    //**************************************************************************
    // Update the cached free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;
    }

#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4bltc.c ===
//******************************Module*Header***********************************
//
// Module Name: NV4BLTC.C
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"

//******************************************************************************
// NV4 vs. NV3
//
// This file is almost exactly the same as the NV3 version.
// The difference, is that since we'll be using 565 bitmap format on NV4, 
// we need to use NV4 specific objects (The NV4 RECTANGLE_TEXT object has 
// changed significantly from the NV3 RECTANGLE_TEXT object... the method
// offsets are *NOT* the same as NV3).
//
// (i.e. we can only use the original NV3 functions on NV4 when running in 555 format)
//******************************************************************************

#define NV_MTMF_FORMAT_INPUT_INC_1     0x00000001
#define NV_MTMF_FORMAT_OUTPUT_INC_1    0x00000100

//******************************************************************************
// Externs
//******************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

#ifdef _X86_

//******************************************************************************
// X86 Assembly routine to xfer host bitmap->screen
//******************************************************************************

void NV4_DmaPush_Transfer_MemToScreen_Data(PDEV *, LONG, ULONG, ULONG *,LONG);

#endif

#if 1 // Enable xlate caching
//******************************************************************************
// Replacing all (BYTE)XLATEOBJ_iXlate(pxlo,DWORD) with a macro that is caching
// the last value.
// The call to XLATEOBJ_iXlate is expensive. Until now it was done per pixel. 
// This caused our NV4ScreenToMem32to8bppBlt to be slower than a return FALSE 
// and punt to Eng. 
// Now we cache the last xlated value and index and only xlate if necessary. 
// This gives us 25 % speedup in SolidWorks2000 I/O bench (1280TC) and some 
// points in WinBench99 (NT4 1024TC).
//
// Because the entire Xfer stuff is a macro it is very hard to debug or modify 
// code. so I choose a macro, too :-(
// Everywhere NV_XLATEOBJ_IXLATE is used the NV_XLATE_INIT macro must be added 
// to define and intialize the cache variables:
//******************************************************************************
//
    // Macro to initialize cached xlate values
    #define NV_XLATE_INIT                                                \
        DWORD cachedXlIndex = 0;                                         \
        BYTE  jXlCached     = (BYTE)XLATEOBJ_iXlate(pxlo,cachedXlIndex);


    #if DBG
        // In a debug environment we count the misses and hits to the cached value.
        DWORD cacheXlHits = 0; // counter for xlated cache hits
        DWORD cacheXlMiss = 0; // counter for xlated cache misses

        #define NV_XLATEOBJ_IXLATE(pxlo,cIndex) ( ((cIndex) == cachedXlIndex) ?                                       \
            ( cacheXlHits++, jXlCached ) :                                                                            \
            ( cacheXlMiss++, (cachedXlIndex = (cIndex)), (jXlCached = (BYTE)XLATEOBJ_iXlate((pxlo),cachedXlIndex))) )
    #else
        // free build
        // if (index==prev index) {take cached xlated value} else {remember this index, calculate and remember xlated value}
        #define NV_XLATEOBJ_IXLATE(pxlo,cIndex) ( ((cIndex) == cachedXlIndex) ?                                       \
            (                jXlCached ) :                                                                            \
            (                (cachedXlIndex = (cIndex)), (jXlCached = (BYTE)XLATEOBJ_iXlate((pxlo),cachedXlIndex))) )
    #endif

#else
    // original 1:1 xlate without caching
    #define NV_XLATE_INIT
    #define NV_XLATEOBJ_IXLATE(pxlo,cIndex) XLATEOBJ_iXlate(pxlo,cIndex)
#endif

//******************************************************************************
//
//  Function:   NV4DmaPushFillSolid
//
//  Routine Description:
//
//      Fills a list of rectangles with a solid colour.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushFillSolid(       // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used

    {
    LONG  xDst;
    LONG  yDst;
    ULONG width,height;
    ULONG Rop3;
    ULONG temp;
    ULONG AlphaWithColor;

    DECLARE_DMA_FIFO;
    
    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;
    
    //**************************************************************************
    // Equation to convert to Rop4 to Rop3 (We don't get patterns here)
    //
    // Rop4:
    //                 Truth table for a Rop 3.
    //                 ------------------------
    //                                    R
    //                                    O
    //                        (SD)        P
    //                  11  10  01  00    3
    //                  --------------
    //          (P) 1  |         x   x    High nibble    Example Value = 0xf0
    //              0  | x   x            Low nibble
    //
    //
    // After rop4 >> 2:
    //
    //                 Truth table for a Rop 3.
    //                 ------------------------
    //                                    R
    //                                    O
    //                        (SD)        P
    //                  11  10  01  00    3
    //                  --------------
    //          (P) 1  |                  High nibble    Value = 0x3c
    //              0  | x   x   x   x    Low nibble
    //
    //
    // After (rop4 >> 2 ) & 0xf:
    //
    //                                                   Value = 0x0c
    //
    // Final Rop3 equivalent value of a Rop2 value = 0xcc
    //
    //         This value does not depend on the Pattern
    //**************************************************************************

    AlphaWithColor = ((ppdev->AlphaEnableValue) | rbc.iSolidColor);
    temp = ((rop4 >> 2) & 0xf);         // Get bottom nibble
    Rop3 = temp | (temp << 4);        // Duplicate in top nibble

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(5+(4*c))));  

    //**************************************************************************
    // Set Rop
    //**************************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**********************************************************************
    // Since the sub-channel is same in the while loop, the color is set 
    // out of the while loop.
    //**********************************************************************
    NV_DMAPUSH_START (1, RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_A)
    NV_DMA_FIFO = AlphaWithColor;
    
    while(TRUE)
        {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of pixels drawn.
        // So, adjusting by 1 pixel is NOT necessary when calculating width and height.
        //**********************************************************************

        xDst = prcl->left;
        yDst = prcl->top;
        width = prcl->right - xDst;
        height = prcl->bottom - yDst;

        NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL, NV04A_UNCLIPPED_RECTANGLE(0))
        NV_DMA_FIFO = (xDst << 16) | (yDst & 0xffff);
        NV_DMA_FIFO = (width << (16) | (height & 0xffff));
        
        if (--c == 0)
            {
            //******************************************************************
            // Update global push buffer count
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;

            //******************************************************************
            // Send data on thru to the DMA push buffer
            //******************************************************************

            NV4_DmaPushSend(ppdev);

            return;
            }

        prcl++;
        }

    }


//******************************************************************************
//
//  Function:   NV4DmaPushCopyBlit
//
//  Routine Description:
//
//      Does a screen-to-screen blt of a list of rectangles.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushCopyBlt(    // Type FNCOPY
    PDEV*   ppdev,
    LONG    c,          // Can't be zero
    RECTL*  prcl,       // Array of relative coordinates destination rectangles
    ULONG   rop4,       // rop4
    POINTL* pptlSrc,    // Original unclipped source point
    RECTL*  prclDst,    // Original unclipped destination rectangle
    BLENDOBJ *pBlendObj)
    {
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source

    ULONG   width,height;
    ULONG   xsrc,ysrc;
    ULONG   xdst,ydst;
    ULONG   Rop3;
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),"Expect only a rop2");
    ASSERTDD((pBlendObj==NULL), "Must use NV4DmaPushCopyAlphaBlt for blended CopyBlt");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************
    NV_DMAPUSH_CHECKFREE((ULONG)(5 + (4*c)));

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        
        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Set Rop
    //**************************************************************************

    Rop3 = (rop4 & 0xff);

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

    //**************************************************************************
    // Do a copy blit for each clip rectangle
    //**************************************************************************

    do  {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        xdst = prcl->left;
        ydst = prcl->top;

        width = prcl->right - xdst;
        height = prcl->bottom - ydst;

        dx = xdst - prclDst->left;      // prcl is always within prcldst???
        dy = ydst - prclDst->top;       // prcl is always within prcldst???

        xsrc = pptlSrc->x + dx;
        ysrc = pptlSrc->y + dy;

        //**********************************************************************
        // Wait for FIFO to be ready, then draw

        //**********************************************************************
        // Set methods for image_blit:
        //    NV05F_CONTROL_POINT_IN 
        //    NV05F_CONTROL_POINT_OUT
        //    NV05F_SIZE             
        //**********************************************************************

        NV_DMAPUSH_START(3, BLIT_SUBCHANNEL, NV05F_CONTROL_POINT_IN );
        NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );
        NV_DMA_FIFO = ( (ydst << 16) | (xdst & 0xffff) );
        NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));

        prcl++;

    } while (--c != 0);

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    }




//******************************************************************************
//
//  Function:   NV4DmaScreenToScreenWithPatBlt
//
//  Routine Description:
//
//      Does a screen-to-screen blt of a list of rectangles, supporting brushes
//      and all rops.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4ScreenToScreenWithPatBlt(
    
    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    BRUSHOBJ*   pbo,                // Brush object
    POINTL*     pptlBrush,          // Brush start coordinate in the pattern bits.
    ROP4        rop4)               // Op that describes the blit (must be 1 byte max)

{
    ULONG       rop3;
    RBRUSH*     prb;
    
    ULONG       xsrc,ysrc;

    ULONG       Color0;
    ULONG       Color1;
    ULONG       width;
    ULONG       height;
    LONG        xShift;
    LONG        yShift;
    LONG        BytesPerSrcScan;
    BYTE*       SrcBits;
    BYTE*       DstBits;
    ULONG*      ScanPtr;
    ULONG*      NextScan;
    LONG        ScanInc;
    LONG        cjLeft;
    LONG        cjRight;
    ULONG       i, ix,iy;


    DECLARE_DMA_FIFO;

    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4DmaScreenToScreenWithPatBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL destination rectangles supplied !" );
        
    ASSERTDD( pptlSrc != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL destination rectangle supplied !" );
    
    ASSERTDD( pbo != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL brush object supplied !" );
    
    ASSERTDD( pptlBrush != NULL,
              "NV4DmaScreenToScreenWithPatBlt: NULL upper left point of brush supplied !" );

    ASSERTDD( ( (rop4 & 0xff00) >> 8 ) == (rop4 & 0xff),
              "NV4DmaScreenToScreenWithPatBlt: The rop has more than one byte set");


    //**************************************************************************
    // Init the local dma variables with the ones in ppdev.
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Setup variables
    //**************************************************************************
    
    rop3 = (ULONG)(rop4 & 0xff);            /* Get ROP3 (1 byte only)        */
    prb  = (RBRUSH*) pbo->pvRbrush;         /* Get pointer to realized brush */
    
    //**************************************************************************
    // Check if there is enough free space in the push buffer. We check ONE
    // time because this seems to be a great deal of overhead.  Furthermore,
    // we check for the largest possible amount we will use in the rest of the
    // function...
    //**************************************************************************
    
    NV_DMAPUSH_CHECKFREE((  (ULONG)(  3+8+65+ (c<<2)  )   ));  
    
    
    /* Max between:                                                            */
    /*                                                                         */
    /*  Solid case:    3+12+4*c                                                */
    /*                                                                         */
    /*                  and                                                    */
    /*                                                                         */
    /*  NonSolid case: 3+12+4*c                                                */
    /*                                                                         */
    /*                                                                         */
    /*                  and                                                    */
    /*                                                                         */
    /*                 3+8+65+4*c                                              */
    /*                                                                         */
    
    
    //**************************************************************************
    // Restore clip rect if there is need to...
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
    {
        //NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag = 0;       // Clear the "clipper is not to max"
                                          // flag
    }

    
    if(prb != NULL)  goto NV4StoSPat_NonSolid;

    //**************************************************************************
    //***[ BEGIN "Brush is Solid" ]*********************************************
    //**************************************************************************
       
    //**************************************************************************
    // 
    // Set the pattern object to all the same color (I'm not sure this is the
    // best way to do it, there might be another way to setup the NV4_IMAGE_BLIT
    // object so that it understands that the brush is solid, and that we only
    // need to give it the solid color...)
    // 
    // We are going to write a monochrome pattern to the pattern object, but all
    // "111..." so that we only have to set the foreground color.  This is better
    // than realizing a color pattern because it will take less data output to
    // the hardware
    //**************************************************************************


    // Determine the color format of our frame buffer and set the format of the
    // pattern object accordingly

    switch (ppdev->iBitmapFormat)
    {
        case BMF_32BPP:
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
           break;
        case BMF_16BPP:
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
           break;
        default:
        case BMF_8BPP:
           // Must be set to a legal value but hardware ignores it otherwise 
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
           break;
    }            
        
    //**********************************************************************
    // Set the following methods for context_pattern
    //    NV044_SET_MONOCHROME_FORMAT 
    //    NV044_SET_MONOCHROME_SHAPE  
    //    NV044_SET_PATTERN_SELECT    
    //    NV044_SET_MONOCHROME_COLOR0  
    //    NV044_SET_MONOCHROME_COLOR1,  
    //    NV044_SET_MONOCHROME_PATTERN0
    //    NV044_SET_MONOCHROME_PATTERN1
    //**********************************************************************

    NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
    NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
    NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
    NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
    NV_DMA_FIFO = 0;                                             // Not used (color0)
    NV_DMA_FIFO = (pbo->iSolidColor | ppdev->AlphaEnableValue);  // Color to use when bit is "1" 

    NV_DMA_FIFO = (ULONG) 0xFFFFFFFF;                  // 8x8 = 64 bit pattern
    NV_DMA_FIFO = (ULONG) 0xFFFFFFFF;                  // " "

    
    // Set the rop
    
    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);   

    
    /***********************************************************************/
    /* Blit all rectangle regions                                          */
    /***********************************************************************/

    do 
    {
        //******************************************************************
        // Get width and height of the destination rectangle
        //******************************************************************

        width = parcl->right - parcl->left;
        height= parcl->bottom - parcl->top;


        xsrc = pptlSrc->x + (parcl->left - prclDst->left);
        ysrc = pptlSrc->y + (parcl->top - prclDst->top);


        //******************************************************************
        // Set methods for image_blit:
        //    NV05F_CONTROL_POINT_IN 
        //    NV05F_CONTROL_POINT_OUT
        //    NV05F_SIZE             
        //******************************************************************

        NV_DMAPUSH_START(3, BLIT_SUBCHANNEL, NV05F_CONTROL_POINT_IN );
        NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );
        NV_DMA_FIFO = ( (parcl->top << 16) | (parcl->left & 0xffff) );
        NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));


        parcl++;

    } while (--c != 0);
    
    
    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    
    return;  

    
    //**************************************************************************
    //***[ END OF "Brush is Solid" ]********************************************
    //**************************************************************************

NV4StoSPat_NonSolid:
    

    //**************************************************************************
    // 
    // Set the pattern object with the data of our brush
    // (if we end here, the brush pattern is required, the brush is nonsolid)
    //
    //**************************************************************************

    if (prb->fl & RBRUSH_2COLOR)
    {
        /* Brush is monochrome                                                */
        /*                                                                    */
        /* Note: this code is copy pasted from fillpatfast for brush pattern  */
        /*       setup. if we see it's worth it, we might try to find a way   */
        /*       to optimize the alignement procedure (this seems it could    */
        /*       be done) or better yet, use brush caching)                   */
        

        //**********************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // The brush is aligned in absolute coordinates, so we have to add
        // in the surface offset:
        //
        // NV: We DON'T need to manually account for the position of the pattern
        //     on the screen, like we do for the Memory to Screen blits for
        //     multi-color patterns (below).
        //**********************************************************************

        //**********************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //**********************************************************************

        xShift = pptlBrush->x & 7;
        yShift = pptlBrush->y & 7;

        //**********************************************************************
        // Shift Mono pattern bits appropriately (vertically)
        // First we'll align it properly by copying it to a temporary buffer:
        //**********************************************************************

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift;                              // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //**********************************************************************
        // Now copy the pattern , row by row (byte by byte) and
        // align it vertically and horizontally at the same time
        //**********************************************************************

        do  
        {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;

        } while (--i != 0);

        //**********************************************************************
        // Now copy the 'top' part
        //**********************************************************************

        DstBits -=8;                    // Move back to beginning of destination

        for (; yShift != 0; yShift--)
        {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;
        }

        //**********************************************************************
        // Init foreground and background color
        //**********************************************************************

        Color1 = prb->ulForeColor | (ppdev->AlphaEnableValue); // Background color
        Color0 = prb->ulBackColor | (ppdev->AlphaEnableValue); // Foreground color

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        //NV_DMAPUSH_CHECKFREE(((ULONG)((c<<2)+12)));  

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        // Determine the color format
        switch (ppdev->iBitmapFormat)
        {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
        }            

        //**********************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //    NV044_SET_MONOCHROME_COLOR0  
        //    NV044_SET_MONOCHROME_COLOR,  
        //    NV044_SET_MONOCHROME_PATTERN0
        //    NV044_SET_MONOCHROME_PATTERN1
        //**********************************************************************

        NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
        NV_DMA_FIFO = Color0; 
        NV_DMA_FIFO = Color1;
        NV_DMA_FIFO = ppdev->AlignedBrush[0];
        NV_DMA_FIFO = ppdev->AlignedBrush[1];
        
                
        /***********************************************************************/
        /* Blit all rectangle regions                                          */
        /***********************************************************************/
        
        do 
        {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = parcl->right - parcl->left;
            height= parcl->bottom - parcl->top;

            
            xsrc = pptlSrc->x + (parcl->left - prclDst->left);
            ysrc = pptlSrc->y + (parcl->top - prclDst->top);
            
            
            //******************************************************************
            // Set methods for image_blit:
            //    NV05F_CONTROL_POINT_IN 
            //    NV05F_CONTROL_POINT_OUT
            //    NV05F_SIZE             
            //******************************************************************
            
            NV_DMAPUSH_START(3, BLIT_SUBCHANNEL, NV05F_CONTROL_POINT_IN );
            NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );
            NV_DMA_FIFO = ( (parcl->top << 16) | (parcl->left & 0xffff) );
            NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));

            
            parcl++;

        } while (--c != 0);

    }

    else
    {
        /*******************************************************************/
        /* Else we have a color brush                                      */
        /*                                                                 */
        /* Note that the code to setup the pattern is copy pasted from     */
        /* fillpatfast                                                     */
        /*******************************************************************/

        //******************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // NV4: Colored Pattern fills are now supported in hardware
        //******************************************************************

        xShift = pptlBrush->x;
        yShift = pptlBrush->y;

        //******************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //******************************************************************

        xShift &= 7;
        yShift &= 7;

        //******************************************************************
        // We're going to do a straight of the Xbpp 8x8 pattern to the screen.
        // First we'll align it properly by copying it to a temporary buffer:
        //******************************************************************

        cjLeft  = CONVERT_TO_BYTES(xShift, ppdev);      // Number of bytes pattern
                                                        //   is shifted to the right
        cjRight = CONVERT_TO_BYTES(8, ppdev) - cjLeft;  // Number of bytes pattern
                                                        // is shifted to the left

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift * CONVERT_TO_BYTES(8, ppdev); // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //******************************************************************
        // Now copy the pattern and align it, in 2 steps.
        // The 'left' part, and 'right' part (as well as the 'bottom' and 'top')
        // We'll start copying the 'bottom' part first.
        //******************************************************************

        do  
        {
            RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
            RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

            DstBits += cjLeft + cjRight;
            SrcBits += cjLeft + cjRight;

        } while (--i != 0);

        //******************************************************************
        // Now copy the 'top' part
        //******************************************************************

        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

        for (; yShift != 0; yShift--)
        {
            RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
            RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

            DstBits += cjLeft + cjRight;
            SrcBits += cjLeft + cjRight;
        }
        
        //******************************************************************
        // Ptr to pattern data
        //******************************************************************

        SrcBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

        //******************************************************************
        // Get ptr to start of SRC
        //******************************************************************

        NextScan = (ULONG *)(SrcBits);

        //******************************************************************
        // We only ever support 8x8 patterns
        //******************************************************************

        BytesPerSrcScan = ppdev->cjPelSize << 3; /* cjPelsize * 8 */

        //******************************************************************
        // Amount to increment for each scanline (in dwords)
        //******************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

        //******************************************************************
        // Check if we've got enough room in the push buffer for max amount
        // of data possible for the later code...
        //******************************************************************

        //NV_DMAPUSH_CHECKFREE(((ULONG)(8+65+4*c)));  

        //******************************************************************
        // Send the Rop straight on through 
        // (We now support colored patterns in hardware)
        //******************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        //******************************************************************
        // Init color pattern in hardware
        //******************************************************************

        // Determine the color format
        switch (ppdev->iBitmapFormat)
        {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
        }            


        //******************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //******************************************************************

        NV_DMAPUSH_START(3, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_COLOR;


        //******************************************************************
        // Init the 8x8 pattern for 8,16, or 32bpp 
        //******************************************************************

        if (ppdev->cjPelSize == 4)  // 32bpp
        {
            //**************************************************************
            // Init the 8x8 colored pattern
            //**************************************************************

            NV_DMAPUSH_START(64, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_X8R8G8B8(0));

            for (iy=0;iy<8;iy++)
            {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<8;ix++)
                {                    
                    NV_DMA_FIFO = ScanPtr[ix];
                }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
            }
        }
        
        else if (ppdev->cjPelSize == 2) // 16bpp
        {
            //**************************************************************
            // 16bpp
            //**************************************************************

            //**************************************************************
            // Init the 8x8 colored pattern for 16bpp
            //**************************************************************

            NV_DMAPUSH_START(32, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_R5G6B5(0));
                       

            for (iy=0;iy<8;iy++)
            {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<4;ix++)
                {                    
                    NV_DMA_FIFO = ScanPtr[ix];  // 2 16bpp pixels at a time
                }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
            }
        }
                                         

        else
        {
            //**************************************************************
            // 8bpp
            //**************************************************************

            //**************************************************************
            // Init the 8x8 colored pattern for 8bpp
            //**************************************************************

            NV_DMAPUSH_START(16, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_Y8(0));

            for (iy=0;iy<8;iy++)
            {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<2;ix++)
                {                    
                    NV_DMA_FIFO = ScanPtr[ix];  // 4 8bpp pixels at a time
                }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
            }
                                                    
            
        }
            
        //**********************************************************************
        // Loop thru all the clipping rectangles
        //**********************************************************************
    
        do  
        {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************
    
            width = parcl->right - parcl->left;
            height= parcl->bottom - parcl->top;
    

            xsrc = pptlSrc->x + (parcl->left - prclDst->left);
            ysrc = pptlSrc->y + (parcl->top - prclDst->top);

            
            //******************************************************************
            // Set methods for image_blit:
            //    NV05F_CONTROL_POINT_IN 
            //    NV05F_CONTROL_POINT_OUT
            //    NV05F_SIZE             
            //******************************************************************

            NV_DMAPUSH_START(3, BLIT_SUBCHANNEL, NV05F_CONTROL_POINT_IN );
            NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );
            NV_DMA_FIFO = ( (parcl->top << 16) | (parcl->left & 0xffff) );
            NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));
            
            //******************************************************************
            // Onto the next clipping rectangle
            //******************************************************************
    
            parcl++;
    
        } while (--c != 0);

    } // ...else the brush pattern is color (not mono)

    
    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

}
//**************** End of function: NV4DmaScreenToScreenWithPatBlt *************
//******************************************************************************





//******************************************************************************
//
//  Function:   NV4DmaPushFillPatFast
//
//  Routine Description:
//      Using NV04_GDI_RECTANGLE_TEXT class to fill with patterns.
//      The IMAGE_APTTERN_SUBCHANNEL set up the pattern first,
//      and then the RECT_AND_TEXT_SUBCHANNEL fill up the rectangle with 
//      the pattern.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment

    {
    //BOOL        bTransparent;
    //BRUSHENTRY* pbe;          // Pointer to brush entry data, which is used
                                //   for keeping track of the location and status
                                //   of the pattern bits cached in off-screen
                                //   memory

    ULONG       Color0;
    ULONG       Color1;
    ULONG       AlphaEnableValue;
    ULONG       width;
    ULONG       height;
    ULONG       rop3;
    LONG        xShift;
    LONG        yShift;
    LONG        BytesPerSrcScan;
    BYTE*       SrcBits;
    BYTE*       DstBits;
    ULONG*      ScanPtr;
    RBRUSH*     prb;
    ULONG*      NextScan;
    LONG        ScanInc;
    LONG        cjLeft;
    LONG        cjRight;
    ULONG       i, ix,iy;


    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // TODO: Do I need to do anything special for transparent cases?
    //**************************************************************************
    
    rop3 = (ULONG)(rop4 & 0xff);
    
    //bTransparent = (((rop4 >> 8) & 0xff) != rop3);

    //**************************************************************************
    // Get pointer to brush entry
    //**************************************************************************

    prb = rbc.prb;
    
    //pbe = prb->apbe[IBOARD(ppdev)];

    //**************************************************************************
    // Need to add if statement if brush pattern hasn't changed
    // For now, just always re-calculate brush pattern
    // Performance boost of how much?
    //**************************************************************************

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    
    //**************************************************************************
    // Check if there is enough free space in the push buffer. We check ONE
    // time because this is faster.  Furthermore, we check for the largest 
    // possible amount we will use in the rest of the function...
    //**************************************************************************


    //MAX of :  NV_DMAPUSH_CHECKFREE(((ULONG)(3+14+3*c     )));   and
    //          NV_DMAPUSH_CHECKFREE(((ULONG)(3+8+65+3*c     )));  

    NV_DMAPUSH_CHECKFREE(((ULONG)( 3+8+65+3*c )));  

    
    
    //**************************************************************************
    // Restore clip rect if we need to
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // I considered doing the colour expansion for 1bpp brushes in
    // software, but by letting the hardware do it, we don't have
    // to do as many OUTs to transfer the pattern.
    //**************************************************************************

    if (prb->fl & RBRUSH_2COLOR)
        {

        //**********************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // The brush is aligned in absolute coordinates, so we have to add
        // in the surface offset:
        //
        // NV: We DON'T need to manually account for the position of the pattern
        //     on the screen, like we do for the Memory to Screen blits for
        //     multi-color patterns (below).
        //**********************************************************************

        //**********************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //**********************************************************************

        xShift = pptlBrush->x & 7;
        yShift = pptlBrush->y & 7;

        //**********************************************************************
        // Shift Mono pattern bits appropriately (vertically)
        // First we'll align it properly by copying it to a temporary buffer:
        //**********************************************************************

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift;                              // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //**********************************************************************
        // Now copy the pattern , row by row (byte by byte) and
        // align it vertically and horizontally at the same time
        //**********************************************************************

        do  {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;

            } while (--i != 0);

        //**********************************************************************
        // Now copy the 'top' part
        //**********************************************************************

        DstBits -=8;                    // Move back to beginning of destination

        for (; yShift != 0; yShift--)
            {
            *DstBits = ((*SrcBits >> xShift) | (*SrcBits << (8-xShift)));
            DstBits ++;
            SrcBits ++;
            }

        //**********************************************************************
        // Init foreground and background color
        //**********************************************************************

        Color1 = rbc.prb->ulForeColor | (AlphaEnableValue); // Background color
        Color0 = rbc.prb->ulBackColor | (AlphaEnableValue); // Foreground color

        
        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        // Determine the color format
        switch (ppdev->iBitmapFormat)
            {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            }            

        //**********************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //    NV044_SET_MONOCHROME_COLOR0  
        //    NV044_SET_MONOCHROME_COLOR,  
        //    NV044_SET_MONOCHROME_PATTERN0
        //    NV044_SET_MONOCHROME_PATTERN1
        //**********************************************************************

        NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
        NV_DMA_FIFO = Color0; 
        NV_DMA_FIFO = Color1;
        NV_DMA_FIFO = ppdev->AlignedBrush[0];
        NV_DMA_FIFO = ppdev->AlignedBrush[1];
        
        //**********************************************************************
        // Since the sub-channel is same in the do-while loop, the color is set 
        // out of the do-while loop. (value can be anything tough, it's never
        // used anyway but method state must be valid, and it is volatile, being
        // invalidated when we use another subchannel or switch channels) - steph
        //**********************************************************************
        
        NV_DMAPUSH_START (1, RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_A);
        NV_DMA_FIFO = 0;

        do {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = prcl->right - prcl->left;
            height= prcl->bottom - prcl->top;

            NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL, NV04A_UNCLIPPED_RECTANGLE(0))
            NV_DMA_FIFO = (prcl->left << 16) | prcl->top;
            NV_DMA_FIFO = (width << (16) | height);

            prcl++;

            } while (--c != 0);

        }


    else

        {
        //******************************************************************
        // Handle multi-color patterns in hardware (new for NV4)
        //******************************************************************

        //******************************************************************
        // Because we handle only 8x8 brushes, it is easy to compute the
        // number of pels by which we have to rotate the brush pattern
        // right and down.  Note that if we were to handle arbitrary sized
        // patterns, this calculation would require a modulus operation.
        //
        // NV4: Colored Pattern fills are now supported in hardware
        //******************************************************************

        xShift = pptlBrush->x;
        yShift = pptlBrush->y;

        //******************************************************************
        // Rotate pattern 'xShift' pels right
        // Rotate pattern 'yShift' pels down
        //******************************************************************

        xShift &= 7;
        yShift &= 7;

        //******************************************************************
        // We're going to do a straight of the Xbpp 8x8 pattern to the screen.
        // First we'll align it properly by copying it to a temporary buffer:
        //******************************************************************

        cjLeft  = CONVERT_TO_BYTES(xShift, ppdev);      // Number of bytes pattern
                                                        //   is shifted to the right
        cjRight = CONVERT_TO_BYTES(8, ppdev) - cjLeft;  // Number of bytes pattern
                                                        // is shifted to the left

        SrcBits = (BYTE*) &prb->aulPattern[0];          // Copy from brush buffer
        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Copy to our aligned buffer

        DstBits += yShift * CONVERT_TO_BYTES(8, ppdev); // Starting yShift rows
        i = 8 - yShift;                                 //  down for 8 - yShift rows

        //******************************************************************
        // Now copy the pattern and align it, in 2 steps.
        // The 'left' part, and 'right' part (as well as the 'bottom' and 'top')
        // We'll start copying the 'bottom' part first.
        //******************************************************************

        do  {
            RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
            RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

            DstBits += cjLeft + cjRight;
            SrcBits += cjLeft + cjRight;

            } while (--i != 0);

        //******************************************************************
        // Now copy the 'top' part
        //******************************************************************

        DstBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

        for (; yShift != 0; yShift--)
            {
            RtlCopyMemory(DstBits + cjLeft, SrcBits, cjRight);
            RtlCopyMemory(DstBits, SrcBits + cjRight, cjLeft);

            DstBits += cjLeft + cjRight;
            SrcBits += cjLeft + cjRight;
            }
        
        //******************************************************************
        // Ptr to pattern data
        //******************************************************************

        SrcBits = (BYTE*) &ppdev->AlignedBrush[0];      // Move to the beginning of destination

        //******************************************************************
        // Get ptr to start of SRC
        //******************************************************************

        NextScan = (ULONG *)(SrcBits);

        //******************************************************************
        // We only ever support 8x8 patterns
        //******************************************************************

        BytesPerSrcScan = 8 * ppdev->cjPelSize;

        //******************************************************************
        // Amount to increment for each scanline (in dwords)
        //******************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

        //******************************************************************
        // Send the Rop straight on through 
        // (We now support colored patterns in hardware)
        //******************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        //******************************************************************
        // Init color pattern in hardware
        //******************************************************************

        // Determine the color format
        switch (ppdev->iBitmapFormat)
            {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            }            


        //******************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //******************************************************************

        NV_DMAPUSH_START(3, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_8X_8Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_COLOR;

        //******************************************************************
        // Init the 8x8 pattern for 8,16, or 32bpp 
        //******************************************************************

        if (ppdev->cjPelSize == 4)  // 32bpp
            {
            //**************************************************************
            // Init the 8x8 colored pattern
            //**************************************************************

            NV_DMAPUSH_START(64, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_X8R8G8B8(0));

            for (iy=0;iy<8;iy++)
                {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<8;ix++)
                    {                    
                    NV_DMA_FIFO = ScanPtr[ix];
                    }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
                }
            }
        else if (ppdev->cjPelSize == 2) // 16bpp
        
            {
            //**************************************************************
            // 16bpp
            //**************************************************************

            //**************************************************************
            // Init the 8x8 colored pattern for 16bpp
            //**************************************************************

            NV_DMAPUSH_START(32, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_R5G6B5(0));
                       

            for (iy=0;iy<8;iy++)
                {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<4;ix++)
                    {                    
                    NV_DMA_FIFO = ScanPtr[ix];  // 2 16bpp pixels at a time
                    }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
                }
                                                    
            }
                                         

        else
        
            {
            //**************************************************************
            // 8bpp
            //**************************************************************

            //**************************************************************
            // Init the 8x8 colored pattern for 8bpp
            //**************************************************************

            NV_DMAPUSH_START(16, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_Y8(0));
                       

            for (iy=0;iy<8;iy++)
                {
                //**********************************************************
                // Read one scanline at a time
                //**********************************************************

                ScanPtr = NextScan;

                for (ix=0;ix<2;ix++)
                    {                    
                    NV_DMA_FIFO = ScanPtr[ix];  // 4 8bpp pixels at a time
                    }
                
                //**********************************************************
                // Advance to next pattern scanline
                //**********************************************************

                NextScan+=ScanInc;
                }
                                                    
            
            }
        
        //**********************************************************************
        //* Set the color method even tough we don't use it
        //**********************************************************************

        NV_DMAPUSH_START (1, RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_A);  
        NV_DMA_FIFO = 0;
        
        //**********************************************************************
        // Loop thru all the clipping rectangles
        //**********************************************************************
        do  {
            //******************************************************************
            // Get width and height of the destination rectangle
            //******************************************************************

            width = prcl->right - prcl->left;
            height= prcl->bottom - prcl->top;                             

            NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL, NV04A_UNCLIPPED_RECTANGLE(0))
            NV_DMA_FIFO = (prcl->left << 16) | prcl->top;
            NV_DMA_FIFO = (width << (16) | height);

            //******************************************************************
            // Onto the next clipping rectangle
            //******************************************************************

            prcl++;

            } while (--c != 0);


        } // Multi-color pattern

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

} // End of FillPatFast routine



//******************************************************************************
//
//  Function:   NV4DmaPushMonoScanlineImageTransfer
//
//  Routine Description:
//
//       Low-level routine for transferring a bitmap image via RENDER_GDI0_RECT_AND_TEXT
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

#ifdef UNUSED_FUNC

VOID NV4DmaPushMonoScanlineImageTransfer(
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
ULONG   NumDwordsPerScan)
    {
    ULONG *SrcDataPtr;
    ULONG i;
    
    DECLARE_DMA_FIFO;
    //**************************************************************************
    // Init dma pusher variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Dword Ptr to Src Data
    //**************************************************************************

    SrcDataPtr = (DWORD *)pjSrc;

    //**************************************************************************
    // Class 'E' can output a maximum of 128 dwords at a time
    // If we've got less than 128 dwords, blast them out all at once.
    //**************************************************************************

    while (NumDwordsPerScan >= 128)

        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(129)));  

        //**********************************************************************
        // Blast out all glyph data to push buffer
        //**********************************************************************

        NV_DMAPUSH_START(128, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );
    
        //**********************************************************************
        // Set the following methods for RECT_AND_TEXT
        //     NV04A_MONOCHROME_COLOR01_E(0)
        //     NV04A_MONOCHROME_COLOR01_E(1)
        //     NV04A_MONOCHROME_COLOR01_E(2)
        //      ...
        //**********************************************************************
    
        for (i=0 ; i< 128; i++)
            NV_DMA_FIFO = SrcDataPtr[i];    

        NumDwordsPerScan-=128;
        SrcDataPtr += 128;

        }
                

    //**************************************************************************
    // Handle remaining dwords
    //**************************************************************************

    if (NumDwordsPerScan>0)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(NumDwordsPerScan+1)));  

        //**********************************************************************
        // Blast out all glyph data to push buffer
        //**********************************************************************

        NV_DMAPUSH_START(NumDwordsPerScan, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );
    
        //**********************************************************************
        // Set the following methods for RECT_AND_TEXT
        //     NV04A_MONOCHROME_COLOR01_E(0)
        //     NV04A_MONOCHROME_COLOR01_E(1)
        //     NV04A_MONOCHROME_COLOR01_E(2)
        //      ...
        //**********************************************************************
    
        for (i=0;i<NumDwordsPerScan;i++)
            NV_DMA_FIFO = SrcDataPtr[i];    

        }


    //**************************************************************************
    // Update cached dma count variable
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    }
    
#endif    

#define DWORD_BLK_XFER                                                                                  \
{                                                                                                       \
    ULONG i;                                                                                            \
    ULONG *SrcDataPtr;                                                                                  \
                                                                                                        \
    SrcDataPtr = (DWORD *)pjSrc;                                                                        \
    while (NumDwordsPerScan >= 128)                                                                     \
    {                                                                                                   \
        NV_DMAPUSH_CHECKFREE(((ULONG)(129)));                                                           \
                                                                                                        \
        NV_DMAPUSH_START(128, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );                \
                                                                                                        \
        for (i=0 ; i< 128; i++)                                                                         \
            NV_DMA_FIFO = SrcDataPtr[i];                                                                \
                                                                                                        \
        NumDwordsPerScan-=128;                                                                          \
        SrcDataPtr += 128;                                                                              \
    }                                                                                                   \
                                                                                                        \
    NV_DMAPUSH_CHECKFREE(((ULONG)(NumBytesPerScan)));                                                   \
    if (NumDwordsPerScan>0)                                                                             \
    {                                                                                                   \
        NV_DMAPUSH_START(NumDwordsPerScan, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );   \
                                                                                                        \
        for (i=0;i<NumDwordsPerScan;i++)                                                                \
            NV_DMA_FIFO = SrcDataPtr[i];                                                                \
                                                                                                        \
    }                                                                                                   \
}

#define LAST_DWORD_XFER                                                                                 \
    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));                                                                 \
    NV_DMAPUSH_START(1, RECT_AND_TEXT_SUBCHANNEL, NV04A_MONOCHROME_COLOR01_E(0) );                      \
    NV_DMA_FIFO = LastDword;    


//******************************************************************************
//
//  Function:   NV4DmaPushXfer1bpp
//
//  Routine Description:
//
//     This routine colour expands a monochrome bitmap, possibly with different
//     Rop2's for the foreground and background.  It will be called in the
//     following cases:
//
//     1) To colour-expand the monochrome text buffer for the vFastText routine.
//     2) To blt a 1bpp source with a simple Rop2 between the source and
//        destination.
//  x  3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
//        white and black, and the pattern is a solid colour.
//     4) To handle a true Rop4 that works out to be two Rop2's between the
//        pattern and destination.
//
//     Needless to say, making this routine fast can leverage a lot of
//     performance.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushXfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,     // Solid Color of pattern
BLENDOBJ*   pBlendObj)
    {
    LONG    dxSrc;
    LONG    dySrc;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;
    LONG    xLeft;
    LONG    yTop;
    LONG    xBias;

    ULONG Color0;
    ULONG Color1;
    ULONG AlphaEnableValue;
    ULONG NumBytesPerScan;
    ULONG NumDwordsPerScan;
    ULONG OffsetOfLastDword;
    ULONG LastDword;
    ULONG width;
    ULONG height;
    ULONG SizeInWidth;
    ULONG rop3;
    ULONG ClipLeft;
    ULONG ClipTop;
    ULONG ClipWidth;
    ULONG ClipHeight;
    RECTL DstRect;
    
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Make sure following conditions are true before continuing on
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");
    ASSERTDD(((((rop4 & 0xff00) >> 8) == (rop4 & 0xff)) || (rop4 == 0xaacc)),
             "Expect weird rops only when opaquing");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // Init foreground and background color
    //**************************************************************************

    Color0 = pxlo->pulXlate[0] | (AlphaEnableValue); // Background color
    Color1 = pxlo->pulXlate[1] | (AlphaEnableValue); // Foreground color

    //**************************************************************************
    // Find the pitch and starting location of the source mono (pattern) bitmap
    //
    // NOTE:  Normally, we'd need to check if this source SURFOBJ was a
    //        standard DIB or a DFB that was moved to system memory.
    //        However, since we don't store 1bpp SURFOBJs in offscreen memory
    //        (see drvCreateDeviceBitmap), we know that the this source SURFOBJ
    //        is just a plain standard DIB. (i.e.  we don't need to get the
    //        'lDelta' and 'pvScan0' values from psoSrc->dhsurf->pso->lDelta
    //        and psoSrc->dhsurf->pso->pvScan0.
    //
    //**************************************************************************

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    //**************************************************************************
    // Safety check  ...check and see if source bitmap is dword aligned
    // This is a requirement....bitmap should never start on non-dword alignment..
    // Otherwise, that will invalidate some assumptions made...we currently
    // always read dword multiples...at dword alignments...if source bitmap
    // doesn't start on a dword boundary, then we might not be able to get
    // the first dword of data on a dword boundary ...Send back to DIBengine?
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3), "Unaligned source bitmap");

    //**************************************************************************
    // Adjust dest rect in case it is in offscreen memory
    //**************************************************************************

    DstRect.top = prclDst->top;
    DstRect.left = prclDst->left;
    DstRect.right = prclDst->right;
    DstRect.bottom = prclDst->bottom;

    do  {
        //**********************************************************************
        //
        //  First, we need to determine the XBIAS required (where the starting bit
        //  of the monochrome source bitmap is located).  XBIAS is affected
        //  by 3 values as follows:
        //
        //          1) pptlSrc->x    ( value x1 shown below )
        //
        //                  This is simply the bit at which we want to
        //                  start in the monochrome pattern bitmap
        //
        //          2) prclDst->x    ( value x2 shown below )
        //
        //                  Location of the original unclipped destination rectangle
        //
        //          3) prcl->x       ( value x3 shown below)
        //
        //                  Current clip rectangle with coordinates relative
        //                  to prclDst
        //
        //  Screen Origin
        //  +--------------------------------------------------------------->
        //  |
        //  |
        //  |           x2 = prclDst->left
        //  |           +-----------------------------------------------
        //  |           |                             ^                 |-Original
        //  |           |                             | dySrc           |  Unclipped
        //  |           |                             |                 |   Destination
        //  |           |         x3 = prcl->left     v                 |    Rectangle
        //  |           |         +------------       -                 |
        //  |           |         |            |                        |
        //  |           |<-dxSrc->|            |                        |
        //  |           |         |            |                        |
        //  |           |         |            |-Current                |
        //  |           |         |            |  Clip                  |
        //  |           |          ------------    Rectangle            |
        //  |           |                                               |
        //  |           |                                               |
        //  |           |                                               |
        //  |            -----------------------------------------------
        //  |
        //  v
        //
        //            Source MonoChrome Bitmap
        //          +--------+--------+--------+------->
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |00011001|00010010|00010011|
        //          |           ^
        //          v           |
        //                      |
        //                      |
        //          |-- x1 ---->|
        //
        //**********************************************************************

        //**********************************************************************
        //
        // Once we determine the starting bit in the monochrome bitmap,
        // we can calculate the XBIAS value.  The left portion of the 1st source
        // dword that we will read will end up getting clipped by hardware.
        // This will allow us to NOT have to align subsequent source data.
        //
        //    xbias =  ( x1 + (x3 - x2) ) & 0x1f
        //
        //    xbias =  ( x1 + (dxSrc)   ) & 0x1f  ( starting bit position in dword)
        //                                                 from 0 - 31
        //
        //           --------------------------
        //          |00011001|00010010|00010011|  1st dword of source data
        //           --------------------------
        //          |               |          |
        //          |<--- xbias --->|          |
        //          |               |   This   |
        //          | This region is| region is|
        //          |   clipped     |  drawn   |
        //          v               v          v
        //
        //**********************************************************************

        //**********************************************************************
        // Set initial destination coordinates of blit
        //**********************************************************************

        yTop  = prcl->top;
        xLeft = prcl->left;

        //**********************************************************************
        // Init dimensions of clip rectangle.
        //**********************************************************************

        ClipTop = prcl->top;
        ClipLeft = prcl->left;

        ClipHeight = prcl->bottom - prcl->top;
        ClipWidth = prcl->right - prcl->left;

        //**********************************************************************
        // Find starting bit location of pattern.  We really only care about
        // the dword alignment (bottom 5 bits) of this value.
        //**********************************************************************

        dxSrc = prcl->left - DstRect.left;
        dySrc = prcl->top  - DstRect.top;

        //**********************************************************************
        // Determine the bias of the bitmap
        //**********************************************************************

        xBias = ( (pptlSrc->x + dxSrc) & 0x1f);     // Value from 0 thru 31
        if (xBias != 0)
            {
            //******************************************************************
            // NV: Set the hardware clip rectangle so we don't have to
            //     manually align the pattern bitmap.  Then make sure
            //     to adjust the starting point of the blit to account
            //     for this xbias.
            //
            // We should probably remove the  if (xBias !=0) statement
            // since it's not necessary.
            //******************************************************************

            xLeft -= xBias;
            }

        //**********************************************************************
        // Get width and height of the destination rectangle
        // Then calculate the DWORDS we'll send to the NV engine
        // (we always output DWORDS at a time), and the number of bytes per scan
        // SizeInWidth will always be a multiple of 32 pixels (1 dword's worth)
        //
        // Remember, xLeft has now been adjusted to account for the XBias value
        //**********************************************************************

        width = prcl->right - xLeft;
        height= prcl->bottom - yTop;

        //**********************************************************************
        // Get values required by NV hardware engine
        //**********************************************************************

        SizeInWidth = (width + 31) & 0xffe0;    // Always a multiple of 32 pixels
        NumBytesPerScan = SizeInWidth >> 3;     // Divide mono pixels by 8 to get bytes


        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(20)));  

        // Determine the color format
        switch (ppdev->iBitmapFormat)
            {
            case BMF_32BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            case BMF_16BPP:
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
               break;
            default:
            case BMF_8BPP:
               // Must be set to a legal value but hardware ignores it otherwise 
               NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
               break;
            }            

        //**********************************************************************
        // Set the following methods for context_pattern
        //    NV044_SET_MONOCHROME_FORMAT 
        //    NV044_SET_MONOCHROME_SHAPE  
        //    NV044_SET_PATTERN_SELECT    
        //    NV044_SET_MONOCHROME_COLOR0  
        //    NV044_SET_MONOCHROME_COLOR,  
        //    NV044_SET_MONOCHROME_PATTERN0
        //    NV044_SET_MONOCHROME_PATTERN1
        //**********************************************************************

        NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
        NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
        NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_64X_1Y;
        NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
        NV_DMA_FIFO = (PatternColor | AlphaEnableValue); 
        NV_DMA_FIFO = (PatternColor | AlphaEnableValue);
        NV_DMA_FIFO = 0xffffffff;
        NV_DMA_FIFO = 0xffffffff;

        //**********************************************************************
        // Notify the rest of the driver that we changed the pattern
        //**********************************************************************

        ppdev->NVPatternResetFlag=1;

        //**********************************************************************
        // Get Rop3 value from Rop4
        //**********************************************************************

        rop3 = (ULONG)((BYTE)rop4);

        //**********************************************************************
        // Set Rop
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

        //**********************************************************************
        // Set the following methods for RECT_AND_TEXT
        //      NV04A_CLIP_POINT0_E  
        //      NV04A_CLIP_POINT1_E  
        //      NV04A_COLOR0_E      
        //      NV04A_COLOR1_E      
        //      NV04A_SIZE_IN_E     
        //      NV04A_SIZE_OUT_E    
        //      NV04A_POINT_E       
        //**********************************************************************

        NV_DMAPUSH_START(7, RECT_AND_TEXT_SUBCHANNEL, NV04A_CLIP_POINT0_E );
        NV_DMA_FIFO = (  (ClipTop << 16) | (ClipLeft & 0xffff) );
        NV_DMA_FIFO = (((ClipTop+ClipHeight)<<16) | (ClipLeft+ClipWidth) );
        NV_DMA_FIFO = Color0 ;
        NV_DMA_FIFO = Color1 ;
        NV_DMA_FIFO = ( (height <<16) | SizeInWidth  );
        NV_DMA_FIFO = ( (height <<16) | width      );
        NV_DMA_FIFO = ( (yTop <<16) | (xLeft & 0xffff) );

        //**********************************************************************
        // Get starting byte address of source pattern bitmap
        // Once we have the starting byte address, we can get the starting dword address
        //
        // ?: Is it possible that pptlSrc->y + dySrc will go past
        //    end of Source Bitmap??
        //**********************************************************************

        pjSrc = pjSrcScan0 + (pptlSrc->y + dySrc) * lSrcDelta
                           + ((pptlSrc->x + dxSrc) >> 3);

        (ULONG_PTR)pjSrc &= ~0x3;

        //**********************************************************************
        // Get values pertinent for each scanline
        //**********************************************************************

        NumDwordsPerScan = SizeInWidth >> 5; //SizeInWidth / 32;
        OffsetOfLastDword = NumDwordsPerScan << 2;

        //**********************************************************************
        //
        // For performance, we have 2 main objectives as follows:
        //
        //   a) When reading src data, we'd like it to be dword aligned
        //   b) When outputting data, we'd like to output dwords as much as possible
        //
        // With that in mind, we accomplish objective (a) by calculating an
        // xbias value and reading the dword that the first byte of source data
        // is contained in.  That is, we'll grab the first dword of source data
        // and clip the left part of it using the hardware clip rectangle.
        // As a result, any subsequent reads of src data will not require
        // alignment.
        //
        // Example:
        //          Src data begins here --+
        //          at this bit            |
        //                                 v
        //           -----------------------------------
        //          |        |        |        |        |   1st dword of src data
        //           -----------------------------------
        //            byte 0    byte1    byte2    byte3
        //
        //          |<------ xbias ------->|
        //                                 |
        //                                 |<-- used -->|
        //                                 |    data
        //          |<- hardware clipped ->|
        //
        //
        // Objective (b) is accomplished by examining how many dwords we
        // need to output.  The key here is to make sure we don't read past
        // the end of the source bitmap. If the number of bytes we need to
        // output is a dword multiple, then we don't need to worry about it.
        // However, if it's not, we need to check the last couple of bytes
        // and not read past the end of the src data. Otherwise, we'll
        // generate a protection fault. This is done simply by using
        // a switch statement that handles 0,1,2, or 3 remaining bytes of src data.
        //
        //          Switch (Number Of src bytes left)
        //              0:  We are dword aligned already
        //              1:  Just read 1 more byte
        //              2:  Just read 2 more bytes
        //              3:  just read 3 more bytes
        //
        //**********************************************************************


        //**********************************************************************
        // Get src data, depending on how many bytes we will output
        // TO DO:  Since we now read the starting dword of the source bitmap
        //         (instead of the starting byte), isn't it true that
        //         we don't need to worry about straggling bytes going past
        //         end of bitmap...i.e. bitmaps are always allocated as
        //         multiples of dwords?  VERIFY!
        //
        //**********************************************************************

        switch (NumBytesPerScan & 3)
            {

            //******************************************************************
            // Output dwords at a time, then output last 3 bytes of data (in last dword)
            //******************************************************************

            case 3:
                do  {
                    if (NumDwordsPerScan > 0)
                        DWORD_BLK_XFER;

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword))  |
                            (*(pjSrc + OffsetOfLastDword + 1) << 8) |
                            (*(pjSrc + OffsetOfLastDword + 2) << 16);
                      
                    LAST_DWORD_XFER;        
                    
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // Output dwords at a time, then output last 2 bytes of data (in last dword)
            //******************************************************************

            case 2:
                do  {
                    if (NumDwordsPerScan > 0)
                        DWORD_BLK_XFER;


                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword))  |
                            (*(pjSrc + OffsetOfLastDword + 1) << 8);

                    LAST_DWORD_XFER;        
                    
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // Output dwords at a time, then output last byte of data (in last dword)
            //******************************************************************

            case 1:
                do  {
                    if (NumDwordsPerScan > 0)
                        DWORD_BLK_XFER;

                    //**********************************************************
                    // Store bytes in reverse order (not necessary for NV?)
                    //**********************************************************

                    LastDword = (ULONG) (*(pjSrc + OffsetOfLastDword));

                    LAST_DWORD_XFER;        
                    
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            //******************************************************************
            // The amount of data we will send is already a multiple of 4.
            // We will blast out all data in dwords
            //******************************************************************

            case 0:
                do  {
                    DWORD_BLK_XFER;
                    
                    pjSrc += lSrcDelta;

                    } while (--height != 0);
                break;

            } // Switch (NumBytesPerScan)

        prcl++;
        } while (--c != 0); // Next Clipping rectangle

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    }



//******************************************************************************
//
//  Function:   NV4_DmaPush_Send_Data
//
//  Routine Description:
//
//       Low-level routine for transferring a bitmap image via IMAGE_MONO_FROM_CPU
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4_DmaPush_Send_Data(
PDEV*   ppdev,
ULONG*  SrcDataPtr,              // Source pointer
ULONG   PixelCount)


    {
    ULONG DwordCount;
    ULONG i;
    
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    DwordCount = (PixelCount+3)>>2; // was /4 

    //**************************************************************************
    // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time
    // If we've got less than that, blast them out all at once.
    //**************************************************************************

    while (DwordCount >= 1024)

        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(1025)));  

        NV_DMAPUSH_START(1024, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_COLOR(0)
        //     NV061_COLOR(1)
        //     NV061_COLOR(2)
        //      ...
        //**********************************************************************
    
        for (i=0 ; i< 1024; i++)
            NV_DMA_FIFO = SrcDataPtr[i];    

        DwordCount-=1024;
        SrcDataPtr += 1024;

        }
                

    //**************************************************************************
    // Handle remaining dwords
    //**************************************************************************

    if (DwordCount>0)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(DwordCount+1)));  

        //**********************************************************************
        // Blast out remaining data
        //**********************************************************************

        NV_DMAPUSH_START(DwordCount, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_COLOR(0)
        //     NV061_COLOR(1)
        //     NV061_COLOR(2)
        //      ...
        //**********************************************************************
    
        for (i=0;i<DwordCount;i++)
            NV_DMA_FIFO = SrcDataPtr[i];    

        }


    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;


    }

//******************************************************************************
//
//  Function:   NV4DmaPushXfer4bpp
//
//  Routine Description:
//
//      Does a 4bpp transfer from a bitmap to the screen.
//
//      NOTE: The screen must be 8bpp for this function to be called!
//
//      The reason we implement this is that a lot of resources are kept as 4bpp,
//      and used to initialize DFBs, some of which we of course keep off-screen.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


//******************************************************************************
// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.
//
// NV_HALF_BUFFER_SIZE -> NV fifo can hold up to 32 DWORDS (128 bytes)
//                        Here, we output the data when we've reach half of that
//******************************************************************************

#define XLATE_BUFFER_SIZE 256
#define NV_HALF_FIFO_SIZE 16*4

VOID NV4DmaPushXfer4bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG PatternColor,
BLENDOBJ*   pBlendObj)  // Not used

    {
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;

    ULONG depth;
    LONG BytesPerSrcScan;
    ULONG Rop3;
    LONG xsrc,ysrc;
    BYTE *NextScan;
    ULONG yscan;
    BYTE *ScanPtr;
    LONG ScanInc;
    BYTE *DstBits;
    ULONG SizeInWidth;
    LONG clip_x,clip_y;
    ULONG clip_width,clip_height;
    BYTE TempPixelData[XLATE_BUFFER_SIZE];
    DSURF*  pdsurfSrc;
    ULONG*  pulXlate;
    BYTE  PixelDataByte;
    ULONG PixelDataDword;
    ULONG   LoopCount;
    ULONG PixelCount;
    ULONG i;

    DECLARE_DMA_FIFO;
    
    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get ready to translate the 4bpp colors
    //**************************************************************************

    ASSERTDD(pxlo != NULL, "Xfer4BPP, NULL XLATEOBJ");
    pulXlate  =  pxlo->pulXlate;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    if (pdsurfSrc != NULL)
        pjSrcScan0 = pdsurfSrc->pso->pvScan0;
    else
        pjSrcScan0 = psoSrc->pvScan0;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************
    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3),
        "Unaligned source bitmap");// ACK!....src bitmap is not dword aligned !!!

    //**************************************************************************
    // Get Rop3 value
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
    else
        BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************
    ASSERTDD(!((ULONG) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = BytesPerSrcScan ;      // Number of bytes to increment

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //***************************************************************************

    if (ppdev->NVClipResetFlag)
       {
       //***********************************************************************
       // Check if we've got enough room in the push buffer
       //***********************************************************************

       NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

       //***********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //***********************************************************************

       NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
       NV_DMA_FIFO = 0;
       NV_DMA_FIFO = ppdev->dwMaxClip; 

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
       }

    //**************************************************************************
    // Blit for each clipping rectangle
    //**************************************************************************

    while(TRUE)
        {

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + prcl->left - prclDst->left;
        ysrc = pptlSrc->y + prcl->top  - prclDst->top;

        //**********************************************************************
        // Get ptr to start of SRC (Remember, there are 2 pixels per byte!)
        //**********************************************************************

        NextScan = &(pjSrcScan0[(LONG)((xsrc>>1) + ysrc*BytesPerSrcScan)]);

        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - prcl->left;
        clip_height = prcl->bottom - prcl->top;

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

        //**********************************************************************
        // Setup NV Blit parameters for CPU to SCREEN blit
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ( ( clip_y << 16) | ( clip_x & 0xffff)  );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width  );

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        if (depth == 8)
            SizeInWidth = ((clip_width + 3) & 0xfffc);
        else if (depth == 16)
            SizeInWidth = ((clip_width + 1) & 0xfffe);
        else
            SizeInWidth = clip_width;

        //*********************************************************************
        //     NV061_SIZE_IN 
        //*********************************************************************

        NV_DMA_FIFO = ( (clip_height <<16) | (SizeInWidth)  );

        //*********************************************************************
        //
        // 4bpp Source Bitmap:
        //
        // nibble| hi lo | hi  lo| hi lo | hi lo | hi  lo|
        //        -----------------------------------------------
        //       | Byte0 | Byte1 | Byte2 | Byte3 | Byte4 | etc..
        //        -----------------------------------------------
        // Pixels  0  1    2  3     4  5    6  7    8  9
        //
        // Pixels are displayed on screen as UPPER NYBBLE, then LOWER NYBBLE
        //
        // We must be careful not to read past end of 4bpp bitmap
        // We do this by breaking up the operation into 2 cases:
        //
        // If the starting pixel is ODD, then we need to read
        // the LOWER nybble of the source byte first, and proceed from there.
        // If the starting pixel is EVEN, then we need to read
        // the UPPER nybble of the source byte first, and proceed from there.
        //
        //*********************************************************************

        //*********************************************************************
        //
        // The IA64 will fault on unaligned addresses.  Therefore use
        // the "odd" path in these cases to prevent DWORD sized accesses
        // that have this problem. Note that xsrc being divisible by 8
        // implies that the source address is divisible by 4.
        //
        //*********************************************************************

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

#ifdef _WIN64
        if ( xsrc & 0x7)
#else
        if ( xsrc & 0x1)
#endif
            {

            for (yscan=0;yscan < clip_height; yscan++)
                {
                ScanPtr = NextScan;
                PixelCount=0;
                //**************************************************************
                // For each byte, we read 2 pixels.  We will count by bytes.
                // If xsrc is ODD, we start on the ODD pixel so we read the LOWER
                // nibble of the current source byte FIRST, then we read the UPPER nibble
                // Vice Versa if xsrc is Even (which it can be for Win64's enforcement of DWord aligned access)
                // 
                //**************************************************************

                LoopCount= clip_width>>1 ;      // Odd pel handled separately

                //**************************************************************
                // Get the current 2 pixels of data
                //**************************************************************

                PixelDataByte = *ScanPtr;

                while (LoopCount-- > 0)
                    {
                    // If xsrc is ODD - no shift since first read in loop is lower nibble of current BYTE
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataByte >> ((xsrc & 0x1) ? 0 : 4)) & 0xf];

                    // If xsrc is ODD, prior read was lower nibble of BYTE, so advance to next BYTE
                    if (xsrc & 0x1) 
                        {
                        ScanPtr++;
                        PixelDataByte =*ScanPtr ;
                        }
                    
                    // If xsrc is ODD - shift since second read in loop is upper nibble of new byte read above
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataByte >> ((xsrc & 0x1) ? 4 : 0)) & 0xf];

                    // If xsrc is EVEN, prior read was lower nibble of BYTE, so advance to next BYTE
                    if (!(xsrc & 0x1))
                        {
                        ScanPtr++;
                        PixelDataByte =*ScanPtr ;
                        }


                    //**********************************************************
                    // Check if we need to flush the data and
                    // send it to NV hardware
                    //**********************************************************

                    if (PixelCount >= NV_HALF_FIFO_SIZE)
                        {
                        UPDATE_PDEV_DMA_COUNT;
                        NV4_DmaPush_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount);
                        UPDATE_LOCAL_DMA_COUNT;
                        PixelCount=0;
                        }
                    }

                //**************************************************************
                // Check for any straggling pixel leftover
                // If xsrc is ODD - no shift since we want lower nibble of current BYTE
                //**************************************************************
                if (clip_width & 1)
                    TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataByte >> ((xsrc & 0x1) ? 0 : 4)) & 0xf];

                //**************************************************************
                // Flush any remaining pixel data
                //**************************************************************

                if (PixelCount!=0)
                    {
                    UPDATE_PDEV_DMA_COUNT;
                    NV4_DmaPush_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount);
                    UPDATE_LOCAL_DMA_COUNT;
                    }
                    
                NextScan+=ScanInc;

            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

                UPDATE_PDEV_DMA_COUNT;
                NV4_DmaPushSend(ppdev);             // Time to kickoff the buffer
                UPDATE_LOCAL_DMA_COUNT;

                }
            }
        else
            {

            for (yscan=0;yscan < clip_height; yscan++)
                {
                ScanPtr = NextScan;
                PixelCount=0;
                //**************************************************************
                // Pixels are displayed on screen as UPPER NYBBLE, then LOWER NYBBLE
                //**************************************************************

                LoopCount = (clip_width + 1) >> 1;  // Each loop handles 2 pels

                do  {
                    //**********************************************************
                    // See if we can speed things up a bit by reading DWORDS
                    //**********************************************************

                    if (LoopCount>=4)               // 8 pels or more to go?
                        {
                        PixelDataDword = *((DWORD *)ScanPtr);
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >> 4) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword     ) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>12) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >> 8) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>20) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>16) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>28) & 0xf];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[(PixelDataDword >>24) & 0xf];

                        ScanPtr+=4;                 // Advance by 8 source pels

                        LoopCount-=4;               // 4 groups of 2 pels = 8 pels
                        }

                    else
                        {
                        PixelDataByte = *ScanPtr;

                        TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte >> 4];
                        TempPixelData[PixelCount++] = (BYTE) pulXlate[PixelDataByte & 0xf];

                        ScanPtr++;                  // Advance by 2 source pels

                        LoopCount--;                // 1 group of 2 pels = 2 pels
                        }

                    //**********************************************************
                    // Check if we need to flush the data and
                    // send it to NV hardware
                    //**********************************************************

                    if (PixelCount >= NV_HALF_FIFO_SIZE)
                        {
                        UPDATE_PDEV_DMA_COUNT;
                        NV4_DmaPush_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount);
                        UPDATE_LOCAL_DMA_COUNT;
                        PixelCount=0;
                        }

                    } while (LoopCount != 0);

                //**************************************************************
                // Flush any remaining pixel data
                //**************************************************************

                if (PixelCount!=0)
                    {
                    UPDATE_PDEV_DMA_COUNT;
                    NV4_DmaPush_Send_Data(ppdev,(ULONG *)TempPixelData,PixelCount);
                    UPDATE_LOCAL_DMA_COUNT;
                    }
                    

                NextScan+=ScanInc;
                
            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

                UPDATE_PDEV_DMA_COUNT;
                NV4_DmaPushSend(ppdev);             // Time to kickoff the buffer
                UPDATE_LOCAL_DMA_COUNT;
                }
            }

        if (--c == 0)
            {
            return;
            }

        prcl++;

        } // while (TRUE)...




    }


//******************************************************************************
//
//  Function:   NV4DmaPushXferNative
//
//      Transfers a bitmap that is the same colour depth as the display to
//      the screen via the data transfer register, with no translation.
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushXferNative(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,
BLENDOBJ*   pBlendObj)
{
    LONG    lSrcDelta;
    BYTE*   SrcBits;
    BYTE*   pjSrc;
    LONG    cjSrc;

    ULONG   BytesPerSrcPixel;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    LONG    xsrc,ysrc;
    ULONG   xsrcOffset;
    ULONG   AlignMask;
    ULONG*  NextScan;
    ULONG   BytesPerDstScan;
    ULONG   yscan;
    ULONG*  ScanPtr;
    LONG    ScanInc;
    BYTE*   DstBits;
    ULONG   SizeInWidth;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    DSURF*  pdsurfSrc;
    ULONG   ByteCount;
    ULONG   i;
    ULONG   TempPixelData1;
    ULONG   BytesWritten;

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD((pxlo == NULL) || !pxlo->flXlate || (pxlo->flXlate & XO_TRIVIAL) ||
            ((pxlo->flXlate == 0x10) && (OglIsEnabled(ppdev))),
            "Can handle trivial xlate only");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff), "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Setup Blender if needed  -paul
    // Only supported on Win2k
    //**************************************************************************
    
#if (_WIN32_WINNT >= 0x0500)
    
    if (pBlendObj) 
        {
        //**************************************************************************
        // Need to load alpha value into all bytes of the word since the hardware
        // uses each byte independently as an alpha value
        //**************************************************************************
        ULONG constAlpha = 0x00000000;
        
        constAlpha = pBlendObj->BlendFunction.SourceConstantAlpha & 0x000000FF;
        constAlpha |=constAlpha <<  8;
        constAlpha |=constAlpha <<  16;

        NV_DMAPUSH_CHECKFREE(((ULONG)(5*2)));
        
        if (ppdev->dDrawSpareSubchannelObject != NV_DD_CONTEXT_BETA4)
            {
            NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), NV_DD_CONTEXT_BETA4);
            ppdev->dDrawSpareSubchannelObject = NV_DD_CONTEXT_BETA4;
            }
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NV072_SET_BETA_FACTOR, constAlpha);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION, NV061_SET_OPERATION_BLEND_PREMULT);
        
        // If Alpha in source pixels, change source format - default 061 format has no alpha
        if (pBlendObj->BlendFunction.AlphaFormat & AC_SRC_ALPHA) 
            {
            // 32bpp source if it has alpha
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_A8R8G8B8);
            }
            else
            {
            // If no alpha, set to 16bpp or 32bpp format, w/ no src alpha.  HW then treats alpha as 0xff (1.0)
            // Note caller may have called AlphaPreserve to set source (061) format to format w/ alpha
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, 
                              (psoSrc->iBitmapFormat == BMF_16BPP) ? NV061_SET_COLOR_FORMAT_LE_R5G6B5 : 
                                                                     NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
            }
        
        if ((ppdev->iBitmapFormat == BMF_16BPP) &&
            (ppdev->CurrentClass.ContextSurfaces2D != NV04_CONTEXT_SURFACES_2D))
            {
            // For post NV4 hw, we turn dither off for the blend
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV065_SET_COLOR_CONVERSION, NV065_SET_COLOR_CONVERSION_TRUNCATE);
            }

        }
    else if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
        {
        // Some non-blend Native Xfers support source format different from vidmem (eg. TransparentBlt)
        NV_DMAPUSH_CHECKFREE(((ULONG)(1*2)));
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, 
                      (psoSrc->iBitmapFormat == BMF_16BPP) ? NV061_SET_COLOR_FORMAT_LE_R5G6B5 : 
                                                             NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
        }
#endif //(_WIN32_WINNT >= 0x0500)
    
    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**********************************************************************
    // Compute the alignment mask for rounding up SizeIn and for computing
    // correctly aligned addresses for IA64.
    //**********************************************************************

    if (psoSrc->iBitmapFormat == BMF_8BPP)
        {
        BytesPerSrcPixel = 1;
        AlignMask = 0x3;
        }
    else if (psoSrc->iBitmapFormat == BMF_16BPP)
        {
        BytesPerSrcPixel = 2;
        AlignMask = 0x1;
        }
    else
        {
        BytesPerSrcPixel = 4;
        AlignMask = 0x0;
        }

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        if ((prclDst->right - prclDst->left) < (prcl->right - clip_x))
            {
            clip_width = prclDst->right - prclDst->left;
            }
        else
            {
            clip_width = prcl->right - clip_x;
            }
        if ((prclDst->bottom - prclDst->top) < (prcl->bottom - clip_y))
            {
            clip_height = prclDst->bottom - prclDst->top;
            }
        else
            {
            clip_height = prcl->bottom - clip_y;
            }

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional (ignored) pixels
        //**********************************************************************

        //**********************************************************************
        // The IA64 architecture provides an additional complication: unaligned
        // accesses cause the process to fault.  Detect the unaligned cases and
        // mask off the offending address bits; once again we'll be sending more
        // bits to the NV engine as necessary.  Rely on the clipper (in this
        // case only) to drop the leading left edge of pixels.
        //**********************************************************************


        //**********************************************************************
        // Determine whether we will have a misaligned access on the IA64.
        // Alignment poses no problem for the X86 so clear the adjustment.
        //**********************************************************************

#ifdef _WIN64
        xsrcOffset = xsrc & AlignMask;
#else
        xsrcOffset = 0;
#endif

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(12)));

#if defined(_WIN64)

        if (xsrcOffset)
            {
            //**********************************************************************
            // For unaligned (DWORD) accesses, set the clipping region to the
            // original dest size to prevent drawing any more than requested.
            //**********************************************************************

            //******************************************************************
            // Set Point and Size methods for clip:
            //    NV019_SET_POINT
            //    NV019_SET_SIZE
            //******************************************************************

            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = ((0 << 16) |  clip_x);
            NV_DMA_FIFO = ((ppdev->cyMemory << 16) | clip_width); 

            ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset

            // adjust src x to DWORD boundary
            xsrc -= xsrcOffset;

            // adjust clip_x, clip_width - used for Dst x and width from here on
            clip_x -= xsrcOffset;
            clip_width += xsrcOffset;
            }
    else
#endif
        //**********************************************************************
        // Reset clipping rectangle to full screen extents if necessary
        // Resetting the clipping rectangle causes delays so we want to do it
        // as little as possible!
        //**********************************************************************

        if (ppdev->NVClipResetFlag)
            {

            //******************************************************************
            // Set Point and Size methods for clip:
            //    NV019_SET_POINT
            //    NV019_SET_SIZE
            //******************************************************************

            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = 0;
            NV_DMA_FIFO = ppdev->dwMaxClip; 

            ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
            }

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ( (clip_y <<16) | (clip_x & 0xffff) );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width );

        //**********************************************************************
        // Calculate the number of DWORDs to output for each scanline and
        // compute the address to the start of the source.  If the original 
        // value would have created an unaligned source address, back up the
        // left margin and increase the width to compensate.  In either case
        // round the SizeIn argument as described above.
        //**********************************************************************
    
        SizeInWidth = ((clip_width + AlignMask) & ~AlignMask);
        NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc*BytesPerSrcPixel) +
                                              (ysrc*BytesPerSrcScan))]));

        BytesPerDstScan = clip_width * BytesPerSrcPixel;

        //**********************************************************************
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMA_FIFO = ( (clip_height <<16) | SizeInWidth  );

        //**********************************************************************
        // Amount to increment for each scanline
        //**********************************************************************

        ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

#ifdef _X86_
        //**********************************************************************
        // Use assembly to output as fast as possible
        //**********************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPush_Transfer_MemToScreen_Data(ppdev,BytesPerDstScan,clip_height,NextScan,ScanInc);
        UPDATE_LOCAL_DMA_COUNT;

#else   // ifdef _x86_

        //*********************************************************************
        // The following C code is the exact equivalent of
        // NV4_Transfer_MemToScreen_Data in assembly.
        //*********************************************************************

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0;yscan < clip_height; yscan++)
            {
            ByteCount=BytesPerDstScan; 
            ScanPtr = NextScan;

            //******************************************************************
            // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time
            // If we've got less than that, blast them out all at once.
            //******************************************************************

            while (ByteCount >= 1024 * sizeof(ULONG))

                {
                //**************************************************************
                // Check if we've got enough room in the push buffer
                //**************************************************************

                NV_DMAPUSH_CHECKFREE(((ULONG)(1025)));  

                NV_DMAPUSH_START(1024, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
                //**************************************************************
                // Set the following methods for IMAGE_FROM_CPU
                //     NV061_COLOR(0)
                //     NV061_COLOR(1)
                //     NV061_COLOR(2)
                //      ...
                //**************************************************************
            
                for (i=0 ; i< 1024; i++)
                    NV_DMA_FIFO = ScanPtr[i];    

                ByteCount -= (1024 * sizeof(ULONG));
                ScanPtr += 1024;

                }


            //******************************************************************
            // Handle remaining dwords
            //******************************************************************

            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)((ByteCount>>2) + 3)));  

            if (ByteCount>=4)
                {

                //**************************************************************
                // Blast out remaining data
                //**************************************************************

                NV_DMAPUSH_START((ByteCount>>2), IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
                //**************************************************************
                // Set the following methods for IMAGE_FROM_CPU
                //     NV061_COLOR(0)
                //     NV061_COLOR(1)
                //     NV061_COLOR(2)
                //      ...
                //**************************************************************
        
                for (i=0;i<(ByteCount>>2);i++)
                    NV_DMA_FIFO = ScanPtr[i];    
        
                ScanPtr += (ByteCount>>2);
                ByteCount -= ((ByteCount>>2) * sizeof(ULONG));

                }

            //
            // Pad src scanline.
            //
            if (ByteCount)
                {
                //**************************************************************
                // Check if we've got enough room in the push buffer
                //**************************************************************

                TempPixelData1 = 0;
                for (i = 0; i < ByteCount; i++)
                {
                    TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) ,  TempPixelData1  );

                }

            NextScan+=ScanInc;

            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }
#endif  // ifdef else _X86_

        if (--c == 0)
            {
            goto All_Done;
            }

        prcl++;

        } // while (TRUE)...
All_Done:
    
#if (_WIN32_WINNT >= 0x0500)
                                                                     
    // If blending, restore Object state to defaults before return
    if (pBlendObj) 
        {
        NV_DMAPUSH_CHECKFREE((ULONG)(3*2));  
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION, NV061_SET_OPERATION_ROP_AND);
        // Restore color format which was changed to be the source image format
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, 
                              (ppdev->iBitmapFormat == BMF_16BPP) ? NV061_SET_COLOR_FORMAT_LE_R5G6B5 : 
                                                                    NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
        if ((ppdev->iBitmapFormat == BMF_16BPP) &&
            (ppdev->CurrentClass.ContextSurfaces2D != NV04_CONTEXT_SURFACES_2D))
            {
            // For post NV4 hw, we turned dither off for the blend, so restore here
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV065_SET_COLOR_CONVERSION, NV065_SET_COLOR_CONVERSION_DITHER);
            }

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
        }   
    else if (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)
        {
        // Restore source format if earlier changed since is different from vidmem format
        NV_DMAPUSH_CHECKFREE(((ULONG)(1*2)));
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, 
                              (ppdev->iBitmapFormat == BMF_16BPP) ? NV061_SET_COLOR_FORMAT_LE_R5G6B5 : 
                                                                    NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
        }

#endif //(_WIN32_WINNT >= 0x0500)
 
    return;
}

//******************************************************************************
//
//  Function:   NV4DmaPushMemToScreenBlit
//
//  Routine Description:
//
//      Does a memory-to-screen blt
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushMemToScreenBlt(
PDEV*   ppdev,
SURFOBJ* psoSrc,
POINTL* pptlSrc,
RECTL*  prclDst)

    {
    ULONG width,height;
    ULONG xscan,yscan;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    ULONG xsrcOffset;
    ULONG depth;
    ULONG AlignMask;
    LONG BytesPerSrcScan;
    ULONG ByteCount;
    ULONG SizeInWidth;
    ULONG BytesPerDstScan;
    ULONG *ScanPtr;
    ULONG *NextScan;
    LONG ScanInc;
    BYTE* SrcBits;
    DSURF* pdsurfSrc;
    ULONG TempPixelData1;
    ULONG BytesWritten;
    ULONG i;

    DECLARE_DMA_FIFO;
    //**************************************************************************
    // This function is exactly the same as XferNative, except
    // that 1) Rop = SRCCOPY always
    //      2) No clipping is done here
    //      3) No color translation
    //**************************************************************************

    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = (BytesPerSrcScan+3) >> 2;
        
    //**************************************************************************
    // Top left coordinate of destination on destination surface
    //**************************************************************************

    xdst = prclDst->left;
    ydst = prclDst->top;

    //**************************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**************************************************************************

    width = prclDst->right - xdst;
    height = prclDst->bottom - ydst;

    //**************************************************************************
    // Top left coordinate of source bitmap on source surface
    //**************************************************************************

    xsrc = pptlSrc->x;
    ysrc = pptlSrc->y;

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    //**************************************************************************

    //**************************************************************************
    // The IA64 architecture provides an additional complication: unaligned
    // accesses cause the process to fault.  Detect the unaligned cases and
    // mask off the offending address bits; once again we'll be sending more
    // bits to the NV engine as necessary.  Rely on the clipper (in this case
    // only) to drop the leading left edge of pixels.
    //**************************************************************************

    //**************************************************************************
    // Compute the alignment mask for rounding up SizeIn and for computing
    // correctly aligned addresses for IA64.
    //**************************************************************************

    if (depth == 8)
        AlignMask = 0x3;
    else if (depth == 16)
        AlignMask = 0x1;
    else
        AlignMask = 0x0;

    //**************************************************************************
    // Determine whether we will have a misaligned access on the IA64.
    // Alignment poses no problem for the X86 so clear the offset.
    //**************************************************************************

#ifdef _WIN64
    xsrcOffset = xsrc & AlignMask;
#else
    xsrcOffset = 0;
#endif

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(9)));

#if defined(_WIN64)
   //***************************************************************************
   // For unaligned (DWORD) accesses, set the clipping region to the
   // original dest size to prevent drawing any more than requested.
   //***************************************************************************

   if (xsrcOffset)
       {
       //***********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //***********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = ((0 << 16) |  xdst);
        NV_DMA_FIFO = ((ppdev->cyMemory << 16) | width); 
        
        // adjust src x to DWORD boundary
        xsrc -= xsrcOffset;

        // adjust xdst, width - used for Dst x and width from here on
        xdst -= xsrcOffset;
        width += xsrcOffset;

        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
       }
   else
#endif
   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

   if (ppdev->NVClipResetFlag)
       {
       //***********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //***********************************************************************

       NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
       NV_DMA_FIFO = 0;
       NV_DMA_FIFO = ppdev->dwMaxClip; 

       ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
       }

    //**************************************************************************
    // Initialize the ImageFromCpu object
    //**************************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , NV_SRCCOPY);

    //**************************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_POINT     
    //     NV061_SIZE_OUT  
    //     NV061_SIZE_IN 
    //**************************************************************************

    NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
    NV_DMA_FIFO = ( (ydst <<16) | (xdst & 0xffff) );
    NV_DMA_FIFO = ( (height <<16) | width );

    //**************************************************************************
    // Calculate the number of DWORDs to output for each scanline and
    // compute the address to the start of the source.  If the original 
    // value would have created an unaligned source address, back up the
    // left margin and increase the width to compensate.  In either case
    // round the SizeIn argument as described above.
    //**************************************************************************
    
    SizeInWidth = ((width + AlignMask) & ~AlignMask);
    BytesPerDstScan = width * (depth>>3);
    NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc*(depth>>3)) +
                                          (ysrc*BytesPerSrcScan))]));

    //**************************************************************************
    //     NV061_SIZE_IN 
    //**************************************************************************

    NV_DMA_FIFO = ( (height <<16) | (SizeInWidth) );

#ifdef _X86_
    //**************************************************************************
    // Use assembly to output as fast as possible
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPush_Transfer_MemToScreen_Data(ppdev,BytesPerDstScan,height,NextScan,ScanInc);

#else   // ifdef _x86_

    //**************************************************************************
    // The following C code is the exact equivalent of
    // NV4_Transfer_MemToScreen_Data in assembly.
    //**************************************************************************

    //***************************************************************************
    // Output one scan at a time
    //***************************************************************************

    for (yscan=0;yscan < height; yscan++)
        {
        ByteCount = BytesPerDstScan;

        ScanPtr = NextScan;

        //**********************************************************************
        // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time
        // If we've got less than that, blast them out all at once.
        //**********************************************************************

        while (ByteCount >= 1024 * sizeof(ULONG))

            {
            //******************************************************************
            // Check if we've got enough room in the push buffer
            //******************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)(1025)));  


            NV_DMAPUSH_START(1024, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //******************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //******************************************************************
        
            for (i=0 ; i< 1024; i++)
                NV_DMA_FIFO = ScanPtr[i];    

            ByteCount -= (1024 * sizeof(ULONG));
            ScanPtr += 1024;

            }


        //******************************************************************
        // Check if we've got enough room in the push buffer
        //******************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)((ByteCount>>2) + 3)));  

        //**********************************************************************
        // Handle remaining dwords
        //**********************************************************************

        if (ByteCount>=4)
            {
            //******************************************************************
            // Blast out remaining data
            //******************************************************************

            NV_DMAPUSH_START((ByteCount>>2), IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //******************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //******************************************************************
    
            for (i=0;i<(ByteCount>>2);i++)
                NV_DMA_FIFO = ScanPtr[i];    
    
            ScanPtr += (ByteCount>>2);
            ByteCount -= ((ByteCount>>2) * sizeof(ULONG));
            }


        //**********************************************************************
        // Pad src scanline.
        //**********************************************************************
        if (ByteCount)
            {
            ULONG   i;
            TempPixelData1 = 0;
            for (i = 0; i < ByteCount; i++)
                {
                TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) , TempPixelData1  );
            }

        NextScan+=ScanInc;

        //*********************************************************************
        // Kickoff buffer after each scanline
        //*********************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
        UPDATE_LOCAL_DMA_COUNT;
        }

#endif  // _X86_

    }

//******************************************************************************
//
//  Function:   NV4DmaPushMemToScreenWithPatternBlt()
//
//  Routine Description:
//
//              Does a memory-to-screen with pattern blt
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushMemToScreenWithPatternBlt(
PDEV*   ppdev,
SURFOBJ* psoSrc,
POINTL* pptlSrc,
RECTL*  prclDst,
ULONG rop3,
RBRUSH_COLOR   *rbc,
RECTL*  prclClip
)


    {
    ULONG width,height;
    ULONG xscan,yscan;
    ULONG xsrc,ysrc;
    ULONG xdst,ydst;
    ULONG depth;
    ULONG xsrcOffset;
    LONG BytesPerSrcScan;
    ULONG ByteCount;
    ULONG SizeInWidth;
    ULONG BytesPerDstScan;
    ULONG TempPixelData1;
    ULONG *ScanPtr;
    ULONG *NextScan;
    LONG ScanInc;
    BYTE* SrcBits;
    DSURF* pdsurfSrc;
    ULONG   i;
    ULONG AlphaEnableValue;
    DECLARE_DMA_FIFO;


    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the source ptr from pdsurfSrc->pso->pvScan0.
    // Otherwise, just get it from psoSrc->pvScan0 (standard DIB)
    //**************************************************************************

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    // CAREFUL: If this is a DFB which has been moved to system memory (DT_DIB),
    // then get the 'ldelta' value from pdsurfSrc->pso->lDelta.  Source DFB
    // will NEVER come from offscreen VRAM (DT_SCREEN) so we don't have to even
    // check for dt == DT_DIB.  Otherwise, if we're dealing with a standard
    // system memory DIB, just get 'lDelta' from psoSrc->lDelta.
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        SrcBits         = pdsurfSrc->pso->pvScan0;
        BytesPerSrcScan = pdsurfSrc->pso->lDelta;
        }
    else
        {
        SrcBits         = psoSrc->pvScan0;
        BytesPerSrcScan = psoSrc->lDelta;
        }

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**************************************************************************

    width = prclDst->right - prclDst->left;
    height = prclDst->bottom - prclDst->top;

    //**************************************************************************
    // Top left coordinate of source bitmap on source surface
    //**************************************************************************

    xsrc = pptlSrc->x;
    ysrc = pptlSrc->y;

    //**************************************************************************
    // Top left coordinate of destination on destination surface
    //**************************************************************************

    xdst = prclDst->left;
    ydst = prclDst->top;

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    depth = ppdev->cBitsPerPel;

    //**************************************************************************
    // Determine whether we will have a misaligned access on the IA64.
    // Alignment poses no problem for the X86 so clear the offset.
    //**************************************************************************

#ifdef _WIN64
    if (depth == 8)
        xsrcOffset = xsrc & 0x3;
    else if (depth == 16)
        xsrcOffset = xsrc & 0x1;
    else
        xsrcOffset = 0x0;
#else
    xsrcOffset = 0;
#endif

    //***********************************************************************
    // Check if we've got enough room in the push buffer
    //***********************************************************************
 
    NV_DMAPUSH_CHECKFREE(((ULONG)(19)));  


#if defined(_WIN64)
   //***************************************************************************
   // For unaligned (DWORD) accesses, set the clipping region to the
   // original dest size to prevent drawing any more than requested.
   //***************************************************************************

   if (xsrcOffset)
       {
       //***********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //***********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = ((0 << 16) |  xdst);
        NV_DMA_FIFO = ((ppdev->cyMemory << 16) | width); 
        
        // adjust src x to DWORD boundary
        xsrc -= xsrcOffset;

        // adjust xdst, width - used for Dst x and width from here on
        xdst -= xsrcOffset;
        width += xsrcOffset;

        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
       }
   else
#endif


   //***************************************************************************
   // Reset clipping rectangle to full screen extents if necessary
   // Resetting the clipping rectangle causes delays so we want to do it
   // as little as possible!
   //***************************************************************************

    if((prclClip == NULL) && (ppdev->NVClipResetFlag))
    {
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 
        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
    }
    else if(prclClip != NULL)
    {
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = (( prclClip->top << 16) |  prclClip->left);
        NV_DMA_FIFO = (((prclClip->bottom - prclClip->top) << 16) 
                    | (prclClip->right - prclClip->left) ); 
        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
    }

    //**************************************************************************
    // Wait for FIFO, then set pattern registers
    //**************************************************************************

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
           break;
        case BMF_16BPP:
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
           break;
        default:
        case BMF_8BPP:
           // Must be set to a legal value but hardware ignores it otherwise 
           NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
           break;
        }            

    //**************************************************************************
    // Set the following methods for context_pattern
    //    NV044_SET_MONOCHROME_FORMAT 
    //    NV044_SET_MONOCHROME_SHAPE  
    //    NV044_SET_PATTERN_SELECT    
    //    NV044_SET_MONOCHROME_COLOR0  
    //    NV044_SET_MONOCHROME_COLOR,  
    //    NV044_SET_MONOCHROME_PATTERN0
    //    NV044_SET_MONOCHROME_PATTERN1
    //**************************************************************************

    NV_DMAPUSH_START(7, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT);
    NV_DMA_FIFO = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
    NV_DMA_FIFO = NV044_SET_MONOCHROME_SHAPE_64X_1Y;
    NV_DMA_FIFO = NV044_SET_PATTERN_SELECT_MONOCHROME;
    NV_DMA_FIFO = (ULONG)(rbc->iSolidColor | AlphaEnableValue); 
    NV_DMA_FIFO = (ULONG)(rbc->iSolidColor | AlphaEnableValue);
    NV_DMA_FIFO = 0xffffffff;
    NV_DMA_FIFO = 0xffffffff;

    //**************************************************************************
    // Notify the rest of the driver that we changed the pattern
    //**************************************************************************

    ppdev->NVPatternResetFlag=1;

    //**************************************************************************
    // Wait for FIFO, then set IMAGE_FROM_CPU registers
    //**************************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop3);

    //**************************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_POINT     
    //     NV061_SIZE_OUT  
    //     NV061_SIZE_IN 
    //**************************************************************************

    NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
    NV_DMA_FIFO = ( (ydst <<16) | (xdst & 0xffff) );
    NV_DMA_FIFO = ( (height <<16) | width );

    //**************************************************************************
    // Specifying 1 more pixel (example: in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    // SizeIn is specified in pixels.
    //**************************************************************************

    //**************************************************************************
    // Calculate number of dwords to output per scanline
    // This is the actual amount of data that the NV engine expects per scanline.
    // SizeInWidth is guaranteed to be a multiple of 2 (for 16bpp) and
    // a multiple of 4 (for 8bpp).  So we'll always be outputting DWORDS.
    // (No leftover words or bytes, they get clipped)
    //**************************************************************************

    //**************************************************************************
    // Get ptr to start of SRC
    //**************************************************************************

    if (depth == 8)
        {        
        SizeInWidth = ((width + 3) & 0xfffc);       // We always send 4 pixels at a time
        BytesPerDstScan = width;
        NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc) + (ysrc*BytesPerSrcScan))]));
        }
    else if (depth == 16)
        {        
        SizeInWidth = ((width + 1) & 0xfffe);       // We always send 2 pixels at a time
        BytesPerDstScan = width * 2;
        NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc*2) + (ysrc*BytesPerSrcScan))]));
        }
    else
        {        
        SizeInWidth = width;                        // We always send 1 pixel at a time
        BytesPerDstScan = width * 4;
        NextScan = (ULONG *)(&(SrcBits[(LONG)((xsrc*4) + (ysrc*BytesPerSrcScan))]));
        }

    //**************************************************************************
    //     NV061_SIZE_IN 
    //**************************************************************************

    NV_DMA_FIFO = ( (height <<16) | (SizeInWidth)  );

    //**************************************************************************
    // Amount to increment for each scanline
    //**************************************************************************

    ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

#ifdef _X86_

    //**********************************************************************
    // Use assembly to output as fast as possible
    //**********************************************************************

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPush_Transfer_MemToScreen_Data(ppdev,BytesPerDstScan,height,NextScan,ScanInc);

#else   // ifdef _x86_

    //**************************************************************************
    // Output one scan at a time
    //**************************************************************************

    for (yscan=0;yscan < height; yscan++)
        {
        ByteCount=BytesPerDstScan;

        ScanPtr = NextScan;

        //**********************************************************************
        // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time
        // If we've got less than that, blast them out all at once.
        //**********************************************************************

        while (ByteCount >= 1024 * sizeof(ULONG))

            {

            //******************************************************************
            // Check if we've got enough room in the push buffer
            //******************************************************************
 
            NV_DMAPUSH_CHECKFREE(((ULONG)(1025)));  


            NV_DMAPUSH_START(1024, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //******************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //******************************************************************
        
            for (i=0 ; i< 1024; i++)
                NV_DMA_FIFO = ScanPtr[i];    

            ByteCount -= (1024 * sizeof(ULONG));
            ScanPtr += 1024;

            }


        //******************************************************************
        // Check if we've got enough room in the push buffer
        //******************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(ByteCount>>2) + 3));  

        //**********************************************************************
        // Handle remaining dwords
        //**********************************************************************

        if (ByteCount >= 4)
            {
            //******************************************************************
            // Blast out remaining data
            //******************************************************************

            NV_DMAPUSH_START((ByteCount>>2), IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //******************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //******************************************************************
    
            for (i=0;i<(ByteCount>>2);i++)
                NV_DMA_FIFO = ScanPtr[i];    
    
            ScanPtr += (ByteCount>>2);
            ByteCount -= ((ByteCount>>2) * sizeof(ULONG));
            }

        //
        // Pad src scanline.
        //
        if (ByteCount)
            {
            TempPixelData1 = 0;
            for (i = 0; i < ByteCount; i++)
                {
                TempPixelData1 |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                }

            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0), TempPixelData1);
            }


        NextScan+=ScanInc;
        
        //******************************************************************
        // Kickoff buffer after each scanline
        //******************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
        UPDATE_LOCAL_DMA_COUNT;


        }

#endif  // ifdef else _X86_

    //**************************************************************************
    // Notify the rest of the driver that we changed the pattern
    //**************************************************************************

    ppdev->NVPatternResetFlag=1;

    }

//******************************************************************************
//
//  Function:   NV4ScreenTo1bppMemBlit
//
//  Routine Description:
//
//      Does a memory-to-screen blt
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

//*****************************Public*Table*************************************
// BYTE gajLeftMask[] and BYTE gajRightMask[]
//
// Edge tables for vXferScreenTo1bpp.
//******************************************************************************

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

BOOL NV4ScreenTo1bppMemBlt(
PDEV*   ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
SURFOBJ* psoSrc,
SURFOBJ* psoDst,
POINTL* pptlSrc,
RECTL*  prclDst,
XLATEOBJ*   pxlo)               // Provides colour-compressions information

    {
    DSURF*  pdsurfSrc;
    ULONG   width,height;
    ULONG*  pulXlate;
    SURFOBJ soTmp;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    VOID*   pfnCompute;
    BYTE*   pjDst;
    LONG    cjPelSize;
    LONG    cyToGo;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    ULONG   numbytes;
    RECTL*  ptmp_rcl;
    LONG    tmp_c;
    BOOL    status;
    BYTE*   jSrcPtr;
    USHORT* sSrcPtr;
    ULONG*  lSrcPtr;

    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(MEM_TO_MEM_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cjPelSize),
                "Temp buffer has to be larger than widest possible scan");

    //**************************************************************************
    // Assume call succeeded
    //**************************************************************************

    status = TRUE;
    
    //**************************************************************************
    // Get pointer to start of source bitmap
    // Need to be careful about this!  This function gets called
    // when copying a system memory bitmap to VRAM.  However, the SOURCE
    // surfobj can be a standard DIB or it can be a DFB that's been moved
    // from offscreen VRAM to system memory.  If this is the case, then
    // we need to make sure and get the source ptr from the correct place.
    //**************************************************************************

    pdsurfSrc = (DSURF*)psoSrc->dhsurf;

    //**************************************************************************
    // Get a ptr to the clip list and the count of clip rectangles
    //**************************************************************************

    ptmp_rcl = prcl;
    tmp_c    = c;

    //**********************************************************************
    // Destination pel size is either 1,2 or 4
    //**********************************************************************

    cjPelSize = ppdev->cjPelSize;

    
    //**************************************************************************
    // Check that the temporary buffer is large enough
    //**************************************************************************

    do  {

        //**********************************************************************
        // Get height, and the number of bytes required to hold the bitmap
        //
        // Number of bytes in bitmap is  width * height * bytesPerPixel.
        //**********************************************************************

        height = ptmp_rcl->bottom - ptmp_rcl->top;
        width = (((ptmp_rcl->right + 7L) & ~7L) - (ptmp_rcl->left & ~7L));

        numbytes = width * height * cjPelSize;
        
        //**********************************************************************
        // Check if our temporary buffer was large enough.
        // If not, then punt the call back to GDI.
        //**********************************************************************

        if (numbytes >= ppdev->MemToMemBufferSize)
            return(FALSE);            

        ptmp_rcl++;
        tmp_c--;
        } while (tmp_c != 0);
    

    //**************************************************************************
    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.
    //**************************************************************************

    if (ppdev->iBitmapFormat == BMF_8BPP)

        {

        //**********************************************************************
        // When the source is 8bpp or less, we find the foreground colour
        // by searching the translate table for the only '1':
        //**********************************************************************

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        //**********************************************************************
        // Get color index (from 0 to 255)
        //**********************************************************************

        ulForeColor = (ULONG)(pulXlate - pxlo->pulXlate);

        }

    else

        {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        //**********************************************************************
        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':
        //**********************************************************************

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
        }


    //**************************************************************************
    // We use the temporary buffer to keep a copy of the source
    // rectangle:
    //**************************************************************************

    soTmp.pvScan0 = ppdev->pMemToMemBuffer;

    do  {
        
        //**********************************************************************
        //
        //          1) pptlSrc->x    ( value x1 shown below )
        //
        //          2) prclDst->x    ( value x2 shown below )
        //
        //                  Location of the original unclipped destination rectangle
        //
        //          3) prcl->x       ( value x3 shown below)
        //
        //                  Current clip rectangle with coordinates relative to prclDst
        //
        //
        //   Origin  (Dst bitmap 1bpp)
        //  +--------------------------------------------------------------->
        //  |
        //  |
        //  |           x2 = prclDst->left
        //  |           +-----------------------------------------------
        //  |           |                             ^                 |-Original
        //  |           |                             | dySrc           |  Unclipped
        //  |           |                             |                 |   Destination
        //  |           |         x3 = prcl->left     v                 |    Rectangle
        //  |           |         +------------       -                 |
        //  |           |         |            |                        |
        //  |           |<-dxSrc->|            |                        |
        //  |           |         |            |                        |
        //  |           |         |            |-Current                |
        //  |           |         |            |  Clip                  |
        //  |           |          ------------    Rectangle            |
        //  |           |                                               |
        //  |           |                                               |
        //  |           |                                               |
        //  |            -----------------------------------------------
        //  |
        //  v
        //
        //
        //            Source Bitmap Color
        //          +--------+--|-----+--------+------->
        //          |           x1
        //          |
        //          |
        //          |
        //          |           ^
        //          v           |
        //                      |
        //                      |
        //          |-- x1 ---->|   x1 = pptlSrc->x
        //
        //**********************************************************************

        //**********************************************************************
        // ptlSrc points to the upper-left corner of the src screen rectangle
        //**********************************************************************

        ptlSrc.x = pptlSrc->x +  prcl->left - prclDst->left;
        ptlSrc.y = pptlSrc->y +  prcl->top  - prclDst->top;

        //**********************************************************************
        // Determine ptr for Destination 1bpp bitmap (we are actually determining
        // a byte address but the x position actually correponds to a bit address)
        //**********************************************************************

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        //**********************************************************************
        // Here, we determine the number of bytes required per each SRC scanline
        // that we will read into the temporary buffer (from the source screen bitmap)
        // (Right pel is exclusive)
        //
        // Left Pel Address         Right Pel address        
        // ----------------         -----------------        
        // 0->7    maps to 0         0     maps to 0         
        // 8->15   maps to 8         1->8  maps to 8         
        // 16->24  maps to 16        9->16 maps to 16        
        //
        // The following calculation should give us the amount
        // of bytes needed to hold a scanline of pixels, while also being a multiple
        // of 8 pixels.
        //**********************************************************************

        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L))
                       * cjPelSize;

        //**********************************************************************
        // cyToGo is the total number of scans we have to do for this rectangle.
        //**********************************************************************

        cyToGo     = prcl->bottom - prcl->top;

        //**********************************************************************
        // rclTmp is the temporary buffer destination rectangle
        // Initialize variables that don't change within the loop:
        // (rclTmp is passed to vGetBits)
        // Left destination coordinate is byte aligned
        //**********************************************************************

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;    
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;
        rclTmp.bottom = cyToGo;

        //**********************************************************************
        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).
        //
        // That is, the gajRightMask table data has been adjusted to account for
        // rclTmp.right being right-exclusive.  If rcl.right == 8, then
        // we would only access byte 0 , and not byte 1.  Therefore, the right
        // mask = 0xff for rcl.right = 8.
        //**********************************************************************

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];

        //**********************************************************************
        // Since the destination is mono, we need to calculate the number of bytes
        // that will hold the corresponding monochrome bits (shift right by 3)
        //
        // |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|  pixel position
        //     |             | |
        //     |             | v
        //     |             |  right
        //     |             |     
        //     v             v
        //  (rclTmp.left)  (rclTmp.right - 1)   This is exclusive 
        //
        //
        //
        // 
        // Shift by 3 (divide by 8) to determine the which byte contains the position        
        // This will give us a 'left byte' address and a 'right' byte address
        //
        //       Left Byte  = (rclTmp.left)      >> 3
        //       Right Byte = (rclTmp.right - 1) >> 3
        //
        //
        //
        // This then leaves us with 3 cases:
        //
        //
        // - Case 1:  Left Byte and Right Byte are the same byte
        // 
        //   |        |        |        |        |        |
        //   | byte 0 | byte 1 | byte 2 | byte 3 | byte 4 | etc....
        //   |        |        |        |        |        |
        //      ^  ^
        //      |  |                    no 'middle' bytes
        //      L  R
        //
        //
        // - Case 2:  Left Byte and Right Byte are next to each other
        // 
        //   |        |        |        |        |        |
        //   | byte 0 | byte 1 | byte 2 | byte 3 | byte 4 | etc....
        //   |        |        |        |        |        |
        //         
        //      ^       ^
        //      |       |               no 'middle' bytes
        //      L       R
        //
        //
        // - Case 3:  Left Byte and Right Byte are more than 1 byte away
        //            from each other
        // 
        //   |        |        |        |        |        |
        //   | byte 0 | byte 1 | byte 2 | byte 3 | byte 4 | etc....
        //   |        |        |        |        |        |
        //         
        //      ^                 ^
        //      |                 |      some 'middle' bytes
        //      L                 R
        // 
        //**********************************************************************

        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        //**********************************************************************
        // We are left with the following cases:
        //
        //   right - left   = 0     No middle byte
        //   right - left   = 1     No middle byte, just left and right bytes
        //   right - left   > 1     Middle byte present
        //
        // This can be simplified by subtracting 1 as follows:
        //
        //   right - left - 1  = negative     No middle byte, blt starts and ends in same byte
        //   right - left - 1  = 0            No middle byte, just left and right bytes
        //   right - left - 1  > 0            Middle byte present
        //
        //**********************************************************************

        if (cjMiddle < 0)
            {
            //******************************************************************
            // The blt starts and ends in the same byte:
            //******************************************************************

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
            }

        //**********************************************************************
        // Calculate the 'NOT' masks ahead of time
        //**********************************************************************

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;

        //**********************************************************************
        // Mono destination bitmap delta:
        // Delta from the END of one scan to the START on the next scan,
        // accounting for 'left' and 'right' bytes 
        //**********************************************************************

        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                
        //**********************************************************************
        // Color source bitmap delta: (temporary buffer)
        // Compute source delta for special cases like when cjMiddle gets bumped
        // up to '0', and to correct aligned cases
        // (Delta from the END of one scan to the START on the next scan)
        //**********************************************************************

        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) * cjPelSize);

        //**********************************************************************
        // Copy a rectangle of data from SCREEN and read it to the temporary buffer
        // Specify SRC PDSURF,  Dst surfobj (temporary buffer),  dest rectangle,
        // src x and y (pptlsrc)
        //**********************************************************************

        (ppdev->pfnGetScreenBits)(ppdev, pdsurfSrc, &soTmp, &rclTmp, &ptlSrc);
                                
        //**********************************************************************
        // Convert the color bitmap to mono bitmap scanline by scanline
        //**********************************************************************

#ifndef _WIN64
        do  {

           _asm {
                mov     eax,ulForeColor     ; eax = foreground colour
                                            ; ebx = temporary storage
                                            ; ecx = count of middle dst bytes
                                            ; dl  = destination byte accumulator
                                            ; dh  = temporary storage
                mov     esi,soTmp.pvScan0   ; esi = source pointer (from temp buffer)
                mov     edi,pjDst           ; edi = destination pointer

                ;***************************************************************
                ; Figure out the appropriate compute routine:
                ;***************************************************************

                mov     ebx,cjPelSize       ; 1,2 or 4
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

                ;***************************************************************
                ; Convert any 'left' bytes present
                ;***************************************************************

            Do_Left_Byte:
                call    pfnCompute          ; DL = 8 bits of monochrome data
                and     dl,jLeftMask        ; Mask off unnecessary bits
                mov     dh,jNotLeftMask     ; Get mask for destination data
                and     dh,[edi]            ; Get bits from dest that we won't touch
                or      dh,dl               ; Get resultant 8 bits of mono data
                mov     [edi],dh            ; Update the destination bitmap
                inc     edi                 ; Advance dst ptr by a byte
                mov     ecx,cjMiddle        ; Check for middle bytes
                dec     ecx                 ; We can skip it if there are none
                jl      short Do_Right_Byte ; Skip middle bytes code

            Do_Middle_Bytes:
                call    pfnCompute          ; DL = 8 bits of monochrome data
                mov     [edi],dl            ; Store the data directly into dst
                inc     edi                 ; Advance dst ptr by a byte
                dec     ecx                 ; Check for remaining middle bytes
                jge     short Do_Middle_Bytes ; Continue processing bitmap

            Do_Right_Byte:
                call    pfnCompute          ; DL = 8 bits of monochrome data
                and     dl,jRightMask       ; Mask off unnecessary bits
                mov     dh,jNotRightMask    ; Get mask for destination data
                and     dh,[edi]            ; Get bits from dest that we won't touch  
                or      dh,dl               ; Get resultant 8 bits of mono data
                mov     [edi],dh            ; Update the destination bitmap
                inc     edi                 ; Advance the dst ptr by a byte

                add     edi,lDstDelta       ; Advance dst bitmap ptr by a scanline
                add     esi,lSrcDelta       ; Advance src (tmp buffer) ptr by a scanline
                dec     cyToGo              ; Continue converting next scanline              
                jnz     short Do_Left_Byte  ; Check if we're done

                jmp     All_Done            ; We're done

                ;***************************************************************
                ; Convert 8bpp color bitmap to 1bpp monochrome
                ;***************************************************************

            Compute_Destination_Byte_From_8bpp:

                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl               ; Bit 7

                add     esi,8               ; Advance the source
                ret

                ;***************************************************************
                ; Convert 16bpp color bitmap to 1bpp monochrome
                ;***************************************************************

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl               ; Bit 7

                add     esi,16              ; Advance the source
                ret

                ;***************************************************************
                ; Convert 32bpp color bitmap to 1bpp monochrome
                ;***************************************************************

            Compute_Destination_Byte_From_32bpp:

                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl               ; Bit 7

                add     esi,32              ; Advance the source
                ret

All_Done:
                }   

            } while (cyToGo > 0);

#else // _WIN64

#define CONVERT_TO_MONO(Src, Dst)                                         \
    {                                                                     \
    BYTE jVal = 0;                                                        \
    BYTE *DstPtr = Dst;                                                   \
    LONG i, j;                                                            \
                                                                          \
    do  {                                                                 \
        for (i = 0; i < 8; i++)                                           \
            jVal = (jVal << 1) + (*(Src)++ == ulForeColor);               \
        *DstPtr++ = (jVal & jLeftMask) | (*DstPtr & jNotLeftMask);        \
        for (j = 0; j < cjMiddle; j++)  {                                 \
            for (i = 0; i < 8; i++)                                       \
                jVal = (jVal << 1) + (*(Src)++ == ulForeColor);           \
            *DstPtr++ = jVal;                                             \
            }                                                             \
        for (i = 0; i < 8; i++)                                           \
            jVal = (jVal << 1) + (*(Src)++ == ulForeColor);               \
        *DstPtr++ = (jVal & jRightMask) | (*DstPtr & jNotRightMask);      \
        (BYTE *)(Src) += lSrcDelta;                                       \
        DstPtr += lDstDelta;                                              \
        } while (--cyToGo > 0);                                           \
    }

        switch (cjPelSize)
            {
            case 1:
               jSrcPtr = (BYTE *)soTmp.pvScan0;
               CONVERT_TO_MONO(jSrcPtr, pjDst);
               break;
            case 2:
               sSrcPtr = (USHORT *)soTmp.pvScan0;
               CONVERT_TO_MONO(sSrcPtr, pjDst);
               break;
            case 4:
               lSrcPtr = (ULONG *)soTmp.pvScan0;
               CONVERT_TO_MONO(lSrcPtr, pjDst);
               break;
            }

#endif // _WIN64

        prcl++;
        } while (--c != 0);


    return(status);

    }
    


    
//******************************************************************************
//
//  Function:   NV4ScreenToMemBlt
//
//  Routine Description:
//
//      Does a screen-to-memory blt (called when bitmap formats from src to 
//      dest are the same; THERE IS NO COLOR TRANSLATION GOING ON.)
//
//      Ask a DMA transfer to the hardware;
//      The Xfer is from VRAM to the locked MEM2MEM buffer in 
//      PDEV. Then, it transfers the content of the buffer to the actual dest. surface
//      (with normal, cpu transfer).
//      (The SRC bitmap must be in VRAM.)
//
//      Since there is no translation going on, if we could lock the dest. surface
//      and *quickly* create a dma context on-the-fly out of this surface, we 
//      could avoid using a intermediate buffer.  But DMA context allocation is
//      slow so...   
//
//      ***IMPORTANT*** Read comments about assumptions this function makes
//
//
//  Arguments:
//
//      (see header)
//
//  Return Value:
//
//      BOOL :  TRUE if call succeeded, else, FALSE.
//
//  Comments:
//
//      At the time of it's writing, this function makes these asumptions:
//
//          - A surface that has it's bitmap in VRAM can be a GDI managed DIB
//            (no DSURF associated, psoSrc->dhsurf == NULL )
//            if and only if it is the primary surface (what most
//            comments in the whole display driver code call the "SCREEN"), that
//            is, the surface which has PDEV.pjScreen as it's associated bitmap.
//          - Otherwise the surface is device managed and has a DSURF struct
//            associated with it
//          - We use PDEV.cjPelSize to know the number of bytes per pixel
//            EVEN when dealing with a src surface that is NOT the primary
//            one (the one which is actually associated with the PDEV).  So,
//            how come can we say that cjPelSize FROM PDEV is really the format
//            of our src bitmap ?  Because right now, the display memory must
//            contain only bitmaps of the same format.
//
//      (this is the way the whole NV display driver is done at this time)
//  
//          - Like ScreenTo1Bpp, this function assumes that the array of rectangles
//            that constrain (clip) the DST rectangle are already INSIDE this 
//            dst rectangle (so, already clipped by it).
//
//          - Like DMAGetScreenBits, this function makes assumption about the 
//            the value of the static data of the MEM_TO_MEM nv object.
//            It assumes that the SetContextDmaBufferIn() has been set to
//            the VRAM dma context, and that SetContextDmaBufferOut() has
//            been set to the mem2mem DMA buffer
//
//      Instead of using a temp SURFOBJ and passing the call to GetScreenBits
//      like in ScreenTo1Bpp, I have coded a different algo here, where I 
//      directly initiate
//      the transfer. That way, we don't have to use a temp SURFOBJ, and
//      we have more control over the DMA transfer. That is, we 
//      initiate transfer for a certain number of bytes (or pixels) and 
//      wait for a notifier event. When this first part of the transfer is 
//      finished, we initiate the next transfer and start copying from 
//      the mem2mem locked buffer to the final dest surface. This enable
//      parallel tranfer from/to the intermediate mem2mem buffer and almost
//      eleminate the overhead of this inter. buffer.  In fact, only the first
//      fill of this buffer would be overhead in the ideal case. But to really
//      be optimal we would have to determine HOW MANY pixels/bytes
//      to copy at each tranfer ? ( I've done a math model for this xfer case
//      that I tried to optimize after that.  From this, I did the whole 
//      calibration, and optbytesperxfer calcultion algorythm.  This is the 
//      only thing in this function that is not too well documented)
//
//        - Stephane
//
//
//******************************************************************************
                                         

#define  CALIBRATION_ENABLED        // Enable calibration

    
#ifdef  CALIBRATION_ENABLED
    
//****************************************
//    For fast MSBit position localization
//****************************************

BYTE Byte2_MSBitPos_LUT[256] = {

    0,  0,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  
    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
};
    

//*****************************************
//    For fast int squareroot approximation
//*****************************************

ULONG BitPos2SquRtAprox_LUT[32] = {

           1,           2,           2,           3,           5,           7,
          10,          14,          20,          28,          39,          55,
          78,         111,         157,         222,         314,         443,
         627,         887,        1254,        1774,        2508,        3547,
        5017,        7094,       10033,       14189,       20066,       28378,
       40132,       56756

};

#endif



BOOL NV4ScreenToMemBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;                // Total number of lines left to Xfer

    ULONG           bytes2Xfer;               // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;             // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;          // Optimal bytes per Xfer (calculated based on mathematic model 
                                              // and profiling data, see notes)
    ULONG           linesPerXfer;             // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;         // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;         // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;                // Pitch of the source surface
    
    LONG            lDstPitch;                // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;                // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;             // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;          // Pointer to the beg. of the dest. bits (in the final surface)
                                              // (will also be incremented to advance in the destination bits during xfer)
    
    BYTE*           pjDmaRead;                // Pointer in the mem2mem dma buffer that we are going to use in the
                                              // CPU-Xfers to keep track of where we are currently reading 
    
    
    BYTE*           pjDmaRead_lastXfer;       // Var to hold where to read the last CPU-Xfer

    BYTE*           pjDmaRead_start;          // Start of the Mem2Mem buffer

    BYTE*           pjDmaRead_2ndPart;        // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;             // Left top corner of current clipped region/rectangle in Src surface
                                              // to xfer
    
    ULONG           DstDMAOffset;             // Offset (relative to DMA base)
                                              // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;             // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset;      // Offset of the 2nd part of the Mem2Mem buffer
       
    NvNotification* pNotifier;                // Pointer to MemToMem notifier array

    DECLARE_DMA_FIFO;                         // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
                                          
    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));

    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
                
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMemBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMemBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMemBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMemBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMemBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMemBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMemBlt: NULL destination rectangle supplied !" );

    ASSERTDD( psoDst->iBitmapFormat == ppdev->iBitmapFormat,
              "NV4ScreenToMemBlt: Src and Dst bitmap formats must be the same" ); // ok

    ASSERTDD( (pxlo==NULL) || (pxlo->flXlate & XO_TRIVIAL),
              "NV4ScreenToMemBlt: Non-trivial color Xlation asked"); // ok

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMemBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************


    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }

    //UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
    //NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer                      
    //
    // let it be there until the next xfer...
    //

    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pjDmaRead_start   = ppdev->pMemToMemBuffer;  
    pjDmaRead_2ndPart = (BYTE *)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1);
    
    
    //**************************************************************************
    //  Transfer all rectangles regions in the array
    //**************************************************************************
    
    for(i=0; i < c; i++) // For all rectangles
    {
        // Calculate the number of bytes it takes to hold this bitmap that
        // we want to transfer.

        height = parcl[i].bottom - parcl[i].top;        // parcl[i]
        width  = parcl[i].right - parcl[i].left;
               
        bytesPerLine = width * ppdev->cjPelSize;        // This value is reused later
        bytes2Xfer   = height * bytesPerLine;
        
        // ( We check if the Mem2Mem buffer is large enough later )


        //**********************************************************************
        //
        // Decide the number of lines to Xfer at a time. We must round to a #
        // of lines for each rectangle because MEM2MEM objects Xfer by count 
        // of lines, so we can't stop in the middle
        // of a line, and start a Xfer with the width of the first line to xfer
        // being different from the width of all of the lines following it.
        //
        //**********************************************************************

        // (Use optimal equation with profiling data)
        //
        // I have modified the Newton method using a lut so that 
        // I can have a nearly perfect INT result of the square root
        // with only 2 iterations.
        //
        // to calculate optBytesPerXfer = squareroot(bytes2Xfer*overhead_of_setup*average_speed_of_dma_xfer)
        //
        // We already have squareroot(overhead_of_setup*average_speed_of_dma_xfer) in the global
        // var "globalXferOverheadFactor"
        //

        //optBytesPerXfer = bytesPerLine;      // Force perscanline xfers for the moment (test)

        //optBytesPerXfer = bytes2Xfer;        // Force non-overlapping xfer (test)



        #ifdef  CALIBRATION_ENABLED

        // We are going to compute a fast squareroot (of a 32bit int)
        // (see notes for more detail -stephane)
        
        // - First, find the position of the MSBit in the 32 bits

        if ( (bytes2Xfer & 0xFFFF0000 ) != 0 ) 
        {
            // Search in the MSWord

            tempUlong = (bytes2Xfer & 0xFF000000);

            if ( tempUlong != 0 ) 
            {
                // the MSBit is in this MSByte, let the LUT do the rest of the job
                
                // ( bytes2Xfer >> 24 ) slide the MSByte in the LSByte position
                
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 24 ] + 24;
            }
            else // the  LSByte of the MSWord contains the bit we are looking for
            {
                // Our number is 0x00??????
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 16 ] + 16;
            }

        }
        else
        {
            // Search the LSWord
            
            tempUlong = (bytes2Xfer & 0x0000FF00);

            if ( tempUlong != 0 ) 
            {
                // the MSBit is in this MSByte of the LSWord let the LUT do the rest of the job

                // ( bytes2Xfer >> 8 ) slide the MSByte in the LSByte position

                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 8 ] + 8;
            }
            else // the  LSByte of the LSWord contains the bit we are looking for
            {
                // Our number is 0x000000??
                
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer ];
            }
        
        } // ... else the MSBit is in the LSWord of our 32 bit "bytes2Xfer" number

        //
        // We now have msbitPos, plug it into the other LUT to get a very good
        // initial approximation of the squareroot of bytes2Xfer.
        //

        tempUlong = BitPos2SquRtAprox_LUT[ msbitPos ];
        
        // Do Newton 2 times 
        // We could actually use only 1 iteration and it would be enough for our
        // needs.

        tempUlong = (tempUlong + bytes2Xfer/tempUlong) >> 1 ;
        tempUlong = (tempUlong + bytes2Xfer/tempUlong) >> 1 ;
        
        // We now have our squareroot(bytes2Xfer), all we need is to mul it
        // by our profiled constant

        optBytesPerXfer = tempUlong * ppdev->globalXferOverheadFactor;
                                

        #else  // else if NOT #ifdef  CALIBRATION_ENABLED
        
        optBytesPerXfer = bytesPerLine << 3;   //Force per-8-scanline xfers
        
        //optBytesPerXfer = bytes2Xfer;        // Force non-overlapping xfer (test)

        #endif // ...#ifdef  CALIBRATION_ENABLED        
        

        //**********************************************************************
        // We have our optBytesPerXfer, now convert it in linesPerXfer
        //**********************************************************************

        // But first check if the Mem2Mem buffer is large enough to hold 2 chunks
        // of this size

        // NOTE:
        //
        // ( We try to reduce the Xfer size to 1 scanline (the minimum);
        //   we could try reducing it by half and recheck, but it's not
        //   really worth it, if mem2mem buffer is too small, we are
        //   already in a case that will be handled more slowly )
        
        
        // Check if we are not in the special case where it is more
        // efficient to do the xfer without overlapping ( in that case,
        // we need "bytes2Xfer" bytes in the mem2mem buffer)
        // (Clamp optBytesPerXfer to bytes2Xfer in that case)

        if( optBytesPerXfer > bytes2Xfer )                  
        {
            optBytesPerXfer = bytes2Xfer;  // clamp the size of the chunk
                                           // to total bytes to xfer

            if( optBytesPerXfer > ppdev->MemToMemBufferSize )
            {
                // We must do one xfer, but mem2membuffer is too small.
                // Reduce it to the minimum
    
                optBytesPerXfer = bytesPerLine;
    
                if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                
                    return(FALSE);  // we can't even store 2 scanlines!
            }
        
        } // ...if optxfersize > total2xfer
        
        //  Else, check if we need to clamp to at least 1 scanline
        // (indeed, if optBytesPerXfer calculated is
        //  lower than a scanline, we are going to use
        //  a scanline-based transfer anyway, so we
        //  must check the size of mem2mem buffer VS 
        //  at least a scanline )
        
        else if( optBytesPerXfer < bytesPerLine )
        {                
            optBytesPerXfer = bytesPerLine;
            
            if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                
                return(FALSE);  // we can't even store 2 scanlines!
        }            

        // Else optBytesPerXfer is within boundaries, check if we can
        // store two chunks of that size

        else if( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )
        {
            // Mem2Mem buffer size is too small for the size of 2 Xfer chunks.
            // Try to reduce the xfer chunk to the minimum
        
            optBytesPerXfer = bytesPerLine;
        
            if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                
                return(FALSE);  // we can't even store 2 scanlines!
        }


        // There are many ways to round: clamp to unit by truncating, or clamp to
        // higher unit as soon as there is a rest, etc.  Simplest is truncating
        //
        
        linesPerXfer = ( optBytesPerXfer / bytesPerLine );

       
        // Clamp to higher unit instead of truncate with ( bytesPerXfer / bytesPerLine );
        //
        // Let's limit bytersPerXfer to 33 MB, so we have 7 bits (MSBits) out of
        // 32 to use to do fixed point math. ( 32-7 = 25, 2^25 = 33 MB )
        //
        // [ (bytesPerXfer << 7 ) / ( bytesPerLine << 7 )  + 0x7F (which is 1111111b) ]  >> 7        
                

        

        //**********************************************************************
        //  An object of NV_MEM_TO_MEM class must be attached to 2 DMA contexts.
        //  The src and dst must be given through method writes, and these src
        //  and dst ptr must be in offset RELATIVE to the address of the BASE
        //  (so relative to the beginning) of the DMA region.
        //
        //  So, we are going to:
        //
        //      - First, find the coordinates of the current clip rectangle
        //        in the SRC RECTL. (see below)
        //      - Find the offset in byte of these coordinates, relative to the
        //        beginning of the source bits, and find the absolute address 
        //        of these coordinates by adding the base of the source bits.        
        //      - Substract the base of the DMA region from this ptr to obtain
        //        an offset relative to the base.
        //
        //**********************************************************************

        
        //**********************************************************************
        //      - First, find the coordinates of the current clip rectangle
        //        in the SRC RECTL. (see below)
        //**********************************************************************

        
        //**********************************************************************
        //
        //          1) pptlSrc->x    ( value x1 shown below )
        //
        //          2) prclDst->x    ( value x2 shown below )
        //
        //                  Location of the original unclipped destination rectangle
        //
        //          3) parcl[i]       ( value x3 shown below)
        //
        //                  Current clip rectangle with coordinates relative to origin
        //                                                                  of Dst
        //
        //   Origin  (Destination bitmap )
        //  +--------------------------------------------------------------->
        //  |
        //  |
        //  |           x2 = prclDst->left
        //  |           +-----------------------------------------------
        //  |           |                              ^                |-Original
        //  |           |                              | dySrc          |  Unclipped
        //  |           |                              |                |   Destination
        //  |           |         x3 = parcl[i].left   v                |    Rectangle
        //  |           |         +------------        -                |
        //  |           |         |            |                        |
        //  |           |<-dxSrc->|            |                        |
        //  |           |         |            |                        |
        //  |           |         |            |-Current                |
        //  |           |         |            |  Clip                  |
        //  |           |          ------------    Rectangle            |
        //  |           |                                               |
        //  |           |                                               |
        //  |           |                                               |
        //  |            -----------------------------------------------
        //  |
        //  v
        //
        //
        //           Origin (Source bitmap)
        //          +--------+--|-----+--------+------->
        //          |           x1
        //          |
        //          |
        //          |
        //          |           ^
        //          v           |
        //          |           |
        //          |           |
        //          |-- x1 ---->|   x1 = pptlSrc->x
        //          |           +-----------------------------------------------
        //          |           |                             ^                 |-Source
        //          |           |                             | dySrc           | Rectangle 
        //          |           |                             |                 |   
        //          |           |         x? = x1 + dxSrc     v                 |    
        //          |           |         +------------       -                 |
        //          |           |         |            |                        |
        //          |           |<-dxSrc->|            |                        |
        //          |           |         |            |                        |
        //          |           |         |            |-Current                |
        //          |           |         |            |  Clip                  |
        //          |           |          ------------    Rectangle            |
        //          |           |                        ( but in SRC surface)  |
        //          |           |                                               |
        //          |           |                                               |
        //          |            -----------------------------------------------
        //
        //**********************************************************************


        ptlSrcRegion.x  = pptlSrc->x + (parcl[i].left - prclDst->left);
        ptlSrcRegion.y  = pptlSrc->y + (parcl[i].top  - prclDst->top);

        //**************************************************************************
        //      - Find the offset in byte of these coordinates, relative to the
        //        beginning of the source bits, and find the absolute address 
        //        of these coordinates by adding the base of the source bits.        
        //
        // (Calculate the pointer to the upper-left corner of Source clipped region)
        //**************************************************************************
        
        pjSrcRclBits    =     pjSrcBits                             // base of Src Bits
                              + ( ptlSrcRegion.y  * lSrcPitch ) 
                              + ptlSrcRegion.x * ppdev->cjPelSize ;   
                                // CONVERT_TO_BYTES(x,pdev) == (x) * pdev->cjPelSize        

        
        // We don't have to calculate the dst address for the DMA transfer: 
        // we have it, it is the dst
        // of the mem2mem DMA buffer, but we have to calculate the address in
        // the final destination surface, for the cpu transfer

        //**************************************************************************
        // Calculate the pointer to the upper-left corner of Destination clipped region
        // (THE FINAL DESTINATION, not the MEM2MEM buffer)
        //**************************************************************************

        pjFinalDstWrite =  (BYTE*) psoDst->pvScan0 
                          + ( parcl[i].top  * lDstPitch )
                          + ( parcl[i].left * ppdev->cjPelSize );
                            
                            // Remember, we don't do any format conversion, and the
                            // src is in screen mem, and the format descriptor of
                            // the src mem is the pdev. That's why we can use
                            // pdev->cjPelSize to
                            // calculate an "x" offset from pixel to bytes.
        
        //**************************************************************************
        //
        //  Now, we need to setup the first Xfer, wait for it to end, and enter
        //  the main Xfer loop, were we kick a Xfer for the next chunk, and Xfer
        //  the last chunk from mem2mem buffer to final sys mem destination.
        //  Finally, we are going to Xfer the remaining data 
        //  ( total_lines_to_xfer % optimal_lines_by_xfer )
        //  
        //**************************************************************************


        //**************************************************************************
        // Calculate the offsets of the transfer src and dst from the beginning of 
        // their respective DMA region base
        //**************************************************************************

        DstDMAOffset = 0;         // Init the current DMAoffset where to write
        
        
                                  // Init current source DMAoffset where to read

        SrcDMAOffset = (ULONG)( pjSrcRclBits - ppdev->pjFrameBufbase ); 
                                  // We are assuming that base of VRAM DMA context
                                  // is == pjFrameBufbase, that is, that the DMAoffset of pjFrameBufbase
                                  // is always 0. That's why we use ppdev->pjFrameBufbase for
                                  // base of DMA region
        
        //**********************************************************************
        //
        // Precalculate the num of bytes to add to the SrcDmaOffset for each 
        // transfer and the address of the second chunk in the DstDMA 
        // (the mem2mem buffer) 
        //
        // ( We could use linesPerXfer * bytesPerLine,
        // and that would also be the number of bytes to add to the
        // DstDmaOffset if we would be user a mem2mem buffer the size of the
        // whole transfer. In other words, not using the strict minimum to be
        // able to do overlapping, that is 2 chunks in the buffer (one to which
        // DMA write, the other to which CPU read, and then, the opposite...)
        // 
        // Instead we use ppdev->MemToMemBufferSize/2, because that value never
        // changes (for any xfer size), so we can put that calculation out of
        // the rectangle loop. (for all rectangles)
        //
        //
        // Also init some variables before going on to the Xfers
        //
        // Reminder: the pitch include the linelenght (bytesperline)!
        //**********************************************************************
        
        
        //DstDMA2ndPartOffset   =  (ppdev->MemToMemBufferSize >> 1);  does not change
        SrcDMAincPerXfer      = linesPerXfer * lSrcPitch;

        
        // Calculate the jump to get to the next line of the 
        // final destination rectangle (in the final Dst surface)
        // AFTER having transfered "bytesPerLine" (in other words,
        // pitch is the num of bytes to the jump AT THE SAME POSITION
        // in the bitmap but one line lower; what we want is the jump
        // value to jump from the end of a line TO THE BEGINNING
        // of the next line )
        
        FinalDstJump2NextLineBeg = lDstPitch - bytesPerLine;

        
        //pjDmaRead_start        = ppdev->pMemToMemBuffer;  // These var will not change for different rectangles

        //pjDmaRead_2ndPart      = ppdev->pMemToMemBuffer + (ppdev->MemToMemBufferSize >> 1);

        
        pjDmaRead                = pjDmaRead_start;  // Init the reading ptr for the second
                                                     // transfer "pipe" (the CPU-Xfers)
        
        linesToGo                = height;           // Init the number of lines left to transfer


        
        
        //**********************************************************************
        //                      Setup the first transfer
        //
        //  NOTE: Somebody looking at this code (further below) might think:
        //        why doing this first xfer outside of the main xfer loop ? 
        //        "Everything looks the same inside the loop"  This is not
        //        exactly right: the loop is done so when it rolls we wait 
        //        for the last notifier being setup, just before resetting 
        //        this notifier and kicking off the new transfer. If we would
        //        remove that special-casing of the first xfer, we would be 
        //        waiting inside the start of the xfer loop forever because
        //        no xfer has been setup yet...
        //
        //
        //**********************************************************************

        //**********************************************************************
        // Set methods for memory_to_memory dma blit
        //   NV039_OFFSET_IN                                            
        //   NV039_OFFSET_OUT                                           
        //   NV039_PITCH_IN                                             
        //   NV039_PITCH_OUT                                            
        //   NV039_LINE_LENGTH_IN                                       
        //   NV039_LINE_COUNT                                           
        //   NV039_FORMAT                                               
        //   NV039_BUFFER_NOTIFY                                        
        //**********************************************************************

        //**************************************************************************
        // Check if we've got enough room in the push buffer
        //**************************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));

        //**************************************************************************
        // Set notifier to 'BUSY' value (use second notification structure)
        //**************************************************************************

        pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

        NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
        NV_DMA_FIFO = SrcDMAOffset;                             // Offset In
        NV_DMA_FIFO = DstDMAOffset;                             // Offset Out
        NV_DMA_FIFO = lSrcPitch;                                // Pitch In
        NV_DMA_FIFO = bytesPerLine;                               // Pitch Out == bytesPerLine because
                                                                  // we dont want any memory "hole" between
                                                                  // two contiguous lines in the mem2mem buffer

        NV_DMA_FIFO = bytesPerLine;                             // Line Length in bytes
        NV_DMA_FIFO = linesPerXfer;                             // Line Count (num to copy)
        NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | 
                      NV_MTMF_FORMAT_OUTPUT_INC_1;              // Format
        NV_DMA_FIFO = 0;                                        // Set Buffer Notify and kickoff

        //**************************************************************************
        // Update global push buffer count
        //**************************************************************************

        UPDATE_PDEV_DMA_COUNT;

        //**************************************************************************
        // Send data on thru to the DMA push buffer
        //**************************************************************************

        NV4_DmaPushSend(ppdev);

        //**************************************************************************
        // Here we incremented the offsets before the Xfer completes, so we can
        // cover a bit the processing (make these calculations during the time
        // the first Xfer execute)
        //**************************************************************************

        linesToGo       -= linesPerXfer;          // Susbtract the lines that have been done.
        SrcDMAOffset    += SrcDMAincPerXfer;      // Advance in the source DMA region
        DstDMAOffset     = DstDMA2ndPartOffset;   // Advance in the dest. DMA region
                                                  // (the mem2mem buffer) so we use the 
                                                  // 2nd part the next time.

        //
        // REMINDER: ANY CODE FOLLOWING THIS MUST CHECK THE NOTIFIER
        // IF IT WANTS TO BE SURE THAT THE MEM2MEM BUFFER DATA IS VALID
        //
        
        //***[ Make sure there are still enough lines to Xfer before starting  *****
        //*                                                  another DMA Xfer ]    *
        
        if ( linesToGo < linesPerXfer )  // if there are not "linesPerXfer" lines to Xfer
        {
            // Now what is left is a CPU Xfer of "linesPerXfer" plus at most
            // one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...
            //
            // We save the value to which we must set the position of pjDmaRead
            // for the very last CPU read ( of size height % linesPerXfer)
    
            pjDmaRead_lastXfer = pjDmaRead_2ndPart;
        

        } // ...if there are less than linesPerXfer left to Xfer
        
        else
        {
            //  else, enter the main Xfer loop.
        
            //**************************************************************************
            //                Main transfer loop with overlapping Xfers
            //
            //  Note that we are starting to setup the next DMA
            //  xfer even before checking if the last one is finished. We only do so
            //  at the last minute, before resetting the notifier, and kicking the next
            //  DMA Xfer for maximum overlapping of processing
            //
            //
            //**************************************************************************                        
        
            for(;;)   // (for all Xfers that can be done in linesPerXfer chunks):
                      // - this is a 2 part loop with 
                      //   2 breakout cases, so that's why we use a for(;;))
                      //   (2 cases because we are doing either one or the other part of
                      //   the mem2mem buffer)
            {
                //
                // START another DMA-Xfer:    remember, we use ( 2*bytesperxfer ) bytes
                //                            in our Mem2Mem buffer. (So we alternate
                //                            using it's two parts )
                //
                //                            We started Xfering to the first part
                //                            (before entering the loop, and at the end
                //                            of this for(;;) loop),
                //                            (the NV hw is writting to the first part)
                //                            so we are going to read from that first part
                //                            while we kick another Xfer in the second
                //                            part.
                //
                // (Note that the first time we enter this loop, we will wait without
                //  overlapping: this is normal, we need to wait for the **FIRST** xfer
                //  to be done, because in the other part of the 2part buffer, there
                //  isn't any data available yet for our CPU.)
                //          

                //---[ So now: ]-------------------------
                //                                      -
                // DstDMAOffset == DstDMA2ndPartOffset; -
                //    pjDMAread == pjDmaRead_start;     -
                //                                      -
                //---------------------------------------

                //
                // START another DMA-Xfer
                //
    
    
                NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  

                NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
                NV_DMA_FIFO = SrcDMAOffset;                             // Offset In
                NV_DMA_FIFO = DstDMAOffset;                             // Offset Out
                NV_DMA_FIFO = lSrcPitch;                                // Pitch In
                NV_DMA_FIFO = bytesPerLine;                               // Pitch Out == bytesPerLine because
                                                                          // we dont want any memory "hole" between
                                                                          // two contiguous lines in the mem2mem buffer

                NV_DMA_FIFO = bytesPerLine;                             // Line Length in bytes
                NV_DMA_FIFO = linesPerXfer;                             // Line Count (num to copy)
                NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | 
                              NV_MTMF_FORMAT_OUTPUT_INC_1;              // Format
                NV_DMA_FIFO = 0;                                        // Set Buffer Notify and kickoff
    
                //**************************************************************************
                // Wait for the last DMA-Xfer kicked to be completed (use second notification structure)
                // ( if it is not yet completed )
                //**************************************************************************
    
                while ( pNotifier->status != 0 );
    
    
                //**************************************************************************
                // Set notifier to 'BUSY' value (use second notification structure)
                //**************************************************************************
    
                pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
    
                UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
                NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer
    
    
                linesToGo    -= linesPerXfer;          // Susbtract the lines that have been done.
                SrcDMAOffset += SrcDMAincPerXfer;      // Advance in the source DMA region (VRAM)
                DstDMAOffset  = 0;                     // Go back to the first part of the mem2mem
                                                       // DMA buffer in the next DMA Xfer.
    
                //**************************************************************************
                //  In the meantime, CPU-Xfer what has been DMA-Xfered.
                //
                //  Note that here we have two chases that can go on: if DMA-Xfer is faster,
                //  the while(!notified) active-wait will always be true by the time we
                //  get here. We could, to be fancier, check after a certain number of bytes
                //  CPU-Xfered, if the notification has been trigered (using the profiling
                //  data, we can do it), but it's not really worth it. Indeed, if the DMA-Xfer
                //  is faster, and we launch more than 1 per CPU-Xfered-chunk, (let's say 1.2
                //  on average), at the end, all the DMA-Xfers will be over, yes, and the 
                //  hardware will be idle yes, but we will still have to finish here, in this
                //  function, with our CPU transfer, and THAT is going to be the limiting speed.
                //  (And since the driver is not re-entrant, the idle hardware won't be used
                //  anyway during this time)
                //  Repeat a similar reasoning for the other chase condition, that is,
                //  if the CPU-Xfers are faster than the DMA-Xfers.
                //**************************************************************************
    
                //
                // NOTE: The next loop can be optimized...
                //
    
                // Xfer all lines
                //
                for(j=0; j < linesPerXfer; j++)
                {            
                    // Xfer a whole line
                    //
                    for(limit = pjDmaRead + bytesPerLine; 
                        pjDmaRead < limit; 
                        pjDmaRead++, pjFinalDstWrite++ )
                    {
                        *pjFinalDstWrite = *pjDmaRead ;
                    }
    
                    pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                                 // next line in the dest surface
    
                } // ...for all bytes in chunk to cpu-xfer
    
                // Set our pjDmaRead ptr at the beginning of the second part of our mem2mem buffer
                // (For the next CPU-Xfer)

                pjDmaRead = pjDmaRead_2ndPart;

                //
                // ... CPU Xfer done.                    
                
                
                //***[ Make sure there are still lines to Xfer before starting         *****
                //*                                                  another DMA Xfer ]    *

                if ( linesToGo < linesPerXfer )  // if there are no more chunk to Xfer
                {
                    
                    // Now what is left is a CPU Xfer of "linesPerXfer" plus at most
                    // one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...
                    //
                    // We save the value to which we must set the position of pjDmaRead
                    // for the very last CPU read ( of size height % linesPerXfer)
    
                    pjDmaRead_lastXfer = pjDmaRead_start;
                    
                    break;          // break out of the Xfer loop (for(;;))
                }
                //*                                                                        *
                //**************************************************************************
                                    
                //
                // START another DMA-Xfer:    Remember, we use ( 2*bytesPerXfer ) bytes
                //                            in our Mem2Mem buffer. (So we alternate
                //                            using it's two parts )
                //
                //                            The last Xfer kicked used the 2nd part.
                //                            Next Xfer is going to use the first part
                //                            again.
        
                //---[ So now: ]-------------------------
                //                                      -
                // DstDMAOffset == 0;                   -
                //    pjDMAread == pjDmaRead_2ndPart;   -
                //                                      -
                //---------------------------------------

        
                NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  
        
                NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
                NV_DMA_FIFO = SrcDMAOffset;                         // Offset In
                NV_DMA_FIFO = DstDMAOffset;                         // Offset Out
                NV_DMA_FIFO = lSrcPitch;                            // Pitch In
                NV_DMA_FIFO = bytesPerLine;                         // Pitch Out == bytesPerLine because
                                                                      // we dont want any memory "hole" between
                                                                      // two contiguous lines in the mem2mem buffer
                NV_DMA_FIFO = bytesPerLine;                         // Line Length in bytes
                NV_DMA_FIFO = linesPerXfer;                         // Line Count (num to copy)
                NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | 
                              NV_MTMF_FORMAT_OUTPUT_INC_1;          // Format
                NV_DMA_FIFO = 0;                                    // Set Buffer Notify and kickoff
        
        
                //**************************************************************************
                // Wait for the last DMA-Xfer kicked to be completed (use second notification structure)
                // ( if it is not yet completed )
                //**************************************************************************
        
                while ( pNotifier->status != 0 );
        
        
                //**************************************************************************
                // Set notifier to 'BUSY' value (use second notification structure)
                //**************************************************************************
        
                pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        
                UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
                NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer
        
        
                linesToGo       -= linesPerXfer;          // Susbtract the lines that have been done.
                SrcDMAOffset    += SrcDMAincPerXfer;      // Advance in the source DMA region (VRAM)                    
                DstDMAOffset     = DstDMA2ndPartOffset;   // Advance in the dest. DMA region
                                                          // (the mem2mem buffer) so we use the 
                                                          // 2nd part the next time.
        
                //**************************************************************************
                //  In the meantime, CPU-Xfer what has been DMA-Xfered in the 2nd part
                //**************************************************************************
                
                // Xfer all lines
                //
                for(j=0; j < linesPerXfer; j++)
                {            
                    // Xfer a whole line
                    //
                    for(limit = pjDmaRead + bytesPerLine; 
                        pjDmaRead < limit; 
                        pjDmaRead++, pjFinalDstWrite++ )
                    {
                        *pjFinalDstWrite = *pjDmaRead ;
                    }
    
                    pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                                 // next line in the dest surface
    
                } // ...for all bytes in chunk to cpu-xfer
                
                // Set our pjDmaRead ptr at the beginning of the first part of our mem2mem buffer
                
                pjDmaRead = pjDmaRead_start;                 // Reset the read ptr at the 
                                                             // first part (beginning) of the
                                                             // MEM2MEM buffer
                // ... CPU Xfer Done.
                

                //***[ Make sure there are still lines to Xfer before starting         *****
                //*                                                  another DMA Xfer ]    *
                
                if ( linesToGo < linesPerXfer )  // if there are no more lines to Xfer
                {
                    
                    // Now what is left is a CPU Xfer of "linesPerXfer" plus at most
                    // one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...
                    //
                    // We save the value to which we must set the position of pjDmaRead
                    // for the very last CPU read ( of size height % linesPerXfer)
    
                    pjDmaRead_lastXfer = pjDmaRead_2ndPart;

                    break;          // break out of the Xfer loop (for(;;))

                } // ...if there are less than "linesPerXfer" left to Xfer
                
                //*                                                                        *
                //**************************************************************************

    
            } // ...for(;;)  ( while(linesToGo >= linesPerXfer )  )
              // 
              // (this is a special cased 2 part loop)

        
        } //  ...else enter the main Xfer loop (if there are at least linesPerXfer left to Xfer)

        //**************************************************************************
        //
        //                Last transfer: Time to execute the last transfer
        //
        //  There is at most one DMA transfer left to execute, and at most 2 mem2mem
        //  chunks to transfer (the last DMA that is about to be completed, and the 
        //  one that we are about to start, if there is one)
        //
        //**************************************************************************

        if ( linesToGo == 0 ) // only 1 CPU-Xfer left to execute
                              // (that means that totalLinesToXfer was a multiple
                              // of linesPerXfer, => total % linesPerXfer == 0
        {
            //**************************************************************************
            // Wait for the last DMA to be completed (use second notification structure)
            //**************************************************************************

            while ( pNotifier->status != 0 );

            // Xfer the last "linesPerXfer" lines
            //
            for(j=0; j < linesPerXfer; j++)
            {            
                // Xfer a whole line
                //
                for(limit = pjDmaRead + bytesPerLine; 
                    pjDmaRead < limit; 
                    pjDmaRead++, pjFinalDstWrite++ )
                {
                    *pjFinalDstWrite = *pjDmaRead ;
                }

                pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                             // next line in the dest surface

            } // ...for all bytes in chunk to cpu-xfer

            //****************************************
            // And this rectangle is done, at last...
            //****************************************

        } // ...if ( linesToGo == 0 )

        else // else, setup one last DMA Xfer
        {
            // This last DMA-Xfer is different in that the line count is
            // linesToGo (the rest of the lines, which is < than our linesPerXfer calculated )
            //

            NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  

            NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
            NV_DMA_FIFO = SrcDMAOffset;                    // Offset In
            NV_DMA_FIFO = DstDMAOffset;                    // Offset Out
            NV_DMA_FIFO = lSrcPitch;                       // Pitch In
            NV_DMA_FIFO = bytesPerLine;                      // Pitch Out == bytesPerLine because
                                                             // we dont want any memory "hole" between
                                                             // two contiguous lines in the mem2mem buffer
            NV_DMA_FIFO = bytesPerLine;                    // Line Length in bytes
            NV_DMA_FIFO = linesToGo;                       // Line Count (num to copy)
            NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
            NV_DMA_FIFO = 0;                               // Set Buffer Notify and kickoff

            //**************************************************************************
            // Wait for the last DMA-Xfer kicked to be completed (use second notification structure)
            // ( if it is not yet completed )
            //**************************************************************************

            while ( pNotifier->status != 0 );


            //**************************************************************************
            // Set notifier to 'BUSY' value (use second notification structure)
            //**************************************************************************

            pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

            UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
            NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer                      

            
            //**************************************************************************
            // Now that this last DMA-Xfer is running, transfer the last "linesPerXfer"
            // long chunk. (this is our last but one CPU-Xfer)
            //                
            // We might think of one complication here: we do not know where we broke in
            // our main for(;;) loop.  So we do not know to which part of the mem2mem 
            // buffer we must read our last cpu xfer. (In other words, where to put the 
            // pjDmaRead ptr. This is solved in the loop by saving the next value to which 
            // it must be set (this is to avoid doing an additionnal "IF" here, to know 
            // were we broke in the for(;;) )
            //
            //**************************************************************************

            // Xfer the "linesPerXfer" lines
            //
            for(j=0; j < linesPerXfer; j++)
            {            
                // Xfer a whole line
                //
                for(limit = pjDmaRead + bytesPerLine; 
                    pjDmaRead < limit; 
                    pjDmaRead++, pjFinalDstWrite++ )
                {
                    *pjFinalDstWrite = *pjDmaRead ;
                }

                pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                             // next line in the dest surface
            } // ...for all bytes in chunk to cpu-xfer

            // Set our pjDmaRead ptr at the beginning of the ? part of our mem2mem buffer
            // (the right part for our last cpu xfer; this was selected in the for(;;)

            pjDmaRead = pjDmaRead_lastXfer;

            
            //**************************************************************************
            // Wait for the LAST DMA-Xfer to be completed
            // ( if it is not yet completed ) and CPU-Xfer these remainder lines
            //**************************************************************************

            while ( pNotifier->status != 0 );


            for(j=0; j < linesToGo; j++)
            {            
                // Xfer a whole line
                //
                for(limit = pjDmaRead + bytesPerLine; 
                    pjDmaRead < limit; 
                    pjDmaRead++, pjFinalDstWrite++ )
                {
                    *pjFinalDstWrite = *pjDmaRead ;
                }

                pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                             // next line in the dest surface

            } // ...for all lines left

            //****************************************
            // And this rectangle is done, at last...
            //****************************************

        } // ...else ( linesToGo != 0 )  ( one last DMA xfer to setup )

    
    } // ...for(i=0; i < c; i++) // For all rectangles
    
    return TRUE;
}

// ...End of NV4ScreenToMem()
    


//******************************************************************************
//  ------------------------------------------------------------------
//            BEGIN NV4ScreenToMem*to*bppBlt FUNCTIONS
//  ------------------------------------------------------------------
//******************************************************************************

//******************************************************************************
//
//  NV4ScreenToMem*to*bppBlt functions and macro definitions for these
//  ------------------------------------------------------------------
//
//
//  NOTE: These macros are NOT meant to be used alone. These uses local variables
//        of NV4ScreenToMem*to*bppBlt functions, and the order in which they are
//        used is obviously important. ( For example, ScreenToMemXbpp_Common must
//        be executed before "height, width, ..." are usable; See ScreenToMem4bpp
//        for an example)
//
//  After the macros, these functions are defined:
//
//      NV4ScreenToMem32to4bppBlt
//      NV4ScreenToMem32to8bppBlt
//      NV4ScreenToMem16to4bppBlt
//      NV4ScreenToMem16to8bppBlt
//
//  These functions do a ScreenToMem Blt (like NV4ScreenToMemBlt) but with
//  color translation between non indexed (high/true color) to indexed color
//  formats (4bpp and 8bpp).  (It seems that this read from frame buffer happens
//  every time a window with very small icons pop, like the advance display applet
//  with the small NV logo, or when going to display properties and listing all
//  available patterns and bmp for the desktop (the icons there) )
//
//  The reason why these different functions are aliased instead of having one
//  NV4ScreenToMemWithXlate function is that we don't want to have a big "IF"
//  in the high level code (bitblt) and then, recheck again the same variables
//  but this time to isolate the cases of the "big IF". (This is similar to
//  the PushXfer??to?? functions...
//
//
//
//      ***IMPORTANT*** Read comments about assumptions these function makes
//                      (further below, after macro descriptions - these 
//                      are the same comments then in NV4ScreenToMemBlt)
//
//
//
//  ---------------------------------------------------------------------------          
//  Macro:                  [ GiveOptBytesPerXfer( optBytesPerXfer ) ]
//
//  Macro Description:      optBytesPerXfer will = optimal num. of bytes/xfer
//
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMemXbpp_Common ]
//
//  Macro Description:      Insert the code common to all core ScreenToMemXbpp
//                          functions in the beginning of the for(all rectangles)
//                          loop.
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMemXbpp_Common2 ]
//
//  Macro Description:      Insert the code common to all core ScreenToMemXbpp
//                          functions.  This contain the core of the transfer
//                          code. The 3th parameter is the name of the macro
//                          to use for all CPUXFER. This macro must accept 
//                          2 params, as described in CpuXferTo4bpp for example
//  ---------------------------------------------------------------------------          
//  Macro:                  [ PushSendDMAXfer_forXlines(linesPerXfer) ]
//
//  Macro Description:      Insert the code to push and send a DMA Xfer for
//                          "linesPerXfer" lines. (Does not update the variables
//                          it uses like "SrcDMAOffset", etc.)
//  ---------------------------------------------------------------------------          
//
//  Macro:                  [ PushWaitSendDMAXfer_forXlines(linesPerXfer) ]
//
//  Macro Description:      Insert the code to push, wait for the last DMA Xfer
//                          to end, reset the notifier and send a DMA Xfer for
//                          "linesPerXfer" lines. (Does not update the variables
//                          it uses like "SrcDMAOffset", etc.)
//  ---------------------------------------------------------------------------          
//
//  Macro:                  [ CpuXferTo4bpp(pxxDmaRead,linesPerXfer) ]
//                          
//  Macro Description:      Core of a CPU Xfer to convert a part of the MemToMem
//                          DMA buffer to 4bpp and write it in the final surface;
//                          This macro is used when we have at least 2 bytes per
//                          scanline (the case when there is a width of 1 or 2       
//                          pixels inside THE SAME byte must be special cased)
//                          
//                          pxxDmaRead is ULONG* if the source is 32bpp, USHORT*
//                          if the source is 16bpp, etc.
//
//                          (Source must be converted from non-indexed,
//                          to indexed)
//
//  ---------------------------------------------------------------------------          
//  Macro:                  [ CpuXferTo4bpp_1ByteWidth(pxxDmaRead,linesPerXfer) ]
//                          
//  Macro Description:      See CpuXferTo4bpp...
//                          
//  ---------------------------------------------------------------------------          
//  Macro:                  [ CpuXferTo8bpp(pxxDmaRead,linesPerXfer) ]
//                          
//  Macro Description:      Core of a CPU transfer when destination is 8bpp 
//                          (and source must be converted from non-indexed,
//                          to indexed)
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMem4bpp_Core(pxxDmaRead, cast) ]
//                          
//  Macro Description:      Core of a ScreenToMem with non-indexed to indexed
//                          translation, when dest. is 4bpp (and scanline is
//                          at least 2 bytes wide) (See CpuXferTo4bpp)
//
//                          The "cast" parameter MUST MATCH the pointer type:
//                          "cast" is (ULONG*) when "pxxDmaRead" is a (ULONG*)
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMem4bpp_Core_1ByteWidth(pxxDmaRead, cast) ]
//                          
//  Macro Description:      Core of a ScreenToMem with non-indexed to indexed
//                          translation, when dest. is 4bpp (and scanline is
//                          1 byte wide) (See CpuXferTo4bpp_1ByteWidth)
//
//                          The "cast" parameter MUST MATCH the pointer type:
//                          "cast" is (ULONG*) when "pxxDmaRead" is a (ULONG*)
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMem4bpp(pxxDmaRead,cast) ]
//                          
//  Macro Description:      Upper level macro to do a StoMblt with non-indexed
//                          to indexed translation, when dest. is 4bpp.
//                          Basically, it has the "for all rectangles" loop,
//                          calculate the "middleWidth" of a scanline and 
//                          exec the appropriate ScreenToMem4bpp_Core macro.
//
//                          The "cast" parameter MUST MATCH the pointer type:
//                          "cast" is (ULONG*) when "pxxDmaRead" is a (ULONG*)
//  ---------------------------------------------------------------------------          
//  Macro:                  [ ScreenToMem8bpp(pxxDmaRead,cast) ]
//                          
//  Macro Description:      Similar to ScreenToMem4bpp...
//                          
//                          
//  ---------------------------------------------------------------------------          
//
//  Here is a figure that shows a "macro-dependancy" example:
//
//                         ScreenToMem32to4bppBlt
//                         |
//                         |
//                         v
//                         ScreenToMem4bpp
//                           |
//                           |
//                           v
//                          .ScreenToMemXbpp_Common
//                          .       |
//                          .       v
//                          .       GiveOptBytesPerXfer
//                          .ScreenToMem4bpp_Core    
//                            |
//                            |
//                            v
//                            ScreenToMemXbpp_Common2
//                              |
//                              |
//                              v
//                             .PushSendDMAXfer_forXlines
//                             .PushWaitSendDMAXfer_forXlines
//                             .CpuXferTo4bpp
//
//  
//  Comments:
//
//      At the time of it's writing, this function makes these asumptions:
//
//          - A surface that has it's bitmap in VRAM can be a GDI managed DIB
//            (no DSURF associated, psoSrc->dhsurf == NULL )
//            if and only if it is the primary surface (what most
//            comments in the whole display driver code call the "SCREEN"), that
//            is, the surface which has PDEV.pjScreen as it's associated bitmap.
//          - Otherwise the surface is device managed and has a DSURF struct
//            associated with it
//          - We use PDEV.cjPelSize to know the number of bytes per pixel
//            EVEN when dealing with a src surface that is NOT the primary
//            one (the one which is actually associated with the PDEV).  So,
//            how come can we say that cjPelSize FROM PDEV is really the format
//            of our src bitmap ?  Because right now, the display memory must
//            contain only bitmaps of the same format.
//
//      (this is the way the whole NV display driver is done at this time)
//  
//          - Like ScreenTo1Bpp, this function assumes that the array of rectangles
//            that constrain (clip) the DST rectangle are already INSIDE this 
//            dst rectangle (so, already clipped by it).
//
//          - Like DMAGetScreenBits, this function makes assumption about the 
//            the value of the static data of the MEM_TO_MEM nv object.
//            It assumes that the SetContextDmaBufferIn() has been set to
//            the VRAM dma context, and that SetContextDmaBufferOut() has
//            been set to the mem2mem DMA buffer
//
//
//******************************************************************************

//******************************************************************************
// To get an approximation of the optimal "BytesPerXfer":
//
// We use the same ppdev->globalXferOverheadFactor than in ScreenToMem.  This is
// wrong, because this factor is based on calibration data that is calculated 
// in DrvEnableSurface based on the code of screentomem.  We have specified there,
// that any changes in the screentomem code must me made to the xfer loop being
// calibrated, otherwise, the calibration data is faulty.  So, ideally, calib
// data would have to give one factor for each different cpu/dma xfer algo.
// But since this calibration doesn't seem to affect benchmarks that much 
// after all (except for blitting lots of small icons ?), we use the same factor
//******************************************************************************


#ifdef  CALIBRATION_ENABLED
                                                                                                                  
#define GiveOptBytesPerXfer( optBytesPerXfer )                                                                    \
{                                                                                                                 \
        /* We are going to compute a fast squareroot (of a 32bit int)   */                                        \
        /* (see notes for more detail -stephane)                        */                                        \
                                                                                                                  \
        /* - First, find the position of the MSBit in the 32 bits       */                                        \
                                                                                                                  \
        if ( (bytes2Xfer & 0xFFFF0000 ) != 0 )                                                                    \
        {                                                                                                         \
            /* Search in the MSWord */                                                                            \
                                                                                                                  \
            tempUlong = (bytes2Xfer & 0xFF000000);                                                                \
                                                                                                                  \
            if ( tempUlong != 0 )                                                                                 \
            {                                                                                                     \
                /* the MSBit is in this MSByte, let the LUT do the rest of the job  */                            \
                                                                                                                  \
                /* ( bytes2Xfer >> 24 ) slide the MSByte in the LSByte position     */                            \
                                                                                                                  \
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 24 ] + 24;                                           \
            }                                                                                                     \
            else /* the  LSByte of the MSWord contains the bit we are looking for   */                            \
            {                                                                                                     \
                /* Our number is 0x00??????  */                                                                   \
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 16 ] + 16;                                           \
            }                                                                                                     \
                                                                                                                  \
        }                                                                                                         \
        else                                                                                                      \
        {                                                                                                         \
            /* Search the LSWord  */                                                                              \
                                                                                                                  \
            tempUlong = (bytes2Xfer & 0x0000FF00);                                                                \
                                                                                                                  \
            if ( tempUlong != 0 )                                                                                 \
            {                                                                                                     \
                /* the MSBit is in this MSByte of the LSWord let the LUT do the rest of the job  */               \
                                                                                                                  \
                /* ( bytes2Xfer >> 8 ) slide the MSByte in the LSByte position  */                                \
                                                                                                                  \
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer >> 8 ] + 8;                                             \
            }                                                                                                     \
            else /* the  LSByte of the LSWord contains the bit we are looking for  */                             \
            {                                                                                                     \
                /* Our number is 0x000000??  */                                                                   \
                                                                                                                  \
                msbitPos = Byte2_MSBitPos_LUT[ bytes2Xfer ];                                                      \
            }                                                                                                     \
                                                                                                                  \
        } /* ... else the MSBit is in the LSWord of our 32 bit "bytes2Xfer" number  */                            \
                                                                                                                  \
        /*                                                                        */                              \
        /* We now have msbitPos, plug it into the other LUT to get a very good    */                              \
        /* initial approximation of the squareroot of bytes2Xfer.                 */                              \
        /*                                                                        */                              \
                                                                                                                  \
        tempUlong = BitPos2SquRtAprox_LUT[ msbitPos ];                                                            \
                                                                                                                  \
        /* Do Newton 2 times                                                      */                              \
        /* We could actually use only 1 iteration and it would be enough for our  */                              \
        /* needs.                                                                 */                              \
                                                                                                                  \
        tempUlong = (tempUlong + bytes2Xfer/tempUlong) >> 1 ;                                                     \
        tempUlong = (tempUlong + bytes2Xfer/tempUlong) >> 1 ;                                                     \
                                                                                                                  \
        /* We now have our squareroot(bytes2Xfer), all we need is to mul it       */                              \
        /* by our profiled constant                                               */                              \
                                                                                                                  \
        optBytesPerXfer = tempUlong * ppdev->globalXferOverheadFactor;                                            \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/******************************* End of GiveOptBytesPerXfer( optBytesPerXfer ) ***********************************/

#else  /* else if NOT #ifdef  CALIBRATION_ENABLED */
                                                                                                                  
            
#define GiveOptBytesPerXfer( optBytesPerXfer )                                                                    \
{                                                                                                                 \
        optBytesPerXfer = bytesPerLine << 3;   /* Force per-8-scanline xfers */                                   \
                                                                                                                  \
        /* optBytesPerXfer = bytes2Xfer;  */   /* Force non-overlapping xfer (test) */                            \
}                                                                                                                 \
/******************************* End of GiveOptBytesPerXfer( optBytesPerXfer ) ***********************************/


#endif /* ...#ifdef  CALIBRATION_ENABLED         */






#define ScreenToMemXbpp_Common                                                                                    \
{                                                                                                                 \
                                                                                                                  \
                                                                                                                  \
        /* Calculate the number of bytes it takes to hold this bitmap that   */                                   \
        /* we want to transfer.                                              */                                   \
        /*                                                                   */                                   \
                                                                                                                  \
        height = parcl[i].bottom - parcl[i].top;        /* parcl[i]  */                                           \
        width  = parcl[i].right - parcl[i].left;                                                                  \
                                                                                                                  \
        bytesPerLine = width * ppdev->cjPelSize;        /* This value is reused later */                          \
        bytes2Xfer   = height * bytesPerLine;                                                                     \
                                                                                                                  \
                                                                                                                  \
        /* ( We check if the Mem2Mem buffer is large enough later )   */                                          \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*                                                                      */                                \
        /* Decide the number of lines to Xfer at a time. We must round to a #   */                                \
        /* of lines for each rectangle because MEM2MEM objects Xfer by count    */                                \
        /* of lines, so we can't stop in the middle                             */                                \
        /* of a line, and start a Xfer with the width of the first line to xfer */                                \
        /* being different from the width of all of the lines following it.     */                                \
        /*                                                                      */                                \
        /************************************************************************/                                \
                                                                                                                  \
        /* (Use optimal equation with profiling data)                                                        */   \
        /*                                                                                                   */   \
        /* I have modified the Newton method using a lut so that                                             */   \
        /* I can have a nearly perfect INT result of the square root                                         */   \
        /* with only 2 iterations.                                                                           */   \
        /*                                                                                                   */   \
        /* to calculate optBytesPerXfer = squareroot(bytes2Xfer*overhead_of_setup*average_speed_of_dma_xfer) */   \
        /*                                                                                                   */   \
        /* We already have squareroot(overhead_of_setup*average_speed_of_dma_xfer) in the global             */   \
        /* var "globalXferOverheadFactor"                                                                    */   \
        /*                                                                                                   */   \
                                                                                                                  \
        /* optBytesPerXfer = bytesPerLine; */     /* Force perscanline xfers for the moment (test)   */           \
                                                                                                                  \
        /* optBytesPerXfer = bytes2Xfer;   */     /* Force non-overlapping xfer (test)               */           \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
         GiveOptBytesPerXfer( optBytesPerXfer );                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /* We have our optBytesPerXfer, now convert it in linesPerXfer          */                                \
        /************************************************************************/                                \
                                                                                                                  \
        /* But first check if the Mem2Mem buffer is large enough to hold 2 chunks */                              \
        /* of this size                                                           */                              \
                                                                                                                  \
        /* NOTE:                                                                  */                              \
        /*                                                                        */                              \
        /* ( We try to reduce the Xfer size to 1 scanline (the minimum);          */                              \
        /*   we could try reducing it by half and recheck, but it's not           */                              \
        /*   really worth it, if mem2mem buffer is too small, we are              */                              \
        /*   already in a case that will be handled more slowly )                 */                              \
                                                                                                                  \
                                                                                                                  \
        /* Check if we are not in the special case where it is more               */                              \
        /* efficient to do the xfer without overlapping ( in that case,           */                              \
        /* we need "bytes2Xfer" bytes in the mem2mem buffer)                      */                              \
        /* (Clamp optBytesPerXfer to bytes2Xfer in that case)                     */                              \
                                                                                                                  \
        if( optBytesPerXfer > bytes2Xfer )                                                                        \
        {                                                                                                         \
            optBytesPerXfer = bytes2Xfer;  /* clamp the size of the chunk */                                      \
                                           /* to total bytes to xfer      */                                      \
                                                                                                                  \
            if( optBytesPerXfer > ppdev->MemToMemBufferSize )                                                     \
            {                                                                                                     \
                /* We must do one xfer, but mem2membuffer is too small. */                                        \
                /* Reduce it to the minimum                             */                                        \
                                                                                                                  \
                optBytesPerXfer = bytesPerLine;                                                                   \
                                                                                                                  \
                if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                                       \
                    return(FALSE);  /* we can't even store 2 scanlines! */                                        \
            }                                                                                                     \
                                                                                                                  \
        } /* ...if optxfersize > total2xfer  */                                                                   \
                                                                                                                  \
        /*  Else, check if we need to clamp to at least 1 scanline   */                                           \
        /* (indeed, if optBytesPerXfer calculated is                 */                                           \
        /*  lower than a scanline, we are going to use               */                                           \
        /*  a scanline-based transfer anyway, so we                  */                                           \
        /*  must check the size of mem2mem buffer VS                 */                                           \
        /*  at least a scanline )                                    */                                           \
                                                                                                                  \
        else if( optBytesPerXfer < bytesPerLine )                                                                 \
        {                                                                                                         \
            optBytesPerXfer = bytesPerLine;                                                                       \
                                                                                                                  \
            if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                                           \
                return(FALSE);  /* we can't even store 2 scanlines!   */                                          \
        }                                                                                                         \
                                                                                                                  \
        /* Else optBytesPerXfer is within boundaries, check if we can */                                          \
        /* store two chunks of that size                              */                                          \
                                                                                                                  \
        else if( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                                           \
        {                                                                                                         \
            /* Mem2Mem buffer size is too small for the size of 2 Xfer chunks. */                                 \
            /* Try to reduce the xfer chunk to the minimum                     */                                 \
                                                                                                                  \
            optBytesPerXfer = bytesPerLine;                                                                       \
                                                                                                                  \
            if ( (optBytesPerXfer << 1)  >  ppdev->MemToMemBufferSize )                                           \
                return(FALSE);  /* we can't even store 2 scanlines!     */                                        \
        }                                                                                                         \
                                                                                                                  \
                                                                                                                  \
        /* There are many ways to round: clamp to unit by truncating, or clamp to */                              \
        /* higher unit as soon as there is a rest, etc.  Simplest is truncating   */                              \
        /*                                                                        */                              \
                                                                                                                  \
        linesPerXfer = ( optBytesPerXfer / bytesPerLine );                                                        \
                                                                                                                  \
                                                                                                                  \
        /* Clamp to higher unit instead of truncate with ( bytesPerXfer / bytesPerLine );       */                \
        /*                                                                                      */                \
        /* Let's limit bytersPerXfer to 33 MB, so we have 7 bits (MSBits) out of                */                \
        /* 32 to use to do fixed point math. ( 32-7 = 25, 2^25 = 33 MB )                        */                \
        /*                                                                                      */                \
        /* [ (bytesPerXfer << 7 ) / ( bytesPerLine << 7 )  + 0x7F (which is 1111111b) ]  >> 7   */                \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*  An object of NV_MEM_TO_MEM class must be attached to 2 DMA contexts.*/                                \
        /*  The src and dst must be given through method writes, and these src  */                                \
        /*  and dst ptr must be in offset RELATIVE to the address of the BASE   */                                \
        /*  (so relative to the beginning) of the DMA region.                   */                                \
        /*                                                                      */                                \
        /*  So, we are going to:                                                */                                \
        /*                                                                      */                                \
        /*      - First, find the coordinates of the current clip rectangle     */                                \
        /*        in the SRC RECTL. (see below)                                 */                                \
        /*      - Find the offset in byte of these coordinates, relative to the */                                \
        /*        beginning of the source bits, and find the absolute address   */                                \
        /*        of these coordinates by adding the base of the source bits.   */                                \
        /*      - Substract the base of the DMA region from this ptr to obtain  */                                \
        /*        an offset relative to the base.                               */                                \
        /*                                                                      */                                \
        /************************************************************************/                                \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*      - First, find the coordinates of the current clip rectangle     */                                \
        /*        in the SRC RECTL. (see below)                                 */                                \
        /************************************************************************/                                \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*                                                                      */                                \
        /*          1) pptlSrc->x    ( value x1 shown below )                   */                                \
        /*                                                                      */                                \
        /*          2) prclDst->x    ( value x2 shown below )                   */                                \
        /*                                                                      */                                \
        /*             Location of the original unclipped destination rectangle */                                \
        /*                                                                      */                                \
        /*          3) parcl[i]       ( value x3 shown below)                   */                                \
        /*                                                                      */                                \
        /*            Current clip rectangle with coordinates relative to origin*/                                \
        /*                                                                of Dst*/                                \
        /*                                                                      */                                \
        /*   Origin  (Destination bitmap )                                      */                                \
        /*  +--------------------------------------------------------------->   */                                \
        /*  |                                                                   */                                \
        /*  |                                                                   */                                \
        /*  |           x2 = prclDst->left                                      */                                \
        /*  |           +-----------------------------------------------                  */                      \
        /*  |           |                              ^                |-Original        */                      \
        /*  |           |                              | dySrc          |  Unclipped      */                      \
        /*  |           |                              |                |   Destination   */                      \
        /*  |           |         x3 = parcl[i].left   v                |    Rectangle    */                      \
        /*  |           |         +------------        -                |                 */                      \
        /*  |           |         |            |                        |       */                                \
        /*  |           |<-dxSrc->|            |                        |       */                                \
        /*  |           |         |            |                        |       */                                \
        /*  |           |         |            |-Current                |       */                                \
        /*  |           |         |            |  Clip                  |       */                                \
        /*  |           |          ------------    Rectangle            |       */                                \
        /*  |           |                                               |       */                                \
        /*  |           |                                               |       */                                \
        /*  |           |                                               |       */                                \
        /*  |            -----------------------------------------------        */                                \
        /*  |                                                                   */                                \
        /*  v                                                                   */                                \
        /*                                                                      */                                \
        /*                                                                      */                                \
        /*           Origin (Source bitmap)                                     */                                \
        /*          +--------+--|-----+--------+------->                        */                                \
        /*          |           x1                                              */                                \
        /*          |                                                           */                                \
        /*          |                                                           */                                \
        /*          |                                                           */                                \
        /*          |           ^                                               */                                \
        /*          v           |                                               */                                \
        /*          |           |                                               */                                \
        /*          |           |                                                           */                    \
        /*          |-- x1 ---->|   x1 = pptlSrc->x                                         */                    \
        /*          |           +-----------------------------------------------            */                    \
        /*          |           |                             ^                 |-Source    */                    \
        /*          |           |                             | dySrc           | Rectangle */                    \
        /*          |           |                             |                 |           */                    \
        /*          |           |         x? = x1 + dxSrc     v                 |           */                    \
        /*          |           |         +------------       -                 |           */                    \
        /*          |           |         |            |                        |           */                    \
        /*          |           |<-dxSrc->|            |                        |           */                    \
        /*          |           |         |            |                        |           */                    \
        /*          |           |         |            |-Current                |           */                    \
        /*          |           |         |            |  Clip                  |           */                    \
        /*          |           |          ------------    Rectangle            |           */                    \
        /*          |           |                        ( but in SRC surface)  |           */                    \
        /*          |           |                                               |           */                    \
        /*          |           |                                               |           */                    \
        /*          |            -----------------------------------------------            */                    \
        /*                                                                                  */                    \
        /***********************************************************************            */                    \
                                                                                                                  \
                                                                                                                  \
        ptlSrcRegion.x  = pptlSrc->x + (parcl[i].left - prclDst->left);                                           \
        ptlSrcRegion.y  = pptlSrc->y + (parcl[i].top  - prclDst->top);                                            \
                                                                                                                  \
        /****************************************************************************/                            \
        /*      - Find the offset in byte of these coordinates, relative to the     */                            \
        /*        beginning of the source bits, and find the absolute address       */                            \
        /*        of these coordinates by adding the base of the source bits.       */                            \
        /*                                                                          */                            \
        /* (Calculate the pointer to the upper-left corner of Source clipped region)*/                            \
        /****************************************************************************/                            \
                                                                                                                  \
        pjSrcRclBits    =     pjSrcBits                             /* base of Src Bits */                        \
                              + ( ptlSrcRegion.y  * lSrcPitch )                                                   \
                              + ptlSrcRegion.x * ppdev->cjPelSize ;                                               \
                                /* CONVERT_TO_BYTES(x,pdev) == (x) * pdev->cjPelSize    */                        \
                                                                                                                  \
                                                                                                                  \
        /* We don't have to calculate the dst address for the DMA transfer:    */                                 \
        /* we have it, it is the dst                                           */                                 \
        /* of the mem2mem DMA buffer, but we have to calculate the address in  */                                 \
        /* the final destination surface, for the cpu transfer                 */                                 \
                                                                                                                  \
                                                                                                                  \
        /****************************************************************************/                            \
        /*                                                                          */                            \
        /*  Now, we need to setup the first Xfer, wait for it to end, and enter     */                            \
        /*  the main Xfer loop, were we kick a Xfer for the next chunk, and Xfer    */                            \
        /*  the last chunk from mem2mem buffer to final sys mem destination.        */                            \
        /*  Finally, we are going to Xfer the remaining data                        */                            \
        /*  ( total_lines_to_xfer % optimal_lines_by_xfer )                         */                            \
        /*                                                                          */                            \
        /****************************************************************************/                            \
                                                                                                                  \
                                                                                                                  \
        /****************************************************************************/                            \
        /* Calculate the offsets of the transfer src and dst from the beginning of  */                            \
        /* their respective DMA region base                                         */                            \
        /****************************************************************************/                            \
                                                                                                                  \
        DstDMAOffset = 0;         /* Init the current DMAoffset where to write    */                              \
                                                                                                                  \
                                                                                                                  \
                                  /* Init current source DMAoffset where to read  */                              \
                                                                                                                  \
        SrcDMAOffset = (ULONG)(pjSrcRclBits - ppdev->pjFrameBufbase);                                                   \
                                  /* We are assuming that base of VRAM DMA context             */                 \
                                  /* is == pjFrameBufbase, that is, that the DMAoffset of pjFrameBufbase   */                 \
                                  /* is always 0. That's why we use ppdev->pjFrameBufbase for        */                 \
                                  /* base of DMA region                                        */                 \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
        /************************************************************************/                                \
        /*                                                                      */                                \
        /* Precalculate the num of bytes to add to the SrcDmaOffset for each    */                                \
        /* transfer and the address of the second chunk in the DstDMA           */                                \
        /* (the mem2mem buffer)                                                 */                                \
        /*                                                                      */                                \
        /* ( We could use linesPerXfer * bytesPerLine,                          */                                \
        /* and that would also be the number of bytes to add to the             */                                \
        /* DstDmaOffset if we would be user a mem2mem buffer the size of the    */                                \
        /* whole transfer. In other words, not using the strict minimum to be   */                                \
        /* able to do overlapping, that is 2 chunks in the buffer (one to which */                                \
        /* DMA write, the other to which CPU read, and then, the opposite...)   */                                \
        /*                                                                      */                                \
        /* Instead we use ppdev->MemToMemBufferSize/2, because that value never */                                \
        /* changes (for any xfer size), so we can put that calculation out of   */                                \
        /* the rectangle loop. (for all rectangles)                             */                                \
        /*                                                                      */                                \
        /*                                                                      */                                \
        /* Also init some variables before going on to the Xfers                */                                \
        /*                                                                      */                                \
        /* Reminder: the pitch include the linelenght (bytesperline)!           */                                \
        /************************************************************************/                                \
                                                                                                                  \
                                                                                                                  \
        SrcDMAincPerXfer         = linesPerXfer * lSrcPitch;                                                      \
                                                                                                                  \
                                                                                                                  \
        linesToGo                = height;      /* Init the number of lines left to transfer  */                  \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/*************************************** End of ScreenToMemXbpp_Common *******************************************/






#define ScreenToMemXbpp_Common2(pxxDmaRead, cast, CpuXferMACRONAME)                                               \
{                                                                                                                 \
                                                                                                                  \
        pxxDmaRead               = cast(pulDmaRead_start); /* Init the reading ptr for the second  */             \
                                                           /* transfer "pipe" (the CPU-Xfers)      */             \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
        /***********************************************************************************/                     \
        /*                      Setup the first transfer                                   */                     \
        /*                                                                                 */                     \
        /*  NOTE: Somebody looking at this code (further below) might think:               */                     \
        /*        why doing this first xfer outside of the main xfer loop ?                */                     \
        /*        "Everything looks the same inside the loop"  This is not                 */                     \
        /*        exactly right: the loop is done so when it rolls we wait                 */                     \
        /*        for the last notifier being setup, just before resetting                 */                     \
        /*        this notifier and kicking off the new transfer. If we would              */                     \
        /*        remove that special-casing of the first xfer, we would be                */                     \
        /*        waiting inside the start of the xfer loop forever because                */                     \
        /*        no xfer has been setup yet...                                            */                     \
        /*                                                                                 */                     \
        /*                                                                                 */                     \
        /***********************************************************************************/                     \
                                                                                                                  \
        PushSendDMAXfer_forXlines(linesPerXfer);                                                                  \
                                                                                                                  \
        /***********************************************************************************/                     \
        /* Here we incremented the offsets before the Xfer completes, so we can            */                     \
        /* cover a bit the processing (make these calculations during the time             */                     \
        /* the first Xfer execute)                                                         */                     \
        /***********************************************************************************/                     \
                                                                                                                  \
        linesToGo       -= linesPerXfer;          /* Susbtract the lines that have been done. */                  \
        SrcDMAOffset    += SrcDMAincPerXfer;      /* Advance in the source DMA region         */                  \
        DstDMAOffset     = DstDMA2ndPartOffset;   /* Advance in the dest. DMA region          */                  \
                                                  /* (the mem2mem buffer) so we use the       */                  \
                                                  /* 2nd part the next time.                  */                  \
                                                                                                                  \
        /*                                                                  */                                    \
        /* REMINDER: ANY CODE FOLLOWING THIS MUST CHECK THE NOTIFIER        */                                    \
        /* IF IT WANTS TO BE SURE THAT THE MEM2MEM BUFFER DATA IS VALID     */                                    \
        /*                                                                  */                                    \
                                                                                                                  \
        /***[ Make sure there are still enough lines to Xfer before starting  *****/                              \
        /*                                                  another DMA Xfer ]    */                              \
                                                                                                                  \
        if ( linesToGo < linesPerXfer )  /* if there are not "linesPerXfer" lines to Xfer     */                  \
        {                                                                                                         \
            /* Now what is left is a CPU Xfer of "linesPerXfer" plus at most      */                              \
            /* one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...   */                              \
            /*                                                                    */                              \
            /* We save the value to which we must set the position of pulDmaRead  */                              \
            /* for the very last CPU read ( of size height % linesPerXfer)        */                              \
                                                                                                                  \
            pulDmaRead_lastXfer = pulDmaRead_2ndPart;                                                             \
                                                                                                                  \
                                                                                                                  \
        } /* ...if there are less than linesPerXfer left to Xfer                  */                              \
                                                                                                                  \
        else                                                                                                      \
        {                                                                                                         \
            /*  else, enter the main Xfer loop. */                                                                \
                                                                                                                  \
            /*******************************************************************************/                     \
            /*                Main transfer loop with overlapping Xfers                    */                     \
            /*                                                                             */                     \
            /*  Note that we are starting to setup the next DMA                            */                     \
            /*  xfer even before checking if the last one is finished. We only do so       */                     \
            /*  at the last minute, before resetting the notifier, and kicking the next    */                     \
            /*  DMA Xfer for maximum overlapping of processing                             */                     \
            /*                                                                             */                     \
            /*                                                                             */                     \
            /*******************************************************************************/                     \
                                                                                                                  \
            for(;;)   /* (for all Xfers that can be done in linesPerXfer chunks):         */                      \
                      /* - this is a 2 part loop with                                     */                      \
                      /*   2 breakout cases, so that's why we use a for(;;))              */                      \
                      /*   (2 cases because we are doing either one or the other part of  */                      \
                      /*   the mem2mem buffer)                                            */                      \
            {                                                                                                     \
                /*                                                                          */                    \
                /* START another DMA-Xfer:    remember, we use ( 2*bytesperxfer ) bytes     */                    \
                /*                            in our Mem2Mem buffer. (So we alternate       */                    \
                /*                            using it's two parts )                        */                    \
                /*                                                                          */                    \
                /*                            We started Xfering to the first part          */                    \
                /*                            (before entering the loop, and at the end     */                    \
                /*                            of this for(;;) loop),                        */                    \
                /*                            (the NV hw is writting to the first part)     */                    \
                /*                            so we are going to read from that first part  */                    \
                /*                            while we kick another Xfer in the second      */                    \
                /*                            part.                                         */                    \
                /*                                                                          */                    \
                /* (Note that the first time we enter this loop, we will wait without       */                    \
                /*  overlapping: this is normal, we need to wait for the **FIRST** xfer     */                    \
                /*  to be done, because in the other part of the 2part buffer, there        */                    \
                /*  isn't any data available yet for our CPU.)                              */                    \
                /*                                                                          */                    \
                                                                                                                  \
                /*---[ So now: ]------------------------*/                                                        \
                /*                                      */                                                        \
                /* DstDMAOffset == DstDMA2ndPartOffset; */                                                        \
                /*   pulDmaRead == pulDmaRead_start;    */                                                        \
                /*                                      */                                                        \
                /*--------------------------------------*/                                                        \
                                                                                                                  \
                /*                                                                                    */          \
                /* START another DMA-Xfer (but this time with wait for notification before resetting  */          \
                /*                         the notifier and kicking it)                               */          \
                /*                                                                                    */          \
                                                                                                                  \
                                                                                                                  \
                PushWaitSendDMAXfer_forXlines(linesPerXfer);                                                      \
                                                                                                                  \
                linesToGo    -= linesPerXfer;          /* Susbtract the lines that have been done.  */            \
                SrcDMAOffset += SrcDMAincPerXfer;      /* Advance in the source DMA region (VRAM)   */            \
                DstDMAOffset  = 0;                     /* Go back to the first part of the mem2mem  */            \
                                                       /* DMA buffer in the next DMA Xfer.          */            \
                                                                                                                  \
                /***************************************************************************/                     \
                /*  In the meantime, CPU-Xfer what has been DMA-Xfered.                    */                     \
                /*                                                                         */                     \
                /*  Note that here we have two chases that can go on: if DMA-Xfer is faster,     */               \
                /*  the while(!notified) active-wait will always be true by the time we          */               \
                /*  get here. We could, to be fancier, check after a certain number of bytes     */               \
                /*  CPU-Xfered, if the notification has been trigered (using the profiling       */               \
                /*  data, we can do it), but it's not really worth it. Indeed, if the DMA-Xfer   */               \
                /*  is faster, and we launch more than 1 per CPU-Xfered-chunk, (let's say 1.2    */               \
                /*  on average), at the end, all the DMA-Xfers will be over, yes, and the        */               \
                /*  hardware will be idle yes, but we will still have to finish here, in this    */               \
                /*  function, with our CPU transfer, and THAT is going to be the limiting speed. */               \
                /*  (And since the driver is not re-entrant, the idle hardware won't be used     */               \
                /*  anyway during this time)                                                     */               \
                /*  Repeat a similar reasoning for the other chase condition, that is,     */                     \
                /*  if the CPU-Xfers are faster than the DMA-Xfers.                        */                     \
                /***************************************************************************/                     \
                                                                                                                  \
                CpuXferMACRONAME(pxxDmaRead,linesPerXfer);                                                        \
                                                                                                                  \
                /* Set our pjDmaRead ptr at the beginning of the second part of our mem2mem buffer */             \
                /* (For the next CPU-Xfer)                                                         */             \
                                                                                                                  \
                pxxDmaRead = cast(pulDmaRead_2ndPart);                                                            \
                                                                                                                  \
                /*                              */                                                                \
                /* ... CPU Xfer done.           */                                                                \
                                                                                                                  \
                                                                                                                  \
                /***[ Make sure there are still lines to Xfer before starting         *****/                      \
                /*                                                  another DMA Xfer ]    */                      \
                                                                                                                  \
                if ( linesToGo < linesPerXfer )  /* if there are no more chunk to Xfer    */                      \
                {                                                                                                 \
                                                                                                                  \
                    /* Now what is left is a CPU Xfer of "linesPerXfer" plus at most      */                      \
                    /* one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...   */                      \
                    /*                                                                    */                      \
                    /* We save the value to which we must set the position of pjDmaRead   */                      \
                    /* for the very last CPU read ( of size height % linesPerXfer)        */                      \
                                                                                                                  \
                    pulDmaRead_lastXfer = pulDmaRead_start;                                                       \
                                                                                                                  \
                    break;          /* break out of the Xfer loop (for(;;))  */                                   \
                }                                                                                                 \
                /*                                                                        */                      \
                /**************************************************************************/                      \
                                                                                                                  \
                /*                                                                        */                      \
                /* START another DMA-Xfer:    Remember, we use ( 2*bytesPerXfer ) bytes   */                      \
                /*                            in our Mem2Mem buffer. (So we alternate     */                      \
                /*                            using it's two parts )                      */                      \
                /*                                                                        */                      \
                /*                            The last Xfer kicked used the 2nd part.     */                      \
                /*                            Next Xfer is going to use the first part    */                      \
                /*                            again.                                      */                      \
                                                                                                                  \
                /*---[ So now: ]------------------------*/                                                        \
                /*                                      */                                                        \
                /* DstDMAOffset == 0;                   */                                                        \
                /*   pulDMAread == pulDmaRead_2ndPart;  */                                                        \
                /*                                      */                                                        \
                /*--------------------------------------*/                                                        \
                                                                                                                  \
                PushWaitSendDMAXfer_forXlines(linesPerXfer);                                                      \
                                                                                                                  \
                linesToGo       -= linesPerXfer;          /* Susbtract the lines that have been done. */          \
                SrcDMAOffset    += SrcDMAincPerXfer;      /* Advance in the source DMA region (VRAM)  */          \
                DstDMAOffset     = DstDMA2ndPartOffset;   /* Advance in the dest. DMA region          */          \
                                                          /* (the mem2mem buffer) so we use the       */          \
                                                          /* 2nd part the next time.                  */          \
                                                                                                                  \
                /***************************************************************************/                     \
                /*  In the meantime, CPU-Xfer what has been DMA-Xfered in the 2nd part     */                     \
                /***************************************************************************/                     \
                                                                                                                  \
                                                                                                                  \
                CpuXferMACRONAME(pxxDmaRead,linesPerXfer);                                                        \
                                                                                                                  \
                                                                                                                  \
                /* Set our pjDmaRead ptr at the beginning of the first part of our mem2mem buffer  */             \
                                                                                                                  \
                pxxDmaRead = cast(pulDmaRead_start);         /* Reset the read ptr at the        */               \
                                                             /* first part (beginning) of the    */               \
                                                             /* MEM2MEM buffer                   */               \
                /* ... CPU Xfer Done.  */                                                                         \
                                                                                                                  \
                                                                                                                  \
                /***[ Make sure there are still lines to Xfer before starting         *****/                      \
                /*                                                  another DMA Xfer ]    */                      \
                                                                                                                  \
                if ( linesToGo < linesPerXfer )  /* if there are no more lines to Xfer    */                      \
                {                                                                                                 \
                                                                                                                  \
                    /* Now what is left is a CPU Xfer of "linesPerXfer" plus at most      */                      \
                    /* one DMA+CPU Xfers of size " height % (modulo) linesPerXfer " ...   */                      \
                    /*                                                                    */                      \
                    /* We save the value to which we must set the position of pjDmaRead   */                      \
                    /* for the very last CPU read ( of size height % linesPerXfer)        */                      \
                                                                                                                  \
                    pulDmaRead_lastXfer = pulDmaRead_2ndPart;                                                     \
                                                                                                                  \
                    break;          /* break out of the Xfer loop (for(;;)) */                                    \
                                                                                                                  \
                } /* ...if there are less than "linesPerXfer" left to Xfer  */                                    \
                                                                                                                  \
                /*                                                                        */                      \
                /**************************************************************************/                      \
                                                                                                                  \
                                                                                                                  \
            } /* ...for(;;)  ( while(linesToGo >= linesPerXfer )  )  */                                           \
              /*                                                     */                                           \
              /* (this is a special cased 2 part loop)               */                                           \
                                                                                                                  \
                                                                                                                  \
        } /*  ...else enter the main Xfer loop (if there are at least linesPerXfer left to Xfer) */               \
                                                                                                                  \
        /***********************************************************************************/                     \
        /*                                                                                 */                     \
        /*                Last transfer: Time to execute the last transfer                 */                     \
        /*                                                                                 */                     \
        /*  There is at most one DMA transfer left to execute, and at most 2 mem2mem       */                     \
        /*  chunks to transfer (the last DMA that is about to be completed, and the        */                     \
        /*  one that we are about to start, if there is one)                               */                     \
        /*                                                                                 */                     \
        /***********************************************************************************/                     \
                                                                                                                  \
        if ( linesToGo == 0 ) /* only 1 CPU-Xfer left to execute                   */                             \
                              /* (that means that totalLinesToXfer was a multiple  */                             \
                              /* of linesPerXfer, => total % linesPerXfer == 0     */                             \
        {                                                                                                         \
            /*******************************************************************************/                     \
            /* Wait for the last DMA to be completed (use second notification structure)   */                     \
            /*******************************************************************************/                     \
                                                                                                                  \
            while ( pNotifier->status != 0 );                                                                     \
                                                                                                                  \
            CpuXferMACRONAME(pxxDmaRead,linesPerXfer);                                                            \
                                                                                                                  \
            /******************************************/                                                          \
            /* And this rectangle is done, at last... */                                                          \
            /******************************************/                                                          \
                                                                                                                  \
        } /* ...if ( linesToGo == 0 ) */                                                                          \
                                                                                                                  \
        else /* else, setup one last DMA Xfer */                                                                  \
        {                                                                                                         \
            /* This last DMA-Xfer is different in that the line count is                        */                \
            /* linesToGo (the rest of the lines, which is < than our linesPerXfer calculated )  */                \
            /*                                                                                  */                \
                                                                                                                  \
            PushWaitSendDMAXfer_forXlines(linesToGo);                                                             \
                                                                                                                  \
            /*******************************************************************************/                     \
            /* Now that this last DMA-Xfer is running, transfer the last "linesPerXfer"    */                     \
            /* long chunk. (this is our last but one CPU-Xfer)                             */                     \
            /*                                                                             */                     \
            /* We might think of one complication here: we do not know where we broke in   */                     \
            /* our main for(;;) loop.  So we do not know to which part of the mem2mem      */                     \
            /* buffer we must read our last cpu xfer. (In other words, where to put the    */                     \
            /* pjDmaRead ptr. This is solved in the loop by saving the next value to which */                     \
            /* it must be set (this is to avoid doing an additionnal "IF" here, to know    */                     \
            /* were we broke in the for(;;) )                                              */                     \
            /*                                                                             */                     \
            /*******************************************************************************/                     \
                                                                                                                  \
            CpuXferMACRONAME(pxxDmaRead,linesPerXfer);                                                            \
                                                                                                                  \
            /* Set our pjDmaRead ptr at the beginning of the ? part of our mem2mem buffer  */                     \
            /* (the right part for our last cpu xfer; this was selected in the for(;;)     */                     \
                                                                                                                  \
            pxxDmaRead = cast(pulDmaRead_lastXfer);                                                               \
                                                                                                                  \
                                                                                                                  \
            /*******************************************************************************/                     \
            /* Wait for the LAST DMA-Xfer to be completed                                  */                     \
            /* ( if it is not yet completed ) and CPU-Xfer these remainder lines           */                     \
            /*******************************************************************************/                     \
                                                                                                                  \
            while ( pNotifier->status != 0 );                                                                     \
                                                                                                                  \
            CpuXferMACRONAME(pxxDmaRead,linesToGo);                                                               \
                                                                                                                  \
            /*****************************************/                                                           \
            /* And this rectangle is done, at last...*/                                                           \
            /*****************************************/                                                           \
                                                                                                                  \
        } /* ...else ( linesToGo != 0 )  ( one last DMA xfer to setup )   */                                      \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/************************ End of ScreenToMemXbpp_Common2(pxxDmaRead,cast,CpuXferMACRONAME) ***********************/





#define PushSendDMAXfer_forXlines(linesPerXfer)                                                                   \
{                                                                                                                 \
    /***********************************************************************/                                     \
    /* Set methods for memory_to_memory dma blit                           */                                     \
    /*   NV039_OFFSET_IN                                                   */                                     \
    /*   NV039_OFFSET_OUT                                                  */                                     \
    /*   NV039_PITCH_IN                                                    */                                     \
    /*   NV039_PITCH_OUT                                                   */                                     \
    /*   NV039_LINE_LENGTH_IN                                              */                                     \
    /*   NV039_LINE_COUNT                                                  */                                     \
    /*   NV039_FORMAT                                                      */                                     \
    /*   NV039_BUFFER_NOTIFY                                               */                                     \
    /***********************************************************************/                                     \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Set notifier to 'BUSY' value (use second notification structure)        */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;                                                    \
                                                                                                                  \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Check if we've got enough room in the push buffer                       */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    NV_DMAPUSH_CHECKFREE(((ULONG)(9)));                                                                           \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
    NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );                                                              \
    NV_DMA_FIFO = SrcDMAOffset;                         /* Offset In  */                                          \
    NV_DMA_FIFO = DstDMAOffset;                         /* Offset Out */                                          \
    NV_DMA_FIFO = lSrcPitch;                            /* Pitch In   */                                          \
    NV_DMA_FIFO = bytesPerLine;                         /* Pitch Out == bytesPerLine because          */          \
                                                        /* we dont want any memory "hole" between     */          \
                                                        /* two contiguous lines in the mem2mem buffer */          \
                                                                                                                  \
    NV_DMA_FIFO = bytesPerLine;                         /* Line Length in bytes          */                       \
    NV_DMA_FIFO = linesPerXfer;                         /* Line Count (num to copy)      */                       \
    NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 |                                                                    \
                  NV_MTMF_FORMAT_OUTPUT_INC_1;          /* Format                        */                       \
    NV_DMA_FIFO = 0;                                    /* Set Buffer Notify and kickoff */                       \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Update global push buffer count                                         */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    UPDATE_PDEV_DMA_COUNT;                                                                                        \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Send data on thru to the DMA push buffer                                */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    NV4_DmaPushSend(ppdev);                                                                                       \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/*********************** End of PushSendDMAXfer_forXlines(linesPerXfer) ******************************************/
                                                                                                                   


#define PushWaitSendDMAXfer_forXlines(linesPerXfer)                                                               \
{                                                                                                                 \
    /***********************************************************************/                                     \
    /* Set methods for memory_to_memory dma blit                           */                                     \
    /*   NV039_OFFSET_IN                                                   */                                     \
    /*   NV039_OFFSET_OUT                                                  */                                     \
    /*   NV039_PITCH_IN                                                    */                                     \
    /*   NV039_PITCH_OUT                                                   */                                     \
    /*   NV039_LINE_LENGTH_IN                                              */                                     \
    /*   NV039_LINE_COUNT                                                  */                                     \
    /*   NV039_FORMAT                                                      */                                     \
    /*   NV039_BUFFER_NOTIFY                                               */                                     \
    /***********************************************************************/                                     \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Check if we've got enough room in the push buffer                       */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    NV_DMAPUSH_CHECKFREE(((ULONG)(9)));                                                                           \
                                                                                                                  \
                                                                                                                  \
    NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );                                                              \
    NV_DMA_FIFO = SrcDMAOffset;                         /* Offset In  */                                          \
    NV_DMA_FIFO = DstDMAOffset;                         /* Offset Out */                                          \
    NV_DMA_FIFO = lSrcPitch;                            /* Pitch In   */                                          \
    NV_DMA_FIFO = bytesPerLine;                         /* Pitch Out == bytesPerLine because          */          \
                                                        /* we dont want any memory "hole" between     */          \
                                                        /* two contiguous lines in the mem2mem buffer */          \
                                                                                                                  \
    NV_DMA_FIFO = bytesPerLine;                         /* Line Length in bytes          */                       \
    NV_DMA_FIFO = linesPerXfer;                         /* Line Count (num to copy)      */                       \
    NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 |                                                                    \
                  NV_MTMF_FORMAT_OUTPUT_INC_1;          /* Format                        */                       \
    NV_DMA_FIFO = 0;                                    /* Set Buffer Notify and kickoff */                       \
                                                                                                                  \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Wait for the last DMA-Xfer kicked to be completed (use 2nd notif.struct)*/                                 \
    /* ( if it is not yet completed )                                          */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    while ( pNotifier->status != 0 );                                                                             \
                                                                                                                  \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Set notifier to 'BUSY' value (use second notification structure)        */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;                                                    \
                                                                                                                  \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Update global push buffer count                                         */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    UPDATE_PDEV_DMA_COUNT;                                                                                        \
                                                                                                                  \
    /***************************************************************************/                                 \
    /* Send data on thru to the DMA push buffer                                */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    NV4_DmaPushSend(ppdev);                                                                                       \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/********************************* End of PushWaitSendDMAXfer_forXlines ******************************************/


// CpuXferTo4bpp(pxxDmaRead,linesPerXfer)
//
// Here we do:
//
//  For the left 
//
//   1) Read the final dest byte (containing the left pixel)
//      by masking also the bits we will modifie (read with an AND
//      between our mask and dest byte)
//
//   2) Read and translate the pixel (32bit) in the DMA mem2mem buffer
//   3) Shift translated byte to put it's 4 bits in the correct part
//      of the byte
//   4) Write the 4bits of the xlated byte (this is our new pixel!)
//      inside the byte "created" at step 1. (by doing step1_byte |= xlated_byte;
//   5) Write back the resulting byte from step 4 in it's final destination
//      (same address then the one we read from at step 1)
//
//   After doing the left byte, we do the middle bytes in a similar way
//   except that we don't have to mask because all the byte must be overwritten.
//   Then we do the right byte in a similar way than the left byte.

// ********************
// Do the Left byte
// ********************

// If the left coordinate was starting on the low nibble of the byte containing
// the pixel, we need to process another pixel before going on to the middle bytes

// (We could have done this to avoid doing this if:
//
//   (similar to the ScreenTo1Bpp code )
//
// Transfer more than we need (by clamping the right coordinate
// to the highest even number, and clamping the left one the lowest even)
// This is done to avoid special casing when we translate the LEFT byte
// in the CPU-Xfer loop: if the left coordinate start in the low nibble
// of a byte in the dest scanline, this means that we are going to read
// only 1 32bit pixel in the mem2mem buffer, before doing the middle
// bytes. But if the left coordinate start on the high nibble, we will
// have to convert 2 pixels from the mem2mem buffer and combine them
// in 1 byte to write before going on the middle bytes. (We would also use
// a real mask, pretty much like ScreenTo1Bpp but only a 2 entry LUT, we have 4bpp)
//
//
// But is it really worth it ?  Because when u think of it: you have more overhead
// by reading more than you need (insignificant for the DMA I agree), overhead to
// clamp the coordinates (insignificant), and (more significant) overhead of always
// Xlating a pixel for nothing (in the case where there is a rest)
//  (call to the Xlate macro). (Because this pixel is not in the destination region
// to modifie and it will get masked out anyway by our mask, if there's a rest)
//
// SO, to summarize, we use "IFs" instead of a general algo like 
// " transfer an even number of byte + always convert all pixels in the byte + and only
// write back, at the dest, the pixels we really need to modifie " we use IF's to avoid
// converting pixels for nothing (because this is expensive)

            
#define CpuXferTo4bpp(pxxDmaRead,linesPerXfer)                                                                    \
{                                                                                                                 \
    /* Xfer all lines    */                                                                                       \
    /*                   */                                                                                       \
    for(j=0; j < linesPerXfer; j++)                                                                               \
    {                                                                                                             \
        /*************************/                                                                               \
        /* Do the Left byte      */                                                                               \
        /*************************/                                                                               \
                                                                                                                  \
        if ( leftRest == 0) /* There is no rest, so that we must modifie the whole left byte */                   \
        {                                                                                                         \
            XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* xlate first pixel             */   \
            pxxDmaRead++;                                                                                         \
            XlatedByte <<= 4;                                           /* place the nibble in the MS Nibble */   \
            XlatedByte  |= (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* xlate & combine second pixel  */   \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
                /* NOTE: Here we know the destination is 4Bpp,                       */                           \
                /*       so even if the macro returns a ULONG,                       */                           \
                /*       it will only have it's lower 4 bits                         */                           \
                /*       equal to the color, the rest of them                        */                           \
                /*       will be 0. If they are not 0, we will                       */                           \
                /*       have garbage in XlatedByte, and will                        */                           \
                /*       have a faulty convertion.  We assume                        */                           \
                /*       that the macro function correctly, but                      */                           \
                /*       a defensive code would be:                                  */                           \
                /*  |= (BYTE) ( XLATEOBJ_iXlate(pxlo, *pulDmaRead++) & 0x0000000F)   */                           \
                                                                                                                  \
            *pjFinalDstWrite++ = XlatedByte; /* Write the byte in the dest region */                              \
        }                                                                                                         \
        else                                                                                                      \
        {                                                                                                         \
            /* Else there is a rest, we must modifie the LOW Nibble only */                                       \
                                                                                                                  \
            TempByte   = *pjFinalDstWrite;                                                                        \
            TempByte  &= 0xF0;            /* TempByte = DestSurfByte & Mask (clear the bits         */            \
                                          /*                                 we are going to mod.)  */            \
                                                                                                                  \
            XlatedByte = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* Translate source pixel     */        \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
            TempByte  |= XlatedByte;                                                                              \
                                                                                                                  \
            *pjFinalDstWrite++ = TempByte; /* Write back the left byte.    */                                     \
                                                                                                                  \
        }                                                                                                         \
                                                                                                                  \
        /*************************/                                                                               \
        /* Do the Middle byte(s) */                                                                               \
        /*************************/                                                                               \
                                                         /* Reminder of ptr arythmetics (if ptr is ULONG*): */    \
        for(limit = (BYTE*)( pxxDmaRead + middleWidth);  /* limit = the ptr + width*4 bytes/pixel           */    \
            (BYTE*) pxxDmaRead < limit;                                                                           \
            pjFinalDstWrite++ )                                                                                   \
        {                                                                                                         \
            XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo,*pxxDmaRead);                                        \
            pxxDmaRead++;                                                                                         \
            XlatedByte <<= 4;                                                                                     \
            XlatedByte  |= (BYTE) NV_XLATEOBJ_IXLATE(pxlo,*pxxDmaRead);                                        \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
            *pjFinalDstWrite = XlatedByte;                                                                        \
        }                                                                                                         \
                                                                                                                  \
        /*************************/                                                                               \
        /* Do the Right byte     */                                                                               \
        /*************************/                                                                               \
                                                                                                                  \
        if( rightRest != 0 ) /* there is a rest */                                                                \
        {                                                                                                         \
            /* Modifie the HIGH NIBBLE of the right byte (the LOW one, corresponding to  */                       \
            /* the coordinate, is exclusive)                                             */                       \
                                                                                                                  \
            TempByte   = *pjFinalDstWrite;                                                                        \
            TempByte  &= 0x0F;             /* TempByte = DestSurfByte & Mask (clear the bits          */          \
                                           /*                                 we are going to mod.)   */          \
                                                                                                                  \
            XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead);  /* Translate source pixel    */      \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
            XlatedByte <<= 4;             /* Place the pixel in the high nibble (filling in zeros     */          \
                                          /* in the low nibble so we don't modifie the low nibble     */          \
                                          /* when ORing next)                                         */          \
                                                                                                                  \
            TempByte |= XlatedByte;       /* Combine the translated pixel to the pixel we don't */                \
                                          /* want to modifie                                    */                \
                                                                                                                  \
            *pjFinalDstWrite++ = TempByte;   /* Write back the right byte. */                                     \
                                                                                                                  \
                                                                                                                  \
        }                                                                                                         \
        else                                                                                                      \
        {                                                                                                         \
            /* Else, we do a full byte: Indeed, in our calculation for "middleWidth", middleWidth = number of */  \
            /* FULL bytes AFTER the left byte (containing the right coordinate) minus 1.  Thus, if the scan-  */  \
            /* line ends with a FULL byte to modifie (rightRest = 0), this full byte is not included in the   */  \
            /* "middleWidth" and is considered the right byte (so if there's only 2 bytes, all in all, in the */  \
            /* scanline, even if they are full, they are considered the "left and right bytes"                */  \
            /*                                                                                                */  \
            /* ALSO, we might think "what if the byte previous (left) to the one containing the right coordi- */  \
            /* nate, is not one full byte ?" Well, the only way this can happen is to have the computation    */  \
            /* of "middleWidth" to be -1  (see in the code ScreenToMem?bpp), and we handle those cases with   */  \
            /* a different function (yes, it could be the same, like in ScreenTo1Bpp, but it is faster to do  */  \
            /* this a different way, because we do not convert a bunch of pixels for nothing                  */  \
                                                                                                                  \
            XlatedByte       = (BYTE) NV_XLATEOBJ_IXLATE(pxlo,*pxxDmaRead);                                    \
            pxxDmaRead++;                                                                                         \
            XlatedByte     <<= 4;                                                                                 \
            XlatedByte      |= (BYTE) NV_XLATEOBJ_IXLATE(pxlo,*pxxDmaRead);                                    \
            pxxDmaRead++;                                                                                         \
            *pjFinalDstWrite++ = XlatedByte;                                                                      \
                                                                                                                  \
        }                                                                                                         \
                                                                                                                  \
        pjFinalDstWrite += FinalDstJump2NextLineBeg;  /* Switch to beginning of the    */                         \
                                                      /* next line in the dest surface */                         \
    } /* ...for all bytes in chunk to cpu-xfer  */                                                                \
                                                                                                                  \
}                                                                                                                 \
/******************************** End of CpuXferTo4bpp(pxxDmaRead,linesPerXfer) **********************************/


#define CpuXferTo4bpp_1ByteWidth(pxxDmaRead,linesPerXfer)                                                         \
{                                                                                                                 \
    /* Xfer all lines    */                                                                                       \
    /*                   */                                                                                       \
    for(j=0; j < linesPerXfer; j++)                                                                               \
    {                                                                                                             \
        /*************************/                                                                               \
        /* Do the Left byte      */                                                                               \
        /*************************/                                                                               \
                                                                                                                  \
        if ( leftRest == 0 )  /* There is no rest */                                                              \
        {                                                                                                         \
            if ( rightRest == 0 )   /* AND the right coord. has no rest (even). We have 2 pixels */               \
            {                                                                                                     \
                XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead);  /* xlate first pixel */          \
                pxxDmaRead++;                                                                                     \
                                                                                                                  \
                XlatedByte <<= 4;     /* place the nibble in the MS Nibble */                                     \
                                                                                                                  \
                XlatedByte  |= (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead);/* xlate & combine second pixel */ \
                pxxDmaRead++;                                                                                     \
                                                                                                                  \
                *pjFinalDstWrite++ = XlatedByte;  /* Write the byte in the dest region */                         \
            }                                                                                                     \
            else                                                                                                  \
            {                                                                                                     \
                /* Else just do the high nibble */                                                                \
                                                                                                                  \
                TempByte   = *pjFinalDstWrite;                                                                    \
                TempByte  &= 0x0F;             /* TempByte = DestSurfByte & Mask (clear the bits        */        \
                                               /*                                 we are going to mod.) */        \
                                                                                                                  \
                XlatedByte   = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* Translate source pixel   */    \
                pxxDmaRead++;                                                                                     \
                                                                                                                  \
                XlatedByte <<= 4;              /* Place the pixel in the high nibble (filling in zeros  */        \
                                               /* in the low nibble so we don't modifie the low nibble  */        \
                                               /* when ORing next)                                      */        \
                                                                                                                  \
                TempByte |= XlatedByte;        /* Combine the translated pixel to the pixel we don't    */        \
                                               /* want to modifie                                       */        \
                                                                                                                  \
                *pjFinalDstWrite++ = TempByte;  /* Write back the right byte.                           */        \
                                                                                                                  \
            }                                                                                                     \
        }                                                                                                         \
        else                                                                                                      \
        {                                                                                                         \
            /* Else there is a rest, we must modifie the LOW Nibble only and we are finished!    */               \
                                                                                                                  \
            TempByte   = *pjFinalDstWrite;                                                                        \
            TempByte  &= 0xF0;             /* TempByte = DestSurfByte & Mask (clear the bits            */        \
                                           /*                                 we are going to mod.)     */        \
                                                                                                                  \
            XlatedByte = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead);   /* Translate source pixel       */    \
            pxxDmaRead++;                                                                                         \
                                                                                                                  \
            TempByte  |= XlatedByte;                                                                              \
                                                                                                                  \
            *pjFinalDstWrite++ = TempByte;   /* Write back the left byte. */                                      \
                                                                                                                  \
        }                                                                                                         \
                                                                                                                  \
                                                                                                                  \
        pjFinalDstWrite += FinalDstJump2NextLineBeg;   /* Switch to beginning of the              */              \
                                                       /* next line in the dest surface           */              \
    } /* ...for all bytes in chunk to cpu-xfer */                                                                 \
}                                                                                                                 \
/**************************** End of CpuXferTo4bpp_1ByteWidth(pxxDmaRead,linesPerXfer) ***************************/


#define CpuXferTo8bpp(pxxDmaRead,linesPerXfer)                                                                    \
{                                                                                                                 \
    for(j=0; j < linesPerXfer; j++)                                                                               \
    {                                                                                                             \
        /* Xfer a whole line */                                                                                   \
        /*                   */                                                                                   \
                                                         /* Reminder of ptr arythmetics (if ptr is ULONG*): */    \
        for(limit = (BYTE*)( pxxDmaRead + width);        /* limit = the ptr + width*4 bytes/pixel           */    \
            (BYTE*) pxxDmaRead < limit;                                                                           \
            pxxDmaRead++, pjFinalDstWrite++ )                                                                     \
        {                                                                                                         \
            *pjFinalDstWrite = (BYTE) NV_XLATEOBJ_IXLATE(pxlo, *pxxDmaRead); /* Translate source pixel & write */ \
        }                                                                                                         \
                                                                                                                  \
        pjFinalDstWrite += FinalDstJump2NextLineBeg;    /* Switch to beginning of the    */                       \
                                                        /* next line in the dest surface */                       \
                                                                                                                  \
    } /* ...for all bytes in chunk to cpu-xfer */                                                                 \
}                                                                                                                 \
/****************************** End of CpuXferTo8bpp(pxxDmaRead,linesPerXfer) ************************************/





#define ScreenToMem4bpp(pxxDmaRead,cast)                                                                          \
{                                                                                                                 \
    /***************************************************************************/                                 \
    /*  Transfer all rectangles regions in the array                           */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    for(i=0; i < c; i++) /* For all rectangles */                                                                 \
    {                                                                                                             \
                                                                                                                  \
        /* Calculate the number of full bytes we have per scanline              */                                \
        /* (this will need to be clamped to 0 if it is negative; we do that     */                                \
        /*  later because this value will make us decide which function         */                                \
        /*  we use in case the destination is 4Bpp)                             */                                \
                                                                                                                  \
        /*  Explanation for this formula: the right coordinate is exclusive, so we substract 1,    */             \
        /*  and clamp it to the lowest multiple of 2. We clamp the left coordinate to the lowest   */             \
        /*  multiple of 2 also.  (This is because we have 2 pixel / bytes when the dest is 4BPP)   */             \
        /*  (We only use this "middleWidth" when dest is 4 BPP.) We substract both of them, and    */             \
        /*  -1 also, because we want 0 => when there is a left byte and a right byte (2 byte that  */             \
        /*  contains the pixels), -1 when the width is at most 1 byte (the pixel(s) of one         */             \
        /*  scanline are in a single byte), and else, "middleWidth" gives us the number of bytes   */             \
        /*  taking aside the first byte we process and the last one. We multiply by 2 the whole    */             \
        /*  formula ( << 1 at the end) because we want middleWidth in NUMBER OF PIXELS.            */             \
                                                                                                                  \
        middleWidth = ( ((parcl[i].right - 1) >> 1) - (parcl[i].left >> 1) - 1 ) << 1 ;                           \
                                                                                                                  \
        /* Calculate the rest of the left and right coordinates (this is out of ScreenToMemXbpp_Common */         \
        /* because for 8bpp destination, we don't need this )                                          */         \
                                                                                                                  \
        leftRest  = (BYTE)( parcl[i].left & 1 );        /* leftRest = 1 if left coordinate is odd  */             \
        rightRest = (BYTE)( parcl[i].right & 1 );                                                                 \
                                                                                                                  \
        ScreenToMemXbpp_Common;    /* This is the beginning of the Xfer loop (for all rectangles) common */       \
                                   /* to all ScreenToMemXbpp functions.                                  */       \
                                   /* In this macro, we setup the linesPerXfer, and all variables needed */       \
                                   /* after this point in the for(all rectangles) (dma offsets, read/    */       \
                                   /* write ptr addresses, ... )                                         */       \
                                                                                                                  \
        /* Now we must chose the core routine for our ScreenToMem4bpp blit:     */                                \
                                                                                                                  \
        if(middleWidth < 0)                                                                                       \
        {                                                                                                         \
            /*middleWidth = 0;   No need to, in CpuXferTo4bpp_1ByteWidth, we don't use it  */                     \
            ScreenToMem4bpp_Core_1ByteWidth(pxxDmaRead, cast);                                                    \
        }                                                                                                         \
        else ScreenToMem4bpp_Core(pxxDmaRead, cast);                                                              \
                                                                                                                  \
    } /* ...for(i=0; i < c; i++)  For all rectangles  */                                                          \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/********************************** End of ScreenToMem4bpp(pxxDmaRead,cast) **************************************/





//
// Usage: ScreenToMem4bpp_Core( pjDmaread, (BYTE*))
//

    
#define ScreenToMem4bpp_Core(pxxDmaRead,cast)                                                                     \
{                                                                                                                 \
                                                                                                                  \
                                                                                                                  \
        /***************************************************************************    */                        \
        /* Calculate the pointer to the upper-left corner of Destination clipped region */                        \
        /* (THE FINAL DESTINATION, not the MEM2MEM buffer)                              */                        \
        /***************************************************************************    */                        \
                                                                                                                  \
        pjFinalDstWrite =  (BYTE*) psoDst->pvScan0                                                                \
                          + ( parcl[i].top  * lDstPitch )                                                         \
                          + ( parcl[i].left >> 1 );                                                               \
                                                                                                                  \
                                                                                                                  \
        /* Calculate the jump to get to the next line of the             */                                       \
        /* final destination rectangle (in the final Dst surface)        */                                       \
        /* AFTER having transfered "bytesPerLine" (in other words,       */                                       \
        /* pitch is the num of bytes to the jump AT THE SAME POSITION    */                                       \
        /* in the bitmap but one line lower; what we want is the jump    */                                       \
        /* value to jump from the end of a line TO THE BEGINNING         */                                       \
        /* of the next line )                                            */                                       \
        /*                                                               */                                       \
        /* We add 1 to width so that we round to the upper multiple      */                                       \
        /* of 2 (we have 2 pixels per byte, and the scanline must be     */                                       \
        /* of at least 1 byte wide even if it is 1 pixel wide only...    */                                       \
                                                                                                                  \
        FinalDstJump2NextLineBeg = lDstPitch - ((width+1) >> 1);                                                  \
                                                                                                                  \
                                                                                                                  \
        /* Do the rest of the loop (all the core of the xfer/convertion  */                                       \
                                                                                                                  \
                                                                                                                  \
        ScreenToMemXbpp_Common2(pxxDmaRead, cast,CpuXferTo4bpp);                                                  \
                                                                                                                  \
}                                                                                                                 \
/****************************** End of ScreenToMem4bpp_Core(pxxDmaRead,cast) *************************************/




#define ScreenToMem4bpp_Core_1ByteWidth(pxxDmaRead,cast)                                                          \
{                                                                                                                 \
                                                                                                                  \
                                                                                                                  \
        /***************************************************************************    */                        \
        /* Calculate the pointer to the upper-left corner of Destination clipped region */                        \
        /* (THE FINAL DESTINATION, not the MEM2MEM buffer)                              */                        \
        /***************************************************************************    */                        \
                                                                                                                  \
        pjFinalDstWrite =  (BYTE*) psoDst->pvScan0                                                                \
                          + ( parcl[i].top  * lDstPitch )                                                         \
                          + ( parcl[i].left >> 1 );                                                               \
                                                                                                                  \
                                                                                                                  \
        /* Calculate the jump to get to the next line of the             */                                       \
        /* final destination rectangle (in the final Dst surface)        */                                       \
        /* AFTER having transfered "bytesPerLine" (in other words,       */                                       \
        /* pitch is the num of bytes to the jump AT THE SAME POSITION    */                                       \
        /* in the bitmap but one line lower; what we want is the jump    */                                       \
        /* value to jump from the end of a line TO THE BEGINNING         */                                       \
        /* of the next line )                                            */                                       \
        /*                                                               */                                       \
        /* We add 1 to width so that we round to the upper multiple      */                                       \
        /* of 2 (we have 2 pixels per byte, and the scanline must be     */                                       \
        /* of at least 1 byte wide even if it is 1 pixel wide only...    */                                       \
                                                                                                                  \
        FinalDstJump2NextLineBeg = lDstPitch - 1;                                                                 \
                                                                                                                  \
        /* Do the rest of the loop (all the core of the xfer/convertion  */                                       \
                                                                                                                  \
        ScreenToMemXbpp_Common2(pxxDmaRead, cast, CpuXferTo4bpp_1ByteWidth);                                      \
                                                                                                                  \
                                                                                                                  \
}                                                                                                                 \
/*************************** End of ScreenToMem4bpp_Core_1ByteWidth(pxxDmaRead,cast) *****************************/






#define ScreenToMem8bpp(pxxDmaRead,cast)                                                                          \
{                                                                                                                 \
    /***************************************************************************/                                 \
    /*  Transfer all rectangles regions in the array                           */                                 \
    /***************************************************************************/                                 \
                                                                                                                  \
    for(i=0; i < c; i++) /* For all rectangles */                                                                 \
    {                                                                                                             \
                                                                                                                  \
        ScreenToMemXbpp_Common;    /* This is the beginning of the Xfer loop (for all rectangles) common */       \
                                   /* to all ScreenToMemXbpp functions.                                  */       \
                                   /* In this macro, we setup the linesPerXfer, and all variables needed */       \
                                   /* after this point in the for(all rectangles) (dma offsets, read/    */       \
                                   /* write ptr addresses, ... )                                         */       \
                                                                                                                  \
                                                                                                                  \
        /***************************************************************************    */                        \
        /* Calculate the pointer to the upper-left corner of Destination clipped region */                        \
        /* (THE FINAL DESTINATION, not the MEM2MEM buffer)                              */                        \
        /***************************************************************************    */                        \
                                                                                                                  \
        pjFinalDstWrite =  (BYTE*) psoDst->pvScan0                                                                \
                          + ( parcl[i].top  * lDstPitch )                                                         \
                          + ( parcl[i].left );                                                                    \
                                                                                                                  \
                                                                                                                  \
        /* Calculate the jump to get to the next line of the             */                                       \
        /* final destination rectangle (in the final Dst surface)        */                                       \
        /* AFTER having transfered "bytesPerLine" (in other words,       */                                       \
        /* pitch is the num of bytes to the jump AT THE SAME POSITION    */                                       \
        /* in the bitmap but one line lower; what we want is the jump    */                                       \
        /* value to jump from the end of a line TO THE BEGINNING         */                                       \
        /* of the next line )                                            */                                       \
        /*                                                               */                                       \
        /* (We use width directly because if we are here, we know        */                                       \
        /*  we have 8bpp in the destination, 1 byte per pixel...)        */                                       \
                                                                                                                  \
        FinalDstJump2NextLineBeg = lDstPitch - width;                                                             \
                                                                                                                  \
        /* Do the rest of the loop (all the core of the xfer/convertion  */                                       \
                                                                                                                  \
        ScreenToMemXbpp_Common2(pxxDmaRead, cast, CpuXferTo8bpp);                                                 \
                                                                                                                  \
    } /* ...for(i=0; i < c; i++)  For all rectangles  */                                                          \
                                                                                                                  \
}                                                                                                                 \
/********************************** End of ScreenToMem8bpp(pxxDmaRead,cast) **************************************/
    
    



BOOL NV4ScreenToMem32to4bppBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;           // Total number of lines left to Xfer

    ULONG           bytes2Xfer;          // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;        // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;     // Optimal bytes per Xfer (calculated based on mathematic model 
                                         // and profiling data, see notes)
    ULONG           linesPerXfer;        // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;    // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;    // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;           // Pitch of the source surface
    
    LONG            lDstPitch;           // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;           // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;        // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;     // Pointer to the beg. of the dest. bits (in the final surface)
                                         // (will also be incremented to advance in the destination bits during xfer)
    
    ULONG*          pulDmaRead;          // Pointer in the mem2mem dma buffer that we are going to use in the
                                         // CPU-Xfers to keep track of where we are currently reading 
    
    //USHORT*         psDmaRead;
    //BYTE*           pjDmaRead;
    
    BYTE            XlatedByte, TempByte;

    ULONG*          pulDmaRead_lastXfer; // Var to hold where to read the last CPU-Xfer

    ULONG*          pulDmaRead_start;    // Start of the Mem2Mem buffer

    ULONG*          pulDmaRead_2ndPart;  // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;        // Left top corner of current clipped region/rectangle in Src surface
                                         // to xfer
    
    ULONG           DstDMAOffset;        // Offset (relative to DMA base)
                                         // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;        // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset; // Offset of the 2nd part of the Mem2Mem buffer
       
    BYTE            leftRest, rightRest; // Rest of ( %(modulo) 2 ) of the left and right coordinates 

    LONG            middleWidth;         // Number of bytes to process with the "middle" loop (when Dest == 4 bpp)
    
    NvNotification* pNotifier;           // Pointer to MemToMem notifier array
    NV_XLATE_INIT                        // Initialize cached xlate values
    DECLARE_DMA_FIFO;                    // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
                                          

    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
                
    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMem32to4bppBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL destination rectangle supplied !" );

    ASSERTDD( (psoDst->iBitmapFormat == BMF_4BPP),
              "NV4ScreenToMem32to4bppBlt: Dst bitmap format must be 4bpp" );

    ASSERTDD( (psoSrc->iBitmapFormat == BMF_32BPP),
              "NV4ScreenToMem32to4bppBlt: Src bitmap format must be 32bpp" );

    ASSERTDD( pxlo != NULL,
              "NV4ScreenToMem32to4bppBlt: NULL translation object");

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG is not defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMem32to4bppBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pulDmaRead_start   = (ULONG *)( ppdev->pMemToMemBuffer  );
    pulDmaRead_2ndPart = (ULONG *)( (BYTE*)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1) );
            

    /***********************************************************************/
    /*                                                                     */
    /*  We are ready to start the transfer                                 */
    /*                                                                     */
    /***********************************************************************/
    
    pulDmaRead = pulDmaRead_start;

    ScreenToMem4bpp(pulDmaRead, (ULONG*));
    
    return TRUE;
}
            

BOOL NV4ScreenToMem32to8bppBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;           // Total number of lines left to Xfer

    ULONG           bytes2Xfer;          // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;        // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;     // Optimal bytes per Xfer (calculated based on mathematic model 
                                         // and profiling data, see notes)
    ULONG           linesPerXfer;        // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;    // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;    // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;           // Pitch of the source surface
    
    LONG            lDstPitch;           // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;           // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;        // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;     // Pointer to the beg. of the dest. bits (in the final surface)
                                         // (will also be incremented to advance in the destination bits during xfer)
    
    ULONG*          pulDmaRead;          // Pointer in the mem2mem dma buffer that we are going to use in the
                                         // CPU-Xfers to keep track of where we are currently reading 
    
    //USHORT*         psDmaRead;
    //BYTE*           pjDmaRead;
    
    BYTE            XlatedByte, TempByte;

    ULONG*          pulDmaRead_lastXfer; // Var to hold where to read the last CPU-Xfer

    ULONG*          pulDmaRead_start;    // Start of the Mem2Mem buffer

    ULONG*          pulDmaRead_2ndPart;  // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;        // Left top corner of current clipped region/rectangle in Src surface
                                         // to xfer
    
    ULONG           DstDMAOffset;        // Offset (relative to DMA base)
                                         // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;        // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset; // Offset of the 2nd part of the Mem2Mem buffer
       
    BYTE            leftRest, rightRest; // Rest of ( %(modulo) 2 ) of the left and right coordinates 

    LONG            middleWidth;         // Number of bytes to process with the "middle" loop (when Dest == 4 bpp)
    
    NvNotification* pNotifier;           // Pointer to MemToMem notifier array
    NV_XLATE_INIT                        // Initialize cached xlate values
    DECLARE_DMA_FIFO;                    // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)

    DISPDBG((9, "S32M8: %d (%d*%d) %s src:%s %s (%d,%d), dst:%s %s (%d,%d %d*%d)",
        c, parcl->right-parcl->left,parcl->bottom-parcl->top,
        pxlo?szDbg_XLATEOBJflXlate(pxlo->flXlate):"XO_trivial",
        psoSrc?szDbg_SURFOBJiBitmapFormat(psoSrc->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoSrc), pptlSrc->x, pptlSrc->y, 
        psoDst?szDbg_SURFOBJiBitmapFormat(psoDst->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoDst), prclDst->left, prclDst->top, prclDst->right-prclDst->left, prclDst->bottom-prclDst->top
        ));


    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
                
    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMem32to8bppBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL destination rectangle supplied !" );

    ASSERTDD( (psoDst->iBitmapFormat == BMF_8BPP),
              "NV4ScreenToMem32to8bppBlt: Dst bitmap format must be 8bpp" );

    ASSERTDD( (psoSrc->iBitmapFormat == BMF_32BPP),
              "NV4ScreenToMem32to8bppBlt: Src bitmap format must be 32bpp" );

    ASSERTDD( pxlo != NULL,
              "NV4ScreenToMem32to8bppBlt: NULL translation object");

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG is not defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMem32to8bppBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pulDmaRead_start   = (ULONG *)( ppdev->pMemToMemBuffer  );
    pulDmaRead_2ndPart = (ULONG *)( (BYTE*)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1) );
            

    /***********************************************************************/
    /*                                                                     */
    /*  We are ready to start the transfer                                 */
    /*                                                                     */
    /***********************************************************************/
    
    pulDmaRead = pulDmaRead_start;

    ScreenToMem8bpp(pulDmaRead, (ULONG*));
    
    return TRUE;
}



BOOL NV4ScreenToMem16to4bppBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;           // Total number of lines left to Xfer

    ULONG           bytes2Xfer;          // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;        // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;     // Optimal bytes per Xfer (calculated based on mathematic model 
                                         // and profiling data, see notes)
    ULONG           linesPerXfer;        // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;    // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;    // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;           // Pitch of the source surface
    
    LONG            lDstPitch;           // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;            // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;         // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;      // Pointer to the beg. of the dest. bits (in the final surface)
                                          // (will also be incremented to advance in the destination bits during xfer)
    
    //ULONG*          pulDmaRead;         // Pointer in the mem2mem dma buffer that we are going to use in the
                                          // CPU-Xfers to keep track of where we are currently reading 
    
    USHORT*         psDmaRead;
    //BYTE*           pjDmaRead;
    
    BYTE            XlatedByte, TempByte;

    ULONG*          pulDmaRead_lastXfer; // Var to hold where to read the last CPU-Xfer

    ULONG*          pulDmaRead_start;    // Start of the Mem2Mem buffer

    ULONG*          pulDmaRead_2ndPart;  // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;        // Left top corner of current clipped region/rectangle in Src surface
                                         // to xfer
    
    ULONG           DstDMAOffset;        // Offset (relative to DMA base)
                                         // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;        // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset; // Offset of the 2nd part of the Mem2Mem buffer
       
    BYTE            leftRest, rightRest; // Rest of ( %(modulo) 2 ) of the left and right coordinates 

    LONG            middleWidth;         // Number of bytes to process with the "middle" loop (when Dest == 4 bpp)
    
    NV_XLATE_INIT                        // Initialize cached xlate values
    NvNotification* pNotifier;           // Pointer to MemToMem notifier array
    DECLARE_DMA_FIFO;                    // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
                                          

    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMem16to4bppBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL destination rectangle supplied !" );

    ASSERTDD( (psoDst->iBitmapFormat == BMF_4BPP),
              "NV4ScreenToMem16to4bppBlt: Dst bitmap format must be 4bpp" );

    ASSERTDD( (psoSrc->iBitmapFormat == BMF_16BPP),
              "NV4ScreenToMem16to4bppBlt: Src bitmap format must be 16bpp" );

    ASSERTDD( pxlo != NULL,
              "NV4ScreenToMem16to4bppBlt: NULL translation object");

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG is not defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMem16to4bppBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pulDmaRead_start   = (ULONG *)( ppdev->pMemToMemBuffer  );
    pulDmaRead_2ndPart = (ULONG *)( (BYTE*)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1) );
            

    /***********************************************************************/
    /*                                                                     */
    /*  We are ready to start the transfer                                 */
    /*                                                                     */
    /***********************************************************************/
    
    psDmaRead = (USHORT*) pulDmaRead_start;

    ScreenToMem4bpp(psDmaRead, (USHORT*));
    
    return TRUE;
}



BOOL NV4ScreenToMem16to8bppBlt(

    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    SURFOBJ*    psoSrc,             // Source surface
    SURFOBJ*    psoDst,             // Dest surface
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    XLATEOBJ*   pxlo)               // Provides color translation info
    
{
    
#if DBG        // only allocate those for convenience (for the next assert) on checked builds

    ULONG*      DstBits;
    ULONG*      SrcBits;
    ULONG*      ScreenBitmap;
    DSURF*      pdsurfDst;
    DSURF*      pdsurfSrc;   

#endif

#ifdef  CALIBRATION_ENABLED
    
    ULONG       tempUlong;
    BYTE        msbitPos;

#endif
    

    LONG            i;
    ULONG           j;
    
    BYTE*           limit;

    ULONG           width,height;

    ULONG           linesToGo;           // Total number of lines left to Xfer

    ULONG           bytes2Xfer;          // Total amount of bytes to Xfer for current rectangle
    
    ULONG           bytesPerLine;        // Width of one line of the current rectangle, in bytes

    ULONG           optBytesPerXfer;     // Optimal bytes per Xfer (calculated based on mathematic model 
                                         // and profiling data, see notes)
    ULONG           linesPerXfer;        // Number of lines to transfer by Xfer (based on bytesPerLine and OptBytesPerXfer)

    ULONG           DstDMAincPerXfer;    // linesPerXfer * bytesPerline
    ULONG           SrcDMAincPerXfer;    // (lSrcPitch+bytesPerLine)*linesPerXfer

    LONG            lSrcPitch;           // Pitch of the source surface
    
    LONG            lDstPitch;           // Pitch of the final dest surface

    LONG            FinalDstJump2NextLineBeg; // DstPitch - byterperline (see where it is used)

    BYTE*           pjSrcBits;           // Pointer to the beginning of the source bits (for the Xfer)
    BYTE*           pjSrcRclBits;        // Pointer to the beginning of the source cliped rectangle bits

    BYTE*           pjFinalDstWrite;     // Pointer to the beg. of the dest. bits (in the final surface)
                                         // (will also be incremented to advance in the destination bits during xfer)
    
    //ULONG*          pulDmaRead;        // Pointer in the mem2mem dma buffer that we are going to use in the
                                         // CPU-Xfers to keep track of where we are currently reading 
    
    USHORT*         psDmaRead;
    //BYTE*           pjDmaRead;
    
    BYTE            XlatedByte, TempByte;

    ULONG*          pulDmaRead_lastXfer; // Var to hold where to read the last CPU-Xfer

    ULONG*          pulDmaRead_start;    // Start of the Mem2Mem buffer

    ULONG*          pulDmaRead_2ndPart;  // Address of 2nd part of Mem2Mem buffer

    POINTL          ptlSrcRegion;        // Left top corner of current clipped region/rectangle in Src surface
                                         // to xfer
    
    ULONG           DstDMAOffset;        // Offset (relative to DMA base)
                                         // of the destination bytes in the dst DMA region
    ULONG           SrcDMAOffset;        // Offset of the source bytes in the src DMA region
    
    ULONG           DstDMA2ndPartOffset; // Offset of the 2nd part of the Mem2Mem buffer
       
    BYTE            leftRest, rightRest; // Rest of ( %(modulo) 2 ) of the left and right coordinates 

    LONG            middleWidth;         // Number of bytes to process with the "middle" loop (when Dest == 4 bpp)
    
    NV_XLATE_INIT                        // Initialize cached xlate values
    NvNotification* pNotifier;           // Pointer to MemToMem notifier array
    DECLARE_DMA_FIFO;                    // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
                                          

    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer global information (from pdev) into local variables
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
                
    
    //**************************************************************************
    // Validate parameters first
    //**************************************************************************

    ASSERTDD( ppdev != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL PDEV supplied !" );

    ASSERTDD( c > 0,
              "NV4ScreenToMem16to8bppBlt: Can't handle zero rectangles" ); // ok

    ASSERTDD( parcl != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL destination rectangles supplied !" );
    
    ASSERTDD( psoSrc != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL source surface supplied !" );

    ASSERTDD( psoDst != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL destination surface supplied !" );
    
    ASSERTDD( pptlSrc != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL source upper left point supplied !" );

    ASSERTDD( prclDst != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL destination rectangle supplied !" );

    ASSERTDD( (psoDst->iBitmapFormat == BMF_8BPP),
              "NV4ScreenToMem16to8bppBlt: Dst bitmap format must be 8bpp" );

    ASSERTDD( (psoSrc->iBitmapFormat == BMF_16BPP),
              "NV4ScreenToMem16to8bppBlt: Src bitmap format must be 16bpp" );

    ASSERTDD( pxlo != NULL,
              "NV4ScreenToMem16to8bppBlt: NULL translation object");

    

#if DBG // we dont put asserts in if DBG, the actual macro definition, ASSERTDD is omited when DBG is not defined.
    
    DstBits                = (ULONG *) psoDst->pvBits;
    SrcBits                = (ULONG *) psoSrc->pvBits;
    ScreenBitmap           = (ULONG *) ppdev->pjScreen;
    pdsurfDst              = (DSURF *) psoDst->dhsurf;
    pdsurfSrc              = (DSURF *) psoSrc->dhsurf;
    
#endif         
    
    // Assert that this is a VRAM to SYSRAM blit ( we wont check it with an if, this
    // function is solely made for this case anyway ) 

    ASSERTDD( 
              //SRC is VRAM:       
              (
                ( SrcBits == ScreenBitmap) ||              
                ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN) )
              ) &&
              
              //DEST is SYSRAM:
              (
                (DstBits != ScreenBitmap) &&
                ( (pdsurfDst == NULL) || (pdsurfDst->dt == DT_DIB) )
              ),

              "NV4ScreenToMem16to8bppBlt: Expected a VRAM to SYSRAM blit !"
             
            );

    
    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2)));

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY) {
        
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
    }


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    // and set pitch and src ptr from the appropriate descriptive structure
    //**************************************************************************

    if ( psoSrc->dhsurf != NULL )               // The DSURF obj is not NULL, so
                                                // this srfc is device-managed
                                                // so it is in VRAM, offscreen
        {
        lSrcPitch  = ( (DSURF *) psoSrc->dhsurf )->LinearStride;
        pjSrcBits  = ( (DSURF *) psoSrc->dhsurf )->LinearPtr;
        }
    else
        { // Onscreen (primary surface, GDI managed)
        
        lSrcPitch   = ppdev->lDelta;
        pjSrcBits   = ppdev->pjScreen;
        }
    
    lDstPitch = psoDst->lDelta ;  // Also set the final dest. surface pitch

    
    // Set the offset (relative to the beginning of the dma mem2mem buffer)
    // of the middle of the mem2mem buffer
    // (See further, we use this as the address of the 2nd part of the mem2mem
    // buffer - one part is being written to, while one part is being read from)
     
    DstDMA2ndPartOffset = (ppdev->MemToMemBufferSize >> 1) ;
    
    // Also get the start and middle adress of the mem2membuffer

    pulDmaRead_start   = (ULONG *)( ppdev->pMemToMemBuffer  );
    pulDmaRead_2ndPart = (ULONG *)( (BYTE*)(ppdev->pMemToMemBuffer) + (ppdev->MemToMemBufferSize >> 1) );
            

    /***********************************************************************/
    /*                                                                     */
    /*  We are ready to start the transfer                                 */
    /*                                                                     */
    /***********************************************************************/
    
    psDmaRead = (USHORT*) pulDmaRead_start;

    ScreenToMem8bpp(psDmaRead, (USHORT*));
    
    return TRUE;
}


//******************************************************************************
//  ------------------------------------------------------------------
//              END OF NV4ScreenToMem*to*bppBlt FUNCTIONS
//  ------------------------------------------------------------------
//******************************************************************************

    
    
//******************************Public*Routine**********************************
//
// Function: NV4DmaPushDMAGetScreenBits
//
// Routine Description:
//
// Arguments:
//
//       ppdev - Pointer to the physical device structure
//
// Return Value:
//
//******************************************************************************


VOID NV4DmaPushDMAGetScreenBits(
PDEV*       ppdev,
DSURF*      pdsurfSrc,
SURFOBJ*    psoDst,
RECTL*      prclDst,
POINTL*     pptlSrc)        // Absolute coordinates!

    {
    LONG            cyScan;
    LONG            lDstDelta;
    LONG            lSrcDelta;
    BYTE*           pjDst;
    BYTE*           pjSrc;
    LONG            cjScan;
    LONG            width,height;
    RECTL           rclSrc;
    ULONG           OffsetFromSource;
    ULONG           DstOffset;
    ULONG           SrcOffset;
    NvNotification* pNotifier;

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Setup the 'source' rectangle to read from
    // Note, the prclDst that is passed into here has already
    // been derived from the clip rectangle (no clipping necessary in this function)
    //**************************************************************************

    rclSrc.left   = pptlSrc->x;
    rclSrc.top    = pptlSrc->y;
    rclSrc.right  = pptlSrc->x + (prclDst->right  - prclDst->left);
    rclSrc.bottom = pptlSrc->y + (prclDst->bottom - prclDst->top);

    //**************************************************************************
    // Get width and height of source rectangle
    //**************************************************************************

    width  = (rclSrc.right  - rclSrc.left);
    height = (rclSrc.bottom - rclSrc.top);


    //**************************************************************************
    // Check if source bitmap (from video mem) is offscreen or onscreen
    //**************************************************************************

    if (pdsurfSrc != NULL)
        {
        lSrcDelta  = pdsurfSrc->LinearStride;
        pjSrc      = pdsurfSrc->LinearPtr;
        }
    else
        {
        lSrcDelta   = ppdev->lDelta;
        pjSrc       = ppdev->pjScreen;
        }

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Source rectangle 
    //**************************************************************************

    OffsetFromSource = ( (rclSrc.top  * lSrcDelta) + CONVERT_TO_BYTES(rclSrc.left, ppdev)) ;   
    pjSrc += OffsetFromSource;
                
    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Destination rectangle 
    //**************************************************************************

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + (prclDst->top  * lDstDelta)
                                          + CONVERT_TO_BYTES(prclDst->left, ppdev);
                                          
    //**************************************************************************
    // Calculate number of scanlines to copy (cyScan), and
    // Calculate number of bytes to copy for each scanline (cjScan)
    //**************************************************************************

    cjScan = CONVERT_TO_BYTES(width, ppdev);
    cyScan = height;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(11)));  

    //**************************************************************************
    // Calculate the offset from the beginning of the DMA Buffer Base
    //**************************************************************************

    DstOffset = (ULONG)(pjDst - (BYTE *)ppdev->pMemToMemBuffer);
    SrcOffset = (ULONG)(pjSrc - ppdev->pjFrameBufbase);

    //**************************************************************************
    // Set memory to memory object in spare subchannel
    //**************************************************************************

    if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY)
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
        ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
        }

    //**********************************************************************
    // Set methods for memory_to_memory dma blit
    //   NV039_OFFSET_IN                                            
    //   NV039_OFFSET_OUT                                           
    //   NV039_PITCH_IN                                             
    //   NV039_PITCH_OUT                                            
    //   NV039_LINE_LENGTH_IN                                       
    //   NV039_LINE_COUNT                                           
    //   NV039_FORMAT                                               
    //   NV039_BUFFER_NOTIFY                                        
    //**********************************************************************

    //**************************************************************************
    // Set notifier to 'BUSY' value (use second notification structure)
    //**************************************************************************

    pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

    NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
    NV_DMA_FIFO = SrcOffset;        // Offset In
    NV_DMA_FIFO = DstOffset;        // Offset Out
    NV_DMA_FIFO = lSrcDelta;        // Pitch In
    NV_DMA_FIFO = lDstDelta;        // Pitch Out
    NV_DMA_FIFO = cjScan;           // Line Length In
    NV_DMA_FIFO = cyScan;           // Line Count
    NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
    NV_DMA_FIFO = 0;                // Set Buffer Notify and kickoff

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    //**************************************************************************
    // Wait for DMA to be completed (use second notification structure)
    //**************************************************************************

    while ( pNotifier->status != 0 );
    

    return;
    }

//******************************************************************************
//
//  Function:   NV4DmaPushXfer8to32bpp
//
//  Routine Description: Does 8bpp to 32bpp translation and puts the translated
//      image in the DMA push buffer. Does not use indexed image.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushXfer8to32bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // Array of relative coordinates destination rectangles
ROP4        rop4,               // rop4
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,       // Solid Color of pattern - NOT USED
BLENDOBJ*   pBlendObj)

    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    LONG    xsrc,ysrc;
    BYTE    *NextScan;
    ULONG   yscan;
    BYTE    *SrcPtr;
    ULONG   DwordCount;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    ULONG   i;

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        NextScan = (&(SrcBits[(LONG)(xsrc + (ysrc*BytesPerSrcScan))]));

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ( (clip_y <<16) | (clip_x & 0xffff)  );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width  );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width  );

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0; yscan < clip_height; yscan++)
            {

            DwordCount = clip_width;
            SrcPtr = NextScan;

            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)(DwordCount+2)));  

            if (DwordCount >= MAX_INDEXED_IMAGE_DWORDS)

                {
                NV_DMAPUSH_START(MAX_INDEXED_IMAGE_DWORDS, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
                //**************************************************************
                // Set the following methods for IMAGE_FROM_CPU
                //     NV061_COLOR(0)
                //     NV061_COLOR(1)
                //     NV061_COLOR(2)
                //      ...
                //**************************************************************

                for (i=0; i < MAX_INDEXED_IMAGE_DWORDS; i++)
                    {
                    NV_DMA_FIFO = pulXlate[*SrcPtr++];    
                    }
                DwordCount -= MAX_INDEXED_IMAGE_DWORDS;
                }

            if (DwordCount>0)
                {
                
                NV_DMAPUSH_START(DwordCount, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
    
                //**************************************************************
                // Set the following methods for IMAGE_FROM_CPU
                //     NV061_COLOR(0)
                //     NV061_COLOR(1)
                //     NV061_COLOR(2)
                //      ...
                //**************************************************************

                while (DwordCount > 0)
                    {
                    NV_DMA_FIFO = pulXlate[*SrcPtr++];
                    DwordCount--;
                    }
                }

            NextScan+=BytesPerSrcScan;

            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }

        if (--c == 0)
            return;

        prcl++;

        } // while (TRUE)...

    }

//******************************************************************************
//
//  Function:   NV4DmaPushXfer4to32bpp
//
//  Routine Description: Does 4bpp to 32bpp translation and puts the translated
//      image in the DMA push buffer. Does not use indexed image. 
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushXfer4to32bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // Array of relative coordinates destination rectangles
ROP4        rop4,               // rop4
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,       // Solid Color of pattern - NOT USED
BLENDOBJ*   pBlendObj)

    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    LONG    xsrc,ysrc;
    BYTE    *NextScan;
    ULONG   yscan;
    BYTE    *SrcPtr;
    ULONG   DwordCount;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    ULONG   i;

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        NextScan = &(SrcBits[(LONG)(((xsrc)>>1) + (ysrc*BytesPerSrcScan))]);

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ((clip_y <<16) | (clip_x & 0xffff));
        NV_DMA_FIFO = ((clip_height <<16) | clip_width);
        NV_DMA_FIFO = ((clip_height <<16) | clip_width);

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0; yscan < clip_height; yscan++)
            {
            DwordCount = clip_width;
            SrcPtr = NextScan;

            NV_DMAPUSH_CHECKFREE(((ULONG)(DwordCount+4)));  
            
            if (xsrc & 1)
                {
                NV_DMAPUSH_START(1, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );
                NV_DMA_FIFO = pulXlate[(*(SrcPtr)) & 0xf];
                DwordCount--;
                SrcPtr++;
                }

            if (DwordCount >= MAX_INDEXED_IMAGE_DWORDS)

                {
            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

                NV_DMAPUSH_START(MAX_INDEXED_IMAGE_DWORDS, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //**************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //**************************************************************

                for (i=0; i < ((MAX_INDEXED_IMAGE_DWORDS)/2) ; i++)
                    {
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) >> 4];    
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) & 0xf];
                    SrcPtr++;
                    }
                DwordCount -= MAX_INDEXED_IMAGE_DWORDS;
                }

            if (DwordCount>0)
                {
            
            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

                NV_DMAPUSH_START(DwordCount, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //**************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //**************************************************************

                while (DwordCount >= 2)
                    {
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) >> 4];    
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) & 0xf];
                    SrcPtr++;
                    DwordCount -= 2;
                    }

                if (DwordCount > 0)
                    {
                    NV_DMA_FIFO = pulXlate[(*SrcPtr) >> 4];
                    DwordCount--;
                    }
                }

            NextScan+=BytesPerSrcScan;

        //******************************************************************
        // Kickoff buffer after each scanline
        //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }
        if (--c == 0)
            return;

        prcl++;

        } // while (TRUE)...
    }


//******************************************************************************
//
//  Function:   NV4DmaPushXfer8to16bpp
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushXfer8to16bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // Array of relative coordinates destination rectangles
ROP4        rop4,               // rop4
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,       // Solid Color of pattern - NOT USED
BLENDOBJ*   pBlendObj
)
    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    ULONG   temp;
    LONG    xsrc,ysrc;
    BYTE    *NextScan;
    ULONG   yscan;
    BYTE    *SrcPtr;
    ULONG   WordCount;
    ULONG   ByteCount;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    ULONG   i;
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        NextScan = (&(SrcBits[xsrc + (ysrc*BytesPerSrcScan)]));

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ( (clip_y <<16) | (clip_x & 0xffff)  );
        NV_DMA_FIFO = ( (clip_height <<16) | clip_width  );
        NV_DMA_FIFO = ( (clip_height <<16) | (clip_width+1)&0xfffe);

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0; yscan < clip_height; yscan++)
            {

            ByteCount = clip_width;
            WordCount = ByteCount>>1;
            SrcPtr = NextScan;

            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)((ByteCount+1)>>1)+1));  
            NV_DMAPUSH_START((ByteCount+1)>>1, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //**************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //**************************************************************

            while (WordCount > 0)
                {
                temp = pulXlate[*SrcPtr++];
                NV_DMA_FIFO = pulXlate[*SrcPtr++]<<16 | temp;
                WordCount--;
                }
                
            if (ByteCount&1)
                {
                temp = pulXlate[*SrcPtr];
                NV_DMA_FIFO = temp;
                }

            NextScan+=BytesPerSrcScan;

            //******************************************************************
            // Kickoff buffer after each scanline
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }

        if (--c == 0)
            return;

        prcl++;

        } // while (TRUE)...

    }


//******************************************************************************
//
//  Function:   NV4DmaPushXfer4to16bpp
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushXfer4to16bpp(     // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // Array of relative coordinates destination rectangles
ROP4        rop4,               // rop4
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo,
ULONG       PatternColor,       // Solid Color of pattern - NOT USED
BLENDOBJ*   pBlendObj
)
    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    LONG    BytesPerSrcScan;
    ULONG   Rop3;
    ULONG   temp;
    LONG    xsrc,ysrc;
    BYTE    *NextScan;
    ULONG   yscan;
    BYTE    *SrcPtr;
    ULONG   ByteCount;
    LONG    clip_x,clip_y;
    ULONG   clip_width,clip_height;
    ULONG   i;
    DECLARE_DMA_FIFO;


    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Setup NV Blit parameters for CPU (MEMORY to SCREEN) blit
    //**************************************************************************

    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Enumerate the clipping regions
    //**************************************************************************

    while(TRUE)
        {
        //**********************************************************************
        // Top left coordinate of destination on destination surface
        //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

        //**********************************************************************
        // Top left coordinate of source bitmap on source surface
        //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y - prclDst->top;

        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  

        //************************************************************************
        // Check if 4bpp bitmap starting x is odd. In this case, we will add 1 to
        // width and start drawing the bitmap as if it were even, and use hardware
        // clipping to take care of it.
        //************************************************************************
    
        if ((xsrc&1))
            {
        //*********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //*********************************************************************

       
            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = ((0 << 16) | clip_x);
            NV_DMA_FIFO = (((ppdev->cyMemory)<<16) | clip_width);

            ppdev->NVClipResetFlag=TRUE;
            clip_width++;
            clip_x--;
            xsrc--;
            }

        //********************************************************************
        // Reset clipping rectangle to full screen extents if necessary
        // Resetting the clipping rectangle causes delays so we want to do it
        // as little as possible!
        //********************************************************************

        else if (ppdev->NVClipResetFlag)
            {

        //*********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //*********************************************************************

            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = 0;
            NV_DMA_FIFO = ppdev->dwMaxClip; 

            ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
            }

        //**********************************************************************
        // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
        // ignore/clip the extra pixel that we send it, so that it won't
        // get included as part of the next scanline. Since we always
        // send DWords at a time, we may actually send more data to the NV
        // engine than is necessary.  So clip it by specifying a larger SizeIn
        // That is, we always send DWORDS at a time for each scanline.
        // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
        //**********************************************************************

        NextScan = (&(SrcBits[(LONG)((xsrc>>1) + (ysrc*BytesPerSrcScan))]));

        //**********************************************************************
        // Initialize the ImageFromCpu object
        //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        //**********************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_POINT     
        //     NV061_SIZE_OUT  
        //     NV061_SIZE_IN 
        //**********************************************************************

        NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
        NV_DMA_FIFO = ((clip_y <<16) | (clip_x & 0xffff));
        NV_DMA_FIFO = ((clip_height <<16) | clip_width);
        NV_DMA_FIFO = ( (clip_height <<16) | (clip_width+1)&0xfffe);

        //**********************************************************************
        // Output one scan at a time
        //**********************************************************************

        for (yscan=0; yscan < clip_height; yscan++)
            {
            ByteCount = clip_width>>1;
            SrcPtr = NextScan;


            //**************************************************************
            // Check if we've got enough room in the push buffer
            //**************************************************************

            NV_DMAPUSH_CHECKFREE(((ULONG)((clip_width+1)>>1)+1));  
            NV_DMAPUSH_START((clip_width+1)>>1, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

            //**************************************************************
            // Set the following methods for IMAGE_FROM_CPU
            //     NV061_COLOR(0)
            //     NV061_COLOR(1)
            //     NV061_COLOR(2)
            //      ...
            //**************************************************************

            while (ByteCount > 0)
                {
                temp = pulXlate[(*SrcPtr) >> 4];    
                NV_DMA_FIFO = (pulXlate[(*SrcPtr) & 0xf]) <<16 | temp;
                SrcPtr++;
                ByteCount--;
                }

            if (clip_width&1)
                {
                temp = pulXlate[(*SrcPtr) >> 4];    
                NV_DMA_FIFO = temp;
                }

            NextScan+=BytesPerSrcScan;

        //******************************************************************
        // Kickoff buffer after each scanline
        //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;

            }
        if (--c == 0)
            return;

        prcl++;

        } // while (TRUE)...
    }

//******************************************************************************
//
//  Function:   NV4DmaPushFastXfer8to32
//
//  Routine Description: Does 8bpp to 32bpp translation and puts the translated
//      image in the DMA push buffer. Does not use indexed image.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushFastXfer8to32(   // Type FastXFER
PDEV*       ppdev,
RECTL*      prcl,               // Array of relative coordinates destination rectangles
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
XLATEOBJ*   pxlo)

    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    BYTE    *SrcPtr;
    ULONG   clip_x;
    ULONG   clip_width;
    ULONG   i;

    DECLARE_DMA_FIFO;
    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) (psoSrc->lDelta) & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**********************************************************************
    // Top left coordinate of destination on destination surface
    //**********************************************************************

    clip_x = prcl->left;

    //**********************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**********************************************************************

    clip_width = (prcl->right - prcl->left) & 0xffff;

    //**********************************************************************
    // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    //**********************************************************************

    SrcPtr = (BYTE *)(&(SrcBits[pptlSrc->x + ((pptlSrc->y)*(psoSrc->lDelta))]));

    //**********************************************************************
    // Check if we've got enough room in the push buffer
    //**********************************************************************

    NV_DMAPUSH_CHECKFREE((ULONG)(clip_width + 7));  

    //**********************************************************************
    // Initialize the ImageFromCpu object
    //**********************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , NV_SRCCOPY);

    //**********************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_POINT     
    //     NV061_SIZE_OUT  
    //     NV061_SIZE_IN 
    //**********************************************************************

    NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
    NV_DMA_FIFO = (((prcl->top) << 16) | (clip_x & 0xffff));
    NV_DMA_FIFO = ((1 << 16) | clip_width);
    NV_DMA_FIFO = ((1 << 16) | clip_width);

    //**********************************************************************
    // Output one scanline - only 1
    //**********************************************************************

    if (clip_width >= MAX_INDEXED_IMAGE_DWORDS)

        {
        //**************************************************************
        // Check if we've got enough room in the push buffer
        //**************************************************************

        NV_DMAPUSH_START(MAX_INDEXED_IMAGE_DWORDS, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

        //**************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_COLOR(0)
        //     NV061_COLOR(1)
        //     NV061_COLOR(2)
        //      ...
        //**************************************************************

        for (i=0; i < MAX_INDEXED_IMAGE_DWORDS; i++)
            {
            NV_DMA_FIFO = pulXlate[*SrcPtr++];    
            }
        clip_width -= MAX_INDEXED_IMAGE_DWORDS;
        }

    if (clip_width > 0)
        {
        
        //**************************************************************
        // Check if we've got enough room in the push buffer
        //**************************************************************

        NV_DMAPUSH_START(clip_width, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

        //**************************************************************
        // Set the following methods for IMAGE_FROM_CPU
        //     NV061_COLOR(0)
        //     NV061_COLOR(1)
        //     NV061_COLOR(2)
        //      ...
        //**************************************************************

        while (clip_width > 0)
            {
            NV_DMA_FIFO = pulXlate[*SrcPtr++];
            clip_width--;
            }

        }

    //******************************************************************
    // Kickoff buffer
    //******************************************************************

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer

    }

//******************************************************************************
//
//  Function:   NV4DmaPushFastXfer8to16
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushFastXfer8to16(   // Type FastXFER
PDEV*       ppdev,
RECTL*      prcl,               // Array of relative coordinates destination rectangles
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
XLATEOBJ*   pxlo)

    {
    ULONG   *pulXlate;
    BYTE    *SrcBits;
    ULONG   temp;
    BYTE    *SrcPtr;
    ULONG   WordCount;
    ULONG   ByteCount;
    LONG    clip_x;
    ULONG   clip_width;
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Get Number of bytes to advance to next scanline in SOURCE
    //**************************************************************************

    pulXlate        = pxlo->pulXlate;
    SrcBits         = psoSrc->pvScan0;

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) SrcBits & 0x3),
        "Src address is not dword aligned"); // ACK!..src addr is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) (psoSrc->lDelta & 0x3)),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //**************************************************************************

    if (ppdev->NVClipResetFlag)
        {
        //**********************************************************************
        // Check if we've got enough room in the push buffer
        //**********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(3)));  

        //**********************************************************************
        // Set Point and Size methods for clip:
        //    NV019_SET_POINT
        //    NV019_SET_SIZE
        //**********************************************************************

        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 

        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
        }

    //**********************************************************************
    // Top left coordinate of destination on destination surface
    //**********************************************************************

    clip_x = prcl->left;

    //**********************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**********************************************************************

    clip_width = prcl->right - clip_x;
    WordCount = clip_width>>1;

    //**********************************************************************
    // Specifying 1 more pixel (in 16bpp) for SizeIn causes the NV engine to
    // ignore/clip the extra pixel that we send it, so that it won't
    // get included as part of the next scanline. Since we always
    // send DWords at a time, we may actually send more data to the NV
    // engine than is necessary.  So clip it by specifying a larger SizeIn
    // That is, we always send DWORDS at a time for each scanline.
    // For 8bpp, we may specify up to 3 additional pixels (which get ignored)
    //**********************************************************************

    SrcPtr = (BYTE *)(&(SrcBits[pptlSrc->x + ((pptlSrc->y)*(psoSrc->lDelta))]));

    //**********************************************************************
    // Check if we've got enough room in the push buffer
    //**********************************************************************

    NV_DMAPUSH_CHECKFREE((ULONG)(WordCount+7));  

    //**********************************************************************
    // Initialize the ImageFromCpu object
    //**********************************************************************

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , NV_SRCCOPY);

    //**********************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_POINT     
    //     NV061_SIZE_OUT  
    //     NV061_SIZE_IN 
    //**********************************************************************

    NV_DMAPUSH_START(3, IMAGE_FROM_CPU_SUBCHANNEL, NV061_POINT );
    NV_DMA_FIFO = (((prcl->top) <<16) | (clip_x & 0xffff));
    NV_DMA_FIFO = ((1 << 16) | clip_width);
    NV_DMA_FIFO = ((1 << 16) | (clip_width+1)&0xfffe);

    //**************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************

    NV_DMAPUSH_START((clip_width+1)>>1, IMAGE_FROM_CPU_SUBCHANNEL, NV061_COLOR(0) );

    //**************************************************************
    // Set the following methods for IMAGE_FROM_CPU
    //     NV061_COLOR(0)
    //     NV061_COLOR(1)
    //     NV061_COLOR(2)
    //      ...
    //**************************************************************

    while (WordCount > 0)
        {
        temp = pulXlate[*SrcPtr++];
        NV_DMA_FIFO = pulXlate[*SrcPtr++]<<16 | temp;
        WordCount--;
        }
        
    if (clip_width&1)
        {
        temp = pulXlate[*SrcPtr];
        NV_DMA_FIFO = temp;
        }

    //******************************************************************
    // Kickoff buffer after each scanline
    //******************************************************************

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer

    }

//******************************************************************************
//
//  Function:   NV4DmaPushIndexedImage
//
//  Routine Description:
//
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV4DmaPushIndexedImage(    // Type FNXFER

    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern
    BLENDOBJ*   pBlendObj)

    {

    BYTE* pjSrcScan0;

    ULONG lutEntries;
    ULONG sourcePixelDepth;
    LONG  BytesPerSrcScan;
    ULONG BytesPerDstScan;
    ULONG ScanInc;
    ULONG Rop3;
    ULONG temp;
    LONG  xsrc,ysrc;
    ULONG xsrcOffset;
    ULONG AlignMask;
    BYTE  *NextScan;
    ULONG *ScanPtr;
    ULONG yscan;
    ULONG SizeInWidth;
    LONG  clip_x,clip_y;
    ULONG clip_width,clip_height;
    ULONG *pulXlate;
    ULONG *currentLut;
    ULONG i;
    ULONG TempPixelData;
    ULONG LoopCount;
    ULONG DwordCount;
    ULONG ByteCount;
    ULONG tempId;
    ULONG savedId;
    ULONG lutOffset;
    ULONG notifierIndex;
    ULONG red5;
    ULONG green6;
    ULONG blue5;

    DECLARE_DMA_FIFO;
    
    ASSERTDD(pBlendObj == NULL, "Can't handle Alpha Blends");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    //**************************************************************************
    // Get ready to translate the 4bpp colors
    //**************************************************************************

    ASSERTDD(pxlo != NULL, "Xfer4BPP, NULL XLATEOBJ");

    //**************************************************************************
    // Force channelsync          
    // BugFix for Indexed image   
    // blits when OGL running,    
    // for NV < NV10              
    // bug #20000720-213841       
    //**************************************************************************
    if ( OglIsEnabled(ppdev) && 
         ppdev->CurrentClass.ChannelDMA == NV04_CHANNEL_DMA ) 
    {
        ppdev->oglLastChannel = -1;           
        ppdev->pfnWaitForChannelSwitch(ppdev);
    }                                         

    //**************************************************************************
    // Current pixel depth
    //**************************************************************************

    sourcePixelDepth = psoSrc->iBitmapFormat;

    //**************************************************************************
    // Get pointer to start of source bitmap
    //**************************************************************************

    pjSrcScan0 = psoSrc->pvScan0;
    BytesPerSrcScan = psoSrc->lDelta;
    ScanInc = (BytesPerSrcScan+3) >> 2;      // Number of dwords to increment

    //**************************************************************************
    // Verify that src bitmap is DWORD aligned.  As far as I can tell, this
    // appears to always be the case.
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) pjSrcScan0 & 0x3),
        "Unaligned source bitmap");// ACK!....src bitmap is not dword aligned !!!

    //**************************************************************************
    // Verify that src bitmap pitch is a multiple of 4 (for dwords)
    //**************************************************************************

    ASSERTDD(!((ULONG_PTR) BytesPerSrcScan & 0x3),
        "Pitch is not dword aligned"); // ACK!....pitch is not dword aligned !!!

    //**************************************************************************
    // Get Rop3 value
    //**************************************************************************
    Rop3 = (rop4 & 0xff);               // Get bottom byte

    //**************************************************************************
    // Each LUT is associated with an indexed image operation. To improve
    // performance, there are multiple indexed image objects with an associated
    // LUT. This is necessary because the LUT can't be updated before an operation
    // has completed; otherwise it will be corrupted. There is a notifier assoicated
    // with each indexed image operation. This code checks for a completed
    // operation so it can use that indexed image object and associated LUT. This
    // is much faster than waiting for the engine idle, or even waiting for the
    // previous indexed image operation to be completed.
    //**************************************************************************

    //**************************************************************************
    // Wait for completed indexed image object.
    //**************************************************************************

    notifierIndex = (ppdev->NvLastIndexedImageNotifier + 1)&(MAX_INDEXED_IMAGE_NOTIFIERS-1);
    
    while (TRUE)
        {
        if (((NvNotification *) (&(ppdev->Notifiers->DmaToMemIndexedImage[notifierIndex*sizeof(NvNotification)])))->status
                                             != NV064_NOTIFICATION_STATUS_IN_PROGRESS)
            break;      // operation has completed - free to re-use.
        notifierIndex = (notifierIndex+1)&(MAX_INDEXED_IMAGE_NOTIFIERS-1); // check next indexed image object
        }

    //**************************************************************************
    // Load LUT associated with indexed image object.
    //**************************************************************************

    ppdev->NvLastIndexedImageNotifier = notifierIndex;
    lutOffset = notifierIndex << 10;        // each LUT is max of 1024 bytes

    pulXlate  =  pxlo->pulXlate;
    currentLut = (ULONG *) ((BYTE*)(ppdev->NvDmaIndexedImageLut) + lutOffset);
    lutEntries = pxlo->cEntries;
    
    if (ppdev->iBitmapFormat == BMF_32BPP)  // destination pixel format 32bpp
        {
        while (lutEntries--)
            *currentLut++ = *pulXlate++;
        }
    else
        {
        //**********************************************************************
        // In 16bpp, indexed image hardware will dither when using R5G6B5. 
        // So we must use X8R8G8B8 instead to get the exact desired results
        //**********************************************************************
           
        while (lutEntries--)
            {     
            temp    = *pulXlate++;
            blue5   = temp & 0x001f;            // Get bottom 5 bits
            green6  = temp & 0x07e0;            // Get middle 6 bits
            red5    = temp & 0xf800;            // Get top 5 bits
            
            blue5   <<=3;                       // Convert R5G6B5 to X8R8G8B8
            green6  <<=5;                       
            red5    <<=8;                        
 
            *currentLut++ = (red5 | green6 | blue5);    // Store LUT data
            }
        }

    //************************************************************************
    // Get push buffer information    
    //************************************************************************

    INIT_LOCAL_DMA_FIFO;

    while (TRUE)
        {
        
    //**********************************************************************
    // Top left coordinate of destination on destination surface
    //**********************************************************************

        clip_x = prcl->left;
        clip_y = prcl->top;

    //**********************************************************************
    // Top left coordinate of source bitmap on source surface
    //**********************************************************************

        xsrc = pptlSrc->x + clip_x - prclDst->left;
        ysrc = pptlSrc->y + clip_y  - prclDst->top;

    //**********************************************************************
    // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
    // That is, the lower right coordinate is NOT included
    // For NV, the width/height actually means the number of
    // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
    // when calculating width and height.
    //**********************************************************************

        clip_width = prcl->right - clip_x;
        clip_height = prcl->bottom - clip_y;

    //***********************************************************************
    // Check if we've got enough room in the push buffer
    //***********************************************************************

        NV_DMAPUSH_CHECKFREE(((ULONG)(13))); 

    //************************************************************************
    // For the X86, check if 4bpp bitmap starting x is odd. In this case, we
    // will add 1 to width and start drawing the bitmap as if it were even,
    // and use hardware clipping to take care of it.
    //************************************************************************

    //************************************************************************
    // The IA64 has a different problem, but can use the same solution.
    // The processor will fault on unaligned addresses.  So reuse the code,
    // but with more stringent alignment requirements.
    //************************************************************************

#ifdef _WIN64
        if (sourcePixelDepth == BMF_4BPP)
           AlignMask = 0x7;
        else
           AlignMask = 0x3;
#else
        if (sourcePixelDepth == BMF_4BPP)
           AlignMask = 0x1;
        else
           AlignMask = 0x0;
#endif
        xsrcOffset = xsrc & AlignMask;
        if (xsrcOffset)
           {
           xsrc &= ~AlignMask;
        
       //*********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //*********************************************************************

           NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
           NV_DMA_FIFO = ((0 << 16) | clip_x);
           NV_DMA_FIFO = (((ppdev->cyMemory)<<16) | clip_width);

           ppdev->NVClipResetFlag=TRUE;

           // adjust clip_x, clip_width - used for Dst x and width from here on
           clip_x -= xsrcOffset;
           clip_width += xsrcOffset;
           } 

    //************************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to do it
    // as little as possible!
    //************************************************************************

        else if (ppdev->NVClipResetFlag)
           {

       //*********************************************************************
       // Set Point and Size methods for clip:
       //    NV019_SET_POINT
       //    NV019_SET_SIZE
       //*********************************************************************

           NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
           NV_DMA_FIFO = 0;
           NV_DMA_FIFO = ppdev->dwMaxClip; 

           ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
           }

    //**********************************************************************
    // Get ptr to start of SRC. For 4bpp case, there are 2 pixels per byte.
    //**********************************************************************

        if (sourcePixelDepth == BMF_4BPP)
            {
            SizeInWidth = ((clip_width + 7) & 0xfff8);
            NextScan = (&(pjSrcScan0[(LONG)((xsrc>>1) + ysrc*BytesPerSrcScan)]));
            LoopCount = (clip_width+1) >> 3;    // Each loop handles 8 pels
            ByteCount = ((clip_width+1) & 7) >>1;   // extra bytes in bitmap
            }
        else
            {
            SizeInWidth = ((clip_width + 3) & 0xfffc);
            NextScan = (&(pjSrcScan0[(LONG)((xsrc) + ysrc*BytesPerSrcScan)]));
            LoopCount = clip_width >> 2;        // Each loop handles 4 pels
            ByteCount = clip_width & 3;         // extra bytes in bitmap
            }
        
        BytesPerDstScan = (LoopCount*4) + ByteCount;            
        
    //**********************************************************************
    // Set the following methods for INDEXED_IMAGE_FROM_CPU
    //     ROP
    //     SET_OBJECT and restore later
    //**********************************************************************

        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV064_SET_OBJECT, DD_INDEXED_IMAGE1_FROM_CPU+notifierIndex);

    //**********************************************************************
    // Set the following methods for INDEXED_IMAGE_FROM_CPU
    //     NV064_INDEX_FORMAT
    //     NV064_LUT_OFFSET
    //     NV064_POINT     
    //     NV064_SIZE_OUT  
    //     NV064_SIZE_IN 
    //**********************************************************************

        NV_DMAPUSH_START(5, IMAGE_FROM_CPU_SUBCHANNEL, NV064_INDEX_FORMAT);
        if (sourcePixelDepth == BMF_4BPP)
            NV_DMA_FIFO = NV064_INDEX_FORMAT_SVGA65_I4;
        else
            NV_DMA_FIFO = NV064_INDEX_FORMAT_LE_I8;
        NV_DMA_FIFO = lutOffset;        // byte offset

        NV_DMA_FIFO = ((clip_y << 16) | (clip_x & 0xffff));
        NV_DMA_FIFO = ((clip_height <<16) | clip_width);
        NV_DMA_FIFO = ((clip_height <<16) | SizeInWidth);

    //**********************************************************************
    // Output 1 scanline at a time.
    //**********************************************************************

#ifdef _X86_
        //**********************************************************************
        // Use assembly to output as fast as possible
        //**********************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPush_Transfer_MemToScreen_Data(ppdev,BytesPerDstScan,clip_height, (ULONG *)NextScan,ScanInc);
        UPDATE_LOCAL_DMA_COUNT;

#else   // ifdef _x86_

        for (yscan=0; yscan < clip_height; yscan++)
            {
            DwordCount = LoopCount;
            ScanPtr = (ULONG*) NextScan;
            
            
        //**********************************************************************
        // IMAGE_FROM_CPU can output a maximum of 1792 dwords at a time.
        // For very high resolutions, there is the possibility of exceeding this
        // maximum once per scanline; typically, it will never happen.
        //**********************************************************************

            if (DwordCount >= MAX_INDEXED_IMAGE_DWORDS)
                {

        //**********************************************************************
        // Check if we've got enough room in the push buffer and write 1792 dwords
        //**********************************************************************
        
                NV_DMAPUSH_CHECKFREE(((ULONG)(MAX_INDEXED_IMAGE_DWORDS+1)));  

                NV_DMAPUSH_START(MAX_INDEXED_IMAGE_DWORDS, IMAGE_FROM_CPU_SUBCHANNEL, NV064_INDICES(0) );
    
        //**********************************************************************
        // Set the following methods for INDEXED_IMAGE_FROM_CPU
        //     NV064_INDICES(0)
        //     NV064_INDICES(1)
        //     NV064_INDICES(2)
        //      ...
        //**********************************************************************
    
                for (i=0; i < MAX_INDEXED_IMAGE_DWORDS; i++)
                    NV_DMA_FIFO = ScanPtr[i];    
                DwordCount -= MAX_INDEXED_IMAGE_DWORDS;
                ScanPtr += MAX_INDEXED_IMAGE_DWORDS;

                }

            if (DwordCount > 0)
                {
                NV_DMAPUSH_CHECKFREE(((ULONG)(DwordCount+1)));  

                NV_DMAPUSH_START(DwordCount, IMAGE_FROM_CPU_SUBCHANNEL, NV064_INDICES(0) );
    
        //**********************************************************************
        // Set the following methods for INDEXED_IMAGE_FROM_CPU
        //     NV064_INDICES(0)
        //     NV064_INDICES(1)
        //     NV064_INDICES(2)
        //      ...
        //**********************************************************************
    
                for (i=0; i<DwordCount; i++)
                    NV_DMA_FIFO = ScanPtr[i];    
                }
                
            if (ByteCount > 0)
                {
                ScanPtr += DwordCount;
                TempPixelData = 0;
                for (i=0; i<ByteCount; i++)
                    TempPixelData |= ((PBYTE) (ScanPtr))[i] << (8 * i);
                NV_DMAPUSH_CHECKFREE(((ULONG)(2)));  

                NV_DMAPUSH_START(1, IMAGE_FROM_CPU_SUBCHANNEL, NV064_INDICES(0) );
                NV_DMA_FIFO = TempPixelData;
                }
                
            NextScan += BytesPerSrcScan;
            UPDATE_PDEV_DMA_COUNT;
            NV4_DmaPushSend(ppdev);                 // Time to kickoff the buffer
            UPDATE_LOCAL_DMA_COUNT;
            }

#endif  // ifdef else _X86_

        //******************************************************************
        // Restore channel and send data on thru to the DMA push buffer
        //******************************************************************

            if (--c == 0)
                {

        //*******************************************************************
        // Use a notifier so that the next time we get into indexed image
        // we can check if this is finished instead of doing an engine wait.
        //*******************************************************************

                ((NvNotification *) (&(ppdev->Notifiers->DmaToMemIndexedImage[notifierIndex*sizeof(NvNotification)])))->status = NV064_NOTIFICATION_STATUS_IN_PROGRESS;

                NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV064_NOTIFY       , NV064_NOTIFY_WRITE_ONLY);
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV064_NO_OPERATION , 0x00000000);

                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OBJECT, DD_IMAGE_FROM_CPU);

                UPDATE_PDEV_DMA_COUNT;
                NV4_DmaPushSend(ppdev);
                return;
                }

            prcl++;

        } // while (TRUE)
    }


//******************************************************************************
//
//  Function:   NV4DmaPushStretchCopy
//
//  Routine Description:
//      Private escape function for Desktop Manager zoom feature.
//      Performs a vidmem-to-vidmem unclipped SRCCOPY stretched blit.
//      Implements the ESC_NV_DESKMGR_ZOOMBLIT escape.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL NV4DmaPushStretchCopy(     // Type FNSTRETCHCOPY

    PDEV*       ppdev,
    ULONG       uSmooth,        // Non-zero for a smoothed copy.
    int         iScale,         // Scale factor.
    RECTL*      prclSrc,        // Source rectangle.
    RECTL*      prclDst,        // Destination rectangle.
    int         iClips,         // Number of destination clips (0 is OK).
    RECTL*      prclClips)      // Destination clips (NULL OK if zero clips).

    {
    unsigned uSrcColorFormat;
    unsigned uDstPoint, uDstSize;
    unsigned uClipPoint, uClipSize;
    unsigned uDSDX;
    unsigned uSrcPoint, uSrcSize, uSrcOffset;
    unsigned uInFormat;
    unsigned x, y, i;
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    // The modeswitch counter is odd whenever modeset/powersave is in progress.
    if (ppdev->dwGlobalModeSwitchCount & 1)
        return TRUE;

    // Safety check.
    ASSERTDD(ppdev->CurrentClass.ScaledImageFromMemory != 0,
             "No scaled image class available in NV4DmaPushStretchCopy");

    // Compute the private color format.
    if (ppdev->iBitmapFormat == BMF_32BPP)
        uSrcColorFormat = NV089_SET_COLOR_FORMAT_LE_A8R8G8B8;
    else if (ppdev->iBitmapFormat == BMF_16BPP)
        uSrcColorFormat = NV089_SET_COLOR_FORMAT_LE_R5G6B5;
    else
        // Unsupported color format: bail.
        return FALSE;

    // Compute destination point and size.
    uDstPoint = (((unsigned) prclDst->top) << 16) |
                    (unsigned) prclDst->left;
    x = (unsigned) (prclDst->right - prclDst->left);
    y = (unsigned) (prclDst->bottom - prclDst->top);
    uDstSize = (y << 16) | x;
    // Compute scale factor.
    uDSDX = (unsigned) ((0x100000 + (iScale >> 1)) / iScale);

    // Compute source point, size, and offset.
    // There are significant restrictions on the range of the source size
    // so we adjust the source offset and point to compensate.
    // Adjust the source offset.
    x = (unsigned) (prclSrc->left & ~0x0000001f);
    y = (unsigned) (prclSrc->top & ~0x00000001);
    uSrcOffset = y * (unsigned) ppdev->lDelta +
                 x * (unsigned) ppdev->cjPelSize;
    // Compute the new source size.
    x = (((unsigned) prclSrc->right) - x + 1) & ~1;
    y = ((unsigned) prclSrc->bottom) - y;
    uSrcSize = (y << 16) | x;
    // Adjust the source point.
    x = (unsigned) (prclSrc->left & 0x0000001f);
    y = (unsigned) (prclSrc->top & 0x00000001);
    uSrcPoint = (y << 20) | (x << 4);

    // Compute the image in format.
    uInFormat = ((unsigned) ppdev->lDelta) |
                (NV089_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16);
    if (uSmooth)
        uInFormat |= (NV089_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24);
    else
        uInFormat |= (NV089_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24);

    // Specify source and destination buffers--in this case the primary buffer.
    ppdev->pfnSetSourceBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
    ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);

    // Sync our locals back after ppdev has been modified by the above calls.
    INIT_LOCAL_DMA_FIFO;

    // Get enough room in the pushbuffer; err on the side of caution.
    NV_DMAPUSH_CHECKFREE(((ULONG)(16 * iClips + 24)));

    // Load our object into the spare subchannel.
    if (ppdev->dDrawSpareSubchannelObject != DD_SCALED_IMAGE_FROM_MEMORY)
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),
                          DD_SCALED_IMAGE_FROM_MEMORY);
        ppdev->dDrawSpareSubchannelObject = DD_SCALED_IMAGE_FROM_MEMORY;
        }

    // Program the object's non-volatile methods.
    NV_DMAPUSH_WRITE1(DD_SPARE, NV089_SET_CONTEXT_DMA_NOTIFIES,
                      NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV089_SET_CONTEXT_DMA_IMAGE,
                      DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV089_SET_CONTEXT_SURFACE,
                      DD_PRIMARY_IMAGE_IN_MEMORY);

    // Loop over all the destination clip rectangles.
    i = 0;
    do
        {
        // Compute clip point and size.
        if (iClips)
            {
            uClipPoint = (((unsigned) prclClips[i].top) << 16) |
                            (unsigned) prclClips[i].left;
            x = (unsigned) (prclClips[i].right - prclClips[i].left);
            y = (unsigned) (prclClips[i].bottom - prclClips[i].top);
            uClipSize = (y << 16) | x;
            }
        // If no clips are specified then use the destination rectangle.
        else
            {
            uClipPoint = uDstPoint;
            uClipSize = uDstSize;
            }

        NV_DMAPUSH_START(8, DD_SPARE, NV089_SET_COLOR_FORMAT);
        NV_DMA_FIFO = uSrcColorFormat;              // NV089_SET_COLOR_FORMAT
        NV_DMA_FIFO = NV089_SET_OPERATION_SRCCOPY;  // NV089_SET_OPERATION
        NV_DMA_FIFO = uClipPoint;                   // NV089_CLIP_POINT
        NV_DMA_FIFO = uClipSize;                    // NV089_CLIP_SIZE
        NV_DMA_FIFO = uDstPoint;                    // NV089_IMAGE_OUT_POINT
        NV_DMA_FIFO = uDstSize;                     // NV089_IMAGE_OUT_SIZE
        NV_DMA_FIFO = uDSDX;                        // NV089_DS_DX
        NV_DMA_FIFO = uDSDX;                        // NV089_DT_DY
        NV_DMAPUSH_START(4, DD_SPARE, NV089_IMAGE_IN_SIZE);
        NV_DMA_FIFO = uSrcSize;                     // NV089_IMAGE_IN_SIZE
        NV_DMA_FIFO = uInFormat;                    // NV089_IMAGE_IN_FORMAT
        NV_DMA_FIFO = uSrcOffset;                   // NV089_IMAGE_IN_OFFSET
        NV_DMA_FIFO = uSrcPoint;                    // NV089_IMAGE_IN

        } while (++i < (unsigned) iClips);

    // Kick off the pushbuffer.
    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);

    // Success!
    return TRUE;
    }


//*********************************************************************
//
//  Function:   NV4DmaPushColorKeyBlt
//
//  Routine Description:
//      Colorkey blit on a list of rectangles. Especially used in
//      the OpenGL overlay mergeblit.
//
//      NOTE: Only initialized in 16 and 32 bpp!
//
//      NOTE: Needs surface src and dst to be set outside!
//
//  Arguments:
//
//  Return Value:
//
//      None.
// 
//*********************************************************************
VOID NV4DmaPushColorKeyBlt(
    PPDEV        ppdev,
    LONG         c,            // Number of rects in prcl
    RECTL       *prcl,         // Array of relative coordinates destination rectangles
    POINTL      *pptlSrc,      // Original unclipped source point
    RECTL       *prclDst,      // Original unclipped destination rectangle
    ULONG        ulColorRef)   // 32bit ARGB color key reference value
{  
    NvU32   ulColorFormat; // Class 57 color format of colorkey
    NvU32   ulColorKey;    // Class 57 colorkey
    ULONG   red, green, blue;
    LONG    dx;            // Add delta to destination to get source
    LONG    dy;           
    ULONG   width,height;
    ULONG   xsrc,ysrc;
    ULONG   xdst,ydst;
  
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    ASSERT(0!=c); // don't call me if you don't need
    ASSERT(NULL!=prcl   );
    ASSERT(NULL!=pptlSrc);
    ASSERT(NULL!=prclDst);

    //
    // setup color key object
    //
    if (2==ppdev->cjPelSize)
    {
        blue        = (ulColorRef & 0x00FF0000) >> (16 + 3);   // 5 bits of B            
        green       = (ulColorRef & 0x0000FF00) >> (8 + 2);    // 6 bits of G                       
        red         = (ulColorRef & 0x000000FF) >> 3;          // 5 bits of R                 

        ulColorKey    = (NvU32)( ((red << 11) | (green << 5) | blue) | 0xFFFF0000 );
        ulColorFormat = NV057_SET_COLOR_FORMAT_LE_A16R5G6B5;
    } 
    else 
    {
        ASSERT(4==ppdev->cjPelSize);

        blue        = (ulColorRef & 0x00FF0000) >> 16;               
        green       = (ulColorRef & 0x0000FF00) >> 8;               
        red         = (ulColorRef & 0x000000FF);               

        ulColorKey    = (NvU32)( ((red << 16) | (green << 8) | blue | 0xFF000000) );
        ulColorFormat = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
    }

    NV_DMAPUSH_CHECKFREE((ULONG)(6));

    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),    DD_IMAGE_SOLID);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, ulColorFormat)
    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR,        ulColorKey);

    for ( /* c */; c > 0; c--)
    {
        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************

        xdst = prcl->left;
        ydst = prcl->top;

        width = prcl->right - xdst;
        height = prcl->bottom - ydst;

        dx = xdst - prclDst->left;      // prcl is always within prcldst???
        dy = ydst - prclDst->top;       // prcl is always within prcldst???

        xsrc = pptlSrc->x + dx;
        ysrc = pptlSrc->y + dy;

        NV_DMAPUSH_CHECKFREE((ULONG)(8));
        //
        // do the transparent blt
        //
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_IMAGE_BLIT_COLORKEY);
        NV_DMAPUSH_START(3, DD_SPARE, NV05F_CONTROL_POINT_IN);
        NV_DMA_FIFO = ( (ysrc << 16) | (xsrc & 0xffff) );              // NV05F_CONTROL_POINT_IN 
        NV_DMA_FIFO = ( (ydst << 16) | (xdst & 0xffff) );              // NV05F_CONTROL_POINT_OUT
        NV_DMA_FIFO = ( (height << 16) | (width & 0xffff));            // NV05F_SIZE             

        prcl++;
    }

    NV_DMAPUSH_CHECKFREE((ULONG)(4));
    //
    // disable colorkey again
    //
    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_IMAGE_SOLID);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR, 0); // color key disabled

    ppdev->dDrawSpareSubchannelObject = DD_IMAGE_SOLID;

    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);
}


//******************************************************************************
//
// Function: NV4DmaPushAlphaPreserve
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     bStart - True if beginning AlphaPreserveMode, False if ending
//     bFromCpu - True if blt source is system memory
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4DmaPushAlphaPreserve(
    PPDEV       ppdev,
    BOOL        bStart,
    BOOL        bFromCpu)
{
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    NV_DMAPUSH_CHECKFREE((ULONG)(8));

    if (bStart) 
        {
        if (bFromCpu) 
            {
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION, NV061_SET_OPERATION_SRCCOPY);
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_A8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),    DD_PRIMARY_IMAGE_IN_MEMORY);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);
            }
        else
            {
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_OPERATION, NV05F_SET_OPERATION_SRCCOPY);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),    DD_PRIMARY_IMAGE_IN_MEMORY);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_BLIT);
            }
        }
    else
        {
        if (bFromCpu) 
            {
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION, NV061_SET_OPERATION_ROP_AND);
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_BLIT);
            }
        else
            {
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_OPERATION, NV05F_SET_OPERATION_ROP_AND);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),    DD_PRIMARY_IMAGE_IN_MEMORY);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_BLIT);   
            }
        }

    UPDATE_PDEV_DMA_COUNT;

    // For performance reasons, don't kick off this tiny bit of data now (NV4_DmaPushSend(ppdev);)
}

#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
//
//  Function:   NV4CheckAlphaBlendOK
//
//  Routine Description:
//
//      For given state in PDEV, check if HW can do the blend 
//
//  Arguments:
//
//     ppdev - Pointer to the physical device structure
//
//  Return Value: 
//
//      TRUE if HW capable, FALSE if not
//
//******************************************************************************

BOOL NV4CheckAlphaBlendOK(
    PDEV*   ppdev)
{
    // Check for state/hw combinations which don't support alpha blending
    // In 16bpp, need better than NV04 so we can turn dither off
    // Note NV04_IMAGE_FROM_CPU works fine for 32bpp, but not 16bpp, since it has no way to turn off
    //   dither.  So we support alpha in 32bpp and can punt (by returning FALSE here) in 16bpp.  
    // HOWEVER, there are no DCT failures on pre-NV10 hw in 16bpp even though we can't disable dither.
    //   THEREFORE, the punt is disabled. The code remains in case we find a failure and want to punt for old HW.
    #if 0
    if ((ppdev->CurrentClass.ContextSurfaces2D == NV04_CONTEXT_SURFACES_2D) &&
        (ppdev->iBitmapFormat == BMF_16BPP))
        {
        return FALSE;
        }
    else
    #endif
        {
        // all else, we can do
        return TRUE;
        }
}   


//******************************************************************************
//
//  Function:   NV4DmaPushCopyAlphaBlit
//
//  Routine Description:
//
//      Does a screen-to-screen blt of a list of alpha blended rectangles.
//      A modified version of NV4DmaPushCopyBlt, that uses class 077 (NV4_SCALED_IMAGE_FROM_MEMORY)
//
//  Arguments:
//
//  Return Value: 
//
//      TRUE if successful, FALSE if caller must punt operation to GDI
//
//******************************************************************************

BOOL NV4DmaPushCopyAlphaBlt(    // Type FNCOPY
    PDEV*   ppdev,
    LONG    c,          // Can't be zero
    RECTL*  prcl,       // Array of relative coordinates destination rectangles
    ULONG   rop4,       // rop4
    POINTL* pptlSrc,    // Original unclipped source point
    RECTL*  prclDst,    // Original unclipped destination rectangle
    BLENDOBJ* pBlendObj)
{
    LONG    clipx,clipy,clipwidth,clipheight;
    LONG    xdst,ydst,width,height;
    LONG    dx,dy;
    LONG    xsrc,ysrc;
    ULONG   constAlpha;

    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Safety checks
    //**************************************************************************
    ASSERTDD(pBlendObj, "Expect valid pBlendObj on alphablend blts");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),"Expect only a rop2");

    // DD_ALPHA_IMAGE_FROM_MEMORY is either NV04_SCALED_IMAGE_FROM_MEMORY(077) or NV10_SCALED_IMAGE_FROM_MEMORY(089)
    // Routine uses NV077 offsets for methods common to each class, and 089 for NV10-only features
    // We should return an error here if we need an NV10 feature but the class is pre-NV10 (meaning hw is pre-NV10)
    //   Caller knows error return means not-supported and will punt to GDI
    // Note NV04_SCALED_IMAGE_FROM_MEMORY works fine for 32bpp, but not 16bpp, since it has no way to turn off
    //   dither.  We support alpha in 32bpp and can punt (by returning FALSE here) in 16bpp.  
    // HOWEVER, there are no DCT failures on pre-NV10 hw in 16bpp even though we can't disable dither.
    //   THEREFORE, the punt is disabled. The code remains in case we find a failure and want to punt for old HW.
    // Finally, note it turns out we could call NV4CheckAlphaBlendOK since it and the check for NV04_SCALED_IMAGE are 
    //   the same for current hardware.  However, we leave the separate specific check SCALED_IMAGE support since it 
    //   was already there and in case future hardware has varying SCALED_IMAGE support
    #if 0 // Disable punt : let pre-NV10 proceed w/ dither on
    if ((ppdev->CurrentClass.AlphaImageFromMemory == NV04_SCALED_IMAGE_FROM_MEMORY) &&
        (ppdev->iBitmapFormat == BMF_16BPP))
        {
        return FALSE;
        }
    #endif
            
    // Check if we've got enough room in the push buffer for largest possible output
    NV_DMAPUSH_CHECKFREE((ULONG)((13*2) + (12*c)));

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , rop4 & 0xff);

    // Setup Blender - load alpha value into all bytes since hw uses each byte as an independent alpha value
    constAlpha = pBlendObj->BlendFunction.SourceConstantAlpha & 0x000000FF;
    constAlpha |= constAlpha << 8;
    constAlpha |= constAlpha << 16;

    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),    NV_DD_CONTEXT_BETA4);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV072_SET_BETA_FACTOR,  constAlpha);

    // if 32bpp, use color format with valid alpha for destination (primary)
    if (ppdev->iBitmapFormat==BMF_32BPP) 
        {
        // set back to default LE_X8R8G8B8 (32bpp) at the end
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),     DD_PRIMARY_IMAGE_IN_MEMORY);
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT,  NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),     DD_IMAGE_BLIT);
        }

    // Load Alpha image object into the spare subchannel
    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),    DD_ALPHA_IMAGE_FROM_MEMORY);
    ppdev->dDrawSpareSubchannelObject = DD_ALPHA_IMAGE_FROM_MEMORY;

    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_SURFACE,      DD_PRIMARY_IMAGE_IN_MEMORY);

    if (pBlendObj->BlendFunction.AlphaFormat & AC_SRC_ALPHA) 
        {
        // Source has valid alpha
        ASSERTDD(ppdev->iBitmapFormat==BMF_32BPP, "Alphablend CopyBlts w/ SrcAlpha must be 32bpp");
        NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_COLOR_FORMAT, NV077_SET_COLOR_FORMAT_LE_A8R8G8B8);
        }
    else
        {
        // Source has no alpha - use format having no alpha, where source alpha defaults to 0xff by HW
        if (ppdev->iBitmapFormat==BMF_32BPP) 
            {
            NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_COLOR_FORMAT, NV077_SET_COLOR_FORMAT_LE_X8R8G8B8);
            }
            else
            {
            NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_COLOR_FORMAT, NV077_SET_COLOR_FORMAT_LE_R5G6B5);
            // For post NV4 hw, turn dither off for the blend
            if (ppdev->CurrentClass.AlphaImageFromMemory != NV04_SCALED_IMAGE_FROM_MEMORY)
                {
                NV_DMAPUSH_WRITE1(DD_SPARE, NV089_SET_COLOR_CONVERSION, NV089_SET_COLOR_CONVERSION_TRUNCATE);
                }
            
            }
        }

    // Do a copy blit for each clip rectangle
    do  {

        //**********************************************************************
        // GDI passes the lower right and bottom coordinate as EXCLUSIVE.
        // That is, the lower right coordinate is NOT included
        // For NV, the width/height actually means the number of
        // pixels drawn.  So, adjusting by 1 pixel is NOT necessary
        // when calculating width and height.
        //**********************************************************************
        
        // Set Clip point and size for Screen boundaries
        clipx = prcl->left;
        if (prcl->right > ppdev->cxScreen)
            {
            clipwidth = ppdev->cxScreen - clipx; 
            }
        else
            {
            clipwidth = prcl->right - clipx;
           
            if (clipx < 0)
                {
                clipwidth += clipx; // subtract (add neg. x) distance from x start to screen left
                clipx = 0;
                }
            }

        clipy = prcl->top;
        if (prcl->bottom > ppdev->cyScreen)
            {
            clipheight = ppdev->cyScreen - clipy; 
            }
        else
            {
            clipheight = prcl->bottom - clipy;
            
            if (clipy < 0)
                {
                clipheight += clipy; // subtract (add neg. y) distance from y start to screen top
                clipy = 0;
                }
            }

        NV_DMAPUSH_START(6, DD_SPARE, NV077_CLIP_POINT);
        NV_DMA_FIFO = ((clipy << 16)|(clipx & 0xffff));         // NV077_CLIP_POINT
        NV_DMA_FIFO = ((clipheight << 16)|(clipwidth & 0xffff));// NV077_CLIP_SIZE

        // Use original unclipped origin, size for image size
        xdst = prcl->left;
        ydst = prcl->top;
        width = prcl->right - xdst;
        height = prcl->bottom - ydst;
        
        NV_DMA_FIFO = ((ydst << 16)|(xdst & 0xffff));   // NV077_IMAGE_OUT_POINT
        NV_DMA_FIFO = ((height << 16)|(width & 0xffff));// NV077_IMAGE_OUT_SIZE
        NV_DMA_FIFO = 0x100000;                         // NV077_DELTA_DU_DX = 1.0 - no scaled blts supported yet
        NV_DMA_FIFO = 0x100000;                         // NV077_DELTA_DV_DY = 1.0 - no scaled blts supported yet

        dx = xdst - prclDst->left;      // prcl is always within prcldst???
        dy = ydst - prclDst->top;       // prcl is always within prcldst???

        xsrc = pptlSrc->x + dx;
        ysrc = pptlSrc->y + dy;

        // width, height are w.r.t SrcOffset, so add src x,y
        width  += xsrc;
        height += ysrc;
        
        // Class restriction - width must be a multiple of 2
        width = (width + 1) & ~1;

        NV_DMAPUSH_START(4, DD_SPARE, NV077_IMAGE_IN_SIZE);
        NV_DMA_FIFO = (height << 16) | width;           // NV077_IMAGE_IN_SIZE
        NV_DMA_FIFO = ((unsigned) ppdev->CurrentSourcePitch) |  // NV077_IMAGE_IN_FORMAT
                        (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                        (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24);
        NV_DMA_FIFO = ppdev->CurrentSourceOffset;       // NV077_IMAGE_IN_OFFSET
        NV_DMA_FIFO = (ysrc << 20) | (xsrc << 4);       // NV077_IMAGE_IN

        prcl++;

    } while (--c != 0);

    // if 32bpp, restore color format which was changed at entry
    if (ppdev->iBitmapFormat==BMF_32BPP) 
        {
        // restore defaults
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),     DD_PRIMARY_IMAGE_IN_MEMORY);
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT,  NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),     DD_IMAGE_BLIT);
        }

    // Update global push buffer count
    UPDATE_PDEV_DMA_COUNT;

    // Send data on thru to the DMA push buffer
    NV4_DmaPushSend(ppdev);

    return TRUE;

}


//******************************************************************************
//
// Function: NV4DmaPushSetColorKey
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     colorformat - non-zero colorformat format if Set key, 0 if disabling color keying
//     iTransColor - The color key 
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4DmaPushSetColorKey(
    PPDEV       ppdev,
    ULONG       colorformat, // 0 means disable
    ULONG       iTransColor)
{
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    NV_DMAPUSH_CHECKFREE((ULONG)(10));

    if (colorformat)
        {
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_COLOR_KEY, DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_COLOR_KEY, DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),    DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, colorformat ==  BMF_32BPP ?
                                                            NV057_SET_COLOR_FORMAT_LE_A8R8G8B8 :
                                                            NV057_SET_COLOR_FORMAT_LE_A16R5G6B5);
        // iTransColor already in surface's color format - set Alpha non-zero to activate color key check in NV hardware
        NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR,        iTransColor | (0xff << 24));
        }
    else
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR, 0); // color key disabled
        NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_COLOR_KEY, 0);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_COLOR_KEY, 0);
        ppdev->dDrawSpareSubchannelObject = DD_IMAGE_SOLID;
        }

    UPDATE_PDEV_DMA_COUNT;

    // For performance reasons, don't kick off this tiny bit of data now (NV4_DmaPushSend(ppdev);)
}


#endif // (_WIN32_WINNT >= 0x0500)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4hw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV4HW.C
//
// Abstract:
//
//     Implements NV4 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the S3 Display driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "nv32.h"
#include "driver.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif

#include "nv4_ref.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

//******************************************************************************
// We'll add the 565 bitmap format functions here
// (We'll use the NV3 functions for 555 format)
//******************************************************************************

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV4_DmaPushSend(PDEV *);
VOID NV_DmaPush_Wrap(PDEV *, ULONG );
VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG);

VOID MagicDelay (VOID);

#define LOOP_WAIT   450*8

#ifdef _WIN64
VOID MagicDelay (VOID)
{
    volatile int i;

    for (i = 0; i < LOOP_WAIT; i++);
}
#else
VOID MagicDelay (VOID)
{
    _asm              mov     ecx, LOOP_WAIT
    _asm WaitLoop:    loop    WaitLoop
}
#endif


//******************************************************************************
//
// Function: NV4_DmaPushSetSourceBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_DmaPushSetSourceBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {
    DECLARE_DMA_FIFO;

    if ((Offset == ppdev->CurrentSourceOffset) &&
        (Stride == (LONG)ppdev->CurrentSourcePitch))

        return;                 // current settings are correct - just return

    //**************************************************************************
    // Get push buffer information
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;


    //**************************************************************************
    // NOTE: BitBlt/Text/Lines currently assume that there are 2 surface objects
    //       (Surface0 and Surface1).  However, in NV4, instead of 2 surface objects,
    //       there is now JUST 1 surface object (NV4_CONTEXT_SURFACES_2D).
    //**************************************************************************

    //**************************************************************************
    // Make sure that pitch is at least 32 (NV4 requirement for CONTEXT_SURFACES_2D)
    // even when NO source is being used during the blit operation
    // (A newly created ppdev ZERO's out these values)
    //**************************************************************************

    if (ppdev->CurrentDestPitch <= ppdev->ulSurfaceAlign)       // Destination Pitch
        ppdev->CurrentDestPitch = ppdev->ulSurfaceAlign+1;

    if ((ULONG)Stride <= ppdev->ulSurfaceAlign)                        // Source Pitch
        Stride = ppdev->ulSurfaceAlign+1;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(6)));

    //**************************************************************************
    // Setup DSTIMAGE_IN_MEMORY object.
    //**************************************************************************

    if (ppdev->dDrawSpareSubchannelObject != DD_PRIMARY_IMAGE_IN_MEMORY)
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_PRIMARY_IMAGE_IN_MEMORY);
        ppdev->dDrawSpareSubchannelObject     = DD_PRIMARY_IMAGE_IN_MEMORY;
        }

    //**************************************************************************
    // Send methods to DMA push buffer
    //**************************************************************************

    NV_DMAPUSH_START(3, DD_SPARE , NV042_SET_PITCH )
    NV_DMA_FIFO = ((ppdev->CurrentDestPitch <<16) | (Stride));
    NV_DMA_FIFO = Offset;
    NV_DMA_FIFO = ppdev->CurrentDestOffset;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentSourceOffset = Offset;
    ppdev->CurrentSourcePitch  = Stride;

    //**************************************************************************
    // Make sure to update the DMA count before we exit!!
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    }


//******************************************************************************
//
// Function: NV4_DmaPushSetDestBase()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_DmaPushSetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride)

    {

    DECLARE_DMA_FIFO;

    if ((Offset == ppdev->CurrentDestOffset) &&
        (Stride == (LONG)ppdev->CurrentDestPitch))

        return;                 // current settings are correct - just return

    //**************************************************************************
    // Get push buffer information
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;


    //**************************************************************************
    // NOTE: BitBlt/Text/Lines currently assume that there are 2 surface objects
    //       (Surface0 and Surface1).  However, in NV4, instead of 2 surface objects,
    //       there is now JUST 1 surface object (NV4_CONTEXT_SURFACES_2D).
    //**************************************************************************

    //**************************************************************************
    // Make sure that pitch is at least 32 (NV4 requirement for CONTEXT_SURFACES_2D)
    // even when NO source is being used during the blit operation
    // (A newly created ppdev ZERO's out these values)
    //**************************************************************************

    if (ppdev->CurrentSourcePitch <= ppdev->ulSurfaceAlign)     // Source Pitch
        ppdev->CurrentSourcePitch = ppdev->ulSurfaceAlign+1;

    if ((ULONG)Stride <= ppdev->ulSurfaceAlign)                        // Destination Pitch
        Stride = ppdev->ulSurfaceAlign+1;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(6)));

    //**************************************************************************
    // Setup DSTIMAGE_IN_MEMORY object.
    //**************************************************************************

    if (ppdev->dDrawSpareSubchannelObject != DD_PRIMARY_IMAGE_IN_MEMORY)
        {
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), DD_PRIMARY_IMAGE_IN_MEMORY);
        ppdev->dDrawSpareSubchannelObject     = DD_PRIMARY_IMAGE_IN_MEMORY;
        }

    //**************************************************************************
    // Send methods to DMA push buffer
    //**************************************************************************

    NV_DMAPUSH_START(3, DD_SPARE , NV042_SET_PITCH )
    NV_DMA_FIFO = ((Stride <<16) | (ppdev->CurrentSourcePitch));
    NV_DMA_FIFO = ppdev->CurrentSourceOffset;
    NV_DMA_FIFO = Offset;

    //**************************************************************************
    // Save the updated offset and pitch, update global freecount.
    //**************************************************************************
    ppdev->CurrentDestOffset = Offset;
    ppdev->CurrentDestPitch  = Stride;

    //**************************************************************************
    // Make sure to update the DMA count before we exit!!
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Send data on thru to the DMA push buffer
    //**************************************************************************

    NV4_DmaPushSend(ppdev);

    }

//******************************************************************************
//
// Function: NV4_DmaPushSend()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_DmaPushSend(PDEV *ppdev)

    {
    Nv04ControlDma      *nvDmaChannel;
    BOOL                 bReleaseOpenGLMutex = FALSE;

    nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

    //**********************************************************************
    // Check if the ALI 1541 chipset is present.
    // If so, then we need to workaround a cache issue by doing an out to port
    //**********************************************************************

    if (ppdev->AliFixupIoNeeded)
        {
// Assembly is not feasible for IA64
#ifndef _WIN64
        outp(ppdev->AliFixupIoBase, 0);      // This will flush the cache
#endif
        }
        
    //**************************************************************************
    // Some OGL CAD apps need GDI & OGL to be sync'ed up.
    //**************************************************************************
    if (ppdev->oglSyncGdi)
        {
        ppdev->pfnAcquireOglMutex(ppdev);
        ppdev->pfnWaitForChannelSwitch(ppdev);
        ppdev->NVFreeCount = 0;
        bReleaseOpenGLMutex = TRUE;
        }

#ifdef NVD3D    // DX6
    //**********************************************************************
    // If there is another DMA push channel active, wait til it's finished.
    //
    // It hurts performance to check this with every kickoff, so we only do
    // this check when:
    // 1) This is a DX6 build. We can only successfully sync with other DMA
    //    Push Channels and not PIO channels (DX3 is PIO only).
    // 2) DirectDraw is enabled and ddraw objects have been created
    //   (determined by checking if surfaces have been created).
    //
    //**********************************************************************

    if ((ppdev->DDrawEnabledFlag) &&
        (ppdev->pDriverData->DDrawVideoSurfaceCount))
        {
        if (ppdev->pfnWaitForChannelSwitch)
            ppdev->pfnWaitForChannelSwitch(ppdev);
        }
#else
    //**********************************************************************
    // It's possible the DX3 PIO channel is still active. We need to wait
    // til it's finished. It hurts performance to check this with every
    // kickoff, so we only do this check when DirectDraw is enabled.
    //**********************************************************************
    if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
        {
        NV4_DdPioSync(ppdev);
        ppdev->bDDChannelActive = FALSE;
        }
#endif // #ifndef NVD3D

    //**************************************************************************
    // Convert the PUT ptr to a byte address
    //**************************************************************************

    ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;

    //**************************************************************************
    // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
    // Then 'OR' it near the end of the push buffer
    //**************************************************************************

    if (ppdev->nvDmaCount >0)
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
    else
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

    *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;

    //**************************************************************************
    // Tell the hardware to start processing the push buffer
    //**************************************************************************

    nvDmaChannel->Put = ppdev->nvDmaCachedPut;

    ppdev->oglLastChannel = GDI_CHANNEL_ID;

    if (bReleaseOpenGLMutex)
        {
        ppdev->pfnReleaseOglMutex(ppdev);
        }

    }

//******************************************************************************
//
// Function: NV_DmaPush_Wrap()
//
// Routine Description:
//
//         This function causes a WRAP around to occur
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV_DmaPush_Wrap(PDEV *ppdev, ULONG Dwords_Needed)

    {
    ULONG               totalBytesNeeded;
    Nv04ControlDma      *nvDmaChannel;

    nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

    ASSERTDD(Dwords_Needed < ( (ppdev->DmaPushBufTotalSize>>2) - DMAPUSH_PADDING), "ERROR:  PushBuffer Size TOO small !!!");

#ifdef NVD3D    // DX6
    //**********************************************************************
    // If there is another DMA push channel active, wait til it's finished.
    //
    // It hurts performance to check this with every kickoff, so we only do
    // this check when:
    // 1) This is a DX6 build. We can only successfully sync with other DMA
    //    Push Channels and not PIO channels (DX3 is PIO only).
    // 2) DirectDraw is enabled and ddraw objects have been created
    //   (determined by checking if surfaces have been created).
    //
    //**********************************************************************

    if ((ppdev->DDrawEnabledFlag) &&
        (ppdev->pDriverData->DDrawVideoSurfaceCount))
        {
        if (ppdev->pfnWaitForChannelSwitch)
            ppdev->pfnWaitForChannelSwitch(ppdev);
        }
#else
    //**********************************************************************
    // It's possible the DX3 PIO channel is still active. We need to wait
    // til it's finished. It hurts performance to check this with every
    // kickoff, so we only do this check when DirectDraw is enabled.
    //**********************************************************************
    if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
        {
        NV4_DdPioSync(ppdev);
        ppdev->bDDChannelActive = FALSE;
        }
#endif // #ifndef NVD3D

    //**************************************************************************
    //
    // Write a jump to prepare for wrap.
    //
    //  WRAP_FLAG = TRUE
    //
    //         ---------  0
    //   ---> |         |
    //  |     |         |
    //  |     |         |  <-- Get Ptr
    //  |     |         |
    //  |     |  Push   |
    //  |     | Buffer  |  <-- Put Ptr
    //  |     |         |
    //  |     |         |
    //  |     |         |
    //   ---- |JUMP CMD |  <-- DMA Count
    //         ---------
    //
    //**************************************************************************

    ppdev->nvDmaFifo[ppdev->nvDmaCount] = NV4_JUMP(0);

    //**************************************************************************
    // Check if get pointer is way behind. If it is, wait until it starts to
    // catch up. This way we can distinguish between a pointer that is way behind
    // from a pointer that has wrapped.
    //**************************************************************************

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;

    while (ppdev->nvDmaCachedGet == 0)
        {
        MagicDelay ();
        ppdev->nvDmaCachedGet = nvDmaChannel->Get;
        }

    //**************************************************************************
    // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
    // Then 'OR' it near the end of the push buffer
    //**************************************************************************

    if (ppdev->nvDmaCount >0)
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
    else
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

    *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


    //******************************************************************
    // Force a kickoff. This will cause the engine to process the current
    // push buffer data and then wraparound to zero.
    //******************************************************************

    nvDmaChannel->Put = 0;
    ppdev->nvDmaCount = 0;

    //**********************************************************************
    //
    //  WRAP_FLAG = TRUE
    //
    //  Wait until Get >= Dwords_Needed
    //
    //         ---------  0
    //        |         |  <-- Put Ptr <------ DMA Count
    //        |         |                         ^
    //        |         |                         |
    //        |         |                         |--- Dwords Needed
    //        |  Push   |                         |
    //        | Buffer  |                         v
    //        |         |  <-- Get Ptr     <-------
    //        |         |
    //        |         |
    //        |JUMP CMD |
    //         ---------
    //
    //**********************************************************************

    totalBytesNeeded = (Dwords_Needed + (DMAPUSH_PADDING)) << 2;

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;

    while (ppdev->nvDmaCachedGet > 0)
        {
        if (totalBytesNeeded < ppdev->nvDmaCachedGet)
            {
            ppdev->nvDmaWrapFlag = TRUE;
            return;
            }

        MagicDelay ();
        ppdev->nvDmaCachedGet = nvDmaChannel->Get;

        }


    //**********************************************************************
    //
    // WRAP_FLAG = FALSE
    //
    // We are no longer wrapped, Get == 0, wrap has occurred. We should have
    // enough room now.
    //
    //         ---------   <- Put Ptr  <- DMA Count <- Get Ptr
    //        |         |
    //        |         |
    //        |         |
    //        |         |
    //        |  PUSH   |
    //        | BUFFER  |
    //        |         |
    //        |         |
    //        |         |
    //        |         |
    //         ---------
    //
    //**********************************************************************

    ppdev->nvDmaWrapFlag = FALSE;
    return;

    }

//******************************************************************************
//
// Function: NV_DmaPush_CheckWrapped()
//
// Routine Description:
//
//          Make sure that the DmaCount PUT ptr does NOT go past the
//          GET ptr (this occurs when DmaCount is wrapped around and
//          catching up to the GET ptr).
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV_DmaPush_CheckWrapped(PDEV *ppdev, ULONG Dwords_Needed)

    {
    ULONG               totalBytesNeeded;
    Nv04ControlDma      *nvDmaChannel;
    nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

    //**************************************************************************
    //
    //         WRAP_FLAG = TRUE
    //
    //         ---------  0
    //        |         |  <---- Put Ptr
    //        |         |
    //        |         |
    //        |  Push   |  <----- DMA Count (Where CPU currently writes data)
    //        | Buffer  |    |
    //        |         |    |
    //        |         |    v
    //        |         |  <----- Get Ptr
    //        |         |    |
    //        |         |    v
    //        |JUMP CMD |
    //         ---------
    //
    //**************************************************************************

    ASSERTDD(Dwords_Needed < ((ppdev->DmaPushBufTotalSize>>2) - DMAPUSH_PADDING), "ERROR:  PushBuffer Size TOO small !!!");

#ifdef NVD3D    // DX6
    //**********************************************************************
    // If there is another DMA push channel active, wait til it's finished.
    //
    // It hurts performance to check this with every kickoff, so we only do
    // this check when:
    // 1) This is a DX6 build. We can only successfully sync with other DMA
    //    Push Channels and not PIO channels (DX3 is PIO only).
    // 2) DirectDraw is enabled and ddraw objects have been created
    //   (determined by checking if surfaces have been created).
    //
    //**********************************************************************

    if ((ppdev->DDrawEnabledFlag) &&
        (ppdev->pDriverData->DDrawVideoSurfaceCount))
        {
        if (ppdev->pfnWaitForChannelSwitch)
            ppdev->pfnWaitForChannelSwitch(ppdev);
        }
#else
    //**********************************************************************
    // It's possible the DX3 PIO channel is still active. We need to wait
    // til it's finished. It hurts performance to check this with every
    // kickoff, so we only do this check when DirectDraw is enabled.
    //**********************************************************************
    if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
        {
        NV4_DdPioSync(ppdev);
        ppdev->bDDChannelActive = FALSE;
        }
#endif // #ifndef NVD3D

    //**************************************************************************
    // Calculate the number of bytes needed in the push buffer
    //**************************************************************************

    totalBytesNeeded = (ppdev->nvDmaCount + Dwords_Needed + DMAPUSH_PADDING) << 2;

    //**************************************************************************
    // Get the current GET ptr from hardware
    //**************************************************************************

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;

    //**************************************************************************
    // Check if the GET ptr is still ahead of the DMA count ptr
    //**************************************************************************

    if (ppdev->nvDmaCount < (ppdev->nvDmaCachedGet>>2))
        {
        //******************************************************************
        //
        //  CASE 1:
        //
        //  WRAP_FLAG = TRUE
        //
        //  CachedGet >= Dwords_Needed, just return immediately
        //
        //         ---------  0
        //        |         |
        //        |         |  <------------------ DMA Count
        //        |         |                         ^
        //        |  Push   |                         |
        //        | Buffer  |                         |--- Dwords Needed
        //        |         |                         |
        //        |         |                  <------
        //        |         |  <-- Get Ptr
        //        |         |    |
        //        |         |    |
        //        |         |    v
        //        |JUMP CMD |
        //         ---------
        //
        //******************************************************************

        if (totalBytesNeeded < ppdev->nvDmaCachedGet)
            return;

        //******************************************************************
        //
        // CASE 2:
        //
        //      WRAP_FLAG = TRUE
        //
        //      Dwords Needed < remaining space available
        //      Then need to wait for get pointer to advance
        //
        //         ---------  0
        //        |         |
        //        |         |
        //        |  Push   |  <----- DMA Count (Where CPU currently writes data)
        //        | Buffer  |    |                  |
        //        |         |    |                  |
        //        |         |    v                  |
        //        |         |  <----- Get Ptr       |-- Dwords Needed < remaining space
        //        |         |    |                  |
        //        |         |    v                  |
        //        |JUMP CMD |  <--------------------
        //         ---------
        //
        //******************************************************************

        else if (totalBytesNeeded < (ppdev->DmaPushBufTotalSize))
            {
            while (ppdev->nvDmaCount < (ppdev->nvDmaCachedGet>>2))
                {
                if (totalBytesNeeded < ppdev->nvDmaCachedGet)
                    return;

                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            //*************************************************************
            //
            //      WRAP_FLAG = FALSE
            //
            // We are no longer wrapped
            //
            //         ---------   <- Get Ptr
            //        |         |
            //        |         |
            //        |         |
            //        |  Push   |  <----- DMA Count (Where CPU currently writes data)
            //        | Buffer  |                       |
            //        |         |                       |
            //        |         |                       |
            //        |         |                       |-- Dwords Needed < remaining space
            //        |         |                       |
            //        |         |                       |
            //        |         |  <--------------------
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaWrapFlag = FALSE;
            return;

            }

        //******************************************************************
        //
        // CASE 3:
        //
        //      WRAP_FLAG = TRUE
        //
        //      Dwords Needed > remaining space available
        //
        //      We are way behind here, so we need to wait and catch up or else
        //      we will overwrite data.
        //
        //         ---------  0
        //        |         |
        //        |         |
        //        |  Push   |
        //        | Buffer  |
        //        |         |
        //        |         |
        //        |         |  <----- DMA Count (Where CPU currently writes data)
        //        |         |    |                  |
        //        |         |    v                  |
        //        |         |  <----- Get Ptr       |-- Dwords Needed > remaining space
        //        |         |    |                  |
        //        |JUMP CMD |    v                  |
        //         ---------                        |
        //                                          |
        //                     <--------------------
        //
        //******************************************************************

        else    // (totalBytesNeeded > DMAPUSH_BUFFER_SIZE)
            {

            //******************************************************************
            //
            // Wait for wraparound to occur
            //
            //         ---------   <- Get Ptr
            //        |         |
            //        |         |
            //        |  Push   |
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |         |  <----- DMA Count (Where CPU currently writes data)
            //        |         |                       |
            //        |         |                       |
            //        |         |                       |-- Dwords Needed > remaining space
            //        |         |                       |
            //         ---------                        |
            //                                          |
            //                     <--------------------
            //
            //******************************************************************

            while (ppdev->nvDmaCount < (ppdev->nvDmaCachedGet>>2))
                {
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            //******************************************************************
            // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
            // Then 'OR' it near the end of the push buffer
            //******************************************************************

            if (ppdev->nvDmaCount >0)
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
            else
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

            *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


            //******************************************************************
            //
            // Kick off so pointers catch up to DMA count
            //
            //         ---------
            //        |         |
            //        |         | <-- Get Ptr
            //        |  Push   |
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |JUMP CMD |  <----- DMA Count <- Put Ptr
            //        |         |                       |
            //        |         |                       |
            //        |         |                       |-- Dwords Needed > remaining space
            //        |         |                       |
            //         ---------                        |
            //                                          |
            //                     <--------------------
            //
            //******************************************************************

            ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;

            nvDmaChannel->Put = ppdev->nvDmaCachedPut;

            //******************************************************************
            // Make sure Get ptr is not zero, otherwise we can't distinguish between
            // a pointer that is way behind from a pointer that has wrapped.
            //******************************************************************

            ppdev->nvDmaCachedGet = nvDmaChannel->Get;

            while (ppdev->nvDmaCachedGet == 0)
                {
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            //******************************************************************
            //
            // Force a kickoff. This will cause the engine to process the current
            // push buffer data and then wraparound to zero.
            //
            //         ---------   <- Put Ptr  <- DMA Count
            //        |         |
            //        |         |
            //        |  Push   |  <-- Get Ptr
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |JUMP CMD |
            //        |         |
            //        |         |
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaFifo[ppdev->nvDmaCount] = NV4_JUMP(0);

            //******************************************************************
            // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
            // Then 'OR' it near the end of the push buffer
            //******************************************************************

            if (ppdev->nvDmaCount >0)
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
            else
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

            *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


            ppdev->nvDmaCount = 0;
            nvDmaChannel->Put = 0;

            totalBytesNeeded = (Dwords_Needed + DMAPUSH_PADDING) << 2;

            ppdev->nvDmaCachedGet = nvDmaChannel->Get;

            while (ppdev->nvDmaCachedGet > 0)
                {
                if (totalBytesNeeded < ppdev->nvDmaCachedGet)
                    {
                    ppdev->nvDmaWrapFlag = TRUE;
                    return;
                    }
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }


            //******************************************************************
            //
            //      WRAP_FLAG = FALSE
            //
            // Get pointer has wrapped.
            //
            //         ---------   <- Put Ptr  <- DMA Count <-- Get Ptr
            //        |         |
            //        |         |
            //        |  Push   |
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaWrapFlag = FALSE;
            return;

            }
        }
    else        // (ppdev->nvDmaCount > (ppdev->nvDmaCachedGet>>2))
        {

        //******************************************************************
        //
        //  CASE 4:
        //
        //      WRAP_FLAG = FALSE
        //
        //         ---------  0
        //        |         |
        //        |         |
        //        |         |  <-- Get Ptr
        //        |         |
        //        |         |  <-------------- DMA Count
        //        |         |                         |
        //        |         |                         |--- Dwords Needed
        //        |  Push   |                         |
        //        | Buffer  |                         |
        //        |         |                 <-------
        //        |         |
        //         ---------
        //
        //         Total Size of Push Buffer
        //
        //******************************************************************

        if (totalBytesNeeded <= (ppdev->DmaPushBufTotalSize))
            {
            ppdev->nvDmaWrapFlag = FALSE;       // no longer wrapped
            return;
            }

        //******************************************************************
        //
        //  CASE 5:
        //
        //      WRAP_FLAG = FALSE
        //
        //         ---------  0
        //        |         |
        //        |         |
        //        |         |  <-- Get Ptr
        //        |         |
        //        |         |
        //        |         |  <-------------- DMA Count
        //        |  Push   |                         |
        //        | Buffer  |                         |
        //        |         |                         |
        //        |         |                         |--- Dwords Needed
        //        |         |                         |
        //         ---------                          |
        //                                    <-------
        //******************************************************************

        else        // totalBytesNeeded > DMAPUSH_BUFFER_SIZE
            {

            //******************************************************************
            // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
            // Then 'OR' it near the end of the push buffer
            //******************************************************************

            if (ppdev->nvDmaCount >0)
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
            else
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

            *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


            //******************************************************************
            //
            // WRAP_FLAG = TRUE
            //
            // Force a kickoff. This will cause the engine to process the current
            // push buffer data and then wraparound to zero.
            //
            //         ---------   <- Put Ptr  <- DMA Count
            //        |         |
            //        |         |
            //        |  Push   |
            //        | Buffer  |
            //        |         |  <- Get Ptr
            //        |         |
            //        |         |
            //        |         |
            //        |JUMP CMD |
            //        |         |
            //        |         |
            //        |         |
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;

            nvDmaChannel->Put = ppdev->nvDmaCachedPut;

            //******************************************************************
            // Make sure Get ptr is not zero, otherwise we can't distinguish between
            // a pointer that is way behind from a pointer that has wrapped.
            //******************************************************************

            ppdev->nvDmaCachedGet = nvDmaChannel->Get;

            while (ppdev->nvDmaCachedGet == 0)
                {
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            ppdev->nvDmaFifo[ppdev->nvDmaCount] = NV4_JUMP(0);

            //******************************************************************
            // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
            // Then 'OR' it near the end of the push buffer
            //******************************************************************

            if (ppdev->nvDmaCount >0)
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
            else
                ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

            *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;


            ppdev->nvDmaCount = 0;
            nvDmaChannel->Put = 0;

            totalBytesNeeded = (Dwords_Needed + DMAPUSH_PADDING) << 2;

            ppdev->nvDmaCachedGet = nvDmaChannel->Get;

            while (ppdev->nvDmaCachedGet > 0)
                {
                if (totalBytesNeeded < ppdev->nvDmaCachedGet)
                    {
                    ppdev->nvDmaWrapFlag = TRUE;
                    return;
                    }
                MagicDelay ();
                ppdev->nvDmaCachedGet = nvDmaChannel->Get;
                }

            //******************************************************************
            //
            //      WRAP_FLAG = FALSE
            //
            // We are no longer wrapped, Get == 0, wrap has occurred
            //
            //         ---------   <- Put Ptr  <- DMA Count <- Get Ptr
            //        |         |
            //        |         |
            //        |  Push   |
            //        | Buffer  |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //        |         |
            //         ---------
            //
            //******************************************************************

            ppdev->nvDmaWrapFlag = FALSE;
            return;

            }
        }
    }


//******************************************************************************
//
// Function: NV4_DmaPushWaitOnSync
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV4_DmaPushWaitOnSync(PDEV *ppdev)

    {
    Nv04ControlDma      *nvDmaChannel;

    nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

#ifdef NVD3D    // DX6
    //**********************************************************************
    // If there is another DMA push channel active, wait til it's finished.
    //
    // It hurts performance to check this with every kickoff, so we only do
    // this check when:
    // 1) This is a DX6 build. We can only successfully sync with other DMA
    //    Push Channels and not PIO channels (DX3 is PIO only).
    // 2) DirectDraw is enabled and ddraw objects have been created
    //   (determined by checking if surfaces have been created).
    //
    //**********************************************************************

    if ((ppdev->DDrawEnabledFlag) &&
        (ppdev->pDriverData->DDrawVideoSurfaceCount))
        {
        if (ppdev->pfnWaitForChannelSwitch)
            ppdev->pfnWaitForChannelSwitch(ppdev);
        }
#else
    //**********************************************************************
    // It's possible the DX3 PIO channel is still active. We need to wait
    // til it's finished. It hurts performance to check this with every
    // kickoff, so we only do this check when DirectDraw is enabled.
    //**********************************************************************
    if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
        {
        NV4_DdPioSync(ppdev);
        ppdev->bDDChannelActive = FALSE;
        }
#endif // #ifndef NVD3D

    //**************************************************************************
    // Wait for all commands to be processed
    //**************************************************************************

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;
    while (ppdev->nvDmaCachedGet != ppdev->nvDmaCachedPut)
        {
        MagicDelay ();
        ppdev->nvDmaCachedGet = nvDmaChannel->Get;
        }

    //**************************************************************************
    // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
    // Then 'OR' it near the end of the push buffer
    //**************************************************************************

    if (ppdev->nvDmaCount >0)
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
    else
        ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

    *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;

    //**************************************************************************
    // Kickoff again
    //**************************************************************************

    nvDmaChannel->Put = 0;

    //**************************************************************************
    // Wait for jump wraparound
    //**************************************************************************

    ppdev->nvDmaCachedGet = nvDmaChannel->Get;
    while (ppdev->nvDmaCachedGet != 0)
        {
        MagicDelay ();
        ppdev->nvDmaCachedGet = nvDmaChannel->Get;
        }
    }

//******************************************************************************
//
// Function: NV4_DdPioSync
//
// Routine Description:
// This routine is called from the GDI driver (as well as the the DD PIO
// code) to wait until the PIO channel has completed processing.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV4_DdPioSync(PDEV *ppdev)
{
    Nv3ChannelPio *nvDDChannel = (Nv03ChannelPio *)(ppdev->ddChannelPtr);
    USHORT freeCount = NvGetFreeCount(nvDDChannel, 2);
    NvNotification *pSyncNotifier = (NvNotification *)ppdev->Notifiers->Sync;

    //**************************************************************
    // Sync on method notification for NV_IMAGE_BLACK_RECTANGLE object.
    // This should ensure all processing of PIO channel has completed.
    //**************************************************************
    while (freeCount < 2 * 4)
        freeCount = NvGetFreeCount(nvDDChannel, 2);
    freeCount -= 2 * 4;

    while ((volatile) pSyncNotifier[NV019_NOTIFIERS_NOTIFY].status == NV019_NOTIFICATION_STATUS_IN_PROGRESS);
    pSyncNotifier[NV019_NOTIFIERS_NOTIFY].status = NV019_NOTIFICATION_STATUS_IN_PROGRESS;
    nvDDChannel->subchannel[6].nv1ImageBlackRectangle.Notify = NV019_NOTIFY_WRITE_ONLY;
    nvDDChannel->subchannel[6].nv1ImageBlackRectangle.NoOperation = 0;
    while ((volatile) pSyncNotifier[NV019_NOTIFIERS_NOTIFY].status == NV019_NOTIFICATION_STATUS_IN_PROGRESS);
    ppdev->NVFreeCount = freeCount;
}

//*****************************Public*Routine******************************\
// void NvSetDacImageOffset
//
// This routine set the new offset of Dac so that the display window can be
// on any part of frame buffer.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//     ulDac - Which Dac is going to set, 0 - primary DAC
//     ulOffset - New offset in in the display desktop [ulDac] area.
//              - it is offset from the ppdev->ulPrimarySurfaceOffset
//
// Return Value:
//
//     None.
//**************************************************************************/
void __cdecl NvSetDacImageOffset(PDEV* ppdev, ULONG ulDac, ULONG ulOffset)
{
    // !!! To Do
    // ulDac is not current used; will be used for NV11 Dual View.
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    // Wait for previous image completed
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

    NV_DMAPUSH_CHECKFREE( ((ULONG)(6)));

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulDac);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_OFFSET(0), ulOffset + ppdev->ulPrimarySurfaceOffset);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_FORMAT(0), ppdev->lDelta |
                    NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31);

    UPDATE_PDEV_DMA_COUNT;

    //******************************************************************
    // Send data on thru to the DMA push buffer
    //******************************************************************
    NV4_DmaPushSend(ppdev);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4lines.c ===
//******************************************************************************
//
// Module Name: NV4LINES.C
// 
// Contains most of the required GDI line support.  Supports drawing
// lines in short 'strips' when clipping is complex or coordinates
// are too large to be drawn by the line hardware.
// 
// Copyright (c) 1990-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

#define PO_ALL_INTEGERS     0x00000004
#define PO_ENUM_AS_INTEGERS 0x00000008

#define POINT_OUTOFBOUNDS(x,y) \
(\
  ((x) ^ ((int)(x) >> 31) |  \
   (y) ^ ((int)(y) >> 31)  ) \
  & 0xFFFF8000               \
)
//*****************************************************************************
// Externs
//*****************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );


    
//*****************************************************************************
//  Function:     vector_has_tiebreaker_pixels
//  Routine Description: 
//                Checks to see if the line contains pixels which will be
//                affected by tiebreaker rules
//  Arguments:    All coordinates are integer.
//  Return Value: TRUE if tiebreaker pixels exist, FALSE otherwise
//*****************************************************************************
BOOL vector_has_tiebreaker_pixels
(
    LONG x1,
    LONG y1,
    LONG x2,
    LONG y2
)
{
    LONG    delta_x = x2 - x1;
    LONG    delta_y = y2 - y1;

    /*
    ** No tiebreakers in vectors with no minor steps.
    */
    if ((delta_x==0) || (delta_y==0))
        return FALSE;

    /*
    ** Calculate magnitudes of delta_major and delta_minor.
    */
    if (delta_x < 0)
        delta_x = -delta_x;

    if (delta_y < 0)
        delta_y = -delta_y;

    /*
    ** A bresenham pattern repeats "common factors" times over the length of
    ** the vector where "common factors" is the product of the common factors
    ** in delta_x and delta_y.  We don't care about odd common factors because
    ** that case can never create a tiebreaker situation.  We'll refer to this
    ** result of eliminating the 2^n factor as the "2^n reduced slope".
    **
    ** If the "2^n reduced slope" is such that reduced delta_major is EVEN and
    ** reduced delta_minor is ODD then the bresenham will step at least one
    ** case were the pure (not tiebreaker biased) bresenham error will be 0.
    ** 
    ** We don't need the actual reduced delta values.  Since we have already
    ** eliminated the '0' cases, taking the largest 2^n common factor out the
    ** delta_* values results in at least one of them being ODD.  The only way
    ** then for the reduced delta_major to be EVEN and the reduced delta_minor
    ** to be ODD is if delta_major has a larger 2^n factor than delta_minor.
    **
    ** ANDing a number and its 2's complement gives the highest 2^n factor.
    */

    if (delta_x > delta_y)
    {
        // x major vector

        if ((delta_x & -delta_x) > (delta_y & -delta_y))
            return TRUE;
    }
    else
    {
        // y major vector

        if ((delta_y & -delta_y) > (delta_x & -delta_x))
            return TRUE;
    }

    return FALSE;
}

//*****************************************************************************
//
//  Function:   vLinesSimple
//
//  Routine Description:
//
//              Strokes the path.
//
//  Arguments:  All coordinates are integer.
//
//  Return Value:
//
//      None.
//
//*****************************************************************************
VOID vLinesSimple(
PDEV*       ppdev,
PATHOBJ*    ppo,
BRUSHOBJ*  pbo,
RECTL*  prclClip
)
{
    BOOL        bMore;
    PATHDATA    pd;
    LONG        cVertex;
    POINTFIX*   pptfx;
    POINTFIX    ptfxStartFigure = {0, 0};
    ULONG       i;
    DECLARE_DMA_FIFO;
 
    INIT_LOCAL_DMA_FIFO;

    PATHOBJ_vEnumStart(ppo);    
    ppo->fl |= PO_ENUM_AS_INTEGERS;
    
    //**********************************************************
    // Set Point and Size methods for clip:
    //    NV019_SET_POINT
    //    NV019_SET_SIZE
    //**********************************************************
    NV_DMAPUSH_CHECKFREE( ((ULONG)(5)));  
    
    if((prclClip == NULL) && (ppdev->NVClipResetFlag))
    {
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = 0;
        NV_DMA_FIFO = ppdev->dwMaxClip; 
        ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
    }
    else if(prclClip != NULL)
    {
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = (( prclClip->top << 16) |  prclClip->left);
        NV_DMA_FIFO = (((prclClip->bottom - prclClip->top) << 16) 
                    | (prclClip->right - prclClip->left) ); 
        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
    }
    
    
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_COLOR, pbo->iSolidColor);
    do {
    
        bMore  = PATHOBJ_bEnum(ppo, &pd);
        cVertex = pd.count;
        pptfx  = pd.pptfx;

        //**************************************************************
        // Check if we've got enough room in the push buffer
        //**************************************************************
        
        NV_DMAPUSH_CHECKFREE( ((ULONG)( 4 + cVertex*2 + cVertex / 16 )));  
        
        if (pd.flags & PD_BEGINSUBPATH)
        {
            // New path; can be multiple paths
            ptfxStartFigure.x = pptfx->x;
            ptfxStartFigure.y = pptfx->y;
        
            cVertex--;
            pptfx++;
        }
  
        NV_DMAPUSH_START( 4, SOLID_LIN_SUBCHANNEL, NV05C_LIN32(0));
        NV_DMA_FIFO = ptfxStartFigure.x;
        NV_DMA_FIFO = ptfxStartFigure.y;
        NV_DMA_FIFO = pptfx->x;
        NV_DMA_FIFO = pptfx->y;
        
        if(--cVertex)
            pptfx++;
        
        while(cVertex > 16)
        {
            NV_DMAPUSH_START(32, SOLID_LIN_SUBCHANNEL, NV05C_POLY_LIN32(0));
        
            for(i = 0; i < 16; i++, --cVertex)
            {
                NV_DMA_FIFO = pptfx->x;
                NV_DMA_FIFO = pptfx->y;
        
                pptfx++;
            }
        }
        
        if(cVertex > 0)
        {
            NV_DMAPUSH_START( 2*cVertex, SOLID_LIN_SUBCHANNEL, NV05C_POLY_LIN32(0));
            while (cVertex > 0)
            {
                NV_DMA_FIFO = pptfx->x;
                NV_DMA_FIFO = pptfx->y;
                if(--cVertex)
                    pptfx++;
            }
        }

        if (pd.flags & PD_CLOSEFIGURE)
        {
            pd.flags &= ~PD_CLOSEFIGURE;
            NV_DMAPUSH_START( 2, SOLID_LIN_SUBCHANNEL, NV05C_POLY_LIN32(0));
            NV_DMA_FIFO = ptfxStartFigure.x;
            NV_DMA_FIFO = ptfxStartFigure.y;
        }
        
        if(!bMore) break;
        
        // Multiple paths
        ptfxStartFigure.x = pptfx->x;
        ptfxStartFigure.y = pptfx->y;
            
    } while (1);
    
    //******************************************************************
    // Update global push buffer count
    //******************************************************************
    
    UPDATE_PDEV_DMA_COUNT;

    //******************************************************************
    // Send data on thru to the DMA push buffer
    //******************************************************************

    NV4_DmaPushSend(ppdev);
}


//*****************************************************************************
//
//  Function:   NV4DmaPushStrokePath
//
//  Routine Description:
//
//              Strokes the path.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************

BOOL NV4DmaPushStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)

    {
    PDEV*       ppdev;
    DSURF*      pdsurf;
    RECTL       arclClip[4];                  // For rectangular clipping

    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    PuntPtr;

    BOOL        bMore;
    ULONG       VertexCount;
    POINTFIX    *CurrentVertexPtr;
    POINTFIX    *FirstVertexPtr;
    POINTFIX    *NextVertexPtr;
    POINTFIX    *LastVertexPtr;

    POINTFIX    *CurrPt = NULL;
    POINTFIX    *PrevPt = NULL;
    POINTFIX    *FrstPt = NULL;
    POINTFIX    *LastPt = NULL;

    LONG        x0,y0;
    LONG        x1,y1;
    ULONG       width,height;
    ULONG       AlphaEnableValue;
    PATHDATA    pd;
    ULONG       temp;
    ULONG       LineVisibleFlag;
    ULONG       Rop3;
    ULONG       i;
    LONG        curX, curY;
    BYTE        jClip;
    RECTFX      BoundingRect;

    DECLARE_DMA_FIFO;


    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Default to the original surface object passed in to us
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = ppdev->psoPunt;

    pdsurf = (DSURF*) pso->dhsurf;

    //**************************************************************************
    // As of NT 4.0 SP2, the rasterization convention has been loosened
    // for paths that have the PO_ALL_INTEGERS flag set.  For those paths,
    // you may do the 'tie-breaker' pixels anyway you like, which usually
    // means that you can use the point-to-point line drawing capabilities
    // of the hardware.
    //**************************************************************************
    if ((ppo->fl & PO_ALL_INTEGERS) &&      // Points must be integer
        !(pla->fl & LA_STYLED))             // Solid lines, no styles
    {
        CLIPENUM  ce;
    
        //**************************************************************************
        //  Check that the points sent to us are not going to be out
        //  of range for our hardware. Also check that the lines to be drawn
        //  don't have tiebreakers, since hw handles tiebreakers differently from
        //  NT4/W2K gdi.  
        //**************************************************************************
        PATHOBJ_vEnumStart(ppo);
        ppo->fl |= PO_ENUM_AS_INTEGERS;
        do
        {
            pd.flags = 0;
            bMore = PATHOBJ_bEnum(ppo, &pd);
            CurrPt = &(pd.pptfx[0]);
            if (POINT_OUTOFBOUNDS(CurrPt->x,CurrPt->y))
                goto DMAPUSH_GDI_StrokePathIt;


            if (pd.flags & PD_BEGINSUBPATH || LastPt == NULL)
            {
                FrstPt = CurrPt;
                PrevPt = CurrPt;
                CurrPt++;
                pd.count --;
            }
            else
            {
                FrstPt = LastPt;
                PrevPt = LastPt;
            }

            // check first line to get count/ptrs coordinated. There will always be at
            // least one line
            if (vector_has_tiebreaker_pixels(CurrPt->x,CurrPt->y,PrevPt->x,PrevPt->y) ||
                POINT_OUTOFBOUNDS(CurrPt->x,CurrPt->y))
            {
                goto DMAPUSH_GDI_StrokePathIt;
            }

            pd.count --;
            PrevPt = CurrPt;
            while (pd.count)
            {
                CurrPt++;
                if (vector_has_tiebreaker_pixels(CurrPt->x,CurrPt->y,PrevPt->x,PrevPt->y) ||
                    POINT_OUTOFBOUNDS(CurrPt->x,CurrPt->y))
                {
                    goto DMAPUSH_GDI_StrokePathIt;
                }
                PrevPt++;
                pd.count--;
            }

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (vector_has_tiebreaker_pixels(CurrPt->x,CurrPt->y,FrstPt->x,FrstPt->y))
                {
                    goto DMAPUSH_GDI_StrokePathIt;
                }
            }
            LastPt = CurrPt;

        } while (bMore);

        NV_DMAPUSH_CHECKFREE(( (ULONG) (4) ));  
    
        if(ppdev->dDrawSpareSubchannelObject != DD_IMAGE_ROP_AND_LIN)
        {
            NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_ROP_AND_LIN);
            ppdev->dDrawSpareSubchannelObject     = DD_IMAGE_ROP_AND_LIN;
        }

        //**************************************************************
        // Reset clipping rectangle to full screen extents if necessary
        // Resetting the clipping rectangle causes delays so we want to
        // do it as little as possible!
        //**************************************************************
    
                                  
        Rop3 = (mix & 0x0f) - 1;
        Rop3 |= (Rop3 << 4);
    
        NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);
    
    
        UPDATE_PDEV_DMA_COUNT;
    
        if (pco->iDComplexity == DC_TRIVIAL)
        {
            vLinesSimple(ppdev, ppo, pbo, NULL);
            return(TRUE);
        }
        else
        {
            if (pco->iDComplexity == DC_RECT)
            {
                vLinesSimple(ppdev, ppo, pbo, &pco->rclBounds);
            }
            else
            {
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN,
                                   0);

                do {
                    // Get a batch of region rectangles:

                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*) &ce);
                    for (i = 0; i < (ULONG)ce.c; i++)
                    {
                        vLinesSimple(ppdev, ppo, pbo, &ce.arcl[i]);
                    }
                } while (bMore);
            }
            return(TRUE);
        }
        return(TRUE);
    }

    //**************************************************************************
    // Only SIMPLE, STRAIGHT lines implemented, the rest go thru GDI
    //
    // If we get to this point, the line is to be drawn onscreen
    // We'll currently use NV hardware to ONLY draw straight integer lines.
    // (Because #1) The line object is not yet implemented, just the solid
    //              rectangle object, so we'll use that to draw only straight lines
    //          #2) Currently don't have time to verify the lines are drawn
    //              exactly correct.  We'll just handle the extremely simple
    //              lines, and let GDI worry about the rest.
    //**************************************************************************

    //**************************************************************************
    // ONLY handle solid single pixel wide lines
    // Line Style is solid if pstyle array ptr is NULL
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;
    else
        jClip = pco->iDComplexity;

    if ((pla->pstyle == (FLOAT_LONG*) NULL) && !(pla->fl & (LA_GEOMETRIC | LA_ALTERNATE)))
        {

        //**********************************************************************
        // ONLY handle non-clipped lines or single rectangle clipped lines
        //**********************************************************************

        if ((jClip == DC_TRIVIAL) || (jClip == DC_RECT))
            {
            //******************************************************************
            // If this is a mix which uses the destination, then we cannot punt to GDI
            // in the middle of a path enumeration since GDI will draw the same lines
            // which we have already drawn. So we MUST prescan the list of lines in the
            // path to ensure that none of the vertices in the path have a fractional
            // component, and that ALL of the lines are either horiz or vert. For now
            // we'll just check for a SRCCOPY mix.
            //******************************************************************
            if ((mix & 0xf) != R2_COPYPEN)
            {
                PATHOBJ_vEnumStart(ppo);
                do
                {
                    pd.flags = 0;
                    bMore = PATHOBJ_bEnum(ppo, &pd);
                    curX = pd.pptfx[0].x >> 4;
                    curY = pd.pptfx[0].y >> 4;

                    for (i = 0; i < pd.count; i++)
                    {
                        if ((((pd.pptfx[i].x | pd.pptfx[i].y) & 0xf) != 0) ||
                            !((pd.pptfx[i].x >> 4) == curX || (pd.pptfx[i].y >> 4) == curY))
                            goto DMAPUSH_GDI_StrokePathIt;
                        else
                            {
                            curX = pd.pptfx[i].x >> 4;
                            curY = pd.pptfx[i].y >> 4;
                            }
                    }
                    if (pd.flags & PD_BEGINSUBPATH)
                    {
                        //**********************************************************
                        // Get ptr to coordinates of the first vertex
                        //**********************************************************
                        FirstVertexPtr      = pd.pptfx;
                    }
                    if (pd.flags & PD_CLOSEFIGURE)
                    {
                        if(!((FirstVertexPtr->x >> 4) == curX || (FirstVertexPtr->y >> 4) == curY))
                            goto DMAPUSH_GDI_StrokePathIt;
                    }
                } while (bMore);
            }

            //******************************************************************
            // First, copy the clipping rectangle if it's present
            //******************************************************************

            if (jClip == DC_RECT)
                {
                arclClip[0] = pco->rclBounds;
                }

            //******************************************************************
            // Convert mix to a Rop3 value.
            //******************************************************************
            Rop3 = (mix & 0x0f) - 1;
            Rop3 |= (Rop3 << 4);

            NV_DMAPUSH_CHECKFREE(( (ULONG) (7) ));  
                
            NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

            //**************************************************************
            // Reset clipping rectangle to full screen extents if necessary
            // Resetting the clipping rectangle causes delays so we want to
            // do it as little as possible!
            //**************************************************************
    
            if (ppdev->NVClipResetFlag)
                {
                //**********************************************************
                // Set Point and Size methods for clip:
                //    NV019_SET_POINT
                //    NV019_SET_SIZE
                //**********************************************************
    
                NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
                NV_DMA_FIFO = 0;
                NV_DMA_FIFO = ppdev->dwMaxClip; 
    
                ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
                }

            NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL,
                                  NV04A_COLOR1_A,
                                  pbo->iSolidColor);
    
            PATHOBJ_vEnumStart(ppo);
            do  {

                pd.flags = 0;

                //**************************************************************
                // Get the current group of lines
                //**************************************************************

                bMore = PATHOBJ_bEnum(ppo, &pd);

                //**************************************************************
                // Get number of vertices in this record.
                //**************************************************************

                VertexCount = pd.count;

                //**************************************************************
                // Check if we've got enough room in the push buffer
                //**************************************************************
    
                NV_DMAPUSH_CHECKFREE(((ULONG)(5 + (VertexCount*4))));  
    
                //**************************************************************
                // Check to see if we need to 'reset' the starting vertex
                //**************************************************************

                if (pd.flags & PD_BEGINSUBPATH)
                    {
                    //**********************************************************
                    // Get ptr to coordinates of the first vertex
                    //**********************************************************

                    CurrentVertexPtr    = pd.pptfx;
                    NextVertexPtr       = pd.pptfx+1;
                    FirstVertexPtr      = pd.pptfx;
                    }

                else

                    {
                    //**********************************************************
                    // Get coordinates of first vertex.
                    // Since we didn't get a BEGIN_SUBPATH notification,
                    // use the last vertex from the last line record
                    // as the first vertex.
                    //**********************************************************

                    CurrentVertexPtr    = LastVertexPtr;
                    NextVertexPtr       = pd.pptfx;

                    // We didn't get a BEGIN_SUBPATH.  Since the next PATHDATA
                    // retreived from the PATHOBJ could have only 1 point in it
                    // (a case that occurs in w2k), if we don't inc the VertexCount,
                    // we will skip a line segment (the joint between the lastvertex
                    // from the last PATHDATA and this 1 point) because the linedrawing
                    // loop will immediatly exit (VertexCount will be < 2).
                    
                    VertexCount++;
                    }


                //**************************************************************
                // Exit if there aren't at least 2 vertices
                //**************************************************************

                if (VertexCount < 2)
                    goto DMAPUSH_NV_LinesAreDone;

                //**************************************************************
                //
                // Save a ptr to the last vertex in this record
                //
                // ( there is no chance of getting a dangling reference because
                //  to pointer saved points to an element of the PATHDATA we
                //  are currently processing. In the next fetch from the PATHOBJ
                // (with PATHOBJ_bEnum), we will get a new PATHDATA, and the 
                // pointer will be invalid, but is not used before we get here
                // again. (And when we get here, we make the ptr valid) )
                //**************************************************************

                
                LastVertexPtr = &( pd.pptfx[ pd.count - 1 ] );


                //**************************************************************
                // Need a minimum of 2 vertices per line
                //**************************************************************

                do  {
                    //**********************************************************
                    // Check each line and see if it's an integer and straight
                    // Get the first PATHDATA record
                    //**********************************************************

                    x0 = CurrentVertexPtr->x;
                    y0 = CurrentVertexPtr->y;

                    x1 = NextVertexPtr->x;
                    y1 = NextVertexPtr->y;

                    //**********************************************************
                    // Send to GDI if we get a non-integer line
                    //**********************************************************

                    if (((x0 | y0 | x1 | y1) & 0xf) != 0)
                        goto DMAPUSH_GDI_StrokePathIt;

                    //**********************************************************
                    // Get rid of fixed fractional component
                    //**********************************************************

                    x0 >>=4;
                    y0 >>=4;
                    x1 >>=4;
                    y1 >>=4;

                    //**********************************************************
                    // Default to always drawing the line
                    //**********************************************************

                    LineVisibleFlag = TRUE;

                    //**********************************************************
                    // Only draw line if it's horizontal or vertical
                    //**********************************************************

                    if (x0==x1)

                        {
                        //******************************************************
                        // We're dealing with a VERTICAL line
                        // Make sure to calculate a positive height and
                        // swap the coordinates if necessary
                        //******************************************************

                        width=1;
                        if (y0 > y1)
                            {
                            temp=y0;
                            y0=y1+1;
                            y1=temp+1;
                            }

                        //******************************************************
                        // Vertical Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((x0 < arclClip[0].left) || (x0 >= arclClip[0].right) ||
                                (y1 <= arclClip[0].top) || (y0 >= arclClip[0].bottom))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the height.
                                //**********************************************

                                if (y1 > arclClip[0].bottom)
                                    y1 = arclClip[0].bottom;

                                if (y0 < arclClip[0].top)
                                    y0 = arclClip[0].top;
                                }
                            }
                        height = y1 - y0;
                        }

                   else if (y0==y1)

                        {
                        //******************************************************
                        // We're dealing with a HORIZONTAL line
                        // Make sure to calculate a positive width and
                        // swap the coordinates if necessary
                        //******************************************************

                        height=1;
                        if (x0 > x1)
                            {
                            temp=x0;
                            x0=x1+1;
                            x1=temp+1;
                            }

                        //******************************************************
                        // Horizontal Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((y0 < arclClip[0].top) || (y0 >= arclClip[0].bottom) ||
                                (x1 <= arclClip[0].left) || (x0 >= arclClip[0].right))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the width.
                                //**********************************************

                                if (x1 > arclClip[0].right)
                                    x1 = arclClip[0].right;

                                if (x0 < arclClip[0].left)
                                    x0 = arclClip[0].left;

                                }
                            }
                        width = x1 - x0;
                        }

                    else

                        {
                        //******************************************************
                        // This group of lines contains a NON straight line.
                        // Just punt it back to GDI
                        //******************************************************
                        goto DMAPUSH_GDI_StrokePathIt;

                        }

                    //**********************************************************
                    // Time to output a straight line if visible
                    //**********************************************************

                    if (LineVisibleFlag == TRUE)
                        {
                        DISPDBG((6,"x,y: %x %x h,w: %x %x", x0, y0, height, width));

                        //******************************************************
                        // Set Point and Size methods for rectangle:
                        //******************************************************

                        NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL,
                                          NV04A_UNCLIPPED_RECTANGLE_POINT(0))

                        NV_DMA_FIFO = (x0 << 16) | (y0 & 0xffff);
                        NV_DMA_FIFO = ( width << (16) | height );
                        
                        //******************************************************
                        // Advance to next line (must have at least 2 vertices)
                        //******************************************************
                        }

                    VertexCount--;

                    CurrentVertexPtr = NextVertexPtr;
                    NextVertexPtr++;

                    } while (VertexCount >= 2);

                //**************************************************************
                // Draw closing line if specified and if it's straight
                //**************************************************************

                if (pd.flags & PD_CLOSEFIGURE)
                    {

                    x0 = LastVertexPtr->x;
                    y0 = LastVertexPtr->y;

                    x1 = FirstVertexPtr->x;
                    y1 = FirstVertexPtr->y;

                    //**********************************************************
                    // Send to GDI if we get a non-integer line
                    //**********************************************************

                    if (((x0 | y0 | x1 | y1) & 0xf) != 0)
                        goto DMAPUSH_GDI_StrokePathIt;

                    //**********************************************************
                    // Get rid of fixed fractional component
                    //**********************************************************

                    x0 >>=4;
                    y0 >>=4;
                    x1 >>=4;
                    y1 >>=4;

                    //**********************************************************
                    // Default to always drawing the closing line
                    //**********************************************************

                    LineVisibleFlag = TRUE;

                    //**********************************************************
                    // Make sure line is straight!
                    //**********************************************************

                    if (x0==x1)

                        {
                        //******************************************************
                        // We're dealing with a VERTICAL line
                        // Make sure to calculate a positive height and
                        // swap the coordinates if necessary
                        //******************************************************

                        width=1;
                        if (y0 > y1)
                            {
                            temp=y0;
                            y0=y1+1;
                            y1=temp+1;
                            }

                        //******************************************************
                        // Vertical Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((x0 < arclClip[0].left) || (x0 >= arclClip[0].right) ||
                                (y1 <= arclClip[0].top) || (y0 >= arclClip[0].bottom))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the height.
                                //**********************************************

                                if (y0 < arclClip[0].top)
                                    y0 = arclClip[0].top;

                                if (y1 > arclClip[0].bottom)
                                    y1 = arclClip[0].bottom;
                                }
                            }
                        height = y1 - y0;
                        }

                   else if (y0==y1)

                        {
                        //******************************************************
                        // We're dealing with a HORIZONTAL line
                        // Make sure to calculate a positive width and
                        // swap the coordinates if necessary
                        //******************************************************

                        height=1;
                        if (x0 > x1)
                            {
                            temp=x0;
                            x0=x1+1;
                            x1=temp+1;
                            }

                        //******************************************************
                        // Horizontal Line Clipping:
                        // At this point, we have the following variables to
                        // work with:       x,y,  and  width,height
                        //
                        // Now we can do single rectangle clipping very easily
                        //******************************************************

                        if (jClip == DC_RECT)
                            {

                            //**************************************************
                            // Check if is line is visible or completely clipped
                            //**************************************************

                            if ((y0 < arclClip[0].top) || (y0 >= arclClip[0].bottom) ||
                                (x1 <= arclClip[0].left) || (x0 >= arclClip[0].right))
                                LineVisibleFlag = FALSE;
                            else
                                {
                                //**********************************************
                                // If line is visible, check if it needs to be clipped
                                // If it is clipped , then update the width.
                                //**********************************************

                                if (x0 < arclClip[0].left)
                                    x0 = arclClip[0].left;

                                if (x1 > arclClip[0].right)
                                    x1 = arclClip[0].right;
                                }
                            }
                        width = x1 - x0;
                        }


                    else

                        {
                        //******************************************************
                        // This group of lines contains a NON straight line.
                        // Just punt it back to GDI
                        //******************************************************
                        goto DMAPUSH_GDI_StrokePathIt;

                        }


                    //**********************************************************
                    // Time to output a straight line if visible
                    //**********************************************************

                    if (LineVisibleFlag == TRUE)
                        {
                        DISPDBG((6,"x,y: %x %x h,w: %x %x", x0, y0, height, width));

                        //******************************************************
                        // Set Point and Size methods for rectangle:
                        //******************************************************

                        NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL,
                                          NV04A_UNCLIPPED_RECTANGLE_POINT(0))

                        NV_DMA_FIFO = (x0 << 16) | (y0 & 0xffff);
                        NV_DMA_FIFO = ( width << (16) | height );
                        
                        }

                    }

                } while (bMore) ;

DMAPUSH_NV_LinesAreDone:
            //******************************************************************
            // Update global push buffer count
            //******************************************************************

            UPDATE_PDEV_DMA_COUNT;
            
            //******************************************************************
            // Send data on thru to the DMA push buffer
            //******************************************************************

            NV4_DmaPushSend(ppdev);

            return(TRUE);

            } // Only handle non-clipped lines or lines clipped to a single rectangle


        } // Only handle solid-lines


    //**************************************************************************
    // Send all other lines thru GDI
    //**************************************************************************

DMAPUSH_GDI_StrokePathIt:

    if (pdsurf !=0)

        {

        //******************************************************************
        // This is an offscreen DFB (DT_SCREEN).  Let GDI draw the line
        // using the wrapper 'punt' surface object
        //******************************************************************

        PuntPtr->dhsurf = 0;               // Behave like a standard DIB
        PuntPtr->sizlBitmap = pdsurf->sizl;

        //******************************************************************
        // Set linear offset and stride for source and destination buffers
        //******************************************************************

        PuntPtr->cjBits  = pdsurf->LinearStride * pdsurf->sizl.cy;
        PuntPtr->pvBits  = pdsurf->LinearPtr;
        PuntPtr->pvScan0 = pdsurf->LinearPtr;
        PuntPtr->lDelta  = pdsurf->LinearStride;

        PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;

        TempDstSurfObjPtr = PuntPtr;

        }

    //**************************************************************************
    // Update global push buffer count
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;
    
    NV4_DmaPushSend(ppdev);

    ppdev->pfnWaitEngineBusy(ppdev);
    return(EngStrokePath(TempDstSurfObjPtr, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));


    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv3textc.c ===
//******************************Module*Header***********************************
//
// Module Name: NV3TEXTC.C
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

#ifdef NV3
#include "oldnv332.h"
#define NV32_INCLUDED // Prevents re-inclusion of real nv32 header
#include "driver.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// Extern declarations
//******************************************************************************

// IA64 Assembly is NOT feasible under IA64
#ifndef _WIN64
extern void NV3_Transfer_Text_Data(ULONG, USHORT *, ULONG *, Nv3ChannelPio *);
#endif

extern VOID vClipSolid(PDEV* ,LONG ,RECTL *,ULONG ,CLIPOBJ*);
extern RECTL grclMax;

//******************************************************************************
//
//  Function:   NV3GeneralText
//
//  Routine Description:
//
//      Handles any strings that need to be clipped, using the 'glyph
//      expansion' method.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV3GeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco,
BRUSHOBJ* pboFore)

    {
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    DWORD*      myGlyph;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        cx;
    LONG        cy;
    BYTE        iDComplexity;

    Nv3ChannelPio   *nv = (Nv3ChannelPio *)ppdev->pjMmBase;
    ULONG       width,height;
    ULONG       SizeInWidth;
    ULONG       NumDwords;
    ULONG       NumBytesPerScan;
    ULONG       Color1;
    USHORT      FreeCount;
    ULONG       NumDwordsPerGlyph;
    ULONG       AlphaEnableValue;
    ULONG       LocalClipResetFlag;

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    //**************************************************************************
    // Get pixel depth for the current mode.
    // Then determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //**************************************************************************
    // Get first freecount
    //**************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //**************************************************************************
    // Since we are using Class D of the monster text class, we don't
    // have to specify color 0 (It's always transparent)
    // We only need to get and specify the color for the '1' bits.
    //**************************************************************************

    Color1 = pboFore->iSolidColor   | ( AlphaEnableValue); // Visible

    //**************************************************************************
    // Must make sure that ROP is set correctly
    //**************************************************************************

    while (FreeCount < 1*4)
         FreeCount = nv->subchannel[ROP_SOLID_SUBCHANNEL].control.Free;
    FreeCount -= 1*4;

    nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = NV_SRCCOPY ;

    //**************************************************************************
    // Performance Optimization: Only specify the clipping rectangle
    // if necessary.  A nonzero value means that we need to resend it to hardware.
    //**************************************************************************

    LocalClipResetFlag = 1;

    do  {

        //**********************************************************************
        // pstro->pgp points to the GLYPHPOS array for the whole string.
        // If it is NONZERO, then enumeration is not needed.  There's
        // just one batch of glyphs
        //**********************************************************************

        if (pstro->pgp != NULL)

            {
            //******************************************************************
            // There's only the one batch of glyphs, so save ourselves
            // a call:
            //
            // pgpOriginal   --> GLYPHPOS (contains glyph definition and src origin
            // cGlyphOriginal -> Number of glyphs in the string object
            // bMoreGlyphs    -> Since there's only one batch, don't enumerate
            //******************************************************************

            pgpOriginal    = pstro->pgp;
            cGlyphOriginal = pstro->cGlyphs;
            bMoreGlyphs    = FALSE;
            }

        else

            {
            //******************************************************************
            // Get next batch of GLYPHPOS structures
            //******************************************************************
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
            }

        //**********************************************************************
        // Check if we have any glyphs to output
        //**********************************************************************

        if (cGlyphOriginal > 0)
            {
            //******************************************************************
            // If ulCharInc is NONZERO, then we have a fixed-pitch
            // (monospace) font.  Just add this value to get position of next char
            //******************************************************************

            ulCharInc = pstro->ulCharInc;

            //******************************************************************
            // Check whether we need to do clipping or not
            //******************************************************************

            iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

            if (iDComplexity != DC_COMPLEX)
                {
                //**************************************************************
                // We could call 'cEnumStart' and 'bEnum' when the clipping is
                // DC_RECT, but the last time I checked, those two calls took
                // more than 150 instructions to go through GDI.  Since
                // 'rclBounds' already contains the DC_RECT clip rectangle,
                // and since it's such a common case, we'll special case it:
                //**************************************************************

                //**************************************************************
                // ce => Clip enumeration structure, consists of c (count)
                //       and an array of rectangle structures
                // Specify bmore = FALSE because we have one clipping structure
                //**************************************************************

                bMore = FALSE;
                ce.c  = 1;

                //**************************************************************
                // grclMax essentially means to ignore clipping
                // Otherwise, use the bounds specified in the CLIP Object
                //**************************************************************

                if (iDComplexity == DC_TRIVIAL)
                    prclClip = &grclMax;
                else
                    prclClip = &pco->rclBounds;

                //**************************************************************
                // Skip ahead and handle one clipping rectangle
                //**************************************************************
                goto SingleRectangle;
                }

            //******************************************************************
            // pco           -> Clip Object
            // FALSE         -> only parts relevant to the current drawing
            //                  operation should be enumerated.  Otherwise,
            //                  the whole region should be enumerated (TRUE)
            // CT_RECTANGLES -> Region is to be enumerated as a list of
            //                  rectangles
            //******************************************************************

            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

            //******************************************************************
            // Get the next clip rectangle to be enumerated from clip region.
            // (ce holds the clip rectangle)
            //******************************************************************

            do  {
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                //**************************************************************
                // Draw glyphs for each clipping rectangle
                //**************************************************************

                for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)

                    {
SingleRectangle:
                    pgp    = pgpOriginal;           // GLYPHPOS structure
                    cGlyph = cGlyphOriginal;        // Number of glyphs
                    pgb    = pgp->pgdf->pgb;        // Ptr to GLYPHBITS structure

                    //**********************************************************
                    // Origin = Origin of char in bitmap + position on screen
                    //**********************************************************

                    ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
                    ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

                    //**********************************************************
                    // Loop through all the glyphs for this rectangle:
                    //**********************************************************

                    while (TRUE)
                        {
                        //******************************************************
                        // Get the size (in pixels) of the monochrome bitmap
                        //******************************************************

                        cxGlyph = pgb->sizlBitmap.cx;
                        cyGlyph = pgb->sizlBitmap.cy;

                        //******************************************************
                        // Get pointer to BYTE aligned glyph bitmap
                        //******************************************************

                        pjGlyph = pgb->aj;

                        //******************************************************
                        // Check if this glyph lies completely within
                        // the clipping rectangle.
                        //******************************************************

                        if ((prclClip->left   <= ptlOrigin.x) &&
                            (prclClip->top    <= ptlOrigin.y) &&
                            (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                            (prclClip->bottom >= ptlOrigin.y + cyGlyph))
                            {

                            //**************************************************
                            // Unclipped glyph
                            //**************************************************

                            //**************************************************
                            // Specify SizeInWidth as multiple of 32 since
                            // we always output DWORDS at a time. The excess
                            // pixels will get clipped according to the width
                            // we specify in Size. SizeInWidth corresponds to the
                            // amount of data that the NV Engine expects.
                            //**************************************************

                            width = cxGlyph;
                            height= cyGlyph;
                            SizeInWidth = (width + 31) & 0xffe0;
                            NumBytesPerScan = (width+7) >> 3;   // Divide by 8

                            //**************************************************
                            // As far as I can tell, the beginning of the
                            // glyph (according to the GLYPHBITS structure)
                            // appears to always start on a DWORD boundary.
                            // In addition, the DDK specifies that the bits
                            // will always be DWORD padded at the end.
                            // So let's just deal with DWORDS for performance.
                            // Otherwise, use the slow byte-by-byte routine.
                            //**************************************************

                            //**************************************************
                            // Calculate total number of DWORDS NV engine expects
                            // to receive for this glyph.  Add 3 so that
                            // 1->4 bytes means 1 dword, 5-8 bytes means 2 dwords..etc..
                            //**************************************************

                            NumDwordsPerGlyph = ((NumBytesPerScan*height)+3) >> 2 ; // Divide by 4

                            //**************************************************
                            // Specify SizeInWidth as multiple of 8 since
                            // the incoming glyph data is always row ordered
                            // and BYTE packed. We will always output up to a
                            // BYTE boundary. The excess pixels will get clipped
                            // according to the width we specify in Size.
                            // 'SizeIn' corresponds to the amount of data
                            // that the NV Engine expects to receive, and it
                            // specifies how the data will be layed out on the
                            // screen.. 'Size' just corresponds to the clipping
                            // rectangle. Add 7 so that 1->8 means 8, 9-16 means 16, etc...
                            //**************************************************

                            SizeInWidth = (width + 7) & 0xfff8;

                            //**************************************************
                            // Only send the clip rectangle if this is the first
                            // time, or we've changed the state of the hardware
                            // (by using another class).  Otherwise, we don't
                            // have to constantly send these values thru the FIFO.
                            //**************************************************

                            if (LocalClipResetFlag)
                                {
                                while (FreeCount < 3*4)
                                    FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
                                FreeCount -= 3*4;

                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint0D = ((0 << 16) | 0);
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint1D = ( ((ppdev->cyMemory)<<16) | (ppdev->cxMemory) ) ;
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color1D = Color1;

                                LocalClipResetFlag=0;
                                }


                            while (FreeCount < 3*4)
                               FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
                            FreeCount -= 3*4;

                            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeInD = ( (height <<16) | SizeInWidth );
                            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeOutD = ( (height <<16) | width );
                            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.PointD =  ( ((ptlOrigin.y) <<16) | ((ptlOrigin.x) & 0xffff) );


                            //**************************************************
                            // Get pointer to monochrome bitmap
                            //**************************************************

                            myGlyph = (DWORD *)pjGlyph;

                            //**************************************************
                            // Check if Bitmap pointer is DWORD aligned
                            //**************************************************

                            ASSERTDD( (((ULONG_PTR)pjGlyph & 3) == 0), "NOT dword aligned !!!");

                            //**************************************************
                            // Blast out the data as fast as possible
                            // in assembly routine
                            //**************************************************
// IA64 Assembly is NOT feasible under IA64
#ifndef _WIN64
                            NV3_Transfer_Text_Data(NumDwordsPerGlyph,&FreeCount,&myGlyph[0],nv);
#endif

                            }

                        else

                            {

                            //**************************************************
                            // Clipped glyph
                            //**************************************************

                            //**************************************************
                            // Find the intersection of the glyph rectangle
                            // and the clip rectangle:
                            //**************************************************

                            xLeft   = max(prclClip->left,   ptlOrigin.x);
                            yTop    = max(prclClip->top,    ptlOrigin.y);
                            xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                            yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                            //**************************************************
                            // Check for trivial rejection:
                            //**************************************************

                            if (((cx = xRight - xLeft) > 0) &&
                                ((cy = yBottom - yTop) > 0))
                                {
                                //**********************************************
                                // Specify the hardware clipping rectangle
                                //**********************************************

                                while (FreeCount < 2*4)
                                   FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
                                FreeCount -= 2*4;

                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint0D = (((prclClip->top) << 16) | ((prclClip->left)&0xffff) );
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.ClipPoint1D = ((prclClip->bottom <<16) | ((prclClip->right&0xffff)));


                                //**********************************************
                                // The clipping rectangle has changed.
                                // We need to re-specify it if we subsequently
                                // draw unclipped text
                                //**********************************************

                                LocalClipResetFlag=1;


                                width = cxGlyph;
                                height= cyGlyph;
                                SizeInWidth = (width + 31) & 0xffe0;
                                NumBytesPerScan = (width+7) >> 3;   // Divide by 8
                                NumDwords = (width + 31) >> 5;      // Divide by 32

                                //**********************************************
                                // As far as I can tell, the beginning of the
                                // glyph (according to the GLYPHBITS structure)
                                // appears to always start on a DWORD boundary.
                                // In addition, the DDK specifies that the bits
                                // will always be DWORD padded at the end.
                                // So let's just deal with DWORDS for performance.
                                // Otherwise, use the slow byte-by-byte routine.
                                //**********************************************

                                //**********************************************
                                // Calculate total number of DWORDS NV engine expects
                                // to receive for this glyph.  Add 3 so that
                                // 1->4 bytes means 1 dword, 5-8 bytes means 2 dwords..etc..
                                //**********************************************

                                NumDwordsPerGlyph = ((NumBytesPerScan*height)+3) >> 2; // Divide by 4

                                //**********************************************
                                // Specify SizeInWidth as multiple of 8 since
                                // the incoming glyph data is always row ordered
                                // and BYTE packed. We will always output up to a
                                // BYTE boundary. The excess pixels will get clipped
                                // according to the width we specify in Size.
                                // 'SizeIn' corresponds to the amount of data
                                // that the NV Engine expects to receive, and it
                                // specifies how the data will be layed out on the
                                // screen.. 'Size' just corresponds to the clipping
                                // rectangle. Add 7 so that 1->8 means 8, 9-16 means 16, etc...
                                //**********************************************

                                SizeInWidth = (width + 7) & 0xfff8;

                                //**********************************************
                                // Set the ALPHA bits to make the color visible.
                                // Clear the ALPHA bits to make the color transparent.
                                // 8bpp is in  X16A8Y8 format
                                // 16bpp is in A1R5G5B5 format
                                // 32bpp is in A8R8G8B8 format
                                //**********************************************

                                while (FreeCount < 4*4)
                                   FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
                                FreeCount -= 4*4;

                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color1D = Color1;
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeInD = ( (height <<16) | SizeInWidth );
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.SizeOutD = ( (height <<16) | width );
                                nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.PointD =  ( ((ptlOrigin.y) <<16) | ((ptlOrigin.x) & 0xffff) );

                                //**********************************************
                                // Get pointer to monochrome bitmap
                                //**********************************************

                                myGlyph = (DWORD *)pjGlyph;

                                //**********************************************
                                // Check if Bitmap pointer is DWORD aligned
                                //**********************************************

                                ASSERTDD( (((ULONG_PTR)pjGlyph & 3) == 0), "NOT dword aligned !!!");

                                //**********************************************
                                // Blast out the data as fast as possible
                                // in assembly routine
                                //**********************************************

// IA64 Assembly is NOT feasible under IA64
#ifndef _WIN64
                                NV3_Transfer_Text_Data(NumDwordsPerGlyph,&FreeCount,&myGlyph[0],nv);
#endif

                                }  // cx=xright-xleft

                            } // clipped glyph

                        if (--cGlyph == 0)
                            break;

                        //******************************************************
                        // Get ready for next glyph:
                        //******************************************************

                        pgp++;
                        pgb = pgp->pgdf->pgb;

                        if (ulCharInc == 0)
                            {
                            ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                            ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
                            }
                        else
                            {
                            ptlOrigin.x += ulCharInc;
                            }

                        }  // while TRUE...

                    } // For prclClip...

                } while (bMore);  // do while loop

            } // if (cglyphoriginal)...

        } while (bMoreGlyphs); // main do while loop

    //**************************************************************************
    // Make sure to update the global cached free count
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    }



//******************************************************************************
//
// Function: NV3TextOut()
//
// Routine Description:
//
//   Outputs text using the 'buffer expansion' method.  The CPU draws to a
//   1bpp buffer, and the result is colour-expanded to the screen using the
//   hardware.
//
//   Note that this is x86 only ('vFastText', which draws the glyphs to the
//   1bpp buffer, is writen in Asm).
//
//   If you're just getting your driver working, this is the fastest way to
//   bring up working accelerated text.  All you have to do is write the
//   'Xfer1bpp' function that's also used by the blt code.  This
//   'bBufferExpansion' routine shouldn't need to be modified at all.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//******************************************************************************


BOOL NV3TextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)

    {
    PDEV*           ppdev;
    BYTE            iDComplexity;
    RECTL           rclOpaque;

    Nv3ChannelPio   *nv;
    ULONG   x,y;
    ULONG   width,height;
    USHORT  FreeCount;
    ULONG   AlphaEnableValue;

    //*************************************************************************
    // Initialize NV specific pointers
    //*************************************************************************

    ppdev = (PDEV*) pso->dhpdev;
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    //*************************************************************************
    // Initialize NV specific registers
    //*************************************************************************

    nv = (Nv3ChannelPio *)ppdev->pjMmBase;

    //*************************************************************************
    // Get first FreeCount
    //*************************************************************************

    FreeCount = ppdev->NVFreeCount;

    //*************************************************************************
    // Determine the ALPHA_CHANNEL enable value
    //**************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;


    //*************************************************************************
    // Check if we need to draw the opaque rectangle first
    //*************************************************************************

    if (prclOpaque != NULL)
        {

        //**********************************************************************
        // Opaque Initialization - No clipping necessary
        //**********************************************************************

        while (FreeCount < 2*4)
             FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
        FreeCount -= 2*4;

        nv->subchannel[ROP_SOLID_SUBCHANNEL].nv3ContextRop.SetRop5 = NV_SRCCOPY ;
        nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.Color1A = AlphaEnableValue | pboOpaque->iSolidColor;


        if (iDComplexity == DC_TRIVIAL)
            {

DrawOpaqueRect:

            x = prclOpaque->left;
            y = prclOpaque->top;
            width = prclOpaque->right - prclOpaque->left;
            height = prclOpaque->bottom - prclOpaque->top;

            while (FreeCount < 2*4)
                FreeCount = nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].control.Free;
            FreeCount -= 2*4;

            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.UnclippedRectangle[0].point = ( ((x) << 16) | (y) );
            nv->subchannel[RECT_AND_TEXT_SUBCHANNEL].nv3GdiRectangleText.UnclippedRectangle[0].size = ( (width << 16) | height );

            }

        //**********************************************************************
        // Opaque Initialization - Check for single clipping rectangle
        //**********************************************************************

        else if (iDComplexity == DC_RECT)

            {
            if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
                {
                prclOpaque = &rclOpaque;
                goto DrawOpaqueRect;
                }
            }

        else

        //**********************************************************************
        // Opaque Initialization - Check for multiple rectangles to be drawn
        //**********************************************************************

            {
            //******************************************************************
            // WARNING: Make sure to update global freecount here first,because
            //          vClipSolid ALSO updates the FreeCount!
            //******************************************************************

            ppdev->NVFreeCount = FreeCount;

            vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);

            //******************************************************************
            // WARNING: Now make sure our local FreeCount has been updated
            //          because we'll use it below!
            //******************************************************************

            FreeCount = ppdev->NVFreeCount;

            }


        }

    //**************************************************************************
    // Make sure to update global freecount here first, because
    // NV1GeneralText relies on it being set correctly
    //**************************************************************************

    ppdev->NVFreeCount = FreeCount;

    NV3GeneralText(ppdev, pstro, pco, pboFore);

    return(TRUE);

    }

#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4pal.c ===
//******************************Module*Header***********************************
// 
// Module Name: NV4PAL.C
// 
// Copyright (c) 1992-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

#include "nvapi.h"


//******************************************************************************
// Extern declarations
//******************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );


//******************************************************************************
//
//  Function:   NV4DmaPushSetPalette
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID NV4DmaPushSetPalette(
PDEV* ppdev,
ULONG start,
ULONG length)
    {
    ULONG i;
    ULONG ulHead;

#if _WIN32_WINNT >= 0x0500

    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;

    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
	{
        ulHead = ppdev->ulDeviceDisplay[i];
#if (_WIN32_WINNT >= 0x0500) && defined(NVD3D) && !defined(_WIN64)

        if( (ppdev->pDriverData->vpp.dwOverlayFSNumSurfaces != 0))
        {
        // Disable pan & scan because Video is rendering on the head now.
            if(ppdev->pDriverData->vpp.dwOverlayFSHead == ulHead)
            {
                continue;
            }
        }
#endif
        ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_OFFSET(0), 0);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_FORMAT(0), NV046_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY);
        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);
        while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    }
    return;

#else
    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
	{
        ulHead = ppdev->ulDeviceDisplay[i];
        // setup LUT using Direct Method Call -- no notification needed
        if (
            NvDirectMethodCall(
                ppdev->hDriver,
                ppdev->hClient,
                ppdev->hDmaChannel,
                NV_VIDEO_LUT_CURSOR_DAC + ulHead,
                NV046_SET_LUT_OFFSET(0),
                0
            ) != NVOS1D_STATUS_SUCCESS
        )
        {
            DISPDBG((2, "NVDD: Cannot perform set LUT offset"));
        }
        if (
            NvDirectMethodCall(
                ppdev->hDriver,
                ppdev->hClient,
                ppdev->hDmaChannel,
                NV_VIDEO_LUT_CURSOR_DAC + ulHead,
                NV046_SET_LUT_FORMAT(0),
                0                                   // don't need notification w/DMC
            ) != NVOS1D_STATUS_SUCCESS
        )
        {
            DISPDBG((2, "NVDD: Cannot perform set LUT format"));
        }
    } //for each head
    return;
        
#endif // _WIN32_WINNT >= 0x0500

    }


/******************************Public*Routine******************************\
* ULONG nvSetGammaRamp
\**************************************************************************/
BOOL nvSetHeadGammaRamp(PDEV *ppdev, ULONG ulHead, PUSHORT fpRampVals)
{
    ULONG i, ulOffset;
    ULONG ulNumEntries = 256;

    DECLARE_DMA_FIFO;

    if (!ppdev) return(FALSE);

    if(ppdev->iBitmapFormat != BMF_8BPP)
    {
        ulOffset = ulHead*256;

        for (i = 0; i < ulNumEntries; i++) 
        {
            ppdev->ajClutData[i + ulOffset].Blue  = (UCHAR) (fpRampVals[512 + i] >> 8); /* blue value */
            ppdev->ajClutData[i + ulOffset].Green = (UCHAR) (fpRampVals[256 + i] >> 8); /* green value */
            ppdev->ajClutData[i + ulOffset].Red   = (UCHAR) (fpRampVals[i] >> 8); /* red value */
        }

        INIT_LOCAL_DMA_FIFO;

        ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
        NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_OFFSET(0), 0);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_FORMAT(0), NV046_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY);
        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);
        while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);

        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}



/******************************Public*Routine******************************\
* ULONG nvSetGammaRamp
\**************************************************************************/
BOOL nvGetHeadGammaRamp(PDEV *ppdev, ULONG ulHead, PUSHORT fpRampVals)
{
    ULONG i, ulOffset;
    ULONG ulNumEntries = 256;

    DECLARE_DMA_FIFO;

    if (!ppdev) return(FALSE);

    if(ppdev->iBitmapFormat != BMF_8BPP)
    {
        ulOffset = ulHead*256;

        for (i = 0; i < ulNumEntries; i++) 
        {
            fpRampVals[512 + i] = ((USHORT)ppdev->ajClutData[i + ulOffset].Blue << 8); // blue value
            fpRampVals[256 + i] = ((USHORT)ppdev->ajClutData[i + ulOffset].Green << 8);// green value
            fpRampVals[i]       = ((USHORT)ppdev->ajClutData[i + ulOffset].Red << 8);  // red value
        }
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4linto.c ===
//*****************************Module*Header************************************
// 
// Module Name: NV4LINTO.C
// 
// DrvLineTo for NV driver
// 
// Copyright (c) 1995-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "nv32.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

//*****************************************************************************
// Externs
//*****************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

// The our hardware clipping coordinates are limited to 16-bit signed values:



/******************************Public*Routine******************************\
* VOID vLineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line.
*
\**************************************************************************/

VOID vLineToTrivial(
PDEV*       ppdev,
LONG        x1,              // Passed in x1
LONG        y1,              // Passed in y1
LONG        x2,             // Passed in x2
LONG        y2,             // Passed in y2
ULONG       iSolidColor,
MIX         mix)
{
    ULONG       Rop3;
    
    DECLARE_DMA_FIFO;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************
    
    INIT_LOCAL_DMA_FIFO;
    
    NV_DMAPUSH_CHECKFREE(( (ULONG) (11) ));  

    if(ppdev->dDrawSpareSubchannelObject != DD_IMAGE_ROP_AND_LIN)
        {
        NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NVFFF_SET_OBJECT(0), DD_IMAGE_ROP_AND_LIN);
        ppdev->dDrawSpareSubchannelObject     = DD_IMAGE_ROP_AND_LIN;
        }

    //**************************************************************
    // Reset clipping rectangle to full screen extents if necessary
    // Resetting the clipping rectangle causes delays so we want to
    // do it as little as possible!
    //**************************************************************
    
                              
    Rop3 = (mix & 0x0f) - 1;
    Rop3 |= (Rop3 << 4);
    
    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , Rop3);

    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_COLOR, iSolidColor);

    NV_DMAPUSH_START( 4, SOLID_LIN_SUBCHANNEL, NV05C_LIN32(0));
    NV_DMA_FIFO = x1;
    NV_DMA_FIFO = y1;
    NV_DMA_FIFO = x2;
    NV_DMA_FIFO = y2;
    
    //******************************************************************
    // Update global push buffer count
    //******************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //******************************************************************
    // Send data on thru to the DMA push buffer
    //******************************************************************

    NV4_DmaPushSend(ppdev);
    
    return;
}



//*****************************************************************************
//
//  Function:   NV4DmaPushLineTo
//
//  Routine Description:
//
//          Draws a single solid integer-only cosmetic line.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//*****************************************************************************


BOOL NV4DmaPushLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)

    {
    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    PuntPtr;
    
    PDEV*       ppdev;
    DSURF*      pdsurf;
    ULONG       *DstBits;
    ULONG       *ScreenBitmap;
    RECTL*      prclClip;
    ULONG       ulHeight, ulWidth;
    BOOL        bMore;
    CLIPENUM    ce;
    LONG        c;

    
    DECLARE_DMA_FIFO;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    //**************************************************************************
    // Get ptr to physical device.  We should never get a null surface object
    //**************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    INIT_LOCAL_DMA_FIFO;
    
    //**************************************************************************
    // Default to the original surface object passed in to us
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // This 'punt' surface object is used only if we need to use GDI to
    // draw to an offscreen DFB.  Since the primary surface is already
    // a GDI-managed surface, we can kick back any line drawn to the screen.
    //**************************************************************************

    PuntPtr = ppdev->psoPunt;

    //**************************************************************************
    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:
    //**************************************************************************

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf !=0)
        {

        //**********************************************************************
        // Pass the surface off to GDI if it's a device bitmap that we've
        // converted to a DIB:
        //**********************************************************************

        if (pdsurf->dt == DT_DIB)
            {
            //******************************************************************
            // NOTE: We use pdsurf->pso, NOT just pso, because this is
            //       a DFB that exists in system memory.
            //******************************************************************
            ppdev->pfnWaitEngineBusy(ppdev);
            return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix));

            }
        }

    //*************************************************************************
    // Only handle line drawing to VRAM.  Send lines drawn
    // to system memory back to GDI.
    //*************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

    if ((pdsurf == 0) && (DstBits != ScreenBitmap))
        goto DMAPUSH_GDI_EngLineToIt;

    //**************************************************************************
    // Get push buffer information    
    //**************************************************************************

    ulHeight = prclBounds->bottom - prclBounds->top;
    ulWidth = prclBounds->right - prclBounds->left;
    
    if ((prclBounds->left   < MIN_INTEGER_BOUND) ||
        (prclBounds->top    < MIN_INTEGER_BOUND) ||
        (ulHeight           > MAX_INTEGER_BOUND) ||
        (ulWidth            > MAX_INTEGER_BOUND))
        {
        goto DMAPUSH_GDI_EngLineToIt;
        }
    if (pco == NULL)
        {
        if (ppdev->NVClipResetFlag)
            {
            NV_DMAPUSH_CHECKFREE(( (ULONG) (3) ));  
            NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
            NV_DMA_FIFO = 0;
            NV_DMA_FIFO = ppdev->dwMaxClip; 
            ppdev->NVClipResetFlag=0;       // Clipping rectangle has been reset
            }
        
        UPDATE_PDEV_DMA_COUNT;
        vLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix);
        
        return(TRUE);
        }
    else if (pco->iDComplexity <= DC_RECT) 
        {
        prclClip = &pco->rclBounds;
        ulHeight = prclClip->bottom - prclClip->top;
        ulWidth = prclClip->right - prclClip->left;

        NV_DMAPUSH_CHECKFREE(( (ULONG) (3) ));  
        NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
        NV_DMA_FIFO = (( prclClip->top << 16) |  prclClip->left);
        NV_DMA_FIFO = (( ulHeight << 16) | ulWidth ); 
        UPDATE_PDEV_DMA_COUNT;

        vLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix);

        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset

        return(TRUE);
        }
    else if (pco->iDComplexity == DC_COMPLEX) 
        {
        //**********************************************************
        // Clip region must be enumerated
        //**********************************************************
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do  {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

            c = cIntersect(prclBounds, ce.arcl, ce.c);

            prclClip = ce.arcl;
            while (c--)
                {
                ulHeight = prclClip->bottom - prclClip->top;
                ulWidth = prclClip->right - prclClip->left;

                NV_DMAPUSH_CHECKFREE(( (ULONG) (3) ));  
                NV_DMAPUSH_START(2, CLIP_SUBCHANNEL, NV019_SET_POINT);
                NV_DMA_FIFO = (( prclClip->top << 16) |  prclClip->left);
                NV_DMA_FIFO = (( ulHeight << 16) | ulWidth ); 
                UPDATE_PDEV_DMA_COUNT;

                vLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix);
                INIT_LOCAL_DMA_FIFO;
                prclClip++;
                }
            } while (bMore);

        ppdev->NVClipResetFlag=1;       // Clipping rectangle has been reset
        return(TRUE);

        }
DMAPUSH_GDI_EngLineToIt:

    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************
    if (pdsurf !=0 )
        {
        PuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurf->dt == DT_SCREEN)
            {
            PuntPtr->sizlBitmap  = pdsurf->sizl;

            //*************************************************************
            // Set linear offset and stride for source and destination buffers
            //*************************************************************

            PuntPtr->cjBits  = pdsurf->LinearStride * pdsurf->sizl.cy;
            PuntPtr->pvBits  = pdsurf->LinearPtr;
            PuntPtr->pvScan0 = pdsurf->LinearPtr;
            PuntPtr->lDelta  = pdsurf->LinearStride;

            PuntPtr->iBitmapFormat = ppdev->iBitmapFormat;

            }
        else
            {
            //*************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //*************************************************************
            PuntPtr->sizlBitmap  = pdsurf->pso->sizlBitmap;
            PuntPtr->cjBits      = pdsurf->pso->lDelta * pdsurf->pso->sizlBitmap.cy;
            PuntPtr->pvBits  = pdsurf->pso->pvBits;
            PuntPtr->pvScan0 = pdsurf->pso->pvScan0;
            PuntPtr->lDelta  = pdsurf->pso->lDelta;
            PuntPtr->iBitmapFormat = pdsurf->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempDstSurfObjPtr       = PuntPtr;
        }
        
    ppdev->pfnWaitEngineBusy(ppdev);
    return(EngLineTo(TempDstSurfObjPtr, pco, pbo, x1, y1, x2, y2, prclBounds, mix));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4ddrw.c ===
//******************************************************************************
//
// Module Name:
//
//     NV4DDRW.C
//
// Abstract:
//
//     Implements all NV4 specific routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "nv32.h"
#include "driver.h"

#include "nv4_ref.h"
#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// We'll add the 565 bitmap format functions here
// (We'll use the NV3 functions for 555 format)
//******************************************************************************

#define MASK_OUT_OTHER_CHANNELS         0xFFFFFFFE
#define OFFSET_NV_PFIFO_BASE            (0x2000)
#define OFFSET_NV_PFIFO_DMA_REG         (0x2508-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PUSH1    (0x3204-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_STATUS   (0x3214-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_PUSH (0x3220-OFFSET_NV_PFIFO_BASE)
#define CACHE1_DMA_PUSH_BUFFER_EMPTY    0x100
#define CACHE1_PUSH1_MODE_DMA           0x100
#define CACHE1_STATUS_LOW_MARK_EMPTY    0x010

#define OFFSET_NV_PGRAPH_DEBUG_3                     (0x0040008C - 0x00400000)
#define POSTDITHER_2D_ENABLE                          0x00001000
#define PREDITHER_2D_ENABLE                           0x00004000

//
//#define OFFSET_PRMCIO_INP0_COLOR_REG                0x3da
//
//#define OFFSET_PRMCIO_CRX__COLOR_REG                0x3d4
//#define OFFSET_PRMCIO_CR__COLOR_REG                 0x3d5
//
//#define OFFSET_PRMVIO_SRX_REG                       0x3c4
//#define OFFSET_PRMVIO_SR_LOCK_REG                   0x3c5
//#define OFFSET_PRMVIO_MISC_READ_REG                 0x3cc
//#define OFFSET_PRAMDAC_CU_START_POS_REG             0x0
//
//#define NV_SR_UNLOCK_VALUE                          0x00000057
//#define NV_SR_LOCK_VALUE                            0x00000099
//


//******************************************************************************
// Forward Declarations
//******************************************************************************

ULONG NV4_VBlankIsActive(PDEV *);
ULONG NV4_DisplayIsActive(PDEV *);
ULONG NV4_GraphicsEngineBusy(PDEV *);
VOID NV4_WaitWhileVBlankActive(PDEV * );
VOID NV4_WaitWhileDisplayActive(PDEV * );
VOID NV4_SetDestBase(PDEV*   ppdev, ULONG Offset, LONG Stride);
VOID NV4_DmaPushSend(PDEV *);
VOID MagicDelay ();

//******************************************************************************
// External Declarations
//******************************************************************************

extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

//******************************************************************************
//
// Function: NV4_VBlankIsActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV4_VBlankIsActive(PDEV*   ppdev)

    {
    //**************************************************************************
    // Get VBLANK status
    //**************************************************************************
    if (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK))
        return(TRUE);
    return(FALSE);

    }


//******************************************************************************
//
// Function: NV4_DisplayIsActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV4_DisplayIsActive(PDEV*   ppdev)

    {
    //**************************************************************************
    // Get DISPLAY status
    //**************************************************************************
    if (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK))
        return(FALSE);
    return(TRUE);
    }

#pragma optimize("",off)    // Need this so we only do ULONG reads from the hw

//******************************************************************************
//
// Function: NV4_ChannelIsGdi()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

ULONG NV4_ChannelIsGdi(PDEV *ppdev)

    {
    volatile ULONG  *pfifoDmaReg;
    volatile ULONG  regValue;

    pfifoDmaReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_DMA_REG);

    regValue = READ_REGISTER_ULONG(pfifoDmaReg);
    if ((regValue & MASK_OUT_OTHER_CHANNELS) == 0) // if its GDI return TRUE
        {
        return(1); // GDI channel
        }

    return(0); // not GDI channel
    }

//******************************************************************************
//
// Function: NV4_WaitForChannelSwitch()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_WaitForChannelSwitch(PDEV*   ppdev)

    {
    volatile ULONG  *pfifoDmaReg;
    volatile ULONG  *pfifoCache1Push1;
    volatile ULONG  *pfifoCache1Status;
    volatile ULONG  *pfifoCache1DmaPush;
    volatile ULONG  *GrStatusReg;
    volatile ULONG  regValue;

    if (!ppdev->PFIFORegs)
        {
        ppdev->oglLastChannel = GDI_CHANNEL_ID;
        return;
        }

    if (ppdev->oglLastChannel == GDI_CHANNEL_ID)
        {
        return;
        }
    
    pfifoDmaReg        = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_DMA_REG);
    pfifoCache1Push1   = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PUSH1);
    pfifoCache1Status  = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_STATUS);
    pfifoCache1DmaPush = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_PUSH);

    //
    // Wait for all DMA push channels to be not busy.
    // TODO: wait on DirectDraw PIO channel...
    // TODO: in these loops we should not just hammer the bus, we should probably do a sleep...
    //
    regValue = READ_REGISTER_ULONG(pfifoDmaReg);
    // Assume that GDI is channel 0 and wait for all other channels to go to 0 (not active)
    while (regValue)
        {
        MagicDelay ();
        regValue = READ_REGISTER_ULONG(pfifoDmaReg);
        }

    //
    // If its not the GDI channel then wait for DMA push to complete in FIFO
    //
    regValue = READ_REGISTER_ULONG(pfifoCache1Push1);
    if ((regValue & CACHE1_PUSH1_MODE_DMA) && ((regValue & 0x1F) != GDI_CHANNEL_ID))
        {
        regValue = READ_REGISTER_ULONG(pfifoCache1DmaPush);
        while ((regValue & CACHE1_DMA_PUSH_BUFFER_EMPTY) == 0)
            {
            MagicDelay ();
            regValue = READ_REGISTER_ULONG(pfifoCache1DmaPush);
            }
        regValue = READ_REGISTER_ULONG(pfifoCache1Status);
        while ((regValue & CACHE1_STATUS_LOW_MARK_EMPTY) == 0)
            {
            MagicDelay ();
            regValue = READ_REGISTER_ULONG(pfifoCache1Status);
            }
        }

    GrStatusReg = ppdev->GrStatusReg;

    while (*GrStatusReg)
        {
        MagicDelay ();
        }

    // On NV15 there is a one cycle bubble between the fifo and the gfx
    // engine where the status register may indicate idle.  Reading it
    // twice ensures that we won't hit the bubble.
    while (*GrStatusReg)
        {
        MagicDelay ();
        }

    return;
    }
#pragma optimize("",on)


//******************************************************************************
//
// Function: NV4_GraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV4_GraphicsEngineBusy(PDEV*   ppdev)

    {
    volatile ULONG  *pfifoDmaReg;
    ULONG           intr;

    if (ppdev == NULL)
        return FALSE;

    pfifoDmaReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_DMA_REG);

    //
    // Return DMA push register status
    // FIXME: TODO check DirectDraw PIO channel...
    //

    intr = READ_REGISTER_ULONG(pfifoDmaReg);
    if  (intr)
        return(TRUE);
    else
        return(FALSE);
    }


//******************************************************************************
//
// Function: NV4_WaitWhileVBlankActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_WaitWhileVBlankActive(PDEV*   ppdev)

    {
    while (NV4_VBlankIsActive(ppdev))
        MagicDelay();
    }

//******************************************************************************
//
// Function: NV3_WaitWhileDisplayActive()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_WaitWhileDisplayActive(PDEV*   ppdev)

    {
    while (NV4_DisplayIsActive(ppdev))
        MagicDelay();
    }


//******************************************************************************
//
// Function: NV4_WaitWhileGraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_WaitWhileGraphicsEngineBusy(PDEV*   ppdev)

    {
    if (ppdev == NULL)
        return;

    NV4_WaitForChannelSwitch(ppdev);

    ppdev->NVFreeCount = 0;

    }


//******************************************************************************
//
// Function: NV4_DmaPushWaitForChannelSwitch()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


VOID NV4_DmaPushWaitForChannelSwitch(PDEV*   ppdev)

    {

    if (ppdev == NULL)
        return;

    NV4_WaitForChannelSwitch(ppdev);

    return;
    }

//******************************************************************************
//
// Function: NV4_DmaPushGraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************


ULONG NV4_DmaPushGraphicsEngineBusy(PDEV*   ppdev)

    {
    volatile ULONG *GrStatusReg;

// TODO: Update this code for NV4 !!

    //**************************************************************************
    // It's possible that the device may have been disabled, and this function
    // still gets called (when pjmmbase == NULL). So make sure we don't
    // try to access the user channel if it doesn't exist!
    //**************************************************************************

    //**************************************************************************
    // Get pointer to graphics status register
    //**************************************************************************

    GrStatusReg = ppdev->GrStatusReg;

    //**************************************************************************
    // Wait for graphics engine to to finish
    //
    // WARNING: The compiler will generate code that reads the
    //          bottom BYTE of the CONFIG0 REG. We need to be
    //          aware of this in case we need to use registers
    //          which REQUIRE entire DWORD reads. To make sure we read
    //          an ENTIRE Dword, we can set a bit in the highest
    //          byte. This will force a DWORD read.  Also, we
    //          know that Bit 31 will ALWAYS be 0 for PFB_CONFIG_0
    //          register. So, no harm done. As always, check the LISTING !!
    //**************************************************************************

    if  (*GrStatusReg)  //& (NV_PGRAPH_STATUS_STATE_BUSY | 0x80000000))
        return(TRUE);
    else
        return(FALSE);
    }

 
//******************************************************************************
//
// Function: NV4_DmaPushWaitWhileGraphicsEngineBusy()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV4_DmaPushWaitWhileGraphicsEngineBusy(PDEV*   ppdev)

    {
    DECLARE_DMA_FIFO;

    // HW is not intialized yet.
    if((ppdev == NULL) || (!ppdev->bEnabled) || (ppdev->NVSignature != NV_SIGNATURE))
        return;

    //**************************************************************************
    // MAKE SURE that the RM is done updating the palette registers
    // before we start freeing the contexts associated with the colormap object
    // (Make sure the 2nd notifier array entry (index 1) is zero)
    // See NV4DmaPushSetPalette for more information
    //**************************************************************************
    if (ppdev->iBitmapFormat == BMF_8BPP)
        while ( (volatile)(((NvNotification *) (&(ppdev->Notifiers->DmaToMem[NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY*sizeof(NvNotification)])))->status) != NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS );

    //*************************************************************************************************************************
    // Here is the sequence of opearations we do to ensure we syncronize correctly with other channels and the graphics engines.
    // what we will do.
    // 1.   Do a channelswitch to make sure GDI is the current channel.
    // 2.   Do a notifier to make sure the GDI channel's pushbuffer and hardware FIFO is empty and that the graphics engine
    //      is idle.
    // 3.   Read the Graphics status register to make sure the graphics engine is idle. This third step is not really
    //      necessary as the notifier should guarantee us that the graphics engine is idle but it should not hurt.
    // 4.   Finally, Set the CachedGet Pointer to be equal to the CachedPut pointer as the pushbuffer is guaranteed to be
    //      empty at this point.
    //*************************************************************************************************************************

    //**********************************
    // First do a channel switch to GDI
    //**********************************
    ppdev->pfnWaitForChannelSwitch(ppdev);

    //*********************************************************************************************************
    // Using the notifier method is the most guaranteed way of making sure our channel has finished rendering.
    // We use a notifier to make sure the
    // engine is no longer busy. We'll just send a NO-OP (using the
    // RECT_AND_TEXT object) and wait for the notifier to complete.
    //*********************************************************************************************************
    INIT_LOCAL_DMA_FIFO;
    if (ppdev->nvDmaFifo == NULL)
        return;
    ((NvNotification *) (ppdev->Notifiers->DmaToMem))->status = NV04A_NOTIFICATION_STATUS_IN_PROGRESS;

    //**************************************************************************
    // Check if we've got enough room in the push buffer
    //**************************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(4)));

    //**************************************************************************
    // Send the NO-OP on thru
    //**************************************************************************
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL,  NV04A_NOTIFY       , NV04A_NOTIFY_WRITE_ONLY);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL,  NV04A_NO_OPERATION , 0x00000000);

    //**************************************************************************
    // Kickoff the DMA push operation immediately
    // Make sure to update the DMA put pointer first
    //**************************************************************************
    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);

    //**************************************************************************
    // Wait for completion...
    //**************************************************************************
    while ( ((NvNotification *) (ppdev->Notifiers->DmaToMem))->status == NV04A_NOTIFICATION_STATUS_IN_PROGRESS);

    //*****************************************************************************************************************
    // Now read the graphics status register. This is strictly not necessary since we are using the notifier above, but
    // it should not hurt.
    //*****************************************************************************************************************
    while (NV4_DmaPushGraphicsEngineBusy(ppdev));

    //*************************************************************************************************
    // Now we know that our push buffer is empty. So set the Get pointer to be equal to the put pointer
    //*************************************************************************************************
    ppdev->nvDmaCachedGet = ppdev->nvDmaCachedPut;
}

 
//******************************************************************************
//
// Function: NV4_AcquireOglMutex
//
// Routine Description:
//
//     Acquire the mutex that keeps OpenGL off the hardware.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
VOID NV4_AcquireOglMutex(PDEV *ppdev)
{
}

//******************************************************************************
//
// Function: NV4_ReleaseOglMutex
//
// Routine Description:
//
//     Release the mutex that keeps OpenGL off the hardware.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

VOID NV4_ReleaseOglMutex(PDEV *ppdev)
{
}


//******************************************************************************
//
// Function: nvDDrawSynWithNvGdiDrv 
//
// Routine Description:
//     This funciton is called by nvDDraw to syn. rendering
//     
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
void __cdecl nvDDrawSynWithNvGdiDrv(PDEV*   ppdev)
{
    ppdev->pfnWaitEngineBusy(ppdev);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nv4textc.c ===
//******************************Module*Header***********************************
// 
// Module Name: NV4TEXTC.C
// 
// Copyright (c) 1992-1996 Microsoft Corporation
// 
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "nv32.h"
#include "driver.h"

#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"

//******************************************************************************
// We'll add the 565 bitmap format functions here 
// (We'll use the NV3 functions for 555 format)
//******************************************************************************


//******************************************************************************
// Extern declarations
//******************************************************************************

extern void NV4_DrawFastGlyphs (SURFOBJ*, STROBJ*, FONTOBJ*, RECTL*,
                                GLYPHPOS*, ULONG);
extern VOID vClipSolid(PDEV* ,LONG ,RECTL *,ULONG ,CLIPOBJ*);
extern RECTL grclMax;
extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );


//*****************************************************************************
//
// Function: NV4DmaPushTextOut()
//
// Routine Description:
//
//   Outputs text using the 'buffer expansion' method.  The CPU draws to a
//   1bpp buffer, and the result is colour-expanded to the screen using the
//   hardware.
//
//   Note that this is x86 only ('vFastText', which draws the glyphs to the
//   1bpp buffer, is writen in Asm).
//
//   If you're just getting your driver working, this is the fastest way to
//   bring up working accelerated text.  All you have to do is write the
//   'Xfer1bpp' function that's also used by the blt code.  This
//   'bBufferExpansion' routine shouldn't need to be modified at all.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//*****************************************************************************


BOOL NV4DmaPushTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)

    {
    PDEV*           ppdev;
    ULONG           cGlyphOriginal;
    BOOL            bMore;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgpOriginal;
    BYTE            iDComplexity;
    CLIPENUM        ce;
    RECTL           rclOpaque;

    RECTL*          prclClip;
    ULONG           Color1;

    ULONG           x,y;
    ULONG           width,height;
    ULONG           AlphaEnableValue;

    DECLARE_DMA_FIFO;
    
    //*************************************************************************
    // Initialize NV specific pointers
    //*************************************************************************

    ppdev = (PDEV*) pso->dhpdev;
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    //*************************************************************************
    // Get push buffer information    
    //*************************************************************************

    INIT_LOCAL_DMA_FIFO;

    //*************************************************************************
    // Determine the ALPHA_CHANNEL enable value
    //*************************************************************************

    AlphaEnableValue = ppdev->AlphaEnableValue;

    //*************************************************************************
    // Make sure ROP is correct.
    // NOTE: needed below in case there is no rectangle.
    //*************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(6)));  

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5 , NV_SRCCOPY);

    //*************************************************************************
    // Check if we need to draw the opaque rectangle first
    //*************************************************************************

    if (prclOpaque != NULL)
        {

        //*********************************************************************
        // Opaque Initialization - No clipping necessary
        //*********************************************************************

        if (iDComplexity == DC_TRIVIAL)
            {

DrawOpaqueRect:

            x = prclOpaque->left;
            y = prclOpaque->top;
            width = prclOpaque->right - x;
            height = prclOpaque->bottom - y;

            NV_DMAPUSH_START (3, RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_A);

            NV_DMA_FIFO = (AlphaEnableValue | pboOpaque->iSolidColor);
            NV_DMA_FIFO = (x << 16) | y;
            NV_DMA_FIFO = (width << (16) | height);
            }

        //*********************************************************************
        // Opaque Initialization - Check for single clipping rectangle
        //*********************************************************************

        else if (iDComplexity == DC_RECT)
            {
            if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
                {
                prclOpaque = &rclOpaque;
                goto DrawOpaqueRect;
                }
            }

        //*********************************************************************
        // Opaque Initialization - Check for multiple rectangles to be drawn
        //*********************************************************************

        else
            {
            //*****************************************************************
            // WARNING: Make sure to update the global push buffer count here
            //          first, because vClipSolid ALSO updates the buffer Count
            //*****************************************************************


            UPDATE_PDEV_DMA_COUNT;
            vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);

            //*****************************************************************
            // WARNING: Now make sure our local DMA Count has been updated
            //          because we'll use it below!
            //*****************************************************************

            UPDATE_LOCAL_DMA_COUNT;
            }
        }    // if (prclOpaque != NULL)

//*****************************************************************************
//
//      Handles any strings that need to be clipped.
//
//*****************************************************************************

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    //*************************************************************************
    // Since we are using Class D of the monster text class, we don't
    // have to specify color 0 (It's always transparent)
    // We only need to get and specify the color for the '1' bits.
    //
    // NV4: Class D is now gone in NV4, but we can simulate it by
    //      using Class C and Class E.  Just use Class C but send
    //      SizeIn, SizeOut, and Point to Class E.
    //*************************************************************************

    Color1 = pboFore->iSolidColor | AlphaEnableValue; // Visible

    //*************************************************************************
    // NOTE: ROP set correctly above.
    //*************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(2))); 
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_COLOR1_C, Color1);

    do  {

        //*********************************************************************
        // pstro->pgp points to the GLYPHPOS array for the whole string.
        // If it is NONZERO, then enumeration is not needed.  There's
        // just one batch of glyphs
        //*********************************************************************

        if (pstro->pgp != NULL)
            {
            //*****************************************************************
            // There's only the one batch of glyphs, so save ourselves
            // a call:
            //
            // pgpOriginal   --> GLYPHPOS (contains glyph definition and src
            //                   origin
            // cGlyphOriginal -> Number of glyphs in the string object
            // bMoreGlyphs    -> Since there's only one batch, don't enumerate
            //*****************************************************************

            pgpOriginal    = pstro->pgp;
            cGlyphOriginal = pstro->cGlyphs;
            bMoreGlyphs    = FALSE;
            }
        else
            {
            //*****************************************************************
            // Get next batch of GLYPHPOS structures
            //*****************************************************************

            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
            }

        //*********************************************************************
        // Check if we have any glyphs to output
        //*********************************************************************

        if (cGlyphOriginal > 0)
            {
            //*****************************************************************
            // Simple clipping case - either none or rectangular
            //*****************************************************************

            if (iDComplexity != DC_COMPLEX)
                {
                //*************************************************************
                // grclMax essentially means to ignore clipping
                // Otherwise, use the bounds specified in the CLIP Object
                //*************************************************************
    
                if (iDComplexity == DC_TRIVIAL)
                    prclClip = &grclMax;
                else
                    prclClip = &pco->rclBounds;

                UPDATE_PDEV_DMA_COUNT;

                NV4_DrawFastGlyphs (pso,
                                    pstro,
                                    pfo,
                                    prclClip,
                                    pgpOriginal,
                                    cGlyphOriginal);
            
                NV4_DmaPushSend(ppdev);
                UPDATE_LOCAL_DMA_COUNT;
                }

            //*****************************************************************
            //
            // Complex clipping case
            //
            // pco           -> Clip Object
            // FALSE         -> only parts relevant to the current drawing
            //                  operation should be enumerated.  Otherwise,
            //                  the whole region should be enumerated (TRUE)
            // CT_RECTANGLES -> Region is to be enumerated as a list of
            //                  rectangles
            //*****************************************************************
    
            else
                {
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

            //*****************************************************************
            // Get the next clip rectangle to be enumerated from clip region.
            // (ce holds the clip rectangle)
            //*****************************************************************
    
                do  {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                //**************************************************************
                // Draw glyphs for each clipping rectangle
                //**************************************************************

                    for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
                        {
                            UPDATE_PDEV_DMA_COUNT;

                            NV4_DrawFastGlyphs (pso,
                                                pstro,
                                                pfo,
                                                prclClip,
                                                pgpOriginal,
                                                cGlyphOriginal);
                    
                            NV4_DmaPushSend(ppdev);
                            UPDATE_LOCAL_DMA_COUNT;

                        } // For prclClip...

                    } while (bMore);  // do while loop

                } // else (complex clipping case)

            } // if (cglyphoriginal)...
        
        } while (bMoreGlyphs); // main do while loop

    return (TRUE);

    }

#ifdef _WIN64
//*****************************************************************************
//
// Function: NV4_DrawFastGlyphs()
//
// Routine Description:
//
//   C version for IA64 bringup.
//
// Arguments:
//
// Return Value:
//
//     None.
//
//*****************************************************************************

#define MAX_MONO_DWORDS    128   // sizeof Color1C array in Nv04GdiRectangleText

void NV4_DrawFastGlyphs (
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
RECTL*    prclClip,
GLYPHPOS* pgpParm,
ULONG     glyphCount)
    {
    PDEV*           ppdev;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    POINTL          ptlOrigin;
    ULONG           ulCharInc;
    ULONG           height;
    ULONG           width;
    ULONG           widthByteAligned;
    ULONG           widthBytes;
    ULONG           widthDwords;
    ULONG           glyphDwordsTotal;
    ULONG           glyphDwordsIter;
    ULONG*          glyphData;
    ULONG           i, j;

    DECLARE_DMA_FIFO;
    
    //*************************************************************************
    // Initialize NV specific pointers
    //*************************************************************************

    ppdev = (PDEV*) pso->dhpdev;

    //*************************************************************************
    // Get push buffer information    
    //*************************************************************************

    INIT_LOCAL_DMA_FIFO;
    
    NV_DMAPUSH_CHECKFREE((ULONG)(6 + glyphCount));  

    NV_DMAPUSH_START (2, RECT_AND_TEXT_SUBCHANNEL, NV04A_CLIP_POINT0_C);
    NV_DMA_FIFO = (prclClip->top << 16)    | prclClip->left;
    NV_DMA_FIFO = (prclClip->bottom << 16) | prclClip->right;
    
    //*************************************************************************
    // Trivial rejection
    //*************************************************************************

    if ((prclClip->right  < pstro->rclBkGround.left) ||
        (prclClip->bottom < pstro->rclBkGround.top) ||
        (prclClip->left   > pstro->rclBkGround.right) ||
        (prclClip->top    > pstro->rclBkGround.bottom))
        {
            return;
        }
   
    ulCharInc = pstro->ulCharInc;

    for (i = 0, pgp = pgpParm;
         i < glyphCount;
         i++, pgp = (GLYPHPOS *)((BYTE *)pgp + sizeof(GLYPHPOS)))
        {
            pgb = pgp->pgdf->pgb;
            if ((ulCharInc == 0) || (i == 0))
                {
                ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
                ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;
                }
            else
                {
                ptlOrigin.x += ulCharInc;
                }
            //*****************************************************************
            // Eliminate beginning glyphs that are clipped on the left
            //*****************************************************************
            if ((ptlOrigin.x + pgb->sizlBitmap.cx) <= prclClip->left)
                continue;

            height = pgb->sizlBitmap.cy & 0xffff;            

            if ((height==0) ||
                (ptlOrigin.x > prclClip->right) ||
                (ptlOrigin.y > prclClip->bottom))
                {
                continue;
                }

            width = pgb->sizlBitmap.cx & 0xffff;

            widthByteAligned = (width + 7) & 0xfff8;
            widthBytes = widthByteAligned >> 3;
            glyphDwordsTotal = ((widthBytes * height) + 3) >> 2;
            
            NV_DMAPUSH_CHECKFREE((ULONG)(4));
    
            NV_DMAPUSH_START (3, RECT_AND_TEXT_SUBCHANNEL, NV04A_SIZE_IN_E);
            NV_DMA_FIFO = height << 16 | widthByteAligned;
            NV_DMA_FIFO = height << 16 | width;
            NV_DMA_FIFO = (ptlOrigin.y << 16) | (ptlOrigin.x & 0xffff);
    
            glyphData = (ULONG *)pgb->aj;

            do  {
                glyphDwordsIter = min(glyphDwordsTotal, MAX_MONO_DWORDS);

                NV_DMAPUSH_CHECKFREE((ULONG)(glyphDwordsIter + 1));

                NV_DMAPUSH_START(glyphDwordsIter,
                                 RECT_AND_TEXT_SUBCHANNEL,
                                 NV04A_MONOCHROME_COLOR1_C(0));
                
                for (j = 0; j < glyphDwordsIter; j++)
                    {
                    NV_DMA_FIFO = *glyphData++;
                    }
                glyphDwordsTotal -= glyphDwordsIter;

                } while (glyphDwordsTotal > 0);
        }
    UPDATE_PDEV_DMA_COUNT;
    }
#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvosnt.h ===
// this file contains the display driver -to- miniport IOCTL codes
// and NvAlloc..() macros for the display driver client


typedef HANDLE NVDESCRIPTOR;
#define NVOPEN_INVALID_DESCRIPTOR 0

#define Nv1GetDeviceOsName(fd, ps)              \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_GET_DEVICE_OS_NAME,    \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_GET_DEVICE_OS_NAME_STRUCT),  \
        &cbReturned                             \
    );                                          \
}                                               

#define Nv1AllocContextDma(fd, ps)              \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_ALLOC_CONTEXT_DMA,     \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_ALLOC_CONTEXT_DMA_STRUCT),   \
        &cbReturned                             \
    );                                          \
}                                               

#define Nv1FreeContextDma(fd, ps)               \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_FREE_CONTEXT_DMA,      \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_FREE_CONTEXT_DMA_STRUCT),    \
        &cbReturned                             \
    );                                          \
}

#define Nv3AllocChannelPio(fd, ps)              \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_ALLOC_CHANNEL_PIO,     \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV3_ALLOC_CHANNEL_PIO_STRUCT),   \
        &cbReturned                             \
    );                                          \
}                                               

#define Nv3FreeChannelPio(fd, ps)               \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_FREE_CHANNEL_PIO,      \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV3_FREE_CHANNEL_PIO_STRUCT),    \
        &cbReturned                             \
    );                                          \
}

#define Nv3NtAllocChannelDma(fd, ps)              \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_ALLOC_CHANNEL_DMA,     \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NVOS07_PARAMETERS),   \
        &cbReturned                             \
    );                                          \
}                                               

#define Nv3FreeChannelDma(fd, ps)               \
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_FREE_CHANNEL_DMA,      \
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV3_FREE_CHANNEL_DMA_STRUCT),    \
        &cbReturned                             \
    );                                          \
}

#define Nv3NtDmaFlowControl(fd, ps)               		\
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV3_IOCTL_DMA_FLOW_CONTROL,      		\
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NVOS08_PARAMETERS),    		\
        &cbReturned                             \
    );                                          \
}

#define Nv1AllocMemory(fd, ps)               	\
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_ALLOC_MEMORY,      	\
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_ALLOC_MEMORY_STRUCT),    	\
        &cbReturned                             \
    );                                          \
}

#define Nv1FreeMemory(fd, ps)               	\
{                                               \
    DWORD cbReturned;                           \
    VOID *pps = ps;                             \
    EngDeviceIoControl(                         \
        (HANDLE)(fd),                           \
        (DWORD)NV1_IOCTL_FREE_MEMORY,      		\
        (&pps),                                 \
        sizeof(PVOID),                          \
        (ps),                                   \
        sizeof(NV1_FREE_MEMORY_STRUCT),    		\
        &cbReturned                             \
    );                                          \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvdoublebuf.h ===
#ifndef _NVDOUBLEBUF_H
#define _NVDOUBLEBUF_H
/**************************************************************************
** nvdoublebuf.h
**
** Export file for nvdoublebuf.c. Declare exported functions.
**
** Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
**
** FNicklisch 12.10.2000: New
**************************************************************************/

BOOL bDoublePumped(PPDEV ppdev, ULONG ulSurfaceOffset);
void NV_InitDoubleBufferMode(PDEV *ppdev, LONG NumBuffers, ULONG *MultiBufferOffsets);
void NV_DisableDoubleBufferMode(PPDEV  ppdev);
BOOL NV_AddDoubleBufferSurface(PPDEV ppdev, ULONG ulSurfaceOffset);
BOOL NV_RemoveDoubleBufferSurface(PPDEV ppdev, ULONG ulSurfaceOffset);
VOID NV_InitDoubleBufferSavedProcs(PPDEV ppdev);


#endif // _NVDOUBLEBUF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvhw.c ===
//******************************************************************************
//
// Module Name:
//
//     NVHW.C
//
// Abstract:
//
//     Implements chip generic hardware routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"

//#include "oldnv332.h"
#include "driver.h"

#include "nv3a_ref.h"

#include "nvsubch.h"
#include "nvalpha.h"
#include "nvapi.h"
#include "nvcm.h"

#undef DEBUG_MSG_CHANNEL_WAIT

#define OFFSET_NV_PFIFO_BASE                        (0x2000)
#define OFFSET_NV_PFIFO_CACHE1_PUSH0_REG            (0x3200-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA0_REG             (0x3220-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_INTR_0                      (0x2100-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHES                      (0x2500-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PULL0                (0x3240-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PUSH1                (0x3204-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_STATUS               (0x3214-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CONFIG_0                    (0x2200-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PT_BASE      (0x3238-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_TAG          (0x3230-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_TLB_PTE          (0x3234-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA3                 (0x322C-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_STATUS           (0x3218-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA1                 (0x3224-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA2                 (0x3228-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA0                 (0x3220-OFFSET_NV_PFIFO_BASE)

#define OFFSET_PRMCIO_INP0_COLOR_REG                0x3da

#define OFFSET_PRMCIO_CRX__COLOR_REG                0x3d4
#define OFFSET_PRMCIO_CR__COLOR_REG                 0x3d5

#define OFFSET_PRMVIO_SRX_REG                       0x3c4
#define OFFSET_PRMVIO_SR_LOCK_REG                   0x3c5
#define OFFSET_PRMVIO_MISC_READ_REG                 0x3cc
#define OFFSET_PRAMDAC_CU_START_POS_REG             0x0

#define NV_SR_UNLOCK_VALUE                          0x00000057
#define NV_SR_LOCK_VALUE                            0x00000099

//******************************Public*Routine**********************************
//
// Function: NV_GetScanLineData
//
// Routine Description:
//
//             Return current display scanline.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     Current Scanline.
//
//******************************************************************************
ULONG NV_GetScanLineData(PDEV* ppdev) {
#ifdef NV3
    ULONG   Value, Value32;
    UCHAR   lock;

    //******************************************************************************
    // Make sure the extended CRTC registers are enabled
    //******************************************************************************

    (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SRX_REG] = NV_PRMVIO_SR_LOCK_INDEX;
    lock = (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SR_LOCK_REG];
    (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SR_LOCK_REG] =  NV_SR_UNLOCK_VALUE;

    //******************************************************************************
    // Get the scanline value.
    //******************************************************************************
    (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CRX__COLOR_REG] = NV_CIO_CRE_RL1__INDEX;
    Value = (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CR__COLOR_REG];
    Value <<= 8;
    (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CRX__COLOR_REG] = NV_CIO_CRE_RL0__INDEX;
    Value32 = (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CR__COLOR_REG] & 0xFF;
    Value |= Value32;
    Value &= 0x7FF;
    if (Value == 0)
    {
        //******************************************************************************
        // Double check to fix hw bug.
        //******************************************************************************
        (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CRX__COLOR_REG] = NV_CIO_CRE_RL1__INDEX;
        Value = (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CR__COLOR_REG];
        Value <<= 8;
        (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CRX__COLOR_REG] = NV_CIO_CRE_RL0__INDEX;
        Value32 = (BYTE) PRMCIO_Base[OFFSET_PRMCIO_CR__COLOR_REG] & 0xFF;
        Value |= Value32;
        Value &= 0x7FF;
    }

    //******************************************************************************
    // Restore the lock
    //******************************************************************************
    (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SRX_REG] = NV_PRMVIO_SR_LOCK_INDEX;
    if(lock != 0x01)    // unlock read-back value
    {
        (BYTE) PRMVIO_Base[OFFSET_PRMVIO_SR_LOCK_REG] = NV_SR_LOCK_VALUE;
    }

    return(Value);
#else
    return (((REG_RD32(NV_PCRTC_RASTER+(ppdev->ulDeviceDisplay[0]*0x2000)))>>
            DRF_SHIFT(NV_PCRTC_RASTER_POSITION))&DRF_MASK(NV_PCRTC_RASTER_POSITION));
#endif // NV#
}


//******************************Public*Routine**********************************
//
// Function: NV_WaitForOneVerticalRefresh
//
// Routine Description:
//
//           Palette writes
//           (using video colormap) get queued up and don't
//           actually get written until the next vertical blank.
//           Normally, we would wait on the video colormap buffer notifier
//           to make sure the palette writes are done, before resetting
//           the device (calling int 10h).  However notifiers for the video
//           colormap are currrently *not* functional.  So for now, we'll
//           wait for at least one vertical refresh to occur , to make sure
//           all the palette writes have completed.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     Current Scanline.
//
//******************************************************************************

VOID NV_WaitForOneVerticalRefresh(PDEV* ppdev)

    {
    ULONG   TotalScanLines;
    ULONG   PreviousScanLine, NextScanLine;

    TotalScanLines   = 0;

    //**************************************************************************
    // Get a 'starting' scanline
    //**************************************************************************

    PreviousScanLine = NV_GetScanLineData(ppdev);

    //**************************************************************************
    // The largest resolution (at least for the foreseeable future)
    // will be 2k x 2k.  So wait for 2000 vertical scanlines worth to occur.
    //**************************************************************************

    do
        {
        ULONG   Count=0;

        //**********************************************************************
        // Wait for scanline to advance
        //**********************************************************************

        do
            {
            NextScanLine = NV_GetScanLineData(ppdev);
            Count++;

            //******************************************************************
            // Safety Abort just in case
            //******************************************************************

            if (Count > 10000) goto abort_scan_loop;

            } while (NextScanLine == PreviousScanLine);


        //**********************************************************************
        // If the scan has wrapped, then just add the value of NextScanLine.
        // This is *not* an accurate algorithm but it will get the job done.
        //**********************************************************************

        if (NextScanLine < PreviousScanLine)
            {
            TotalScanLines+=NextScanLine;
            PreviousScanLine = NextScanLine;
            }

        else
            {
            TotalScanLines+=(NextScanLine-PreviousScanLine);
            PreviousScanLine = NextScanLine;
            }


        } while (TotalScanLines < 2000);


abort_scan_loop:

    return;
}





//******************************Public*Routine**********************************
//
// Function: NvHwSpecific
//
// Routine Description:
//
//      This functioin is specific to a Nv chip set to workaround HW problem.
//
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     Current Scanline.
//
//******************************************************************************

VOID NvHwSpecific(PDEV* ppdev)
{
    ULONG ulRetVal;

    // Looking for NV11 Rev. B chip
    NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_CFG_FLAT_PANEL_DITHER_MODE, &ulRetVal );
    if(ulRetVal & NV_CFG_FLAT_PANEL_DITHER_MODE_CAPABLE)
    {
        NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,    
                NV_CFG_FLAT_PANEL_DITHER_MODE, &ulRetVal );             
        if(ulRetVal & NV_CFG_FLAT_PANEL_DITHER_MODE_ENABLED)            
            ppdev->ulWorkAroundHwFlag |=  NV_WORKAROUND_NV11RevB_DIRTHERING;
        else
            ppdev->ulWorkAroundHwFlag &=  ~NV_WORKAROUND_NV11RevB_DIRTHERING;
    }

    // Other chips ...
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvapi.c ===
/******************************************************************************
*
*   Module:  nvapi.c
*
*   Description:
*       This module contains the functions that provide the NT display driver
*   access to the resource manager.
*
******************************************************************************/

#include "precomp.h"
#include <nv32.h>
#include <nvos.h>
#include <nvntioctl.h>
#include <nvapi.h>

HANDLE __cdecl NvOpen
(
    HANDLE hDriver
)
{
    DWORD status, cbReturned;

    // connect to the RM thru an IOCTL to the miniport
    status = EngDeviceIoControl(
        hDriver,
        (DWORD)NVAPI_IOCTL_OPEN,
        NULL,
        0,
        NULL,
        0,
        &cbReturned
    );

    return (status == 0) ? hDriver : NVARCH_INVALID_NVDESCRIPTOR;
}

VOID _cdecl NvClose
(
    HANDLE hDriver
)
{
    DWORD cbReturned;

    // disconnect from the RM thru an IOCTL to the miniport
    EngDeviceIoControl(
        hDriver,
        (DWORD)NVAPI_IOCTL_CLOSE,
        NULL,
        0,
        NULL,
        0,
        &cbReturned
    );
}

ULONG __cdecl NvAllocRoot
(
    HANDLE hDriver,
    ULONG  hClass,
    ULONG *phClient
)
{
    NVOS01_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClass            = hClass;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_ROOT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS01_PARAMETERS),
        &cbReturned
    );

    *phClient               = (ULONG)parms.hObjectNew;

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocDevice
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    NVOS06_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hObjectParent     = (NvV32)hClient;
    parms.hObjectNew        = (NvV32)hDevice;
    parms.hClass            = (NvV32)hClass;
    parms.szName            = (NvP64)szName;



    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_DEVICE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS06_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocContextDma
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    NVOS03_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hObjectParent      = (NvV32)hClient;
    parms.hObjectNew         = (NvV32)hDma;
    parms.hClass             = (NvV32)hClass;
    parms.flags              = (NvV32)flags;
    parms.pBase              = (NvP64)base;
    parms.limit              = (NvU64)limit;

    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_CONTEXT_DMA,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS03_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocChannelPio
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    NVOS04_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hDevice;
    parms.hObjectNew        = (NvV32)hChannel;
    parms.hClass            = (NvV32)hClass;
    parms.hObjectError      = (NvV32)hErrorCtx;
    parms.flags             = (NvV32)flags;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_CHANNEL_PIO,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS04_PARAMETERS),
        &cbReturned
    );

    *ppChannel = (PVOID)parms.pChannel;

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocChannelDma
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    NVOS07_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hDevice;
    parms.hObjectNew        = (NvV32)hChannel;
    parms.hClass            = (NvV32)hClass;
    parms.hObjectError      = (NvV32)hErrorCtx;
    parms.hObjectBuffer     = (NvV32)hDataCtx;
    parms.offset            = (NvU32)offset;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV03_ALLOC_CHANNEL_DMA,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS07_PARAMETERS),
        &cbReturned
    );

    *ppChannel = (PVOID)parms.pControl;

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocMemory
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    NVOS02_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    // set input parameters
    parms.hRoot                = (NvV32)hClient;
    parms.hObjectParent        = (NvV32)hParent;
    parms.hObjectNew           = (NvV32)hMemory;
    parms.hClass               = (NvV32)hClass;
    parms.flags                = (NvV32)flags;
    parms.pMemory              = (NvP64)*ppAddress;
    parms.pLimit               = (NvU64)*pLimit;

    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_MEMORY,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS02_PARAMETERS),
        &cbReturned
    );

    // retrieve output parameters
    *ppAddress = (PVOID)parms.pMemory;
    *pLimit    = (ULONG)parms.pLimit;

    return (ULONG)parms.status;

}

ULONG __cdecl NvAllocObject
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    NVOS05_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_OBJECT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS05_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}
ULONG __cdecl NvAllocEvent
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hParent,
    ULONG hObject,
    ULONG hClass,
    ULONG index,
#ifdef _WIN64
    PVOID hEvent
#else
    ULONG hEvent
#endif
)
{
    NVOS10_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;
    parms.index             = (NvV32)index;
    parms.hEvent            = (NvU64)hEvent;

    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ALLOC_EVENT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS10_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvAlloc
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass,
    PVOID pAllocParms
)
{
    NVOS21_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    // set input parameters
    parms.hRoot                    = (NvV32)hClient;
    parms.hObjectParent            = (NvV32)hChannel;
    parms.hObjectNew               = (NvV32)hObject;
    parms.hClass                   = (NvV32)hClass;
    parms.pAllocParms              = (NvP64)pAllocParms;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV04_ALLOC,
        &pParms,
        sizeof(PVOID),
        &parms,
        sizeof(NVOS21_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvFree
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    NVOS00_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectOld        = (NvV32)hObject;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_FREE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS00_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvGetDmaPushInfo
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG retArray,
    ULONG hDmaContext
)
{
    ULONG parms[5];
    PVOID pParms;
    DWORD cbReturned;

    parms[0] = (NvV32)hClient;
    parms[1] = (NvV32)hDevice;
    parms[2] = (NvU32)hChannel;
    parms[3] = (NvU32)retArray;
    parms[4] = (NvU32)hDmaContext;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV03_DMA_FLOW_CONTROL, // USING THIS TO GET TO RM
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(parms),
        &cbReturned
    );

    return (ULONG)parms[4];

}

ULONG __cdecl NvDmaFlowControl
(
    HANDLE hDriver,
    ULONG hChannel,
    ULONG flags,
    ULONG put,
    ULONG get
)
{
    NVOS08_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hChannel          = (NvV32)hChannel;
    parms.flags             = (NvV32)flags;
    parms.put               = (NvU32)put;
    parms.get               = (NvU32)get;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV03_DMA_FLOW_CONTROL,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS08_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;
}

ULONG __cdecl NvArchHeap
(
    HANDLE hDriver,
    PVOID  parms
)
{
    PVOID pParms;
    DWORD cbReturned;

    pParms = parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_ARCH_HEAP,
        (&pParms),
        sizeof(PVOID),
        parms,
        sizeof(NVOS11_PARAMETERS),
        &cbReturned
    );

    return ((NVOS11_PARAMETERS *)parms)->status;
}

/*
/*
ULONG NvDmaPushMutexState
(
    HANDLE hDriver,
    DWORD  mutexState
)
{
    NV3_DMA_PUSH_MUTEX_STATE_STRUCT parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.mutexState = (U032)mutexState;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)NVAPI_IOCTL_DMA_PUSH_MUTEX_STATE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NV3_DMA_PUSH_MUTEX_STATE_STRUCT),
        &cbReturned
    );

    return (ULONG)parms.nvStatus;

}
*/

ULONG __cdecl NvConfigVersion
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG *pVersion
)
{
    NVOS12_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_CONFIG_VERSION,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS12_PARAMETERS),
        &cbReturned
    );

    *pVersion = (ULONG)parms.version;

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigGet
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    NVOS13_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.index             = (NvV32)index;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_CONFIG_GET,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS13_PARAMETERS),
        &cbReturned
    );

    *pValue = (ULONG)parms.value;

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigSet
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    NVOS14_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.index             = (NvV32)index;
    parms.newValue          = (NvV32)newValue;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_CONFIG_SET,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS14_PARAMETERS),
        &cbReturned
    );

    *pOldValue = (ULONG)parms.oldValue;

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigGetEx
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    PVOID paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_GET_EX_PARAMS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.index             = (NvV32)index;
    parms.paramStructPtr    = (NvP64)paramStructPtr;
    parms.paramSize         = (NvU32)paramSize;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV04_CONFIG_GET_EX,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS_CONFIG_GET_EX_PARAMS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigSetEx
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    PVOID paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_SET_EX_PARAMS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.index             = (NvV32)index;
    parms.paramStructPtr    = (NvP64)paramStructPtr;
    parms.paramSize         = (NvU32)paramSize;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV04_CONFIG_SET_EX,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS_CONFIG_SET_EX_PARAMS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG __cdecl NvConfigUpdate
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hDevice,
    ULONG flags
)
{
    NVOS15_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hClient           = (NvV32)hClient;
    parms.hDevice           = (NvV32)hDevice;
    parms.flags             = (NvV32)flags;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_CONFIG_UPDATE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS15_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

ULONG NvRmDebugControl
(
    HANDLE hDriver,
    ULONG hRoot,
    ULONG command,
    PVOID pArgs
)
{
    NVOS20_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot              = (NvV32)hRoot;
    parms.command            = command;
    parms.pArgs              = (NvP64)((ULONG_PTR)hRoot);

    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV01_DEBUG_CONTROL,
        (&pParms),                      // input buffer
        sizeof(PVOID),                  // input buffer size
        (&parms),                       // output buffer
        sizeof(NVOS20_PARAMETERS),      // output buffer size
        &cbReturned
    );

    return (ULONG)parms.status;
}

ULONG __cdecl NvDirectMethodCall
(
    HANDLE hDriver,
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG method,
    ULONG data
)
{
    NVOS1D_PARAMETERS parms;
    PVOID pParms;
    DWORD cbReturned;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectOld        = (NvV32)hObject;
    parms.method            = (NvV32)method;
    parms.data              = (NvV32)data;
    pParms = &parms;

    EngDeviceIoControl(
        hDriver,
        (DWORD)IOCTL_NV04_DIRECT_METHOD_CALL,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS1D_PARAMETERS),
        &cbReturned
    );

    return (ULONG)parms.status;

}

// end of nvapi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvptr.c ===
//******************************Module*Header***********************************
//
// Module Name: NVPTR.C
//
// This module contains the hardware pointer support for the display
// driver.  Supports the following classes:
//          NV04_VIDEO_LUT_CURSOR_DAC
//          NV05_VIDEO_LUT_CURSOR_DAC
//          NV10_VIDEO_LUT_CURSOR_DAC
//          NV15_VIDEO_LUT_CURSOR_DAC
//
// Does not support NV3!!
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997-2000 NVidia Corporation. All Rights Reserved.          *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "ddminint.h"

#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif

#include "dmamacro.h"

#include "nvsubch.h"
#include "nvalpha.h"
#include "nvapi.h"
#include "nvcm.h"

#define WORK_AROUND_NV11_DIRTHER                                        \
{                                                                       \
    if(ppdev->ulWorkAroundHwFlag &  NV_WORKAROUND_NV11RevB_DIRTHERING)  \
    {                                                                   \
        return(SPS_DECLINE);                                            \
    }                                                                   \
}

#ifndef NV3

//*****************************************************************************
// Externs
//*****************************************************************************

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );

#define CURSOR_PIXEL_SIZE 4

#define DESKTOP_MOVING_RATE 20    

#define USE_CURSOR_REGISTER 1
#ifdef USE_CURSOR_REGISTER //[

/*
** 1/10/01 jbaldwin
** This direct register write gains ~2% performance on 2D Winbench 99 BG.  The
** PRAMDAC_CU_START_POS_Reg register is identical from NV3 thru NV20 so this
** direct register write bypassing the class interface isn't quite as bad as
** it would otherwise be.
*/
#define SET_CURSOR_LOCATION(ppdev, ulHead, x, y)                            \
{                                                                           \
    volatile ULONG * PRAMDAC_CU_START_POS_Reg;                              \
                                                                            \
    PRAMDAC_CU_START_POS_Reg = ppdev->PRAMDACRegs + ((ulHead) * 0x2000/4);  \
                                                                            \
    *PRAMDAC_CU_START_POS_Reg = (((x) & 0xffff) | ((y) << 16));             \
}

#else // USE_CURSOR_REGISTER ][

#define USE_DMC_CURSOR 1
// Send the new location directly to HW; new code
#if USE_DMC_CURSOR
#define SET_CURSOR_LOCATION(ppdev, ulHead, x, y)                            \
if (                                                                        \
    NvDirectMethodCall(                                                     \
        ppdev->hDriver,                                                     \
        ppdev->hClient,                                                     \
        ppdev->hDmaChannel,                                                 \
        NV_VIDEO_LUT_CURSOR_DAC+ulHead,                                     \
        NV046_SET_CURSOR_POINT,                                             \
        (x & 0xffff) | (y << 16)                                            \
    ) != NVOS1D_STATUS_SUCCESS                                              \
)                                                                           \
{                                                                           \
    DISPDBG((2, "NVDD: Cannot perform cursor move on %d head", ulHead));    \
}

#else
// Send the new location of cursor into DMA push buffer;  old code
// !!! This code has not been tested yet !!!
#define SET_CURSOR_LOCATION(ppdev, ulHead, x, y)                                                            \
{                                                                                                           \
    DECLARE_DMA_FIFO;                                                                                       \
    INIT_LOCAL_DMA_FIFO;                                                                                    \
    NV_DMAPUSH_CHECKFREE( ((ULONG)(4)));                                                                    \
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ulhead);   \
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_POINT, (x & 0xffff) | (y << 16) );        \
    UPDATE_PDEV_DMA_COUNT;                                                                                  \
    NV4_DmaPushSend(ppdev);                                                                                 \
}

#endif

#endif // USE_CURSOR_REGISTER ]

//******************************************************************************
//
//  Function:   NvAllocateCursorMem
//
//  Routine Description:
//          Allocating the memory for cursor
//      
//
//  Arguments:
//          ppdev - display driver structure
//          ulBufIndex - double buffer.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL NvAllocateCursorMem(PDEV* ppdev, ULONG ulBufIndex)
{
    if(!ppdev->ulCursorMemOffset[ulBufIndex])
    {
        NvU32 dwStatus;

        // Don't worry offset alignment because RM should take care TYPE_CURSOR
        NVHEAP_ALLOC(dwStatus, ppdev->ulCursorMemOffset[ulBufIndex],  ppdev->ulMaxHwCursorSize * ppdev->ulMaxHwCursorSize * CURSOR_PIXEL_SIZE, TYPE_CURSOR);

        if (dwStatus!=0)
        {
            DISPDBG((2, "NVEnablePointer: Cannot allocate cursor memory"));
            return (FALSE);
        }

        if(NvAllocContextDma(ppdev->hDriver,
                             ppdev->hClient,
                             NV_CONTEXT_DMA_CURSOR+ulBufIndex,
                             NV01_CONTEXT_DMA,
                             NVOS03_FLAGS_ACCESS_READ_WRITE,
                             (PVOID)(ppdev->pjFrameBufbase + ppdev->ulCursorMemOffset[ulBufIndex]),
                             ppdev->ulMaxHwCursorSize * ppdev->ulMaxHwCursorSize * CURSOR_PIXEL_SIZE - 1
                             ))
        {
            DISPDBG((1, "NVEnablePointer: Cannot allocate dma in memory context for cursor"));
            NVHEAP_FREE(ppdev->ulCursorMemOffset[ulBufIndex]);
            ppdev->ulCursorMemOffset[ulBufIndex] = 0;
            return (FALSE);
        }
    }
    return(TRUE);
}

//******************************************************************************
//
//  Function:   NvFreeCursorMem
//
//  Routine Description:
//         Free the cursor memory
//      
//
//  Arguments:
//          ppdev - display driver structure
//          ulBufIndex - double buffer.
//
//
//  Return Value:
//
//      None.
//
//******************************************************************************
void NvFreeCursorMem(PDEV* ppdev, ULONG ulBufIndex)
{

        if(ppdev->ulCursorMemOffset[ulBufIndex])
        {
            if (!(ppdev->flCaps & CAPS_SW_POINTER))
            {
                ppdev->pfnShowPointer(ppdev,FALSE);
                ppdev->pfnWaitEngineBusy(ppdev);
                if (NvFree(  ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_CONTEXT_DMA_CURSOR+ulBufIndex) !=
                    NVOS00_STATUS_SUCCESS )
                {
                    DISPDBG((0, "EnablePointer: Cannot free dma in memory context for cursor"));
                }
                NVHEAP_FREE(ppdev->ulCursorMemOffset[ulBufIndex]);
                ppdev->ulCursorMemOffset[ulBufIndex] = 0;
            }
        }

}




//******************************************************************************
//
//  Function:   NVEnablePointer
//
//  Routine Description:
//
//      Handling Allocate / Free memory for the cursor
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
VOID NVEnablePointer
(
PDEV*               ppdev,
BOOL    bEnable
)
{
    ULONG i, nBuffers;
    ULONG ulHead;
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    if (bEnable)
    {
        for(nBuffers = 0; nBuffers < 2; nBuffers++)
        {
            if(!NvAllocateCursorMem(ppdev, nBuffers))
            {
                ppdev->flCaps |= CAPS_SW_POINTER;
                return;
            }

        	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
        	{
                ulHead = ppdev->ulDeviceDisplay[i];
                NV_DMAPUSH_CHECKFREE( ((ULONG)(4)));  
                NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
                NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_CURSOR(nBuffers), NV_CONTEXT_DMA_CURSOR+nBuffers);
            }
        }
        UPDATE_PDEV_DMA_COUNT;

        //******************************************************************
        // Send data on thru to the DMA push buffer
        //******************************************************************

        if(ppdev->bEnabled)
            NV4_DmaPushSend(ppdev);
        
        // Wait for it to complete.
        ppdev->pfnWaitEngineBusy(ppdev);

    }
    else
    {
        for(i = 0; i < 2; i++)
            NvFreeCursorMem(ppdev, i);
    }
}

//******************************************************************************
//
//  Function:   NvCalNewDisplayWindow
//
//  Routine Description:
//
//      Calculating the display window based on the location of cursor pointer.
//
//  Arguments:
//
//  Return Value:
//
//      True - Moved; FALSE - The location is within Window; Not need to move.
//
//******************************************************************************
BOOLEAN NvCalNewDisplayWindow(
LONG x, LONG y, 
LONG lOutsideLeft, LONG lOutsideTop, LONG lOutsideRight, LONG lOutsideBottom,
ULONG ulMoveDisplayDx, ULONG ulMoveDisplayDy,
RECTL * pWindow)
{

    LONG lNewX1, lNewX2, lNewY1, lNewY2 ;
    BOOLEAN bRet = FALSE;

    lNewX2 = lNewY2 = 0;

    if(x == lOutsideLeft)
    {
        // Reset the X coordinate
        pWindow->right = lOutsideLeft + (pWindow->right - pWindow->left);
        pWindow->left  = lOutsideLeft;
        bRet = TRUE;
    }
    else if(x > pWindow->left)
    {
        if(x < pWindow->right)
        {
            // Inside the view of Display Screen;
            // Do nothing for X;
        }
        else
        {
            if(pWindow->right < lOutsideRight)
            {
                // MOVE display to right
                lNewX2 = pWindow->right + ulMoveDisplayDx;
                while(x > lNewX2)
                    lNewX2 += ulMoveDisplayDx;
                if(lNewX2 > lOutsideRight)
                    lNewX2 = lOutsideRight;
                lNewX1 = lNewX2 - (pWindow->right - pWindow->left);
                pWindow->left = lNewX1;
                pWindow->right = lNewX2;
                bRet = TRUE;
            }
        }
    }
    else
    {
        // MOVE display to left
        if(pWindow->left > lOutsideLeft)
        {
            lNewX1 = pWindow->left - ulMoveDisplayDx;
            while(x < lNewX1)
                lNewX1 -= ulMoveDisplayDx;
            if(lNewX1 < lOutsideLeft)
                lNewX1 = lOutsideLeft;
            lNewX2 = lNewX1 + (pWindow->right - pWindow->left);
            pWindow->left = lNewX1;
            pWindow->right = lNewX2;
            bRet = TRUE;
        }
    }

    // HW restriction Enforcement: Since image offset value is a multiple of 4 bytes.  
    // and this rountine does not deal with 8bpp, 16bpp or 32bpp,
    // set to 4 pixels alignment in order to satisfy HW restriction.
    if(bRet)
        pWindow->left = (pWindow->left + 3) & ~(0x03);

    if(y == lOutsideTop)
    {
        // Reset the Y coordinate
        pWindow->bottom = lOutsideTop + (pWindow->bottom - pWindow->top);
        pWindow->top = lOutsideTop;
        bRet = TRUE;
    }
    else if(y > pWindow->top)
    {
        if(y < (pWindow->bottom) )
        {
            // Inside the view of Display Screen;
            // Do nothing for Y;
        }
        else
        {
            if(pWindow->bottom < lOutsideBottom)
            {
                // Move display down
                lNewY2 = pWindow->bottom + ulMoveDisplayDy;
                while(y > lNewY2)
                    lNewY2 += ulMoveDisplayDy;
                if(lNewY2 > lOutsideBottom)
                    lNewY2 = lOutsideBottom;
                lNewY1 = lNewY2 - (pWindow->bottom - pWindow->top);
                pWindow->top = lNewY1;
                pWindow->bottom = lNewY2;
                bRet = TRUE;
            }
        }
    }
    else
    {
        // MOVE display up
        if(pWindow->top > lOutsideTop)
        {
            lNewY1 = pWindow->top - ulMoveDisplayDy;
            while(y < lNewY1)
                lNewY1 -= ulMoveDisplayDy;
            if(lNewY1 < 0)
                lNewY1 = 0;
            lNewY2 = lNewY1 + (pWindow->bottom - pWindow->top);
            pWindow->top = lNewY1;
            pWindow->bottom = lNewY2;
            bRet = TRUE;
        }
    }

    return(bRet);
}


//******************************************************************************
//
//  Function:   NVMoveDisplayWindow
//
//  Routine Description:
//
//      Move the display window to new location.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
void __cdecl NVMoveDisplayWindow(
PDEV*   ppdev,
ULONG   ulHead,
RECTL * prclCurrentDisplay)
{
    ULONG ulPanOffset;
    DECLARE_DMA_FIFO;
    INIT_LOCAL_DMA_FIFO;

    NV_DMAPUSH_CHECKFREE( ((ULONG)(10)));  
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ulHead);
    ulPanOffset = prclCurrentDisplay->left * ppdev->cjPelSize + prclCurrentDisplay->top * ppdev->lDelta 
                                    + ppdev->ulPrimarySurfaceOffset - ppdev->ulHeadDisplayOffset[ulHead];
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_PAN_OFFSET, ulPanOffset);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_FORMAT(0), ppdev->lDelta |
        NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31);
    //******************************************************************
    // Update global push buffer count
    //******************************************************************
    UPDATE_PDEV_DMA_COUNT;

    //******************************************************************
    // Send data on thru to the DMA push buffer
    //******************************************************************
    NV4_DmaPushSend(ppdev);

    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    ppdev->pfnWaitEngineBusy(ppdev);

}

//******************************************************************************
//
//  Function:   NVMovePointer
//
//  Routine Description:
//
//      Move the NV hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NVMovePointer(
PDEV*   ppdev,
LONG    x,
LONG    y)

{
    RECTL * prclCurrentDisplay;
    RECTL * prclDisplayDesktop;
    LONG lOriginalX, lOriginalY;
    ULONG ulHead;
    LONG lOverlayDisabledHead = -1;

    ULONG ulSaveDesktopMode;

    lOriginalX, lOriginalY;

    if(x == -1)
    {
        x  = ppdev->cxScreen + 64;
        y  = ppdev->cyScreen + 64;
    }

    lOriginalX = x;
    lOriginalY = y;

    ulHead = ppdev->ulDeviceDisplay[0];
    prclCurrentDisplay = &ppdev->rclCurrentDisplay[ulHead];

#if (_WIN32_WINNT >= 0x0500) && defined(NVD3D) && !defined(_WIN64)
    ulSaveDesktopMode = ppdev->ulDesktopMode;

    if( (ppdev->pDriverData->vpp.dwOverlayFSNumSurfaces != 0))
    {
        // Disable pan & scan because Video is rendering on the head now.
        lOverlayDisabledHead =  ppdev->pDriverData->vpp.dwOverlayFSHead; 
        if( ulHead == (ULONG) lOverlayDisabledHead)
        {
            // Logical head 0
            ppdev->ulDesktopMode &= ~(NV_VIRTUAL_DESKTOP_1);
        }
        else
        {
            // Logical head 1
            ppdev->ulDesktopMode &= ~(NV_VIRTUAL_DESKTOP_2);
        }
    }
#endif
    if(ppdev->ulDesktopMode & NV_VIRTUAL_DESKTOP_1)
    {
        // Primary DAC
        prclDisplayDesktop = &ppdev->rclDisplayDesktop[ulHead];

        if( (x >= prclDisplayDesktop->left) && (x < prclDisplayDesktop->right) && 
            (y >= prclDisplayDesktop->top)  && (y < prclDisplayDesktop->bottom)) 
        {
            if (NvCalNewDisplayWindow(x,y, prclDisplayDesktop->left,  prclDisplayDesktop->top, 
                                         prclDisplayDesktop->right, prclDisplayDesktop->bottom, 
                                         ppdev->ulMoveDisplayDx, 
                                         ppdev->ulMoveDisplayDy, 
                                         prclCurrentDisplay))
            {
                NVMoveDisplayWindow(ppdev, ulHead, prclCurrentDisplay);
            }
        }
    }

    if(!ppdev->ulPuntCursorToGDI)
    {
        // Don't worry to move the cursor pointer; GDI Software cursor pointer
        x -= ppdev->xPointerHot;
        x -= prclCurrentDisplay->left;
        y -= ppdev->yPointerHot;
        y -= prclCurrentDisplay->top;
        
        if( ulHead != (ULONG) lOverlayDisabledHead)
        {
            SET_CURSOR_LOCATION(ppdev, ulHead, x, y);
        }
    }

    if(ppdev->ulDesktopMode & NV_TWO_DACS)
    {
        x = lOriginalX;
        y = lOriginalY;

        ulHead = ppdev->ulDeviceDisplay[1];
        prclCurrentDisplay = &ppdev->rclCurrentDisplay[ulHead];

        if(ppdev->ulDesktopMode & NV_VIRTUAL_DESKTOP_2)
        {
            // Secondary DAC
            prclDisplayDesktop = &ppdev->rclDisplayDesktop[ulHead];

            if( (x >= prclDisplayDesktop->left) && (x < prclDisplayDesktop->right) && 
                (y >= prclDisplayDesktop->top)  && (y < prclDisplayDesktop->bottom)) 
            {
                if (NvCalNewDisplayWindow(x,y, prclDisplayDesktop->left,  prclDisplayDesktop->top, 
                                         prclDisplayDesktop->right, prclDisplayDesktop->bottom, 
                                         ppdev->ulMoveDisplayDx, 
                                         ppdev->ulMoveDisplayDy, 
                                         prclCurrentDisplay))
                {
                    NVMoveDisplayWindow(ppdev, ulHead, prclCurrentDisplay);
                }
            }
        }

        if(!ppdev->ulPuntCursorToGDI)
        {
            // Don't worry to move the cursor pointer; GDI Software cursor pointer
            x -= ppdev->xPointerHot;
            x -= prclCurrentDisplay->left;
            y -= ppdev->yPointerHot;
            y -= prclCurrentDisplay->top;

            if( ulHead != (ULONG) lOverlayDisabledHead)
            {
                SET_CURSOR_LOCATION(ppdev, ulHead, x, y);
            }
        }

    }

#if (_WIN32_WINNT >= 0x0500) && defined(NVD3D) && !defined(_WIN64)
    // restore the Desktop mode
    ppdev->ulDesktopMode = ulSaveDesktopMode;
#endif
}

//******************************************************************************
//
//  Function:   NvSwMonoToHw16BppCursor
//
//  Routine Description:
//  Handle Mono cursor in 16Bpp HW cursor mode (Alpha1?Cur:Cur^Bkgnd).
//
// USING A1R5G5B5 16 bits format
// Translate to black and white format for DAC
// Expand 32 x 32 x 1  (monochrome source ) to 32 x 32 x 16 CursorColorImage
//
// We're going to take the requested pointer AND masks and XOR
// masks and combine them into our work buffer,
//
//              Monochrome Source
//              -----------------
//
//         Byte0   Byte1   Byte2   Byte3
//  0    |       |       |       |       |
//  1    |       |       |       |       |         (monochrome source)
//  2    |       |       |       |       |     Total of 128 bytes per plane
//  3    |       |       |       |       |
//                      etc..
//
//  31   |       |       |       |       |
//
//
//
//              Color Destination
//              -----------------
//
//         Word0   Word1   ....    Word31
//  0    |       |       |       |       |
//  1    |       |       |       |       |         (color destination)
//  2    |       |       |       |       |      Total 32*32*2 bytes
//  3    |       |       |       |       |
//                      etc..
//
//  31   |       |       |       |       |
//
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
void Nv1BppToHw16BppCursor(LONG cx, LONG cy, BYTE* pjSrcScan, ULONG *pulDstScan, 
ULONG ulHwCursorWidth, LONG lSrcDelta, LONG lDstDelta)
{
    int i, j, k;
    BYTE    bMask, bMono;
    ULONG ulDwordCount, ulColor, ulTemp, ulTest;
    LONG    lPixelCountPerLine;

    for(i = 0; i < cy; i++)
    { 
        ulDwordCount = 0;
        lPixelCountPerLine = 0;
        for(j = 0; j < lDstDelta && lPixelCountPerLine < cx; j++)            // in term of bytes
        {
            bMask = pjSrcScan[i * lSrcDelta + j];           // Get a Mask byte (8 pixels)
            bMono = pjSrcScan[ (cy + i) * lSrcDelta + j];   // Get a Mono byte (8 pixels)

            //**************************************************************
            // Now combine the masks according to the AND-XOR Microsoft convention
            //
            //  ('mask' value)      ('mono' value)
            //  AND mask value      XOR mask value      Result on screen
            //  --------------      --------------      ----------------
            //          0               0               Black
            //          0               1               White
            //          1               0               Transparent, pixel unchanged
            //          1               1               Inverts the pixel color
            //
            // We'll parse the pixels from right to left in source
            // (Bit 0 is leftmost in mono image).  This will cause
            // us to bit flip the cursor image and draw it correctly
            //**************************************************************

            ulTest = 0x80;
            for (k = 0; k < 8; k++, ulTest >>= 1)
            {
                if (ulTest & bMono)        // Test this bit
                    ulColor = 0x7fff;     // White
                else
                    ulColor = 0;          // Black

                if (!(ulTest & bMask))
                    ulColor |= 0x8000;    // Not transparent


                //**********************************************************
                // Store 16 bits for NV cursor image data
                //**********************************************************
                if(k & 1)
                {
                    ulTemp = ((ULONG) ulColor << 16) | ulTemp;
                    *pulDstScan++ = ulTemp;
                    ulDwordCount++;
                }
                else
                {
                    ulTemp = ulColor;
                }
                // Before next pixel, 1 byte (mono) is for 8 pixels.  
                // When it is over the width of cursor, quit but check last pixel
                // whether it has been written.
                if( (++lPixelCountPerLine) > cx)
                {
                    if(!(k & 1))
                    {
                        *pulDstScan++ = ulTemp;
                        ulDwordCount++;
                    }
                    break;
                }
            }
        }   // End of j loop

        // make HW happy, fill remaining DWORD to ulHwCursorWidth
        while(ulDwordCount < (ulHwCursorWidth / 2))
        {
            *pulDstScan++ = 0x0;
            ulDwordCount++;
        }
    }   // End of i loop
    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }
}

//******************************************************************************
ULONG Nv8BppToHw16BppCursor(PDEV* ppdev, PPALETTEENTRY pPal, XLATEOBJ*   pxlo, LONG cx, LONG cy, 
BYTE* pjSrcColor, BYTE* pjSrcColorMask, ULONG *pulDstScan, ULONG ulHwCursorWidth, 
LONG lSrcDelta, LONG lPitch)
{
    int i, j, k;
    ULONG ulMask;
    ULONG ulDwordCount, ulColor, ulTemp, ulTest;
    WORD    red;
    WORD    green;
    WORD    blue;
    PALETTEENTRY pXlatePal[256];

    //**************************************************************
    // We gotta look up the color from the palette to
    // convert to RGB. Try to get info from the XLATEOBJ
    // first.
    //**************************************************************
//    pPal = ppdev->pPal;     // Default to using pal from PDEV
    if (pxlo != NULL)
    {
        if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, NULL) == 256)
        {
            //******************************************************
            // Get the RGB palette.
            //******************************************************
            if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, (PULONG) pXlatePal) != 256)
                pPal = pXlatePal;
        }
    }
    for (i = 0; i < cy; i++)
    {
        ulMask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
        ulTest = 0x00000080;
        ulDwordCount = 0;
        for (k = 0; k < cx; k++, ulTest >>=1)
        {
            if (!(k & 7))
                ulTest = 0x00000080 << k;
            ulColor = *((PBYTE) (pjSrcColor + i*lPitch + k)); // Get 15 bits of color
            blue  = pPal[ulColor].peBlue;
            green = pPal[ulColor].peGreen;
            red   = pPal[ulColor].peRed;
            ulColor = ((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >> 3);
            if (!(ulTest & ulMask))
            {
                ulColor |= 0x8000;              // Not transparent
            }
            else
            {
                if(ulColor == 0x7FFF)
                {
                    // inverted background color
                    WORK_AROUND_NV11_DIRTHER;
                }
                else
                {
				        // Transparent
                }
            }

            //******************************************************
            // Store 16 bits for NV cursor image data
            //******************************************************
            if(k & 1)
            {
                ulTemp = ((ULONG) ulColor << 16) | ulTemp;
                *pulDstScan++ = ulTemp;
                ulDwordCount++;
            }
            else
            {
                ulTemp = ulColor;
            }
        }
        // make HW happy, fill remaining DWORD to ulHwCursorWidth
        while(ulDwordCount < (ulHwCursorWidth / 2))
        {
            *pulDstScan++ = 0x0;
            ulDwordCount++;
        }
    }
    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }
    return(SPS_ACCEPT_NOEXCLUDE);
}

//******************************************************************************
ULONG Nv16BppToHw16BppCursor(PDEV* ppdev, LONG cx, LONG cy, BYTE* pjSrcColor, BYTE* pjSrcColorMask, 
    LONG lSrcDelta, LONG lPitch, ULONG*  pulDstScan, ULONG ulHwCursorWidth, FLONG flGreen)
{
    ULONG ulMask, ulTest;
    WORD    red;
    WORD    green;
    WORD    blue;
    LONG    i,j,k;
    ULONG*  pulTemp;
    ULONG   ulTemp, ulColor, ulDwordCount;

    for (i = 0; i < cy; i++)
    {
        ulMask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
        ulTest = 0x00000080;
        ulDwordCount = 0;
        for (k = 0; k < cx; k++, ulTest >>=1)
        {
           if (!(k & 7))
               ulTest = 0x00000080 << k;

           if (flGreen == 0x03e0)
           {
                //**************************************************
                // For 555: We can use the source color as is
                //          since the color cursor is always 555
                //**************************************************
                ulColor = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 15 bits of color
           }
           else
           {
                //**************************************************
                // For 565: Convert from 565 bitmap format to 555
                //          since the color cursor is always 555
                //**************************************************
                ulColor = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 16 bits of color
                red   = (WORD)(ulColor & 0xf800); // 5 bits
                green = (WORD)(ulColor & 0x07c0); // Just take top 5 of 6 bits !
                blue  = (WORD)(ulColor & 0x001f); // 5 bits
                ulColor = (  (red >> 1 ) | (green >> 1 ) | (blue) );
           }

           if (!(ulTest & ulMask))
                 ulColor |= 0x8000;                // Not transparent
           else
           {
                if(ulColor == 0x7FFF)
                {
                    // inverted background color
                    WORK_AROUND_NV11_DIRTHER;
                }
                else
                {
				        // Transparent
                }
           }
          

           //******************************************************
           // Store 16 bits for NV cursor image data
           //******************************************************
            if(k & 1)
            {
                ulTemp = ((ULONG) ulColor << 16) | ulTemp;
                *pulDstScan++ = ulTemp;
                ulDwordCount++;
            }
            else
            {
                ulTemp = ulColor;
            }
        }
        // make HW happy, fill remaining DWORD to ulHwCursorWidth
        while(ulDwordCount < (ulHwCursorWidth / 2))
        {
            *pulDstScan++ = 0x0;
            ulDwordCount++;
        }
    }
    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }

    return(SPS_ACCEPT_NOEXCLUDE);
}


//******************************************************************************
//
//  Function:   NvHw16BppCursor
//
//  Routine Description:
//
//      The cursor has some pixels to be inverted back ground color
//      handle it in 16BPP mode of cursor
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
void NvHw16BppCursor(LONG cx, LONG cy, BYTE* pjSrcColor, BYTE* pjSrcColorMask, 
    LONG lSrcDelta, LONG lPitch, ULONG*  pulDstScan, ULONG ulHwCursorWidth, BOOL AlphaBlendedCursor)
{

    BYTE    bMask, bTest;
    WORD    wRed, wGreen, wBlue;
    LONG    i,j,k;
    ULONG*  pulTemp;
    ULONG   ulTemp, ulColor, ulDwordCount;
    LONG    lPixelCountPerLine;


    for (i = 0; i < cy; i++) 
    {
        ulDwordCount = 0;
        lPixelCountPerLine = 0;
        pulTemp = (ULONG *)(pjSrcColor + i * lPitch);
        for (j = 0; j < cx ; j += 8) 
        {
            bMask = 0;
            if(!AlphaBlendedCursor)
            {
                // Not a alpha cursor; use get the mask
                bMask = *(pjSrcColorMask + i*lSrcDelta + j / 8);  
            }

            bTest = 0x80;
            for(k = 0; k < 8; k++, bTest >>= 1) 
            {
                ulColor = *pulTemp++;

                if(AlphaBlendedCursor)
                {
                    // Check alpha value of each pixel to determinie the transparenet
                    if( (ulColor & 0xFF000000) == 0xFF000000)
                    {
                        // New Cursor Color
                    }
                    else
                    {
                        // Really want to use the backgroup color
                        // clear the mask bit so that it will get the backgroup color.
                        bMask |= bTest;
                    }
                }

                if(!(bTest & bMask))
                {
                    wRed   = (WORD)(((ulColor & 0xFF0000) >> 16) * 32 / 256); // 5 bits
                    wRed   <<= 10;
                    wGreen = (WORD)(((ulColor & 0x00FF00) >> 8 ) * 32 / 256); // 5 bits
                    wGreen <<= 5;
                    wBlue  = (WORD)(((ulColor & 0x0000FF)      ) * 32 / 256); // 5 bits
                
                    ulColor = 0x8000 | wRed | wGreen | wBlue;
                }
                else
                {
				    if (ulColor == 0x00FFFFFF)
					{
                        // inverted background color
                        ulColor = 0x7FFF; 
					}
					else 
					{
				        // Transparent
						ulColor = 0;
					}
                }

                //**********************************************************
                // Store 16 bits for NV cursor image data
                //**********************************************************
                if(k & 1)
                {
                    ulTemp = ((ULONG) ulColor << 16) | ulTemp;
                    *pulDstScan++ = ulTemp;
                    ulDwordCount++;
                }
                else
                {
                    ulTemp = ulColor;
                }

                // Before next pixel, 1 byte (mono) is for 8 pixels.  
                // When it is over the width of cursor, quit but check last pixel
                // whether it has been written.
                if( (++lPixelCountPerLine) > cx)
                {
                    if(!(k & 1))
                    {
                        *pulDstScan++ = ulTemp;
                        ulDwordCount++;
                    }
                    break;
                }

            }
        }
        // make HW happy, fill remaining DWORD to ulHwCursorWidth
        while(ulDwordCount < (ulHwCursorWidth / 2))
        {
            *pulDstScan++ = 0x0;
            ulDwordCount++;
        }
    }

    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }
    
}

//******************************************************************************
//
//  Function:   NVSetPointerShapeToHw
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
void NvSetPointerShapeToHw(PDEV * ppdev,  ULONG ulHwCursorWidth, ULONG ulHwCursorHeight, ULONG ulHwCursorFormat)
{
    DECLARE_DMA_FIFO;
    
    ppdev->ulCachedCursorWidth = ulHwCursorWidth;
    ppdev->ulCachedCursorFormat = ulHwCursorFormat;
	INIT_LOCAL_DMA_FIFO;
    NV_DMAPUSH_CHECKFREE( ((ULONG)(6)));  

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ppdev->ulDeviceDisplay[0]);

	NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_IMAGE_OFFSET(ppdev->ulCursorCurBufIndex), 0);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_IMAGE_FORMAT(ppdev->ulCursorCurBufIndex), 
    	 (ulHwCursorFormat << 16) |
	     (ulHwCursorHeight << 8) | ulHwCursorWidth);

    if(ppdev->ulDesktopMode & NV_TWO_DACS)
	{
        NV_DMAPUSH_CHECKFREE( ((ULONG)(8)));
	    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(ppdev->ulCursorCurBufIndex) ,   NV_VIDEO_LUT_CURSOR_DAC+ppdev->ulDeviceDisplay[1]);

        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_IMAGE_OFFSET(ppdev->ulCursorCurBufIndex), 0);

    	NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_IMAGE_FORMAT(ppdev->ulCursorCurBufIndex), 
        	 (ulHwCursorFormat << 16) |
	         (ulHwCursorHeight << 8) | ulHwCursorWidth);

        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC);
	}

	//******************************************************************
    // Update global push buffer count
	//******************************************************************
    
    UPDATE_PDEV_DMA_COUNT;

	//******************************************************************
    // Send data on thru to the DMA push buffer
	//******************************************************************

	NV4_DmaPushSend(ppdev);
}



//******************************************************************************
//
//  Function:   NVSetPointerShapeOn16BppHwMode
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG NVSetPointerShapeOn16BppHwMode(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
LONG        cx,
LONG        cy,
BOOL        AlphaBlendedCursor
)
{
    PDEV*   ppdev;
    
    BYTE    bMono, bMask;
    BYTE    bTest;

    LONG    lPixelCount;
    LONG    i,j,k;
    LONG    lSrcDelta = 0;
    LONG    lDstDelta = 0;
    
    ULONG   ulDwordCount;    
    ULONG   ulTest; 
    ULONG   ulColor;
    ULONG   ulAlpha;
    ULONG   ulTemp;
    ULONG   ulHwCursorWidth;      // HW : 32 or 64
    ULONG   ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;

    BYTE*    pjSrcScan;           // BYTE * because GDI may give us on byte alignment
    ULONG*   pulDstScan;          // ULONG * for performance

    //**************************************************************************
    // Get pointer to pdev
    //**************************************************************************

    ppdev    = (PDEV*) pso->dhpdev;

    if ( AlphaBlendedCursor && globalOpenGLData.oglDrawableClientCount )
    {
        //******************************************************************
        // For alpha blended cursors when an OpenGL window is open,
        // we convert it to a hardware mono cursor. 
        // if alpha blended cursors come thru with cx > ppdev->ulMaxHwCursorSize or cy > ppdev->ulMaxHwCursorSize, 
        // they'll get clipped
        //******************************************************************

        if (cx > (LONG)(ppdev->ulMaxHwCursorSize) )
            cx = ppdev->ulMaxHwCursorSize;
            
        if (cy > (LONG)(ppdev->ulMaxHwCursorSize) )
            cy = ppdev->ulMaxHwCursorSize;            
    }
    else 
    {
        if(AlphaBlendedCursor)
        {
            // Not alpha cursor support on 16Bpp mode.
            return(SPS_DECLINE);
        }

        if ( (cx > (LONG)(ppdev->ulMaxHwCursorSize))  ||  (cy > (LONG)(ppdev->ulMaxHwCursorSize)) ) {
            DISPDBG((5, "NVSetPointerShape: Unsupported size"));          
            return(SPS_DECLINE);
        }
    }

    if(cx > 32)
        ulHwCursorWidth = 64;
    else
        ulHwCursorWidth = 32; 
    
    pulDstScan = (ULONG *) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase);

    //**************************************************************************
    // Check whether we'll be drawing a MONOCHROME or COLOR cursor
    //**************************************************************************
    if (psoColor == NULL)
    {

        pjSrcScan    = psoMsk->pvScan0;
        lSrcDelta    = psoMsk->lDelta;

        lDstDelta = (cx + 7) / 8;
         
        Nv1BppToHw16BppCursor(cx, cy, pjSrcScan, pulDstScan, ulHwCursorWidth, lSrcDelta, lDstDelta);

        DISPDBG((5, "NVSetPointerShape: Mono Cursor"));

    }   // Draw monochrome cursor (psoColor == NULL)
    else
    {
        ULONG   iSrcBitDepth;
        LONG    lPitch;
        BYTE*   pjSrcColor;
        BYTE*   pjSrcColorMask;
        
        //**********************************************************************
        // Color cursor ( or alpha blended cursor)
        // Calc width of each scan in the color cursor bitmap. Assume the
        // bitmap has the same color format as the display device.
        //
        // The first 32*4 bytes is the AND mask.
        // The next 32 * 32 * bytes/pixel is the cursor image.
        // Translate the image into 1-5-5-5 format for the DAC
        // The AND mask value goes into the upper bit
        // The pixel image gets reduced to 5 bits each color and goes in the lower 15 bits
        // 8 bpp  - 8 bit index into palette.           pixel = 1 byte
        // 16 bpp - 1 bit X, 5 bit R, 5 bit G, 5 bit B. pixel = 2 bytes
        // 32 bit - 8 bit R, 8 bit G, 8 bit B           pixel = 3 bytes unpacked (+unused byte).
        //**********************************************************************

        //**********************************************************************
        // Determine if this is a device bitmap or GDI managed bitmap.
        // Note that the cursor bitmap may be any legal bit depth: it
        // does not necessarily match the current video mode. That's ok
        // since we have to convert it to 16BPP for our color cursor
        // hw.
        //**********************************************************************

        if (psoColor->dhsurf != NULL) {
            
            //******************************************************************
            // Device managed bitmap
            //******************************************************************
            if (((DSURF *) psoColor->dhsurf)->dt == DT_SCREEN) {
                //**************************************************************
                // Ptr surface is in offscreen device memory, need to wait for
                // fifo empty and graphics engine idle prior to copying the
                // pointer bitmap.
                //**************************************************************
                pjSrcColor      = (PBYTE) (((DSURF *) psoColor->dhsurf)->LinearPtr);
                lPitch          = (((DSURF *) psoColor->dhsurf))->LinearStride;
                iSrcBitDepth =  (((DSURF *) psoColor->dhsurf)->ppdev)->iBitmapFormat;
                ppdev->pfnWaitEngineBusy(ppdev);
            } else {
                // (pdsurfSrc->dt == DT_DIB)
                //**************************************************************
                // Device managed DFB in host memory, stored as DIB.
                // Don't bother moving DIB to offscreen memory since whe don't
                // use the graphics engine to draw or translate it.
                //**************************************************************
                psoColor = ((DSURF *) psoColor->dhsurf)->pso;
                lPitch =  psoColor->lDelta;
                iSrcBitDepth = psoColor->iBitmapFormat;
                pjSrcColor = (PBYTE) psoColor->pvScan0;
            }

        } else if (psoColor->pvScan0 != NULL) {
            //******************************************************************
            // GDI managed host memory bitmap
            //******************************************************************
            pjSrcColor      = (PBYTE) psoColor->pvScan0;
            lPitch          = psoColor->lDelta;
            iSrcBitDepth =  psoColor->iBitmapFormat;
        } else {
            //******************************************************************
            // If ptr bmp is neither DFB nor DIB, it's likely an error occurred.
            //******************************************************************
            return(SPS_DECLINE);
        }

        //**********************************************************************
        // Can't use ptr without address of the bitmap
        //**********************************************************************

        if (pjSrcColor == NULL) {
            return(SPS_DECLINE);
        }

        //**********************************************************************
        // psoMsk is NULL when using an Alpha Blended cursor
        //**********************************************************************

        if (!(AlphaBlendedCursor)) {
            pjSrcColorMask  = psoMsk->pvScan0;
            lSrcDelta       = psoMsk->lDelta;
        }
            
        switch (iSrcBitDepth)
        {
            //******************************************************************
            // We gotta look up the color from the palette to convert to RGB
            //******************************************************************

            case BMF_8BPP:
                Nv8BppToHw16BppCursor(ppdev, ppdev->pPal, pxlo, cx, cy, 
                    pjSrcColor, pjSrcColorMask, pulDstScan, ulHwCursorWidth, 
                    lSrcDelta, lPitch);
                break;

            //******************************************************************
            // Screen is currently in 16bpp mode
            //******************************************************************
            case BMF_16BPP:
                Nv16BppToHw16BppCursor(ppdev, cx, cy, pjSrcColor, pjSrcColorMask, 
                     lSrcDelta, lPitch,  pulDstScan,  ulHwCursorWidth, ppdev->flGreen);

                break;
            //******************************************************************
            // Screen is currently in 32bpp mode
            //******************************************************************
            case BMF_32BPP:
                // Converted to 16Bpp for HW.

                NvHw16BppCursor(cx, cy, pjSrcColor, pjSrcColorMask, lSrcDelta, lPitch,
                    (ULONG*) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase), ulHwCursorWidth, AlphaBlendedCursor);
                break;

             default:
                //**************************************************************
                // Can't handle any other bit depths
                //**************************************************************
                DISPDBG((5, "NVSetPointerShape: Unsupported bit depth"));
                return(SPS_DECLINE);

        }   // Switch
    } // psoColor != NULL

    DISPDBG((5, "NVSetPointerShape: Width or format changed.  Reloading."));
    NvSetPointerShapeToHw(ppdev,  ulHwCursorWidth, cy, ulHwCursorFormat);
    ppdev->ulCursorCurBufIndex ^= 1;
	
    //**************************************************************************
    // Get HotSpot
    //**************************************************************************

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    ppdev->pfnMovePointer(ppdev, x, y);

    return(SPS_ACCEPT_NOEXCLUDE);

}

//******************************************************************************
//
//  Function:   NVSetPointerShapeOn32BppHwMode
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG NVSetPointerShapeOn32BppHwMode(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
LONG        cx,
LONG        cy,
BOOL        AlphaBlendedCursor
)
{
    PDEV*   ppdev;
    
    BYTE    bMono, bMask;
    BYTE    bTest;

    LONG    lPixelCount;
    LONG    i,j,k;
    LONG    lSrcDelta = 0;
    LONG    lDstDelta = 0;
    
    ULONG   ulDwordCount;    
    ULONG   ulTest; 
    ULONG   ulColor;
    ULONG   ulAlpha;
    ULONG   ulTemp;
    ULONG   ulHwCursorWidth;      // HW : 32 or 64
    // All 32Bpp cursor are done on PM_LE_A8R8G8B8 except the inverted background color cursor.
    ULONG   ulHwCursorFormat = NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8; 

    BYTE*    pjSrcScan;           // BYTE * because GDI may give us on byte alignment
    ULONG*   pulDstScan;          // ULONG * for performance

    //**************************************************************************
    // Get pointer to pdev
    //**************************************************************************

    ppdev    = (PDEV*) pso->dhpdev;

    if ( AlphaBlendedCursor && globalOpenGLData.oglDrawableClientCount )
    {
        //******************************************************************
        // For alpha blended cursors when an OpenGL window is open,
        // we convert it to a hardware mono cursor. 
        // if alpha blended cursors come thru with cx > ppdev->ulMaxHwCursorSize or cy > ppdev->ulMaxHwCursorSize, 
        // they'll get clipped
        //******************************************************************

        if (cx > (LONG)(ppdev->ulMaxHwCursorSize) )
            cx = ppdev->ulMaxHwCursorSize;
            
        if (cy > (LONG)(ppdev->ulMaxHwCursorSize) )
            cy = ppdev->ulMaxHwCursorSize;            
    }
    else 
    {
        if ( (cx > (LONG)(ppdev->ulMaxHwCursorSize))  ||  (cy > (LONG)(ppdev->ulMaxHwCursorSize)) ) {
            DISPDBG((5, "NVSetPointerShape: Unsupported size"));
            return(SPS_DECLINE);
        }
    }

    if(cx > 32)
        ulHwCursorWidth = 64;
    else
        ulHwCursorWidth = 32; 
    
    pulDstScan = (ULONG *) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase);

    //**************************************************************************
    // Check whether we'll be drawing a MONOCHROME or COLOR cursor
    //**************************************************************************
    if (psoColor == NULL)
    {
        pjSrcScan    = psoMsk->pvScan0;
        lSrcDelta    = psoMsk->lDelta;

        lDstDelta = (cx + 7) / 8;
         
        for(i = 0; i < cy; i++)
        { 
            ulDwordCount = 0;
            for(j = 0; j < lDstDelta; j++)                 // in term of bytes
            {
                bMask = pjSrcScan[i * lSrcDelta + j];           // Get a Mask byte (8 pixels)
                bMono = pjSrcScan[ (cy + i) * lSrcDelta + j];   // Get a Mono byte (8 pixels)

                //**************************************************************
                // Now combine the masks according to the AND-XOR Microsoft convention
                //
                //  ('mask' value)      ('mono' value)
                //  AND mask value      XOR mask value      Result on screen
                //  --------------      --------------      ----------------
                //          0               0               Black
                //          0               1               White
                //          1               0               Transparent, pixel unchanged
                //          1               1               Inverts the pixel color
                //
                // We'll parse the pixels from right to left in source
                // (Bit 0 is leftmost in mono image).  This will cause
                // us to bit flip the cursor image and draw it correctly
                //**************************************************************

                ulTest = 0x80;
                for (k = 0; k < 8; k++, ulTest >>= 1)
                {
                    if ((ulTest & bMask))
                    {
                        if (ulTest & bMono)             // Test this bit
                        {
                            // inverted background color
                            pulDstScan = (ULONG *) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase);
                            WORK_AROUND_NV11_DIRTHER;
                            Nv1BppToHw16BppCursor(cx, cy, pjSrcScan, 
                                pulDstScan, ulHwCursorWidth, lSrcDelta, lDstDelta);
                            ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                            goto NvCursorDoneImage;
                        }
                        else
                        {
                            ulColor = 0;                // transparent
                        }
                    }
                    else
                    {
                        if (ulTest & bMono)             // Test this bit
                            ulColor = 0xffffffff;         // White
                        else
                            ulColor = 0xff000000;                // Black
                    }

                    *pulDstScan++ = ulColor;
                    ulDwordCount++;
                }
            }   // End of j loop

            // make HW happy, fill remaining DWORD to ulHwCursorWidth
            while(ulDwordCount < ulHwCursorWidth)
            {
                *pulDstScan++ = 0x0;
                ulDwordCount++;
            }
        }   // End of i loop
        DISPDBG((5, "NVSetPointerShape: Mono Cursor"));
    }   // Draw monochrome cursor (psoColor == NULL)
    else
    {
        WORD    red;
        WORD    green;
        WORD    blue;
        WORD    alpha;
        ULONG   ulMask;
        ULONG   iSrcBitDepth;
        LONG    lPitch;
        BYTE*   pjSrcColor;
        BYTE*   pjSrcColorMask;
        ULONG*  pulTemp;
        PALETTEENTRY pXlatePal[256];
        PPALETTEENTRY pPal;
    
        
        //**********************************************************************
        // Color cursor ( or alpha blended cursor)
        // Calc width of each scan in the color cursor bitmap. Assume the
        // bitmap has the same color format as the display device.
        //
        // The first 32*4 bytes is the AND mask.
        // The next 32 * 32 * bytes/pixel is the cursor image.
        // Translate the image into 1-5-5-5 format for the DAC
        // The AND mask value goes into the upper bit
        // The pixel image gets reduced to 5 bits each color and goes in the lower 15 bits
        // 8 bpp  - 8 bit index into palette.           pixel = 1 byte
        // 16 bpp - 1 bit X, 5 bit R, 5 bit G, 5 bit B. pixel = 2 bytes
        // 32 bit - 8 bit R, 8 bit G, 8 bit B           pixel = 3 bytes unpacked (+unused byte).
        //**********************************************************************

        //**********************************************************************
        // Determine if this is a device bitmap or GDI managed bitmap.
        // Note that the cursor bitmap may be any legal bit depth: it
        // does not necessarily match the current video mode. That's ok
        // since we have to convert it to 16BPP for our color cursor
        // hw.
        //**********************************************************************

        if (psoColor->dhsurf != NULL) {
            
            //******************************************************************
            // Device managed bitmap
            //******************************************************************
            if (((DSURF *) psoColor->dhsurf)->dt == DT_SCREEN) {
                //**************************************************************
                // Ptr surface is in offscreen device memory, need to wait for
                // fifo empty and graphics engine idle prior to copying the
                // pointer bitmap.
                //**************************************************************
                pjSrcColor      = (PBYTE) (((DSURF *) psoColor->dhsurf)->LinearPtr);
                lPitch          = (((DSURF *) psoColor->dhsurf))->LinearStride;
                iSrcBitDepth =  (((DSURF *) psoColor->dhsurf)->ppdev)->iBitmapFormat;
                ppdev->pfnWaitEngineBusy(ppdev);
            } else {
                // (pdsurfSrc->dt == DT_DIB)
                //**************************************************************
                // Device managed DFB in host memory, stored as DIB.
                // Don't bother moving DIB to offscreen memory since whe don't
                // use the graphics engine to draw or translate it.
                //**************************************************************
                psoColor = ((DSURF *) psoColor->dhsurf)->pso;
                lPitch =  psoColor->lDelta;
                iSrcBitDepth = psoColor->iBitmapFormat;
                pjSrcColor = (PBYTE) psoColor->pvScan0;
            }

        } else if (psoColor->pvScan0 != NULL) {
            //******************************************************************
            // GDI managed host memory bitmap
            //******************************************************************
            pjSrcColor      = (PBYTE) psoColor->pvScan0;
            lPitch          = psoColor->lDelta;
            iSrcBitDepth =  psoColor->iBitmapFormat;
        } else {
            //******************************************************************
            // If ptr bmp is neither DFB nor DIB, it's likely an error occurred.
            //******************************************************************
            return(SPS_DECLINE);
        }

        //**********************************************************************
        // Can't use ptr without address of the bitmap
        //**********************************************************************

        if (pjSrcColor == NULL) {
            return(SPS_DECLINE);
        }

        //**********************************************************************
        // psoMsk is NULL when using an Alpha Blended cursor
        //**********************************************************************

        if (!(AlphaBlendedCursor)) {
            pjSrcColorMask  = psoMsk->pvScan0;
            lSrcDelta       = psoMsk->lDelta;
        }
            
        switch (iSrcBitDepth)
        {
            //******************************************************************
            // We gotta look up the color from the palette to convert to RGB
            //******************************************************************

            case BMF_8BPP:

            #ifdef HW_SUPPORT_32BPP_XOR
            !!!  Will enable later on for new chip (NV20 and later)
            !!!  set new format for 32Bpp XOR function
            !!!  set the format
            !!!  ulHwCursorFormat = NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8; 
            
        
                //**************************************************************
                // We gotta look up the color from the palette to
                // convert to RGB. Try to get info from the XLATEOBJ
                // first.
                //**************************************************************
                pPal = ppdev->pPal;     // Default to using pal from PDEV
                if (pxlo != NULL)
                {
                    if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, NULL) == 256)
                    {
                        //******************************************************
                        // Get the RGB palette.
                        //******************************************************
                        if (XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, 256, (PULONG) pXlatePal) != 256)
                            pPal = pXlatePal;
                    }
                }
                for (i = 0; i < cy; i++)
                {
                    ulMask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
                    ulTest = 0x00000080;
                    ulDwordCount = 0;
                    for (k = 0; k < cx; k++, ulTest >>=1)
                    {
                        if (!(k & 7))
                            ulTest = 0x00000080 << k;
                        ulColor = *((PBYTE) (pjSrcColor + i*lPitch + k)); // Get 15 bits of color
                        blue  = pPal[ulColor].peBlue;
                        green = pPal[ulColor].peGreen;
                        red   = pPal[ulColor].peRed;
                        ulColor = ( (DWORD)(red & 0xf8) << 13) | ((green & 0xf8) << 5) | ((blue & 0xf8) >> 3);

                        if (!(ulTest & ulMask))
                            ulColor |= 0xff000000;      // Not transparent
                        else
                            ulColor = 0;                // transparent

                        *pulDstScan++ = ulColor;
                        ulDwordCount++;
                    }
                    // make HW happy, fill remaining DWORD to ulHwCursorWidth
                    while(ulDwordCount < ulHwCursorWidth)
                    {
                        *pulDstScan++ = 0x0;
                        ulDwordCount++;
                    }
                }
                DISPDBG((5, "NVSetPointerShape: 8bpp Cursor"));
            #else
                if(Nv8BppToHw16BppCursor(ppdev, ppdev->pPal, pxlo, cx, cy, 
                    pjSrcColor, pjSrcColorMask, pulDstScan, ulHwCursorWidth, 
                    lSrcDelta, lPitch)
                     == SPS_DECLINE)
                    return(SPS_DECLINE);
                ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                goto NvCursorDoneImage;
            #endif
                break;

            //******************************************************************
            // Screen is currently in 16bpp mode
            //******************************************************************
            case BMF_16BPP:
            #ifdef HW_SUPPORT_32BPP_XOR
            !!!  Will enable later on for new chip (NV20 and later)
            !!!  set new format for 32Bpp XOR function
            !!!  ulHwCursorFormat = NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8; 
                for (i = 0; i < cy; i++)
                {
                    ulMask = *(PULONG) (pjSrcColorMask + i*lSrcDelta);     // Get 8 AND bits
                    ulTest = 0x00000080;
                    ulDwordCount = 0;
                    for (k = 0; k < cx; k++, ulTest >>=1)
                    {
                       if (!(k & 7))
                           ulTest = 0x00000080 << k;

                       ulColor = *((PUSHORT) (pjSrcColor + i*lPitch + k*2)); // Get 16 bits of color
                       red   = (WORD)((ulColor & 0xf800) >> 11); // 5 bits
                       green = (WORD)((ulColor & 0x07e0) >> 5); // 6 bits
                       blue  = (WORD)(ulColor & 0x001f); // 5 bits
                       ulColor = (  (DWORD)(red << 16) | (green << 8) | (blue) );

                        if (!(ulTest & ulMask))
                            ulColor |= 0xff000000;      // Not transparent
                        else
                            ulColor = 0;                // transparent

                        *pulDstScan++ = ulColor;
                        ulDwordCount++;

                    }
                    // make HW happy, fill remaining DWORD to ulHwCursorWidth
                    while(ulDwordCount < ulHwCursorWidth)
                    {
                        *pulDstScan++ = 0x0;
                        ulDwordCount++;
                    }
                }
                DISPDBG((5, "NVSetPointerShape: 16bpp Cursor"));
            #else
                if(Nv16BppToHw16BppCursor(ppdev, cx, cy, pjSrcColor, pjSrcColorMask, 
                     lSrcDelta, lPitch,  pulDstScan,  ulHwCursorWidth, ppdev->flGreen)
                     == SPS_DECLINE)
                    return(SPS_DECLINE);
                ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                goto NvCursorDoneImage;
            #endif

                break;
            //******************************************************************
            // Screen is currently in 32bpp mode
            //******************************************************************
            case BMF_32BPP:
                if (ppdev->ulMaxHwCursorDepth >= 32) {
                    if(AlphaBlendedCursor) {
                        if (ppdev->bSupportAlphaCursor) {
                            // NV11, NV15 and up have full 32bit, alpha cursor support

                            for (i = 0; i < cy; i++) {
                                pulTemp = (ULONG *)(pjSrcColor + i * lPitch);
                                for (k = 0; k < cx; k++) {
                                    *pulDstScan++ =  *pulTemp++;
                                }
                                // make HW happy, fill remaining DWORD to ulHwCursorWidth
                                for( ; k < (LONG)ulHwCursorWidth; k++) {
                                    *pulDstScan++ = 0x0;
                                }
                            }
                            DISPDBG((5, "NVSetPointerShape: 32bpp Alpha Cursor"));
                        } else {
                            // If we have no alpha cursor support in hardware AND opengl 
                            // or an overlay is present, support the cursor in hardware
                            // by ignoring the alpha componenet.  This prevents the cursor
                            // from disappearing due to a GDI software cursor getting
                            // overwritten by opengl or the overlay.
                            if (globalOpenGLData.oglDrawableClientCount 
#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
                                || ppdev->pDriverData->vpp.dwOverlaySurfaces
#endif          
                                ) {
                                for (i = 0; i < cy; i++) {
                                    pulTemp = (ULONG *)(pjSrcColor + i * lPitch);
                                    for (k = 0; k < cx; k++) {
                                        ulAlpha = *pulTemp;
                                        ulAlpha >>= 24;
                                        // Removed Alpha Value
                                        if(ulAlpha == 0xFF) {
                                            ulColor = *pulTemp | 0xFF000000;
                                        } else {
                                            ulColor = 0x00000000;
                                        }
                                        *pulDstScan++ = ulColor;
                                        pulTemp++;
                                    }
                                    // make HW happy, fill remaining DWORD to ulHwCursorWidth
                                    for( ; k < (LONG)ulHwCursorWidth; k++) {
                                        *pulDstScan++ = 0x0;
                                    }
                                }                        
                            } else {
                                DISPDBG((5, "NVSetPointerShape: No 32bpp Alpha Support"));
                                return(SPS_DECLINE);
                            }
                            DISPDBG((5, "NVSetPointerShape: 32bpp Alpha Cursor w/ no alpha"));
                        }
                    } else {
                        // Regular 32 bit cursor
                        for (i = 0; i < cy; i++) {
                            lPixelCount = 0;
                            pulTemp = (ULONG *)(pjSrcColor + i * lPitch);
                            for (j = 0; j < cx ; j += 8) {
                                bMask = *(pjSrcColorMask + i*lSrcDelta + j / 8);  
                                bTest = 0x80;
                                for(k = 0; k < 8; k++, bTest >>= 1) {
                                    ulColor = *pulTemp++;

                                    if(!(bTest & bMask)) 
                                    {
                                        ulColor |= 0xFF000000;
                                    }
                                    else 
                                    {
                                	    if (ulColor == 0x00FFFFFF)
                    					{
                                            // inverted background color
                                            WORK_AROUND_NV11_DIRTHER;
                                            NvHw16BppCursor(cx, cy, pjSrcColor, pjSrcColorMask, lSrcDelta, lPitch,
                                                (ULONG*) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase), ulHwCursorWidth, AlphaBlendedCursor);
                                            ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                                            goto NvCursorDoneImage;
                    					}
					                    else 
                    					{
				                            // Transparent
                    						ulColor = 0;
					                    }
                                    }

                                    *pulDstScan++ = ulColor;

                                    lPixelCount++;
                                }
                            }
                            // make HW happy, fill remaining DWORD to ulHwCursorWidth
                            for( ; lPixelCount < (LONG)ulHwCursorWidth; lPixelCount++)
                            {
                                *pulDstScan++ = 0x0;
                            }
                        }
                        DISPDBG((5, "NVSetPointerShape: 32bpp Alpha Cursor w/ no alpha"));
                    }
                } 
                else 
                {
                    WORK_AROUND_NV11_DIRTHER;
                    NvHw16BppCursor(cx, cy, pjSrcColor, pjSrcColorMask, lSrcDelta, lPitch,
                        (ULONG*) (ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex] + ppdev->pjFrameBufbase), ulHwCursorWidth, AlphaBlendedCursor);
                    ulHwCursorFormat = NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5;
                    goto NvCursorDoneImage;
                }
                break;

             default:
                //**************************************************************
                // Can't handle any other bit depths
                //**************************************************************
                DISPDBG((5, "NVSetPointerShape: Unsupported bit depth"));
                return(SPS_DECLINE);

        }   // Switch
    } // psoColor != NULL

    for(; i < (LONG) ulHwCursorWidth; i++)
    {
        for(k = 0; k < (LONG) ulHwCursorWidth; k++)
        {
            *pulDstScan++ = 0x0;
        }
    }

NvCursorDoneImage:

    if(ulHwCursorWidth  != ppdev->ulCachedCursorWidth ||
       ulHwCursorFormat != ppdev->ulCachedCursorFormat)
    {
        DISPDBG((5, "NVSetPointerShape: Width or format changed.  Reloading."));
        NvSetPointerShapeToHw(ppdev,  ulHwCursorWidth, cy, ulHwCursorFormat);
    }
    else
    {
        volatile ULONG * pCursorAddress;
        ULONG ulCursorOffset;
        ULONG i, ulHead;
        
      	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
       	{
            ulHead = ppdev->ulDeviceDisplay[i];
            pCursorAddress = ppdev->NvBaseAddr + 0x0060080c / 4 + ((ulHead) * 0x2000/4);
            ulCursorOffset = ppdev->ulCursorMemOffset[ppdev->ulCursorCurBufIndex];
            *pCursorAddress = ulCursorOffset;
        }
        
    }
    ppdev->ulCursorCurBufIndex ^= 1;
	
    //**************************************************************************
    // Get HotSpot
    //**************************************************************************

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    ppdev->pfnMovePointer(ppdev, x, y);

    return(SPS_ACCEPT_NOEXCLUDE);

}


void __cdecl DisableHeadCursor(PDEV *ppdev, ULONG ulHead, ULONG ulDiable)
{
#if !USE_DMC_CURSOR
    DECLARE_DMA_FIFO;
    INIT_LOCAL_DMA_FIFO;
#endif

    if(ulDiable)
    {
#if USE_DMC_CURSOR
        SET_CURSOR_LOCATION(ppdev, ulHead, (ppdev->cxScreen + 64), (ppdev->cyScreen + 64));
#else        
        NV_DMAPUSH_CHECKFREE( ((ULONG)(10)));  
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ulHead);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CURSOR_POINT, ((ppdev->cxScreen + 64) & 0xffff) | ((ppdev->cyScreen + 64) << 16) );

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);
#endif        
    }
}

#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvdoublebuf.c ===
//******************************Module*Header*******************************
// Module Name: nvdoublebuf.c
//
// Double buffer, windowed full screen flipping support.
//
// Copyright (c) 1998 NVidia Corporation
//*************************************************************************

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "Nvcm.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvReg.h"
#include "cliplist.h"
#include "oglsync.h"

//
// Export:
//
#include "nvdoublebuf.h"


/*
#define DOUBLE_PASS(PROC) {                             \
    ULONG FirstBufferOffset = ppdev->CurrentDestOffset; \
    ppdev->DoubleBuffer.SavedProcs.PROC;                \
    if (ppdev->CurrentDestOffset <                      \
        (ppdev->ulPrimarySurfaceOffset +                \
         (ppdev->lDelta * ppdev->cyScreen))) {          \
            ppdev->pfnSetDestBase(ppdev, ppdev->DoubleBuffer.SecondBufferOffset + ppdev->CurrentDestOffset, ppdev->CurrentDestPitch); \
            ppdev->DoubleBuffer.SavedProcs.PROC;                                                           \
            ppdev->pfnSetDestBase(ppdev, FirstBufferOffset, ppdev->CurrentDestPitch);                      \
    }                                                                                                      \
}
*/
#define DBL_SRC  0x0001
#define DBL_DEST 0x0002
#define DBL_PSO  0x0004

#define NOPFN 0 // NOP function used as call prior to double pumped PROC

//*************************************************************************
// DOUBLE_PASS
// 
// macro to douple pump low level GDI functions to all buffers in 
// ppdev->DoubleBuffer.MultiBufferOffsets.
// 
// PSO          optional SURFOBJ*
//              NOTE: call macro with '0' if not used!
// PROC         function including parameter list that has to be called
// PREPROC      optional code called prior to the double pumped PROC
//              NOTE: call macro with 'NOPFN' if not used!
// RET_STRING   optional code that is placed in front of the PROC call
//              used to set return values.
//              NOTE: Call macro with ';' if not used!
// Examples: code below
//*************************************************************************
#define DOUBLE_PASS(PSO,PROC,PREPROC,RET_STRING) {           \
    int i;                                                   \
    unsigned int doubleFlags;                                \
    ULONG LastDestOffset = ppdev->CurrentDestOffset;         \
    ULONG LastSourceOffset = ppdev->CurrentSourceOffset;     \
    VOID  *LastPSOPtr = NULL;                                \
    if ((PSO) && ((SURFOBJ*)(PSO))->dhsurf) {                \
        LastPSOPtr = ((DSURF*)((SURFOBJ*)(PSO))->dhsurf)->LinearPtr; \
    }                                                        \
    doubleFlags = GetDoubleFlags(ppdev,(SURFOBJ*)(PSO));     \
    RET_STRING ppdev->DoubleBuffer.SavedProcs.PROC;          \
    for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {       \
        if (doubleFlags & DBL_SRC) {                         \
            ppdev->pfnSetSourceBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                  \
                LastSourceOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentSourcePitch);           \
        }                                                                                               \
        if (doubleFlags & DBL_DEST) {                                                                   \
            ppdev->pfnSetDestBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                    \
                LastDestOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentDestPitch);               \
        }                                                    \
        if (doubleFlags & DBL_PSO) {                         \
            (char *)((DSURF*)((SURFOBJ*)(PSO))->dhsurf)->LinearPtr = (char *) LastPSOPtr +              \
                ppdev->DoubleBuffer.MultiBufferOffsets[i] -  \
                ppdev->ulPrimarySurfaceOffset;               \
        }                                                    \
        if (doubleFlags & (DBL_DEST|DBL_PSO)) {              \
            PREPROC;                                         \
            RET_STRING ppdev->DoubleBuffer.SavedProcs.PROC;  \
        }                                                    \
    }                                                        \
    if (doubleFlags & DBL_SRC) {                             \
        ppdev->pfnSetSourceBase(ppdev, LastSourceOffset, ppdev->CurrentSourcePitch); \
    }                                                                                \
    if (doubleFlags & DBL_DEST) {                                                    \
        ppdev->pfnSetDestBase(ppdev, LastDestOffset, ppdev->CurrentDestPitch);       \
    }                                                                                \
    if (doubleFlags & DBL_PSO) {                                                     \
        ASSERTDD(NULL != LastPSOPtr, "Bad LastPSOPtr");                              \
        ((DSURF*)((SURFOBJ*)(PSO))->dhsurf)->LinearPtr = LastPSOPtr;                 \
    }                                                                                \
}

unsigned int GetDoubleFlags(PDEV* ppdev, SURFOBJ *pso)
{
    unsigned int doubleFlags = 0;
    NvU32        maxOffset;
    NvU32        newOffset;
    NvS32        delta;

    maxOffset = (ppdev->ulPrimarySurfaceOffset +                
                 (ppdev->lDelta * ppdev->cyScreen));

    if ((ppdev->CurrentSourceOffset >= ppdev->ulPrimarySurfaceOffset) &&
        (ppdev->CurrentSourceOffset < maxOffset)) {
        doubleFlags |= DBL_SRC;
    }
    if ((ppdev->CurrentDestOffset >= ppdev->ulPrimarySurfaceOffset) &&
        (ppdev->CurrentDestOffset < maxOffset)) {
        doubleFlags |= DBL_DEST;
    }
    // If only the source offset is inside of the primary
    // surface while the destination offset is offscreen, then
    // we have to make sure that we blit from memory that 
    // is actually onscreen since OpenGL may
    // have flipped the visible surface.  PaulP 10/11/2000
    if (doubleFlags == DBL_SRC) {
        if (OGL_FLIPPED()) {
            // The visible surface is flipped to the backbuffer
            // Need to set the source to the backbuffer.
            delta = ppdev->ulFlipBase - ppdev->ulPrimarySurfaceOffset;
            newOffset = ppdev->CurrentSourceOffset + delta;
            ppdev->pfnSetSourceBase(ppdev, newOffset, ppdev->CurrentSourcePitch);
        }
    }
    if (pso && pso->dhsurf) {
        VOID *LinearPtr = ((DSURF*)pso->dhsurf)->LinearPtr;
        if (((PUCHAR)LinearPtr >= ppdev->pjScreen) &&
            ((PUCHAR)LinearPtr < ppdev->pjFrameBufbase + maxOffset)) {
            doubleFlags |= DBL_PSO;
        }
    }

    return doubleFlags;
}

VOID NVDmaPushFillSolid_DBLBUF(       // Type FNFILL
    PDEV*           ppdev,
    LONG            c,              // Can't be zero
    RECTL*          prcl,           // List of rectangles to be filled, in relative
                                    //   coordinates
    ULONG           rop4,           // rop4
    RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
    POINTL*         pptlBrush)      // Not used

{
    DOUBLE_PASS(0,pfnFillSolid(ppdev, c, prcl, rop4, rbc, pptlBrush),NOPFN,;);
}


VOID NVDmaPushFillPatFast_DBLBUF(            // Type FNFILL
    PDEV*           ppdev,
    LONG            c,              // Can't be zero
    RECTL*          prcl,           // List of rectangles to be filled, in relative
                                    //   coordinates
    ULONG           rop4,           // rop4
    RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
    POINTL*         pptlBrush)      // Pattern alignment

{
    DOUBLE_PASS(0,pfnFillPat(ppdev, c, prcl, rop4, rbc, pptlBrush),NOPFN,;);
}


VOID NVDmaPushXfer1bpp_DBLBUF(       // Type FNXFER
    PDEV*       ppdev,
    LONG        c,          // Count of rectangles, can't be zero
    RECTL*      prcl,       // List of destination rectangles, in relative
                            //   coordinates
    ROP4        rop4,       // rop4
    SURFOBJ*    psoSrc,     // Source surface
    POINTL*     pptlSrc,    // Original unclipped source point
    RECTL*      prclDst,    // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,     // Solid Color of pattern
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer1bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushXfer4bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,          // Count of rectangles, can't be zero
    RECTL*      prcl,       // Array of relative coordinates destination rectangles
    ROP4        rop4,       // rop4
    SURFOBJ*    psoSrc,     // Source surface
    POINTL*     pptlSrc,    // Original unclipped source point
    RECTL*      prclDst,    // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,
    BLENDOBJ*   pBlendObj)  // Not used
{
    DOUBLE_PASS(0,pfnXfer4bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushXferNative_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,          // Count of rectangles, can't be zero
    RECTL*      prcl,       // Array of relative coordinates destination rectangles
    ROP4        rop4,       // rop4
    SURFOBJ*    psoSrc,     // Source surface
    POINTL*     pptlSrc,    // Original unclipped source point
    RECTL*      prclDst,    // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,
    BLENDOBJ*   pBlendObj)  // Not used
{
    DOUBLE_PASS(0,pfnXferNative(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
/*    {                       
        unsigned int i, doubleFlags;                             
        ULONG LastDestOffset = ppdev->CurrentDestOffset;         
        ULONG LastSourceOffset = ppdev->CurrentSourceOffset;     
        doubleFlags = GetDoubleFlags(ppdev);                     
        ppdev->DoubleBuffer.SavedProcs.pfnXferNative(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj);                     
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {       
            if (doubleFlags & DBL_SRC) {                         
                ppdev->pfnSetSourceBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                  
                    LastSourceOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentSourcePitch); 
            }                                                                                               
            if (doubleFlags & DBL_DEST) {                                                                   
                ppdev->pfnSetDestBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                    
                    LastDestOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentDestPitch);     
            }                                                    
            if (doubleFlags & DBL_DEST) {                                   
                ppdev->DoubleBuffer.SavedProcs.pfnXferNative(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj);  
            }                                                    
        }                                                        
        if (doubleFlags & DBL_SRC) {                             
            ppdev->pfnSetSourceBase(ppdev, LastSourceOffset, ppdev->CurrentSourcePitch); 
        }                                                                                
        if (doubleFlags & DBL_DEST) {                                                    
            ppdev->pfnSetDestBase(ppdev, LastDestOffset, ppdev->CurrentDestPitch);       
        }                                                                                
    }
    */
}


VOID NVDmaPushCopyBlt_DBLBUF(    // Type FNCOPY
    PDEV*   ppdev,
    LONG    c,          // Can't be zero
    RECTL*  prcl,       // Array of relative coordinates destination rectangles
    ULONG   rop4,       // rop4
    POINTL* pptlSrc,    // Original unclipped source point
    RECTL*  prclDst,    // Original unclipped destination rectangle
    BLENDOBJ *pBlendObj)
{
    DOUBLE_PASS(0,pfnCopyBlt(ppdev, c, prcl, rop4, pptlSrc, prclDst, pBlendObj),NOPFN,;);
/*    {                       
        unsigned int i, doubleFlags;                             
        ULONG LastDestOffset = ppdev->CurrentDestOffset;         
        ULONG LastSourceOffset = ppdev->CurrentSourceOffset;     
        doubleFlags = GetDoubleFlags(ppdev);                     
        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, c, prcl, rop4, pptlSrc, prclDst, pBlendObj);                     
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {       
            if (doubleFlags & DBL_SRC) {                         
                ppdev->pfnSetSourceBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                  
                    LastSourceOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentSourcePitch); 
            }                                                                                               
            if (doubleFlags & DBL_DEST) {                                                                   
                ppdev->pfnSetDestBase(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i] +                    
                    LastDestOffset - ppdev->ulPrimarySurfaceOffset, ppdev->CurrentDestPitch);     
            }                                                    
            if (doubleFlags & DBL_DEST) {                                   
                ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, c, prcl, rop4, pptlSrc, prclDst, pBlendObj);  
            }                                                    
        }                                                        
        if (doubleFlags & DBL_SRC) {                             
            ppdev->pfnSetSourceBase(ppdev, LastSourceOffset, ppdev->CurrentSourcePitch); 
        }                                                                                
        if (doubleFlags & DBL_DEST) {                                                    
            ppdev->pfnSetDestBase(ppdev, LastDestOffset, ppdev->CurrentDestPitch);       
        }                                                                                
    }
*/
}


VOID NVDmaPushXfer4to16bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern - NOT USED
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer4to16bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}



VOID NVDmaPushXfer8to16bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern - NOT USED
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer8to16bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushXfer4to32bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern - NOT USED
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer4to32bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}



VOID NVDmaPushXfer8to32bpp_DBLBUF(     // Type FNXFER
    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern - NOT USED
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnXfer8to32bpp(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushFastXfer8to32_DBLBUF(   // Type FastXFER
    PDEV*       ppdev,
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    XLATEOBJ*   pxlo)
{
    DOUBLE_PASS(0,pfnFastXfer8to32(ppdev, prcl, psoSrc, pptlSrc,pxlo),NOPFN,;);
}


VOID NVDmaPushFastXfer8to16_DBLBUF(   // Type FastXFER
    PDEV*       ppdev,
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    XLATEOBJ*   pxlo)
{
    DOUBLE_PASS(0,pfnFastXfer8to16(ppdev, prcl, psoSrc, pptlSrc,pxlo),NOPFN,;);
}

VOID NVDmaPushIndexedImage_DBLBUF(    // Type FNXFER

    PDEV*       ppdev,
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      prcl,               // Array of relative coordinates destination rectangles
    ROP4        rop4,               // rop4
    SURFOBJ*    psoSrc,             // Source surface
    POINTL*     pptlSrc,            // Original unclipped source point
    RECTL*      prclDst,            // Original unclipped destination rectangle
    XLATEOBJ*   pxlo,
    ULONG       PatternColor,       // Solid Color of pattern
    BLENDOBJ*   pBlendObj)
{
    DOUBLE_PASS(0,pfnIndexedImage(ppdev, c, prcl, rop4, psoSrc, pptlSrc, prclDst, pxlo, PatternColor, pBlendObj),NOPFN,;);
}


VOID NVDmaPushMemToScreenBlt_DBLBUF(
    PDEV*   ppdev,
    SURFOBJ* psoSrc,
    POINTL* pptlSrc,
    RECTL*  prclDst)
{
    DOUBLE_PASS(0,pfnMemToScreenBlt(ppdev, psoSrc, pptlSrc, prclDst),NOPFN,;);
}

VOID NVDmaPushMemToScreenWithPatternBlt_DBLBUF(
    PDEV*   ppdev,
    SURFOBJ* psoSrc,
    POINTL* pptlSrc,
    RECTL*  prclDst,
    ULONG rop3,
    RBRUSH_COLOR   *rbc,
    RECTL*  prclClip)
{
    DOUBLE_PASS(0,pfnMemToScreenPatternBlt(ppdev, psoSrc, pptlSrc, prclDst, rop3, rbc, prclClip),NOPFN,;);
}


BOOL NVDmaPushTextOut_DBLBUF(
    SURFOBJ*  pso,
    STROBJ*   pstro,
    FONTOBJ*  pfo,
    CLIPOBJ*  pco,
    RECTL*    prclOpaque,
    BRUSHOBJ* pboFore,
    BRUSHOBJ* pboOpaque)
{
    PDEV*  ppdev;
    BOOL retval;
    
    ppdev = (PDEV*) pso->dhpdev;

    // need to reset STROBJ in the case it was enumerated but not started properly
    DOUBLE_PASS(0,pfnTextOut(pso, pstro, pfo, pco, prclOpaque, pboFore, pboOpaque),STROBJ_vEnumStart(pstro),retval =);
    return retval;
}


//
//  Function bFlippingBufferAdjustPass
//
//  Function sets psoSrc-bufferoffset to ICD's frontbuffer if psoSrc
//  is our Primary and calls unflipped function
//
//  return value: return value of given  unflipped function
//
//  MSchwarzer 12/10/2000: new
//
BOOL bFlippingBufferAdjustPass( 
    FNSCRNTOMEM*    pfnScreenToMem,
    PDEV*           ppdev,
    LONG            c,
    RECTL*          prcl,
    SURFOBJ*        psoSrc,
    SURFOBJ*        psoDst,
    POINTL*         pptlSrc,
    RECTL*          prclDst,
    XLATEOBJ*       pxlo)
{
    BOOL bRet;
    PVOID pvLastSourceOffset;

    ASSERT(ppdev);
    ASSERT(psoSrc);
    ASSERT(psoSrc->dhsurf);     // Src is our Screen => we have an dhsurf !
    ASSERT(pfnScreenToMem);

    pvLastSourceOffset = ((DSURF*)psoSrc->dhsurf)->LinearPtr;

    // do we blt from Primary ?
    // if( STYPE_DEVICE == psoSrc->iType ) //: another possibility to test
    if(pvLastSourceOffset == ppdev->pjScreen)
    {
        if(OGL_FLIPPED()) 
        {
            // The visible surface is flipped to the backbuffer => set the source to the backbuffer.
            ((DSURF*)psoSrc->dhsurf)->LinearPtr = ppdev->pjScreen + ppdev->ulFlipBase;
        }
    }

    bRet = pfnScreenToMem(ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    // reset base of PSO
    ((DSURF*)psoSrc->dhsurf)->LinearPtr = pvLastSourceOffset;

    return bRet;
}


//
//  Function NVScreenTo1bppMemBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenTo1bppMemBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenTo1bppMemBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenTo1bppMemBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenTo1bppMemBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMemBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMemBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMemBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMemBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMemBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMem16to4bppBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMem16to4bppBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMem16to4bppBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMem16to4bppBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to4bppBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMem16to4bppBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to4bppBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMem32to4bppBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMem32to4bppBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMem32to4bppBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMem32to4bppBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to4bppBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMem32to4bppBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to4bppBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMem16to8bppBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMem16to8bppBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMem16to8bppBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMem16to8bppBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to8bppBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMem16to8bppBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to8bppBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}

//
//  Function NVScreenToMem32to8bppBlt_DBLBUF
//
//  Function is the wrapper of NV4ScreenToMem32to8bppBlt for flipped doublepumped  
//  mode to set the psoSrc bufferoffset to ICD's frontbuffer
//
//  return value: return value of given  unflipped function (NV4ScreenToMem32to8bppBlt)
//
//  MSchwarzer 12/10/2000: new
//
BOOL NVScreenToMem32to8bppBlt_DBLBUF(
    PDEV     *ppdev,
    LONG      c,                  // Count of rectangles, can't be zero
    RECTL    *prcl,               // List of destination rectangles, in relative
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoDst,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    XLATEOBJ *pxlo)               // Provides colour-compressions information
{
    BOOL retval;

    ASSERT(ppdev);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to8bppBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt!=NVScreenToMem32to8bppBlt_DBLBUF);
    
    retval = bFlippingBufferAdjustPass( ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to8bppBlt, ppdev, c, prcl, psoSrc, psoDst, pptlSrc, prclDst, pxlo);

    return retval;
}



VOID NVScreenToScreenWithPatBlt_DBLBUF(
    
    PDEV*       ppdev,              // PDEV associated with the SRC device
    LONG        c,                  // Count of rectangles, can't be zero
    RECTL*      parcl,              // Array of destination rectangles (inside prclDst)
    POINTL*     pptlSrc,            // Upper left corner of SRC retcl in SRC surface
    RECTL*      prclDst,            // Rectangle to be modified in the DST surface
    BRUSHOBJ*   pbo,                // Brush object
    POINTL*     pptlBrush,          // Brush start coordinate in the pattern bits.
    ROP4        rop4)               // Op that describes the blit (must be 1 byte max)
{
    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->DoubleBuffer.SavedProcs.pfnScreenToScreenWithPatBlt);
    ASSERT(ppdev->DoubleBuffer.SavedProcs.pfnScreenToScreenWithPatBlt != NVScreenToScreenWithPatBlt_DBLBUF);

    DOUBLE_PASS(0,pfnScreenToScreenWithPatBlt(ppdev, c, parcl, pptlSrc, prclDst, pbo, pptlBrush, rop4),NOPFN,;);
}



BOOL NVDmaPushStrokePath_DBLBUF(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    PDEV*  ppdev;
    BOOL retval;
    
    ppdev = (PDEV*) pso->dhpdev;

    // need to reset PATHOBJ in the case it was enumerated but not started properly
    DOUBLE_PASS(pso,pfnStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix),PATHOBJ_vEnumStart(ppo),retval =);
    return retval;
}


BOOL NVDmaPushLineTo_DBLBUF(
    SURFOBJ*    pso,
    CLIPOBJ*    pco,
    BRUSHOBJ*   pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL*      prclBounds,
    MIX         mix)
{
    PDEV*  ppdev;
    BOOL retval;

    ppdev = (PDEV*) pso->dhpdev;
    
    DOUBLE_PASS(0,pfnLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix),NOPFN,retval =);
    return TRUE;
}

static unsigned int 
GetEngDoubleFlags(PDEV *ppdev, 
                  SURFOBJ *psoSrc, SURFOBJ *psoDst,
                  PVOID *oldSrcBits, PVOID *oldSrcScan,
                  PVOID *oldDstBits, PVOID *oldDstScan)
{
    unsigned int  doubleFlags = 0;
    NvU32         maxOffset;
    NvS32         delta;

    if (ppdev == NULL) {
        return doubleFlags;
    }

    maxOffset = (ppdev->ulPrimarySurfaceOffset +                
                 (ppdev->cyScreen * ppdev->lDelta ));
    
    // Check if destination is within the front screen
    // Now using pvScan0 instead of pvBits because Eng is using it, too. Had a bluescreen because
    // our code didn't set up pso->pvBits correctly.
    if (psoDst && ((PUCHAR)psoDst->pvScan0 >= ppdev->pjScreen) &&   /***********/
        ((PUCHAR)psoDst->pvScan0 <  ppdev->pjFrameBufbase + maxOffset)) {
        doubleFlags |= DBL_DEST;
        *oldDstBits = psoDst->pvBits;
        *oldDstScan = psoDst->pvScan0;
    }

    // Check if source is within the front screen
    if (psoSrc && ((PUCHAR)psoSrc->pvScan0 >= ppdev->pjScreen) &&
        ((PUCHAR)psoSrc->pvScan0 <  ppdev->pjFrameBufbase + maxOffset)) {
        doubleFlags |= DBL_SRC;
        *oldSrcBits = psoSrc->pvBits;
        *oldSrcScan = psoSrc->pvScan0;
    }
    // If only the source offset is inside of the primary
    // surface while the destination offset is offscreen, then
    // we have to make sure that we blit from memory that 
    // is actually onscreen since OpenGL may
    // have flipped the visible surface.  PaulP 10/11/2000
    if (doubleFlags == DBL_SRC) {
        if (OGL_FLIPPED()) {
            // The visible surface is flipped to the backbuffer
            // Need to set the source to the backbuffer.
            delta = ppdev->ulFlipBase - ppdev->ulPrimarySurfaceOffset;
            (char *) psoSrc->pvBits  += delta;
            (char *) psoSrc->pvScan0 += delta;
        }
    }
    return doubleFlags;
}


#define ENG_DOUBLE_PASS(PROC,PREPROC,RET_STRING) {           \
    int i;                                                   \
    unsigned int doubleFlags;                                \
    PVOID oldSrcBits, oldSrcScan;                            \
    PVOID oldDstBits, oldDstScan;                            \
    doubleFlags = GetEngDoubleFlags(ppdev,psoSrc,psoDst,&oldSrcBits,&oldSrcScan,&oldDstBits,&oldDstScan);     \
    RET_STRING PROC;                                         \
    if (ppdev != NULL) {                                     \
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {   \
            if (doubleFlags & DBL_SRC) {                                                                      \
                (char *) psoSrc->pvBits = (char *) oldSrcBits + ppdev->DoubleBuffer.MultiBufferOffsets[i] -   \
                    ppdev->ulPrimarySurfaceOffset;                                                            \
                (char *) psoSrc->pvScan0 = (char *) oldSrcScan + ppdev->DoubleBuffer.MultiBufferOffsets[i] -  \
                    ppdev->ulPrimarySurfaceOffset;                                                            \
            }                                                                                                 \
            if (doubleFlags & DBL_DEST) {                                                                     \
                (char *) psoDst->pvBits = (char *) oldDstBits + ppdev->DoubleBuffer.MultiBufferOffsets[i] -   \
                    ppdev->ulPrimarySurfaceOffset;                                                            \
                (char *) psoDst->pvScan0 = (char *) oldDstScan + ppdev->DoubleBuffer.MultiBufferOffsets[i] -  \
                    ppdev->ulPrimarySurfaceOffset;                                                            \
            }                                                \
            if (doubleFlags & DBL_DEST) {                    \
                PREPROC;                                     \
                RET_STRING PROC;                             \
            }                                                \
        }                                                    \
        if (doubleFlags & DBL_SRC) {                         \
            psoSrc->pvBits  = oldSrcBits;                    \
            psoSrc->pvScan0 = oldSrcScan;                    \
        }                                                    \
        if (doubleFlags & DBL_DEST) {                        \
            psoDst->pvBits  = oldDstBits;                    \
            psoDst->pvScan0 = oldDstScan;                    \
        }                                                    \
    }                                                        \
}


BOOL APIENTRY NV_EngBitBlt_DBLBUF(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    
    ENG_DOUBLE_PASS(EngBitBlt(psoDst,psoSrc,psoMask,pco,pxlo,prclTrg,pptlSrc,pptlMask,pbo,pptlBrush,rop4),NOPFN,retval &=);

    return retval;
}

BOOL APIENTRY NV_EngCopyBits_DBLBUF(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDest,
    POINTL   *pptlSrc)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    
    ENG_DOUBLE_PASS(EngCopyBits(psoDst,psoSrc,pco,pxlo,prclDest,pptlSrc),NOPFN,retval &=);

    return retval;
}

BOOL APIENTRY NV_EngTextOut_DBLBUF(
    SURFOBJ  *psoDst,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    SURFOBJ   *psoSrc = NULL;

    // need to reset STROBJ in the case it was enumerated but not started properly
    ENG_DOUBLE_PASS(EngTextOut(psoDst,pstro,pfo,pco,prclExtra,prclOpaque,pboFore,pboOpaque,pptlOrg,mix),STROBJ_vEnumStart(pstro),retval &=);

    return retval;
}

BOOL APIENTRY NV_EngStrokePath_DBLBUF(
    SURFOBJ   *psoDst,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX        mix)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    SURFOBJ   *psoSrc = NULL;
    
    // need to reset PATHOBJ in the case it was enumerated but not started properly
    ENG_DOUBLE_PASS(EngStrokePath(psoDst,ppo,pco,pxo,pbo,pptlBrushOrg,plineattrs,mix),PATHOBJ_vEnumStart(ppo),retval &=);

    return retval;
}

BOOL APIENTRY NV_EngLineTo_DBLBUF(
    SURFOBJ   *psoDst,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    SURFOBJ   *psoSrc = NULL;
    
    ENG_DOUBLE_PASS(EngLineTo(psoDst,pco,pbo,x1,y1,x2,y2,prclBounds,mix),NOPFN,retval &=);

    return retval;
}

#if _WIN32_WINNT >= 0x0500
BOOL APIENTRY NV_EngAlphaBlend_DBLBUF(
    SURFOBJ       *psoDst,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    
    ENG_DOUBLE_PASS(EngAlphaBlend(psoDst,psoSrc,pco,pxlo,prclDest,prclSrc,pBlendObj),NOPFN,retval &=);

    return retval;
    
}

BOOL APIENTRY NV_EngTransparentBlt_DBLBUF(
    SURFOBJ       *psoDst,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    ULONG         iTransColor,
    ULONG         Reserved)
{
    BOOL      retval = TRUE;
    PDEV*     ppdev = (PDEV*) psoDst->dhpdev;
    
    ENG_DOUBLE_PASS(EngTransparentBlt(psoDst,psoSrc,pco,pxlo,prclDest,prclSrc,iTransColor,Reserved),NOPFN,retval &=);

    return retval;
    
}
#endif


//*************************************************************************
// NV_InitDoubleBufferSavedProcs
// 
// Initialize the SaveProcs structure with all non double pumping 
// hardware functions.
//*************************************************************************
VOID NV_InitDoubleBufferSavedProcs(PPDEV ppdev)
{
    ASSERT(NULL!=ppdev);
    ASSERT(NULL!=ppdev->pfnFillSolid);

    ppdev->DoubleBuffer.SavedProcs.pfnFillSolid              = ppdev->pfnFillSolid;
    ppdev->DoubleBuffer.SavedProcs.pfnFillPat                = ppdev->pfnFillPat;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer1bpp               = ppdev->pfnXfer1bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer4bpp               = ppdev->pfnXfer4bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXferNative             = ppdev->pfnXferNative;
    ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt                = ppdev->pfnCopyBlt;
                                               
    ppdev->DoubleBuffer.SavedProcs.pfnXfer4to16bpp           = ppdev->pfnXfer4to16bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer8to16bpp           = ppdev->pfnXfer8to16bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer4to32bpp           = ppdev->pfnXfer4to32bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnXfer8to32bpp           = ppdev->pfnXfer8to32bpp;
    ppdev->DoubleBuffer.SavedProcs.pfnFastXfer8to32          = ppdev->pfnFastXfer8to32;
    ppdev->DoubleBuffer.SavedProcs.pfnFastXfer8to16          = ppdev->pfnFastXfer8to16;
    ppdev->DoubleBuffer.SavedProcs.pfnIndexedImage           = ppdev->pfnIndexedImage;
                                               
    ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt         = ppdev->pfnMemToScreenBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenPatternBlt  = ppdev->pfnMemToScreenPatternBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnTextOut                = ppdev->pfnTextOut;
    ppdev->DoubleBuffer.SavedProcs.pfnSetPalette             = ppdev->pfnSetPalette;           
                                               
    ppdev->DoubleBuffer.SavedProcs.pfnStrokePath             = ppdev->pfnStrokePath;
    ppdev->DoubleBuffer.SavedProcs.pfnLineTo                 = ppdev->pfnLineTo;

    ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt     = ppdev->pfnScreenTo1BppMemBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt         = ppdev->pfnScreenToMemBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to4bppBlt = ppdev->pfnScreenToMem16to4bppBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to4bppBlt = ppdev->pfnScreenToMem32to4bppBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to8bppBlt = ppdev->pfnScreenToMem16to8bppBlt;
    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to8bppBlt = ppdev->pfnScreenToMem32to8bppBlt;

    ppdev->DoubleBuffer.SavedProcs.pfnScreenToScreenWithPatBlt = ppdev->pfnScreenToScreenWithPatBlt;
}


//*************************************************************************
// NV_CopyPrimaryToDoubleBuffer
// 
// Copy entire screen from primary to fullscreen surface with given offset.
//*************************************************************************
VOID NV_CopyPrimaryToDoubleBuffer(
    PPDEV ppdev, 
    ULONG ulSurfaceOffset)
{
    POINTL  ptlSrc;
    RECTL   rcl;

    ASSERT(NULL!=ppdev);
    ASSERT(ppdev->ulPrimarySurfaceOffset!=ulSurfaceOffset);

    // First copy the front buffer to the multi buffers
    rcl.left   = 0;
    rcl.top    = 0;
    rcl.right  = ppdev->cxScreen;
    rcl.bottom = ppdev->cyScreen;
    ptlSrc.x   = 0;
    ptlSrc.y   = 0;

    OglSyncEngineUsingPDEV(ppdev);

    ppdev->pfnSetSourceBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);

    // Hmm, can we assume that our dest surface has the same stride as the primary?
    ppdev->pfnSetDestBase(ppdev, ulSurfaceOffset, ppdev->lDelta);

    //
    // We only copy the GDI to the other buffers, not the OpenGL client which 
    // already might have a different content!
    //

    if (   (ppdev->OglNegativeClipList.c > 0)
        && (ulSurfaceOffset == ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]) )
    {
        DISPDBG((3, "NV_CopyPrimaryToDoubleBuffer: copy %d exclusive primary to 0x%x", ppdev->OglNegativeClipList.c, ulSurfaceOffset));

        ASSERT(ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC);
        ASSERT(bClipListCheck(&ppdev->OglNegativeClipList));
        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, ppdev->OglNegativeClipList.c, ppdev->OglNegativeClipList.prcl, 0xcccc, &ptlSrc, &rcl, NULL);
    }
    else
    {
        DISPDBG((3, "NV_CopyPrimaryToDoubleBuffer: copy primary to 0x%x", ulSurfaceOffset));
        // This will copy the entire screen to the back or other buffers
        // destroying their content. Visible backs are overwritten!
        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, &rcl, 0xcccc, &ptlSrc, &rcl, NULL);
    }

    // finish blit
    ppdev->pfnWaitEngineBusy(ppdev);
}


//*************************************************************************
// NV_ClearDoubleBuffer
// 
// Clear entire fullscreen surface with given offset.
//*************************************************************************
VOID NV_ClearDoubleBuffer(
    PPDEV ppdev, 
    ULONG ulSurfaceOffset)
{
    RECTL   rcl;
    RBRUSH_COLOR rbc = {0};        // Realized brush or solid colour

    ASSERT(NULL!=ppdev);
    ASSERT(ppdev->ulPrimarySurfaceOffset!=ulSurfaceOffset); // never want to clear primary

    // First copy the front buffer to the multi buffers
    rcl.left   = 0;
    rcl.top    = 0;
    rcl.right  = ppdev->cxScreen;
    rcl.bottom = ppdev->cyScreen;

    rbc.iSolidColor = 0;

    // Hmm, can we assume that our dest surface has the same stride as the primary?
    ppdev->pfnSetDestBase(ppdev, ulSurfaceOffset, ppdev->lDelta);
    if (ppdev->OglNegativeClipList.c > 0)
    {
        ASSERT(bClipListCheck(&ppdev->OglNegativeClipList));
        ppdev->DoubleBuffer.SavedProcs.pfnFillSolid(ppdev, ppdev->OglNegativeClipList.c, ppdev->OglNegativeClipList.prcl, 0xF0F0, rbc, NULL);
    }
    else
    {
        ppdev->DoubleBuffer.SavedProcs.pfnFillSolid(ppdev, 1, &rcl, 0xF0F0, rbc, NULL);
    }

    // finish blit
    ppdev->pfnWaitEngineBusy(ppdev);
}



//*************************************************************************
// NV_InitDoubleBufferMode
// 
// Initializes double buffer mode for the given buffers and resets the 
// function pointer list to DBLBUF functions.
//*************************************************************************
void NV_InitDoubleBufferMode(PDEV *ppdev, LONG NumBuffers, ULONG *MultiBufferOffsets)
{
    LONG    i;
    POINTL  ptlSrc;
    RECTL   prclDst;
    RECTL   rcl;
    DWORD   dwStatus;

    ASSERT(NULL != ppdev);
    ASSERT(0 != NumBuffers);
    ASSERT(NULL != MultiBufferOffsets);
    ASSERT(!ppdev->DoubleBuffer.bEnabled);

    if (ppdev->DoubleBuffer.bEnabled) {
        return;
    }

    ASSERT(0 == ppdev->DoubleBuffer.NumBuffers);

    ppdev->DoubleBuffer.bEnabled = TRUE;

    if (NumBuffers > NV_MAX_BUFFERS) {
        ASSERTDD(NumBuffers <= NV_MAX_BUFFERS,"Too many buffers");
        NumBuffers = NV_MAX_BUFFERS;
    }

    ppdev->DoubleBuffer.NumBuffers = NumBuffers;

    // need this buffer to exchange front to back when disabling flippingmode
    NVHEAP_ALLOC(dwStatus, ppdev->ulTempOffscreenBufferOffset, ppdev->lDelta, TYPE_IMAGE);
    if(dwStatus==0)
        ppdev->ulTempOffscreenBufferSize = ppdev->lDelta;
    else
    {
        ppdev->ulTempOffscreenBufferSize = 0;
        DISPDBG((0,"could not allocate temporary offscreen buffer in NV_InitDoubleBufferMode"));
    }

    for (i=0; i<NumBuffers; i++) {
        ASSERT(MultiBufferOffsets[i] != ppdev->ulPrimarySurfaceOffset);
        ppdev->DoubleBuffer.MultiBufferOffsets[i] = MultiBufferOffsets[i];
        NV_CopyPrimaryToDoubleBuffer(ppdev, MultiBufferOffsets[i]);
    }

    // Initialize save SavedProcs
    NV_InitDoubleBufferSavedProcs(ppdev);

    ppdev->pfnFillSolid              = NVDmaPushFillSolid_DBLBUF;
    ppdev->pfnFillPat                = NVDmaPushFillPatFast_DBLBUF;
    ppdev->pfnXfer1bpp               = NVDmaPushXfer1bpp_DBLBUF;   
    ppdev->pfnXfer4bpp               = NVDmaPushXfer4bpp_DBLBUF;   
    ppdev->pfnXferNative             = NVDmaPushXferNative_DBLBUF; 
    ppdev->pfnCopyBlt                = NVDmaPushCopyBlt_DBLBUF;    
                                                              
    ppdev->pfnXfer4to16bpp           = NVDmaPushXfer4to16bpp_DBLBUF; 
    ppdev->pfnXfer8to16bpp           = NVDmaPushXfer8to16bpp_DBLBUF; 
    ppdev->pfnXfer4to32bpp           = NVDmaPushXfer4to32bpp_DBLBUF; 
    ppdev->pfnXfer8to32bpp           = NVDmaPushXfer8to32bpp_DBLBUF; 
    ppdev->pfnFastXfer8to32          = NVDmaPushFastXfer8to32_DBLBUF; 
    ppdev->pfnFastXfer8to16          = NVDmaPushFastXfer8to16_DBLBUF; 
    ppdev->pfnIndexedImage           = NVDmaPushIndexedImage_DBLBUF;
                                                              
    ppdev->pfnMemToScreenBlt         = NVDmaPushMemToScreenBlt_DBLBUF;           
    ppdev->pfnMemToScreenPatternBlt  = NVDmaPushMemToScreenWithPatternBlt_DBLBUF;
    ppdev->pfnTextOut                = NVDmaPushTextOut_DBLBUF;
                                                              
    ppdev->pfnStrokePath             = NVDmaPushStrokePath_DBLBUF;
    ppdev->pfnLineTo                 = NVDmaPushLineTo_DBLBUF;

    ppdev->pfnScreenTo1BppMemBlt     = NVScreenTo1bppMemBlt_DBLBUF;
    ppdev->pfnScreenToMemBlt         = NVScreenToMemBlt_DBLBUF;
    ppdev->pfnScreenToMem16to4bppBlt = NVScreenToMem16to4bppBlt_DBLBUF;     
    ppdev->pfnScreenToMem32to4bppBlt = NVScreenToMem32to4bppBlt_DBLBUF;     
    ppdev->pfnScreenToMem16to8bppBlt = NVScreenToMem16to8bppBlt_DBLBUF;     
    ppdev->pfnScreenToMem32to8bppBlt = NVScreenToMem32to8bppBlt_DBLBUF;     

    ppdev->pfnScreenToScreenWithPatBlt = NVScreenToScreenWithPatBlt_DBLBUF;

    ppdev->pfnEngBitBlt     = NV_EngBitBlt_DBLBUF;
    ppdev->pfnEngCopyBits   = NV_EngCopyBits_DBLBUF;
    ppdev->pfnEngTextOut    = NV_EngTextOut_DBLBUF;
    ppdev->pfnEngLineTo     = NV_EngLineTo_DBLBUF;
    ppdev->pfnEngStrokePath = NV_EngStrokePath_DBLBUF;
#if _WIN32_WINNT >= 0x0500
    ppdev->pfnEngAlphaBlend = NV_EngAlphaBlend_DBLBUF;
    ppdev->pfnEngTransparentBlt = NV_EngTransparentBlt_DBLBUF;
#endif
}


//*************************************************************************
// NV_DisableDoubleBufferMode
// 
// disables double pumping to all buffers, restores function pointers
//*************************************************************************
void NV_DisableDoubleBufferMode(PDEV *ppdev)
{
    ASSERT(NULL != ppdev);

    if (!ppdev->DoubleBuffer.bEnabled) {
        return;
    }
    ppdev->DoubleBuffer.bEnabled = FALSE;

    ASSERT(0!=ppdev->DoubleBuffer.NumBuffers);

#if DBG
    {
        LONG i;
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) {
            NV_ClearDoubleBuffer(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i]);
        }
    }
#endif

    ppdev->DoubleBuffer.NumBuffers = 0;

    // free temporary doublebuffer-tempbuffer
    if(0!=ppdev->ulTempOffscreenBufferSize)
        NVHEAP_FREE(ppdev->ulTempOffscreenBufferOffset);
    ppdev->ulTempOffscreenBufferSize   = 0;
    ppdev->ulTempOffscreenBufferOffset = 0;

    ppdev->pfnFillSolid              = ppdev->DoubleBuffer.SavedProcs.pfnFillSolid              ;
    ppdev->pfnFillPat                = ppdev->DoubleBuffer.SavedProcs.pfnFillPat                ;
    ppdev->pfnXfer1bpp               = ppdev->DoubleBuffer.SavedProcs.pfnXfer1bpp               ;
    ppdev->pfnXfer4bpp               = ppdev->DoubleBuffer.SavedProcs.pfnXfer4bpp               ;
    ppdev->pfnXferNative             = ppdev->DoubleBuffer.SavedProcs.pfnXferNative             ;
    ppdev->pfnCopyBlt                = ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt                ;
                                                                                  
    ppdev->pfnXfer4to16bpp           = ppdev->DoubleBuffer.SavedProcs.pfnXfer4to16bpp           ;
    ppdev->pfnXfer8to16bpp           = ppdev->DoubleBuffer.SavedProcs.pfnXfer8to16bpp           ;
    ppdev->pfnXfer4to32bpp           = ppdev->DoubleBuffer.SavedProcs.pfnXfer4to32bpp           ;
    ppdev->pfnXfer8to32bpp           = ppdev->DoubleBuffer.SavedProcs.pfnXfer8to32bpp           ;
    ppdev->pfnFastXfer8to32          = ppdev->DoubleBuffer.SavedProcs.pfnFastXfer8to32          ;
    ppdev->pfnFastXfer8to16          = ppdev->DoubleBuffer.SavedProcs.pfnFastXfer8to16          ;
    ppdev->pfnIndexedImage           = ppdev->DoubleBuffer.SavedProcs.pfnIndexedImage           ;
                                                                                  
    ppdev->pfnMemToScreenBlt         = ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt         ;
    ppdev->pfnMemToScreenPatternBlt  = ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenPatternBlt  ;
    ppdev->pfnTextOut                = ppdev->DoubleBuffer.SavedProcs.pfnTextOut                ;
                                                                                  
    ppdev->pfnStrokePath             = ppdev->DoubleBuffer.SavedProcs.pfnStrokePath             ;
    ppdev->pfnLineTo                 = ppdev->DoubleBuffer.SavedProcs.pfnLineTo                 ;

    ppdev->pfnScreenTo1BppMemBlt     = ppdev->DoubleBuffer.SavedProcs.pfnScreenTo1BppMemBlt     ;
    ppdev->pfnScreenToMemBlt         = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt         ;
    ppdev->pfnScreenToMem16to4bppBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to4bppBlt ;     
    ppdev->pfnScreenToMem32to4bppBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to4bppBlt ;     
    ppdev->pfnScreenToMem16to8bppBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem16to8bppBlt ;     
    ppdev->pfnScreenToMem32to8bppBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToMem32to8bppBlt ;     

    ppdev->pfnScreenToScreenWithPatBlt = ppdev->DoubleBuffer.SavedProcs.pfnScreenToScreenWithPatBlt ;     

    ppdev->pfnEngBitBlt     = EngBitBlt;
    ppdev->pfnEngCopyBits   = EngCopyBits;
    ppdev->pfnEngTextOut    = EngTextOut;
    ppdev->pfnEngLineTo     = EngLineTo;
    ppdev->pfnEngStrokePath = EngStrokePath;
#if _WIN32_WINNT >= 0x0500
    ppdev->pfnEngAlphaBlend = EngAlphaBlend;
#endif
}

//
// bDoublePumped
// 
// returns true if the surface offset belongs to a surface that is 2D double pumped
// 
BOOL bDoublePumped(PPDEV ppdev, ULONG ulSurfaceOffset)
{
    BOOL bRet=FALSE; // default exit: not double pumped
    LONG i;

    ASSERT(NULL!=ppdev);

    if (   ppdev->bOglSingleBackDepthSupported
        && (   ppdev->bOglSingleBackDepthCreated
            || ppdev->bOglOverlaySurfacesCreated
            || ppdev->ulOglActiveViews != 0) )
    {
        for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) 
        {
            ASSERT(ppdev->DoubleBuffer.bEnabled);
            if (ulSurfaceOffset == ppdev->DoubleBuffer.MultiBufferOffsets[i])
            {
                // this surface is double pumped
                bRet=TRUE;
                break;
            }
        }
    }

    return bRet;
}


//*************************************************************************
// NV_AddDoubleBufferSurface
// 
// Adds a surface to the double pumping code and activates double 
// buffering if not enabled.
// Returns TRUE if succeeded.
//*************************************************************************
BOOL NV_AddDoubleBufferSurface(
    PPDEV  ppdev, 
    ULONG  ulSurfaceOffset)
{
    BOOL bRet = FALSE;

    if (   ppdev->bOglSingleBackDepthSupported
        && ppdev->bOglSingleBackDepthCreated)
    {
        ASSERT(!bDoublePumped(ppdev, ulSurfaceOffset));
        ASSERT(ulSurfaceOffset != ppdev->ulPrimarySurfaceOffset);
        ASSERT(ppdev->DoubleBuffer.NumBuffers >= 0);

        if (ppdev->DoubleBuffer.bEnabled)
        {
            // Already active, just add a buffer and initialize it
            NV_CopyPrimaryToDoubleBuffer(ppdev, ulSurfaceOffset);

            ppdev->DoubleBuffer.MultiBufferOffsets[ppdev->DoubleBuffer.NumBuffers] = ulSurfaceOffset;
            ASSERT(ppdev->DoubleBuffer.NumBuffers < NV_MAX_BUFFERS);
            ppdev->DoubleBuffer.NumBuffers++;
        }
        else
        {
            NV_InitDoubleBufferMode(ppdev, 1, &ulSurfaceOffset);
        }

        bRet = TRUE;
    }

    return bRet;
}


//*************************************************************************
// NV_RemoveDoubleBufferSurface
// 
// remove the surface with the given offset from the double pumping list 
// and deactivate double buffering if it was the last buffer. 
// Returns TRUE if succeeded.
//*************************************************************************
BOOL NV_RemoveDoubleBufferSurface(
    PPDEV  ppdev, 
    ULONG  ulSurfaceOffset)
{
    LONG i;
    BOOL bRet = FALSE;

    ASSERT(NULL!=ppdev);

    if (   ppdev->bOglSingleBackDepthSupported
        && ppdev->bOglSingleBackDepthCreated)
    {
        ASSERT(bDoublePumped(ppdev, ulSurfaceOffset));
        ASSERT(ulSurfaceOffset != ppdev->ulPrimarySurfaceOffset);
        ASSERT(ppdev->DoubleBuffer.NumBuffers > 0);

        if (1 == ppdev->DoubleBuffer.NumBuffers)
        {
            NV_DisableDoubleBufferMode(ppdev);
        }
        else if (0 != ppdev->DoubleBuffer.NumBuffers)
        {
            // find offset in list (cannot fail!)
            for (i=0; i<ppdev->DoubleBuffer.NumBuffers; i++) 
            {
                if (ulSurfaceOffset == ppdev->DoubleBuffer.MultiBufferOffsets[i])
                {
                    break;
                }
            }

            #if DBG
            // clear surface and remove it from list
            NV_ClearDoubleBuffer(ppdev, ppdev->DoubleBuffer.MultiBufferOffsets[i]);
            #endif

            // move all ohter entries down to fill the hole
            for (/* i */; i<ppdev->DoubleBuffer.NumBuffers-1; i++) 
            {
                ppdev->DoubleBuffer.MultiBufferOffsets[i] = ppdev->DoubleBuffer.MultiBufferOffsets[i+1];
            }

            ppdev->DoubleBuffer.NumBuffers--;
        }

        ASSERT(ppdev->DoubleBuffer.NumBuffers >= 0);
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvinithw.c ===
//******************************************************************************
//
// Module Name:
//
//     NVINITHW.C
//
// Abstract:
//
//     Initialization of HW routines
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996-2000  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
//    #include "nvProcMan.h"
    #include "ddmini.h"
#endif

#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "ddminint.h"
#include "dmamacro.h"
#include "nvcm.h"
#include "oglDD.h"
#include "oglOverlay.h"
#include "oglutils.h"

// To get the NV11 twinview definitions
#include "nvMultiMon.h"
extern BOOL InitMultiMon(PDEV *ppdev);
extern void InduceAndUpdateDeviceScanning (PPDEV ppdev);
extern VOID NV_WaitForOneVerticalRefresh(PDEV*);


VOID NV4_DmaPushSend(PDEV *);
VOID NV_DmaPush_Wrap(PDEV *, ULONG );
VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG);

BOOL NVInitDmaPushHardware(PDEV *);
VOID NVReleaseDmaPushHardware(PDEV *ppdev,BOOL InitDmaPushHardwareFailFlag);
void NvValidateCaps(PDEV* ppdev);
BOOL bClassSupported(PDEV *ppdev, NvU32 classID);

#ifdef NV3
BOOL bNV3CreateStdPatches(PDEV *ppdev);
VOID vNV3DestroyStdPatches(PDEV *ppdev, BOOL CreateStdPatchFailFlag);
#endif // NV3

#define OFFSET_NV_PFIFO_BASE                        (0x2000)
#define OFFSET_NV_PFIFO_CACHE1_DMA0_REG             (0x3224-OFFSET_NV_PFIFO_BASE)

#define NO_MAPPING                                  ((PVOID)1)

//******************************************************************************
//
//  Function:   bAssertModeHardware
//
//  Routine Description:
//
//      Sets the appropriate hardware state for graphics mode or full-screen.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************


BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)

    {
    BYTE*                   pjIoBase;
    BYTE*                   pjMmBase;
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    BYTE                    jExtendedMemoryControl;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    LONG                    cjEndOfFrameBuffer;
    LONG                    cjPointerOffset;
    LONG                    lDelta;
    ULONG                   ulMiscState;
    Nv3ChannelPio           *nv;
    ULONG                   i;
    PVOID                   frameBuffer;
    ULONG                   status;
    TV_CURSOR_ADJUST_INFO   CursorAdjustInfo;
    NV_DESKTOP_INFO         DeskTopInfo;
    NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS nvPitch;
    BOOLEAN                 bVirtualDesktopEnabled;
    ULONG                   ulData;
    DWORD                   dwStatus;

    //**************************************************************************
    // bEnable == TRUE  --> Set the graphics mode
    // bEnable == FALSE --> Reset the adapter into a known state, NTVDM will take over
    //**************************************************************************
    if (bEnable)
        {

        //**********************************************************************
        // Call the miniport via an IOCTL to set the graphics mode.
        //
        // ppdev->ulMode is the REQUESTED mode which is initialized
        // in bInitializeModeFields
        //
        //**********************************************************************

        ppdev->lDelta = 0;

        // Initialize the multi-mon info.
        if(!InitMultiMon(ppdev))
            goto bAssertModeHardware_ReturnFalse;

        ppdev->ulDesktopMode |=  NV_ENABLE_CLASS_SET_MODE;
        DeskTopInfo.ulDesktopModeIndex = ppdev->ulMode;
        DeskTopInfo.ulDesktopMode = ppdev->ulDesktopMode;
        DeskTopInfo.ulTwinView_State = ppdev->TwinView_State;

        DeskTopInfo.ulDesktopWidth = ppdev->cxScreen;
        DeskTopInfo.ulDesktopHeight = ppdev->cyScreen;

        DeskTopInfo.ulNumberDacsOnBoard = ppdev->ulNumberDacsOnBoard;
        DeskTopInfo.ulNumberDacsConnected = ppdev->ulNumberDacsConnected;
        DeskTopInfo.ulNumberDacsActive = ppdev->ulNumberDacsActive;

        DeskTopInfo.ulConnectedDeviceMask = ppdev->ulConnectedDeviceMask;
        DeskTopInfo.ulAllDeviceMask = ppdev->ulAllDeviceMask;
        

        for(i = 0; i < NV_NO_DACS; i++)
        {
            DeskTopInfo.ulDisplayWidth[i] = ppdev->rclCurrentDisplay[i].right - ppdev->rclCurrentDisplay[i].left;
            DeskTopInfo.ulDisplayHeight[i] = ppdev->rclCurrentDisplay[i].bottom - ppdev->rclCurrentDisplay[i].top;
            DeskTopInfo.ulDisplayRefresh[i] = ppdev->ulRefreshRate[i];
            DeskTopInfo.ulDisplayPixelDepth[i] = ppdev->cBitsPerPel;
            DeskTopInfo.ulDeviceDisplay[i] = ppdev->ulDeviceDisplay[i];
            DeskTopInfo.ulDeviceMask[i] = ppdev->ulDeviceMask[i];
            DeskTopInfo.ulDeviceType[i] = ppdev->ulDeviceType[i];
            DeskTopInfo.ulTVFormat[i] = ppdev->ulTVFormat[i];
        }

        if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_SET_DESKTOP_INFO_MODE,
                       &DeskTopInfo,  // input buffer
                       sizeof(NV_DESKTOP_INFO),
                       &bVirtualDesktopEnabled,
                       sizeof(BOOLEAN),
                       &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed IOCTL_VIDEO_SET_DESKTOP_INFO_MODE"));
        }
        else if (ReturnedDataLength == sizeof(BOOLEAN))
        {
            if(bVirtualDesktopEnabled)
            {
                DISPDBG((5, "bAssertModeHardware - Support DualView"));
            }
        }

        nvPitch.Width = ppdev->cxScreen;
        nvPitch.Height = ppdev->cyScreen;
        nvPitch.Depth = ppdev->cjPelSize * 8;

        if (NvConfigGetEx(ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                 NV_CFGEX_GET_SURFACE_DIMENSIONS, &nvPitch, sizeof(NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS))) 
        {
            DISPDBG((0,"bAssertModeHardware - Cannot get pitch value from RM"));  // ERROR ???
            // IF RM cannot calculate the pitch, it will be in trouble to allocate the primary surface late on.
            goto bAssertModeHardware_ReturnFalse;
        }

        ppdev->lDelta = nvPitch.Pitch;

        // clean up the heap first.
        if(!ppdev->ulEnableDualView)
            NVHEAP_DESTROY();

        NVHEAP_ALLOC_TILED(dwStatus,ppdev->ulPrimarySurfaceOffset, (DWORD)nvPitch.Pitch, (DWORD)ppdev->cyScreen, MEM_TYPE_PRIMARY);
        //
        // Under Dualview, it is likely to fail allocation of frame buffer.
        // Suppose both viws are on.  And 2nd view holds big chunk of DDraw surface, which leave no room for the 1st view to getting bigger.
        // Under such a case, 1st can only shrink.  If it tries to expand, OS DrvChangeDisplaySetting will try again on a fall back res at 
        // 640x480.
        //
        if (dwStatus != 0)
        {
            DISPDBG((0, "bAssertModeHardware - Failed to allocate video memory for frame buffer.  Pitch=0x%08x, cyScreen=0x%08x", nvPitch.Pitch, ppdev->cyScreen));
            if (ppdev->ulEnableDualView)
                return FALSE;
            else
                goto bAssertModeHardware_ReturnFalse;
        }

        ppdev->pjScreen = ppdev->pjFrameBufbase + ppdev->ulPrimarySurfaceOffset;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_CURRENT_MODE,
                               &ppdev->ulMode,  // input buffer
                               sizeof(DWORD),
                               &ppdev->bHwVidOvl,
                               sizeof(BOOLEAN),
                               &ReturnedDataLength))
            {
            DISPDBG((1, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto bAssertModeHardware_ReturnFalse;
            }
        else if (ReturnedDataLength != sizeof(BOOLEAN))
            {
            //****************************************************************
            // Miniport didn't know if we can do hw video overlay. Assume we can!
            //****************************************************************
                ppdev->bHwVidOvl = TRUE;

            }

#ifndef NV3
        // Using VIDEO_OVERLAY class, the HW should be able to handle it
        ppdev->bHwVidOvl = TRUE;
#endif

#if _WIN32_WINNT < 0x0500
        if(ppdev->ulNumberDacsActive > 1)
            ppdev->bHwVidOvl = FALSE;
#endif
        //**********************************************************************
        // After we've set the mode, get the information and
        // put it in the VideoModeInfo structure
        //**********************************************************************

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_CURRENT_MODE,
                               NULL,
                               0,
                               &VideoModeInfo,
                               sizeof(VideoModeInfo),
                               &ReturnedDataLength))
            {
            DISPDBG((1, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
            goto bAssertModeHardware_ReturnFalse;
            }

        #if DEBUG_HEAP
            VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
            VideoModeInfo.VideoMemoryBitmapHeight = VideoModeInfo.VisScreenHeight;
        #endif


        //**********************************************************************
        // Also get the necessary cursor adjustments
        // (when we're running on a TV)
        //**********************************************************************

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO,
                               NULL,
                               0,
                               &CursorAdjustInfo,
                               sizeof(CursorAdjustInfo),
                               &ReturnedDataLength))
            {
            DISPDBG((1, "bAssertModeHardware - failed VIDEO_QUERY_TV_CURSOR_ADJUST"));
            goto bAssertModeHardware_ReturnFalse;
            }

        //**********************************************************************
        // Store these values in the pdev structure for all to see
        //**********************************************************************

        ppdev->MonitorType  = CursorAdjustInfo.MonitorType;
        ppdev->Underscan_x  = CursorAdjustInfo.Underscan_x;
        ppdev->Underscan_y  = CursorAdjustInfo.Underscan_y;
        ppdev->Scale_x      = CursorAdjustInfo.Scale_x;
        ppdev->Scale_y      = CursorAdjustInfo.Scale_y;
        ppdev->FilterEnable = CursorAdjustInfo.FilterEnable;
        ppdev->TVCursorMin  = CursorAdjustInfo.TVCursorMin;
        ppdev->TVCursorMax  = CursorAdjustInfo.TVCursorMax;

        //**********************************************************************
        // The following variables are determined only after the initial modeset:
        //
        // NV1 / NV3 / NV4:
        //      flCaps is returned to the display driver and denotes whether
        //      NV1 / NV3 / NV4 was found by the miniport
        //
        //**********************************************************************

        ppdev->flCaps   = VideoModeInfo.DriverSpecificAttributeFlags;
        ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;
#ifndef RM_HEAPMGR
        ppdev->lDelta   = VideoModeInfo.ScreenStride;
#else
        //************************************************************
        // If we are using the RM heap manager, ask the RM for the
        // pitch. Fallback to using the pitch in the mode table if
        // the RM call fails. For NV3, the RM will return success,
        // but will always return a pitch value of 0, so we have
        // to check for this and fallback to the default pitch.
        //************************************************************
        if(!ppdev->lDelta)
        {
            if (NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                         NV_CFG_PRIMARY_SURFACE_PITCH, &ppdev->lDelta)) 
            {
                ppdev->lDelta = VideoModeInfo.ScreenStride;
            }
            if (!ppdev->lDelta)
                ppdev->lDelta = VideoModeInfo.ScreenStride;
            else
                VideoModeInfo.ScreenStride = ppdev->lDelta;
        }
#endif

        //**********************************************************************
        // Get the frame buffer length from the RM
        //**************************************************************************
        //frameBuffer = ppdev->pjScreen;
        frameBuffer = NO_MAPPING;

        ppdev->hFrameBuffer = DD_FRAME_BUFFER_OBJECT_HANDLE;
        status = NvAllocMemory(ppdev->hDriver,
                                     ppdev->hClient,
                                     ppdev->hDevice,
                                     ppdev->hFrameBuffer,
                                     NV01_MEMORY_LOCAL_USER,
                                     0,
                                     &frameBuffer,
                                     &ppdev->cbFrameBuf);

        if (status != NVOS02_STATUS_SUCCESS)
            {
            DISPDBG((1, "Failed bAssertModeHardware"));
            goto bAssertModeHardware_ReturnFalse;
            }

        ASSERTDD(status == NVOS02_STATUS_SUCCESS,
                     "bAssertModeHardware: Failed to allocate memory");

        //**********************************************************************
        // Save the frame buffer size in bytes rounded to the next lowest 4K boundary.
        // Compute the Frame Buffer size (in scanlines) based on the rounded size in
        // bytes.
        //**********************************************************************
        ppdev->cbFrameBuf += 1;
        ppdev->cyMemory = ppdev->cbFrameBuf / ppdev->lDelta;

        if (ppdev->cyMemory > MAX_CY_MEMORY_VALUE)
            ppdev->cyMemory = MAX_CY_MEMORY_VALUE;

        // Max. Clip value:((ppdev->cyMemory)<<16) | (0x7fff)
        ppdev->dwMaxClip = ((ppdev->cyMemory)<<16) | (0x7fff);

        DISPDBG((1, "NVDD: Get channel pointer from RM"));

        //**********************************************************************
        // NV3 uses the old style patchcord initialization
        // (and it must use the old style Resource Manager too)
        // NV4 no longer uses patchcord initialization
        // (and must use the new NV4 Resource Manager)
        //**********************************************************************
#ifdef NV3
        if (!bNV3CreateStdPatches(ppdev))
            goto bAssertModeHardware_ReturnFalse;
#else
        //******************************************************************
        // New NV4 architecture no longer uses patchcords
        //******************************************************************

        ppdev->DmaPushEnabled2D = TRUE;        // Always enabled for now
        ppdev->fontCacheEnabled = FALSE;       // Always disabled for now
                                               //   since not as fast
        //**************************************************************
        // Use DMA Pusher functionality for 2d
        //**************************************************************

        if (!NVInitDmaPushHardware(ppdev)) {
            goto bAssertModeHardware_ReturnFalse;
        }
#endif // NV3

        //**************************************************************
        // Validate capabilities based on classes we allocated.
        //**************************************************************
        NvValidateCaps(ppdev);
        
        //**************************************************************
        // Initialize heap size info.
        //**************************************************************
        NVHEAP_INFO();

        //**********************************************************************
        // Make sure that Clipping rectangle gets reset by the first hardware function
        // By default, the clipping rectangle should include ALL of video memory
        // (including offscreen). Whenever we change it, we need to set this flag.
        // So, by setting it here, the first function we get to will reset
        // the clipping rectangle.  Also, make sure that pattern gets reset.
        //**********************************************************************

        ppdev->NVClipResetFlag=1;
        ppdev->NVPatternResetFlag=1;

        //**********************************************************************
        // Make sure to reset pitches and offsets across modesets!
        //**********************************************************************

        ppdev->CurrentSourceOffset = 0;
        ppdev->CurrentSourcePitch  = 0;
        ppdev->CurrentDestOffset   = 0;
        ppdev->CurrentDestPitch    = 0;

        //**********************************************************************
        // Display the current mode for our convenience on the debugger
        //**********************************************************************

        DISPDBG((1, "cxMemory: %lx  cyMemory: %lx", ppdev->cxMemory, ppdev->cyMemory));
        DISPDBG((1, "cxScreen: %lx  cyScreen: %lx", ppdev->cxMemory, ppdev->cyMemory));
        DISPDBG((1, "ldelta: %lx ", ppdev->lDelta));

        //**********************************************************************
        // Set the CAPS_SW_POINTER to specify a software cursor if necessary,
        // and make the necessary modifications to pointer.c
        //
        // ppdev->flCaps |= CAPS_SW_POINTER;
        //
        //**********************************************************************

        //**********************************************************************
        // Turn off hardware cursor when running in 960x720 modes
        // (Because we're limited to 46k of PRAMIN instance memory,
        // and cursor caching takes up a lot of it)
        //**********************************************************************

        if ((ppdev->cxScreen == 960) && (ppdev->cyScreen == 720))
            ppdev->flCaps |= CAPS_SW_POINTER;


        //**********************************************************************
        // Do some parameter checking on the values that the miniport
        // returned to us:
        //**********************************************************************

        ASSERTDD(ppdev->cxMemory >= ppdev->cxScreen, "Invalid cxMemory");
        ASSERTDD(ppdev->cyMemory >= ppdev->cyScreen, "Invalid cyMemory");

        OglEnableModeSwitchUpdate(ppdev);

        // Now induce the device scan by the miniport to rebuild the possible device options for each head.
        // InduceAndUpdateDeviceScanning(ppdev);

        NvHwSpecific(ppdev);

        ppdev->bEnabled = TRUE;

        }

    else

        {
        OglDisableModeSwitchUpdate(ppdev);


#ifdef NV3

        //******************************************************************
        // Normally, we would wait on the videocolormap buffer notifier
        // to make sure palette writes are done before deleting the patch/contexts.
        // (ie...palette writes occur during vblank, so we must not delete the
        // associated colormap context until the palette writes are completed)
        // However notifiers for the video colormap are not yet implemented.
        // So for now, we have to wait for at least one vertical refresh to occur ,
        // to make sure all the palette writes have completed.
        // Without this sync, the rm colormap notify routine in the vblank handler
        // could potentially crash.
        //******************************************************************

        NV_WaitForOneVerticalRefresh(ppdev);
        NV_WaitForOneVerticalRefresh(ppdev);
        NV_WaitForOneVerticalRefresh(ppdev);

        vNV3DestroyStdPatches(ppdev, FALSE);

#else
        ASSERTDD(ppdev->DmaPushEnabled2D,"NV4 and up need DmaPushEnabled");
        //**************************************************************
        // Normally, we would wait on the videocolormap buffer notifier
        // to make sure palette writes are done before deleting the patch/contexts.
        // (ie...palette writes occur during vblank, so we must not delete the
        // associated colormap context until the palette writes are completed)
        // However notifiers for the video colormap are not yet implemented.
        // So for now, we have to wait for at least one vertical refresh to occur ,
        // to make sure all the palette writes have completed.
        // Without this sync, the rm colormap notify routine in the vblank handler
        // could potentially crash.
        //**************************************************************

        NV_WaitForOneVerticalRefresh(ppdev);
        NV_WaitForOneVerticalRefresh(ppdev);
        NV_WaitForOneVerticalRefresh(ppdev);

        if (ppdev->iBitmapFormat != BMF_8BPP) 
        {
            if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SAVE_GAMMA_VALUES,
                           ppdev->ajClutData,  
                           sizeof(NV_VIDEO_CLUTDATA) * NV_NO_DACS * 256,
                           NULL,
                           0,
                           &ReturnedDataLength))
            {
                DISPDBG((1, "bAssertModeHardware - IOCTL_VIDEO_POSTMODE_SET failed"));
            }
        }

        //**********************************************************************
        // We've been asked to go full-screen DOS, but if we're not the VGA 
        // controller- which is possible in multimon- then another card will go 
        // into full-screen DOS. Painting black on our framebuffer avoids screen 
        // corruption. Its just cosmetic.
        //**********************************************************************
        EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_CLEAR_FRAMEBUFFER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn);

    
        NVReleaseDmaPushHardware(ppdev, TRUE);
        //**************************************************************
        // Release DMA Pusher functionality
        //**************************************************************

#endif // NV3

        NVHEAP_FREE(ppdev->ulPrimarySurfaceOffset);
        ppdev->ulDesktopMode = 0;

        //**********************************************************************
        // Invalidate cursor cache.
        //**********************************************************************
        for (i=0; i<NUM_CACHED_CURSORS; i++)
            ppdev->SavedCursorCheckSums[i] = 0;


        //**********************************************************************
        // For NV4, when using DMA Push, palette writes
        // (using video colormap) get queued up and don't
        // actually get written until the next vertical blank.
        // Normally, we would wait on the video colormap buffer notifier
        // to make sure the palette writes are done, before resetting
        // the device (calling int 10h).  However notifiers for the video
        // colormap are currrently not functional.  So for now, we'll
        // wait for at least one vertical refresh to occur , to make sure
        // all the palette writes have completed.
        //**********************************************************************

        if (ppdev->iBitmapFormat == BMF_8BPP) {
            NV_WaitForOneVerticalRefresh(ppdev);
        }

        //**********************************************************************
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:
        //**********************************************************************

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_RESET_DEVICE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn))
            {
            DISPDBG((1, "bAssertModeHardware - Failed reset IOCTL"));
            goto bAssertModeHardware_ReturnFalse;
            }
    }

    //**************************************************************************
    // AssertModeHardware call succeeded.
    //**************************************************************************

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);

    //**************************************************************************
    // AssertModeHardware call failed.
    //**************************************************************************

bAssertModeHardware_ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
    }

//******************************************************************************
//
//  Function:   bEnableHardware
//
//  Routine Description:
//
//      Puts the hardware in the requested mode and initializes it.
//
//      Note: Should be called before any access is done to the hardware from
//            the display driver.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************

BOOL bEnableHardware(
PDEV*   ppdev)

    {
    BYTE*                       pjIoBase;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange[16];
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    VIDEO_MEMORY                AliVidMem;
    VIDEO_MEMORY_INFORMATION    AliVidMemInfo;
    DWORD                       ReturnedDataLength;
    UCHAR*                      pj;
    USHORT*                     pw;
    ULONG*                      pd;
    ULONG                       i, j;
    ULONG                       ulOffset;
#ifdef PERFTEST
    ULONG* nvptr;
#endif

    //**************************************************************************
    // Create semaphore.  This is mainly used by the
    // ACQUIRE_CRTC_CRITICAL_SECTION macros for an asynchronous cursor.
    //**************************************************************************

    ppdev->csCrtc = EngCreateSemaphore();
    if (ppdev->csCrtc == 0)
        {
        DISPDBG((1, "bEnableHardware - Error creating CRTC semaphore"));
        goto bEnableHardware_ReturnFalse;
        }

    // OpenGL code: Allocate NV3 FIFO semaphore
    ppdev->csFifo = EngCreateSemaphore();
    if (ppdev->csFifo == 0)
        {
        DISPDBG((1, "bEnableHardware - Error creating FIFO semaphore"));
        goto bEnableHardware_ReturnFalse;
        }

    //**************************************************************************
    // Get virtual addresses for the following memory ranges
    //
    // Currently, we'll be giving the display driver
    // public access to 5 ranges (in addition to the frame buffer)
    //
    //     1) NV User Channel 0  (64k)
    //     2) Graphics Status register (to check for Engine Busy)
    //     3) Vertical Blank (PFB_CONFIG_0 register)
    //     4) Frame Buffer Start Address (for page flipping)
    //     5) DAC cursor registers
    //
    // The Dumb Frame buffer ptr is mapped separately in VIDEO_MAP_VIDEO_MEMORY
    //
    // UPDATE: Looks like we'll be needing access to more and more privileged
    //         registers (at least until we get a full resource manager working)
    //         It's becoming a little ugly...but can't be helped right now..
    //         We're programming straight to NV registers, instead of using
    //         objects the way NV was meant to be programmed.
    //
    //     - PRMCIO Registers
    //     - PRMVIO Registers
    //     - PRAMDAC Registers
    //     - PRAMIN Registers
    //     - TEXTURE BUFFER AREA
    //     - PGRAPH Registers
    //     - DMA BUFFER AREA
    //
    //**************************************************************************

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                           NULL,                      // input buffer
                           0,
                           VideoAccessRange,         // output buffer
                           sizeof(VideoAccessRange),
                           &ReturnedDataLength))
        {
        DISPDBG((1, "bEnableHardware - Initialization error mapping IO port base"));
        goto bEnableHardware_ReturnFalse;
        }

    //  Initialize function ptrs and mmio here as soon as we got all necessary info.

    //**************************************************************************
    // Initialize the memory ranges. They're DIFFERENT depending
    // on which chip we're running on, because some ranges that exist
    // on one chip, may not exist on the other
    //**************************************************************************

    ppdev->NvBaseAddr = (volatile DWORD *) VideoAccessRange[0].VirtualAddress;
    ppdev->GrStatusReg = (volatile DWORD *) VideoAccessRange[1].VirtualAddress;
    ppdev->FbConfig0Reg = (volatile DWORD *) VideoAccessRange[2].VirtualAddress;
    ppdev->FbStartAddr = (volatile DWORD *) 0x0;
    ppdev->DACRegs = (volatile DWORD *) 0x0;
    ppdev->PRMCIORegs = (volatile UCHAR *) VideoAccessRange[5].VirtualAddress;
    ppdev->PRMVIORegs = (volatile UCHAR *) VideoAccessRange[6].VirtualAddress;
    ppdev->PRAMDACRegs = (volatile DWORD *) VideoAccessRange[7].VirtualAddress;

    ppdev->PGRAPHRegs = (volatile DWORD *) VideoAccessRange[10].VirtualAddress;
    ppdev->PFIFORegs = (volatile DWORD *) VideoAccessRange[11].VirtualAddress;

#ifdef NV3
    //**********************************************************************
    // Init DMA push length register to 0
    //**********************************************************************
    if (ppdev->PFIFORegs) {
        volatile ULONG *DmaPushLengthReg;
        
        DmaPushLengthReg = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA0_REG);
        *DmaPushLengthReg = 0;
    }
#endif // NV3

    //**********************************************************************
    // DMA buffer is NO LONGER allocated in the miniport.
    // It's now allocated in EnablePDEV, so do NOT initialize it here.
    // (VideoAccessRange[11] is ZERO)
    //**********************************************************************

    DISPDBG((1, "pjMmBase: 0x%p  ", ppdev->pjMmBase));
    DISPDBG((1, "GrStatusReg: 0x%p  ", ppdev->GrStatusReg));
    DISPDBG((1, "FbConfig0Reg: 0x%p  ", ppdev->FbConfig0Reg));
    DISPDBG((1, "FbStartAddr: 0x%p  ", ppdev->FbStartAddr));
    DISPDBG((1, "DACRegs: 0x%p  ", ppdev->DACRegs));
    DISPDBG((1, "PRMCIORegs: 0x%p  ", ppdev->PRMCIORegs));
    DISPDBG((1, "PRMVIORegs: 0x%p  ", ppdev->PRMVIORegs));
    DISPDBG((1, "PRAMDACRegs: 0x%p  ", ppdev->PRAMDACRegs));
    DISPDBG((1, "PRAMINRegs: 0x%p  ", ppdev->PRAMINRegs));
    DISPDBG((1, "PGRAPHRegs: 0x%p  ", ppdev->PGRAPHRegs));
    DISPDBG((1, "PFIFORegs: 0x%p  ", ppdev->PFIFORegs));


    //**************************************************************************
    // Now set the pointers to the hardware specific functions
    //**************************************************************************
#ifdef NV3
    ppdev->pfnSetDestBase           = NV3_SetDestBase;
    ppdev->pfnSetSourceBase         = NV3_SetSourceBase;

    ppdev->pfnFillSolid             = NV3FillSolid;
    ppdev->pfnFillPat               = NV3FillPatFast;
    ppdev->pfnXfer1bpp              = NV3Xfer1bpp;
    ppdev->pfnXfer4bpp              = NV3Xfer4bpp;
    ppdev->pfnXferNative            = NV3XferNative;
    ppdev->pfnCopyBlt               = NV3CopyBlt;

    ppdev->pfnXfer4to16bpp          = NULL;
    ppdev->pfnXfer8to16bpp          = NULL;
    ppdev->pfnXfer4to32bpp          = NULL;
    ppdev->pfnXfer8to32bpp          = NULL;
    ppdev->pfnIndexedImage          = NULL;   

    ppdev->pfnMemToScreenBlt        = NV3MemToScreenBlt;
    ppdev->pfnMemToScreenPatternBlt = NV3MemToScreenWithPatternBlt;
    ppdev->pfnTextOut               = NV3TextOut;
    ppdev->pfnSetPalette            = NV3SetPalette;

    ppdev->pfnScreenTo1BppMemBlt    = NULL;
    ppdev->pfnGetScreenBits         = NULL;
    ppdev->pfnScreenToMemBlt        = NULL;
    ppdev->pfnScreenToMem16to4bppBlt= NULL;  
    ppdev->pfnScreenToMem32to4bppBlt= NULL; 
    ppdev->pfnScreenToMem16to8bppBlt= NULL; 
    ppdev->pfnScreenToMem32to8bppBlt= NULL; 
    ppdev->pfnScreenToScreenWithPatBlt= NULL;


    ppdev->pfnWaitEngineBusy        = NV3_WaitWhileGraphicsEngineBusy;
    ppdev->pfnWaitForChannelSwitch  = NV3_WaitForChannelSwitch;
    ppdev->pfnDmaPushGo             = NV3_DmaPushGo;
    ppdev->pfnStrokePath            = NV1StrokePath;

    ppdev->pfnAcquireOglMutex       = NV3_AcquireOglMutex;
    ppdev->pfnReleaseOglMutex       = NV3_ReleaseOglMutex;

    ppdev->pfnLineTo                = NV1LineTo;
    ppdev->pfnStretchCopy           = NULL;
#else // NV3

    //**************************************************************
    // Use DMA pusher
    //**************************************************************

    ppdev->pfnSetDestBase           = NV4_DmaPushSetDestBase;  // Needed for newer 565 functions
    ppdev->pfnSetSourceBase         = NV4_DmaPushSetSourceBase;

    ppdev->pfnFillSolid             = NV4DmaPushFillSolid;
    ppdev->pfnFillPat               = NV4DmaPushFillPatFast;
    ppdev->pfnXfer1bpp              = NV4DmaPushXfer1bpp;
    ppdev->pfnXfer4bpp              = NV4DmaPushXfer4bpp;
    ppdev->pfnXferNative            = NV4DmaPushXferNative;
    ppdev->pfnCopyBlt               = NV4DmaPushCopyBlt;

    ppdev->pfnXfer4to16bpp          = NV4DmaPushXfer4to16bpp;
    ppdev->pfnXfer8to16bpp          = NV4DmaPushXfer8to16bpp;
    ppdev->pfnXfer4to32bpp          = NV4DmaPushXfer4to32bpp;
    ppdev->pfnXfer8to32bpp          = NV4DmaPushXfer8to32bpp;
    ppdev->pfnFastXfer8to32         = NV4DmaPushFastXfer8to32;
    ppdev->pfnFastXfer8to16         = NV4DmaPushFastXfer8to16;
    
    ppdev->pfnIndexedImage          = NV4DmaPushIndexedImage;

    ppdev->pfnMemToScreenBlt        = NV4DmaPushMemToScreenBlt;
    ppdev->pfnMemToScreenPatternBlt = NV4DmaPushMemToScreenWithPatternBlt;
    ppdev->pfnTextOut               = NV4DmaPushTextOut;
    ppdev->pfnSetPalette            = NV4DmaPushSetPalette;

    ppdev->pfnScreenTo1BppMemBlt    = NV4ScreenTo1bppMemBlt;
    ppdev->pfnGetScreenBits         = NV4DmaPushDMAGetScreenBits;
    ppdev->pfnScreenToMemBlt        = NV4ScreenToMemBlt;
    ppdev->pfnScreenToMem16to4bppBlt= NV4ScreenToMem16to4bppBlt;     
    ppdev->pfnScreenToMem32to4bppBlt= NV4ScreenToMem32to4bppBlt;     
    ppdev->pfnScreenToMem16to8bppBlt= NV4ScreenToMem16to8bppBlt;     
    ppdev->pfnScreenToMem32to8bppBlt= NV4ScreenToMem32to8bppBlt;     
    ppdev->pfnScreenToScreenWithPatBlt= NV4ScreenToScreenWithPatBlt; 

    ppdev->pfnWaitEngineBusy        = NV4_DmaPushWaitWhileGraphicsEngineBusy;
    ppdev->pfnWaitForChannelSwitch  = NV4_DmaPushWaitForChannelSwitch;
    ppdev->pfnDmaPushGo             = NULL;
    ppdev->pfnStrokePath            = NV4DmaPushStrokePath;
    ppdev->pfnLineTo                = NV4DmaPushLineTo;
    ppdev->pfnStretchCopy           = NV4DmaPushStretchCopy;

    ppdev->pfnAcquireOglMutex = NV4_AcquireOglMutex;
    ppdev->pfnReleaseOglMutex = NV4_ReleaseOglMutex;
#endif // NV3

    //**************************************************************************
    // Memory ranges For NV1 vs NV3 will be initialized AFTER
    // AssertModeHardware so we'll know which chip we're currently running on.
    // These values are stored in VideoAccessRange[] array.
    // So don't overwrite them until we extract them later in this function !
    //**************************************************************************


    //**************************************************************************
    // Allocate 64k for a 'Dummy' user channel so that we can profile
    // performance.  We'll use this instead of the NV user channel
    // when we don't want to send data to NV (i.e. so we can measure
    // performance of the software code by itself)
    //**************************************************************************
#ifdef PERFTEST
    ppdev->TestChannelFlag=0;
    ppdev->TestChannelPtr = EngAllocMem(FL_ZERO_MEMORY, 0x10000, ALLOC_TAG);
    if (ppdev->TestChannelPtr == NULL)
        {
        DISPDBG((1, "DrvEnablePDEV - Failed EngAllocMem"));
        goto bEnableHardware_ReturnFalse;
        }

    //**************************************************************************
    // For each of the 8 subchannels, we set the 'FreeCount' register to 0xffff.
    // This effectively tells the software code that there's always plenty
    // of space in the FIFO (i.e...measure performance for hardware which
    // never has it's FIFO busy)
    //**************************************************************************

    nvptr = ppdev->TestChannelPtr;

    //**************************************************************************
    // Each sub-channel is 8k (nvptr is a pointer to ULONG values)
    // 'FreeCount' register exists 16 bytes after beginning of subchannel
    //**************************************************************************

    *(nvptr+(2048*0)+4) = 0xffffffff;
    *(nvptr+(2048*1)+4) = 0xffffffff;
    *(nvptr+(2048*2)+4) = 0xffffffff;
    *(nvptr+(2048*3)+4) = 0xffffffff;
    *(nvptr+(2048*4)+4) = 0xffffffff;
    *(nvptr+(2048*5)+4) = 0xffffffff;
    *(nvptr+(2048*6)+4) = 0xffffffff;
    *(nvptr+(2048*7)+4) = 0xffffffff;
#endif // ifdef PERFTEST

    //**************************************************************************
    // Get the linear memory address range for the FRAME buffer
    //**************************************************************************

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                           &VideoMemory,      // input buffer
                           sizeof(VIDEO_MEMORY),
                           &VideoMemoryInfo,  // output buffer
                           sizeof(VideoMemoryInfo),
                           &ReturnedDataLength))
        {
        DISPDBG((1, "bEnableHardware - Error mapping buffer address"));
        goto bEnableHardware_ReturnFalse;
        }

    //**************************************************************************
    // Record the Frame Buffer Linear Address in our PDEV structure.
    //**************************************************************************

    ppdev->pjFrameBufbase  = (BYTE*) VideoMemoryInfo.FrameBufferBase;

    //**************************************************************************
    // If necessary , map an IO port to workaround an ALI chipset cache issue
    //**************************************************************************

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI,
                           &AliVidMem,      // input buffer
                           sizeof(VIDEO_MEMORY),
                           &AliVidMemInfo,  // output buffer
                           sizeof(AliVidMemInfo),
                           &ReturnedDataLength))
        {
        DISPDBG((1, "bEnableHardware - Error mapping IO port for ALI"));
        goto bEnableHardware_ReturnFalse;
        }

    //**************************************************************************
    // We use the FrameBufferBase field  to return the IO base.
    // We use the FrameBufferlength field to signal if an ALI chipset is present of not.
    //**************************************************************************

    // No need to worry about ALI on IA64
#ifndef _WIN64
    ppdev->AliFixupIoBase   = (ULONG)(AliVidMemInfo.FrameBufferBase);
    ppdev->AliFixupIoNeeded = AliVidMemInfo.FrameBufferLength;
#else
    ppdev->AliFixupIoNeeded = FALSE;
#endif

    //**************************************************************************
    // Identifying
    // NV1 vs NV3:  We won't know what chip version of NV we're using until
    //              AFTER the first modeset occurs (in AssertModeHardware).
    //              That is, the miniport will store the CHIP ID information
    //              in the ppdev->flCaps field during QUERY_CURRENT_VIDEO_MODE
    //              (See DriverSpecificAttributeFlags)
    //**************************************************************************
    {
    union
    {
        ULONG osName;
        char devName[NV_DEVICE_NAME_LENGTH_MAX+1];
    } nameBuffer;

    // set the device handle
    ppdev->hDevice = DD_DEVICE_OBJECT_HANDLE;

    // escape the device class to the device reference
    ppdev->hDevClass = NV03_DEVICE_XX;
    nameBuffer.osName = ppdev->ulDeviceReference;

    // register the client and allocate a device
    ppdev->hClient = 0;
    if (NvAllocRoot(ppdev->hDriver, NV01_ROOT, &ppdev->hClient) != NVOS01_STATUS_SUCCESS)
        {
        DISPDBG((2, "NVDD: Cannot register as client to resource manager"));
        goto bEnableHardware_ReturnFalse;
        }


    if (NvAllocDevice(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, ppdev->hDevClass, nameBuffer.devName) != NVOS06_STATUS_SUCCESS)
        {
        DISPDBG((2, "NVDD: Cannot allocate a device"));
        NvFree(ppdev->hDriver, ppdev->hClient, NV01_NULL_OBJECT, ppdev->hClient);
        goto bEnableHardware_ReturnFalse;
        }
    }

    if (!AllocDmaPushBuf(ppdev))
        goto bEnableHardware_ReturnFalse;

    if (!AllocMemOncePerPdev(ppdev))
        goto bEnableHardware_ReturnFalse;

    // initialize the Gamma default values
    for(i = 0; i < NV_NO_DACS; i++)
    {
        ulOffset = i*256;
   
        for(j = 0 ; j < 256; j++)
        {
            ppdev->ajClutData[j + ulOffset].Red   = (UCHAR)j;   
            ppdev->ajClutData[j + ulOffset].Green = (UCHAR)j;
            ppdev->ajClutData[j + ulOffset].Blue  = (UCHAR)j; 
            ppdev->ajClutData[j + ulOffset].Unused = 0;
        }
    }

    //**************************************************************************
    // Now we can set the mode, and fill in the videomode information structure
    // as well as important PPDEV values
    //**************************************************************************

    if (!bAssertModeHardware(ppdev, TRUE))
        goto bEnableHardware_ReturnFalse;

#ifndef NV3
    //**********************************************************
    // Determine the NV Architecture revision.
    //**********************************************************
    NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                 NV_CFG_ARCHITECTURE, (ULONG *)(&(ppdev->dwDeviceVersion)));

    if (ppdev->dwDeviceVersion == NV_DEVICE_VERSION_4)
    {
        ULONG dwRevision;
        NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_REVISION, &dwRevision);
        if (dwRevision >= 1) ppdev->dwDeviceVersion = NV_DEVICE_VERSION_5;

       // The intermittent bug, 20001023-154559, hang the Graphic engine while performing INDEXED_IMAGE_FROM_CPU on NV5 only.
       // Disabling (NV4 and NV5 only) the Screen to memory blt would make HW happy for INDEXED_IMAGE_FROM_CPU.
       ppdev->pfnScreenToMemBlt        = NULL;
    }

#endif // !NV3

    
    //**************************************************************************
    // All done, return successful
    //**************************************************************************

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

    //**************************************************************************
    // Function failed
    //**************************************************************************

bEnableHardware_ReturnFalse:
    ASSERTDD(FALSE, "Failed bEnableHardware");

    return(FALSE);
    }

//******************************************************************************
//
//  Function:   vDisableHardware
//
//  Routine Description:
//
//      Undoes anything done in bEnableHardware.
//      Note: In an error case, we may call this before bEnableHardware is
//            completely done.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************

VOID vDisableHardware(
PDEV*   ppdev)

    {
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[15];

    FreeMemOncePerPdev(ppdev);
    FreeDmaPushBuf(ppdev);

    NvFree(ppdev->hDriver, ppdev->hClient, NV01_NULL_OBJECT, ppdev->hClient);
    ppdev->hClient = 0;

    //**************************************************************************
    //
    // OpenGL code:
    //
    // Unlock the OpenGL mutex and free it up.
    //
    //**************************************************************************
    DestroyOglGlobalMemory(ppdev);

    //**************************************************************************
    // Free up pointer to frame buffer memory
    //**************************************************************************

    if (ppdev->pjFrameBufbase)
    {
        VideoMemory[0].RequestedVirtualAddress = ppdev->pjFrameBufbase;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                               VideoMemory,
                               sizeof(VIDEO_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((1, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
        }
        ppdev->pjFrameBufbase = ppdev->pjScreen = NULL;
    }


    //**************************************************************************
    // Free up pointer to IO base for the ALI fixup
    //**************************************************************************

    if (ppdev->AliFixupIoBase)
    {
        VideoMemory[0].RequestedVirtualAddress = (PVOID)(ULONG_PTR)ppdev->AliFixupIoBase;
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI,
                               VideoMemory,
                               sizeof(VIDEO_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((1, "vDisableHardware failed IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI"));
        }

        ppdev->AliFixupIoBase   = 0;
        ppdev->AliFixupIoNeeded = FALSE;
    }

    //**************************************************************************
    // Free up the memory ranges. They're DIFFERENT depending
    // on which chip we're running on, because some ranges that exist
    // on one chip, may not exist on the other.
    //**************************************************************************

    //**************************************************************************
    // Free up pointer to NV device memory range
    //**************************************************************************

    if (ppdev->NvBaseAddr)
    {
        VideoMemory[0].RequestedVirtualAddress = (PVOID)(ppdev->NvBaseAddr);
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                               VideoMemory,
                               sizeof(VideoMemory),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((1, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
        }
        ppdev->NvBaseAddr = NULL;
    }

#ifdef PERFTEST
    if (ppdev->TestChannelPtr)
        EngFreeMem(ppdev->TestChannelPtr);
    ppdev->TestChannelPtr = NULL;
#endif  // ifdef PERFTEST
    if (ppdev->csCrtc)
        EngDeleteSemaphore(ppdev->csCrtc);
    if (ppdev->csFifo)
        EngDeleteSemaphore(ppdev->csFifo); // OpenGL code: free NV3 FIFO semaphore
    ppdev->csCrtc = ppdev->csFifo = NULL;
    }

//******************************************************************************
//
//  Function:   NvGetSupportedClasses
//
//  Routine Description:
//      Queries the resman for a list of supported classes on current hardware.
//      Fills in the ppdev->nvClassList and ppdev->nvNumClasses with this info
//
//  Arguments:
//      PDEV *
//
//  Return Value:
//
//      TRUE on success
//
//******************************************************************************

BOOL NvGetSupportedClasses(PDEV *ppdev) {
    
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS nvClassListParams;
    
    //**************************************************************************
    // Query the Resman for a list of supported classes
    //
    // First call RM to get the number of supported classes
    // Then call RM again to get fill a preallocated buffer with the class list
    //**************************************************************************
    ppdev->nvNumClasses = 0;
    
    if (ppdev->nvClassList != NULL) {
        EngFreeMem(ppdev->nvClassList);
        ppdev->nvClassList = NULL;
    }
    
    nvClassListParams.numClasses = 0;
    nvClassListParams.classBuffer = NULL;

    if (NVOS_CGE_STATUS_SUCCESS != 
        NvConfigGetEx (ppdev->hDriver,
                       ppdev->hClient,
                       ppdev->hDevice,
                       NV_CFGEX_GET_SUPPORTED_CLASSES, 
                       &(nvClassListParams),
                       sizeof(NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS)
                       )) {
        ASSERTDD(0,"Failed to get list of supported classes");
        return (FALSE);
    }
    ASSERTDD(nvClassListParams.numClasses > 0,"RM reported 0 supported classes");
    
    nvClassListParams.classBuffer = 
        EngAllocMem(0, nvClassListParams.numClasses * sizeof(NvU32), ALLOC_TAG);

    if (NULL == nvClassListParams.classBuffer) {
        return (FALSE);
    }
    
    if (NVOS_CGE_STATUS_SUCCESS != 
        NvConfigGetEx (ppdev->hDriver,
                       ppdev->hClient,
                       ppdev->hDevice,
                       NV_CFGEX_GET_SUPPORTED_CLASSES, 
                       &(nvClassListParams),
                       sizeof(NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS)
                       )) {
        ASSERTDD(0,"Failed to get list of supported classes");
        return (FALSE);
    }

    ppdev->nvClassList  = nvClassListParams.classBuffer;
    ppdev->nvNumClasses = nvClassListParams.numClasses;

    return TRUE;
}

//******************************************************************************
//
//  Function:   NvAllocDmaMemory
//
//  Routine Description:
//      Machine independent wrapper to allocate memory that will be accessed
//      by the adapter.  On 64 bit systems, the RM allocates the memory to
//      ensure that the memory will be addressible by the adapter.  On systems
//      that do not support physical addresses > 32 bits, a EngAllocMem()
//      works fine.
//
//  Return Value:
//
//       NVOS02_STATUS_SUCCESS on success
//
//******************************************************************************

ULONG NvAllocDmaMemory(PDEV *ppdev, PVOID *pAddress, ULONG hMemory, ULONG numBytes)
{
#if defined(_WIN64)
    ULONG limit = ROUND_TO_PAGES(numBytes) - 1;
    ULONG status;

    *pAddress = NULL;
    return (NvAllocMemory(ppdev->hDriver,
                         ppdev->hClient,
                         ppdev->hDevice,
                         hMemory,
                         NV01_MEMORY_SYSTEM,
                         DRF_DEF(OS02, _FLAGS, _LOCATION, _PCI) |
                         DRF_DEF(OS02, _FLAGS, _PHYSICALITY, _NONCONTIGUOUS),
                         pAddress,
                         &limit));
#else
    *pAddress = EngAllocMem(FL_ZERO_MEMORY, numBytes, ALLOC_TAG);
    if (*pAddress == NULL) {
        return NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES;
    } else {
        return NVOS02_STATUS_SUCCESS;
    }
#endif
}

//******************************************************************************
//
//  Function:   NvFreeDmaMemory
//
//  Routine Description:
//      Machine independent wrapper to free memory allocated with the
//      routine above.
//
//  Return Value:
//
//       NVOS00_STATUS_SUCCESS on success
//
//******************************************************************************
ULONG NvFreeDmaMemory(PDEV *ppdev, ULONG hMemory, PVOID pAddress)
{
#if defined(_WIN64)
    return (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, hMemory));
#else
    EngFreeMem(pAddress);
    return NVOS00_STATUS_SUCCESS;
#endif
}

//******************************************************************************
//
//  Function: NVInitDmaPushHardware
//
//  Routine Description:
//      Initializes DMA Push objects for NV4 and greater.
//
//  Arguments:
//
//  Return Value:
//      TRUE if successful
//      FALSE if unseccessful
//
//
//******************************************************************************

BOOL NVInitDmaPushHardware(
PDEV *ppdev)
    {
    Nv04ControlDma* nvDmaChannel;
    ULONG           i;
    ULONG           ReturnedDataLength;
    ULONG           status;

    DISPDBG((1, "NV_DISP:  Setting up NV4 and greater hardware for DMA Pusher..."));

    ppdev->bNVInitDmaCompleted = FALSE;

    if(!NvSetupContextDma(ppdev))
        goto NVInitDmaPushHardware_ReturnFalse;

    //**************************************************************************
    // Init local DMA push variables
    //**************************************************************************

    ppdev->nvDmaCount       = 0;
    ppdev->nvDmaCachedGet   = 0;
    ppdev->nvDmaCachedPut   = 0;
    ppdev->nvDmaPreviousPut = 0;
    ppdev->nvDmaWrapFlag    = FALSE;
    ppdev->nvDmaCachedFreeCount = (ppdev->DmaPushBufTotalSize>>2) - DMAPUSH_PADDING;
    ppdev->DmaPushBufCanUseSize = ppdev->nvDmaCachedFreeCount;

    //**************************************************************************
    // Allocate the DMA push channel
    //
    // DMA channel alloc parameters (NVOS07_PARAMETERS):
    //  IN  HANDLE hDriver  Driver Handle
    //  IN  V032 hObject;   unique, user defined handle
    //  IN  V032 hDevice;   currently unused -- use 0
    //  IN  V032 hClass;    currently unused -- use 0
    //  IN  V032 hError;    handle used to allocate the error notifier DMA context
    //  IN  V032 hBuffer;   handle used to allocate the data buffer DMA context
    //  IN  U032 offset;    initial offset into the buffer
    //  OUT P064 pChannel;  ptr to DMA push channel
    //
    //**************************************************************************

    ppdev->hDmaChannel = 0x11111111;  // Unique Handle

    //**************************************************************************
    // After this call, nvDmaChannel will contain the pointer to the DMA push channel
    //**************************************************************************

    ppdev->hDmaChannel = DD_DMA_CHANNEL_OBJECT_HANDLE;
    
    //**************************************************************************
    // Create Pushbuffer Channel DMA
    //**************************************************************************
    {
        NvU32 classes[] = {NV10_CHANNEL_DMA,NV04_CHANNEL_DMA, 0};
        ULONG fail = TRUE;

        for (i=0; classes[i] != 0; i++) {
            if (bClassSupported(ppdev,classes[i])) {
                if (NvAllocChannelDma(ppdev->hDriver,
                                      ppdev->hClient,
                                      ppdev->hDevice,
                                      ppdev->hDmaChannel,
                                      classes[i],
                                      NV_CONTEXT_DMA_PUSHBUF_ERROR_NOTIFIER,
                                      NV_CONTEXT_DMA_FROM_MEMORY_PUSHBUF,
                                      0,
                                      (PVOID)&nvDmaChannel) == NVOS07_STATUS_SUCCESS) {
                    fail = FALSE;
                    break;
                }
            }
        }
        if (fail) {
            DISPDBG((0, "NVDD: Cannot allocate DMA push channel"));
            goto NVInitDmaPushHardware_ReturnFalse;
        } else {
            ppdev->CurrentClass.ChannelDMA = classes[i];
        }
    }

    ppdev->nvDmaChannel = (ULONG *)nvDmaChannel;
    
    if(!NvSetupHwObjects(ppdev))
    {
        DISPDBG((0, "NVInitalDmaPushHardware: Cannot setup HW Objects"));
        goto NVInitDmaPushHardware_ReturnFalse;
    }


    //**************************************************************************
    // Create VIDEO_LUT_CURSOR_DAC object and setup DAC
    //**************************************************************************
    
    if (!NvInitialDac(ppdev)) 
    {
        DISPDBG((0, "NVInitalDmaPushHardware: Cannot initialize DAC"));
        goto NVInitDmaPushHardware_ReturnFalse;
    }

    if (!NvInitHwObjects(ppdev)) 
    {
        DISPDBG((0, "NVInitalDmaPushHardware: Cannot initialize HW Objects"));
        goto NVInitDmaPushHardware_ReturnFalse;
    }

    ppdev->bNVInitDmaCompleted = TRUE;

    return TRUE;



NVInitDmaPushHardware_ReturnFalse:

    //**************************************************************************
    // Remove ALL DMA contexts that we previously allocated!
    //**************************************************************************

    NVReleaseDmaPushHardware(ppdev,TRUE);
    return(FALSE);

} // end of NVInitDmaPushHardware()



//******************************************************************************
//
//  Function: NVReleaseDmaPushHardware
//
//  Routine Description:
//
//  Arguments:
//      A pointer to the physical device
//
//  Return Value:
//      TRUE if successful
//      FALSE if unseccessful
//
//
//******************************************************************************

VOID NVReleaseDmaPushHardware(
    PDEV *ppdev,
    BOOL InitDmaPushHardwareFailedFlag
)
{
    if(ppdev->bNVInitDmaCompleted)
        ppdev->pfnWaitEngineBusy(ppdev);

    //**************************************************************************
    // Ensure hw has completed processing prior to destroying objects.
    //
    // MAKE SURE that the RM is done updating the palette registers
    // before we start freeing the contexts associated with the colormap object
    // (Make sure the 2nd notifier array entry (index 1) is zero)
    //**************************************************************************

    //**************************************************************************
    // If we're releasing DMA contexts because InitDmaPushHardware failed,
    // then the pfnWaitEngineBusy ptr may *NOT* have been initialized.
    // So in this case, don't do a WaitForEnginebusy.
    //**************************************************************************

    if (InitDmaPushHardwareFailedFlag == FALSE)
        if(ppdev->bNVInitDmaCompleted)
            ppdev->pfnWaitEngineBusy(ppdev);

    NvFreeContextDma(ppdev);

    //**************************************************************************
    // Free up the DMA push channel
    //**************************************************************************
    if (ppdev->nvDmaChannel !=NULL)
        {

        NvFree(ppdev->hDriver,
               ppdev->hClient,
               ppdev->hDevice,
               ppdev->hDmaChannel);
        ppdev->nvDmaChannel = NULL;
        }

    return;
}

//******************************************************************************
//
//  Function: AllocDmaPushBuf(PDEV *)
//
//  Routine Description: Attempts to allocate push buf from AGP memory, if
//  there is no AGP memory it falls back to allocating the push buf from
//  system memory.
//  Allocate the DMA push BUFFER (at the very minimum, it should be 8k or larger)
//  Then allocate the DMA Context for the DMA push buffer
//
//  PushBufTotalSize should at the very minimum be large enough to hold
//  the largest possible scanline (width = 2k at 32bpp = 2048*4 = 8k)
//
//  Arguments:
//
//  Return Value:
//            TRUE or FALSE
//
//
//******************************************************************************
BOOL AllocDmaPushBuf(PDEV *ppdev)
{

ULONG   cbPushBuf = ppdev->DmaPushBufTotalSize - 1;
int i;

#if (defined(GDI_AGP_PUSHBUF) && (_WIN32_WINNT >= 0x0500) && (defined(NV4)))

// Attempt to alloc AGP mem to determine if AGP is enabled. Currently we don't
// use AGP mem for the GDI pushbuf. To enable the AGP GDI pushbuf,
// #define GDI_AGP_PUSHBUF.

    if (NvAllocMemory(ppdev->hDriver,
                        ppdev->hClient,
                        ppdev->hDevice,
                        NV_AGP_PUSHBUF_OBJECT_HANDLE,
                        NV01_MEMORY_SYSTEM,
                        (DRF_DEF(OS02, _FLAGS, _LOCATION, _AGP) | DRF_DEF(OS02, _FLAGS, _COHERENCY, _WRITE_COMBINE)),
                        (PVOID *)&(ppdev->AgpHeapBase),
                        &cbPushBuf))
    {
        ppdev->bAgp = FALSE;
        ppdev->AgpHeapBase = NULL;
        // AGP allocation failed;  will allocate it as NON-AGP device
    }
    else
    {
        ppdev->bAgp = TRUE;
        ppdev->nvDmaFifo = ppdev->AgpPushBuffer = ppdev->AgpHeapBase;

        goto DoneDmaPushAllocation;
    }
#endif

    //**********************************************************************
    // This is not an AGP device.
    //**********************************************************************
    ppdev->DmaPushBufMinSize   = 0x0;                 // Unused
    for(i = 0; i < 4; i++)
    {
        ppdev->DmaPushBufTotalSize = (DMAPUSH_BUFFER_SIZE >> i);
        if (NvAllocDmaMemory(ppdev,
                         &ppdev->nvDmaFifo,
                         NV_SYS_PUSHBUF_OBJECT_HANDLE,
                         ppdev->DmaPushBufTotalSize) != NVOS02_STATUS_SUCCESS)
        {
            DISPDBG((0, "AllocDmaPushBuf: Failed to allocate a %d byte DMA Push buffer", ppdev->DmaPushBufTotalSize));
        }
        else
        {
            goto DoneDmaPushAllocation;
        }
    }

    DISPDBG((0, "AllocDmaPushBuf: Failed to allocate DMA Push buffer"));
    ppdev->nvDmaFifo = NULL;
    return(FALSE);

DoneDmaPushAllocation:

    //**************************************************************************
    // Get location of a DWORD near the very end of the DMA Push buffer.
    // This is needed to workaround a VIA chipset problem.
    // The goal is to flush the chipset's locality/cache.
    // (This is part of the 'Flush Write-Combine Fix')
    // Back off 16 bytes from the end just to be safe.
    //**************************************************************************

    ppdev->nvDmaFlushFixDwordPtr = (ULONG *) ((BYTE *)(ppdev->nvDmaFifo) + ppdev->DmaPushBufTotalSize - 16);
    return(TRUE);


}

//******************************************************************************
//
//  Function: FreeDmaPushBuf(PDEV *)
//
//  Routine Description: 
//
//  Arguments:
//
//  Return Value:
//            None
//
//******************************************************************************
VOID FreeDmaPushBuf(PDEV * ppdev)
{
    if (ppdev->nvDmaFifo != NULL)
    {
// Free DMA push buffer.

#if (_WIN32_WINNT >= 0x0500) && (defined(NV4))
        if (ppdev->AgpPushBuffer)
            {
            ULONG   ReturnedDataLength;
            NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_AGP_PUSHBUF_OBJECT_HANDLE);
            ppdev->AgpPushBuffer = NULL;
            }
        else
#endif  // #if _WIN32_WINNT >= 0x0500
        if (NvFreeDmaMemory(ppdev, NV_SYS_PUSHBUF_OBJECT_HANDLE, ppdev->nvDmaFifo) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "NVDD: Cannot free DMA push buffer"));
        }
        ppdev->nvDmaFifo = NULL;
     }


}

//******************************************************************************
//
//  Function: AllocMemOncePerPdev(PDEV *)
//
//  Routine Description: Allocating necessary memory once for members in a PDEV
//
//  Arguments:
//
//  Return Value:
//      TRUE or FALSE
//
//******************************************************************************
BOOL AllocMemOncePerPdev(PDEV * ppdev)
{
    //**************************************************************************
    // Allocate the indexed image LUT buffer and context (system memory)
    //**************************************************************************

    if (NvAllocDmaMemory(ppdev,
                         &ppdev->NvDmaIndexedImageLut,
                         NV_INDEXED_IMAGE_LUT_OBJECT_HANDLE,
                         INDEXED_IMAGE_LUT_BUFFER_SIZE) != NVOS02_STATUS_SUCCESS)

    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate indexed image LUT buffer"));
        return(FALSE);
    }

    //**************************************************************************
    // Create our generic temporary buffer, which may be used by any
    // component. (mainly used by memory to memory format object)
    //
    // NOTE: Add 4K to buffer since there appears to be some hardware problem
    // with the Mem to Mem class that requires some additional space
    //**************************************************************************

    ppdev->MemToMemBufferSize = MEM_TO_MEM_BUFFER_SIZE;

    if (NvAllocDmaMemory(ppdev,
                         &ppdev->pMemToMemBuffer,
                         NV_MEM_TO_MEM_BUFFER_OBJECT_HANDLE,
                         MEM_TO_MEM_BUFFER_SIZE + (4*1024)) != NVOS02_STATUS_SUCCESS)
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate pMemToMemBuffer"));
        return(FALSE);
    }

    //**************************************************************************
    // Allocate our local copy of palette data
    //**************************************************************************

    if (NvAllocDmaMemory(ppdev,
                         &ppdev->ajClutData,
                         NV_CLUT_DATA_OBJECT_HANDLE,
                         sizeof(NV_VIDEO_CLUTDATA) * NV_NO_DACS * 256) != NVOS02_STATUS_SUCCESS)
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate ajClutData"));
        return(FALSE);
    }

    if (!NvGetSupportedClasses(ppdev)) 
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot Get Support Nv Classes"));
        return FALSE;
    }

    //*************************************************************************
    // Allocate memory used for notifiers
    //*************************************************************************

    if (NvAllocDmaMemory(  ppdev,
                           &ppdev->Notifiers,
                           NV_NOTIFIERS_OBJECT_HANDLE,
                           sizeof(NV_NOTIFIERS)))
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate notifier memory"));
        return(FALSE);
    }

#if defined(_WIN64)
    //*************************************************************************
    // Allocate memory used to save floating point state prior to OpenGL escape
    //*************************************************************************

    ppdev->fpStateSize = EngSaveFloatingPointState(NULL, 0);
    ppdev->fpState = EngAllocMem(0, ppdev->fpStateSize, ALLOC_TAG);
    if (ppdev->fpState == NULL)
    {
        DISPDBG((0, "AllocMemOncePerPdev: Cannot allocate memory for floating point state"));
        return(FALSE);
    }
#endif
    
    return(TRUE);


}


//******************************************************************************
//
//  Function: FreeMemOncePerPdev(PDEV *)
//
//  Routine Description: free memory for members in a PDEV
//
//  Arguments:
//
//  Return Value:
//      TRUE or FALSE
//
//******************************************************************************
VOID FreeMemOncePerPdev(PDEV * ppdev)
{
    //**************************************************************************
    // De-allocate memory for Indexed Image LUT buffer
    //**************************************************************************

    if (ppdev->NvDmaIndexedImageLut != NULL)
    {
        if (NvFreeDmaMemory(ppdev, NV_INDEXED_IMAGE_LUT_OBJECT_HANDLE, ppdev->NvDmaIndexedImageLut) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "FreeMemOncePerPdev: Cannot free indexed image LUT buffer"));
        }
        ppdev->NvDmaIndexedImageLut = NULL;
    }

    //**************************************************************************
    // Free our generic temporary buffer, which may be used by any
    // component. (mainly used by memory to memory format object)
    //**************************************************************************

    if (ppdev->pMemToMemBuffer != NULL)
    {
        if (NvFreeDmaMemory(ppdev, NV_MEM_TO_MEM_BUFFER_OBJECT_HANDLE, ppdev->pMemToMemBuffer) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "FreeMemOncePerPdev: Cannot free pMemToMemBuffer"));
        }
        ppdev->pMemToMemBuffer = NULL;
    }

    //**************************************************************************
    // Free our local copy of palette data
    //**************************************************************************

    if(ppdev->ajClutData != NULL)
    {
        if (NvFreeDmaMemory(ppdev, NV_CLUT_DATA_OBJECT_HANDLE, ppdev->ajClutData) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "FreeMemOncePerPdev: Cannot free ajClutData"));
        }
        ppdev->ajClutData = NULL;
    }

    //*************************************************************************
    // Free notifier memory
    //*************************************************************************

    if(ppdev->Notifiers != NULL)
    {
        if (NvFreeDmaMemory(ppdev, NV_NOTIFIERS_OBJECT_HANDLE, ppdev->Notifiers) != NVOS00_STATUS_SUCCESS)
        {
            DISPDBG((1, "FreeMemOncePerPdev: Cannot free notifier memory"));
        }
        ppdev->Notifiers = NULL;
    }

    //**************************************************************************
    // Free nvidia class list structure
    //**************************************************************************
    if(ppdev->nvClassList)
    {
        EngFreeMem(ppdev->nvClassList);
        ppdev->nvClassList = NULL;
    }

#if defined(_WIN64)
    //*************************************************************************
    // Free memory used to save floating point state
    //*************************************************************************

    if (ppdev->fpState != NULL)
    {
        EngFreeMem(ppdev->fpState);
        ppdev->fpState = NULL;
    }
#endif

}

//******************************************************************************
//
//  Function: NvValidateCaps
//
//  Routine Description: Validates all capabilities based on what classes were
//                       created in NVInitHardwareDmaPush()
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************

void NvValidateCaps(PDEV* ppdev) 
{
        // Query the graphics caps from the RM
    if (NvConfigGet(ppdev->hDriver,
                    ppdev->hClient,
                    ppdev->hDevice,
                    NV_CFG_GRAPHICS_CAPS,
                    &ppdev->hwGfxCaps)
        == NVOS13_STATUS_SUCCESS) {
        // Coolio!
    } else {
        ppdev->hwGfxCaps = 0;
    }
    
#ifdef NV3
    ppdev->ulSurfaceAlign = NV3_BYTE_ALIGNMENT_PAD;
    ppdev->ulSurfaceBitAlign = NV3_BIT_ALIGNMENT;
    ppdev->cxSurfaceMax = (8192 - NV3_BIT_ALIGNMENT/8) / ppdev->cjPelSize; //max_pitch / bytesPP
#else
    
    OglReadRegistry(ppdev);

    //******************************************************************
    // Set surface alignment
    //*************************************************************
    
    if (ppdev->CurrentClass.ContextSurfaces2D == NV10_CONTEXT_SURFACES_2D) {
        ppdev->ulSurfaceAlign = NV10_BYTE_ALIGNMENT_PAD;
        ppdev->ulSurfaceBitAlign = NV10_BIT_ALIGNMENT;
        ppdev->cxSurfaceMax = (65536 - NV10_BIT_ALIGNMENT/8) / ppdev->cjPelSize; //max_pitch / bytesPP
    } else if (ppdev->CurrentClass.ContextSurfaces2D == NV04_CONTEXT_SURFACES_2D) {
        ppdev->ulSurfaceAlign = NV4_BYTE_ALIGNMENT_PAD;
        ppdev->ulSurfaceBitAlign = NV4_BIT_ALIGNMENT;
        ppdev->cxSurfaceMax = (8192 - NV4_BIT_ALIGNMENT/8) / ppdev->cjPelSize; //max_pitch / bytesPP
    } else {
        ASSERTDD(0,"NvValidateCaps: Unsupported CONTEXT_SURFACES_2D");
    }
    
    //**************************************************************************
    // A little bit of validation based on what type of VIDEO_LUT_CURSOR_DAC
    // object we allocated.
    //**************************************************************************
    if (ppdev->CurrentClass.VideoLutCursorDac == NV10_VIDEO_LUT_CURSOR_DAC ||
        ppdev->CurrentClass.VideoLutCursorDac == NV15_VIDEO_LUT_CURSOR_DAC) {
        ppdev->ulMaxHwCursorDepth = 32;
        ppdev->ulMaxHwCursorSize = 64;
        if (ppdev->CurrentClass.VideoLutCursorDac == NV15_VIDEO_LUT_CURSOR_DAC) {
            ppdev->bSupportAlphaCursor = TRUE;
        } else {
            ppdev->bSupportAlphaCursor = FALSE;
        }
    } else {
        ppdev->ulMaxHwCursorDepth = 16;
        ppdev->ulMaxHwCursorSize = 32;
    }
    {
        int i;
        NvU32 classes11[] = { NV11_CELSIUS_PRIMITIVE };
        NvU32 classes20[] = { NV20_KELVIN_PRIMITIVE };
        
        ppdev->oglColor32Depth16 = FALSE;
        ppdev->oglColor16Depth32 = FALSE;
        ppdev->oglMultisample = FALSE;
        for (i=0; i < (sizeof(classes11)/sizeof(NvU32)); i++) {
            if (bClassSupported(ppdev,classes11[i])) {
                ppdev->oglColor32Depth16 = TRUE;
            }
        }
        for (i=0; i < (sizeof(classes20)/sizeof(NvU32)); i++) {
            if (bClassSupported(ppdev,classes20[i])) {
                ppdev->oglColor32Depth16 = TRUE;
                ppdev->oglColor16Depth32 = TRUE;
                ppdev->oglMultisample = TRUE;
            }
        }
    }
#endif    
}

//******************************************************************************
//
//  Function: NvSetupContextDma(PDEV *)
//
//  Routine Description: Allocating Context Dma
//
//  Arguments:
//
//  Return Value:
//      TRUE or FALSE
//
//******************************************************************************
#define SETUP_CTX_DMA(ppdev, ID, pAddr, size)                                                       \
{                                                                                                   \
    if (NvAllocContextDma(ppdev->hDriver,                                                           \
                          ppdev->hClient,                                                           \
                          ID,                                                                       \
                          NV01_CONTEXT_DMA,                                                         \
                          NVOS03_FLAGS_ACCESS_READ_WRITE,                                           \
                          (PVOID)(pAddr),                                                           \
                          size                                                                      \
                          ))                                                                        \
    {                                                                                               \
        DISPDBG((0, "NvSetupContextDma: Cannot allocate context dma for handle ID %08xh", ID));     \
        return(FALSE);                                                                              \
    }                                                                                               \
}                                                                                                   

BOOL NvSetupContextDma(PDEV * ppdev)
{
    ULONG i;

    SETUP_CTX_DMA(ppdev,DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM,              ppdev->pjFrameBufbase,             ppdev->cbFrameBuf);
    SETUP_CTX_DMA(ppdev,NV_DD_PRIMARY_2D_NOTIFIER_CONTEXT_DMA_TO_MEMORY, ppdev->Notifiers->Primary2d,       sizeof(NvNotification)*5 - 1);
    SETUP_CTX_DMA(ppdev,NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,   ppdev->Notifiers->DmaToMem,        sizeof(NvNotification)*2 - 1);
    SETUP_CTX_DMA(ppdev,NV_WIN_INDEXED_IMAGE_CONTEXT,                    ppdev->NvDmaIndexedImageLut,       INDEXED_IMAGE_LUT_BUFFER_SIZE - 1);
    SETUP_CTX_DMA(ppdev,DD_MEMORY_TO_MEMORY_CONTEXT_DMA_NOTIFIER,        ppdev->Notifiers->MemToMem,        sizeof(NvNotification)*2 - 1);
    SETUP_CTX_DMA(ppdev,DD_TEMP_BUFFER_CONTEXT_DMA,                      ppdev->pMemToMemBuffer,            ppdev->MemToMemBufferSize+4*1024-1);
    SETUP_CTX_DMA(ppdev,NV_CONTEXT_DMA_FROM_MEMORY_PUSHBUF,              ppdev->nvDmaFifo,                  ppdev->DmaPushBufTotalSize - 1);
    SETUP_CTX_DMA(ppdev,NV_CONTEXT_DMA_PUSHBUF_ERROR_NOTIFIER,           ppdev->Notifiers->DmaPushBufErr,   sizeof(NvNotification) - 1);
    SETUP_CTX_DMA(ppdev,NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER,    ppdev->Notifiers->VideoLutCursorDac,sizeof(NvNotification)*9-1);

    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        SETUP_CTX_DMA(ppdev,NV_WIN_COLORMAP_CONTEXT + ppdev->ulDeviceDisplay[i],
                            &ppdev->ajClutData[ppdev->ulDeviceDisplay[i]*256],
                            (256 * sizeof(VIDEO_CLUTDATA)) - 1);
    }

    for(i = 0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
    {
        SETUP_CTX_DMA(ppdev, NV_DD_FROM_MEM_INDEXED_IMAGE1_NOTIFIER_CONTEXT_DMA_TO_MEMORY+i,
                             &(ppdev->Notifiers->DmaToMemIndexedImage[i*sizeof(NvNotification)]),
                             sizeof(NvNotification) - 1);
    }

    return(TRUE);
}

//******************************************************************************
//
//  Function: NvFreeContextDma(PDEV *)
//
//  Routine Description: Free Allocated Context Dma
//
//  Arguments:
//
//  Return Value:
//      None
//
//******************************************************************************
#define FREE_CTX_DMA(ppdev, ID)                                                                 \
{                                                                                               \
    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, ID) != NVOS00_STATUS_SUCCESS)    \
    {                                                                                           \
        DISPDBG((1, "NvFreeContextDma: Cannot free DMA context of handle %d", ID));             \
    }                                                                                           \
}

VOID NvFreeContextDma(PDEV * ppdev)
{
    ULONG i;

    FREE_CTX_DMA(ppdev, DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    FREE_CTX_DMA(ppdev, NV_DD_PRIMARY_2D_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    FREE_CTX_DMA(ppdev, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    FREE_CTX_DMA(ppdev, NV_WIN_INDEXED_IMAGE_CONTEXT);                   
    FREE_CTX_DMA(ppdev, DD_MEMORY_TO_MEMORY_CONTEXT_DMA_NOTIFIER);
    FREE_CTX_DMA(ppdev, DD_TEMP_BUFFER_CONTEXT_DMA);                     
    FREE_CTX_DMA(ppdev, NV_CONTEXT_DMA_FROM_MEMORY_PUSHBUF);             
    FREE_CTX_DMA(ppdev, NV_CONTEXT_DMA_PUSHBUF_ERROR_NOTIFIER);          
    FREE_CTX_DMA(ppdev, NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER);

    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        FREE_CTX_DMA(ppdev,NV_WIN_COLORMAP_CONTEXT + ppdev->ulDeviceDisplay[i]);
    }

    for(i = 0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
    {
        FREE_CTX_DMA(ppdev, NV_DD_FROM_MEM_INDEXED_IMAGE1_NOTIFIER_CONTEXT_DMA_TO_MEMORY+i);
    }
}


//******************************************************************************
//
//  Function: NvInitHwObject(PDEV *)
//
//  Routine Description: Initializing hw Objects
//
//  Arguments:
//
//  Return Value:
//      None
//
//******************************************************************************
BOOL NvInitHwObjects(PDEV * ppdev)
{
    ULONG i;
    ULONG color0, color1;
    ULONG videoFmt;

    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    //**************************************************************************
    // Determine black and white colors
    //**************************************************************************

    switch (ppdev->iBitmapFormat)
    {
        case BMF_32BPP:
            color0 =    NV_ALPHA_1_32 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_32 | 0x00ffffff;         // WHITE
            videoFmt =  NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
            ppdev->AlphaEnableValue = NV_ALPHA_1_32;
            break;
        case BMF_16BPP:

            if (ppdev->flGreen == 0x03e0)
                {
                //**************************************************************
                // 5:5:5 format
                //**************************************************************

                color0 =    NV_ALPHA_1_16 | 0x00000000;     // BLACK
                color1 =    NV_ALPHA_1_16 | 0x00007fff;     // WHITE
                videoFmt =  NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2;
                ppdev->AlphaEnableValue = NV_ALPHA_1_16;        // 5:5:5 format
                }
            else
                {
                //**************************************************************
                // 5:6:5 format
                //**************************************************************

                color0 =   (NV_ALPHA_1_565 | 0x00000000);       // BLACK
                color1 =   (NV_ALPHA_1_565 | 0x0000ffff);       // WHITE
                videoFmt = NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
                ppdev->AlphaEnableValue = NV_ALPHA_1_565;       // 5:6:5 format
                }

            break;
        case BMF_8BPP:
            color0 =    NV_ALPHA_1_08 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_08 | 0x000000ff;         // WHITE
            videoFmt =  NV_VFM_FORMAT_COLOR_LE_Y8_P4;
            ppdev->AlphaEnableValue = NV_ALPHA_1_08;
            break;

        default:
            return(FALSE);
    }

    //**************************************************************************
    // Setup ROP5 SOLID
    //**************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(10)));

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NVFFF_SET_OBJECT(0),               DD_ROP5_SOLID);

    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(ROP_SOLID_SUBCHANNEL, NV043_SET_ROP5,                 0xcccc);

    //**************************************************************************
    // Setup IMAGE BLACK RECTANGLE
    //**************************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(12)));

    NV_DMAPUSH_WRITE1(CLIP_SUBCHANNEL, NVFFF_SET_OBJECT(0),                    DD_IMAGE_BLACK_RECTANGLE);

    NV_DMAPUSH_WRITE1(CLIP_SUBCHANNEL, NV019_SET_CONTEXT_DMA_NOTIFIES,      NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(CLIP_SUBCHANNEL, NV019_SET_POINT,                     0);
    NV_DMAPUSH_WRITE1(CLIP_SUBCHANNEL, NV019_SET_SIZE,                      ((0x7fff<<16) | 0x7fff));

    //*************************************************************************
    // Create the memory to memory format object.
    //*************************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(12)));

    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),           MY_MEMORY_TO_MEMORY);

    NV_DMAPUSH_WRITE1(DD_SPARE, NV039_SET_CONTEXT_DMA_NOTIFIES,     DD_MEMORY_TO_MEMORY_CONTEXT_DMA_NOTIFIER );
    NV_DMAPUSH_WRITE1(DD_SPARE, NV039_SET_CONTEXT_DMA_BUFFER_IN,    DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV039_SET_CONTEXT_DMA_BUFFER_OUT,   DD_TEMP_BUFFER_CONTEXT_DMA);

    ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;

    //**********************************************************************
    // Setup DST surface for device bitmaps
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(20)));
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),                    DD_PRIMARY_IMAGE_IN_MEMORY);

    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_CONTEXT_DMA_NOTIFIES,      NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_CONTEXT_DMA_IMAGE_SOURCE,  DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_CONTEXT_DMA_IMAGE_DESTIN,  DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);

    // Determine the color format
    switch (ppdev->iBitmapFormat) {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
            break;
        case BMF_8BPP:
            NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_COLOR_FORMAT, NV042_SET_COLOR_FORMAT_LE_Y8);
            break;
        default:
            return(FALSE);
    }

    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_PITCH,                 ( ((ppdev->lDelta) << 16) |  (ppdev->lDelta)) ) ;
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_OFFSET_SOURCE,         ppdev->ulPrimarySurfaceOffset);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV042_SET_OFFSET_DESTIN,         ppdev->ulPrimarySurfaceOffset);

    //**********************************************************************
    // Setup CONTEXT PATTERN
    //**********************************************************************

    NV_DMAPUSH_CHECKFREE(((ULONG)(24)));
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NVFFF_SET_OBJECT(0),       DD_IMAGE_PATTERN);

    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A16R5G6B5);
            break;
        case BMF_8BPP:
            // Must be set to a legal value but hardware ignores it otherwise
            NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_COLOR_FORMAT, NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_FORMAT,        NV044_SET_MONOCHROME_FORMAT_CGA6_M1);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_SHAPE,         NV044_SET_MONOCHROME_SHAPE_64X_1Y);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_SELECT,           NV044_SET_PATTERN_SELECT_MONOCHROME);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_COLOR0,        color0);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_COLOR1,        color1);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_PATTERN0,      0xffffffff);
    NV_DMAPUSH_WRITE1(IMAGE_PATTERN_SUBCHANNEL, NV044_SET_MONOCHROME_PATTERN1,      0x50505050);

    //**********************************************************************
    // Y8 default pattern values
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(17)));
    NV_DMAPUSH_START(16, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_Y8(0));
    for (i=0;i<16;i++)
        NV_DMA_FIFO = 0xffffffff;

    //**********************************************************************
    // R5G6B5 default pattern values
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(33)));
    NV_DMAPUSH_START(32, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_R5G6B5(0));
    for (i=0;i<32;i++)
        NV_DMA_FIFO = 0xffffffff;

    //**********************************************************************
    // X1R5G5B5 default pattern values
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(33)));
    NV_DMAPUSH_START(32, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_X1R5G5B5(0));
    for (i=0;i<32;i++)
        NV_DMA_FIFO = 0xffffffff;

    //**********************************************************************
    // X8R8G8B8 default pattern values
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(65)));
    NV_DMAPUSH_START(64, IMAGE_PATTERN_SUBCHANNEL, NV044_SET_PATTERN_X8R8G8B8(0));
    for (i=0;i<64;i++)
        NV_DMA_FIFO = 0xffffffff;

    //**********************************************************************
    // Setup CONTEXT COLOR KEY
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(12)));
    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),                DD_IMAGE_SOLID);

    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_CONTEXT_DMA_NOTIFIES,  NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    // Determine the color format
    switch (ppdev->iBitmapFormat) {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, NV057_SET_COLOR_FORMAT_LE_A8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, NV057_SET_COLOR_FORMAT_LE_A16R5G6B5);
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR_FORMAT, NV057_SET_COLOR_FORMAT_LE_A8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    NV_DMAPUSH_WRITE1(DD_SPARE, NV057_SET_COLOR, 0);  // Disabled

    ppdev->dDrawSpareSubchannelObject = DD_IMAGE_SOLID;

    //******************************************************************
    // Setup multiple Indexed Image From CPU objects (565 format)
    //
    // Each object has an associated LUT context DMA and a notifier.
    // This is necessary since a LUT can't be updated until the operation
    // is completed. To improve performance, many objects were created so
    // that we didn't have to wait for the previous indexed image operation
    // to be completed.
    //
    // NOTE:  We CAN NOT use the COLOR_KEY (IMAGE_SOLID)
    //        if ROP_OPERATION = ROP_AND
    //******************************************************************                                                 
    for(i=0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
    {
        NV_DMAPUSH_CHECKFREE(((ULONG)(22)));
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NVFFF_SET_OBJECT(0),                  DD_INDEXED_IMAGE1_FROM_CPU + i);

        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_DMA_LUT,         NV_WIN_INDEXED_IMAGE_CONTEXT);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_DMA_NOTIFIES,
                          NV_DD_FROM_MEM_INDEXED_IMAGE1_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_CLIP_RECTANGLE,  DD_IMAGE_BLACK_RECTANGLE);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_PATTERN,         DD_IMAGE_PATTERN);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_ROP,             DD_ROP5_SOLID);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_CONTEXT_SURFACE,         DD_PRIMARY_IMAGE_IN_MEMORY);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_COLOR_CONVERSION,        NV060_SET_COLOR_CONVERSION_TRUNCATE);
        NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_OPERATION,               NV060_SET_OPERATION_ROP_AND);

        // Determine the color format
        switch (ppdev->iBitmapFormat) 
        {
            case BMF_32BPP:
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_COLOR_FORMAT, NV060_SET_COLOR_FORMAT_LE_X8R8G8B8);
                break;
            case BMF_16BPP:
                // In 16bpp, hardware will dither when using R5G6B5, so we must use X8R8G8B8 to get the exact desired results
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_COLOR_FORMAT, NV060_SET_COLOR_FORMAT_LE_X8R8G8B8);
                break;
            case BMF_8BPP:
                // Does hardware ignore this value???
                NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV060_SET_COLOR_FORMAT, NV060_SET_COLOR_FORMAT_LE_X8R8G8B8);
                break;
            default:
                return(FALSE);
        }
    }

    //**********************************************************************
    // Setup Image From CPU (565 format)
    //
    // NOTE:  We CAN NOT use the COLOR_KEY (IMAGE_SOLID)
    //        if ROP_OPERATION = ROP_AND
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(20)));
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NVFFF_SET_OBJECT(0),                  DD_IMAGE_FROM_CPU);

    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_DMA_NOTIFIES,    NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_CLIP_RECTANGLE,  DD_IMAGE_BLACK_RECTANGLE);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_PATTERN,         DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_ROP,             DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_BETA4,           NV_DD_CONTEXT_BETA4);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_CONTEXT_SURFACE,         DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_OPERATION,               NV061_SET_OPERATION_ROP_AND);

    // Determine the color format
    switch (ppdev->iBitmapFormat) {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_R5G6B5);
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            NV_DMAPUSH_WRITE1(IMAGE_FROM_CPU_SUBCHANNEL, NV061_SET_COLOR_FORMAT, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    //**********************************************************************
    // Setup Image BLIT (565 format)
    //
    // NOTE:  We CAN NOT use the COLOR_KEY (IMAGE_SOLID)
    //        if ROP_OPERATION = ROP_AND
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(18)));
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NVFFF_SET_OBJECT(0),                    DD_IMAGE_BLIT);

    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_DMA_NOTIFIES,      NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_CLIP_RECTANGLE,    DD_IMAGE_BLACK_RECTANGLE);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_PATTERN,           DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_ROP,               DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_BETA4,             NV_DD_CONTEXT_BETA4);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_CONTEXT_SURFACES,          DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_DMAPUSH_WRITE1(BLIT_SUBCHANNEL, NV05F_SET_OPERATION,                 NV05F_SET_OPERATION_ROP_AND);

    //**********************************************************************
    // Setup RECT and TEXT  (565 format)
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(22)));
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NVFFF_SET_OBJECT(0),               DD_RENDER_RECT_AND_TEXT);

    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_DMA_FONTS,    DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_PATTERN,      DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_ROP,          DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_CONTEXT_SURFACE,      DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_OPERATION,            NV04A_SET_OPERATION_ROP_AND);

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_COLOR_FORMAT, NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_COLOR_FORMAT, NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5);
            break;
        case BMF_8BPP:
            NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_COLOR_FORMAT, NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    NV_DMAPUSH_WRITE1(RECT_AND_TEXT_SUBCHANNEL, NV04A_SET_MONOCHROME_FORMAT,    NV04A_SET_MONOCHROME_FORMAT_CGA6_M1);

    NV_DMAPUSH_CHECKFREE(((ULONG)(20)));

    //**********************************************************************
    // Setup SOLID_LINE
    //**********************************************************************
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NVFFF_SET_OBJECT(0),                   DD_IMAGE_ROP_AND_LIN);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_DMA_NOTIFIES,     NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_CLIP_RECTANGLE,   DD_IMAGE_BLACK_RECTANGLE);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_PATTERN,          DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_ROP,              DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_CONTEXT_SURFACE,          DD_PRIMARY_IMAGE_IN_MEMORY);
    NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_OPERATION,                NV05C_SET_OPERATION_ROP_AND);
    ppdev->dDrawSpareSubchannelObject     = DD_IMAGE_ROP_AND_LIN;

    // Determine the color format
    switch (ppdev->iBitmapFormat) {
        case BMF_32BPP:
            NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_COLOR_FORMAT, NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        case BMF_16BPP:
            NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_COLOR_FORMAT, NV05C_SET_COLOR_FORMAT_LE_X16R5G6B5);
            break;
        case BMF_8BPP:
            NV_DMAPUSH_WRITE1(SOLID_LIN_SUBCHANNEL, NV05C_SET_COLOR_FORMAT, NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8);
            break;
        default:
            return(FALSE);
    }

    if (ppdev->cjPelSize>1)
    {
        ASSERT((2==ppdev->cjPelSize) || (4==ppdev->cjPelSize));

        NV_DMAPUSH_CHECKFREE(((ULONG)(10)));

        /* Set color key blit object into subchannel. */
        NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),            DD_IMAGE_BLIT_COLORKEY);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV05F_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV05F_SET_CONTEXT_SURFACES,     DD_PRIMARY_IMAGE_IN_MEMORY);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV05F_SET_CONTEXT_COLOR_KEY,    DD_IMAGE_SOLID);
        NV_DMAPUSH_WRITE1(DD_SPARE, NV05F_SET_OPERATION,            NV05F_SET_OPERATION_SRCCOPY_AND); // SRCCOPY doesn't support color key

        ppdev->dDrawSpareSubchannelObject = DD_IMAGE_BLIT_COLORKEY;
    }    

    //**********************************************************************
    // Setup ALPHA IMAGE FROM MEMORY
    //**********************************************************************
    NV_DMAPUSH_CHECKFREE(((ULONG)(8*2)));
    NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0),            DD_ALPHA_IMAGE_FROM_MEMORY);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_DMA_NOTIFIES, NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_DMA_IMAGE,    DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_PATTERN,      DD_IMAGE_PATTERN);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_ROP,          DD_ROP5_SOLID);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_CONTEXT_BETA4,        NV_DD_CONTEXT_BETA4);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_COLOR_FORMAT,         NV077_SET_COLOR_FORMAT_LE_A8R8G8B8);
    NV_DMAPUSH_WRITE1(DD_SPARE, NV077_SET_OPERATION,            NV077_SET_OPERATION_BLEND_PREMULT);

    ppdev->dDrawSpareSubchannelObject = DD_ALPHA_IMAGE_FROM_MEMORY;

    //**************************************************************************
    // Make sure to update the DMA count before we kickoff!
    //**************************************************************************
    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);

    ((NvNotification *) (ppdev->Notifiers->Primary2d))->status = 0;

    ((NvNotification *) (ppdev->Notifiers->DmaToMem))->status = 0;

    ((NvNotification *) (&(ppdev->Notifiers->DmaToMem[NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY*sizeof(NvNotification)])))->status = NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS;

    ppdev->NvLastIndexedImageNotifier = 0;

    for(i = 0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
        ((NvNotification *) (&(ppdev->Notifiers->DmaToMemIndexedImage[i*sizeof(NvNotification)])))->status = NV060_NOTIFICATION_STATUS_DONE_SUCCESS;

    return(TRUE);
}

BOOL NvSetupHwObjects(PDEV * ppdev)
{

    ULONG i;

    NV_CREATE_OBJECT_SETUP();

    //**************************************************************************
    // Create misc objects that we need
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA1(DD_ROP5_SOLID,                NV03_CONTEXT_ROP);
    NV_CREATE_OBJECT_DMA1(NV_DD_CONTEXT_BETA4,          NV04_CONTEXT_BETA);
    NV_CREATE_OBJECT_DMA1(MY_MEMORY_TO_MEMORY,          NV03_MEMORY_TO_MEMORY_FORMAT);
    NV_CREATE_OBJECT_DMA1(DD_IMAGE_BLACK_RECTANGLE,     NV01_IMAGE_BLACK_RECTANGLE);
    NV_CREATE_OBJECT_DMA1(DD_IMAGE_PATTERN,             NV04_CONTEXT_PATTERN);
    NV_CREATE_OBJECT_DMA1(DD_IMAGE_SOLID,               NV04_CONTEXT_COLOR_KEY);
    if (NV_CREATE_OBJECT_FAIL()) {
        DISPDBG((0, "NVDD: Cannot allocate misc objects"));
        return(FALSE);
    }

    //**************************************************************************
    // Create INDEXED_IMAGE_FROM_CPU objects
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    for(i = 0; i < MAX_INDEXED_IMAGE_NOTIFIERS; i++)
    {
        NV_CREATE_OBJECT_DMA2(DD_INDEXED_IMAGE1_FROM_CPU + i,
                          NV05_INDEXED_IMAGE_FROM_CPU,NV04_INDEXED_IMAGE_FROM_CPU)
    }
    if (NV_CREATE_OBJECT_FAIL()) {
        DISPDBG((0, "NVDD: Cannot allocate INDEXED_IMAGE_FROM_CPU"));
        return(FALSE);
    } else {
        ppdev->CurrentClass.IndexedImageFromCPU = NV_CREATE_OBJECT_CLASS();
    }

    //**************************************************************************
    // Create CONTEXT_SURFACES_2D object
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA2(DD_PRIMARY_IMAGE_IN_MEMORY,
                          NV10_CONTEXT_SURFACES_2D,NV04_CONTEXT_SURFACES_2D);
    if (NV_CREATE_OBJECT_FAIL()) {
        DISPDBG((0, "NVDD: Cannot allocate CONTEXT_SURFACES"));
        return(FALSE);
    } else {
        ppdev->CurrentClass.ContextSurfaces2D = NV_CREATE_OBJECT_CLASS();
    }

    //**************************************************************************
    // Create IMAGE objects
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA2(DD_IMAGE_BLIT,           NV15_IMAGE_BLIT,NV04_IMAGE_BLIT);
    NV_CREATE_OBJECT_DMA1(DD_RENDER_RECT_AND_TEXT, NV04_GDI_RECTANGLE_TEXT);
    NV_CREATE_OBJECT_DMA1(DD_IMAGE_ROP_AND_LIN,    NV04_RENDER_SOLID_LIN);
    NV_CREATE_OBJECT_DMA2(DD_IMAGE_FROM_CPU,
                          NV05_IMAGE_FROM_CPU,NV04_IMAGE_FROM_CPU);

    if (NV_CREATE_OBJECT_FAIL()) {
        DISPDBG((0, "NVDD: Cannot allocate IMAGE objects"));
        return(FALSE);
    }

    //**************************************************************************
    // Create SCALED_IMAGE object used by ESC_NV_DESKMGR_ZOOMBLIT
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA1(DD_SCALED_IMAGE_FROM_MEMORY,
                          NV10_SCALED_IMAGE_FROM_MEMORY);

    if (NV_CREATE_OBJECT_FAIL()) {
        ppdev->CurrentClass.ScaledImageFromMemory = 0;
    } else {
        ppdev->CurrentClass.ScaledImageFromMemory = NV_CREATE_OBJECT_CLASS();
    }


    //**************************************************************************
    // Create objects needed to to a color key transparent blit 
    // for the overly merge blit. Only supported in 16 or 32 bpp
    //**************************************************************************
    if (ppdev->cjPelSize>1)
    {
        ASSERT((2==ppdev->cjPelSize) || (4==ppdev->cjPelSize));

        NV_CREATE_OBJECT_INIT();
        NV_CREATE_OBJECT_DMA1(DD_IMAGE_BLIT_COLORKEY, NV04_IMAGE_BLIT);

        if (NV_CREATE_OBJECT_FAIL()) 
        {
            DISPDBG((0, "Cannot allocate DD_IMAGE_BLIT_COLORKEY overlay merge blit objects"));            
            return(FALSE);
        }
    }

    //**************************************************************************
    // Create ALPHA IMAGE FROM MEMORY object used for AlphaBlended CopyBlt
    //**************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_DMA2(DD_ALPHA_IMAGE_FROM_MEMORY,
                          NV10_SCALED_IMAGE_FROM_MEMORY, NV04_SCALED_IMAGE_FROM_MEMORY);

    if (NV_CREATE_OBJECT_FAIL()) 
    {
        DISPDBG((0, "Cannot allocate DD_ALPHA_IMAGE_FROM_MEMORY object"));            
        return(FALSE);
    } else {
        ppdev->CurrentClass.AlphaImageFromMemory = NV_CREATE_OBJECT_CLASS();
    }

    return(TRUE);
}


BOOL bClassSupported(PDEV *ppdev, NvU32 classID)
{
    unsigned int i=0;
    while (i < ppdev->nvNumClasses) {
        if (ppdev->nvClassList[i] == classID) {
            return (TRUE);
        }
        i++;
    }
    return (FALSE);
}



//******************************************************************************
//
//  Function:   NvCreateObject
//
//  Routine Description:
//      Creates a DMA or PIO object given an array of classes.  Walks down array and
//      determines which class is supported by the current hardware.  Once it
//      finds a supported class, it allocates the object.
//      We use this to create the highest known class of a particular type. 
//
//      ie.  NV_CONTEXT_SURFACES_2D which try first with NV10_CONTEXT_SURFACES_2D 
//      and then NV04_CONTEXT_SURFACES_2D
//
//  Arguments:
//      A bunch
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NvCreateObject(PDEV *ppdev,
                    BOOL bCreateDMA,
                    PVOID parms, 
                    NvU32 obj, 
                    NvU32 *createObjClass,
                    NvU32 *createObjFail,
                    int numclasses, 
                    NvU32 *classes) {
    
    int i;                                                                    
    ULONG channel;

    if (bCreateDMA) {
        channel = ppdev->hDmaChannel;
    } else {
        channel = ppdev->hPioChannel;
    }
    *createObjFail |= 1;  // Fail by default
    *createObjClass = 0; 
    for (i=0; i<numclasses; i++) {                      
        if (bClassSupported(ppdev,classes[i])) {
            *createObjClass = classes[i];                                          
                if (NvAlloc(ppdev->hDriver,                                  
                            ppdev->hClient,                                  
                            channel,
                            (obj),                                           
                            (*createObjClass),
                            (parms)) == NVOS05_STATUS_SUCCESS){   
                    *createObjFail &= ~(0x1);                                            
                }                                                                     
            break;
        }
    }                                                                         
    *createObjFail <<= 1;                                                      
}





//******************************************************************************
//
//  Function:   vCalibrate_XferSpeeds
//
//
//  Routine Description:
//
//      This routine calibrates the xfer speeds of the CPU transfers,
//      the DMA xfers, the DMA hardware overhead, the CPU overhead to
//      setup a xfer.  The routine then combine these values into a 
//      single factor in pdev (globalXferOverheadFactor) that will be
//      used in the NVScreenToMem routine to decide which size to take
//      for the xfer chunks. ( The details are in the math. model )
//
//           - Stephane
//
//  Arguments:
//
//      Ptr to PDEV describing the physical device.
//
//  Return Value:
//
//      None.
//
//  Note:
//
//      **IMPORTANT**  This routine include (copy pasted) the actual code of
//                     the function call NV4_DmaPushSend.  This means that
//                     ANY changes to NV4_DmaPushSend must be reflected in
//                     here.  (This is not very good, but this function needs
//                     this to be more accurate)
//
//******************************************************************************


VOID vCalibrate_XferSpeeds(PDEV *ppdev)
{ 
    //***[ For calibration routine ]***[CALIBLOCALS]*****
    
    #define NV_MTMF_FORMAT_INPUT_INC_1     0x00000001
    #define NV_MTMF_FORMAT_OUTPUT_INC_1    0x00000100
    
    ULONG               j;
    
    LONGLONG            llCntrFreq;
    LONGLONG            llTimeStamp1;
    LONGLONG            llTimeStamp2;
    
    BYTE*               SysMemBuffer;
    BYTE*               limit;
    BYTE*               pjFinalDstWrite;
    BYTE*               pjDmaRead;
    BYTE*               pjDmaRead_start;
    
    ULONG               bytesPerLine_max;
    ULONG               bytesPerLine;
    ULONG volatile      volatileDummy;
    BYTE * volatile     volatileDummyPtr;
    ULONG               linesPerXfer;
    ULONG               SrcDMAOffset;
    ULONG               DstDMAOffset;
    ULONG               DstDMA2ndPartOffset;
    ULONG               SrcDMAincPerXfer;
    ULONG               linesToGo;
    
    LONG                lSrcPitch;
    LONG                lDstPitch;
    LONG                FinalDstJump2NextLineBeg;
    
    double              dfX;
    double              dfY;
    double              dfOH;
    double              dfK;
    double              dfTime;
    double              dfFactor;
    
    Nv04ControlDma      *nvDmaChannel;
    NvNotification      *pNotifier;
    
    DECLARE_DMA_FIFO;               // Local fifo var declare (ULONG nvDmaCount, * nvDmaFifo;)
        
    //***[ End of locals for calibration routine ]*******
    //*********************************[CALIBLOCALSEND]**

       
    
    
    
   
    //**************************************************************************
    //*[ Profiling Stuff BEGIN ]***[CALIBSTART]*********************************
    //**************************************************************************   
    //************************************************************************** 
    //
    //               SPEED CALIBRATION FOR CONCURENT DMA/CPU XFERS
    //                              
    //                                  - Stephane
    //
    //************************************************************************** 
    // Setup calibration data and calculate and store a "special" num
    // in ppdev->globalXferOverheadFactor.  (There is mathematical/algorithmic
    // details that are not explained in this function, ask me for details)
    // 
    //
    // We have to calculate 
    //
    // X     ( DMAXfer speed )
    // Y     ( DMAXfer speed )
    // OH    ( overhead between issuing command, and DMAXfer actually start and
    //         get into high (well, constant plateau speed ))
    // k     ( overhead of setting up a xfer )
    //
    //
    //  To approximate OH we kick a very small Xfer, and to approximate X,
    //  we set a long transfer, time it, substract OH from time, and compute 
    //  bytes/time.  To approximate Xaj, we use data from long xfer without
    //  substracting OH.
    //
    
    
    
    //**************************************************************************
    // Initialize notifier pointer to second notification structure
    //**************************************************************************
    
    pNotifier = (NvNotification *) (&(ppdev->Notifiers->MemToMem[NV039_NOTIFIERS_BUFFER_NOTIFY*sizeof(NvNotification)]));
        
    
    //**************************************************************************
    //                                                                         *
    // Get push buffer global information (from pdev) into local variables
    //
    //************************************************************************* 
    
    INIT_LOCAL_DMA_FIFO;            // local fifo var = pdev fifo var;
    
    //*                                                                        *
    //**************************************************************************
    
    
    if ( ppdev->pfnScreenToMemBlt != NULL ) // if this function can be called!
    {                                       // or else profiling data is useless
                                            // and moreover, if we are on NV3,
                                            // there is no DMA push buffer
        
        // Make sure our Mem2Mem object is in spare subchannel
        
        NV_DMAPUSH_CHECKFREE(((ULONG)(2)));
    
        if (ppdev->dDrawSpareSubchannelObject != MY_MEMORY_TO_MEMORY)
        {
            NV_DMAPUSH_WRITE1(DD_SPARE, NVFFF_SET_OBJECT(0), MY_MEMORY_TO_MEMORY);
            ppdev->dDrawSpareSubchannelObject = MY_MEMORY_TO_MEMORY;
            
            UPDATE_PDEV_DMA_COUNT;   //
            NV4_DmaPushSend(ppdev);  // Flush now, to avoid overhead interfering with calibration
        }
    
    
        //**********************************************************************
        //  Good. We are on NV4 or above, and this function is present. 
        //  We are going to setup variables needed to execute a Vram to SysMem 
        //  Xfer via an intermediate buffer (the DMA locked Mem2Mem buffer)
        //  We need to allocate system memory to simulate a destination bitmap
        //  of a destination region. But how big do we create this region? See:
        //**********************************************************************
    
        //  NOTE to get more "accurate" calibration results.
        //  ----------------------------------------------------------
        //
        //        Either prevent optimization of compiler with a special pragma,
        //        OR prevent optimization by setting data type qualifier to VOLATILE
        //        OR make a dummy function accepting all these parameters by adress,
        //        that do not modify them, so that the compiler flag these vars as
        //        being "unoptimizable" due to use (in the call to the dummy()) 
        //        between initialisation and the use of their value here (below)
        //        
        //        The reason why we want to prevent this is to be more precise in the
        //        profiling: if NV_DMA_FIFO == 1, this might be translated as something
        //        like
        //                      -> adress of dma fifo + dmacount (see dmamacro.h)
        //                     |
        //              mov [ebx],1              ; value appended as immediate operhand in
        //                                       ; actual opcode.
        //
        //        instead of
        //
        //              mov eax, [ebp + ??]      ; put local value into reg
        //              mov [ebx],eax            ; put local value into fifo
        //
        //        The following variables are affected by this remark:
        //        (see Nv4ScreenToMemBlt in nv4bltc.c )
        //        
        //        SrcDMAOffset          : Because it is based on the pjSrcBits which
        //                                is based on the src surface we normally 
        //                                receive in Nv4ScreenToMemBlt
        //
        //        lSrcPitch             : (same thing)
        //        bytesPerLine          : (based on the format of the region we get...)
        //        linesPerXfer          : (based on the optimum byte per xfer runtime
        //                                 algo - this calibration is for that algo!)
        //        linesToGo             : (used in the real loop of the xfer per chunk,
        //                                 even tough here it may never be used, and
        //                                 could be pulled out of this code by the 
        //                                 compiler) BUT SEE NOTE BELOW
        //        
        //        SrcDmaincPerXfer      : This don't change in the loops, but still, the
        //                                values must NOT be included in the ADD opcode
        //                                as immediates by the compiler, because in reality,
        //                                (in NV4ScreenToMemBlt), this would really be
        //                                computed runtime.
        //
        // 
        //
        //        FinalDstJump2NextLineBeg :  ( same thing here)
        //
        //        By the way, pjDmaRead is NOT affected, because we use it as in the "real"
        //        case, that is, it gets = to pdev->MemToMemBuffer
        //
        //  NOTE: There might be some unintended side effects by using Volatile, in that
        //        if we use directly the volatile variables in the loop, those might not
        //        be "cached" into registers.  One way to avoid this is to declare dummy
        //        "mirror" volatile variables, assign the static value to them, and then,
        //        init the normal variables with the content of these "mirror" variables.
        //        That way, the compiler has no choice but to take into account that
        //        these variables MUST be used and the compiler cannot assume any value
        //        at one point in the program after their assignation, since the assignation
        //        values were provided by volatiles, which can, by definition, have any 
        //        values any time.
        //        For linesToGo, it is tricky: we don't want to put THIS variable volatile
        //        to prevent unwanted side effects, but we HAVE to use it or else compiler
        //        will remove it.  So one way to prevent this is to assign a volatile to
        //        the value of linesToGo.
        //
        //  The best solution seems to be to use the "mirror-volatile-init-method" because
        //  disabling optimization could impact the calibration because our "real" code in
        //  ScreenToMem blt IS optimized by the compiler.
        //
    
        
        
        EngQueryPerformanceFrequency(&llCntrFreq);  // get the counter frequency
    
        ppdev->pfnWaitEngineBusy( ppdev );          // because we want to time the overhead 
                                                    // of processing the stuff comming next,
                                                    // not including previous commands that
                                                    // might be still pending or running...
    
        UPDATE_LOCAL_DMA_COUNT;                     // !!!RESYNC the local fifo count because
                                                    // wait busy modifies them!!!!
        
        
        // Find an arbitrary bitmap size (height*width) fitting in the
        // mem2mem buffer by taking the squareroot of its size.
        // we will still limit the transfer to 3.5 MB because we don't
        // know how much vram the card has (well we know but where
        // in the driver this info is stored ? ) Anyway, no card has
        // a framebuffer less than 4 MB, (but to be safe, we're going
        // to put about 3.5 meg, just in case (instance memory ? ) )
        //
        // We take the squareroot for bytesperline because we are
        // going to use that same number as our number of lines
        //
    
        if ( ppdev->MemToMemBufferSize > 3655744 )
        {
            bytesPerLine_max = 1912; // clamp to sqrt(3.486 Meg)                                                                
        }
        else // else use mem2mem buffer size since it is < 3.5 meg
             // (we dont want to use 1912, because mem2mem is smaller
             // than 3.5 meg so we would corrupt mem past the buffer)
             // in other words, take Minimum( 1912, sqrt(memtomembuffersize) )
        {
            bytesPerLine_max = (ULONG) sqrt( ppdev->MemToMemBufferSize ) ;
        }
                         
        //
        // From here on, we will use bytesPerLine as the width also, so that
        // the number (max) of lines we can copy is bytesPerLine also. (considering
        // the "surface" being 8bpp)
        //
    
    
        // Allocate the system memory buffer that will simulate the bits of
        // a destination region in unlocked system ram.
    
        
        SysMemBuffer = (BYTE *) EngAllocMem(0, bytesPerLine_max*bytesPerLine_max, ALLOC_TAG);
    
        if( SysMemBuffer == NULL )
        {
            DISPDBG((1, "DrvEnableSurface - Failed EngAllocMem for mem buffer in calibration section"));
            goto CalibXfer_Error;
        }
        
    
        //**********************************************************************
        //
        //                          OH CALIBRATION
        //                **************************************
        //
        // OH is the overhead time of the hardware: the time the hardware takes
        //    to pull from the DMA push buffer and execute the command ( and
        //    finally start the xfer)
        //
        //
        // Setup variables for a very small DMA Xfer (1 byte) from VRAM start
        // to DMA Mem2Mem buffer
        // (remember the variables are all dummies, we do this for 
        // calibration; all we have to make sure is that there is no access
        // violation of course...)
        //
        // Note that for this first transfer we don't calibrate "K" so it doesnt
        // mather if we use the volatiles to init our variables.
        //
        //**********************************************************************
     
        //---[Set the number of bytes per line of the region to Xfer]-----------
    
        volatileDummy    = 1;                   // set the volatile
        bytesPerLine     = volatileDummy;       // assign by volatile to prevent
                                                // optimization
        
        //---[Set the number of lines per Xfer ]--------------------------------
        //
        //                                   (normally based on OptBytesPerXfer)
    
        volatileDummy    = 1;
        linesPerXfer     = volatileDummy;
        
        
        //---[Set Source/FinalDest Pitch and Address of bits (and inc for 
        //                                                    FinalDest Ptr)]---  
    
        // Don't need this for this for calibration
        //
        //pjSrcBits    = ppdev->pjScreen;      // Assume VRAM Base == pjScreen
                                             // (== base of primary surface)
    
        
        volatileDummy = bytesPerLine;
        lSrcPitch     = volatileDummy;       // set source pitch == bytesPerLines 
                                             // (no gap in mem btw ending of lines and beg.
                                             // of next lines)
                
        //   Don't need these for this first calibration xfer
        //
        //volatileDummy = 1;                
        //lDstPitch     = volatileDummy;
    
        
        //FinalDstJump2NextLineBeg = lDstPitch - bytesPerLine;
    
    
    
        //---[Mem2Mem DMA Buffer ReadPtr (to FinalDest) (it's inc == 0)]--------  
                
                
        //  Don't need this for this first calibration xfer
        //
        //pjDmaRead = ppdev->pMemToMemBuffer;  // Init the reading ptr for the second
                                             // transfer "pipe" (the CPU-Xfers)
        
    
        //---[Convert the SRC offset in DMA Offset (and calculate inc. 
        //                                                  after each Xfer)]---
        
        
        volatileDummy    = 0;           // Assume ppdev->pjScreen == Vram DmaContext Base
        SrcDMAOffset     = volatileDummy;
    
        DstDMAOffset = 0;           // Xfer the bytes to start of mem2mem buffer
        
        //  Don't need this for this first calibration xfer
        //
        //                                                      // dont need to "volatile
        //SrcDMAincPerXfer   = linesPerXfer * lSrcPitch;        // mirror" these, because
                                                                // linesPerXfer has already
                                                                // been volatile-assigned.
    
        //---[Set the total number of lines to Xfer (Xfer_siz/bytesPerLine)]----
        
        
        //  Don't need this for this first calibration xfer
        //
        //linesToGo = 1;                       // Init the number of lines left to transfer
    
          
        //***[ Push commands in the DMA Fifo for the 1 byte Xfer ]**************
        
    
        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  
    
        NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
        NV_DMA_FIFO = SrcDMAOffset;                    // Offset In
        NV_DMA_FIFO = DstDMAOffset;                    // Offset Out
        NV_DMA_FIFO = lSrcPitch;                       // Pitch In
        NV_DMA_FIFO = bytesPerLine;                      // Pitch Out == bytesPerLine because
                                                         // we dont want any memory "hole" between
                                                         // two contiguous lines in the mem2mem buffer
        NV_DMA_FIFO = bytesPerLine;                    // Line Length in bytes
        NV_DMA_FIFO = linesPerXfer;                    // Line Count (num to copy)
        NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
        NV_DMA_FIFO = 0;                               // Set Buffer Notify and kickoff
                
        // Set notifier to 'BUSY' value (use second notification structure)
        
        pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        
        UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
                        
        
        // Don't need that, we don't calibrate that yet
        //
        //
        //linesToGo    -= linesPerXfer;          // Susbtract the lines that have been done.
        //SrcDMAOffset += SrcDMAincPerXfer;      // Advance in the source DMA region
        //DstDMAOffset  = DstDMA2ndPartOffset;   // Use the other part of dst DMA region (mem2mem buffer)
                        
                
        // Intstead of that:
        //
        //NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer
        //
        // We will copy paste the function in here so that we can get the time
        // stamp just before the hardware starts processing the FIFO
    
        //  THIS IS COPY PASTED  nv4hw.c BECAUSE WE WANT TO START PROFILING
        //  JUST BEFORE THE LAST STATEMENT OF THIS FUNCTION
    
        nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

        //**********************************************************************
        // Check if the ALI 1541 chipset is present.
        // If so, then we need to workaround a cache issue by doing an out to port
        //**********************************************************************
        
        if (ppdev->AliFixupIoNeeded)
            {
        // Assembly is not feasible for IA64
        #ifndef _WIN64
            outp(ppdev->AliFixupIoBase, 0);      // This will flush the cache
        #endif
            }
        
        
        #ifdef NVD3D    // DX6
        //**********************************************************************
        // If there is another DMA push channel active, wait til it's finished.
        //
        // It hurts performance to check this with every kickoff, so we only do
        // this check when:
        // 1) This is a DX6 build. We can only successfully sync with other DMA
        //    Push Channels and not PIO channels (DX3 is PIO only).
        // 2) DirectDraw is enabled and ddraw objects have been created
        //   (determined by checking if surfaces have been created).
        //
        //**********************************************************************
        
        if ((ppdev->DDrawEnabledFlag) &&
            (ppdev->pDriverData->DDrawVideoSurfaceCount))
            {
            if (ppdev->pfnWaitForChannelSwitch)
                ppdev->pfnWaitForChannelSwitch(ppdev);
            }
        #else
        //**********************************************************************
        // It's possible the DX3 PIO channel is still active. We need to wait
        // til it's finished. It hurts performance to check this with every
        // kickoff, so we only do this check when DirectDraw is enabled.
        //**********************************************************************
        if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
            {
            NV4_DdPioSync(ppdev);
            ppdev->bDDChannelActive = FALSE;
            }
        #endif // #ifndef NVD3D
        
        //**************************************************************************
        // Convert the PUT ptr to a byte address
        //**************************************************************************
        
        ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;
        
        //**************************************************************************
        // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
        // Then 'OR' it near the end of the push buffer
        //**************************************************************************
        
        if (ppdev->nvDmaCount >0)
            ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
        else
            ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];
        
        *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;
        
        //**************************************************************************
        // Tell the hardware to start processing the push buffer
        //**************************************************************************
        
        //**********************************************************************
        //  Here, just before kicking this, we snoop the Eng counter 
        //**********************************************************************
        
        EngQueryPerformanceCounter(&llTimeStamp1);
    
        nvDmaChannel->Put = ppdev->nvDmaCachedPut;
        
        
        // Wait for the DMA-Xfer to complete (use second notification structure)
    
        while ( pNotifier->status != 0 );
    
    
        // The 1 byte Transfer is completed, get the timestamp
    
        EngQueryPerformanceCounter(&llTimeStamp2);
        
        dfOH = (double)(llTimeStamp2 - llTimeStamp1)/(double)(llCntrFreq) ; // get time in seconds;
        
        if ( dfOH == 0 ) 
            goto CalibXfer_Error;
        
        
        
        //**********************************************************************
        //
        //                      K,X, and Y  CALIBRATION
        //                **************************************
        //
        // Setup variables for the largest DMA xfer we can have.
        //
        //**********************************************************************
        
    
    
        //---[Set the number of bytes per line of the region to Xfer]-----------
    
        // bytesPerLine_max must be run time calculated so don't need to use
        // the volatile trick here ? Need to use it so we have a different
        // local variable created, otherwise compiler will never really create
        // "bytesPerLine" and only bytesPerLine_max
        
        volatileDummy    = bytesPerLine_max;        // see init of bytesPerLine_max
        bytesPerLine     = volatileDummy;
                                            
        
        //---[Set the number of lines per Xfer ]--------------------------------
        //
        //                                   (normally based on OptBytesPerXfer)
    
        volatileDummy    = bytesPerLine_max;        // see init of bytesPerLine_max
        linesPerXfer     = volatileDummy;
        
        
        //---[Set Source/FinalDest Pitch and Address of bits (and inc for 
        //                                                    FinalDest Ptr)]---  
    
        
        volatileDummy = bytesPerLine;
        lSrcPitch     = volatileDummy;       // set source pitch == bytesPerLine 
                                             // (no gap in mem btw ending of lines and beg.
                                             // of next lines)
                
        volatileDummy = bytesPerLine;        // Final destination pitch (our sys MEM        
        lDstPitch     = volatileDummy;       // cached surface (unlocked))
    
        
        FinalDstJump2NextLineBeg = lDstPitch - bytesPerLine;  // inc to jump a beg of next line
                                                              // when at the end off the preceding
                                                              // one
    
        //---[Mem2Mem DMA Buffer ReadPtr (to FinalDest) (it's inc == 0)]--------  
                
                
        pjDmaRead       = ppdev->pMemToMemBuffer;  // Init the reading ptr for the second
                                                   // transfer "pipe" (the CPU-Xfers)
        
        volatileDummyPtr= (BYTE *)(ppdev->pMemToMemBuffer);
        
        pjDmaRead_start = volatileDummyPtr;

        pjFinalDstWrite = SysMemBuffer;      // Where to write our CPU Xfers
    
    
        //---[Convert the SRC offset in DMA Offset (and calculate inc. 
        //                                                  after each Xfer)]---
        
        
        volatileDummy    = 0;           // Assume ppdev->pjScreen == Vram DmaContext Base
        SrcDMAOffset     = volatileDummy;
    
        DstDMAOffset        = 0;               // Xfer the bytes to start of mem2mem buffer
        
        DstDMA2ndPartOffset = volatileDummy;   // 2nd part of mem2mem buffer (dummy, we don't care)
        
                                                                // dont need to "volatile
        SrcDMAincPerXfer   = linesPerXfer * lSrcPitch;          // mirror" these, because
                                                                // linesPerXfer has already
                                                                // been volatile-assigned.
    
        //---[Set the total number of lines to Xfer (Xfer_siz/bytesPerLine)]----
                
        volatileDummy = bytesPerLine_max;    // see init of bytesPerLine_max
        linesToGo     = volatileDummy;       // Init the number of lines left to transfer
    
          
        //***[ Push commands in the DMA Fifo for the big Xfer ]*****************
        
        EngQueryPerformanceCounter(&llTimeStamp1);  // Get time stamp first (for K)
    
    
        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  
    
        NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
        NV_DMA_FIFO = SrcDMAOffset;                    // Offset In
        NV_DMA_FIFO = DstDMAOffset;                    // Offset Out
        NV_DMA_FIFO = lSrcPitch;                       // Pitch In
        NV_DMA_FIFO = bytesPerLine;                      // Pitch Out == bytesPerLine because
                                                         // we dont want any memory "hole" between
                                                         // two contiguous lines in the mem2mem buffer
        NV_DMA_FIFO = bytesPerLine;                    // Line Length in bytes
        NV_DMA_FIFO = linesPerXfer;                    // Line Count (num to copy)
        NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
        NV_DMA_FIFO = 0;                               // Set Buffer Notify and kickoff
                
        // Set notifier to 'BUSY' value (use second notification structure)
        
        pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        
        UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count
                        
                
        NV4_DmaPushSend(ppdev);     // Send data on thru to the DMA push buffer
        
                
        // We now need the following, we calibrate K
        //
        //
        linesToGo    -= linesPerXfer;          // Susbtract the lines that have been done.
        SrcDMAOffset += SrcDMAincPerXfer;      // Advance in the source DMA region
        DstDMAOffset  = DstDMA2ndPartOffset;   
        
        // we also include the following, even if in the actual code, it's not in the same place,
        // but because it still has to be executed for each cpu xfers, we include this in K

        pjDmaRead = pjDmaRead_start;

    
        EngQueryPerformanceCounter(&llTimeStamp2);  // Get time stamp (for K)
                
        
        dfK = (double)( llTimeStamp2 - llTimeStamp1 ) / (double)(llCntrFreq) ; // get K in seconds
        
        if ( dfK == 0 ) 
            goto CalibXfer_Error;
        
        
        // Note that here, the EngQuery have overhead, and if the Xfer is too
        // fast, we might wrongly calibrate X if we do the while(!notified) and 
        // get a third timestamp right here. Instead, we are going to kick the xfer
        // another time
    
        // Make sure the variables are used in our program so compiler don't
        // warn us or remove the above (useless) statements
    
        volatileDummy = linesToGo;        // dummy...
        volatileDummy = SrcDMAOffset;
        volatileDummy = DstDMAOffset;
        
        
        // Wait for the DMA-Xfer to complete (use second notification structure)
    
        while ( pNotifier->status != 0 );
    
    
    
        //***[ Setup another Xfer to calibrate X ]**********************************
        
        
        volatileDummy    = 0;           // Assume ppdev->pjScreen == Vram DmaContext Base
        SrcDMAOffset     = volatileDummy;
    
        DstDMAOffset = 0;               // Xfer the bytes to start of mem2mem buffer
        
        volatileDummy = bytesPerLine_max;  // see init of bytesPerLine_max
        linesToGo     = volatileDummy;     // Init the number of lines left to transfer
    
    
        //***[ Push commands in the DMA Fifo for the 2nd big Xfer ]*************
        
        NV_DMAPUSH_CHECKFREE(((ULONG)(9)));  // Check if we've got enough room in the push buffer  
    
        NV_DMAPUSH_START(8,DD_SPARE , NV039_OFFSET_IN );
        NV_DMA_FIFO = SrcDMAOffset;                    // Offset In
        NV_DMA_FIFO = DstDMAOffset;                    // Offset Out
        NV_DMA_FIFO = lSrcPitch;                       // Pitch In
        NV_DMA_FIFO = bytesPerLine;                      // Pitch Out == bytesPerLine because
                                                         // we dont want any memory "hole" between
                                                         // two contiguous lines in the mem2mem buffer
        NV_DMA_FIFO = bytesPerLine;                    // Line Length in bytes
        NV_DMA_FIFO = linesPerXfer;                    // Line Count (num to copy)
        NV_DMA_FIFO = NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1; // Format
        NV_DMA_FIFO = 0;                               // Set Buffer Notify and kickoff
                
        // Set notifier to 'BUSY' value (use second notification structure)
        
        pNotifier->status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        
        
        UPDATE_PDEV_DMA_COUNT;      // Update global push buffer count                                        
        // PushSend:
        //
        //  THIS IS COPY PASTED  nv4hw.c BECAUSE WE WANT TO START PROFILING
        //  JUST BEFORE THE LAST STATEMENT OF THIS FUNCTION
    
        nvDmaChannel = (Nv04ControlDma *)(ppdev->nvDmaChannel);

        //**********************************************************************
        // Check if the ALI 1541 chipset is present.
        // If so, then we need to workaround a cache issue by doing an out to port
        //**********************************************************************

        if (ppdev->AliFixupIoNeeded)
            {
        // Assembly is not feasible for IA64
        #ifndef _WIN64
                outp(ppdev->AliFixupIoBase, 0);      // This will flush the cache
        #endif
            }
    
    
        #ifdef NVD3D    // DX6
        //**********************************************************************
        // If there is another DMA push channel active, wait til it's finished.
        //
        // It hurts performance to check this with every kickoff, so we only do
        // this check when:
        // 1) This is a DX6 build. We can only successfully sync with other DMA
        //    Push Channels and not PIO channels (DX3 is PIO only).
        // 2) DirectDraw is enabled and ddraw objects have been created
        //   (determined by checking if surfaces have been created).
        //
        //**********************************************************************

        if ((ppdev->DDrawEnabledFlag) &&
            (ppdev->pDriverData->DDrawVideoSurfaceCount))
            {
            if (ppdev->pfnWaitForChannelSwitch)
                ppdev->pfnWaitForChannelSwitch(ppdev);
            }
        #else
        //**********************************************************************
        // It's possible the DX3 PIO channel is still active. We need to wait
        // til it's finished. It hurts performance to check this with every
        // kickoff, so we only do this check when DirectDraw is enabled.
        //**********************************************************************
        if (ppdev->DDrawEnabledFlag && ppdev->bDDChannelActive)
            {
            NV4_DdPioSync(ppdev);
            ppdev->bDDChannelActive = FALSE;
            }
        #endif // #ifndef NVD3D

        //**************************************************************************
        // Convert the PUT ptr to a byte address
        //**************************************************************************

        ppdev->nvDmaCachedPut = ppdev->nvDmaCount << 2;

        //**************************************************************************
        // VIA / Flush Write Combine Fix - Read the last DWORD that was output.
        // Then 'OR' it near the end of the push buffer
        //**************************************************************************

        if (ppdev->nvDmaCount >0)
            ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[((ppdev->nvDmaCount)-1)];
        else
            ppdev->nvDmaFlushFixDummyValue = ppdev->nvDmaFifo[0];

        *(ppdev->nvDmaFlushFixDwordPtr) |= ppdev->nvDmaFlushFixDummyValue;
        
        //**************************************************************************
        // Tell the hardware to start processing the push buffer
        //**************************************************************************
        
        //**********************************************************************
        //  Here, just before kicking this, we snoop the Eng counter 
        //**********************************************************************
        
        EngQueryPerformanceCounter(&llTimeStamp1);
    
        nvDmaChannel->Put = ppdev->nvDmaCachedPut;
        
        
        // Wait for the DMA-Xfer to complete (use second notification structure)
    
        while ( pNotifier->status != 0 );
    
    
        // The big transfer is completed, get the timestamp
    
        EngQueryPerformanceCounter(&llTimeStamp2);
        
        // Problem: We don't know how big dfTime can be: this is dependant of the counter
        //          frequency. If it is too big, we will loose all precision in the totalbytes/dfTime
        //          division.  So, the division must not, at first come lower than the smallest positive,
        //          that can be represented by a double, 4.94065645841247E-324 .  Even then, we must check
        //          the operations AFTER that concern X. We will calculate, at the end, sqrt(X*OH) or
        //          sqrt(Y*K).  K and OH are at least one, so sqrt(X) and sqrt(Y) must not be lower than
        //          4.94065645841247E-324, so X and Y should be >= (4.94065645841247E-324 )^2 (but this is
        //          even lower than 4.94065645841247E-324 so the latter is our boundary. 
        //          
        //          (We could also convert the ticks in seconds, with counter frequency, and then divide 
        //          the size of the transfer by the number of seconds it took.  We know that this can't be 
        //          lower than 1 byte (even 1k, even 1 MB ! )   )
      
        dfTime = ( (double)( llTimeStamp2 - llTimeStamp1) - dfOH ) / (double)(llCntrFreq) ; // get time in seconds
    
        if( dfTime == 0 ) // never supposed to happen but...
        {
            // OH is of the order of the time of the xfer, bailout, disable overlapping
            // of Xfers
            goto CalibXfer_Error;
        }
        
        
        dfX = (double)( bytesPerLine * bytesPerLine ) / dfTime ;
        
        if ( dfX <= 4.94065645841247E-324 ) 
            goto CalibXfer_Error;  // practically, dfX would be >>> 1 ! 
                        
        
        //**********************************************************************
        //
        //                           Y  CALIBRATION
        //                **************************************
        //
        // CPU Xfer the big Xfer we just DMA-Xfered.
        //
        //**********************************************************************
    
        
        EngQueryPerformanceCounter(&llTimeStamp1);
    
        for(j=0; j < linesPerXfer; j++)
        {            
                    
            // Xfer a whole line
            //
            for(limit = pjDmaRead + bytesPerLine; 
                pjDmaRead < limit; 
                pjDmaRead++, pjFinalDstWrite++ )
            {
                *pjFinalDstWrite = *pjDmaRead ;
            }
            pjFinalDstWrite += FinalDstJump2NextLineBeg; // Switch to beginning of the
                                                         // next line in the dest surface
    
        } // ...for all bytes in chunk to cpu-xfer
    
        EngQueryPerformanceCounter(&llTimeStamp2);
    
                
        
        dfTime = (double)( llTimeStamp2 - llTimeStamp1 ) / (double)(llCntrFreq) ; // get time in seconds
    
        if( dfTime == 0 ) 
            goto CalibXfer_Error;
                
        dfY = (double)( bytesPerLine * bytesPerLine ) / dfTime ;
        
        if ( dfY <= 4.94065645841247E-324 ) 
            goto CalibXfer_Error;  // practically, dfY would be >>> 1 ! 
    
        // One remark here: we could combine this last if with the if( dfTime == 0)
        // same thing goes for calculation of dfX (see before)...
    
    
        //**********************************************************************
        //
        //               globalXferOverheadFactor CALCULATION
        //             ****************************************
        //
        //  Now that we have X, Y, K, OH, all is left to do is to combine 
        //  (choose which data to use) the calibration data into one value,
        //  the OverheadFactor.  This is were the real model I have designed
        //  and the actual implementation diverge:  this has been done for 
        //  speed purpose of course, and anyway, with experimentation in MatLab,
        //  I have showed that this approximation of the dependant variable
        //  that give the "maxima" of the piecewise optimization function, gives
        //  pretty good results.  Otherwise, if we wanted to have the REAL
        //  optimal block size 100% of the time (I say 100% because the appro-
        //  ximation computation == the optimal anyway), we would be forced to
        //  find the maximum of a piecewise function (made of 2 analytical 
        //  functions and 1 junction).  This implies calculating 2 analytical
        //  maxima, the maxima of the junction (boundarie of the two pieces)
        //  and finally take the max of all those max. (For each Xfer of bitmaps
        //  region) This is unacceptable !
        //  Even now, with this approximation, I end up calculating one maxima
        //  by plugging values in the derivative of an analytical function. This
        //  implies calculating 1 MUL, and 1 SQRT (but the SQRT is optimized, it
        //  is not a CPU-SQRT). Thus...
        //
        //  TODO (would be good to try): instead of calc. the SQRT of Transfer 
        //  size * globalXferOverheadFactor (see nv4bltc.c NV4ScreenToMemBlt),
        //  fill a lookup table with common xfer size VS the opt xfer size, using
        //  the REAL model.  The "common xfer sizes" could be the middle of each
        //  power of 2. (Pretty much like I did the LUT to be able to compute a
        //  SQRT with Newton's method with only 2 iterations).
        //
        //  Of course, before trying this, we would have to see what is the
        //  maximum error we can commit for S (block size of xfer) for each
        //  value in the lookup (each interval) and see if it's worth it. If it's
        //  not, do a linear interpolation ?  (but this bring us back to the sqrt
        //  because Newton's method implies iteration similar to the interpolation)
        //
        //**********************************************************************
    
        //
        // Decide what to use: sqrt(Y*OH) or sqrt(X*K)
        //
                
        if(  ( (dfX/dfY) / (dfOH/dfK) )    >= 1  )
        {
            // Use analytic equation (OgA)' (derivative)
            //  
            // OgA' = sqrt( T*X*K ) = sqrt(T) * sqrt( X*K )
    
            dfFactor = sqrt( dfX*dfK );            
        }
        else
        {
            // Use analytic equation (OgB)' (derivative)
            //  
            // OgB' = sqrt( T*Y*OH ) = sqrt(T) * sqrt( Y*OH )
    
            dfFactor = sqrt( dfY*dfOH );
        }
    
        //
        // Convert the dfFactor in int but check boundaries before
        //
    
        if( dfFactor < 1 )                        // clamp to 1 at least
            ppdev->globalXferOverheadFactor = 1;
        
        else 
        {
            if( dfFactor > 65535 )
                ppdev->globalXferOverheadFactor = 65535;  // 16bit max
            else
                ppdev->globalXferOverheadFactor = (int)(dfFactor);
        }
    
        goto CalibXfer_Done;
    
        
        //---[ An error has most likely occured ]-------------------------------
        
        CalibXfer_Error:
    
            // We diseable implicitly the overlapping
    
            ppdev->globalXferOverheadFactor = 65535;  // 16bit max
    
    
        //---[ All Done... ]----------------------------------------------------
    
        CalibXfer_Done:
    
            EngFreeMem(SysMemBuffer);
    
            
    } // ...if ( ppdev->pfnScreenToMemBlt != NULL ), profile stuff
                                                            
    //**************************************************************************
    //**************************************************************************
    //*[ Profiling Stuff END ]*****[CALIBEND]***********************************
    //**************************************************************************

}

// ...End of:  vCalibrate_XferSpeeds
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvMultiMon.c ===
/************************** Module Header *************************************
//                                                                             *
//  Module Name: nvMultiMon.c                                                  *
//                                                                             *
//  This module contains the support functions for the TwinView multi-mon code *
//  driver, the pdev, and the surface.                                         *
//                                                                             *
//  Copyright (c) 1992-1996 Microsoft Corporation                              *
//                                                                             *
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "ddminint.h"
#include "dmamacro.h"
#include "nvcm.h"
#include "oglDD.h"
#include "nvReg.h"

// To get the NV11 twinview definitions
#include "nvMultiMon.h"

// public prototypes
void UseOnlyGDIDataForModeDetails(PDEV *ppdev);
void UseOnlyRegistryDataForModeDetails(PDEV *ppdev, NVTWINVIEWDATA *pData);
BOOL InitMultiMon(PDEV *ppdev);
void GetDefaultTVFormat(PPDEV ppdev);
void FreeMemoryMultiMon(PDEV *ppdev);
BOOLEAN TwinViewDataOK(PPDEV ppdev, NVTWINVIEWDATA *pData);
BOOLEAN bQuerySupportPhysicalMode(PPDEV ppdev, ULONG head, ULONG ulDeviceMask, MODE_ENTRY *RequestedMode, MODE_ENTRY *BestFitMode);
VOID vBackOffMode(PPDEV ppdev, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *RequestedMode, MODE_ENTRY *BestFitMode);
BOOLEAN bQueryBothPanelsAreInSync(PPDEV ppdev, NVTWINVIEWDATA *pData);
BOOLEAN bConfirmDeviceType(PPDEV ppdev, ULONG Head, ULONG RequestedDeviceMask, ULONG RequestedDeviceType, ULONG RequestedTVType,
                           ULONG * SuggestedDeviceMask, ULONG * SuggestedDeviceType, ULONG * SuggestedTVType);
void PrintPPDEVTwinViewInfo (char *Msg, PPDEV ppdev);
void PrintTwinViewData (char *Msg, ULONG ulDebugLevel, NVTWINVIEWDATA *pData, PPDEV ppdev);
BOOLEAN bGetPhysicalVirtualModeList(PPDEV ppdev, ULONG Head, ULONG DeviceMask, ULONG DeviceType, ULONG TVFormat,
        MODE_ENTRY *PhysModeList, MODE_ENTRY *VirtModeList, ULONG *NumPhysModes, ULONG *NumVirtModes);
void InduceAndUpdateDeviceScanning (PPDEV ppdev);
void   ProcessSynchronousFlags(PPDEV ppdev, NVTWINVIEWDATA *pData);
BOOL BuildModeLists(PPDEV ppdev);
ULONG ValidateRegistryDeviceMasks(PPDEV ppdev, NVTWINVIEWDATA *pData);
VOID ReadToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode);
VOID WriteToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode);


VOID WriteRegistryTwinViewInfo (PPDEV ppdev, NVTWINVIEWDATA *pData);
ULONG GetNumberDacsActiveFromTwinViewInfo (NVTWINVIEWDATA *pData);
VOID InitDevMaskFromTwinViewInfo (PPDEV ppdev, NVTWINVIEWDATA *pData);

ULONG MaskToDeviceType( PPDEV ppdev, ULONG ulDeviceMask);
ULONG TVFormatToTVDeviceType(ULONG ulTVFormat);
ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);
ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask);
ULONG HandleBIOSHeads(PPDEV ppdev);
VOID HandleBandWidth_SingleDacActive(PPDEV ppdev);
VOID HandleBandWidth_DualDacsActive(PPDEV ppdev);

BOOLEAN FindNextLowerRefreshRateMode(PPDEV ppdev, ULONG Head, MODE_ENTRY *pRequestedMode, ULONG *pNextLowerRefreshRate);
BOOLEAN FindNextLowerResolutionMode(PPDEV ppdev, ULONG Head, MODE_ENTRY *pRequestedMode, ULONG *pNextLowerWidth, ULONG *pNextLowerHeight);

BOOLEAN bQueryGDIModePruning(ULONG ulTwinView_State, ULONG ulPrimaryHead, ULONG ulPrimaryDeviceMask,
          ULONG ulHead, ULONG ulDeviceMask, ULONG ulACPISystem, ULONG ulGDIModePruning);

/*  Reg utils */

BOOLEAN GetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG *pulData);
VOID SetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG ulData);

// The next two functions are used 
// as wrapper to do an IOCTL reg key read/write (it wraps the NV_REG struct setup)
// ( *W functions uses unicode strings ( L"abcde..." ) )

void GetRegValueW(HANDLE hDriver, PWSTR keyName, PVOID keyData, ULONG keyDataSize);
void SetRegValueW(HANDLE hDriver, PWSTR keyName, PVOID keyData, ULONG keyDataSize);

/* ... Reg Utils */


ULONG GetInitiatedRegValue(PPDEV ppdev);
VOID SetInitiatedRegValue(PPDEV ppdev, ULONG ulVal);
ULONG GetPowerStateRegValue(PPDEV ppdev);
VOID SetPowerStateRegValue(PPDEV ppdev, ULONG ulVal);
ULONG GetPrevDevMaskRegValue(PPDEV ppdev);
VOID SetPrevDevMaskRegValue(PPDEV ppdev, ULONG ulVal);

VOID vReadSaveSettings(PPDEV ppdev);
VOID vWriteSaveSettings(PPDEV ppdev);
NVTWINVIEWDATA *pFindSaveSettings(PPDEV ppdev, QUERY_SAVE_SETTINGS *pQuery, NVTWINVIEWDATA * pTwinViewData);
VOID vPrintSaveSettings(PPDEV ppdev, ULONG ulDebugLevel);


#if DBG
extern ULONG DebugLevel;
VOID GetDebugLevelRegValue(PPDEV ppdev);
#endif DBG


extern VOID NVMovePointer(
PDEV*   ppdev,
LONG    x,
LONG    y);


     


//
// This function makes sure that the physical coords and virtual coords of the two heads are correctly set.
// We use only the GDI mode details and completely ignore the registry data.
// This function is to be used only in the case of when the registry entry 'TwinViewInfo' does not exist or the registry 
// entry info is not sane.
//
void  UseOnlyGDIDataForModeDetails(PDEV *ppdev)
{
    ULONG i;
    ULONG ulHead;
    MODE_ENTRY RequestedMode, BestFitMode;

    DISPDBG((5,"Enter UseOnlyGDIDataForModeDetails()\n"));


    // Check to see if it is horizontal orientation
    if (HORIZONTAL_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
    {
        ppdev->TwinView_State = NVTWINVIEW_STATE_SPAN;
        ppdev->TwinView_Orientation = HORIZONTAL_ORIENTATION;
        ppdev->ulNumberDacsActive = 2;
        ppdev->ulDesktopMode = NV_TWO_DACS | NV_SPANNING_MODE ;

        RequestedMode.Width = (USHORT)ppdev->cxScreen / 2;
        RequestedMode.Height = (USHORT)ppdev->cyScreen;
        RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
        RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

        //
        // Fill in the info for primary device
        //
        ulHead = ppdev->ulDeviceDisplay[0];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], 0, 0, ppdev->cxScreen / 2, ppdev->cyScreen);

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, RequestedMode.Width, RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }

        //
        // Fill in the info for secondary device
        //
        ulHead = ppdev->ulDeviceDisplay[1];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], ppdev->cxScreen / 2, 0, 
            ppdev->rclDisplayDesktop[ulHead].left + (ppdev->cxScreen / 2), ppdev->cyScreen);

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], ppdev->cxScreen / 2, 0, 
                ppdev->rclCurrentDisplay[ulHead].left + RequestedMode.Width, RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], ppdev->cxScreen / 2, 0, 
                ppdev->rclCurrentDisplay[ulHead].left + BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }
    } // HORIZONTAL_MODE

    // check to see if it is vertical orientation
    if (VERTICAL_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
    {
        ppdev->TwinView_State = NVTWINVIEW_STATE_SPAN;
        ppdev->TwinView_Orientation = VERTICAL_ORIENTATION;
        ppdev->ulNumberDacsActive = 2;
        ppdev->ulDesktopMode = NV_TWO_DACS | NV_SPANNING_MODE ;

        RequestedMode.Width = (USHORT)ppdev->cxScreen;
        RequestedMode.Height =(USHORT) ppdev->cyScreen / 2;
        RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
        RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

        //
        // Fill in the info for primary device
        //
        ulHead = ppdev->ulDeviceDisplay[0];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], 0, 0, ppdev->cxScreen, ppdev->cyScreen / 2);

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, RequestedMode.Width, RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }

        //
        // Fill in the info for secondary device
        //
        ulHead = ppdev->ulDeviceDisplay[1];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], 0, ppdev->cyScreen / 2, 
            ppdev->cxScreen, ppdev->rclDisplayDesktop[ulHead].top + (ppdev->cyScreen / 2));

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, ppdev->cyScreen / 2,
                RequestedMode.Width, ppdev->rclCurrentDisplay[ulHead].top + RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, ppdev->cyScreen / 2,
                BestFitMode.Width, ppdev->rclCurrentDisplay[ulHead].top + BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }
    } // VERTICAL_MODE

    if (!MULTIMON_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
    {
        // We are in Normal mode. There is no concept of clone mode when we use the GDI data.
        if (ppdev->TwinView_State != NVTWINVIEW_STATE_DUALVIEW)
            ppdev->TwinView_State = NVTWINVIEW_STATE_NORMAL;

        // This is the normal mode where we use only one dac.
        ppdev->ulNumberDacsActive = 1;

        RequestedMode.Width = (USHORT)ppdev->cxScreen;
        RequestedMode.Height = (USHORT)ppdev->cyScreen;
        RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
        RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

        //
        // Handle the case where nothing is connected to Head0 but something is connected to head1
        //
        if (ppdev->ulNumberDacsOnBoard == 2)
        {
            if (ppdev->ulNumberDacsConnected == 1)
            {
                if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL)
                {
                    switch (ppdev->ulDeviceDisplay[0])
                    {
                
                    case 0:
                        if (ppdev->ulDeviceType[0] == INVALID_DEVICE_TYPE && ppdev->ulDeviceType[1] != INVALID_DEVICE_TYPE)
                        {
                            // Swap the heads so that we use the other head.
                            ppdev->ulDeviceDisplay[0] = 1;
                            ppdev->ulDeviceDisplay[1] = 0;
                        }
                        break;

                    case 1:
                        if (ppdev->ulDeviceType[1] == INVALID_DEVICE_TYPE && ppdev->ulDeviceType[0] != INVALID_DEVICE_TYPE)
                        {
                            // Swap the heads so that we use the other head.
                            ppdev->ulDeviceDisplay[0] = 0;
                            ppdev->ulDeviceDisplay[1] = 1;
                        }
                        break;

                    default:  
                        DISPDBG((0,"Oops! The primary head is bogus: 0x%x",ppdev->ulDeviceDisplay[0]));
                        break;
                    }
                }
            }
        }


        //
        // Fill in the info for primary device
        //
        ulHead = ppdev->ulDeviceDisplay[0];
        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], 0, 0, ppdev->cxScreen, ppdev->cyScreen);
        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, RequestedMode.Width, RequestedMode.Height);
            ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
        }
        else
        {
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
        }
    } // NORMAL_MODE
}

//
// Returns the number of active dacs from the TwinViewInfo. The returned values are
// 1: standard mode
// 2: clone mode
// 2: spanning mode with a spanning resolution.
// 1: spanning mode with the single screen resolution (6x4, 8x6, 10x7).
// 1: If TwinViewInfo is invalid. This is the safe default value.
//
ULONG GetNumberDacsActiveFromTwinViewInfo (NVTWINVIEWDATA *pData)
{
    ULONG ulNumberDacsActive = 1;

    DISPDBG((5, "Enter GetNumberDacsActiveFromTwinViewInfo()\n"));
    if (pData == NULL)
    {
        DISPDBG((0, "Something Wrong. NULL pointer passed for TwinViewInfo structure"));
        return(ulNumberDacsActive);
    }

    switch (pData->dwState)
    {
        case NVTWINVIEW_STATE_NORMAL:
        case NVTWINVIEW_STATE_DUALVIEW:
            ulNumberDacsActive = 1;
            break;
        case NVTWINVIEW_STATE_CLONE:
            ulNumberDacsActive = 2;
            break;
        case NVTWINVIEW_STATE_SPAN:
            //sanity check
            if (!MULTIMON_MODE((pData->DeskTopRectl.right - pData->DeskTopRectl.left),(pData->DeskTopRectl.bottom - pData->DeskTopRectl.top)))
            {
                ULONG width;
                ULONG height;
                width = pData->DeskTopRectl.right - pData->DeskTopRectl.left;
                height = pData->DeskTopRectl.bottom - pData->DeskTopRectl.top;
                if ((width == 640 && height == 480) ||
                    (width == 800 && height == 600) ||
                    (width == 1024 && height == 768))
                {
                    //
                    // this is ok as we always export these special modes.
                    // The jury is still out on whether we should set the NumberDacsActive to 1 or 2 for this
                    // case, as the more intuitive option. I vote for 1 as being the more intuitive.
                    //
                    ulNumberDacsActive = 1;
                }
                else
                {
                    DISPDBG((0, "Oops! State: 0x%x, inconsistent with the DeskTopRectl: (%d, %d), (%d, %d)\n",pData->dwState,
                        pData->DeskTopRectl.left, pData->DeskTopRectl.top, pData->DeskTopRectl.right,pData->DeskTopRectl.bottom));
                    ulNumberDacsActive = 1;
                }
            }
            else
            {
                // This is a true multimon resolution
                ulNumberDacsActive = 2;
            }
            break;
        default:
            DISPDBG((0, "Oops! Invalid State from the registry pData: 0x%x\n",pData->dwState));
            ulNumberDacsActive = 1;
            break;
    }
    return(ulNumberDacsActive);
}

//
// This function makes sure that the physical coords and virtual coords of the two heads are correctly set.
// We use only the Registry data set by the nVidia panel and completely ignore the GDI Data (which is a safe thing
// thing to do anyway because at this point, we should have made sure that the GDI data is in complete sync 
// with the registry data.
//
void UseOnlyRegistryDataForModeDetails(PDEV *ppdev, NVTWINVIEWDATA *pData)
{
    ULONG i;
    ULONG ulHead;
    MODE_ENTRY RequestedMode, BestFitMode;
    ULONG SuggestedDeviceMask, SuggestedDeviceType, SuggestedTVType;
    ULONG ulPrimaryHead;

    DISPDBG((5, "Enter UseOnlyRegistryDataForModeDetails()\n"));

    ppdev->TwinView_State = pData->dwState;
    ppdev->TwinView_Orientation = pData->dwOrientation;

    switch (pData->dwState)
    {
        case NVTWINVIEW_STATE_NORMAL:
        case NVTWINVIEW_STATE_DUALVIEW:
            ppdev->ulNumberDacsActive = 1;
            ppdev->ulDesktopMode = 0;
            break;
        case NVTWINVIEW_STATE_CLONE:
            ppdev->ulNumberDacsActive = 2;
            ppdev->ulDesktopMode = NV_CLONE_DESKTOP | NV_TWO_DACS;
            break;
        case NVTWINVIEW_STATE_SPAN:
            //sanity check
            if (!MULTIMON_MODE((pData->DeskTopRectl.right - pData->DeskTopRectl.left),(pData->DeskTopRectl.bottom - pData->DeskTopRectl.top)))
            {
                ULONG width;
                ULONG height;
                width = pData->DeskTopRectl.right - pData->DeskTopRectl.left;
                height = pData->DeskTopRectl.bottom - pData->DeskTopRectl.top;
                if ((width <= 640 && height <= 480) ||
                    (width == 800 && height == 600) ||
                    (width == 1024 && height == 768))
                {
                    //
                    // this is ok as we always export these special modes.
                    // The jury is still out on whether we should set the NumberDacsActive to 1 or 2 for this
                    // case, as the more intuitive option. I vote for 1 as being the more intuitive.
                    //
                    ppdev->ulNumberDacsActive = 1;
                    ppdev->ulDesktopMode = 0;
                }
                else
                {
                    DISPDBG((0, "Oops! State: 0x%x, inconsistent with the DeskTopRectl: (%d, %d), (%d, %d)\n",pData->dwState,
                        pData->DeskTopRectl.left, pData->DeskTopRectl.top, pData->DeskTopRectl.right,pData->DeskTopRectl.bottom));
                    return;
                }
            }
            else
            {
                // This is a true multimon resolution
                ppdev->ulNumberDacsActive = 2;
                ppdev->ulDesktopMode = NV_TWO_DACS | NV_SPANNING_MODE ;
            }
            break;
        default:
            DISPDBG((0, "Oops! Invalid State from the registry pData: 0x%x\n",pData->dwState));
            return;
            break;
    }

    ulPrimaryHead = pData->dwDeviceDisplay[0];
    ppdev->cxScreen = pData->DeskTopRectl.right - pData->DeskTopRectl.left;
    ppdev->cyScreen = pData->DeskTopRectl.bottom - pData->DeskTopRectl.top;
    ppdev->cBitsPerPel = pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwBpp; // same for both devices
    ppdev->cjPelSize = pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwBpp / 8; // same for both devices
    ppdev->ulGDIRefreshRate = pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwRefresh;

    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        // Get the physical head ==> logical head mapping.
        ppdev->ulDeviceDisplay[i] = pData->dwDeviceDisplay[i];
    }

    //
    // We should iterate through only the numberDacsActive for std/clone/span modes.
    // The only exception is the WindowsXP dualView mode where both heads needs to be initialized
    // even though the NumberDacsActive is 1.
    //
    for (i=0; i < (pData->dwState == NVTWINVIEW_STATE_DUALVIEW ? ppdev->ulNumberDacsOnBoard : ppdev->ulNumberDacsActive); i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];

        // Get the per head flags.
        ppdev->ulEnablePanScan[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwEnablePanScan;
        ppdev->ulEnableDDC[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwEnableDDC;
        ppdev->ulEnableDDC[ulHead] = 1; // Hardcoded for now till control panel adds a button for this.
        ppdev->ulFreezePanScan[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwFreezePanScan;
        ppdev->ulFreezeOriginX[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwFreezeOriginX;
        ppdev->ulFreezeOriginY[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwFreezeOriginY;
        ppdev->ulTimingOverRide[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTimingOverRide;


        SET_RECT(&ppdev->rclDisplayDesktop[ulHead], pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl.left,
            pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl.top, pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl.right,
            pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl.bottom);

        //
        // Before we honor the nvPanel's device type selection, lets verify it.
        //
        if (bConfirmDeviceType(ppdev, ulHead, pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask, pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType, 
            pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat, &SuggestedDeviceMask, &SuggestedDeviceType, &SuggestedTVType))
        {
            DISPDBG((5,"The requested device type is valid.\n"));
            // use the nvPanel's selected device type
            ppdev->ulDeviceMask[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
            ppdev->ulDeviceType[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType;
            ppdev->ulTVFormat[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat;
        }
        else
        {
            DISPDBG((0,"Head: %d, The nvPanel requested an invalid device type: 0x%x, TVFormat: 0x%x\n",ulHead,
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType,pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat));
            DISPDBG((0,"so using the suggested default device type: 0x%x, TVFormat: 0x%x\n", 
                SuggestedDeviceType,SuggestedTVType));
            ppdev->ulDeviceMask[ulHead] = SuggestedDeviceMask;
            ppdev->ulDeviceType[ulHead] = SuggestedDeviceType;
            ppdev->ulTVFormat[ulHead] = SuggestedTVType;
        }

        //
        // Before we honor the nvPanel's physical rectangle and refrsh, lets verify it.
        //
        RequestedMode.Width = (USHORT)(pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.right - pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.left);
        RequestedMode.Height = (USHORT)(pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.bottom - pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.top);
        RequestedMode.RefreshRate = (USHORT)pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh;
        RequestedMode.Depth = (USHORT)pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwBpp;

        if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
        {
            // Registry had valid physical mode info. Use it as is.
            ppdev->rclCurrentDisplay[ulHead].left = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.left;
            ppdev->rclCurrentDisplay[ulHead].top = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.top;
            ppdev->rclCurrentDisplay[ulHead].right = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.right;
            ppdev->rclCurrentDisplay[ulHead].bottom = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl.bottom;
            ppdev->ulRefreshRate[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh;
        }
        else
        {
            // Registry did not have have valid physical mode info. So construct it.
            SET_RECT(&ppdev->rclCurrentDisplay[ulHead], 0, 0, BestFitMode.Width, BestFitMode.Height);
            ppdev->ulRefreshRate[ulHead] = BestFitMode.RefreshRate;
            //
            // If we are on multimon, adjust the coordinates appropriately for the second head
            //
            if (pData->dwState == NVTWINVIEW_STATE_SPAN && i == 1)
            {
                if (HORIZONTAL_MODE(ppdev->cxScreen, ppdev->cyScreen))
                {
                    ppdev->rclCurrentDisplay[ulHead].left += ppdev->cxScreen / 2;
                    ppdev->rclCurrentDisplay[ulHead].right += ppdev->cxScreen / 2;
                }
                if (VERTICAL_MODE(ppdev->cxScreen, ppdev->cyScreen))
                {
                    ppdev->rclCurrentDisplay[ulHead].top += ppdev->cyScreen / 2;
                    ppdev->rclCurrentDisplay[ulHead].bottom += ppdev->cyScreen / 2;
                }
            }
        }
    }
}


//
//  Does a one time initialization of the following info into the pdev.
//
//  TwinView_State: Read from the registry (normal/clone/multimon).
//  ulNumberDacsOnBoard: Number of heads in the system.
//  ulNumberDacsConnected: Number of heads in the system which are connected to a device.
//  ulNumberDacsActive: Number of heads in the system which are active for this mode.
// ulAllDeviceMask: A mask of all output device connectors in the board.
// ulConnectedDeviceMask: A mask of all currently connected output devices in the system.
//  ulMoveDisplayDX, ulMoveDisplayDy: Panning-scanning amaount to move the screen by.
//  ulDeviceMask[NumDacs]: Bitmask for the device connected to each head.defined in nvcm.h
//  ulDeviceType[NumDacs]: defined in nvcm.h, CRT, TV, DFP
//  ulTVFormat[numDacs]: PAL or NTSC
//  ulNumPhysModes[numDacs]
//  ulnumVirtualModes[NumDacs]
//  PhysModeList[numDacs]
//  VirtualModeList[NumDacs]
//  
//
BOOL InitMultiMon(PDEV *ppdev)
{
    ULONG i, j;
    ULONG ReturnedDataLength;
    NVTWINVIEWDATA sData;
    ULONG RegistryDataOK;   // This indicates if the user selections of the nvPanel stored into the registry is OK.
    ULONG UseGDIData;
    ULONG ulDisplayWidth;
    ULONG ulDisplayHeight;
    ULONG ulHead;
    GET_NUMBER_DACS   NumberDacs;
    ULONG ulDeviceType;
    ULONG ulRet;
    ULONG ulDeviceMask;
    ULONG ulTVFormat;
    ULONG UseBIOSHeads;
    ULONG Status;
    ULONG PowerStateRegValue;
    ULONG ulCombinedDeviceMask, ulTmp;
    ULONG ulBIOSDeviceMask;
    


    DISPDBG((6,"InitMultiMon(): Enter"));


    // Get the head info from the miniport such as number of heads on board, number of heads connected and device type of each head.
    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_GET_NUMBER_DACS,
                        NULL,
                        0,
                        &NumberDacs,
                        sizeof(NumberDacs),
                        &ReturnedDataLength))
    {
        DISPDBG((0, "Oops! InitMultiMon() - IOCTL_VIDEO_GET_NUMBER_DACS failed"));
        // Set safe default values.
        ppdev->ulNumberDacsOnBoard = 1;
        ppdev->ulNumberDacsConnected = 1;
        ppdev->ulAllDeviceMask = BITMASK_CRT0;
        ppdev->ulConnectedDeviceMask = BITMASK_CRT0;
        for (i=0; i < NV_NO_DACS; i++)
        {
            ppdev->ulDeviceMask[i] = BITMASK_CRT0;
            ppdev->ulDeviceType[i] = MONITOR_TYPE_VGA;
        }
    }
    else
    {
        // Fill the info into ppdev.
        ppdev->ulNumberDacsOnBoard = NumberDacs.ulNumberDacsOnBoard;
        ppdev->ulNumberDacsConnected = NumberDacs.ulNumberDacsConnected;
        ppdev->ulAllDeviceMask = NumberDacs.ulAllDeviceMask;
        ppdev->ulConnectedDeviceMask = NumberDacs.ulConnectedDeviceMask;
        ppdev->Mobile = NumberDacs.Mobile;
        ppdev->UseHWSelectedDevice = NumberDacs.UseHWSelectedDevice;
        ppdev->ACPISystem = NumberDacs.ACPISystem;
        ppdev->UseHotKeySameMode = NumberDacs.UseHotKeySameMode;
        ppdev->PanScanSelection = NumberDacs.PanScanSelection;
        ppdev->ulDFPSupports1400x1050 = NumberDacs.ulDFPSupports1400x1050;

        for (i = 0; i < NumberDacs.ulNumberDacsOnBoard; i++)
        {
            ppdev->ulDeviceMask[i] = NumberDacs.ulDeviceMask[i];
            ppdev->ulDeviceDisplay[i] = NumberDacs.ulDeviceDisplay[i];
            ppdev->ulDeviceType[i] = NumberDacs.ulDeviceType[i];
            ppdev->ulTVFormat[i] = NumberDacs.ulTVFormat[i];
            ppdev->ulHeadDeviceOptions[i] = NumberDacs.ulHeadDeviceOptions[i];
            if (ppdev->ulHeadDeviceOptions[i] != 0 && ppdev->ulDeviceType[i] != INVALID_DEVICE_TYPE) 
            {
                ppdev->ulDacStatus[i] |= DAC_STATUS_CONNECTED;
            }
        }
    }

    //
    // Initialize the modelist pointers to NULL
    //
    for (i = 0; i < NV_NO_DACS; i++)
    {
        ppdev->PhysModeList[i] = NULL;
        ppdev->VirtualModeList[i] = NULL;
    }

    //
    // Read the default TVFormat from RM
    //
    GetDefaultTVFormat(ppdev);

    //
    // See if we need to turn on the Sony specific STOP_IMAGE method during modesets.
    //
    ppdev->EnableModesetStopImage = 0;
    GetULONGRegValue(ppdev, "EnableModesetStopImage",&ppdev->EnableModesetStopImage);
    
    if (ppdev->ulNumberDacsConnected != ppdev->ulNumberDacsOnBoard) 
    {
        DISPDBG((1,"ulNumberDacsConnected: %d, different than ulNumberDacsOnBoard: %d",
                ppdev->ulNumberDacsConnected, ppdev->ulNumberDacsOnBoard));
        // ppdev->ulNumberDacsOnBoard = ppdev->ulNumberDacsConnected;
    } 

    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        ppdev->ulDacStatus[i] |= DAC_STATUS_ON_BOARD;
        ppdev->ulEnablePanScan[i] = 1;
        ppdev->ulFreezePanScan[i] = 0;
        ppdev->ulFreezeOriginX[i] = 0;
        ppdev->ulFreezeOriginY[i] = 0;
        ppdev->ulEnableDDC[i] = 1;
        ppdev->ulTimingOverRide[i] = NVTWINVIEW_STATE_AUTO;
    }

    if (ppdev->ulNumberDacsConnected == 0) 
    {
        DISPDBG((0,"Oops! No head is connected, assuming a default CRT monitor with single head config\n"));
        ppdev->ulNumberDacsConnected = 1;
        ppdev->ulAllDeviceMask = BITMASK_CRT0;
        ppdev->ulConnectedDeviceMask = BITMASK_CRT0;
        ppdev->ulDeviceMask[0] = BITMASK_CRT0;
        ppdev->ulDeviceType[0] = MONITOR_TYPE_VGA;
        ppdev->ulDacStatus[0] |= DAC_STATUS_CONNECTED;
        DISPDBG((1,"Deivetype[%d] is MONITOR_TYPE_VGA",i));
    }

    //
    // Read the TwinViewState from the registry
    //
    ppdev->TwinView_State = NVTWINVIEW_STATE_NORMAL;
    ppdev->ulNumberDacsActive = 1;
    UseGDIData = 1;
    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_GET_TWINVIEW_STATE,
                        NULL,
                        0,
                        &sData,
                        sizeof(NVTWINVIEWDATA),
                        &ReturnedDataLength))
    {
        DISPDBG((3, "InitMultiMon() - IOCTL_VIDEO_GET_TWINVIEW_STATE failed"));
        
        if(!BuildModeLists(ppdev))
            return(FALSE);
    }
    else
    {
        //
        // Print the registry data the way it was read
        //
        PrintTwinViewData("Registry data as read in InitMultiMon()", 1, &sData, ppdev);

        //
        // Do some sanity tests to make sure we didnt get bogus data from the registry
        //
        if (sData.dwState == NVTWINVIEW_STATE_DUALVIEW)
            ppdev->TwinView_State = sData.dwState;
        if (TwinViewDataOK(ppdev, &sData))
        {
            ULONG ForceUseGDIData = 0;
            DISPDBG((6, "The registry data is sane\n"));
            

            if (!ValidateRegistryDeviceMasks(ppdev, &sData))
            {
                ForceUseGDIData = 1;
            }
            else
            {
                //
                // The requested device masks are valid. Read it into ppdev before building modelists.  
                //
                InitDevMaskFromTwinViewInfo(ppdev, &sData);
            }

            //
            // Build the virtual/physical modelists for the requested devices.
            //
            if(!BuildModeLists(ppdev))
                return(FALSE);

            if (bQueryBothPanelsAreInSync(ppdev, &sData))
            {
                // Now we can trust and use the Registry data as is.
                DISPDBG((6, "Using the registry data\n"));
                UseGDIData = 0;
            }
            else
            {
                DISPDBG((5, "Both panels are not in sync. So using the GDI data\n"));
            }
            if (ForceUseGDIData)
            {
                DISPDBG((1,"ForceUseGDIData is on. So using the GDI data"));
                UseGDIData = 1;
            }
        } 
        else
        {
            DISPDBG((1, "Ooops! The registry data is not sane\n"));
            if(!BuildModeLists(ppdev))
                return(FALSE);
        }
    } // IOCTL


    if (UseGDIData)
    {
        DISPDBG((3,"Using GDI data for mode details\n"));
        UseOnlyGDIDataForModeDetails(ppdev);
    }
    else
    {
        DISPDBG((3,"Using registry data for mode details\n"));
        UseOnlyRegistryDataForModeDetails(ppdev, &sData);
    }

    DISPDBG((1, "HKPending: 0x%x, ulAssertModeTRUE: 0x%x\n", NumberDacs.ulHotKeyPending,ppdev->ulDrvAssertModeTRUE));

    //
    // If this modeset was initiated by the nvPanel, then the TVFormat specified by the user takes precedence
    // over the default TVFormat.
    //
    if (GetInitiatedRegValue(ppdev) == 1)
    {
        // Now go through the active heads and change the TVFormat if we find any active TV device.
        for (i=0; i < ppdev->ulNumberDacsActive; i++)
        {
            ulHead = ppdev->ulDeviceDisplay[i];
            ulDeviceMask = ppdev->ulDeviceMask[ulHead];
            if (ulDeviceMask & BITMASK_ALL_TV)
            {
                DISPDBG((1, "InitMultiMon(): RMDefaultTVFormat: 0x%x, nvPanelTVFormat: 0x%x, PhysHead: 0x%x\n",
                    ppdev->ulDefaultTVFormat, ppdev->ulTVFormat[ulHead], ulHead));
                DISPDBG((1, "So using the user specified TVFormat instead of the RMDefaultTVFormat\n"));
                ppdev->ulDefaultTVFormat = ppdev->ulTVFormat[ulHead];
                ppdev->ulDefaultTVDeviceType = TVFormatToTVDeviceType(ppdev->ulTVFormat[ulHead]);
                break;
            }
        }
    }

    

    // 
    // Assume we have to obey the BIOS heads
    //
    UseBIOSHeads = 1;

    //
    // Miniport handles the BIOS heads at boot time. So need for the display driver to muck with
    // BIOS heads. We do not want to do this if we were called as a result of the hotkey switch.
    //
    if (NumberDacs.ulHotKeyPending == 1)
    {
        UseBIOSHeads = 0;
        //
        // We need to let the control panel thread know that a HK switch has taken place.
        // This is to handle the case when the control panel is open and the user presses HK
        // and the same desktop is maintained by the OS, then the OS does not send any
        // WM_DISPLAYCHANGE message to the control panel app thus causing some device-type-sensitive
        // pages such as TV adjustment to crash.
        //
        if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SIGNAL_NVCPL_HOTKEY_EVENT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &ReturnedDataLength))
        {
            DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_NVCPL_HOTKEY_EVENT failed"));
        }   

        //
        // Clear the ulInduceModeChangeDeviceMask so that StopImage will be deactivated if it has been turned on.
        // This handles the pathological case, where for some reason, control panel/NVSVC is not able to
        // do the induced modechange successsfully and the screen stays black since StopImage is activated.
        // Then the user will most likely hit HK to get the laptop back to a usable state.
        // Also, let miniport know too.
        //
        if (ppdev->ulInduceModeChangeDeviceMask != 0)
        {
            DISPDBG((1,"Something wrong. ppdev->ulInduceModeChangeDeviceMask: 0x%x, is being cleared due to HK",
            ppdev->ulInduceModeChangeDeviceMask));
        }
        ppdev->ulInduceModeChangeDeviceMask = 0;
        if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK,
                        &ppdev->ulInduceModeChangeDeviceMask,
                        sizeof(ULONG),
                        NULL,
                        0,
                        &ReturnedDataLength))
        {
            DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_DEVMASK failed"));
        }   

    }

    //
    // if we are called directly by the nvPanel, do not use BIOS heads.
    //
    if (GetInitiatedRegValue(ppdev) == 1)
    {
       UseBIOSHeads = 0;
    }

    //
    // The display driver needs to obey BIOS heads only for two cases - returning from FSDOS and resuming from
    // standby/suspend/hibernate. Fortunately for us, Win2K calls DrvAssertMode(TRUE) while returning from 
    // these conditions. So we will use BIOS heads only if this modeset is a result of DrvAssertMode(TRUE) and not
    // DrvEnableSurface().
    //
    if (ppdev->ulDrvAssertModeTRUE == 0)
    {
       UseBIOSHeads = 0;
    }
    else
    {
        //
        // We are here because of a DrvAssertMode(TRUE). Now check if we are enabling
        // the same pdev that was used while going down into VGA mode last. This handles
        // the special case of when we have multiple pdevs active. We compare the 
        // iUnique numbers of the pdevs to distinguish between the cases of
        // resuming from FSDOS/DPMS and toggling between multiple pdevs.
        //
        DISPDBG((1, "Comparing ppdev->iUniqueness: %d, MiniportiUniqueness: %d",
            ppdev->iUniqueness, NumberDacs.ulUniquenessVGA));
        if (NumberDacs.ulUniquenessVGA != ppdev->iUniqueness)
        {
            DISPDBG((1, "Mismatch of iUniqueness so not calling HandleBiosHeads"));
            UseBIOSHeads = 0;
        }
        else
        {
            //
            // We are returning from FSDOS or resuming from DPMS.
            // Clear the PrevDevMask registry entry to ensure that we do the begin/end modeset bracketing.
            //
            SetPrevDevMaskRegValue(ppdev, 0);
        }
    }

    //
    // if we are in spanning mode, we do not obey BIOS heads
    //
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_SPAN)
    {
       //
       // Exception. If one or both of the devices is disconnected, 
       // then we do obey BOOT_DEVICES in spanning mode on laptops.
       //
       if (ppdev->ACPISystem)
       {
            ulCombinedDeviceMask = 0;
            for (i=0; i < ppdev->ulNumberDacsActive; i++)
            {
                ulHead = ppdev->ulDeviceDisplay[i];
                ulCombinedDeviceMask |= ppdev->ulDeviceMask[ulHead];
            }
            ulTmp = ulCombinedDeviceMask;
            if (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                               NV_CFGEX_CHECK_CONNECTED_DEVICES, &ulTmp, sizeof(ULONG)))
            {
                DISPDBG((0, "HandleBIOSHeads - Cannot get CHECK_CONNECTED_DEVICES value from RM"));
                UseBIOSHeads = 0;
            }
            else
            {
                if (ulTmp == ulCombinedDeviceMask)
                {
                   //
                   // Both devices are present. So no need to obey BOOT_DEVICES.
                   //
                   UseBIOSHeads = 0;
                }
            }
        }
    }

    //
    // We don't need to obey BOOT_DEVICES on desktops.
    //
    if (ppdev->ACPISystem == 0)
    {
       UseBIOSHeads = 0;
    }

    //
    // use the BIOS heads only if asked to do so in the registry (for laptops).
    //
    if (ppdev->UseHWSelectedDevice == 0)
    {
       UseBIOSHeads = 0;
    }

    

    //
    // Check the registry to see if this is not the extra DrvAssertMode(TRUE) that the OS calls 
    // while resuming from hibernation. Ugh.. I hate state machines but I could not think of any other
    // way to detect this condition. Note that all these calls act on the same pdev.
    // The situation I was running into a problem on the laptop was as follows:
    //
    // - set clone(DFP+CRT).
    // - hibernate
    // - resume
    // - DrvAssertMode(TRUE):   BOOT_DEVICES correctly indicates DFP+CRT: First call
    // - DrvAssertMode(FALSE):  Display and RM think that we are going into FSDOS
    // - DrvAssertMode(TRUE):   BOOT_DEVICES indicates CRT: We need to identify this extra DrvAssertModeTRUE call
    //                          and not obey the BOOT_DEVICES: Second call.
    //
    // All this jugglery because there is no way for the display driver to uniquely identify when we are really going 
    // down into VDM FSDOS via ALT+ENTER or via an App request. Sigh...
    // Note: '5' corresponds to the VideoPowerHibernateState defined in ddk\src\video\inc\ntddvdeo.h
    // Since I can not include ntddvdeo.h in the display driver, I use the numeral value.
    //
    if (ppdev->ulDrvAssertModeTRUE == 1 && NumberDacs.ulUniquenessVGA == ppdev->iUniqueness)
    {
        #define IGNORE_NEXT_ASSERTMODE 0x1234
        //
        // Read the registry value to see what the power down state was when we went down before resuming.
        //
        PowerStateRegValue = GetPowerStateRegValue(ppdev);

        //
        // See if it is the first call.
        //
        if (PowerStateRegValue == 5)
        {
            //
            // we set the registry to indicate that on the next DrvAssertMode(TRUE) we do not obey the BOOT_DEVICES.
            //
            SetPowerStateRegValue(ppdev, IGNORE_NEXT_ASSERTMODE);
        }

        //
        // See if it is the second call.
        //
        if (PowerStateRegValue == IGNORE_NEXT_ASSERTMODE)
        {
            //
            // we do not read the BOOT_DEVICES for this second extra call.
            // Also, set the registry value back to 0.
            //
            if (ppdev->ulDrvAssertModeTRUE == 1)
            {
                UseBIOSHeads = 0;
                SetPowerStateRegValue(ppdev, 0);
            }
        }
    }
    

    //
    // Now call handleBIOSHEads() if we need to.
    //
    if (UseBIOSHeads)
    {
        ulRet = HandleBIOSHeads(ppdev);
        if (ulRet == FALSE)
        {
            //
            // Since the devices were changed in HandleBIOSHeads(), we need to reconstruct the modelists
            // and make sure we are using valid physical modes.
            // Handle only the standard/clone mode case (just a redundant safety check since we should never be
            // here if we were in spanning mode).
            //
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL ||
                ppdev->TwinView_State == NVTWINVIEW_STATE_DUALVIEW ||
                ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE)
            {
                if(!BuildModeLists(ppdev))
                    return(FALSE);
                UseOnlyGDIDataForModeDetails(ppdev);
            }
        }
    }
    else 
    {
        DISPDBG((1,"Not called HandleBIOSHEads\n"));
        //
        // Print the BOOT_DEVICES just for debugging purposes
        //
        if (Status = NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                                  NV_CFG_GET_BOOT_DEVICES, &ulBIOSDeviceMask))
        {
            DISPDBG((0,"Oops!    NV_CFG_GET_BOOT_DEVICES failed"));
        }
        DISPDBG((1,"Disp: Informational only: HandleBIOSHeads(): BIOSDeviceMask: 0x%x",ulBIOSDeviceMask));
    }

    //
    // Now turn off the DrvAssertMode flag since we have used it already.
    //
    ppdev->ulDrvAssertModeTRUE = 0;
    
    switch (ppdev->TwinView_State)
    {
        case NVTWINVIEW_STATE_SPAN:
            if (MULTIMON_MODE(ppdev->cxScreen, ppdev->cyScreen))
            {
                ppdev->ulDesktopMode = NV_TWO_DACS | NV_SPANNING_MODE ;
                ppdev->ulNumberDacsActive = 2;
            }
            else
            {
                ppdev->ulDesktopMode = 0;
                ppdev->ulNumberDacsActive = 1;
            }
            DISPDBG((6,"State Read is NVTWINVIEW_STATE_SPAN"));
            break;
        case NVTWINVIEW_STATE_CLONE:
            ppdev->ulDesktopMode = NV_CLONE_DESKTOP | NV_TWO_DACS;
            ppdev->ulNumberDacsActive = 2;
            DISPDBG((6,"State Read is NVTWINVIEW_STATE_CLONE"));
            break;
        case NVTWINVIEW_STATE_NORMAL:
        case NVTWINVIEW_STATE_DUALVIEW:
            ppdev->ulNumberDacsActive = 1;
            ppdev->ulDesktopMode = 0;
            DISPDBG((6,"State Read is NVTWINVIEW_STATE_NORMAL/NVTWINVIEW_STATE_DUALVIEW"));
            break;
        default:
            ppdev->ulDesktopMode = 0;
            ppdev->ulNumberDacsActive = 1;
            DISPDBG((0,"oops!! Invalid TwinView State: %d\n",ppdev->TwinView_State));
            break;
    }

    // Control panel To Do
    // should set up these value to move screen for panning and scanning
    
    // HW restriction: Set image offset value is a multiple of 4 bytes.  
    // Since move mouse pointer rountine does not deal with 8bpp, 16bpp or 32bpp,
    // set to 4 pixel increment in order to satisfy HW restriction.
    ppdev->ulMoveDisplayDx = 4; 
    ppdev->ulMoveDisplayDy = 4;

    //
    // Convert the device masks to device type
    //
    for (i = 0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        //
        // Convert the device mask to device type. 
        //
        ulHead = ppdev->ulDeviceDisplay[i];
        ulDeviceType = MaskToDeviceType(ppdev, ppdev->ulDeviceMask[ulHead]);
        ppdev->ulDeviceType[ulHead] = ulDeviceType;
        ppdev->ulTVFormat[ulHead] = ppdev->ulDefaultTVFormat;
    }

    //
    // Make sure the head mapping array is 0,1 or 1,0 for standard mode.
    //
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL || ppdev->TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
    {
        ulHead = ppdev->ulDeviceDisplay[0];
        if (ulHead == 1)
        {
            ppdev->ulDeviceDisplay[1] = 0;
        }
        if (ulHead == 0)
        {
            ppdev->ulDeviceDisplay[1] = 1;
        }
    }

    //
    // Handle the BANDWIDTH limitations of some hardware.
    // For eg. on Toshiba, the NV hardware and the SXGA+ EDID can handle 1400x1050x100HZ.
    // But the system does not allow for scanout bandwidth for this mode while in clone mode.
    // We make this test as a generic test.
    //
    if (ppdev->ulNumberDacsActive == 1)
    {
        HandleBandWidth_SingleDacActive(ppdev);
    }
    if (ppdev->ulNumberDacsActive == 2)
    {
        HandleBandWidth_DualDacsActive(ppdev);
    }
    


    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
        ulDisplayHeight = ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
        if((ulDisplayWidth < (ULONG)(ppdev->rclDisplayDesktop[ulHead].right - ppdev->rclDisplayDesktop[ulHead].left)) ||
           (ulDisplayHeight < (ULONG)(ppdev->rclDisplayDesktop[ulHead].bottom - ppdev->rclDisplayDesktop[ulHead].top)) )
        {
            ppdev->ulDesktopMode |= (i ? NV_VIRTUAL_DESKTOP_2 : NV_VIRTUAL_DESKTOP_1); 
        }
    }

    ppdev->ulFlipBase = 0;          // Re-initialized back to 0 base after a mode switch


    // Initialize the Cached Cursor data for each mode set
    ppdev->ulCachedCursorWidth = 0;
    ppdev->ulCachedCursorFormat = 0;


    //
    // Now print the info recorded into the ppdev
    //
    PrintPPDEVTwinViewInfo("Printing PPDEV info after finishing InitMultiMon()", ppdev);

    //
    // Now write the current selection from the ppdev back into the twinviewinfo registry structure.
    //
    WriteRegistryTwinViewInfo (ppdev, NULL);

    //
    // Read the current SaveSettings table into ppdev
    //
    vReadSaveSettings(ppdev);

    //
    // Update the registry SaveSettings table with the just concluded modeset.
    //
    vWriteSaveSettings(ppdev);

    //
    // Print the just written SaveSettings table for debugging purposes
    //
    vPrintSaveSettings(ppdev, 2);

    return(TRUE);
}

//
// Returns TRUE if the given head supports the "RequestedMode". "BestFitMode" is not modified.
// Returns FALSE if the given head and does not support the requested mode and returns a best fit mode supported by the device
// which is the nearest match this device actually supports.
// BUGBUG: For now we hardcode a max mode of 1024x768x32ppx60HZ for a DFP and 800x600x32bppx60HZ for TV.
// We assume the CRT can do all modes for now.
//
BOOLEAN bQuerySupportPhysicalMode(PPDEV ppdev, ULONG head, ULONG ulDeviceMask, MODE_ENTRY *RequestedMode, MODE_ENTRY *BestFitMode)
{
    BOOLEAN bRet = TRUE;
    ULONG i;
    MODE_ENTRY *PhysModePtr;
    ULONG ulDeviceType;
    ULONG ulPrimaryHead, ulPrimaryDeviceMask;

    if (ulDeviceMask & BITMASK_ALL_CRT)
    {
        ulDeviceType = MONITOR_TYPE_VGA;
    }
    if (ulDeviceMask & BITMASK_ALL_DFP)
    {
        ulDeviceType = MONITOR_TYPE_FLAT_PANEL;
    }
    if (ulDeviceMask & BITMASK_ALL_TV)
    {
        ulDeviceType = ppdev->ulDefaultTVDeviceType;
    }

    // We will set the BestFitMode to be equal to the Requested mode and then change any fields if need be.
    *BestFitMode = *RequestedMode;

    ulPrimaryHead = ppdev->ulDeviceDisplay[0];
    ulPrimaryDeviceMask = ppdev->ulDeviceMask[ulPrimaryHead];

#if _WIN32_WINNT >= 0x500
    //
    // Since we don't expose TV EDID to GDI, GDI has no idea of existence of TV.  Prune TV anyway.
    //
    if (ulDeviceType != ppdev->ulDefaultTVDeviceType)
    {
        //
        // See whether the display driver or the GDI should do the mode pruning for this head.
        //
        if (bQueryGDIModePruning(ppdev->TwinView_State, ulPrimaryHead, ulPrimaryDeviceMask, 
                head,  ulDeviceMask, ppdev->ACPISystem, ppdev->GDIModePruning))
        {
            //
            // We let GDI do the mode pruning for the EDID
            //
            return(TRUE);
        }
    }
#endif


    switch (ulDeviceType)
    {
        case MONITOR_TYPE_VGA:
        case MONITOR_TYPE_FLAT_PANEL:
            PhysModePtr = ppdev->PhysModeList[head];
            for (i=0; i < ppdev->ulNumPhysModes[head]; i++)
            {
                if (PhysModePtr->ValidMode && 
                    PhysModePtr->Width == RequestedMode->Width &&
                    PhysModePtr->Height == RequestedMode->Height &&
                    PhysModePtr->Depth == RequestedMode->Depth &&
                    PhysModePtr->RefreshRate == RequestedMode->RefreshRate)
                {
                    // Found a match.
                    bRet = TRUE;
                    return(bRet);
                }
                PhysModePtr++;
            }
            // Did not find a match.
            // So backoff to find the next best mode.
            vBackOffMode(ppdev, head, ulDeviceMask, RequestedMode, BestFitMode);
            
            bRet = FALSE;
            break;
        case MONITOR_TYPE_NTSC:
        case MONITOR_TYPE_PAL:
            {
                NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
                ULONG ReturnedDataLength;
                DWORD ulRet=0;
                

                // The IOCTL assumes head0.
                ulRet = EngDeviceIoControl(ppdev->hDriver,
                                    IOCTL_VIDEO_GET_TV_ENCODER_TYPE,
                                    NULL,
                                    0,
                                    &TVInfo,
                                    sizeof(TVInfo),
                                    &ReturnedDataLength);
                DISPDBG((2, "TVEncoderType: 0x%x, ID=0x%x, Connected=0x%x",TVInfo.EncoderType, TVInfo.EncoderID, TVInfo.TVConnected));
                if (ulRet)
                {
                    DISPDBG((0, "InitMultiMon() - IOCTL_VIDEO_GET_TV_ENCODER_TYPE failed, returned %d",ulRet));
                    // Set safe default values.
                    BestFitMode->Width  = 800;
                    BestFitMode->Height = 600;
                    bRet = FALSE;
                }
                // Conexant871 == Brooktree871
                else if ( (TVInfo.EncoderType == NV_ENCODER_BROOKTREE_871) && (RequestedMode->Width >= 1024 || RequestedMode->Height >= 768)) 
                {
                    BestFitMode->Width = 1024;
                    BestFitMode->Height = 768;
                    bRet = FALSE;
                }
                else if (RequestedMode->Width > 800 || RequestedMode->Height > 600)
                {
                    BestFitMode->Width  = 800;
                    BestFitMode->Height = 600;
                    bRet = FALSE;
                }
                if (RequestedMode->RefreshRate != 60)
                {
                    BestFitMode->RefreshRate = 60;
                    bRet = FALSE;
                }
                break;
            }

            
        default:
            DISPDBG((1,"bQuerySupportPhysicalMode(): Invalid devicetype: 0x%x\n",ppdev->ulDeviceType[head]));
            BestFitMode->Width = 1024;
            BestFitMode->Height = 768;
            BestFitMode->RefreshRate = 60;
            bRet = FALSE;
            break;
    } //switch


    return(bRet);
}

//
// Finds the nearest match for the requestedMode by backing off in the order - refresh rate, height, width.
// Note: Can be called for any output device type.
//
VOID vBackOffMode(PPDEV ppdev, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *RequestedMode, MODE_ENTRY *BestFitMode)
{
    ULONG i;
    MODE_ENTRY *PhysModePtr;
    DAC_TIMING_VALUES sTimingDac;
    HEAD_RESOLUTION_INFO HeadResolution;
    DWORD ReturnedDataLength;

    // Assume a true match. Then we back off the appropriate attribute.
    BestFitMode->Width = RequestedMode->Width;
    BestFitMode->Height = RequestedMode->Height;
    BestFitMode->Depth = RequestedMode->Depth;
    BestFitMode->RefreshRate = RequestedMode->RefreshRate;

    PhysModePtr = ppdev->PhysModeList[ulHead];
    // sanity check. First see if the mode actually find a true match.
    for (i=0; i < ppdev->ulNumPhysModes[ulHead]; i++)
    {
        if (PhysModePtr->ValidMode && 
            PhysModePtr->Width == RequestedMode->Width &&
            PhysModePtr->Height == RequestedMode->Height &&
            PhysModePtr->Depth == RequestedMode->Depth &&
            PhysModePtr->RefreshRate == RequestedMode->RefreshRate)
        {
            // Found a match.
            return;
        }
        PhysModePtr++;
    }
    
    //
    // Did not find a match. Let the common modeset code FindModeEntry() do the back off for us.
    // Fill up the head resolution info structure used for the common modeset code.
    //
    HeadResolution.ulDisplayWidth = RequestedMode->Width;
    HeadResolution.ulDisplayHeight= RequestedMode->Height;      
    HeadResolution.ulDisplayRefresh = RequestedMode->RefreshRate;   
    
    HeadResolution.ulHead = ulHead;              
    HeadResolution.ulDeviceMask = ulDeviceMask;        
    HeadResolution.ulDeviceType = ppdev->ulDeviceType[ulHead];        
    HeadResolution.ulTVFormat = ppdev->ulTVFormat[ulHead];
    HeadResolution.ulDisplayPixelDepth = RequestedMode->Depth;
    HeadResolution.ulOption = 0;
    

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_TIMING_DAC,
                           &HeadResolution,  // input buffer
                           sizeof(HEAD_RESOLUTION_INFO),
                           &sTimingDac,
                           sizeof(DAC_TIMING_VALUES),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "nvMultiMon.c - IOCTL_VIDEO_GET_TIMING_DAC failed"));
        BestFitMode->Width = 800;
        BestFitMode->Height = 600;
        BestFitMode->Depth = RequestedMode->Depth;
        BestFitMode->RefreshRate = 60;
        return;
    }

    

    // Use the returned mode as the supported physical mode.
    // BUGBUG: FindModeEntry() could have tweaked either the refresh rate or width or height.
    // Not sure what tweak the user would prefer. So for now, I take whatever FindModeEntry() gives.
    // Fortunately it does not tweak the depth!
    BestFitMode->Width = (USHORT)sTimingDac.HorizontalVisible;
    BestFitMode->Height = (USHORT)sTimingDac.VerticalVisible;
    BestFitMode->Depth = RequestedMode->Depth;
    BestFitMode->RefreshRate = (USHORT)sTimingDac.Refresh;
    return;
}


//
// Frees up any memory alloced by the driver for multimon purposes.
// Should be called from DrvDisablePdev().
//
void FreeMemoryMultiMon(PDEV *ppdev)
{
    ULONG   i;

    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        if (ppdev->PhysModeList[i] != NULL)
        {
            EngFreeMem(ppdev->PhysModeList[i]);
            ppdev->PhysModeList[i] = NULL;
        }
        if (ppdev->VirtualModeList[i] != NULL)
        {
            EngFreeMem(ppdev->VirtualModeList[i]);
            ppdev->VirtualModeList[i] = NULL;
        }
    }
}

//
// Returns true if the twinviewData is safe. Otherwise returns FALSE>
//
BOOLEAN TwinViewDataOK(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    BOOLEAN bRet = TRUE;
    if (pData->DeskTopRectl.left == 0 && pData->DeskTopRectl.top == 0 && 
        pData->DeskTopRectl.right == 0 && pData->DeskTopRectl.bottom == 0)
    {
        DISPDBG((1,"DeskTopRectl is all zeroed out\n"));
        bRet = FALSE;
    }

    if (pData->dwState != NVTWINVIEW_STATE_SPAN && pData->dwState != NVTWINVIEW_STATE_CLONE &&
        pData->dwState != NVTWINVIEW_STATE_DUALVIEW && pData->dwState != NVTWINVIEW_STATE_NORMAL) 
    {
       DISPDBG((0,"OOps! Invalid State: 0x%x\n", pData->dwState));
       bRet = FALSE;
    }

    if ((pData->dwState == NVTWINVIEW_STATE_NORMAL || pData->dwState == NVTWINVIEW_STATE_DUALVIEW)
        && pData->dwDeviceDisplay[0] > 1)
    {
       DISPDBG((0,"Oops! Invalid Head Mapping.  dwDviceDisplay[0]: 0x%x for NORMAL state\n", pData->dwDeviceDisplay[0]));
       bRet = FALSE;
    }

    if (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE)
    {
        if (pData->dwDeviceDisplay[0] > 1 || 
            pData->dwDeviceDisplay[1] > 1 ||
            (pData->dwDeviceDisplay[0] == 0 && pData->dwDeviceDisplay[1] == 0) ||
            (pData->dwDeviceDisplay[0] == 1 && pData->dwDeviceDisplay[1] == 1))
        {
           DISPDBG((0,"OOps! Invalid Head Mapping.  dwDeviceDisplay: 0x%x, 0x%x for MULTIMON state\n", 
            pData->dwDeviceDisplay[0], pData->dwDeviceDisplay[1]));
            DISPDBG((0, "Patching the Head Mappings to 0 and 1 respectively\n"));
            // rather than return false, let me try to patch this error.
            pData->dwDeviceDisplay[0] = 0;
            pData->dwDeviceDisplay[1] = 1;
        }
    }

    if (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE) 
    {
        if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp != pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp)
        {
            DISPDBG((0,"OOps! bit depths differ for head0: %d and head1: %d \n",
                pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp,pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp));
            bRet = FALSE;
        }
    }


    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp == 0)
    {
       DISPDBG((0,"OOps! bit depths are Zero for both head0 and head1: %d, %d\n",
            pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp,pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp));
        bRet = FALSE;
    }

    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].dwRefresh == 0)
    {
        DISPDBG((0,"OOps! ulRefreshRate is all zeroed out for both heads\n"));
        bRet = FALSE;
    }
    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.bottom == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.bottom == 0)
    {
        DISPDBG((0,"OOps! VirtualRectl is all zeroed out for both heads\n"));
        bRet = FALSE;
    }

    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.bottom == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.bottom == 0)
    {
        DISPDBG((0,"OOps! PhysicalRectl is all zeroed out for both heads\n"));
        bRet = FALSE;
    }

    // If there is just one head on the board and the registry says any mode other than normal, mark it as invalid.
    if (ppdev)
    {

        if (ppdev->ulNumberDacsOnBoard == 1 &&
            (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE))
        {
            DISPDBG((0,"OOps! Registry state is invalid for the number of heads on the board or for the number of connected heads\n"));
            bRet = FALSE;
        }
    }

    return(bRet);
}



//
// Handle the case when the user makes some selection through nvPanel causing the rgistry entry "TwinViewInfo" 
// to be written and then uses the NT panel (or programmatically through an app) 
// to make mode changes (refresh rate, color depth, resolution, choosing a
// spanning mode resolution). So we need to sync the NT and nvPanel now.
// This function does not modify the 'pdm' or the 'pdev'. It Returns TRUE if the NTPanel selections and the
// nvPanel's selections are identical else returns FALSE.
//
BOOLEAN bQueryBothPanelsAreInSync(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG NumberDacsOnBoard;
    ULONG i;
    ULONG NTWidth, NTHeight, nvWidth, nvHeight; // Width, height of the NT panel selections and nvPanel selections.
    ULONG ulHeadPrimary, ulHead;
    MODE_ENTRY RequestedMode, BestFitMode;

    DISPDBG((5,"Enter bQueryBothPanelsAreInSync()\n"));
    ulHeadPrimary = pData->dwDeviceDisplay[0];

    // Now see if the registry data needs to be synced.
    // If the color depth, primary refresh rate, width and height are the same as in the registry, then the registry data
    // is already in sync and we don't need to do anything.
    if ((ULONG)ppdev->cBitsPerPel == pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwBpp &&
        (ULONG)ppdev->ulGDIRefreshRate == pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwRefresh &&
        ppdev->cxScreen == (pData->DeskTopRectl.right - pData->DeskTopRectl.left) &&
        ppdev->cyScreen == (pData->DeskTopRectl.bottom - pData->DeskTopRectl.top))
    {
        DISPDBG((5,"The registry data and the GDI data are in sync.\n"));
        return(TRUE);
    }

    // Pull out theright pieces of info from GDI into the registry structure
    //
    // GDI _solely_ determines the following pieces of info
    // DEsktopRectl, depth for both heads
    // Head0: bpp, Refresh rate, VirtualRect
    // Head1: bpp, VirtualRect
    //
    // GDI _may_ determine the following
    // Head0: physical rect
    // Head1: physical rect
    //
    // Registry _soley_ determines the following pieces of info
    // dwState, dwOrientation
    //
    // Registry _may_ determine the following pieces of info
    // Head0: physical rect
    // head1: physical rect, refresh rate

    // see if the color depth has changed for the primary head.
    if ((ULONG)ppdev->cBitsPerPel != pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwBpp)
    {
        for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
        {
            ulHead = pData->dwDeviceDisplay[i];
            pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwBpp = (ULONG)ppdev->cBitsPerPel;
        }
    }

    // see if the refresh rate has changed for the primary head.
    if ((ULONG)ppdev->ulGDIRefreshRate != pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwRefresh)
    {
        pData->NVTWINVIEWUNION.nvtwdevdata[ulHeadPrimary].dwRefresh = (ULONG)ppdev->ulGDIRefreshRate;
    }

    // See if the resolution has changed. If so, we need to change each head's virtual rectl and also
    // carefully change each head's physical rect.
    if (ppdev->cxScreen != (pData->DeskTopRectl.right - pData->DeskTopRectl.left) ||
        ppdev->cyScreen != (pData->DeskTopRectl.bottom - pData->DeskTopRectl.top))
    {
        //
        // TODO: GK: Do a sanity check of the ulDeviceDisplay in pData. If it is not sane, set the default 0,1 values
        // into the pData
        //
        SET_RECT(&pData->DeskTopRectl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);

        // set up the virtualrect for all the heads corresponding to the state.
        // Check to see if it is horizontal orientation
        if (HORIZONTAL_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
        {
            if (pData->dwState != NVTWINVIEW_STATE_SPAN  || 
                pData->dwOrientation != HORIZONTAL_ORIENTATION)
            {
                DISPDBG((0,"Oops! Invalid state: 0x%x or orientation: 0x%x for requested GDI resolution (%d, %d)\n",
                    pData->dwState,pData->dwState, ppdev->cxScreen, ppdev->cyScreen));
                DISPDBG((0, "Patch it up by setting the correct state and orientation in pdev\n"));
                pData->dwState = NVTWINVIEW_STATE_SPAN;
                pData->dwState = HORIZONTAL_ORIENTATION;
            }

            RequestedMode.Width = (USHORT)ppdev->cxScreen / 2;
            RequestedMode.Height = (USHORT)ppdev->cyScreen;
            RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
            RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

            //
            // Fill in the info for primary device
            //

            //
            // TODO: GK: Do a sanity check of the ulDeviceDisplay in pData. If it is not sane, set the default 0,1 values
            // into the pData
            //

            ulHead = pData->dwDeviceDisplay[0];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, 0, ppdev->cxScreen / 2, ppdev->cyScreen);
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0,
                    RequestedMode.Width, RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                    BestFitMode.Width, BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }

            //
            // Fill in the info for secondary device
            //
            ulHead = pData->dwDeviceDisplay[1];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, ppdev->cxScreen / 2, 0, 
                (ppdev->cxScreen / 2) + (ppdev->cxScreen / 2), ppdev->cyScreen);
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, ppdev->cxScreen / 2, 0,
                    (ppdev->cxScreen / 2) + RequestedMode.Width, RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, ppdev->cxScreen / 2, 0,
                    (ppdev->cxScreen / 2) + BestFitMode.Width, BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }
        } // HORIZONTAL_MODE

        // check to see if it is vertical orientation
        if (VERTICAL_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
        {   
            if (pData->dwState != NVTWINVIEW_STATE_SPAN  || 
                pData->dwOrientation != VERTICAL_ORIENTATION)
            {
                DISPDBG((0,"Oops! Invalid state: 0x%x or orientation: 0x%x for requested GDI resolution (%d, %d)\n",
                    pData->dwState,pData->dwOrientation, ppdev->cxScreen, ppdev->cyScreen));
                DISPDBG((0, "Patch it up by setting the correct state and orientation in pdev\n"));
                pData->dwState = NVTWINVIEW_STATE_SPAN;
                pData->dwOrientation = VERTICAL_ORIENTATION;
            }

            RequestedMode.Width = (USHORT)ppdev->cxScreen;
            RequestedMode.Height =(USHORT) ppdev->cyScreen / 2;
            RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
            RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

            //
            // Fill in the info for primary device
            //
            ulHead = pData->dwDeviceDisplay[0];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, 0, 
                ppdev->cxScreen, ppdev->cyScreen / 2);
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0,
                    RequestedMode.Width, RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0,
                    BestFitMode.Width, BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }

            //
            // Fill in the info for secondary device
            //
            ulHead = pData->dwDeviceDisplay[1];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, ppdev->cyScreen / 2,
                ppdev->cxScreen, (ppdev->cyScreen / 2) + (ppdev->cyScreen / 2));
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, ppdev->cyScreen / 2,
                    RequestedMode.Width, (ppdev->cyScreen / 2) + RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, ppdev->cyScreen / 2,
                    BestFitMode.Width,(ppdev->cyScreen / 2) + BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }
        } // VERTICAL_MODE

        if (!MULTIMON_MODE(ppdev->cxScreen, ppdev->cyScreen)) 
        {   
            // Note we could still be in the state of multimon except the user has chosen the 6x4 or 8x6 mode.

            RequestedMode.Width = (USHORT)ppdev->cxScreen;
            RequestedMode.Height = (USHORT)ppdev->cyScreen;
            RequestedMode.Depth = (USHORT)ppdev->cBitsPerPel;
            RequestedMode.RefreshRate = (USHORT)ppdev->ulGDIRefreshRate;

            //
            // Fill in the info for primary device
            //
            ulHead = pData->dwDeviceDisplay[0];
            SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
            if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                    RequestedMode.Width, RequestedMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
            }
            else
            {
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                    BestFitMode.Width,BestFitMode.Height);
                pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
            }

            // fill up the second head info also. It will be used in clone mode but ignored in the normal mode.
            if (pData->dwState == NVTWINVIEW_STATE_CLONE && ppdev->ulNumberDacsOnBoard > 1)
            {
                ulHead = pData->dwDeviceDisplay[1];
                SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].VirtualRectl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
                if (bQuerySupportPhysicalMode(ppdev, ulHead, ppdev->ulDeviceMask[ulHead], &RequestedMode, &BestFitMode))
                {
                    SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                        RequestedMode.Width,RequestedMode.Height);
                    pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = RequestedMode.RefreshRate;
                }
                else
                {
                    SET_RECT(&pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].PhysicalRectl, 0, 0, 
                        BestFitMode.Width,BestFitMode.Height);
                    pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwRefresh = BestFitMode.RefreshRate;
                }
            }
        } // single screen resolution
    } // if the GDI resolution is different than registry resolution
    

    return(TRUE);
}


//
// Returns TRUE if the RequestedDeviceType (and the requested TV type in the case of TV) is actually present and
// connected on the 'Head'. If not, returns FALSE and returns a safe valid device type in the *SuggestedDeviceType field.
//
BOOLEAN bConfirmDeviceType(PPDEV ppdev, ULONG Head, ULONG RequestedDeviceMask, ULONG RequestedDeviceType, ULONG RequestedTVType,
                           ULONG * SuggestedDeviceMask, ULONG * SuggestedDeviceType, ULONG * SuggestedTVType)
{
    BOOLEAN bRet = FALSE;
    BOOLEAN bFoundSuggested = FALSE;

    // We ignore the ulDeviceType arguement here.
    if (ppdev->ulConnectedDeviceMask & RequestedDeviceMask)
    {
        return(TRUE);
    }
    else
    {
        *SuggestedDeviceMask = ppdev->ulDeviceMask[Head];
        *SuggestedTVType = ppdev->ulTVFormat[Head];
        return(FALSE);
    }

} // End function bConfirmDeviceType()

//
// This functions returns the physical modelist and virtual modelist for each head.
// Returns TRUE if successful else reurns FALSE.
// if the ModeList pointer is NULL, then only the number of modes is returned, else the actual modelist is returned 
// for the passed in NumModes.
//
BOOLEAN bGetPhysicalVirtualModeList(PPDEV ppdev, ULONG Head, ULONG DeviceMask, ULONG DeviceType, ULONG TVFormat,
        MODE_ENTRY *PhysModeList, MODE_ENTRY *VirtModeList, ULONG *NumPhysModes, ULONG *NumVirtModes)
{
    MODE_ENTRY * SrcPtr;
    ULONG DoSanityCheck = 1;
    ULONG j;
    BOOLEAN bRet = TRUE;
    ULONG ulTmp, ulRet, ulRetSize;
    
    // For the requested devicetype, get the number of virtual modes and fillup the virtual modelist pointer if asked for.
    if (NumVirtModes != NULL)
    {
        *NumVirtModes = ppdev->ulNumVirtualModes[Head];
        //
        // Fill up the virtual modelist.
        // This is device type independent.
        //
        if (VirtModeList != NULL)
        {
            SrcPtr = ppdev->VirtualModeList[Head];
            for (j=0; j < ppdev->ulNumVirtualModes[Head]; j++)
            {
                *VirtModeList = *SrcPtr;
                VirtModeList++;
                SrcPtr++;
            }
        }
    } // NumVirtModes != NULL

    //
    // Fill up the Physical modelist.
    // This is device type dependent.
    // We start off with the virtual modelist and eliminate those modes not supported by this device. Eventually we will do
    // EDID filtering in this chunk of code.
    //
    if (NumPhysModes != NULL)
    {
        HEAD_MODE_LIST_INFO InputInfo;
        

        InputInfo.ulHead = Head;
        InputInfo.ulDeviceMask = DeviceMask;
        InputInfo.ulDeviceType = DeviceType;
        InputInfo.ulTVType = TVFormat;
        InputInfo.ulEnableDDC = ppdev->ulEnableDDC[Head];
        InputInfo.ulEnableDDC = 1; // Hardcoded for now till control panel adds a button for this.

        InputInfo.pVirtualModeList = ppdev->VirtualModeList[Head];
        InputInfo.ulNumVirtualModes = ppdev->ulNumVirtualModes[Head];
        InputInfo.pPhysicalModeList = PhysModeList;

        // Call the IOCTL for the miniport to return the physical modes.
        ulRet = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST,
                                   (HEAD_MODE_LIST_INFO *)&InputInfo,
                                   sizeof(HEAD_MODE_LIST_INFO),
                                   NULL,
                                   0,
                                   &(ulRetSize));
        if (ulRet)
        {
            DISPDBG((0,"Oops! IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST failed!"));
            return(FALSE);
        }
        else
        {
            // Copy the number physical modes into ppdev. The modelist has already been copied into 
            // by the miniport.
            *NumPhysModes = ulRetSize / sizeof(MODE_ENTRY);
            if (*NumPhysModes == 0)
            {
                DISPDBG((0,"Number of physical modes for head: %d is 0",Head));
                return(FALSE);
            }
            return(TRUE);
        }

    } // NumPhysModes != NULL

    return(bRet);
} // end bGetPhysicalVirtualModeList()


//
// Prints the relevant pieces of TwinView related info from the ppdev
//
void PrintPPDEVTwinViewInfo (char *Msg, PPDEV ppdev)
{
    ULONG i;

    DISPDBG((1,".......%s......",Msg));
    DISPDBG((1,"DeskTopMode: 0x%x, NotSupportPanScan: 0x%x, PuntCursor: 0x%x, DacsOnBoard: 0x%x, DacsConnected: 0x%x, DacsActive: 0x%x",
        ppdev->ulDesktopMode, ppdev->ulDriverNotSupportPanScan, ppdev->ulPuntCursorToGDI, ppdev->ulNumberDacsOnBoard,
        ppdev->ulNumberDacsConnected,ppdev->ulNumberDacsActive));
    DISPDBG((1,"TwinViewState: 0x%x, Orientation: 0x%x, DisplayDX: 0x%x, DisplayDy: 0x%x, PrimarySurfOffset: 0x%x",
        ppdev->TwinView_State, ppdev->TwinView_Orientation, ppdev->ulMoveDisplayDx, ppdev->ulMoveDisplayDy,
        ppdev->ulPrimarySurfaceOffset));
    DISPDBG((1,"GDI Requested mode: (%d, %d) at %d bpp, at %d HZ",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cBitsPerPel, ppdev->ulGDIRefreshRate));
    DISPDBG((1,"Head Mapping: %d, %d",ppdev->ulDeviceDisplay[0], ppdev->ulDeviceDisplay[1]));
    DISPDBG((1,"HeadDeviceOptions: 0x%x, 0x%x",ppdev->ulHeadDeviceOptions[0], ppdev->ulHeadDeviceOptions[1]));
    DISPDBG((1,"AllDeviceMask: 0x%x\n",ppdev->ulAllDeviceMask));
    DISPDBG((1,"ConnectedDeviceMask: 0x%x\n",ppdev->ulConnectedDeviceMask));

    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        DISPDBG((1,"Head %d: DacStatus: 0x%x, NumPhysModes: 0x%x, NumVirtualModes: 0x%x, DeviceMask: 0x%x, DeviceType: 0x%x, TVFormat: 0x%x",
            i, ppdev->ulDacStatus[i], ppdev->ulNumPhysModes[i], ppdev->ulNumVirtualModes[i], ppdev->ulDeviceMask[i], ppdev->ulDeviceType[i],
            ppdev->ulTVFormat[i]));
        DISPDBG((1, "Virtual: (%d, %d), (%d, %d), Physical: (%d, %d), (%d, %d) at %d HZ",
            ppdev->rclDisplayDesktop[i].left, ppdev->rclDisplayDesktop[i].top,
            ppdev->rclDisplayDesktop[i].right,ppdev->rclDisplayDesktop[i].bottom,    
            ppdev->rclCurrentDisplay[i].left, ppdev->rclCurrentDisplay[i].top,
            ppdev->rclCurrentDisplay[i].right,ppdev->rclCurrentDisplay[i].bottom,    
            ppdev->ulRefreshRate[i]));

    }
    DISPDBG((1,"................................."));
}

//
// Prints the entire twinviewdata structure
//
void PrintTwinViewData (char *Msg, ULONG ulDebugLevel, NVTWINVIEWDATA *pData, PPDEV ppdev)
{
    ULONG i;

    DISPDBG((ulDebugLevel,"..........%s...........", Msg));
    DISPDBG((ulDebugLevel,"State: 0x%x, Orientation: 0x%x, DeskTopRectl: (%d, %d), (%d, %d), AllDeviceMask: 0x%x, ConnectedDevMask: 0x%x, Head Mapping: %d, %d",
        pData->dwState, pData->dwOrientation, pData->DeskTopRectl.left,pData->DeskTopRectl.top,pData->DeskTopRectl.right,
        pData->DeskTopRectl.bottom, pData->dwAllDeviceMask, pData->dwConnectedDeviceMask, pData->dwDeviceDisplay[0],pData->dwDeviceDisplay[1]));
    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        DISPDBG((ulDebugLevel,"Head %d:    DeviceMask: 0x%x, DeviceType: 0x%x, TVFormat: 0x%x, NumPhysModes: 0x%x, NumVirtualModes: 0x%x",
            i, pData->NVTWINVIEWUNION.nvtwdevdata[i].dwDeviceMask, pData->NVTWINVIEWUNION.nvtwdevdata[i].dwDeviceType, pData->NVTWINVIEWUNION.nvtwdevdata[i].dwTVFormat, 
            pData->NVTWINVIEWUNION.nvtwdevdata[i].dwNumPhysModes,pData->NVTWINVIEWUNION.nvtwdevdata[i].dwNumVirtualModes));
        DISPDBG((ulDebugLevel,"        Virtual: (%d, %d), (%d, %d), Physical: (%d, %d), (%d, %d)",
            pData->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl.left,pData->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl.top,
            pData->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl.right,pData->NVTWINVIEWUNION.nvtwdevdata[i].VirtualRectl.bottom,
            pData->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl.left,pData->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl.top,
            pData->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl.right,pData->NVTWINVIEWUNION.nvtwdevdata[i].PhysicalRectl.bottom));
        DISPDBG((ulDebugLevel,"        %d bpp, %d HZ",
            pData->NVTWINVIEWUNION.nvtwdevdata[i].dwBpp, pData->NVTWINVIEWUNION.nvtwdevdata[i].dwRefresh));
    }
    DISPDBG((ulDebugLevel,"........................"));
}

//
// Calls the miniport to do a device scaning.
// Then gets __only__ the updated device options matrix and stuffs it into the panel. 
// BUGBUG: Should I extract all the info? Think about it and talk to Terry. What happens if say the seconda\ry DFP
// is disconnected before inducing the scan? The mode has already been set.
//
void InduceAndUpdateDeviceScanning (PPDEV ppdev)
{
    ULONG  ReturnedDataLength;
    ULONG  i;
    GET_NUMBER_DACS   NumberDacs;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "Oops! DrvEnablePDEV - IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING failed"));
        return;
    }

    // Get the head info from the miniport such as number of heads on board, number of heads connected and device type of each head.
    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_GET_NUMBER_DACS,
                        NULL,
                        0,
                        &NumberDacs,
                        sizeof(NumberDacs),
                        &ReturnedDataLength))
    {
        DISPDBG((0, "Oops! InitMultiMon() - IOCTL_VIDEO_GET_NUMBER_DACS failed"));
        return;
    }
    else
    {
        // Fill the info into ppdev.
        // BUGBUG: Should I extract all the info? Think about it and talk to Terry. What happens if say the seconda\ry DFP
        // is disconnected before inducing the scan? The mode has already been set.
        ppdev->ulNumberDacsConnected = NumberDacs.ulNumberDacsConnected;
        ppdev->ulNumberDacsOnBoard = NumberDacs.ulNumberDacsOnBoard;
        ppdev->ulAllDeviceMask = NumberDacs.ulAllDeviceMask;
        ppdev->ulConnectedDeviceMask = NumberDacs.ulConnectedDeviceMask;
        DISPDBG((1,"NumDacsOnBoard: 0x%x, NumDacsConnected: 0x%x",ppdev->ulNumberDacsOnBoard,
                 ppdev->ulNumberDacsConnected));
        DISPDBG((1,"ulAllDeviceMask: 0x%x, ulConnectedDeviceMask: 0x%x",ppdev->ulAllDeviceMask,
                 ppdev->ulConnectedDeviceMask));
        for (i=0; i < NumberDacs.ulNumberDacsOnBoard; i++)
        {
            ppdev->ulHeadDeviceOptions[i] = NumberDacs.ulHeadDeviceOptions[i];
            DISPDBG((1,"Physical Head: %d, DeviceOptions: 0x%x",i,ppdev->ulHeadDeviceOptions[i]));
        }
    }

}

//
// Some of the flags in the TwinViewInfo structure are synchronous. i.e., they are read into the incore ppdev
// immediately rather than being read in at the modeset time. These synchronous flags are:
// - ulEnablePanScan
// - ulFreezePanScan
// - ulEnableDDC
//
void   ProcessSynchronousFlags(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG i;
    NVTWINVIEW_DEVICE_TYPE_DATA HeadData;
    ULONG PhysWidth, PhysHeight;
    ULONG ReturnedDataLength;

    for (i=0; i< NV_NO_DACS; i++)
    {
        HeadData = pData->NVTWINVIEWUNION.nvtwdevdata[i];
        ppdev->ulEnablePanScan[i] = HeadData.dwEnablePanScan;
        ppdev->ulEnableDDC[i] = HeadData.dwEnableDDC;
        ppdev->ulEnableDDC[i] = 1; // Hardcoded for now till control panel adds a button for this.
        ppdev->ulFreezePanScan[i] = HeadData.dwFreezePanScan;
        ppdev->ulTimingOverRide[i] = HeadData.dwTimingOverRide;

        if (HeadData.dwFreezePanScan == 0)   
        {
            DISPDBG((3, "Enabling PanScan for Head: %d",i));
            if (i == 0)
            {
                ppdev->ulDesktopMode |= NV_VIRTUAL_DESKTOP_1;
            }
            else
            {
                ppdev->ulDesktopMode |= NV_VIRTUAL_DESKTOP_2;
            }
    
        } 
        else if( ppdev->ulDesktopMode & (i ? NV_VIRTUAL_DESKTOP_2 : NV_VIRTUAL_DESKTOP_1))
        {
            DISPDBG((3, "Disabling PanScan for Head: %d",i));

            //
            // Write the desired freeze location into ppdev.
            //
            ppdev->ulFreezeOriginX[i] = HeadData.dwFreezeOriginX;
            ppdev->ulFreezeOriginY[i] = HeadData.dwFreezeOriginY;
            //
            // Update the physical rectangle.
            //
            PhysWidth = ppdev->rclCurrentDisplay[i].right - ppdev->rclCurrentDisplay[i].left;
            PhysHeight = ppdev->rclCurrentDisplay[i].bottom - ppdev->rclCurrentDisplay[i].top;
            ppdev->rclCurrentDisplay[i].left = HeadData.dwFreezeOriginX;
            ppdev->rclCurrentDisplay[i].top = HeadData.dwFreezeOriginY;
            ppdev->rclCurrentDisplay[i].right = ppdev->rclCurrentDisplay[i].left + PhysWidth;
            ppdev->rclCurrentDisplay[i].bottom = ppdev->rclCurrentDisplay[i].top + PhysHeight;
            //
            // Move the pointer (and the scanout area) to the desired origin if we are not in software cursor mode.
            //
            if (ppdev->ulDriverNotSupportPanScan == FALSE)
            {
                NVMovePointer(ppdev, HeadData.dwFreezeOriginX, HeadData.dwFreezeOriginY);
            }
            //
            // Now turn off the virtual desktop flags to disable pan-scan in the pointer routines.
            //
            if (i == 0)
            {
                ppdev->ulDesktopMode &= ~(NV_VIRTUAL_DESKTOP_1);
            }
            else
            {
                ppdev->ulDesktopMode &= ~(NV_VIRTUAL_DESKTOP_2);
            }
        }
    } // for each dac

    // Get the timing override to take effect immediately.
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "Oops! DrvEnablePDEV - IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE failed"));
        return;
    }

}


//
// Does a one time building of mode lists. Should be called only from InitMultiMon().
//
BOOL BuildModeLists(PPDEV ppdev)
{
    PVIDEO_MODE_INFORMATION pVideoModeInformation, SrcPtr;
    DWORD                   cbModeSize;
    ULONG cModes;
    ULONG i, j;
    MODE_ENTRY *ModeListPtr;
    ULONG ReturnedDataLength;
    ULONG ulHead;
    DWORD cNumGDIModes;
    
   
    // Now construc the per-head virtual and physical mode lists.
    // The modes returned by getAvailableModes() will have all of the single,horizontal and vertical modes.
    cModes = getAvailableModes(ppdev->hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize, &cNumGDIModes);

    if (cModes == 0 || cNumGDIModes == 0)
    {
        // Something wrong. There were no valid modes.
        DISPDBG((0, "BuildModeLists(): error. Invalid cModes: %d, cNumGDIModes: %d",cModes, cNumGDIModes));
        // free up any previously alloced memory. This can happen if BuildModeLists() is called twice in a row.
        FreeMemoryMultiMon(ppdev);
        return(FALSE);
    }
    

    // free up any previously alloced memory. This can happen if BuildModeLists() is called twice in a row.
    FreeMemoryMultiMon(ppdev);


    //
    // Create the single screen virtual mode lists for both heads
    // Note that we need to create virtual mode lists for _both_ heads since this list is not
    // EDID-specific. However, we need to compute the physical mode list for the active heads only.
    //
    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        // Read the virtual single head modes into the VirtualModeList.
        ppdev->VirtualModeList[ulHead] = EngAllocMem(FL_ZERO_MEMORY,
                                   cModes * sizeof(MODE_ENTRY),
                                   ALLOC_TAG);
        if (ppdev->VirtualModeList[ulHead] == NULL)
        {
            DISPDBG((0, "Oops! InitMultiMon(): EngAllocMEm failed!\n"));
            //
            // free up any memory we might have alloced in the loop before this failure.
            //
            FreeMemoryMultiMon(ppdev);
            return(FALSE);
        }

        ppdev->ulNumVirtualModes[ulHead] = 0;
        ModeListPtr = ppdev->VirtualModeList[ulHead];
        SrcPtr = pVideoModeInformation;
        for (j=0; j < cModes; j++) 
        {
            // We select only the single screen virtual modes because thats what the panel wants.
            if (MULTIMON_MODE(SrcPtr->VisScreenWidth, SrcPtr->VisScreenHeight)) 
            {
                SrcPtr++;
                continue;
            }
            ModeListPtr->ValidMode = 1;
            ModeListPtr->Width = (USHORT)SrcPtr->VisScreenWidth;
            ModeListPtr->Height = (USHORT)SrcPtr->VisScreenHeight;
            ModeListPtr->Depth = (USHORT) (SrcPtr->BitsPerPlane * SrcPtr->NumberOfPlanes);
            ModeListPtr->RefreshRate = (USHORT)SrcPtr->Frequency;
            ppdev->ulNumVirtualModes[ulHead]++;
            ModeListPtr++;
            SrcPtr++;
        }
    } // for

    // Create the Physical mode lists for the active heads.
    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        ppdev->PhysModeList[i] = EngAllocMem(FL_ZERO_MEMORY,
                                   cModes * sizeof(MODE_ENTRY),
                                   ALLOC_TAG);
        if (ppdev->PhysModeList[i] == NULL)
        {
            DISPDBG((0, "Oops! InitMultiMon(): EngAllocMEm failed!\n"));
            //
            // free up any memory we might have alloced in the loop before this failure.
            //
            FreeMemoryMultiMon(ppdev);
            return(FALSE);
        }
        ppdev->ulNumPhysModes[i] = 0;
    }

    for (i=0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        // Get the physical mode info for this head and the current device.
        if (!bGetPhysicalVirtualModeList(ppdev, ulHead, 
                                    ppdev->ulDeviceMask[ulHead],
                                    ppdev->ulDeviceType[ulHead],
                                    ppdev->ulTVFormat[ulHead],
                                    ppdev->PhysModeList[ulHead],
                                    NULL,
                                    &ppdev->ulNumPhysModes[ulHead],
                                    NULL))
        {
            //  Ganesh
            //  This is not an error if the head is the unused head in a standard mode.
            
            if(ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL && ppdev->ulDeviceDisplay[0] != i)
            {
                //  Benign error since nobody will be using this head info.
                //  Do not print any warning message also.

                continue;
            }

            DISPDBG((0,"InitMultiMon(): oops! bGetPhysicalVirtualModeList() failed for head: %d, devMask: 0x%x, devType: 0x%x, TVFormat: 0x%x",
                i, ppdev->ulDeviceMask[i], ppdev->ulDeviceType[i], ppdev->ulTVFormat[i]));

            return(FALSE);
        }
    } // for

    
   // Free the modelist memory alloced by getAvailableModes()
    EngFreeMem(pVideoModeInformation);

    return(TRUE);
}


//
// Does a sanity check of the device masks specified in the registry data. If they are not sane, returns FALSE.
// else returns TRUE. No state is changed.
//
ULONG ValidateRegistryDeviceMasks(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG i;
    ULONG ulDevices, ulHead;
    ULONG ulNumDacsActive;
    ULONG ulWidth, ulHeight;

    if (pData->dwAllDeviceMask != ppdev->ulAllDeviceMask)
    {
        DISPDBG((0,"Oops! Mismatch in AllDeviceMask, ppdev: 0x%x, RegData: 0x%x",
                 ppdev->ulAllDeviceMask,pData->dwAllDeviceMask));
        return(FALSE);
    }

    // Initialize the number of active dacs, to keep the compiler happy.
    ulNumDacsActive = 1;

    switch (pData->dwState)
    {
        case NVTWINVIEW_STATE_NORMAL:
        case NVTWINVIEW_STATE_DUALVIEW:
            ulHead = pData->dwDeviceDisplay[0];
            ulDevices = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
            ulNumDacsActive = 1;
            break;
        case NVTWINVIEW_STATE_CLONE:
            ulNumDacsActive = 2;
            ulDevices = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask |
                        pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
            break;
        case NVTWINVIEW_STATE_SPAN:
            ulDevices = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask |
                        pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
            ulWidth = pData->DeskTopRectl.right - pData->DeskTopRectl.left;
            ulHeight = pData->DeskTopRectl.bottom - pData->DeskTopRectl.top;
            if (MULTIMON_MODE(ulWidth, ulHeight))
            {
                ulNumDacsActive = 2;
            }
            else
            {
                if( ulWidth != 480 && ulHeight != 360 &&
                    ulWidth <= 640 && ulHeight <= 480)
                {
                     //
                     // These are the special single resolution modes allowed in spanning mode
                     // in order to support DDraw, low resolutions.
                     // 
                     ulNumDacsActive = 1;
                }
                else
                {
                // Also export low resolution for spanning mode for DirectDraw
                    if ((ulWidth == 640 && ulHeight == 480) ||
                        (ulWidth == 800 && ulHeight == 600) ||
                        (ulWidth == 1024 && ulHeight == 768))
                    {
                        //
                        // These are the special single resolution modes allowed in spanning mode.
                        //
                        ulNumDacsActive = 1;
                    }
                    else
                    {
                        DISPDBG((0, "Invalid resolution specified in the registry for spanning mode: %d, %d", ulWidth, ulHeight));
                        return(FALSE);
                    }
                }
            }
            break;
        default:
            DISPDBG((0, "Invalid State in pData\n"));
            return(FALSE);
    }

    if (pData->dwConnectedDeviceMask != ppdev->ulConnectedDeviceMask)
    {
        DISPDBG((0,"Oops! Mismatch in ConnectedDeviceMask, ppdev: 0x%x, RegData: 0x%x",
                 ppdev->ulConnectedDeviceMask,pData->dwConnectedDeviceMask));
        //
        // Before flagging error, see if the currently chosen devices are still valid. If so, some device
        // which was not being used anyway was removed. This is a benign condition so no need to flag an error.
        //
        if ((ulDevices & ppdev->ulConnectedDeviceMask) == ulDevices)
        {
            //
            // All active devices are still connected, so this is a benign condition and hence don't 
            // flag an error
            //
            return(TRUE);
        }
        else
        {
            //
            // An active device has been removed and hence we have to flag an error.
            //
            return(FALSE);
        }
    }

    // Check if the specified per-head devices are correct.
    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
    {
        ulHead = pData->dwDeviceDisplay[i];
        if (!(pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask & ppdev->ulConnectedDeviceMask))
        {
            DISPDBG((0,"Oops! Head: %d, Invalid Registry Device mask for head: 0x%x, ConnectedMask: 0x%x",
                             ulHead, pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask,ppdev->ulConnectedDeviceMask));
        }
    }
    return(TRUE);
}

//
// Copies the device mask, twinview_state and initializes ulNumberDacsActive from the TwinViewInfo into
// the ppdev. These values are needed to build physical mode lists for the new configuration requested
// by the TwinViewInfo structure.
// Note: Before calling this function, the ValidateRegistryDeviceMasks() should have been successfully called
// to make sure the specified device masks are valid.
//
VOID InitDevMaskFromTwinViewInfo(PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG i;
    ULONG ulHead;
    MODE_ENTRY RequestedMode, BestFitMode;
    ULONG SuggestedDeviceMask, SuggestedDeviceType, SuggestedTVType;
    ULONG ulPrimaryHead;

    //
    // Safety check. Should never happen.
    //
    if (pData == NULL)
    {
        DISPDBG((0, "InitDevMaskFromTwinViewInfo(): NULL pointer for TwinViewInfo"));
        return;
    }

    ppdev->TwinView_State = pData->dwState;
    ppdev->TwinView_Orientation = pData->dwOrientation;
    ppdev->ulNumberDacsActive = GetNumberDacsActiveFromTwinViewInfo(pData);

    for (i=0; i < NV_NO_DACS; i++)
    {
        //
        // Get the physical head ==> logical head mapping.
        //
        ppdev->ulDeviceDisplay[i] = pData->dwDeviceDisplay[i];
    }


    //
    // Copy the device mask
    //
    for (i=0; i<ppdev->ulNumberDacsOnBoard; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        ppdev->ulDeviceMask[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
        ppdev->ulDeviceType[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceType;
        ppdev->ulTVFormat[ulHead] = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTVFormat;
    }
}


//
// Input: bitmask for a single device
// Return: device type of this device.
//
ULONG MaskToDeviceType( PPDEV ppdev, ULONG ulDeviceMask)
{
    ULONG ulRet;

    if (ulDeviceMask & BITMASK_ALL_CRT) ulRet = MONITOR_TYPE_VGA; 
    else 
    if (ulDeviceMask & BITMASK_ALL_DFP) ulRet = MONITOR_TYPE_FLAT_PANEL;
    else 
    if (ulDeviceMask & BITMASK_ALL_TV)
    {
        ulRet = ppdev->ulDefaultTVDeviceType;
    }
    else ulRet = INVALID_DEVICE_TYPE;

    return(ulRet);
}


//
// If the system is a desktop, this routine does nothing.
// If the system is a laptop, we should use the output deive posted by the BIOS for the desktop.
// BUGBUG: Currently this function only handles a single output device posted by the BIOS.
// The code does not yet support when the BIOS posts to two devices (sort of BIOS clone mode).
// Returns: TRUE if the config matches with the BIOS heads.
// FALSE if the config differs and the diff has been handled.
//
ULONG HandleBIOSHeads(PPDEV ppdev)
{

    ULONG ulHead;
    ULONG Status, RetSize;
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;
    ULONG ulCombinedDeviceMask;
    ULONG ulDeviceMask;
    ULONG DeviceMask[NV_NO_DACS];
    ULONG i, status;
    ULONG ReturnedDataLength;
    ULONG ulBIOSDeviceMask;
    
    
    if (Status = NvConfigGet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                                  NV_CFG_GET_BOOT_DEVICES, &ulBIOSDeviceMask))
        {
            DISPDBG((0,"Oops!    NV_CFG_GET_BOOT_DEVICES failed"));
        }

    DISPDBG((1,"Disp: HandleBIOSHeads(): BIOSDeviceMask: 0x%x",ulBIOSDeviceMask));

    //
    // This case should not happen but just a safety check.
    // When we are in multimon mode, allow BOOT_HEADS only if the NVSVC service has started
    //
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_SPAN)
    {
        if (ppdev->ulNVSVCStatus != NVSVC_STATUS_STARTED)
        {
            return(TRUE);
        }
    }

    
    if (ppdev->UseHWSelectedDevice)
    {
        
        //
        // We don't compare BOOT_HEADS if we are explicitly being called by the NVPanel
        //
        if (GetInitiatedRegValue(ppdev) == 1)
        {
            return(TRUE);
        }

        // see if the BIOS had posted on a single device or two devices.
        if (ConvertConnectedMaskToNumDevices(ulBIOSDeviceMask) == 1)
        {
            // BIOS posted on a single device.

            // Check for the cases when we have to do nothing, i.e. windows is in sync with BIOS.
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL || ppdev->TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
            {
                ulHead = ppdev->ulDeviceDisplay[0];
                if (ppdev->ulDeviceMask[ulHead] == ulBIOSDeviceMask)
                {
                    return(TRUE);
                }
            }


            //
            // Invoke NVSVC to do the modeset and return, provided NVSVC service has started.
            //
            if (ppdev->ulNVSVCStatus == NVSVC_STATUS_STARTED)
            {
                ppdev->ulInduceModeChangeDeviceMask = ulBIOSDeviceMask;
                if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SIGNAL_NVSVC_MODESET_EVENT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &ReturnedDataLength))
                {
                    DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_EVENT failed"));
                }   
                if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK,
                        &ppdev->ulInduceModeChangeDeviceMask,
                        sizeof(ULONG),
                        NULL,
                        0,
                        &ReturnedDataLength))
                {
                    DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_DEVMASK failed"));
                }   

                return(TRUE);
            }

            //
            // Since NVSVC has not started, we need to do the device switch ourselves
            // If we are in standard or clone mode, make sure we use this device.
            // We don't handle spanning modes yet.
            //
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL ||
                ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE)
            {
                // Ask ResMan for which head to use.
                // Ask ResMan what head to use.
                ppdev->TwinView_State = NVTWINVIEW_STATE_NORMAL;

                nvConfig.DevicesConfig = ulBIOSDeviceMask;
                nvConfig.OldDevicesConfig = 0;
                nvConfig.OldDevicesAllocationMap = 0;
                nvConfig.DevicesAllocationMap = 0;
                if (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                                   NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
                {

                    DISPDBG((0, "HandleBIOSHeads - Cannot get DEVICES_CONFIG value from RM"));
                }
                else
                {
                    if (nvConfig.DevicesAllocationMap > 1)
                    {
                        DISPDBG((0,"Oops! Invalid DevAllocationMap from RM: 0x%x",nvConfig.DevicesAllocationMap));
                    }
                    if (nvConfig.DevicesAllocationMap == 0)
                    {
                        ppdev->ulDeviceMask[0] = ulBIOSDeviceMask;
                        ppdev->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                        ppdev->ulDeviceDisplay[0] = 0;
                        ppdev->ulDeviceDisplay[1] = 1;
                    }
                    if (nvConfig.DevicesAllocationMap == 1)
                    {
                        ppdev->ulDeviceMask[1] = ulBIOSDeviceMask;
                        ppdev->ulDeviceMask[0] = BITMASK_INVALID_DEVICE;
                        ppdev->ulDeviceDisplay[0] = 1;
                        ppdev->ulDeviceDisplay[1] = 0;
                    }
                }

                // Now fill in all the relevant info into the ppdev.
                ulHead = ppdev->ulDeviceDisplay[0];
                ulDeviceMask = ppdev->ulDeviceMask[ulHead];
                ppdev->ulDeviceType[ulHead] = MaskToDeviceType(ppdev, ulDeviceMask);
                ppdev->ulTVFormat[ulHead] = ppdev->ulDefaultTVFormat; 

                // The resolution (virtual and physical) for the head and desktop will be filled in by the
                // UseOnlyGDIForModeDEtails() which will be called later after HandleBiosHeads().

                // Configuration has changed. So return FALSE.
                return(FALSE);
            } // Normal or Clone
        } // BIOS on single device.

        if (ConvertConnectedMaskToNumDevices(ulBIOSDeviceMask) >= 2)
        {
            // BIOS posted on dual devices.

            // Check for the cases when we have to do nothing, i.e. windows is in sync with BIOS.
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE)
            {
                ulCombinedDeviceMask = ppdev->ulDeviceMask[0] | ppdev->ulDeviceMask[1];
                if (ulCombinedDeviceMask == ulBIOSDeviceMask)
                {
                    return(TRUE);
                }
            }


            //
            // Invoke NVSVC to do the modeset and return, provided NVSVC service has started.
            //
            if (ppdev->ulNVSVCStatus == NVSVC_STATUS_STARTED)
            {
                ppdev->ulInduceModeChangeDeviceMask = ulBIOSDeviceMask;
                if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_SIGNAL_NVSVC_MODESET_EVENT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &ReturnedDataLength))
                {
                    DISPDBG((1, "InitMultiMon() - IOCTL_VIDEO_SIGNAL_MODESET_EVENT failed"));
                }
                return(TRUE);
            }

            //
            // Since NVSVC has not started, we need to do the device switch ourselves.
            // If we are in standard or clone mode, make sure we use this device.
            // We don't handle spanning modes yet.
            //
            if (ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL ||
                ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE)
            {
                // Ask ResMan for which head to use.
                // Ask ResMan what head to use.
                ppdev->TwinView_State = NVTWINVIEW_STATE_CLONE;
                ppdev->ulNumberDacsActive =2;

                ppdev->ulDeviceDisplay[0] = 0;
                ppdev->ulDeviceDisplay[1] = 1;

                // Grab the first output device.
                for (i=0; i < NV_NO_CONNECTORS; i++)
                {
                    if (ulBIOSDeviceMask & (1 << i))
                    {
                        DeviceMask[0] = (1 << i);
                        i++;
                        break;
                    }
                }
                // Continue further and grab the next device.
                for (; i < NV_NO_CONNECTORS; i++)
                {
                    if (ulBIOSDeviceMask & (1 << i))
                    {
                        DeviceMask[1] = (1 << i);
                        break;
                    }
                }

                // Ask ResMan what head to use for the devices.
                nvConfig.DevicesConfig = DeviceMask[0] | DeviceMask[1];
                nvConfig.OldDevicesConfig = 0;
                nvConfig.OldDevicesAllocationMap = 0;
                nvConfig.DevicesAllocationMap = 0;
                status = NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                                NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS));
                if (status != 0)
                {

                    DISPDBG((0, "Oops! HandleBIOSHeads - Cannot get DEVICES_CONFIG value from RM"));
                    // Set to a safe single head mode.
                    ppdev->ulNumberDacsConnected = 1;
                    ppdev->ulConnectedDeviceMask = DeviceMask[0];
                    ppdev->ulAllDeviceMask = DeviceMask[0];
                    ppdev->ulDeviceMask[0] = DeviceMask[0];
                    ppdev->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                }
                else
                {
                    // We got a successful head assignment for both the devices.
                    switch (nvConfig.DevicesAllocationMap)
                    {
                    case 0x10:
                        // Head assignment 1, 0
                        ppdev->ulDeviceMask[0] = DeviceMask[0];
                        ppdev->ulDeviceMask[1] = DeviceMask[1];
                        break;

                    case 0x01:
                        // Head assignment 0, 1
                        ppdev->ulDeviceMask[0] = DeviceMask[1];
                        ppdev->ulDeviceMask[1] = DeviceMask[0];
                        break;

                    default:
                        DISPDBG((0,"Oops! Unexpected head allocationMap: 0x%x",  nvConfig.DevicesAllocationMap));
                        // Set to a safe single head mode.
                        ppdev->ulNumberDacsConnected = 1;
                        ppdev->ulConnectedDeviceMask = DeviceMask[0];
                        ppdev->ulAllDeviceMask = DeviceMask[0];
                        ppdev->ulDeviceMask[0] = DeviceMask[0];
                        ppdev->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                        break;
                    }

                    for (i=0; i < ppdev->ulNumberDacsOnBoard; i++)
                    {
                        //
                        // Convert the device mask to device type. 
                        //
                        ppdev->ulDeviceType[i] = MaskToDeviceType(ppdev, ppdev->ulDeviceMask[i]);
                        ppdev->ulTVFormat[ulHead] = ppdev->ulDefaultTVFormat;
                    }
                } // status != RM_OK

                // The resolution (virtual and physical) for the head and desktop will be filled in by the
                // UseOnlyGDIForModeDEtails() which will be called later after HandleBiosHeads().

                // Configuration has changed. So return FALSE.
                return(FALSE);
            } // Normal or Clone
        } // BIOS selected two devices.
    } // UseHwSelectedDevice
 
     return (TRUE);
}

//
// Returns the index from the device mask.
// Input: A 32bit bitmask with only one of the 32bits set specifying a unique device
// Return Value: Index of this bitmask
//      For example: 
//      input: 0x4, Return: 2
//      input: 0x20, Return: 5
//      input: 0x1, Return: 0
//      input: 0x0, Return: 0
//
ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask)
{
    ULONG i;
    ULONG ulTmp;
    ulTmp = ulDeviceMask;

  
    i=0;
    for (;;)
    {
        if (ulTmp == 0)
        {
            DISPDBG((1,"Oops! ConvertDeviceMaskToIndex(): Invalid ulDeviceMask: 0x%x\n",ulDeviceMask));
            return(0);
        }
        if (ulTmp & 0x1)
        {
            return(i);
        }
        // shift right by one and increment the index
        ulTmp >>= 1;
        i++;
    }
}

//
// Returns the number of bits that are set in the mask.
// 
ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask)
{
    ULONG i, NumDevices, ulDeviceMask;
    NumDevices = 0;
    for(i=0; i < NV_NO_CONNECTORS; i++)
    {
        ulDeviceMask = (1 << i);
        if(ulConnectedDeviceMask & ulDeviceMask)
        {
            NumDevices++;
        }
    }
    return(NumDevices);

}

//
// Reads the ToshibaHotKeyMode registry entry.
//
VOID ReadToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode)
{
    char * KeyName = "ForceGDIMode";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_REGISTRY_STRUCT regStructInput;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStructInput.keyName = (PWSTR)KeyNameUniCode;
    regStructInput.keyVal = pMode;
    regStructInput.keyValSize = sizeof(TOSHIBA_HOTKEY_MODE);

    Status = EngDeviceIoControl(hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                                (LPVOID)&regStructInput,
                                sizeof(NV_REGISTRY_STRUCT),
                                (LPVOID) (pMode),
                                sizeof(TOSHIBA_HOTKEY_MODE),
                                &(returnedDataLen));

    DISPDBG((1,"KeyValSize returned from miniport: 0x%x",returnedDataLen));
}

//
// Writes the ToshibaHotKeyMode registry entry
//
VOID WriteToshibaHotKeyMode(HANDLE      hDriver, TOSHIBA_HOTKEY_MODE *pMode)
{
    char * KeyName = "ForceGDIMode";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_REGISTRY_STRUCT regStruct;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = pMode;
    regStruct.keyValSize = sizeof(TOSHIBA_HOTKEY_MODE);

    Status = EngDeviceIoControl(hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
}

//
// if pData is non-NULL, writes the pData as is to the registry.
// if pData is NULL, then constructs the TwinViewInfo from ppdev information and writes to the registry.
//
VOID WriteRegistryTwinViewInfo (PPDEV ppdev, NVTWINVIEWDATA *pData)
{
    ULONG returnedDataLength;
    NVTWINVIEWDATA sData;
    ULONG i;
    NVTWINVIEW_DEVICE_TYPE_DATA * pHeadData;

    if (pData)
    {
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_TWINVIEW_STATE,
                               pData,
                               sizeof(NVTWINVIEWDATA),
                               NULL,
                               0,
                               &returnedDataLength))
        {
            DISPDBG((0, "WriteRegistryTwinViewInfo pData: - IOCTL_VIDEO_SET_TWINVIEW_STATE failed"));
        }
        return;
    }

    // Zero the memory.
    memset(&sData, 0, sizeof(NVTWINVIEWDATA));

    // We need to costruct the TwinViewData from the ppdev info.
    // Set the desktop resolution.
    sData.DeskTopRectl.left = 0;
    sData.DeskTopRectl.top = 0;
    sData.DeskTopRectl.right = ppdev->cxScreen;
    sData.DeskTopRectl.bottom = ppdev->cyScreen;

    sData.dwState = ppdev->TwinView_State;
    sData.dwOrientation = ppdev->TwinView_Orientation;
    sData.dwAllDeviceMask = ppdev->ulAllDeviceMask;
    sData.dwConnectedDeviceMask = ppdev->ulConnectedDeviceMask;


    for (i=0; i < NV_NO_DACS; i++)
    {
        sData.dwDeviceDisplay[i] = ppdev->ulDeviceDisplay[i];

        pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);

        pHeadData->dwDeviceMask = ppdev->ulDeviceMask[i];
        pHeadData->dwDeviceType = ppdev->ulDeviceType[i];
        pHeadData->dwTVFormat = ppdev->ulTVFormat[i];

        pHeadData->dwBpp = ppdev->cBitsPerPel;
        pHeadData->dwRefresh = ppdev->ulRefreshRate[i];
        pHeadData->VirtualRectl.left = ppdev->rclDisplayDesktop[i].left;
        pHeadData->VirtualRectl.top = ppdev->rclDisplayDesktop[i].top;
        pHeadData->VirtualRectl.right = ppdev->rclDisplayDesktop[i].right;
        pHeadData->VirtualRectl.bottom = ppdev->rclDisplayDesktop[i].bottom;
        pHeadData->PhysicalRectl.left = ppdev->rclCurrentDisplay[i].left;
        pHeadData->PhysicalRectl.top = ppdev->rclCurrentDisplay[i].top;
        pHeadData->PhysicalRectl.right = ppdev->rclCurrentDisplay[i].right;
        pHeadData->PhysicalRectl.bottom = ppdev->rclCurrentDisplay[i].bottom;

        pHeadData->dwNumPhysModes = ppdev->ulNumPhysModes[i];
        pHeadData->dwNumVirtualModes = ppdev->ulNumVirtualModes[i];

        pHeadData->dwEnableDDC = ppdev->ulEnableDDC[i];
        pHeadData->dwEnablePanScan = ppdev->ulEnablePanScan[i];
        pHeadData->dwFreezePanScan = ppdev->ulFreezePanScan[i];
        pHeadData->dwFreezeOriginX = ppdev->ulFreezeOriginX[i];
        pHeadData->dwFreezeOriginY = ppdev->ulFreezeOriginY[i];
        pHeadData->dwTimingOverRide = ppdev->ulTimingOverRide[i];
    }

    //
    // Now write the structure to the registry.
    //
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_TWINVIEW_STATE,
                           &sData,
                           sizeof(NVTWINVIEWDATA),
                           NULL,
                           0,
                           &returnedDataLength))
    {
        DISPDBG((0, "WriteRegistryTwinViewInfo sData: - IOCTL_VIDEO_SET_TWINVIEW_STATE failed"));
    }
    return;
}



// Read a (named) reg key through IOCTL call (through miniport) (DeviceIO Wrapper)
//
// (see dspioctl.h for NV_REG_STRUCT )


void GetRegValueW(
                     HANDLE  hDriver,            // Handle to our phys device
                     PWSTR   keyName,            // Unicode name of the key     : IN
                     PVOID   keyData,            // Ptr to the data of the key  : OUT (IN not used in the IOCTL )
                     ULONG   keyDataSize)        // The sizeof(data) of the key : IN
{
    NV_REGISTRY_STRUCT regStruct;
    ULONG              IOCTLRetDataLen;     // not used
    ULONG              status;

    regStruct.keyName    = keyName;
    regStruct.keyVal     = keyData;
    regStruct.keyValSize = keyDataSize;

    status = EngDeviceIoControl(hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                                
                                (LPVOID)&regStruct,           // only the keyname and datasize is used
                                                              // 
                                sizeof(NV_REGISTRY_STRUCT),
                                
                                (LPVOID) keyData,             // only *keyData is written
                                keyDataSize,                  //
                                                              // NOTE: For this particular IOCTL (see NV.C),
                                                              // the return buffer is used for the reg key data
                                                              // itself

                                
                                &(IOCTLRetDataLen));

} // ...GetRegValueW()


//
// Writes a (named) reg key through IOCTL call (through miniport) (DeviceIO Wrapper)
//

void SetRegValueW(
                      HANDLE  hDriver,            // Handle to our phys device
                      PWSTR   keyName,            // Unicode name of the key     : IN
                      PVOID   keyData,            // The data of the key         : IN
                      ULONG   keyDataSize)        // The sizeof(data) of the key : IN
{
    NV_REGISTRY_STRUCT regStruct;
    ULONG              IOCTLRetDataLen;     // not used
    ULONG              status;

    regStruct.keyName    = keyName;
    regStruct.keyVal     = keyData;
    regStruct.keyValSize = keyDataSize;

    status = EngDeviceIoControl(hDriver,
                                IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                
                                (LPVOID)&regStruct,    
                                                       
                                sizeof(NV_REGISTRY_STRUCT),
                                
                                NULL,
                                0,
                                
                                &(IOCTLRetDataLen));

} // ...SetRegValueW()



//
// Reads the registry entry "Key Name".
// Returns TRUE if this entry exists and the value is returned in pulData.
// Returns FALSE if this registry entry is absent and pulData is not modified.
//
BOOLEAN GetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG *pulData)
{
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG RetSize = 0;
    
    KeyNameLen = strlen(pcKeyName) + 1;


    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)pcKeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)pulData,
                                sizeof(ULONG),
                                &RetSize);
    if (Status == 0)
    {
        //
        // The call succeeded
        //
        DISPDBG((1,"Disp: GetULONGRegValue(): RegKey: %s, Value: 0x%x",pcKeyName, *pulData));
        return(TRUE);

    }
    else
    {    
        //
        // The call failed.
        //
        DISPDBG((1,"Disp: GetULONGRegValue(): RegKey: %s, Does not exist. Error status: 0x%x",pcKeyName, Status));
        return(FALSE);
    }
}

//
// Sets the registry key "pcKeyName" with the ulong value in pulData.
// Creates the registry entry if it does not exist.
//
VOID SetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG ulData)
{
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    NV_REGISTRY_STRUCT regStruct;
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG returnedDataLen = 0;

    KeyNameLen = strlen(pcKeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)pcKeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = &ulData;
    regStruct.keyValSize = sizeof(ULONG);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
    return;
}

//
// Reads the ModeSetInitiated registry entry.
// Returns 1 if this entry exists and has a non-zero value.
// Returns 0 if this registry entry is absent or is present with a value of 0.
//
ULONG GetInitiatedRegValue(PPDEV ppdev)
{
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG ModeSetInitiated;
    ULONG Status;
    ULONG RetSize;
    
    // Read the registry entry "NvCplInduceModeSetInitiated".
    ModeSetInitiated = 0;
    KeyName = "NvCplInduceModeSetInitiated";
    KeyNameLen = strlen(KeyName) + 1;

    ModeSetInitiated = 0;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)&ModeSetInitiated,
                                sizeof(ULONG),
                                &RetSize);
    DISPDBG((1,"Disp: GetInitiatedRegValue(): ModeSetInitiated registry value: 0x%x",ModeSetInitiated));
    return(ModeSetInitiated);

}

//
// Sets the ModeSetInitiated registry entry to 'ulVal'.
// Creates the registry entry if it does not exist.
//
VOID SetInitiatedRegValue(PPDEV ppdev, ULONG ulVal)
{
    char * KeyName = "NvCplInduceModeSetInitiated";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    NV_REGISTRY_STRUCT regStruct;
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = &ulVal;
    regStruct.keyValSize = sizeof(ULONG);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
    return;
}

//
// Reads the ResumingFromAdapterPowerDownState registry entry.
// Returns 1 if this entry exists and has a non-zero value.
// Returns 0 if this registry entry is absent or is present with a value of 0.
//
ULONG GetPowerStateRegValue(PPDEV ppdev)
{
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG ResumingFromAdapterPowerDownState;
    ULONG Status;
    ULONG RetSize;
    
    // Read the registry entry "ResumingFromAdapterPowerDownState".
    ResumingFromAdapterPowerDownState = 0;
    KeyName = "ResumingFromAdapterPowerDownState";
    KeyNameLen = strlen(KeyName) + 1;

    ResumingFromAdapterPowerDownState = 0;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)&ResumingFromAdapterPowerDownState,
                                sizeof(ULONG),
                                &RetSize);
    DISPDBG((1,"Disp: GetPowerStateRegValue(): ResumingFromAdapterPowerDownState registry value: 0x%x",ResumingFromAdapterPowerDownState));
    
    return(ResumingFromAdapterPowerDownState);

}

//
// Sets the ResumingFromAdapterPowerDownState registry entry to 'ulVal'.
// Creates the registry entry if it does not exist.
//
VOID SetPowerStateRegValue(PPDEV ppdev, ULONG ulVal)
{
    char * KeyName = "ResumingFromAdapterPowerDownState";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    NV_REGISTRY_STRUCT regStruct;
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = &ulVal;
    regStruct.keyValSize = sizeof(ULONG);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
    return;
}

//
// Reads the PrevDevMask registry entry.
// Returns the non-zero value if this entry exists and has a non-zero value.
// Returns 0 if this registry entry is absent or is present with a value of 0.
//
ULONG GetPrevDevMaskRegValue(PPDEV ppdev)
{
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG PrevDevMask;
    ULONG Status;
    ULONG RetSize;
    
    // Read the registry entry "PrevDevMask".
    PrevDevMask = 0;
    KeyName = "PrevDevMask";
    KeyNameLen = strlen(KeyName) + 1;

    PrevDevMask = 0;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)&PrevDevMask,
                                sizeof(ULONG),
                                &RetSize);
    DISPDBG((1,"Disp: GetPrevDevMaskRegValue(): PrevDevMask registry value: 0x%x",PrevDevMask));
    
    return(PrevDevMask);

}

//
// Sets the PrevDevMask registry entry to 'ulVal'.
// Creates the registry entry if it does not exist.
//
VOID SetPrevDevMaskRegValue(PPDEV ppdev, ULONG ulVal)
{
    char * KeyName = "PrevDevMask";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    NV_REGISTRY_STRUCT regStruct;
    ULONG KeyNameUniCodeLen;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = &ulVal;
    regStruct.keyValSize = sizeof(ULONG);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
    return;
}




#if DBG
//
// Reads the "nvDispDebugLevel" registry entry.
// If it exists, then sets this value to the global DebugLevel variable.
//
VOID GetDebugLevelRegValue(PPDEV ppdev)
{
    char * KeyName;
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    ULONG ulVal;
    ULONG Status;
    ULONG RetSize;

    //
    // We should not override the DebugLevel value that might have been set, say by a developer by hand.
    // If there is no "nvDispDebugLevel" override, we will simply restore the original DebugLevel value.
    //
    ulVal = DebugLevel;

    //
    // Read the registry entry "nvDispDebugLevel".
    //
    KeyName = "nvDispDebugLevel";
    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                (LPVOID)KeyNameUniCode,
                                KeyNameUniCodeLen,
                                (LPVOID)&ulVal,
                                sizeof(ULONG),
                                &RetSize);
    DISPDBG((1,"Disp: nvDispDebugLevel(): nvDispDebugLevel registry value: 0x%x",ulVal));
    
    DebugLevel = ulVal;
}
#endif DBG

//
// Reads in the latest and correct TV format the driver should use for a default value and caches in the ppdev.
// Note: Currently keeps track of a single TV format since all our cards currently have only one TV encoder but
// in the future we may have cards with say two TV encoders. Then we would have to keep track of TV format per
// TV encoder (or per TV device mask).
//
void GetDefaultTVFormat(PPDEV ppdev)
{
    ULONG Status;
    NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS Params;

    ppdev->ulDefaultTVFormat = 0;
    Params.DevicesConfig = TV_ENCODER_0;
    Params.TVStandard = 0;
    
    if (Status = NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                          NV_CFGEX_GET_VIDEO_TV_STANDARD, &Params, sizeof(NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS)))
    {
        DISPDBG((0,"Oops!    NV_CFGEX_GET_VIDEO_TV_STANDARD failed"));
    }

    ppdev->ulDefaultTVFormat = Params.TVStandard;

    DISPDBG((1,"Disp: GetDefaultTVFormat(): ulDefaultTVFormat: 0x%x",ppdev->ulDefaultTVFormat));
    ppdev->ulDefaultTVDeviceType = TVFormatToTVDeviceType(ppdev->ulDefaultTVFormat);
    DISPDBG((1,"Disp: GetDefaultTVFormat(): ulDefaultTVDeviceType: 0x%x",ppdev->ulDefaultTVDeviceType));
}

//
// Converts a TV FOrmat to the appropriate tV deviceType.
//
ULONG TVFormatToTVDeviceType(ULONG ulTVFormat)
{
    ULONG ulDeviceType;
    switch (ulTVFormat)
    {
    case NTSC_M:
    case NTSC_J:
        ulDeviceType = MONITOR_TYPE_NTSC;
        break;
    case PAL_M:
    case PAL_A:
    case PAL_N:
    case PAL_NC:
        ulDeviceType = MONITOR_TYPE_PAL;
        break;
    default:
        ulDeviceType = MONITOR_TYPE_NTSC;
        break;
    }
    return(ulDeviceType);
}

BOOLEAN ConvertHeadResToTiming(PPDEV ppdev,
                               ULONG ulHead,
                               HEAD_RESOLUTION_INFO *pHeadResolution,
                               NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS *pParam)
{
    ULONG             ReturnedDataLength;
    DAC_TIMING_VALUES sTimingDac;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_TIMING_DAC,
                           pHeadResolution,  // input buffer
                           sizeof(HEAD_RESOLUTION_INFO),
                           &sTimingDac,
                           sizeof(DAC_TIMING_VALUES),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "HandleBandWidth_SingleDacActive() - IOCTL_VIDEO_GET_TIMING_DAC failed"));
        return FALSE;
    }

    //
    // Sanity check. Make sure we got the requested timings. This should not happen.
    //
    if (sTimingDac.HorizontalVisible != pHeadResolution->ulDisplayWidth || 
        sTimingDac.VerticalVisible != pHeadResolution->ulDisplayHeight ||
        sTimingDac.Refresh != pHeadResolution->ulDisplayRefresh)
    {
        return FALSE;
    }

    if (ulHead == 0)
    {
        pParam->TotalWidth0 = sTimingDac.HorizontalTotal;
        pParam->VisibleWidth0 = sTimingDac.HorizontalVisible;
        pParam->TotalHeight0 = sTimingDac.VerticalTotal;
        pParam->VisibleHeight0 = sTimingDac.VerticalVisible;
        pParam->PixelDepth0 = ppdev->cBitsPerPel;
        pParam->PixelClock0 = sTimingDac.PixelClock;
    }
    else
    {
        pParam->TotalWidth1 = sTimingDac.HorizontalTotal;
        pParam->VisibleWidth1 = sTimingDac.HorizontalVisible;
        pParam->TotalHeight1 = sTimingDac.VerticalTotal;
        pParam->VisibleHeight1 = sTimingDac.VerticalVisible;
        pParam->PixelDepth1 = ppdev->cBitsPerPel;
        pParam->PixelClock1 = sTimingDac.PixelClock;
    }

    return TRUE;
}

//
// Verifies that the physical modes can be supported by the Bandwidth restrictions of the system.
// If not, lowers the physical resolution while keeping the same refresh rate.
// If the same refresh rate can not be kept, then keeps the resolution and lowers the refresh rate.
//
VOID HandleBandWidth_SingleDacActive(PPDEV ppdev)
{
    NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS Params;
    HEAD_RESOLUTION_INFO HeadResolution;
    ULONG ulHead;
    MODE_ENTRY RequestedMode;
    ULONG RefreshLoop, ResolutionLoop;
    ULONG NextLowerWidth, NextLowerHeight, NextLowerRefreshRate;

    RtlZeroMemory(&Params, sizeof(Params));
    Params.VidScalerHead = NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_WORST_CASE;

    ulHead = ppdev->ulDeviceDisplay[0];
    if (ulHead == 0)
    {
        Params.HeadActive0 = 1;
    }
    if (ulHead == 1)
    {
        Params.HeadActive1 = 1;
    }
    //
    // Get the timing info for the physical mode.
    //
    HeadResolution.ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
    HeadResolution.ulDisplayHeight= ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
    HeadResolution.ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];   

    HeadResolution.ulHead = ulHead;              
    HeadResolution.ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
    HeadResolution.ulDeviceType = ppdev->ulDeviceType[ulHead];        
    HeadResolution.ulTVFormat = ppdev->ulTVFormat[ulHead];
    HeadResolution.ulDisplayPixelDepth = ppdev->cBitsPerPel;
    HeadResolution.ulOption = 0;

    DISPDBG((1,"PhysMode Head%d: %d x %d, %d BPP, %d HZ, devMask: 0x%x, devType: %d",
             ulHead,
             HeadResolution.ulDisplayWidth, HeadResolution.ulDisplayHeight,
             HeadResolution.ulDisplayPixelDepth, HeadResolution.ulDisplayRefresh,
             HeadResolution.ulDeviceMask, HeadResolution.ulDeviceType));

    if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution, &Params))
        return;

    RefreshLoop = ResolutionLoop = 1;

    RequestedMode.Width = (USHORT)(ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left);
    RequestedMode.Height= (USHORT)(ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top);
    RequestedMode.RefreshRate = (USHORT)(ppdev->ulRefreshRate[ulHead]);   
    RequestedMode.Depth = (USHORT)(ppdev->cBitsPerPel);
    RequestedMode.ValidMode = 1;

    //
    // We have now built up the NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS structure. 
    // Now the quick success case. See if this mode passes. This is the most common case.
    //
    while (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                          NV_CFGEX_VALIDATE_BANDWIDTH, &Params, sizeof(NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS)))
    {
        //
        // We are failing the bandwidth requirements. We need to back off and try a lower physical mode.
        // See if there is a next lower refresh rate physical mode at the same resolution and color depth.
        // If cannot find the next lower refresh rate, try the next lower resolution at the same color depth
        // and refresh rate.
        //
        if (RefreshLoop || ResolutionLoop)
        {
            BOOLEAN bFoundNextLowerMode;

            if (RefreshLoop)
            {
                bFoundNextLowerMode = FindNextLowerRefreshRateMode(ppdev, ulHead, &RequestedMode, &NextLowerRefreshRate);
                if (bFoundNextLowerMode)
                {
                    HeadResolution.ulDisplayRefresh = NextLowerRefreshRate;
                }
            }
            else
            {
                bFoundNextLowerMode = FindNextLowerResolutionMode(ppdev, ulHead, &RequestedMode, &NextLowerWidth, &NextLowerHeight);
                if (bFoundNextLowerMode)
                {
                    HeadResolution.ulDisplayWidth = NextLowerWidth;
                    HeadResolution.ulDisplayHeight= NextLowerHeight;
                    HeadResolution.ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                }
            }

            if (bFoundNextLowerMode)
            {
                HeadResolution.ulHead = ulHead;              
                HeadResolution.ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
                HeadResolution.ulDeviceType = ppdev->ulDeviceType[ulHead];        
                HeadResolution.ulTVFormat = ppdev->ulTVFormat[ulHead];
                HeadResolution.ulDisplayPixelDepth = ppdev->cBitsPerPel;

                if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution, &Params))
                {
                    return;
                }

                //
                // Stick in lowered refresh rate or lowered resolution into the requested mode as we may need to iterate the next time.
                //
                if (RefreshLoop)
                {
                    RequestedMode.RefreshRate = (USHORT)NextLowerRefreshRate;
                }
                else
                {
                    RequestedMode.Width  = (USHORT)NextLowerWidth;
                    RequestedMode.Height = (USHORT)NextLowerHeight;
                }

                if (ResolutionLoop)
                {
                    RefreshLoop = 1;
                }

                //
                // Continue onto validating this combo.
                //
                continue;
            } // if bFoundNextLowerMode
            else
            {
                if (RefreshLoop)
                {
                    RefreshLoop = 0;
                    HeadResolution.ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                    RequestedMode.RefreshRate = (USHORT)HeadResolution.ulDisplayRefresh;

                    if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution, &Params))
                        return;
                }
                else
                {
                    ResolutionLoop = 0;
                }
            }
        }
        else
        {
            DISPDBG((0, "Too bad. Could not find any combo which passes the bandwidth requirements. Returning"));
            return;
        }
    } // while GetExBandwidth()

    //
    // Update the physical mode fields in the ppdev for the head we are varying.
    //
    ppdev->rclCurrentDisplay[ulHead].right = ppdev->rclCurrentDisplay[ulHead].left + RequestedMode.Width;
    ppdev->rclCurrentDisplay[ulHead].bottom = ppdev->rclCurrentDisplay[ulHead].top + RequestedMode.Height;
    ppdev->ulRefreshRate[ulHead] = RequestedMode.RefreshRate;
    
    DISPDBG((1, "Head: %d, DevMask: 0x%x, Final Phys: (%d, %d), (%d, %d) %d bpp, %d Hz",
             ulHead, ppdev->ulDeviceMask[ulHead], 
             ppdev->rclCurrentDisplay[ulHead].left, ppdev->rclCurrentDisplay[ulHead].top,
             ppdev->rclCurrentDisplay[ulHead].right, ppdev->rclCurrentDisplay[ulHead].bottom,
             ppdev->cBitsPerPel, ppdev->ulRefreshRate[ulHead]));

    return;
}

//
// Verifies that the physical modes can be supported by the Bandwidth restrictions of the system.
// If not, lowers the physical resolution while keeping the same refresh rate.
// If the same refresh rate can not be kept, then keeps the resolution and lowers the refresh rate.
//
VOID HandleBandWidth_DualDacsActive(PPDEV ppdev)
{
    NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS Params;
    HEAD_RESOLUTION_INFO HeadResolution[2];
    ULONG ulHead;
    MODE_ENTRY RequestedMode[2];
    ULONG i;
    ULONG RefreshLoop[2], ResolutionLoop[2];
    ULONG NextLowerWidth, NextLowerHeight, NextLowerRefreshRate;

    RtlZeroMemory(&Params, sizeof(Params));
    Params.VidScalerHead = NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_WORST_CASE;
    Params.HeadActive0 = Params.HeadActive1 = 1;

    for (i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        //
        // Get the timing info for the physical mode.
        //
        HeadResolution[i].ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
        HeadResolution[i].ulDisplayHeight= ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
        HeadResolution[i].ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];   

        HeadResolution[i].ulHead = ulHead;              
        HeadResolution[i].ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
        HeadResolution[i].ulDeviceType = ppdev->ulDeviceType[ulHead];        
        HeadResolution[i].ulTVFormat = ppdev->ulTVFormat[ulHead];
        HeadResolution[i].ulDisplayPixelDepth = ppdev->cBitsPerPel;
        HeadResolution[i].ulOption = 0;

        DISPDBG((1,"PhysMode Head%d: %d x %d, %d BPP, %d HZ, devMask: 0x%x, devType: %d",
                 ulHead,
                 HeadResolution[i].ulDisplayWidth, HeadResolution[i].ulDisplayHeight,
                 HeadResolution[i].ulDisplayPixelDepth, HeadResolution[i].ulDisplayRefresh,
                 HeadResolution[i].ulDeviceMask, HeadResolution[i].ulDeviceType));

        if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution[i], &Params))
            return;
    } // for NumberDacsActive


    for (i = 0; i < 2; i++)
    {
        RefreshLoop[i] = ResolutionLoop[i] = 1;

        RequestedMode[i].Width = (USHORT)(ppdev->rclCurrentDisplay[i].right  - ppdev->rclCurrentDisplay[i].left);
        RequestedMode[i].Height= (USHORT)(ppdev->rclCurrentDisplay[i].bottom - ppdev->rclCurrentDisplay[i].top);
        RequestedMode[i].RefreshRate = (USHORT)(ppdev->ulRefreshRate[i]);   
        RequestedMode[i].Depth = (USHORT)(ppdev->cBitsPerPel);
        RequestedMode[i].ValidMode = 1;
    }

    //
    // We have now built up the NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS structure. 
    // Now the quick success case. See if this mode passes. This is the most common case.
    //
    i = 0;
    
    while (NvConfigGetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                          NV_CFGEX_VALIDATE_BANDWIDTH, &Params, sizeof(NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS)))
    {
        //
        // We are failing the bandwidth requirements. We need to back off and try a lower physical mode.
        // See if there is a next lower refresh rate physical mode at the same resolution and color depth.
        // If cannot find the next lower refresh rate, try the next lower resolution at the same color depth
        // and refresh rate.
        //
        if (!RefreshLoop[i] && !ResolutionLoop[i])
        {
            if (i == 1)
            {
                DISPDBG((0, "Too bad. Could not find any combo which passes the bandwidth requirements. Returning"));
                return;
            }
            else
            {
                RefreshLoop[0] = ResolutionLoop[0] = 1;

                ulHead = ppdev->ulDeviceDisplay[0];
                HeadResolution[0].ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
                HeadResolution[0].ulDisplayHeight= ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
                HeadResolution[0].ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                RequestedMode[0].Width = (USHORT)HeadResolution[0].ulDisplayWidth;
                RequestedMode[0].Height= (USHORT)HeadResolution[0].ulDisplayHeight;
                RequestedMode[0].RefreshRate = (USHORT)HeadResolution[0].ulDisplayRefresh;

                if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution[0], &Params))
                    return;

                i = 1;
            }
        }
        else
        {
            BOOLEAN bFoundNextLowerMode;

            ulHead = ppdev->ulDeviceDisplay[i];

            if (RefreshLoop[i])
            {
                bFoundNextLowerMode = FindNextLowerRefreshRateMode(ppdev, ulHead, &RequestedMode[i], &NextLowerRefreshRate);
                if (bFoundNextLowerMode)
                {
                    HeadResolution[i].ulDisplayRefresh = NextLowerRefreshRate;
                }
            }
            else
            {
                bFoundNextLowerMode = FindNextLowerResolutionMode(ppdev, ulHead, &RequestedMode[i], &NextLowerWidth, &NextLowerHeight);
                if (bFoundNextLowerMode)
                {
                    HeadResolution[i].ulDisplayWidth = NextLowerWidth;
                    HeadResolution[i].ulDisplayHeight= NextLowerHeight;
                    HeadResolution[i].ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                }
            }

            if (bFoundNextLowerMode)
            {
                //
                // Found a mode. Now we need to validate against the bandwidth. 
                // So fill the info into the BANDWIDTH_PARAMS structure. First get the TIMING info.
                //
                HeadResolution[i].ulHead = ulHead;              
                HeadResolution[i].ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
                HeadResolution[i].ulDeviceType = ppdev->ulDeviceType[ulHead];        
                HeadResolution[i].ulTVFormat = ppdev->ulTVFormat[ulHead];
                HeadResolution[i].ulDisplayPixelDepth = ppdev->cBitsPerPel;

                if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution[i], &Params))
                    return;

                //
                // Stick in lowered refresh rate or lowered resolution into the requested mode as we may need to iterate the next time.
                //
                if (RefreshLoop[i])
                {
                    RequestedMode[i].RefreshRate = (USHORT)NextLowerRefreshRate;
                }
                else
                {
                    RequestedMode[i].Width  = (USHORT)NextLowerWidth;
                    RequestedMode[i].Height = (USHORT)NextLowerHeight;
                }

                if (ResolutionLoop[i])
                {
                    RefreshLoop[i] = 1;
                }
                //
                // Continue onto validating this combo.
                // For any Head1 change, reset head0 and restart Head0 validation
                //
                if (i == 1)
                {
                    i = 0;
                }
                continue;
            } // if bFoundNextLowerMode
            else
            {
                if (RefreshLoop[i])
                {
                    RefreshLoop[i] = 0;

                    ulHead = ppdev->ulDeviceDisplay[i];
                    HeadResolution[i].ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];
                    RequestedMode[i].RefreshRate = (USHORT)HeadResolution[i].ulDisplayRefresh;
                    
                    if (!ConvertHeadResToTiming(ppdev, ulHead, &HeadResolution[i], &Params))
                        return;
                }
                else
                {
                    ResolutionLoop[i] = 0;
                }
            }
        }
    }

    //
    // Update the physical mode fields in the ppdev.
    //
    for (i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        ppdev->rclCurrentDisplay[ulHead].right  = ppdev->rclCurrentDisplay[ulHead].left + RequestedMode[ulHead].Width;
        ppdev->rclCurrentDisplay[ulHead].bottom = ppdev->rclCurrentDisplay[ulHead].top  + RequestedMode[ulHead].Height;
        ppdev->ulRefreshRate[ulHead] = RequestedMode[ulHead].RefreshRate;

        DISPDBG((1, "Head: %d, PhysHead: %d DevMask: 0x%x, Final Phys: (%d, %d), (%d, %d) %d bpp, %d Hz",
                 i, ulHead, ppdev->ulDeviceMask[i], 
                 ppdev->rclCurrentDisplay[i].left, ppdev->rclCurrentDisplay[i].top,
                 ppdev->rclCurrentDisplay[i].right, ppdev->rclCurrentDisplay[i].bottom,
                 ppdev->cBitsPerPel, ppdev->ulRefreshRate[i]));
    }

    return;
}


//
// For the physical head, finds the next lower refresh rate for the requested mode while keeping the same depth
// and resolution.
// Returns TRUE if a lower refresh rate was found.
// Returns FALSE if a lower refresh rate was not found.
// Note: The physical mode list contains low res modes so weed out modes less than 640x480 since GDI does not
// accept them.
// The lower refresh rate is returned in pNextLowerRefreshRate.
//
BOOLEAN FindNextLowerRefreshRateMode(PPDEV ppdev, ULONG ulHead, MODE_ENTRY *pRequestedMode, ULONG *pNextLowerRefreshRate)
{
    ULONG i;
    MODE_ENTRY *PhysModePtr;
    ULONG LowerRate;

    DISPDBG((1, "FindNextLowerRefreshRateMode() for: %d x %d,  %d bpp, %d HZ",
             pRequestedMode->Width, pRequestedMode->Height, pRequestedMode->Depth, pRequestedMode->RefreshRate));
             

    LowerRate = 0;
    PhysModePtr = ppdev->PhysModeList[ulHead];
    for (i=0; i < ppdev->ulNumPhysModes[ulHead]; i++)
    {
        if (PhysModePtr->ValidMode && 
            PhysModePtr->Width == pRequestedMode->Width &&
            PhysModePtr->Width >= 640 &&
            PhysModePtr->Height == pRequestedMode->Height &&
            PhysModePtr->Height >= 480 &&
            PhysModePtr->Depth == pRequestedMode->Depth &&
            PhysModePtr->RefreshRate  < pRequestedMode->RefreshRate)
        {
            //
            // Found a match. But we still need to scan the rest of the list as we want the highest 
            // among the lower rates.
            //
            if (PhysModePtr->RefreshRate > LowerRate)
            {
                LowerRate =  PhysModePtr->RefreshRate;
            }
            
        }
        PhysModePtr++;
    }

    if (LowerRate != 0)
    {
        //
        // We found a valid lower rate.
        //
        *pNextLowerRefreshRate = LowerRate;
        DISPDBG((1,"Found Lower Rate: %d HZ",LowerRate));
        return(TRUE);

    }
    else
    {
        //
        // We did not find a valid lower rate.
        //
        DISPDBG((1, "Could not find a lower refresh rate"));
        return(FALSE);
    }
}


//
// For the physical head, finds the next lower resolution for the requested mode while keeping the same depth
// and refreshrate.
// Returns TRUE if a lower resolution was found.
// Returns FALSE if a lower resolution rate was not found.
// Note: The physical mode list contains low res modes so weed out modes less than 640x480 since GDI does not
// accept them.
// The lower width is returned in pNextLowerWidth.
// The lower height is returned in pNextLowerHeight.
//
BOOLEAN FindNextLowerResolutionMode(PPDEV ppdev, ULONG ulHead, MODE_ENTRY *pRequestedMode, ULONG *pNextLowerWidth, ULONG *pNextLowerHeight)
{
    ULONG i;
    MODE_ENTRY *PhysModePtr;
    ULONG LowerWidth, LowerHeight;

    DISPDBG((1, "FindNextLowerResolutionMode() for: %d x %d,  %d bpp, %d HZ",
             pRequestedMode->Width, pRequestedMode->Height, pRequestedMode->Depth, pRequestedMode->RefreshRate));

    //
    // Vary the height. Depth and Refresh should be the same. Width should be <= the requested width.
    //
    LowerHeight = 0;
    LowerWidth =  0;
    PhysModePtr = ppdev->PhysModeList[ulHead];
    for (i=0; i < ppdev->ulNumPhysModes[ulHead]; i++)
    {
        if (PhysModePtr->ValidMode && 
            PhysModePtr->Width <= pRequestedMode->Width &&
            PhysModePtr->Width >= 640 &&
            PhysModePtr->Height < pRequestedMode->Height &&
            PhysModePtr->Height >= 480 &&
            PhysModePtr->Depth == pRequestedMode->Depth &&
            PhysModePtr->RefreshRate  == pRequestedMode->RefreshRate)
        {
            //
            // Found a match. But we still need to scan the rest of the list as we want the highest among
            // the lower resolutions.
            //
            if (PhysModePtr->Height > LowerHeight)
            {
                LowerHeight =  PhysModePtr->Height;
                LowerWidth =  PhysModePtr->Width;
            }
            
        }
        PhysModePtr++;
    }

    if (LowerHeight != 0)
    {
        //
        // We found a valid lower resolution.
        //
        *pNextLowerHeight = LowerHeight;
        *pNextLowerWidth =  LowerWidth;
        DISPDBG((1,"Found Lower resolution: %d x %d",LowerWidth, LowerHeight));
        return(TRUE);
    }
    else
    {
        //
        // We did not find a valid lower resolution.
        //
        DISPDBG((1, "Could not find a lower resolution"));
        return(FALSE);
    }
}

//
// Returns true if the GDI should do the EDID mode pruning.
// Returns FALSE to indicate that the display driver should the EDID mode pruning.
// We need to explicitly pass in all the required pieces of data as arguements since we
// don't have ppdev available at DrvGetModes() time.
//
BOOLEAN bQueryGDIModePruning(ULONG ulTwinView_State, ULONG ulPrimaryHead, ULONG ulPrimaryDeviceMask,
        ULONG ulHead, ULONG ulDeviceMask, ULONG ulACPISystem, ULONG ulGDIModePruning)
{
    //
    // If spanning mode, we always let the driver do the pruning
    //
    if (ulTwinView_State == NVTWINVIEW_STATE_SPAN)
    {
        return(FALSE);
    }

    //
    // If DualView mode, we always let the GDI do the pruning
    //
    if (ulTwinView_State == NVTWINVIEW_STATE_DUALVIEW)
    {
        return(TRUE);
    }

    //
    // If we are not dealing with the primary head, then let the driver handle the pruning.
    //
    if (ulHead != ulPrimaryHead || ulDeviceMask != ulPrimaryDeviceMask)
    {
        return(FALSE);
    }

    //
    // Handle  CRT depending on the registry key.
    //
    if ((ulPrimaryDeviceMask & BITMASK_ALL_CRT) &&
        (ulGDIModePruning == GDI_MODE_PRUNING_DESKTOP_LAPTOP_CRT || 
         ulGDIModePruning == GDI_MODE_PRUNING_DESKTOP_CRT_DFP))
    {
        return(TRUE);
    }

    //
    // Handle  DFP depending on the registry key.
    // Note we always want to let the driver handle mode pruning on laptops for DFPs.
    //
    if ((ulPrimaryDeviceMask & BITMASK_ALL_DFP) && ulACPISystem == 0 && 
          ulGDIModePruning == GDI_MODE_PRUNING_DESKTOP_CRT_DFP)
    {
        return(TRUE);
    }
    
    return(FALSE);
}

//
// Reads the SaveSettinngs registry entry into ppdev.
// No need to do extensive sanity checks since miniport would have done the sanity checks at boot time to ensure
// a valid SaveSettings structureexists in the regsistry.
//
VOID vReadSaveSettings(PPDEV ppdev)
{
    char * KeyName = "SaveSettings";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_REGISTRY_STRUCT regStructInput;
    ULONG Status;
    ULONG returnedDataLen;

    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStructInput.keyName = (PWSTR)KeyNameUniCode;
    regStructInput.keyVal = ppdev->SaveSettings;
    regStructInput.keyValSize = sizeof(ppdev->SaveSettings);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL,
                                (LPVOID)&regStructInput,
                                sizeof(NV_REGISTRY_STRUCT),
                                (LPVOID) (ppdev->SaveSettings),
                                sizeof(ppdev->SaveSettings),
                                &(returnedDataLen));

    DISPDBG((2,"ReadSaveSettings(): KeyValSize: 0x%x, returnedDataLen: 0x%x",regStructInput.keyValSize,
                returnedDataLen));
}

//
// Finds the slot in the SaveSettings table for the requested device combo using the 'pQuery' or 'pData' structure if
// provided, else uses the device combo specified in the ppdev.
// Should always return a valid pointer to a slot.
// Note: SaveSettings is not implemented for DualView mode for WinXP since the OS handles it fully.
//
NVTWINVIEWDATA *pFindSaveSettings(PPDEV ppdev, QUERY_SAVE_SETTINGS *pQuery, NVTWINVIEWDATA *pTwinViewData)
{
    ULONG i, ulPrimaryHead;
    ULONG ulState, ulOrientation, ulPrimaryDeviceMask, ulDeviceMask0, ulDeviceMask1;
    ULONG ulStateTable, ulOrientationTable, ulPrimaryDeviceMaskTable, ulDeviceMask0Table, ulDeviceMask1Table;
    NVTWINVIEWDATA *pData;
    NVTWINVIEW_DEVICE_TYPE_DATA *pDevData0, *pDevData1;

    if (pQuery)
    {
        ulState = pQuery->ulState;
        ulOrientation = pQuery->ulOrientation;
        ulPrimaryHead = pQuery->ulDeviceDisplay[0];
        ulPrimaryDeviceMask = pQuery->ulDeviceMask[ulPrimaryHead];
        ulDeviceMask0 = pQuery->ulDeviceMask[0];
        ulDeviceMask1 = pQuery->ulDeviceMask[1];
    }
    else
    if (pTwinViewData)
    {
        ulState = pTwinViewData->dwState;
        ulOrientation = pTwinViewData->dwOrientation;
        ulPrimaryHead = pTwinViewData->dwDeviceDisplay[0];
        ulPrimaryDeviceMask = pTwinViewData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwDeviceMask;
        ulDeviceMask0 = pTwinViewData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask;
        ulDeviceMask1 = pTwinViewData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
    }
    else
    {
        ulState = ppdev->TwinView_State;
        ulOrientation = ppdev->TwinView_Orientation;
        ulPrimaryHead = ppdev->ulDeviceDisplay[0];
        ulPrimaryDeviceMask = ppdev->ulDeviceMask[ulPrimaryHead];
        ulDeviceMask0 = ppdev->ulDeviceMask[0];
        ulDeviceMask1 = ppdev->ulDeviceMask[1];
    }

    // Only for Rel10 and main.
    if (ulState == NVTWINVIEW_STATE_DUALVIEW)
    {
        DISPDBG((1,"pFindSaveSettings(): SaveSettings is not implemented for DualView for XP. Returnign NULL"));
        return(NULL);
    }
    
    //
    // Search for the slot for the standard mode case.
    //
    if (ulState == NVTWINVIEW_STATE_NORMAL)
    {
        for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
        {
            pData = &ppdev->SaveSettings[i];
            ulStateTable = pData->dwState;
            ulPrimaryHead = pData->dwDeviceDisplay[0];
            ulPrimaryDeviceMaskTable = pData->NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwDeviceMask;
            if (ulStateTable == ulState && ulPrimaryDeviceMaskTable == ulPrimaryDeviceMask)
            {
                //
                // Found the slot.
                //
                return(pData);
            }
        }
    }

    //
    // Search for the slot for the clone mode case.
    //
    if (ulState == NVTWINVIEW_STATE_CLONE)
    {
        for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
        {
            pData = &ppdev->SaveSettings[i];
            ulStateTable = pData->dwState;
            ulDeviceMask0Table = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask;
            ulDeviceMask1Table = pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
            if (ulStateTable == ulState && 
                ulDeviceMask0Table == ulDeviceMask0 && ulDeviceMask1Table == ulDeviceMask1)
            {
                //
                // Found the slot.
                //
                return(pData);
            }
        }
    }

    //
    // Search for the slot for the span mode case.
    //
    if (ulState == NVTWINVIEW_STATE_SPAN)
    {
        for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
        {
            pData = &ppdev->SaveSettings[i];
            ulStateTable = pData->dwState;
            ulOrientationTable = pData->dwOrientation;
            ulDeviceMask0Table = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask;
            ulDeviceMask1Table = pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
            if (ulStateTable == ulState && ulOrientationTable == ulOrientation &&
                ulDeviceMask0Table == ulDeviceMask0 && ulDeviceMask1Table == ulDeviceMask1)
            {
                //
                // Found the slot.
                //
                return(pData);
            }
        }
    }

    DISPDBG((1,"pFindSaveSettings(): Something went wrong. Returning NULL"));
    return(NULL);
}
        


//
// Writes the NVTWINVIEWDATA for the current mode into the SaveSettingsTable in the
// appropriate slot.
// Note: It is assumed that the current mode in the ppdev already reflects the pData.
//
VOID vWriteSaveSettings(PPDEV ppdev)
{
    char * KeyName = "SaveSettings";
    ULONG KeyNameLen;
    WCHAR KeyNameUniCode[NV_MAX_REG_KEYNAME_LEN];
    ULONG KeyNameUniCodeLen;
    NV_REGISTRY_STRUCT regStruct;
    ULONG Status;
    ULONG returnedDataLen;
    NVTWINVIEWDATA *pFind;
    NVTWINVIEWDATA sCurrentData;
    ULONG ReturnedDataLength;

    //
    // First readin the TwnViewInfo structure for the just concluded modeset.
    //
    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_GET_TWINVIEW_STATE,
                        NULL,
                        0,
                        &sCurrentData,
                        sizeof(NVTWINVIEWDATA),
                        &ReturnedDataLength))
    {
        DISPDBG((1, "vWriteSaveSettings() something wrong: - IOCTL_VIDEO_GET_TWINVIEW_STATE failed"));
        return;
    }


    pFind = pFindSaveSettings(ppdev, NULL, NULL);
    if (pFind == NULL)
    {   
        DISPDBG((1,"vWriteSaveSettings(): Returning since pFindSaveSettings() returned failure"));
        return;
    }

    //
    // Copy the current mode into the SaveSettings Table of the ppdev in the correct slot.
    //
    *pFind = sCurrentData;
    
    //
    // Now copy the full SaveSettings table into the registry.
    //
    KeyNameLen = strlen(KeyName) + 1;
    EngMultiByteToUnicodeN(KeyNameUniCode,
                           NV_MAX_REG_KEYNAME_LEN,
                           &KeyNameUniCodeLen,
                           (PCHAR)KeyName,
                           KeyNameLen*sizeof(CHAR));

    regStruct.keyName = (PWSTR)KeyNameUniCode;
    regStruct.keyVal = ppdev->SaveSettings;
    regStruct.keyValSize = sizeof(ppdev->SaveSettings);

    Status = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_REGISTRY_VALUE,
                                   (LPVOID)(&regStruct),
                                   sizeof(NV_REGISTRY_STRUCT),
                                   (LPVOID) NULL,
                                   0,
                                   &returnedDataLen);
}

//
// Debug helper routine to print the SaveSettings table.
//
VOID vPrintSaveSettings(PPDEV ppdev, ULONG ulDebugLevel)
{
    ULONG i, ulHead;
    ULONG ulDeviceMask, ulDeviceMask0, ulDeviceMask1;
    NVTWINVIEWDATA *pData;
    NVTWINVIEW_DEVICE_TYPE_DATA *pDevData0, *pDevData1;
    CHAR *pcMode;

    for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
    {
        pData = &ppdev->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        switch (pData->dwState)
        {
        case NVTWINVIEW_STATE_NORMAL:
            pcMode = "Standard";
            break;
        case NVTWINVIEW_STATE_CLONE:
            pcMode = "Clone";
            break;
        case NVTWINVIEW_STATE_SPAN:
            pcMode = "Spanning";
            break;
        default:
            pcMode = "Invalid mode";
            break;
        }
        DISPDBG((ulDebugLevel,"%d: %s,%d,  (%d,%d), (0x%x, %d), (0x%x, %d)",i,
            pcMode, pData->dwOrientation, pData->dwDeviceDisplay[0], pData->dwDeviceDisplay[1], 
            pDevData0->dwDeviceMask, pDevData0->dwTVFormat, pDevData1->dwDeviceMask, pDevData1->dwTVFormat));

        if (pData->DeskTopRectl.left == 0 && pData->DeskTopRectl.top == 0 &&
            pData->DeskTopRectl.right == 0 && pData->DeskTopRectl.bottom == 0)   
        {
            // don't print this since this slot is not valid.
        }
        else
        {
            // This slot is valid and occupied. Print the mode info.
            DISPDBG((ulDebugLevel, "   Desktop: (%d, %d), (%d, %d)", 
                pData->DeskTopRectl.left,pData->DeskTopRectl.top,pData->DeskTopRectl.right, pData->DeskTopRectl.bottom));
            DISPDBG((ulDebugLevel,"    Head0 virt: (%d, %d), (%d, %d)",
                pDevData0->VirtualRectl.left,pDevData0->VirtualRectl.top,pDevData0->VirtualRectl.right,pDevData0->VirtualRectl.bottom));
            DISPDBG((ulDebugLevel,"    Head0 phys: (%d, %d), (%d, %d), %dbpp, %dHZ\n",
                pDevData0->PhysicalRectl.left,pDevData0->PhysicalRectl.top,pDevData0->PhysicalRectl.right,pDevData0->PhysicalRectl.bottom,
                pDevData0->dwBpp, pDevData0->dwRefresh));
            DISPDBG((ulDebugLevel,"    Head1 virt: (%d, %d), (%d, %d)",
                pDevData1->VirtualRectl.left,pDevData1->VirtualRectl.top,pDevData1->VirtualRectl.right,pDevData1->VirtualRectl.bottom));
            DISPDBG((ulDebugLevel,"    Head0 phys: (%d, %d), (%d, %d), %dbpp, %dHZ",
                pDevData1->PhysicalRectl.left,pDevData1->PhysicalRectl.top,pDevData1->PhysicalRectl.right,pDevData1->PhysicalRectl.bottom,
                pDevData1->dwBpp, pDevData1->dwRefresh));
            DISPDBG((ulDebugLevel,""));
        }
        
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglclient.c ===
/******************************Module*Header*******************************\
* Module Name: oglclients.c
*
* This module contains the functions to support the OpenGL clients.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

//******************************************************************************
//
//  Function: FindClientListFromClientInfo
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientListFromClientInfo(PDEV *ppdev, NV_OPENGL_CLIENT_INFO *clientInfo)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    if (clientInfo)
        {
        node = globalOpenGLData.oglClientListHead.clientList;
        while (node)
            {
            if (clientInfo == &node->clientInfo)
                {
                return(node);
                break;
                }
            node = node->next;
            }
        // Although this happens in DrvClipChanged after the ICD destroyed
        // the servers client info, it's a bug to work on invalidated data!
        DISPDBG((1, "WARNING in OglFindClientListFromClientInfo: invalid clientInfo: 0x%p", clientInfo));
        }

    return(NULL);
    }

//******************************************************************************
//
//  Function: OglAppendToClientInfoList
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglAppendToClientInfoList(
PDEV    *ppdev, 
DWORD   flags,                               // bits indicating allocated/free resources
HDRVOBJ hDrvObj,                             // driver object handle for this client
NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo, // drawable information for this client
NV_OPENGL_CONTEXT_INFO  *clientContextInfo)  // context information for this client
    {
    NV_OPENGL_CLIENT_INFO_LIST *newNode, *node;
 
    if (globalOpenGLData.oglClientCount >= MAX_OGL_CLIENTS)
    {
        DISPDBG((2, "OglAppendToClientInfoList: Too many OpenGL clients"));
        return NULL;
    }

    newNode = EngAllocMem(FL_ZERO_MEMORY, sizeof(NV_OPENGL_CLIENT_INFO_LIST), ALLOC_TAG);
    if (newNode == NULL)
        {
        OglDebugPrint("OglAppendToClientInfoList - Failed EngAllocMem");
        return(FALSE);
        }
    memset(newNode, 0, sizeof(NV_OPENGL_CLIENT_INFO_LIST));

    newNode->refCount++;
    newNode->next                          = NULL;
    newNode->clientInfo.flags              = flags;
    newNode->clientInfo.hDrvObj            = hDrvObj;
    newNode->clientInfo.modeSwitchCount    = ppdev->dwGlobalModeSwitchCount;
    newNode->clientInfo.clientDrawableInfo = clientDrawableInfo;
    newNode->clientInfo.clientContextInfo  = clientContextInfo;
    newNode->clientInfo.dwProcessID        = GetCurrentProcessID();

    if (NULL == globalOpenGLData.oglClientListHead.clientList)
        {
        globalOpenGLData.oglClientListHead.clientList = newNode;
        }
    else
        {
        node = globalOpenGLData.oglClientListHead.clientList;
        while (node->next)
            {
            node = node->next;
            }
        node->next = newNode;
        }

    OglIncClientCount(ppdev);
    return(newNode);
    }

//******************************************************************************
//
//  Function: OglRemoveFromClientInfoList
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
void OglRemoveFromClientInfoList(
PDEV *ppdev, 
NV_OPENGL_CLIENT_INFO_LIST *toFree)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node, *parNode;

    if (toFree == NULL ||
        ppdev == NULL ||
        globalOpenGLData.oglClientListHead.clientList == NULL)
        {
        return;
        }

    if (toFree->clientInfo.pwo)
        {
        // Although it's not allowed to call that here, I need to invalidate the pwo because we
        // still get called with this client, but we delete it here.
        // reproduce: run quadroview on nt5 and open a model -> page fault
        // however: will work most of the time, dunno why ?!?! [WNDOBJ_vSetConsumer() is just setting the pvConsumer entry // maybe windows is using the pvConsumer somehow ?!?!]
#if 0
        WNDOBJ_vSetConsumer(toFree->clientInfo.pwo, NULL);
#endif
        }

    if (toFree == globalOpenGLData.oglClientListHead.clientList)
        {
        if (globalOpenGLData.oglClientListHead.clientList)
            {
            globalOpenGLData.oglClientListHead.clientList->refCount--;
            if (globalOpenGLData.oglClientListHead.clientList->refCount == 0)
                {
                //
                // Long explanation:
                //    refCount is used to indicate that multiple PDEVs
                //    are using globalOpenGLData.oglClientListHead.clientList.
                //    If refCount > 0 then we cannot free the memory but
                //    we can set globalOpenGLData.oglClientListHead.clientList to
                //    NULL.  If refCount == 0 then we can free the memory
                //    associated with globalOpenGLData.oglClientListHead.clientList
                //    and set it to NULL.
                //
                //    It is very important to remember that the pointer
                //    and memory associated with globalOpenGLData.oglClientListHead.clientList
                //    maybe be shared between two different PEVs.  Multiple
                //    PDEVs get access to one globalOpenGLData.oglClientListHead.clientList
                //    in ResetPDEV (enable.c).
                //
                globalOpenGLData.oglClientListHead.clientList = 
                    globalOpenGLData.oglClientListHead.clientList->next;
                EngFreeMem(toFree); // free memory
                OglDecClientCount(ppdev);
                }
            }
        }
    else
        {
        parNode = globalOpenGLData.oglClientListHead.clientList;
        node    = globalOpenGLData.oglClientListHead.clientList->next;
        while (node)
            {
            if (node == toFree)
                {
                parNode->next = node->next;
                EngFreeMem(toFree);
                OglDecClientCount(ppdev);
                break;
                }
            parNode = node;
            node    = node->next;
            }
        }

    return;
    }


//******************************************************************************
//
//  Function: OglFindClientInfoRmClient
//
//  Routine Description:
//
//  Arguments:
//
//        Handle to resource manager client
//
//  Return Value:
//        Pointer to client information node
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO *OglFindClientInfoRmClient(
PDEV *ppdev, 
ULONG rmClient)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node       = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.hClient == rmClient)
            {
            clientInfo = &node->clientInfo;
            break;
            }
        node = node->next;
        }

    return(clientInfo);
    }


//******************************************************************************
//
//  Function: OglFindDrawableInClientInfoList
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//        Pointer to client information node
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO *OglFindDrawableInClientInfoList(
PDEV *ppdev, 
NV_OPENGL_DRAWABLE_INFO *inDrawablePtr)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node       = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.clientDrawableInfo == inDrawablePtr)
            {
            clientInfo = &node->clientInfo;
            break;
            }
        node = node->next;
        }

    return(clientInfo);
    }

//******************************************************************************
//
//  Function: OglFindClientInfoGlobalData
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
static NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoGlobalData(
PDEV *ppdev, 
ULONG processHandle, 
PVOID globalData)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.processHandle == processHandle &&
            node->clientInfo.oglGlobalPagePtr == globalData)
            {
            break;
            }
        node = node->next;
        }

    return(node);
    }

//******************************************************************************
//
//  Function:   OglEngDeleteDriverObj
//
//  Routine Description:
//
//        This routine frees the driver object if it is not in use.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
BOOL OglEngDeleteDriverObj(
PDEV *ppdev,
NV_OPENGL_CLIENT_INFO *clientInfo,
ULONG flags
)
    {
        if ((clientInfo->flags & flags) == 0)
        {
            if (clientInfo->hDrvObj)
            {
            DRIVEROBJ *drvObj;

            OglDebugPrint("*********************** OglEngDeleteDriverObj clientInfo = 0x%lx\n", clientInfo);

            drvObj = EngLockDriverObj(clientInfo->hDrvObj);
            if (drvObj)
                {
                OglDebugPrint("*********************** OglEngDeleteDriverObj : GOING to EngDeleteDriverObj clientInfo = 0x%lx\n", clientInfo);
                if (EngDeleteDriverObj(clientInfo->hDrvObj, FALSE, TRUE) == FALSE)
                    {
                    OglDebugPrint("*********************** OglEngDeleteDriverObj EngDeleteDriverObj FAILED! clientInfo = 0x%lx\n", clientInfo);
                    EngUnlockDriverObj(clientInfo->hDrvObj);
                    }
                OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
                }
            else
                {
                OglDebugPrint("*********************** OglEngDeleteDriverObj EngLockDriverObj FAILED! clientInfo = 0x%lx\n", clientInfo);
                return(FALSE);
                }
            return(TRUE);
            }
        }
        return(FALSE);
    }

//******************************************************************************
//
//  Function:   OglDecClientCount
//
//  Routine Description:
//
//        This routine decrements the client count.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void OglDecClientCount(
PDEV *ppdev
)
{
    //
    // Decrement client count.
    //
    globalOpenGLData.oglClientCount--;

#if DBG
    // Walk the linked list of verify the count.
    OglVerifyClientList(ppdev, "OglDecClientCount");
#endif // DBG
}

//******************************************************************************
//
//  Function:   OglIncClientCount
//
//  Routine Description:
//
//        This routine increments the client count.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void OglIncClientCount(
PDEV *ppdev
)
{
    //
    // Increment client count.
    //
    globalOpenGLData.oglClientCount++;

#if DBG
    // Walk the linked list of verify the count.
    OglVerifyClientList(ppdev, "OglIncClientCount");
#endif // DBG
}

/* XXX put into separate file called oglGlobal.c
 */
BOOL CALLBACK ClientSharedDrvFreeObj(DRIVEROBJ *pDriverObj);
BOOL CALLBACK RmClientDrvFreeObj(DRIVEROBJ *pDriverObj);

//******************************************************************************
//
//  Function:   OglRegisterRmClient
//
//  Routine Description:
//
//        Create a node in the OpenGL list and a driver object for the user's RM client.
//
//  Arguments:
//
//        rmClient - RM client handle to track for process abnormal termination
//
//******************************************************************************
void OglRegisterRmClient(PDEV *ppdev, ULONG rmClient)
    {
    int i;
    LONG                   status;
    HDRVOBJ                hDrvObj = (HDRVOBJ)NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

    DISPDBG((2, "OglRegisterRmClient - %ld", rmClient));

    //
    // Get pointer to new client.
    //
    clientList = OglAppendToClientInfoList(ppdev, 
                                           0, 
                                           0, 
                                           NULL, 
                                           NULL);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("OglRegisterRmClient: OglAppendToClientInfoList FAILED\n");
        return;
        }

    //
    // Save client data in node of list
    //
    clientInfo->hClient = rmClient;

    //
    // Set shared info is present bit in flags.
    //
    clientInfo->flags |= NV_OGL_CLIENT_RM_CLIENT;

    //
    // Create driver object that tracks this client index with the client process
    //
    hDrvObj = EngCreateDriverObj((PVOID)clientInfo, RmClientDrvFreeObj, ppdev->hdevEng);
    if (hDrvObj == NULL)
        {
        DISPDBG((1, "OglRegisterRmClient: FAILED EngCreateDriverObj"));
        OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
        OglDecClientCount(ppdev);
        return;
        }

    //
    // Save driver object and mode switch count.
    //
    clientInfo->hDrvObj = hDrvObj;

    OglDebugPrint("OglRegisterRmClient = 0x%p 0x%p\n", ppdev, clientInfo);
    }

//******************************************************************************
//
//  Function:   OglUnRegisterRmClient
//
//  Routine Description:
//
//        Free a previously allocated node in the client list.  The node
//        freed is associated with the rmClient.
//
//  Arguments:
//
//        rmClient - RM client handle to track for process abnormal termination
//
//******************************************************************************
void OglUnRegisterRmClient(PDEV *ppdev, ULONG rmClient)
    {
    int i;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    long status;

    OglDebugPrint("OglUnRegisterRmClient = 0x%p 0x%p\n", ppdev, rmClient);

    clientInfo = OglFindClientInfoRmClient(ppdev, rmClient);
    if (clientInfo && clientInfo->flags & NV_OGL_CLIENT_RM_CLIENT)
        {
        //
        // Free channel and such.
        //
        NvFree(ppdev->hDriver, rmClient, NV01_NULL_OBJECT, rmClient);

        clientInfo->hClient = 0;    // just for good measure...

        //
        // Mark it as freed.
        //
        clientInfo->flags &= ~NV_OGL_CLIENT_RM_CLIENT;

        if (OglEngDeleteDriverObj(ppdev, clientInfo, NV_OGL_CLIENT_RM_CLIENT) == TRUE)
            {
            OglDebugPrint("OglUnRegisterRmClient: client count = %ld\n", globalOpenGLData.oglClientCount);
            }

        OglDebugPrint("OglUnRegisterRmClient = 0x%p 0x%p\n", ppdev, clientInfo);
        }
    }

//******************************************************************************
//
//  Function:   RmClientDrvFreeObj
//
//  Routine Description:
//
//      This routine is the callback for freeing the driver object.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the resources are freed.
//
//******************************************************************************
BOOL CALLBACK RmClientDrvFreeObj(
    DRIVEROBJ *pDriverObj
)
    {
    NV_OPENGL_CLIENT_INFO *clientInfo;
    LONG                  status;
    int                   i, clientIndex;
    PDEV                  *ppdev;

    clientInfo = (NV_OPENGL_CLIENT_INFO *)pDriverObj->pvObj;
    ppdev = (PDEV *)pDriverObj->dhpdev;

    OglAcquireGlobalMutex();
    OglDebugPrint("RmClientDrvFreeObj = 0x%p 0x%p\n", ppdev, clientInfo);

    if (OglFindClientListFromClientInfo(ppdev, clientInfo) == NULL)
        {
        // clientInfo was removed from clientList prior to this callback
        // just return because there is nothing to do...
        OglReleaseGlobalMutex();
        return(TRUE);
        }

    //
    // Cleanup client info.
    //
    if (clientInfo->flags & NV_OGL_CLIENT_RM_CLIENT)
        {
        try
            {
            //
            // Free channel and such.
            //
            NvFree(ppdev->hDriver, clientInfo->hClient, NV01_NULL_OBJECT, clientInfo->hClient);
            }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
            status = GetExceptionCode();
            DISPDBG((1, "RmClientDrvFreeObj: exception = 0x%lx", status));
            OglReleaseGlobalMutex();
            return(TRUE);
            }
        clientInfo->flags &= ~NV_OGL_CLIENT_RM_CLIENT;
        clientInfo->hClient = 0;    // just for good measure...
        }

    clientInfo->hDrvObj = 0;
    clientInfo->flags   = 0;

    //
    // Remove from global client list.
    //
    OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));

    OglDebugPrint("RmClientDrvFreeObj CALLBACK: client count = %ld\n", globalOpenGLData.oglClientCount);

    OglReleaseGlobalMutex();

    return(TRUE);
}

//******************************************************************************
//
//  Function:   CreateSharedClientInfo
//
//  Routine Description:
//
//        Maps the global page (GDI mutex and mode switch counter) into the
//        client address space.  It adds a node to the linked list and register
//        the node with the GDI subsystem.
//
//        Also maps the fifo registers, and the pci config space registers
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void CreateSharedClientInfo(
PDEV *ppdev, 
ULONG hClient,
ULONG processHandle, 
PVOID *globalData, 
PVOID *pfifoAddress,
PVOID *pbusAddress)
    {
    int i;
    LONG                   status;
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryOut;
    HDRVOBJ                hDrvObj = (HDRVOBJ)NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

    DISPDBG((2, "CreateSharedClientInfo - %ld", processHandle));

    *globalData = *pfifoAddress = NULL;

    if (OglMapGlobalPageAddress(ppdev, globalData) == FALSE)
        {
        OglDebugPrint("CreateSharedClientInfo: OglMapGlobalPageAddress FAILED\n");
        return;
        }

    if (OglMapPFifoAddress(ppdev, pfifoAddress) == FALSE)
        {
        OglUnmapGlobalPageAddress(ppdev, *globalData);
        OglDebugPrint("CreateSharedClientInfo: OglMapPFifoAddress FAILED\n");
        return;
        }

    if (OglMapPBusAddress(ppdev, pbusAddress) == FALSE)
        {
        OglUnmapPFifoAddress(ppdev, *pfifoAddress);
        OglUnmapGlobalPageAddress(ppdev, *globalData);
        OglDebugPrint("CreateSharedClientInfo: OglMapPBusAddress FAILED\n");
        return;
        }

    //
    // Get pointer to new client.
    //
    clientList = OglAppendToClientInfoList(ppdev, 
                                           0, 
                                           0, 
                                           NULL, 
                                           NULL);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglUnmapPBusAddress(ppdev, *pbusAddress);
        OglUnmapPFifoAddress(ppdev, *pfifoAddress);
        OglUnmapGlobalPageAddress(ppdev, *globalData);
        OglDebugPrint("CreateSharedClientInfo: OglAppendToClientInfoList FAILED\n");
        return;
        }

    //
    // Save client data in node of list
    //
    clientInfo->hClient          = hClient;       // Per-device client handle
    clientInfo->processHandle    = processHandle; // Process handle from client associated with globalData
    clientInfo->oglGlobalPagePtr = *globalData;   // Pointer to shared memory
    clientInfo->pfifoAddress     = *pfifoAddress; // Address of FIFO in client address space
    clientInfo->pbusAddress      = *pbusAddress;  // Address of BUS registers in client addr space

    //
    // Set shared info is present bit in flags.
    //
    clientInfo->flags |= NV_OGL_CLIENT_SHARED_INFO;

    OglDebugPrint("****************** CreateShared: client count = %ld\n", globalOpenGLData.oglClientCount);

    //
    // Create driver object that tracks this client index with the client process
    //
    hDrvObj = EngCreateDriverObj((PVOID)clientInfo, ClientSharedDrvFreeObj, ppdev->hdevEng);
    if (hDrvObj == NULL)
        {
        DISPDBG((1, "CreateSharedClientInfo: FAILED EngCreateDriverObj"));
        OglDebugPrint("****************** FAILURE CreateShared: client count = %ld\n", globalOpenGLData.oglClientCount);
        OglUnmapGlobalPageAddress(ppdev, clientInfo->oglGlobalPagePtr);
        OglUnmapPFifoAddress(ppdev, clientInfo->pfifoAddress);
        OglUnmapPBusAddress(ppdev, clientInfo->pbusAddress);
        OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
        return;
        }

    //
    // Save driver object and mode switch count.
    //
    clientInfo->hDrvObj         = hDrvObj;
    clientInfo->modeSwitchCount = ppdev->dwGlobalModeSwitchCount;

    OglDebugPrint("CreateShared = 0x%p 0x%p\n", ppdev, clientInfo);
    }

//******************************************************************************
//
//  Function:   DestroySharedClientInfo
//
//  Routine Description:
//
//        This routine is used to unmap the memory and destroy the client node.
//        The node is removed from the list and the GDI tracking of the object
//        is deleted.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void DestroySharedClientInfo(
PDEV *ppdev, 
ULONG hClient, 
ULONG processHandle, 
PVOID globalData, 
ULONG deleteFlag)
    {
    int i;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    long status;

    OglDebugPrint("DestroySharedClientInfo = 0x%p %ld 0x%p\n", ppdev, processHandle, globalData);

    clientList = OglFindClientInfoGlobalData(ppdev, processHandle, globalData);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }

    if (clientInfo && clientInfo->flags & NV_OGL_CLIENT_SHARED_INFO)
        {
        //
        // Free channel and such.
        //
        NvFree(ppdev->hDriver, hClient, NV01_NULL_OBJECT, hClient);

        //
        // Free page mappings from display driver to client.
        //
        OglUnmapGlobalPageAddress(ppdev, clientInfo->oglGlobalPagePtr);
        OglUnmapPFifoAddress(ppdev, clientInfo->pfifoAddress);
        OglUnmapPBusAddress(ppdev, clientInfo->pbusAddress);

        clientInfo->processHandle    = 0;    // just for good measure...
        clientInfo->oglGlobalPagePtr = NULL; // just for good measure...
        clientInfo->pfifoAddress     = NULL; // just for good measure...
        clientInfo->pbusAddress      = NULL; // just for good measure...

        //
        // Mark it as freed.
        //
        clientInfo->flags &= ~NV_OGL_CLIENT_SHARED_INFO;

        if (deleteFlag)
            {
            //
            // Delete driver object if possible
            //
            if (OglEngDeleteDriverObj(ppdev, clientInfo, NV_OGL_CLIENT_SHARED_INFO) == TRUE)
                {
                OglDebugPrint("****************** DestroyShared: client count = %ld\n", globalOpenGLData.oglClientCount);
                }
            }

        OglDebugPrint("DestroyShared = 0x%p 0x%p\n", ppdev, clientInfo);
        }
    }

//******************************************************************************
//
//  Function:   ClientSharedDrvFreeObj
//
//  Routine Description:
//
//      This routine is the callback for freeing the driver object.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the resources are freed.
//
//******************************************************************************
BOOL CALLBACK ClientSharedDrvFreeObj(
    DRIVEROBJ *pDriverObj
)
    {
    NV_OPENGL_CLIENT_INFO *clientInfo;
    LONG                  status;
    int                   i, clientIndex;
    PDEV                  *ppdev;

    clientInfo = (NV_OPENGL_CLIENT_INFO *)pDriverObj->pvObj;
    ppdev = (PDEV *)pDriverObj->dhpdev;

    OglAcquireGlobalMutex();
    OglDebugPrint("SHARED ***************** SHARED DrvFreeObj = 0x%p 0x%p\n", ppdev, clientInfo);

    if (OglFindClientListFromClientInfo(ppdev, clientInfo) == NULL)
        {
        // clientInfo was removed from clientList prior to this callback
        // just return because there is nothing to do...
        OglReleaseGlobalMutex();
        return(TRUE);
        }

    //
    // Cleanup client info.
    //
    if (clientInfo->flags & NV_OGL_CLIENT_SHARED_INFO)
        {
        try
            {
            DestroySharedClientInfo(ppdev, clientInfo->hClient, clientInfo->processHandle, clientInfo->oglGlobalPagePtr, FALSE);
            }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
            status = GetExceptionCode();
            DISPDBG((1, "DestroySharedClientInfo: exception = 0x%lx", status));
            OglReleaseGlobalMutex();
            return(TRUE);
            }
        clientInfo->flags &= ~NV_OGL_CLIENT_SHARED_INFO;
        clientInfo->processHandle    = 0;    // just for good measure...
        clientInfo->hClient          = 0;    // just for good measure...
        clientInfo->oglGlobalPagePtr = NULL; // just for good measure...
        clientInfo->pfifoAddress     = NULL; // just for good measure...
        }

    clientInfo->hDrvObj = 0;
    clientInfo->flags   = 0;

    //
    // Remove from global client list.
    //
    OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));

    //
    // Decrement client count.
    //
    OglDebugPrint("****************** Shared CALLBACK: client count = %ld\n", globalOpenGLData.oglClientCount);

    OglReleaseGlobalMutex();

    return(TRUE);
}

//******************************************************************************
//
//  Function:   OglMapGlogalPageAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the kernel, system
//      address for the shared information into the caller's address space.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
BOOL OglMapGlobalPageAddress(
PDEV *ppdev, 
PVOID *globalData
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "OglMapGlobalPageAddress - Entry"));

    *globalData = NULL;

    sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL     = TRUE;
    sysmemShareMemoryIn.physicalAddress    = 0;
    sysmemShareMemoryIn.userVirtualAddress = (PVOID)NULL;

    sysmemShareMemoryIn.ddVirtualAddress   = (PVOID)ppdev->oglGlobalPagePtr;
    sysmemShareMemoryIn.byteLength         = ppdev->oglGlobalPageSize;

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_MAP_TO_USER,
        &sysmemShareMemoryIn,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &sysmemShareMemoryOut,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &dwReturnedDataLength))
    {
        *globalData = (PVOID)NULL;
        DISPDBG((2, "OglMapGlobalPageAddress - IOCTL_VIDEO_MAP_TO_USER failed"));
        return(FALSE);
    }

    // save user address in shared info structure
    *globalData = (PVOID)sysmemShareMemoryOut.userVirtualAddress;

    DISPDBG((2, "OglMapGlobalPageAddress - Exit"));

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglUnmapGlobalPageAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the user virtual address
//      into system address space where the display driver can get to it.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
BOOL OglUnmapGlobalPageAddress(
PDEV *ppdev, 
PVOID globalData
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;
    LONG status;

    DISPDBG((2, "OglUnmapGlobalPageAddress - Entry"));

    if (globalData)
        {
        sysmemShareMemoryIn.userVirtualAddress = (PVOID)globalData;
        sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl;
        sysmemShareMemoryIn.bDontModifyMDL     = TRUE;  // miniport will NOT free MDL

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_UNMAP_FROM_USER,
            &sysmemShareMemoryIn,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &sysmemShareMemoryOut,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &dwReturnedDataLength))
            {
            DISPDBG((2, "OglUnmapGlobalPageAddress - IOCTL_VIDEO_UNMAP_FROM_USER failed"));
            }
        }
    else
        {
        DISPDBG((2, "OglUnmapGlobalPageAddress - globalData NULL"));
        }

    DISPDBG((2, "OglUnmapGlobalPageAddress - Exit"));
    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglMapPFifoAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the NV FIFO into the client.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
BOOL OglMapPFifoAddress(
PDEV *ppdev, 
PVOID *pfifoAddress
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn;
    ULONG  returnedDataLength;

    *pfifoAddress = NULL;

    memset(&sysmemShareMemoryIn, 0, sizeof(NV_SYSMEM_SHARE_MEMORY));
    sysmemShareMemoryIn.pSystemMdl     = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL = TRUE;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_NV_PFIFO_USER,
                           &sysmemShareMemoryIn, // not really used in mapping...
                           sizeof(HANDLE),
                           (PULONG)pfifoAddress,
                           sizeof(PULONG),
                           &returnedDataLength))
        {
        DISPDBG((2, "MapPFifoAddress - can't map NV PFIFO"));
        return(FALSE);
        }

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglUnmapPFifoAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to unmap the NV FIFO from the client.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the unmapping was a success.
//
//******************************************************************************
BOOL OglUnmapPFifoAddress(
PDEV *ppdev, 
PVOID pfifoAddress
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG                  returnedDataLength;

    if (pfifoAddress)
        {
        sysmemShareMemoryIn.userVirtualAddress = ((ULONG *)pfifoAddress);
        sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl;
        sysmemShareMemoryIn.bDontModifyMDL     = TRUE;  // miniport will NOT free MDL
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_NV_PFIFO_USER,
                               &sysmemShareMemoryIn,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               (PULONG) &sysmemShareMemoryOut,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               &returnedDataLength))
            {
            DISPDBG((2, "UnmapPFifoAddress - can't unmap NV PFIFO"));
            return(FALSE);
            }
        }
    else
        {
        DISPDBG((2, "UnmapPFifoAddress - pfifoAddress NULL"));
        }

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglMapPBusAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the NV PCI bus registers
//      into the client.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
BOOL OglMapPBusAddress(
PDEV *ppdev, 
PVOID *pbusAddress
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn;
    ULONG  returnedDataLength;

    *pbusAddress = NULL;

    memset(&sysmemShareMemoryIn, 0, sizeof(NV_SYSMEM_SHARE_MEMORY));
    sysmemShareMemoryIn.pSystemMdl     = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL = TRUE;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_NV_PBUS_USER,
                           &sysmemShareMemoryIn, // not really used in mapping...
                           sizeof(HANDLE),
                           (PULONG)pbusAddress,
                           sizeof(PULONG),
                           &returnedDataLength))
        {
        DISPDBG((2, "MapPBusAddress - can't map NV PBUS"));
        return(FALSE);
        }

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   OglUnmapPBusAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to unmap the NV PCI bus registers
//      from the client.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the unmapping was a success.
//
//******************************************************************************
BOOL OglUnmapPBusAddress(
PDEV *ppdev, 
PVOID pbusAddress
)
    {
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG                  returnedDataLength;

    if (pbusAddress)
        {
        sysmemShareMemoryIn.userVirtualAddress = ((ULONG *)pbusAddress);
        sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl;
        sysmemShareMemoryIn.bDontModifyMDL     = TRUE;  // miniport will NOT free MDL
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNMAP_NV_PBUS_USER,
                               &sysmemShareMemoryIn,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               (PULONG) &sysmemShareMemoryOut,
                               sizeof(NV_SYSMEM_SHARE_MEMORY),
                               &returnedDataLength))
            {
            DISPDBG((2, "UnmapPBusAddress - can't unmap NV PBUS"));
            return(FALSE);
            }
        }
    else
        {
        DISPDBG((2, "UnmapPBusAddress - pbusAddress NULL"));
        }

    return(TRUE);
    }

#if DBG
//******************************************************************************
//
//  Function:   OglVerifyClientList
//
//  Routine Description:
//
//      This is a debug routine that walks the client linked list and verifies
//      that the count equals the client count.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the count are equal.
//
//******************************************************************************
BOOL OglVerifyClientList(
PDEV *ppdev,
char *s
)
    {
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;
    ULONG i;

    i = 0;
    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        i++;
        node = node->next;
        }
    OglDebugPrint(">>>>>>>>>> %s clientCount = %ld ? %ld\n", s, globalOpenGLData.oglClientCount, i);
    return((BOOL)(i == globalOpenGLData.oglClientCount));
    }
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglclip.h ===
#ifndef _OGLCLIP_H
#define _OGLCLIP_H
//******************************Module*Header***********************************
// Module Name: oglclip.h
//
// OpenGL server side clip management
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

BOOL bOglNegativeClipListCreate(PPDEV ppdev);
BOOL bOglNegativeClipListDestroy(PPDEV ppdev);
BOOL bOglNegativeClipListUpdate(PPDEV ppdev, struct _WNDOBJ *pwo);
BOOL bOglClientIntersectingWithOtherClients(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
void OglClipRectToScreen(RECTL *rect, LONG cxScreen, LONG cyScreen);
void OglCopyClipListToDrawableInfo(PDEV *ppdev, WNDOBJ *pwo, FLONG fl, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
BOOL bOglClipRectAgainstClipobj(
    IN  CLIPOBJ *pco, 
    IN  RECTL   *prcl);
BOOL bOglClipBoundsUpdate(struct _OGLSERVER *pOglServer);
void CombineRectLists(RECTL *rectList1, ULONG count1, 
                      RECTL *rectList2, ULONG count2,
                      LONG  leftList2, LONG topList2,
                      RECTL *resultList, ULONG *resultCount);

#define COPY_RECT(_DST, _SRC) \
    _DST.left = _SRC.left; \
    _DST.right = _SRC.right; \
    _DST.top = _SRC.top; \
    _DST.bottom = _SRC.bottom;


#endif // _OGLCLIP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\nvsetdac.c ===
/************************** Module Header *************************************
 *                                                                             *
 *  Module Name: nvsetdac.c                                                    *
 *                                                                             *
 *                                                                             *
 *   Copyright (C) 1997-present NVidia Corporation. All Rights Reserved.       *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "ddminint.h"
#include "dmamacro.h"
#include "nvcm.h"

extern VOID NV4_DmaPushSend(PDEV *);
extern VOID NV_DmaPush_CheckWrapped(PDEV *, ULONG );
extern VOID NV_DmaPush_Wrap(PDEV *, ULONG );
extern ULONG GetPrevDevMaskRegValue(PPDEV ppdev);
extern VOID SetPrevDevMaskRegValue(PPDEV ppdev, ULONG ulVal);
extern BOOLEAN GetULONGRegValue(PPDEV ppdev, char *pcKeyName, ULONG *pulData);

// Enable Double Scan for height <= this value
#define HEIGHT_ENABLE_DOUBLE_SCAN       384

BOOL __cdecl NvSetDac(PDEV *ppdev, ULONG ulHead, RESOLUTION_INFO * pResolution)
{
	DAC_TIMING_VALUES sTimingDac;
    HEAD_RESOLUTION_INFO HeadResolution;
    DWORD ReturnedDataLength;
    DWORD ulFormat = 0;


    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    //
    // Fill up the head resolution info structure used for the common modeset code.
    //
    HeadResolution.ulDisplayWidth = pResolution->ulDisplayWidth;
    HeadResolution.ulDisplayHeight= pResolution->ulDisplayHeight;  	
    HeadResolution.ulDisplayRefresh = pResolution->ulDisplayRefresh;  	
    
    HeadResolution.ulHead = ulHead;              
    HeadResolution.ulDeviceMask = ppdev->ulDeviceMask[ulHead];        
    HeadResolution.ulDeviceType = ppdev->ulDeviceType[ulHead];        
    HeadResolution.ulTVFormat = ppdev->ulTVFormat[ulHead];
    HeadResolution.ulOption = HEAD_RESOLUTION_OPTION_DONT_BACKOFF;
    switch (pResolution->ulDisplayPixelDepth)
    {
        case BMF_32BPP:
            HeadResolution.ulDisplayPixelDepth = 32;
            break;
        case BMF_16BPP:
            HeadResolution.ulDisplayPixelDepth = 16;
            break;
        case BMF_8BPP:
            HeadResolution.ulDisplayPixelDepth = 8;
            break;
        default:
            DISPDBG((0,"Oops! Invalid color depth: 0x%x\n",pResolution->ulDisplayPixelDepth));
            return(FALSE);
    }


    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_GET_TIMING_DAC,
                           &HeadResolution,  // input buffer
                           sizeof(HEAD_RESOLUTION_INFO),
                           &sTimingDac,
                           sizeof(DAC_TIMING_VALUES),
                           &ReturnedDataLength))
    {
    	DISPDBG((0, "nvsetdac.c - IOCTL_VIDEO_GET_TIMING_DAC failed"));
		return FALSE;
    }

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_PREMODE_SET,
                           &ulHead,  // input buffer
                           sizeof(ULONG),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
    	DISPDBG((0, "nvsetdac.c - IOCTL_VIDEO_PREMODE_SET failed"));
		return FALSE;
    }

    DISPDBG((1,"\nNvSetDac() headResolutionInfo: ........................................."));

    DISPDBG((1,"    ulDisplayWidth: %d",HeadResolution.ulDisplayWidth));
    DISPDBG((1,"    ulDisplayheight: %d",HeadResolution.ulDisplayHeight));
    DISPDBG((1,"    ulDisplayRefresh: %d",HeadResolution.ulDisplayRefresh));
    DISPDBG((1,"    ulDisplayPixelDepth: %d",HeadResolution.ulDisplayPixelDepth));
    DISPDBG((1,"    ulHead: %d",HeadResolution.ulHead));
    DISPDBG((1,"    ulDeviceMask: 0x%x",HeadResolution.ulDeviceMask));
    DISPDBG((1,"    ulDeviceType: %d",HeadResolution.ulDeviceType));
    DISPDBG((1,"    ulTVFormat: %d",HeadResolution.ulTVFormat));
    DISPDBG((1,""));

    DISPDBG((1,"TimingParameters: "));
    DISPDBG((1,"    sTimingDac.HorizontalVisible: 0x%x",sTimingDac.HorizontalVisible));
    DISPDBG((1,"    sTimingDac.VerticalVisible: 0x%x",sTimingDac.VerticalVisible));
    DISPDBG((1,"    sTimingDac.Refresh: 0x%x",sTimingDac.Refresh));
    DISPDBG((1,"    sTimingDac.HorizontalTotal: 0x%x",sTimingDac.HorizontalTotal));
    DISPDBG((1,"    sTimingDac.VerticalTotal: 0x%x",sTimingDac.VerticalTotal));
    DISPDBG((1,"    sTimingDac.HorizontalBlankStart: 0x%x",sTimingDac.HorizontalBlankStart));
    DISPDBG((1,"    sTimingDac.VerticalBlankStart: 0x%x",sTimingDac.VerticalBlankStart));
    DISPDBG((1,"    sTimingDac.HorizontalRetraceStart: 0x%x",sTimingDac.HorizontalRetraceStart));
    DISPDBG((1,"    sTimingDac.VerticalRetraceStart: 0x%x",sTimingDac.VerticalRetraceStart));
    DISPDBG((1,"    sTimingDac.HorizontalRetraceEnd: 0x%x",sTimingDac.HorizontalRetraceEnd));
    DISPDBG((1,"    sTimingDac.VerticalRetraceEnd: 0x%x",sTimingDac.VerticalRetraceEnd));
    DISPDBG((1,"    sTimingDac.HorizontalBlankEnd: 0x%x",sTimingDac.HorizontalBlankEnd));
    DISPDBG((1,"    sTimingDac.VerticalBlankEnd: 0x%x",sTimingDac.VerticalBlankEnd));
    DISPDBG((1,"    sTimingDac.PixelClock: 0x%x",sTimingDac.PixelClock));
    DISPDBG((1,"    sTimingDac.HSyncpolarity: 0x%x",sTimingDac.HSyncpolarity));
    DISPDBG((1,"    sTimingDac.VSyncpolarity: 0x%x",sTimingDac.VSyncpolarity));

    
    DISPDBG((1,"NvSetDac() End........................................................\n"));

#if _WIN32_WINNT >= 0x0500

    // setup mode set using DMA push channel
    
    NV_DMAPUSH_CHECKFREE(( (ULONG) (20) ));  

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_NOTIFIES, NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_IMAGE_SIZE(0), (sTimingDac.VerticalVisible << 16) | sTimingDac.HorizontalVisible);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_HORIZONTAL_BLANK(0), sTimingDac.HorizontalBlankStart | 
                                                ((sTimingDac.HorizontalBlankEnd -   sTimingDac.HorizontalBlankStart ) << 16));


    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_HORIZONTAL_SYNC(0),  sTimingDac.HorizontalRetraceStart | 
                                                ((sTimingDac.HorizontalRetraceEnd - sTimingDac.HorizontalRetraceStart ) << 16));

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_VERTICAL_BLANK(0), sTimingDac.VerticalBlankStart | 
                                                ((sTimingDac.VerticalBlankEnd -   sTimingDac.VerticalBlankStart ) << 16));
                                                                        
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_VERTICAL_SYNC(0),  sTimingDac.VerticalRetraceStart | 
                                                ((sTimingDac.VerticalRetraceEnd - sTimingDac.VerticalRetraceStart ) << 16));

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_TOTAL_SIZE(0),  sTimingDac.VerticalTotal << 16 | sTimingDac.HorizontalTotal);

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_PIXEL_CLOCK(0), sTimingDac.PixelClock);

#else

    // setup mode set using Direct Method Call
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_CONTEXT_DMA_NOTIFIES,
            NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set context DMA notifies"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_IMAGE_SIZE(0),
            (sTimingDac.VerticalVisible << 16) | sTimingDac.HorizontalVisible
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC image size"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_HORIZONTAL_BLANK(0),
            sTimingDac.HorizontalBlankStart | ((sTimingDac.HorizontalBlankEnd - sTimingDac.HorizontalBlankStart) << 16)
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC horizontal blank"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_HORIZONTAL_SYNC(0),
            sTimingDac.HorizontalRetraceStart | ((sTimingDac.HorizontalRetraceEnd - sTimingDac.HorizontalRetraceStart) << 16)
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC horizontal sync"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_VERTICAL_BLANK(0),
            sTimingDac.VerticalBlankStart | ((sTimingDac.VerticalBlankEnd - sTimingDac.VerticalBlankStart) << 16)
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC vertical blank"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_VERTICAL_SYNC(0),
            sTimingDac.VerticalRetraceStart | ((sTimingDac.VerticalRetraceEnd - sTimingDac.VerticalRetraceStart) << 16)
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC vertical sync"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_TOTAL_SIZE(0),
            sTimingDac.VerticalTotal << 16 | sTimingDac.HorizontalTotal
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC total size"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_PIXEL_CLOCK(0),
            sTimingDac.PixelClock
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC pixel clock"));
    }
        
#endif // _WIN32_WINNT >= 0x0500

    if (sTimingDac.VerticalVisible <= HEIGHT_ENABLE_DOUBLE_SCAN)
    {
        ulFormat |= NV046_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED;
    }

    // map to VIDEO_LUT_CURSOR_DAC class values
    if((sTimingDac.HSyncpolarity == 1) || (sTimingDac.HSyncpolarity == 4))
        sTimingDac.HSyncpolarity = NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE;
    else
        sTimingDac.HSyncpolarity = NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE;

    if((sTimingDac.VSyncpolarity == 1) || (sTimingDac.VSyncpolarity == 8))
        sTimingDac.VSyncpolarity = NV046_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE;
    else
        sTimingDac.VSyncpolarity = NV046_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE;

    ulFormat |= (sTimingDac.HSyncpolarity << 2);
    ulFormat |= (sTimingDac.VSyncpolarity << 3);
    ulFormat |= (ulHead << 26);

    switch (pResolution->ulDisplayPixelDepth)
    {
        case BMF_32BPP:
            ulFormat |= (NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8 << 16);
            break;
        case BMF_16BPP:
            ulFormat |= (NV046_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5 << 16);
            break;
        case BMF_8BPP:
            ulFormat |= (NV046_SET_DAC_FORMAT_COLOR_LUT_LE_Y8 << 16);
            break;
        default:
            return(FALSE);
    }

    switch(ppdev->ulDeviceType[ulHead])
    {
        case MONITOR_TYPE_VGA:
            ulFormat |= (NV046_SET_DAC_FORMAT_DISPLAY_TYPE_CRT << 20);
            break;
        case MONITOR_TYPE_NTSC:      
        case MONITOR_TYPE_PAL:       
            ulFormat |= (NV046_SET_DAC_FORMAT_DISPLAY_TYPE_TV << 20);
            ulFormat |= ((ppdev->ulTVFormat[ulHead] & 0x07) << 22);
            break;
        case MONITOR_TYPE_FLAT_PANEL:
            ulFormat |= (NV046_SET_DAC_FORMAT_DISPLAY_TYPE_DFP << 20);
            break;
        case INVALID_DEVICE_TYPE:
            DISPDBG((0,"Oops! Invalid device type for Head: %d. Lets assume a CRT",ulHead));
            ulFormat |= (NV046_SET_DAC_FORMAT_DISPLAY_TYPE_CRT << 20);
            break;
    }

    // Specify if this head is the 'primary' head or not.
    if (ulHead == ppdev->ulDeviceDisplay[0] && ppdev->ulDualViewSecondary == 0)
    {
        // This is the primary head.
        ulFormat |= (NV07C_SET_DAC_FORMAT_PRIMARY_DEVICE_TRUE << 28);
    }
    else
    {
        // This is not the primary head so make sure the bit is turned off.
        ulFormat |= (NV07C_SET_DAC_FORMAT_PRIMARY_DEVICE_FALSE << 28);
    }


#if _WIN32_WINNT >= 0x0500

    // perform mode set using DMA push channel
    
    ulFormat |= (NV046_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY << 31);
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_DAC(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_DAC_FORMAT(0), ulFormat);


    //**************************************************************************
    // Make sure to update the DMA count before we kickoff!
    //**************************************************************************

    UPDATE_PDEV_DMA_COUNT;

    //**************************************************************************
    // Initialize patch
    //**************************************************************************
    NV4_DmaPushSend(ppdev);

    // Wait for the mode is set.
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_DAC(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    
#else

    // perform mode set using Direct Method Call -- no notification needed
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_DAC_FORMAT(0),
            ulFormat
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set DAC format"));
    }
        
#endif // _WIN32_WINNT >= 0x0500

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_POSTMODE_SET,
                           &ulHead,  // input buffer
                           sizeof(ULONG),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
    	DISPDBG((1, "nvsetdac.c - IOCTL_VIDEO_POSTMODE_SET failed"));
		return FALSE;
    }

#if _WIN32_WINNT >= 0x0500

    // Setup the DMA context of LUT using DMA channel
    NV_DMAPUSH_CHECKFREE(( (ULONG) (2) ));  
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_LUT(0), NV_WIN_COLORMAP_CONTEXT+ulHead);
    
#else

    // setup the DMA context of LUT using Direct Method Call
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_CONTEXT_DMA_LUT(0),
            NV_WIN_COLORMAP_CONTEXT + ulHead
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set LUT offset"));
    }
        
#endif // _WIN32_WINNT >= 0x0500
    
    // Since the VIDEO can call this function directly, the gamma values will be set multiple times.
    if (pResolution->ulDisplayPixelDepth != BMF_8BPP)
    {
        if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_RESTORE_GAMMA_VALUES,
                           NULL,
                           0,
                           ppdev->ajClutData,  
                           sizeof(NV_VIDEO_CLUTDATA) * NV_NO_DACS * 256,
                           &ReturnedDataLength))
        {
    	    DISPDBG((1, "nvsetdac.c - IOCTL_VIDEO_POSTMODE_SET failed"));
        }
    }
    
    
        // Cannot call un-initialized function ppdev->pfnSetPalette
#if _WIN32_WINNT >= 0x0500

    // setup LUT using DMA push channel
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_OFFSET(0), 0);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_LUT_FORMAT(0), NV046_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY);
    UPDATE_PDEV_DMA_COUNT;
    NV4_DmaPushSend(ppdev);
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    
#else

    // setup LUT using Direct Method Call -- no notification needed
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_LUT_OFFSET(0),
            0
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set LUT offset"));
    }
    if (
        NvDirectMethodCall(
            ppdev->hDriver,
            ppdev->hClient,
            ppdev->hDmaChannel,
            NV_VIDEO_LUT_CURSOR_DAC + ulHead,
            NV046_SET_LUT_FORMAT(0),
            0                                   // don't need notification w/DMC
        ) != NVOS1D_STATUS_SUCCESS
    )
    {
        DISPDBG((2, "NVDD: Cannot perform set LUT format"));
    }
        
#endif // _WIN32_WINNT >= 0x0500



    return(TRUE);

}

BOOL NvInitialDac(PDEV *ppdev)
{

    NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;
    RESOLUTION_INFO Res;
    ULONG i;
    ULONG ulHead;
    PVOID parms;
    ULONG ulDisplayWidth, ulDisplayHeight, ulOldValue;
    ULONG ulCombinedMask;
    ULONG ulPrimaryHead;
    NV_CFGEX_DISPLAY_CHANGE_START_PARAMS BracketParams;
    ULONG ulPanOffset;
    ULONG ulPrevDevMask;
    BOOLEAN bDoBracketing = FALSE;
    ULONG ulStopImage;
    
    DECLARE_DMA_FIFO;

    INIT_LOCAL_DMA_FIFO;

    DISPDBG((1, "\nNvInitializeDAC: ppdev = 0x%08x", ppdev));
    DISPDBG((1, "ppdev->pjScreen               = 0x%08x", ppdev->pjScreen));
    DISPDBG((1, "ppdev->ulPrimarySurfaceOffset = 0x%08x", ppdev->ulPrimarySurfaceOffset));
    DISPDBG((1, "ppdev->pjFrameBufbase         = 0x%08x", ppdev->pjFrameBufbase));


    // We need to let resman know a combined mask for the devices that ae going to
    // be used in this mode.
    ulCombinedMask = 0;
    for (i = 0;
         i < ((ppdev->TwinView_State == NVTWINVIEW_STATE_NORMAL) ? ppdev->ulNumberDacsActive : ppdev->ulNumberDacsConnected);
         i++)
    {
        ulHead = ppdev->ulDeviceDisplay[i];
        ulCombinedMask |= ppdev->ulDeviceMask[ulHead];
    }
    BracketParams.NewDevices = (ulCombinedMask | NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET);
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_SPAN)
    {
        BracketParams.Properties = 1;
    }
    else
    {
        BracketParams.Properties = 0;
    }

    ulPrevDevMask = GetPrevDevMaskRegValue(ppdev);

    if (ulPrevDevMask == 0)
    {
        //
        // we are booting up, so we need to do the bracketing.
        //
        bDoBracketing = TRUE;
    }
    else
    if (ulPrevDevMask != ulCombinedMask)
    {
        //
        // the previous mode dev mask is different than the new mode device mask, so we need to do the bracketing.
        //
        bDoBracketing = TRUE;
    }


    if (bDoBracketing)
    {
        DISPDBG((1, "Doing the modeset bracketing: PrevDevMask: 0x%x, CurrentMask: 0x%x",ulPrevDevMask, ulCombinedMask));
    }
    else
    {
        DISPDBG((1, "Not Doing the modeset bracketing: PrevDevMask: 0x%x, CurrentMask: 0x%x",ulPrevDevMask, ulCombinedMask));
    }
   
    
    if (bDoBracketing)
    {
        // Let ResMan know we are starting the modeset process for the LUT_CURSOR objects.
        if (NvConfigSetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                         NV_CFGEX_DISPLAY_CHANGE_START, &BracketParams, sizeof(BracketParams))) {
            ASSERTDD(1,"Error in Notifying Start bracket of modeset to ResMan");
        }
    }
    else
    {
        if (ppdev->TwinView_State == NVTWINVIEW_STATE_SPAN || ppdev->TwinView_State == NVTWINVIEW_STATE_DUALVIEW)
        {
            if (NvConfigSet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_DISPLAY_CHANGE_CONFIG, 1, &ulOldValue)) 
            {
                    ASSERTDD(1,"Error in Setting NV_CFG_DISPLAY_CHANGE_CONFIG");
            }
        }
        else
        {
            if (NvConfigSet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_DISPLAY_CHANGE_CONFIG, 0, &ulOldValue)) 
            {
                    ASSERTDD(1,"Error in Setting NV_CFG_DISPLAY_CHANGE_CONFIG");
            }
        }
    }

    // Initialize status of all Notifiers to "nothing pending"
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_DAC(0)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_LUT(0)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_CURSOR_IMAGE(0)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_CURSOR_IMAGE(1)*sizeof(NvNotification)])))->status = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    
    Res.ulDisplayPixelDepth = ppdev->cBitsPerPel;

    for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        NV_CREATE_OBJECT_SETUP();

        ulHead = ppdev->ulDeviceDisplay[i];

        if (ulHead > 0) {
            nv07cAllocParms.logicalHeadId = ulHead;
            parms = &nv07cAllocParms;
        } else {
            parms = NULL;
        }
        NV_CREATE_OBJECT_INIT();
        // NV5 will use NV04_VIDEO_LUT_CURSOR_DAC class because the method offset of NV05_VIDEO_LUT_CURSOR_DAC 
        // is different from other NV??_VIDEO_LUT_CURSOR_DAC classes.
        NV_CREATE_DMA3(parms,NV_VIDEO_LUT_CURSOR_DAC+ulHead, 
                       NV15_VIDEO_LUT_CURSOR_DAC,NV10_VIDEO_LUT_CURSOR_DAC,
                       NV04_VIDEO_LUT_CURSOR_DAC);
        if (NV_CREATE_OBJECT_FAIL()) {
            return (FALSE);
        } else {
            ppdev->CurrentClass.VideoLutCursorDac = NV_CREATE_OBJECT_CLASS();
        }

        Res.ulDisplayWidth = ppdev->rclCurrentDisplay[ulHead].right - ppdev->rclCurrentDisplay[ulHead].left;
        Res.ulDisplayHeight = ppdev->rclCurrentDisplay[ulHead].bottom - ppdev->rclCurrentDisplay[ulHead].top;
        Res.ulDisplayRefresh = ppdev->ulRefreshRate[ulHead];  
        Res.ulDisplayPixelDepth = ppdev->iBitmapFormat;

        NV_DMAPUSH_CHECKFREE( ((ULONG)(4)));
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_IMAGE(0), DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);

        UPDATE_PDEV_DMA_COUNT;
        NvSetDac(ppdev, ulHead, &Res);
    	UPDATE_LOCAL_DMA_COUNT;

         // Wait for previous image completed
        ppdev->ulHeadDisplayOffset[ulHead] = ppdev->rclDisplayDesktop[ulHead].left * ppdev->cjPelSize + ppdev->rclDisplayDesktop[ulHead].top * ppdev->lDelta
                                             + ppdev->ulPrimarySurfaceOffset;
        ulPanOffset = ppdev->rclCurrentDisplay[ulHead].left * ppdev->cjPelSize + ppdev->rclCurrentDisplay[ulHead].top * ppdev->lDelta 
                                             + ppdev->ulPrimarySurfaceOffset - ppdev->ulHeadDisplayOffset[ulHead];

        DISPDBG((1, "ppdev->ulHeadDisplayOffset[%d] = 0x%08x", ulHead, ppdev->ulHeadDisplayOffset[ulHead]));
        DISPDBG((1, "ulPanOffset = 0x%08x", ulPanOffset));

        while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
        ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
        NV_DMAPUSH_CHECKFREE( ((ULONG)(6)));
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_OFFSET(0), ppdev->ulHeadDisplayOffset[ulHead]);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_PAN_OFFSET, ulPanOffset);
        NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_IMAGE_FORMAT(0),
                          ppdev->lDelta | NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31);
        
        //**************************************************************************
        // Make sure to update the DMA count before we kickoff!
        //**************************************************************************

        UPDATE_PDEV_DMA_COUNT;
        NV4_DmaPushSend(ppdev);
    }


    if (NvConfigSet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_SCREEN_WIDTH, ppdev->cxScreen, &ulOldValue)) {
        ASSERTDD(1,"Error in Setting DAC");
    }


    if (NvConfigSet (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                     NV_CFG_SCREEN_HEIGHT, ppdev->cyScreen, &ulOldValue)) {
        ASSERTDD(1,"Error in Setting DAC");
    }

    NV_DMAPUSH_CHECKFREE( ((ULONG)(6)));
    ulPrimaryHead = ppdev->ulDeviceDisplay[0];
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC+ulPrimaryHead);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_NOTIFY, NV046_NOTIFY_WRITE_ONLY);
    NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_IMAGE(0), DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM);
    

    //**************************************************************************
    // Make sure to update the DMA count before we kickoff!
    //**************************************************************************
    UPDATE_PDEV_DMA_COUNT;

    // Set up the notifier after waitinf for any existing notification to finish.
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
    ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

    NV4_DmaPushSend(ppdev);

    // Now wait for the DMA to complete.
    while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);

    if (bDoBracketing)
    {
        // Let ResMan know we are finished with the modeset process for the LUT_CURSOR objects.
        if (NvConfigSetEx (ppdev->hDriver, ppdev->hClient, ppdev->hDevice,
                         NV_CFGEX_DISPLAY_CHANGE_END, &BracketParams, sizeof(BracketParams))) {
            ASSERTDD(1,"Error in Notifying End bracket of modeset to ResMan");
        }
    }

    //
    // Now write the current modeset device mask to the registry as PrevDevMask.
    //
    SetPrevDevMaskRegValue(ppdev, ulCombinedMask);



    //
    // We need to in effect, defer this modeset if we have scheduled a modeset via NVSVC.
    // This way, the user does not 'see' two modesets happen. The cursor needs to be disabled too.
    // Currently we do this only for Win2K and later since we are not supporting laptops in NT4.0
    //
    ulStopImage = 0;
    if (ppdev->ulInduceModeChangeDeviceMask)
    {
        ulStopImage = 1;
    }

    //
    // If the ModesetStopImage feature for sony has been enabled and the registry entry tells us to
    // stop the image, we invoke the STOP_IMAGE method.
    //
    if (ppdev->EnableModesetStopImage)
    {
        ULONG ModesetStopImage = 0;
        GetULONGRegValue(ppdev, "ModesetStopImage", &ModesetStopImage);
        if (ModesetStopImage == 1)
        {
            ulStopImage = 1;
        }
    }
     
    //
    // stop the image if needed.    
    //
    if (ulStopImage)
    {   
        for(i = 0; i < ppdev->ulNumberDacsActive; i++)
        {
        
            ulHead = ppdev->ulDeviceDisplay[i];

            DISPDBG((1, "Stopping Image to defer the first modeset since NVSVC is scheduled for a modeset"));
            NV_DMAPUSH_CHECKFREE(( (ULONG) (8) ));  
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NVFFF_SET_OBJECT(0) ,   NV_VIDEO_LUT_CURSOR_DAC + ulHead);
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_SET_CONTEXT_DMA_NOTIFIES, NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER);

            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_NOTIFY, NV046_NOTIFY_WRITE_ONLY);
            NV_DMAPUSH_WRITE1(LUT_CURSOR_DAC_SUBCHANNEL, NV046_STOP_IMAGE(0), NV046_STOP_IMAGE_AS_SOON_AS_POSSIBLE);
            //**************************************************************************
            // Make sure to update the DMA count before we kickoff!
            //**************************************************************************
            UPDATE_PDEV_DMA_COUNT;
            // Set up the notifier after waitinf for any existing notification to finish.
            while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
            ((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;

            NV4_DmaPushSend(ppdev);

            // Now wait for the DMA to complete.
            while(((NvNotification *) (&(ppdev->Notifiers->VideoLutCursorDac[NV046_NOTIFIERS_NOTIFY*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);
        }
    }
    
    
    return(TRUE);
}

//**************************************************************************
// Restores DACs that may have been flipped by OpenGL to the primary surface
// PaulP
//**************************************************************************

void NvRestoreDacs(PDEV *ppdev)
{
    void __cdecl NVMoveDisplayWindow(PDEV* ppdev, ULONG ulHead, RECTL * prclCurrentDisplay);

    RECTL *prclCurrentDisplay;
    ULONG ulHead;
    ULONG i;

    if (ppdev->ulFlipBase != ppdev->ulPrimarySurfaceOffset)
    {
        ASSERT(OGL_FLIPPED());

        ppdev->ulFlipBase = ppdev->ulPrimarySurfaceOffset;

        for (i=0; i < ppdev->ulNumberDacsActive; i++)
        {
            ulHead = ppdev->ulDeviceDisplay[i];
            prclCurrentDisplay = &ppdev->rclCurrentDisplay[ulHead];
            NvSetDacImageOffset(ppdev, ulHead,
                ppdev->rclDisplayDesktop[ulHead].left * ppdev->cjPelSize + ppdev->rclDisplayDesktop[ulHead].top * ppdev->lDelta);
            #ifdef NV3
                // Pan and Scan feature is not supported in NV3.
            #else
                NVMoveDisplayWindow(ppdev, ulHead, prclCurrentDisplay);
            #endif
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglclip.c ===
/******************************Module*Header*******************************\
* Module Name: oglclip.c
*
* This module contains the functions to support the OpenGL client side
* window clip list processing.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"

#include "oglDD.h"
#include "oglOverlay.h"
#include "oglstereo.h"
#include "oglflip.h"
#include "oglclip.h"
#include "nvdoublebuf.h"

#include "oglutils.h"
#include "ogldebug.h"
#include "cliplist.h"
#include "rectutils.h"
#ifdef NV_MAIN_MULTIMON
#include "linkedlist.h"
#endif

#if (NVARCH >= 0x4)
#include "nvRegionShared.h"
#include "nvcom.h"          // drivers/common/inc
#include "nvtracecom.h"     // drivers/common/inc
#endif // (NVARCH >= 0x4)

#include "Nvcm.h"
//
// export
//

#define DBG_CLIPPED_MESSAGES 1
#undef DBG_CLIPPED_MESSAGES

extern VOID MagicDelay(void);
static void CopyClipListToDrawableInfo(PDEV *ppdev, WNDOBJ *pwo, FLONG fl, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
static void CopyClipListToOtherClients(PDEV *ppdev, WNDOBJ *pwo, FLONG fl, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);

#if (NVARCH >= 0x4)
// Internal functions that are only called from outside of this file
// These should only be called from __glNv10Flush...()
// Moved to nvRegionShared.h
extern void nvConvertRegionGL2NV(RegionPtr nvRegion, unsigned char useExclusive, 
                          __GLregionRect *inclusiveRects, int numInclusiveRects,
                          __GLregionRect *exclusiveRects, int numExclusiveRects,
                          __GLregionRect *boundingRect);
extern void nvConvertRegionNV2GL(RegionPtr nvRegion, unsigned char useExclusive,
                          __GLregionRect **inclusiveRects, int *numInclusiveRects,
                          __GLregionRect **exclusiveRects, int *numExclusiveRects);

#endif // (NVARCH >= 0x4)

static void OglBltBackDepthBuffer(PDEV *ppdev,
                NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
                RECTL *srcRect,
                RECTL *dstRect);

static RECTL nullRect = { 0,0,0,0 };

//******************************************************************************
//
//  Function:   CheckUbbWindowClip
//
//  Routine Description:
//
//
//  Arguments:
//
//      ppdev - pointer to PDEV
//      clientDrawableInfo - window and clip information
//
//  Return Value:
//
//      aint none!
//
//******************************************************************************
static ULONG
AreRectanglesIntersecting(
    RECT *r1, 
    RECT *r2
)
    {
    // it is easier to check fail cases where they do not intersect...
    if ((int)r1->bottom <= (int)r2->top) return FALSE;
    if ((int)r1->top >= (int)r2->bottom) return FALSE;
    if ((int)r1->left >= (int)r2->right) return FALSE;
    if ((int)r1->right <= (int)r2->left) return FALSE;

    return TRUE;
    }

//******************************************************************************
//
//  Function:   IsNullRect
//
//  Routine Description:
//
//      Verify rectangle is valid by checking for a 0,0,0,0 rectangle.
//
//  Arguments:
//
//  Return Value:
//
//      non-zero means it is a NULL rectangle
//
//******************************************************************************
static INLINE int IsNullRect(RECTL *rect)
{
    return rect->left >= rect->right || rect->top >= rect->bottom;
}

static void
CheckUbbWindowClip(
    PDEV *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
    {
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;
    ULONG                      fullyExposed;

    clientDrawableInfo->ubbWindowClipFlag = (ULONG)FALSE;
    if ((globalOpenGLData.oglClientListHead.clientList == NULL) ||
        (ppdev->bOglSingleBackDepthCreated == FALSE) || // Must be in UBB mode...
        (ppdev->DoubleBuffer.bEnabled && !ppdev->bOglOverlaySurfacesCreated) || // must disable ubbwinclip if pageflipping is enabled (front+back must look "same"), but when overlays are enabled we still do the ubbwinclip because mainplane+overlayplane live in  buffers, that are not visible (just copied from!)
        (IsNullRect((RECTL *)&clientDrawableInfo->rect) ||
        (clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED)))
        {
        return;
        }

    OglAcquireGlobalMutex();

    fullyExposed = (ULONG)TRUE;
    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        clientInfo = &node->clientInfo;
        if (bOglHasDrawableInfo(clientInfo) &&
            clientInfo->clientDrawableInfo != clientDrawableInfo &&
            clientInfo->clientDrawableInfo->hWnd != clientDrawableInfo->hWnd)
            {
            if (AreRectanglesIntersecting(&clientInfo->clientDrawableInfo->rect, &clientDrawableInfo->rect) == TRUE)
                {
                if (!(clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED))
                    {
                    // another OGL window intersects our window and it has some exposed pixels.
                    fullyExposed = (ULONG)FALSE;
                    }
                }
            }
        node = node->next;
        }

    clientDrawableInfo->ubbWindowClipFlag = fullyExposed;

    OglReleaseGlobalMutex();
    }

void OglTranslateCachedClipRectList(PDEV *ppdev,
                                    RECTL *srcRects, ULONG srcNumRects, 
                                    RECTL *destRects, ULONG *destNumRects,
                                    RECTL *boundingBox)
{
    ULONG ii;
    long windowLeft, windowTop;

    if (IsNullRect(&srcRects[0])) 
        {
        *destNumRects = 1;
        destRects[0] = nullRect;
        }
    else
        {
        windowLeft = boundingBox->left - ppdev->left;
        windowTop  = boundingBox->top - ppdev->top;
        for (ii = 0; ii < srcNumRects; ii++)
        {
            destRects[ii].left   = srcRects[ii].left   - windowLeft;
            destRects[ii].right  = srcRects[ii].right  - windowLeft;
            destRects[ii].top    = srcRects[ii].top    - windowTop;
            destRects[ii].bottom = srcRects[ii].bottom - windowTop;
        }
        *destNumRects = srcNumRects;
    }
}

/*
** OglTranslateClientRelativeRectListToDevice
** 
** Convert the client relative src rect list to 
** a desktop relative destination list.
** 
** FNicklisch 05.10.2000: New
*/ 
void OglTranslateClientRelativeRectListToDevice(
    PDEV *ppdev,
    RECTL *srcRects,     // src rects
    ULONG srcNumRects, 
    RECTL *destRects,    // dst rects
    ULONG *destNumRects,
    RECTL *boundingBox)  // bounding box for offset calculation
{
    ULONG ii;
    long windowLeft, windowTop;

    if (IsNullRect(&srcRects[0])) 
        {
        *destNumRects = 1;
        destRects[0] = nullRect;
        }
    else
        {
        windowLeft = boundingBox->left - ppdev->left;
        windowTop  = boundingBox->top - ppdev->top;
        for (ii = 0; ii < srcNumRects; ii++)
        {
            destRects[ii].left   = srcRects[ii].left   + windowLeft;
            destRects[ii].right  = srcRects[ii].right  + windowLeft;
            destRects[ii].top    = srcRects[ii].top    + windowTop;
            destRects[ii].bottom = srcRects[ii].bottom + windowTop;
        }
        *destNumRects = srcNumRects;
    }
}


//******************************************************************************
//
//  Function:   TranslateRectToScreen
//
//  Routine Description:
//
//      Use desktop left,top to translate rectangle to screen coordinates.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
static void TranslateRectToScreen(
PDEV *ppdev,
RECTL *rect
)
{
    //
    // In multi-monitor system, ppdev->left and ppdev->top are the
    // left and top edge of the display relative to the desktop.
    // For example, if we have 2 monitors, primary on left and secondary
    // on right, then for primary left,top = 0,0 and for secondary
    // left,top = right_edge_of_primary, 0.  In a  single monitor system
    // left,top always equals 0,0.
    //
    rect[0].left -= ppdev->left;
    rect[0].top -= ppdev->top;
    rect[0].right -= ppdev->left;
    rect[0].bottom -= ppdev->top;
}

static void
CopyClipListToOtherClients(PDEV *ppdev, WNDOBJ *pwo, FLONG fl, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_DRAWABLE_INFO    *nodeDrawableInfo = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        clientInfo = &node->clientInfo;
        nodeDrawableInfo = clientInfo->clientDrawableInfo; // drawable information for this client
        if (bOglHasDrawableInfo(clientInfo) &&
            (nodeDrawableInfo->hWnd == clientDrawableInfo->hWnd) &&
            (nodeDrawableInfo->hDC != clientDrawableInfo->hDC) &&
            (nodeDrawableInfo != clientDrawableInfo))
            {
            if (clientInfo->ppdev)
                {
                CopyClipListToDrawableInfo(clientInfo->ppdev, pwo, fl, nodeDrawableInfo);
                }
            else
                {
                CopyClipListToDrawableInfo(ppdev, pwo, fl, nodeDrawableInfo);
                }
            }
        node = node->next;
        }
}

//******************************************************************************
//
//  Function:   OglValidateDrawableInfo
//
//  Routine Description:
//
//      Walk the linked list of OpenGL nodes a verify that the drawable info
//      is in the list.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE if in list, FALSE otherwise
//
//******************************************************************************
BOOL OglValidateDrawableInfo(NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    BOOL bRet;

    bRet = FALSE;
    if (clientDrawableInfo)
    {
        NV_OPENGL_CLIENT_INFO *clientInfo;

        OglAcquireGlobalMutex();

        // Start at top of list
        clientInfo = NULL;
        while (bOglGetNextClient(&clientInfo))
            {
            ASSERT(bOglHasDrawableInfo(clientInfo));
            if (clientDrawableInfo == clientInfo->clientDrawableInfo)
                {
                bRet = TRUE;
                break;
                }
            }
        OglReleaseGlobalMutex();
    }
    return(bRet);
}


/*
** bWindowHasMoved
**
** checks window's old and new position rectangles and determines if
** moved only ( without resize )
** 
** Return value: FALSE: if window did not move only ( but resize or did not move )
**               TRUE:  if window moved but did not resize
**
** MSchwarz 09/29/2000: new
*/
BOOL bWindowHasMoved( PRECTL prclSrc, PRECTL prclDest )
{
    BOOL bRet = FALSE;
    ASSERT(prclSrc);
    ASSERT(prclDest);

    if(    ( (prclSrc->right  - prclSrc->left)==(prclDest->right  - prclDest->left) )
        && ( (prclSrc->bottom - prclSrc->top )==(prclDest->bottom - prclDest->top)  )
        && (   (prclSrc->left != prclDest->left ) 
             ||(prclSrc->top  != prclDest->top  ) 
           )
      )            
    {
        DISPDBG((2, "  moved: l%4d t%4d r%4d b%4d (w%4d x h%4d) -> l%4d t%4d r%4d b%4d", 
            prclSrc->left, 
            prclSrc->top, 
            prclSrc->right, 
            prclSrc->bottom,
            prclSrc->right-prclSrc->left, 
            prclSrc->bottom-prclSrc->top,
            prclDest->left,
            prclDest->top,
            prclDest->right, 
            prclDest->bottom));
        bRet = TRUE;
    }
    return bRet;
}


/*
** bWindowHasBeenResized
**
** checks window's old and new position rectangles and determines if
** it has been resized
** 
** Return value: FALSE: if window hasn't been resized
**               TRUE:  if window has been resized
**
** MSchwarz 10/05/2000: new
*/
BOOL bWindowHasBeenResized( PRECTL prclSrc, PRECTL prclDest )
{
    BOOL bRet = FALSE;
    ASSERT(prclSrc);
    ASSERT(prclDest);

    if(    ( (prclSrc->right  - prclSrc->left)!=(prclDest->right  - prclDest->left) )
        || ( (prclSrc->bottom - prclSrc->top )!=(prclDest->bottom - prclDest->top)  )
      )
    {
        DISPDBG((2, "  resized: l%4d t%4d r%4d b%4d (w%4d x h%4d) -> l%4d t%4d r%4d b%4d (w%4d x h%4d)", 
            prclSrc->left, 
            prclSrc->top, 
            prclSrc->right, 
            prclSrc->bottom,
            prclSrc->right-prclSrc->left, 
            prclSrc->bottom-prclSrc->top,
            prclDest->left,
            prclDest->top,
            prclDest->right, 
            prclDest->bottom,
            prclDest->right-prclDest->left, 
            prclDest->bottom-prclDest->top
            ));
        bRet = TRUE;
    }
    return bRet;
}


// MSchwarzer 09/28/2000 need this to copy overlaymainplanefront to primary
static HWND g_hWnd = NULL;
// we need this to be able to handle occluded OGLClients
// in case of WOC_CHANGED
static PPDEV g_ppdev = NULL;
//******************************************************************************
//
//  Function:   DrvClipChanged
//
//  Routine Description:
//
//      Implements the routine which is notified when a clip list changes for
//      our client window.
//
//  Arguments:
//      fl:                     pwo:
//      WOC_CHANGED             NULL
//      WOC_RGN_CLIENT_DELTA    client delta clipping (region we will enter) + includes a pvConsumer
//      WOC_RGN_CLIENT          client clipping (new client area) + includes a pvConsumer
//      WOC_RGN_SURFACE_DELTA   desktop delta clipping (region we left)
//      WOC_RGN_SURFACE         desktop clipping (desktop - clients)
//      WOC_DELETE              includes a pvConsumer of the client that dies 
//                              NOTE: In our implementation pvConsumer already is invalidated!
//
//  Return Value:
//
//      None.
//
//******************************************************************************
VOID CALLBACK DrvClipChanged(
    WNDOBJ *pwo,
    FLONG  fl
)
{
    PDEV                    *ppdev              = NULL;
    NV_OPENGL_CLIENT_INFO   *clientInfo         = NULL;
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo = NULL;
    LONG status;
#ifdef NV_MAIN_MULTIMON
    ULONG_PTR ul;
    PVOID ppData;
    BOOL bRet; 
#endif

#if DBG
    if (NULL == pwo)
    {
        // don't have pwo
        DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s ", fl, szDbg_WOC_flGet(fl)));
    }
    else if (NULL == pwo->pvConsumer)
    {
        // don't have pvConsumer==clientInfo
        DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s , pwo:0x%p", fl, szDbg_WOC_flGet(fl), pwo));
    }
    else
    {
        if (fl & WOC_DELETE)
        {
            // should be the WOC_DELETE, but we will crash on invalid pvConsumer data if we access it
            DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s , pwo:0x%p, client:0x%p (INVALID)", fl, szDbg_WOC_flGet(fl), pwo, pwo->pvConsumer));
        }
        else if (   (NULL == OglFindClientListFromClientInfo(NULL, pwo->pvConsumer))
                 || !bOglHasDrawableInfo(pwo->pvConsumer))
        {
            // don't have clientDrawableInfo -> should not happen
            DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s , pwo:0x%p, client:0x%p", 
                fl, szDbg_WOC_flGet(fl), 
                pwo, pwo->pvConsumer));
        }
        else
        {
        
            DISPDBG((1, "DrvClipChanged: fl:0x%03x %-25s , pwo:0x%p, client:0x%p, drawable:0x%p (hWnd:0x%p, clipcount:0x%x)", 
                fl, szDbg_WOC_flGet(fl), 
                pwo, pwo->pvConsumer,
                ((NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer)->clientDrawableInfo,
                ((NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer)->clientDrawableInfo->hWnd,
                ((NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer)->clientDrawableInfo->clipChangedCount
                ));
        }
    }
#endif

    // MSchwarzer 10/06/2000 now we do: we have to check all clientDrawableInfo->ubbWindowClipFlags
    // because after opening a new window underlying window has wrong Flag setting !!
    if (fl & WOC_CHANGED)
    {
        // It is possible for g_ppdev to be NULL here (why?)
        // Since this may cause a leak, print a debug error
        if (g_ppdev == NULL) {
            DBG_ERROR("DrvClipChanged: NULL g_ppdev w/ WOC_CHANGED");
        }
        if (   (NULL != g_ppdev)               // need a ppdev
            && g_ppdev->bEnabled               // running on enabled hardware
            && (NULL != g_ppdev->pOglServer) ) // with initialized oglserver structure
        {
            ppdev = g_ppdev;

            // calculate bounding clip rect around all clients
            bOglClipBoundsUpdate(ppdev->pOglServer);

            // loop over all clients with a NV_OPENGL_DRAWABLE_INFO
            clientInfo = NULL;
            while (bOglGetNextClient(&clientInfo))
            {
                CheckUbbWindowClip(ppdev,clientInfo->clientDrawableInfo); 
            }

            bOglStereoModeUpdate(ppdev);
            bOglOverlayModeUpdate(ppdev);

            // Defers it to next call to bOglPageFlipModeRetryEnable
            ppdev->pOglServer->ulPageFlipRetryCounter = PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP; 

            // Clipping has changed, we should retry on next swap, but not here and now.
            // But we have to disable pageflipping if necessary!
            bOglPageFlipModeUpdate(ppdev);
        }

        // All done => reset globals to Zero
        g_hWnd                     = NULL;
        g_ppdev                    = NULL;
        DISPDBG((1, " "));
        return;
    }

    // from here on we need a pwo
    if (!pwo)
    {
        DISPDBG((1, "DrvClipChanged: pwo NULL"));
        return;
    }

    //
    // Try to get a valid ppdev.
    //
    // Win2K after a mode switch will give us outdated ppdev for all clients
    // that were started before the mode switch. So we have different 
    // mechanisms to retrieve a ppdev:
    //
    // 1. out of pso                            (default)
    // 2. out of client in pvConsumer           (fallback for all CLIENT calls)
    // 3. out of any client in global list      (fallback for all SURFACE calls)    
    // NOTE: Still a problem with WOC_DELETE because pvConsumer is already invalid.
    //       but we don't handle that call

    //
    // 1. try to get ppdev out of pso.
    //
    ppdev = (PDEV *)pwo->psoOwner->dhpdev;

    ASSERT(NULL!=ppdev);
    if (NULL==ppdev) // Be shure we don't crash!
    { 
        DISPDBG((0,"DrvClipChanged: ERROR: Invalid ppdev in Window!"));
        return;
    }

    // Win2K will give us outdated ppdevs after a modeswitch, 
    // try to find a valid ppdev instead
    if (!ppdev->bEnabled)
    {
        //
        // 2. Try this client
        //

        // NOTE:  clientInfo can be NULL!
        // NOTE2: clientInfo can be != NULL but invalid!
        clientInfo = (NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer;

        if (   OglFindClientListFromClientInfo(NULL, clientInfo)
            && bOglHasDrawableInfo(clientInfo) )
        {
            DISPDBG((1, "DrvClipChanged: WARNING: GDI gave us a disabled ppdev, try to get a valid pdev out of given client!"));
            ASSERTDD(NULL!=clientInfo->ppdev, "clientInfo with a drawable should always have a ppdev!");

            ppdev = clientInfo->ppdev;
            ASSERT(NULL!=ppdev);
        }

        //
        // 3. Try any client
        //
        clientInfo = NULL; // start at top of list
        while (   !ppdev->bEnabled                 // still invalid?
               && bOglGetNextClient(&clientInfo) )
        {
            DISPDBG((1, "DrvClipChanged: WARNING: GDI gave us a disabled ppdev, try to get a valid pdev out of any client!"));
            ASSERTDD(NULL!=clientInfo->ppdev, "clientInfo with a drawable should always have a ppdev!");

            ppdev = clientInfo->ppdev;
            ASSERT(NULL!=ppdev);
        }
    }

    //memorize ppdev for WOC_CHANGED
    g_ppdev = ppdev;

#if 0 // still unused
    //
    // WOC_DELETE
    //
    // The WNDOBJ is being deleted as a result of the deletion of the window. 
    // Our problem is, that the pvConsumer (clientInfo) already was deleted 
    // through an escape in ogldrwbl.c in a OglEngDeleteDriverObj call, so 
    // there isn't much data we have left to do anything :-(
    //
    if (fl & WOC_DELETE)
    {
        ASSERT(NULL==pwo->pvConsumer);
        return;
    }
#endif

    // From now on we may access the hardware.
    // For that we need a valid and enabled ppdev!
    // FN moved it into branches...ASSERT(ppdev->bEnabled);

    //
    // WOC_RGN_SURFACE
    //
    // GDI should track changes in the surface region of the window object, and 
    // notify the driver when the surface region changes. The surface region is 
    // the display surface area excluding all visible client regions of the 
    // windows being tracked by the driver. 
    // The WNDOBJ refers to a surface region created by GDI. The pvConsumer 
    // member of the WNDOBJ structure is zero. 
    //
    // In other words: We get the entire desktop minus all ogl clients.
    //
    if (fl & WOC_RGN_SURFACE)
    {
        bOglNegativeClipListUpdate(ppdev, pwo);
    }

    // MSchwarz 09/26/2000 we need to clear all space on overlaybuffers we leave with our
    //                     window to no leave garbage there, which would affect other windows
    if (fl & WOC_RGN_CLIENT_DELTA )
    {
        ASSERT(ppdev->bEnabled);
        // this is the new delta region we will enter

        //  The window object contains the delta client region list. 
        //  The delta region is valid for this call only.

        // clear newly entered region in overlay buffers, if pwo belongs to an overlay client
        // but aware of popup-menues which save and restore frontbuffer contents but NOT 
        // overlaybuffer contents => don't destroy overlay ibn this case
        if( 0 == ppdev->lSavedScreenBits )
        {
            // clear overlay front- and backbuffer because ICD will receive a WM_PAINT message
            bClearOverlayForClient(ppdev, pwo, NULL, TRUE, TRUE);
        }
        else
        {
            // only clear overlay frontbuffer because DrvSaveScreenBits will restore it
            bClearOverlayForClient(ppdev, pwo, NULL, TRUE, FALSE);
        }
    }

    if (fl & WOC_RGN_SURFACE_DELTA)
    {
        ASSERT(ppdev->bEnabled);
        // this is the region we will leave

        //  The window object contains the delta client region list. 
        //  The delta region is valid for this call only.

        // this call belongs to a WOC_RGN_SURFACE_DELTA call into DrvClipChanged
        // since the call says the primary that it will grow, there is NO pwo->pvConsumer

        // clear overlay front of new desktop area
        bClearOverlayArea(ppdev, pwo, ICD_PALETTE_TRANSPARENT_COLOR | 0xFF000000, TRUE, FALSE );
    }


    if (fl & WOC_RGN_CLIENT)
    {
        try // just in case...
        {
            clientInfo = (NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer;

            ASSERT(ppdev);
            if (OglFindClientListFromClientInfo(ppdev, clientInfo) != NULL)
            {

                ASSERT(ppdev->bEnabled);
                clientDrawableInfo = clientInfo->clientDrawableInfo;
                if (OglValidateDrawableInfo(clientDrawableInfo) == TRUE)
                {

                    // MSchwarzer 13/11/2000 we need this hWnd for a WOC_RGN_SURFACE_DELTA-call
                    // if it isn't only a windowmove
                    if( bWindowHasMoved( (PRECTL)&clientDrawableInfo->rect,&pwo->rclClient ) )
                    {
                        bGetOglClientInfoHWnd( clientInfo, &g_hWnd );
                    }

#ifdef NV_MAIN_MULTIMON                                      
                    /* Must synchronize all devices that we intersect */    
                    /* Get the first node in the OGLPDEV Linked list */
                    bRet = bLinkedListGetFirstElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, &ul, &ppData);
        
                    while ( bRet )
                    {
                        ASSERT(NULL != ppData);
    
                        /* Compare the node for intersection with the drawable */
                        if ( OglClientIntersectsDevice(ppData, clientDrawableInfo) )
                        {
                            OglSyncEngineUsingPDEV(ppData);
                        }

                        /* Get the next linked list entry */
                        bRet = bLinkedListGetNextElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, &ul, &ppData);            
                    }
#else
                    // force a sync/engine-stall with GDI channel
                    ppdev->pfnWaitEngineBusy(ppdev);
                    // force a sync/engine-stall with all OGL rendering channels
                    ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
                    ppdev->NVFreeCount = 0;
                    ppdev->pfnWaitForChannelSwitch(ppdev);
#endif

                    CopyClipListToDrawableInfo(ppdev, pwo, fl, clientDrawableInfo);
                    CopyClipListToOtherClients(ppdev, pwo, fl, clientDrawableInfo);
                }
                else
                {
                    DISPDBG((1, "DrvClipChanged: BOGUS clientDrawableInfo"));
                }
            }
            else
            {
                DISPDBG((0, "DrvClipChanged: BOGUS clientInfo"));
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ASSERT(FALSE);
            status = GetExceptionCode();
            DISPDBG((0, "DrvClipChanged: WOC_RGN_CLIENT: exception = 0x%lx", status));
        }
    } 
}


//*************************************************************************
// bOglNegativeClipListCreate
// 
// allocate and initialize a negative clip list to entire desktop.
//
// NOTE: Negative cliplist only makes sense in a UBB and window flipping
//       environment.
//
// returns TRUE  if succeeded.
//         FALSE if failed
//*************************************************************************
BOOL bOglNegativeClipListCreate(PPDEV ppdev)
{
    BOOL      bRet = FALSE;
    CLIPLIST *pClip = NULL; // pointer to negative cliplist

    ASSERT(NULL != ppdev);

    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        pClip    = &ppdev->OglNegativeClipList;

        RtlZeroMemory(pClip, sizeof(CLIPLIST));

        if (bClipListAlloc(pClip, 1))
        {
            pClip->c = 1;
            prclRclSetXYWH(pClip->prcl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);

            lClipListPixelCount(pClip);

            prclRclSetXYWH(&pClip->rclBounds, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
            bRet = TRUE;
        }

        ASSERT(bRet);
    }
    return (bRet);
}


//*************************************************************************
// bOglNegativeClipListDestroy
// 
// free a negative cliplist
//
// returns TRUE  if succeeded.
//         FALSE if failed
//*************************************************************************
BOOL bOglNegativeClipListDestroy(PPDEV ppdev)
{
    BOOL bRet = FALSE;

    ASSERT(NULL != ppdev);
    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        bClipListFree(&ppdev->OglNegativeClipList);

        bRet = TRUE;
    }
    return (bRet);
}


//*************************************************************************
// bOglNegativeClipListUpdate
// 
// gets the rect list out of pwo and interpretes it as the negative client 
// list which is the desktop region minus all client views.
//
// returns TRUE  if succeeded.
//         FALSE if failed, negative clip list not valid!
//*************************************************************************
BOOL bOglNegativeClipListUpdate(PPDEV ppdev, WNDOBJ *pwo)
{
    LONG      c     = 0;
    CLIPENUM  ce;
    CLIPLIST *pClip = NULL; // pointer to negative cliplist
    BOOL      bMore = FALSE;
    BOOL      bRet  = TRUE; // default success exit!

    ASSERT(NULL != ppdev);

    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        RECTL     rclScreen;

        rclScreen.left   = ppdev->left;
        rclScreen.right  = ppdev->left+ppdev->cxScreen;
        rclScreen.top    = ppdev->top;
        rclScreen.bottom = ppdev->top+ppdev->cyScreen;

        ASSERT(NULL != pwo  );
        ASSERT(bClipListCheck(&ppdev->OglNegativeClipList));

        pClip    = &ppdev->OglNegativeClipList;
        pClip->c = 0; // invalidate all existing rects!

        // pwo and screen must be the same!
        if ( !bRclIsEqual(&rclScreen, &pwo->rclClient) )
        {
            LONG      lNeedRects;
            // Windows 2000 has a bug that after a mode switch 
            // it sends us pwo's with clip information of the mode in which the
            // OpenGL application started. 
            // This is bad if we switch to high res because we wouldn't cover outside areas.
            // Try to fix this by adding two rects to the negative cliplist
            lNeedRects = pClip->c + 4; // 4 is what lRclMinusRcl needs as minimum

            if (!bClipListReAlloc(pClip, lNeedRects))
            {
                DISPDBG((0, "bClipListReAlloc failed to realloc from %d to %d", pClip->cMax, lNeedRects));
                // NOTE: This error will override the success below!
                bRet = FALSE;
            }
            else
            {
                pClip->c = lRclMinusRcl(pClip->prcl, &rclScreen, &pwo->rclClient); 
                DISPDBG((0, "WARNING in bOglNegativeClipListUpdate: W2K modeswitch %dx%d -> %dx%d workaround active with %d rects", 
                    lRclWidth(&pwo->rclClient), lRclHeight(&pwo->rclClient), 
                    lRclWidth(&rclScreen)     , lRclHeight(&rclScreen)     , 
                    pClip->c));
            }
        }

        WNDOBJ_cEnumStart(pwo,CT_RECTANGLES,CD_ANY,0);
        do 
        {
            bMore = WNDOBJ_bEnum(pwo, sizeof(ce), &ce.c);

            if (!bClipListReAlloc(pClip, pClip->c + ce.c))
            {
                DISPDBG((0, "bClipListReAlloc failed to realloc from %d to %d", pClip->cMax, pClip->c + ce.c));
                bRet = FALSE;
                break;
            }

            for (c = 0; c < ce.c; c++)
            {
                ASSERT(pClip->c < pClip->cMax);

                // in the case of W2K switching to low res, clip against current screen
                if (bRclIntersect(&(pClip->prcl[pClip->c]), &(ce.arcl[c]), &rclScreen))
                {
                    pClip->c++;
                }
                else
                {
                    // Mode switch case??
                    DISPDBG((0, "bOglNegativeClipListUpdate: GDI did give us cliprect outside screen! %d,%d,%d,%d",
                        ce.arcl[c].left,ce.arcl[c].top,ce.arcl[c].right,ce.arcl[c].bottom));
                }
            }
        }
        while (bMore);

        //
        // Error handling
        //
        if (!bRet)
        {
            // This is an error case, where we try to do the best!
            if (pClip->cMax > 0)
            {
                // Add entire desktop
                pClip->c = 1;
                prclRclSetXYWH(pClip->prcl, 0, 0, ppdev->cxScreen, ppdev->cyScreen);
            }
            else
            {
                // can't use cliplist at all!
                pClip->c = 0;
            }
        }

        //
        // Finalize work on clip list
        //
        lClipListPixelCount(pClip);
        prclRclSetXYWH(&pClip->rclBounds, 0, 0, ppdev->cxScreen, ppdev->cyScreen);

        ASSERT(bClipListCheck(pClip));
    }
    return (bRet);
}

//*************************************************************************
// AllocateWindowRectList
//
// Given the clientDrawableInfo, allocate a memory for the list of rectangles.
//*************************************************************************
static void
ReallocCopyWindowRect(
    PDEV                    *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    ULONG                   numClipRects
)
{
#ifndef NV3
    // Do this for NV4 and higher only...
    // Is it a realloc?
    if ((clientDrawableInfo->sizeCopyWindowRectList > MAX_OGL_CLIP_RECTS) && 
        (clientDrawableInfo->copyWindowRect != NULL) &&
        (clientDrawableInfo->copyWindowRect != (&(clientDrawableInfo->windowRect[0])))) {
        EngFreeMem(clientDrawableInfo->copyWindowRect);
        clientDrawableInfo->sizeCopyWindowRectList = 0;
        clientDrawableInfo->copyWindowRect = NULL;
        if (clientDrawableInfo->origWindowRectList)
            {
            EngFreeMem(clientDrawableInfo->origWindowRectList);
            clientDrawableInfo->origWindowRectList = NULL;
            }
    }
                
    // To avoid thrashing allocate a bigger list.
    clientDrawableInfo->sizeCopyWindowRectList = numClipRects + MAX_OGL_CLIP_RECTS;
    clientDrawableInfo->copyWindowRect = (RECTL *)
        EngAllocMem(FL_ZERO_MEMORY, 
                    (sizeof(RECTL) * clientDrawableInfo->sizeCopyWindowRectList), 
                    ALLOC_TAG);
#else                
    // FOR NV3.....
    if (numClipRects > MAX_OGL_CLIP_RECTS) {
        numClipRects = MAX_OGL_CLIP_RECTS;
    }
#endif // NV3
    if (clientDrawableInfo->bOrigClipList == TRUE)
    {
        clientDrawableInfo->origWindowRectList = (RECTL *)
            EngAllocMem(FL_ZERO_MEMORY, 
                        (sizeof(RECTL) * clientDrawableInfo->sizeCopyWindowRectList), 
                        ALLOC_TAG);
    }
}

//*************************************************************************
// CharacterizeTheClip
//
// Determine what type of clip list is in the clientDrawableInfo.
//*************************************************************************
static void
CharacterizeTheClip(
    PDEV                    *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo, 
    RECTL                   *windowRectList,
    RECTL                   *origRectList
)
{
    // do it here to avoid decision in loop above
    if (clientDrawableInfo->numClipRects == 0)
    {
        clientDrawableInfo->numClipRects = 1;
        windowRectList[0] = nullRect;
        if (clientDrawableInfo->bOrigClipList == TRUE)
            {
            COPY_RECT(origRectList[0], windowRectList[0]);
            }
    }

    // Characterize the clip
    if (clientDrawableInfo->numClipRects == 1)
    {
        if (IsNullRect(windowRectList))
        {
            clientDrawableInfo->clipFlags = NV_WINDOW_CLIP_OCCLUDED;
        }
        else if (windowRectList->left == 0 &&
                 windowRectList->top == 0 &&
                 (LONG)windowRectList->right == (LONG)clientDrawableInfo->cxScreen &&
                 (LONG)windowRectList->bottom == (LONG)clientDrawableInfo->cyScreen)
        {
            clientDrawableInfo->clipFlags = NV_WINDOW_CLIP_FULLSCREEN;
        }
        else
        {
            clientDrawableInfo->clipFlags = NV_WINDOW_CLIP_SINGLERECTANGLE;
        }
    }
    else
    {
        clientDrawableInfo->clipFlags = NV_WINDOW_CLIP_COMPLEX;
    }
}

//*************************************************************************
// CheckFullScreen
//
// Walk the list of OpenGL clients and evaluate whether there is an
// full screen OpenGL application.
//*************************************************************************
static void
CheckFullScreen(
    PDEV                    *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
{
    // Display driver should know whether the OpenGL is rendering in FULL screen mode
    // in order to avoid the channel switch between GDI and OpenGL
    if(clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLSCREEN)
    {
        ppdev->ulOpenGLinFullScreen = TRUE;
    }
    else
    {   
        // Walk down the whole list to check whether any window is in FULL screen mode                                       
        NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

        OglAcquireGlobalMutex();
        ppdev->ulOpenGLinFullScreen = FALSE;
        node = globalOpenGLData.oglClientListHead.clientList;
        while (node)
        {
            if (bOglHasDrawableInfo(&node->clientInfo))
            {
                if (node->clientInfo.clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLSCREEN)
                {
                    ppdev->ulOpenGLinFullScreen = TRUE;
                    break;
                }
            }
            node = node->next;
        }
        OglReleaseGlobalMutex();
    }
}

static void
ClipRectListToScreen(
    PDEV  *ppdev, 
    RECTL *windowRectList,
    ULONG numClipRects,
    LONG  cxScreen, 
    LONG  cyScreen
)
{
    int i;

    for (i = 0; i < (int)numClipRects; i++)
    {
        TranslateRectToScreen(ppdev, &windowRectList[i]);
        OglClipRectToScreen(&windowRectList[i], cxScreen, cyScreen);
    }
}

//*************************************************************************
// AllocateAndCopyWindowClipList
//
// Allocate memory for a new clip list and copy the rectangles from
// a given list.
//*************************************************************************
void
OglAllocateAndCopyWindowClipList(
    PDEV                    *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    RECTL                   *srcRectList,
    ULONG                   numClipRects
)
{
    ASSERT(NULL!=ppdev);

    if (numClipRects > 0)
    {
        ASSERT(NULL!=clientDrawableInfo);
        ASSERT(NULL!=srcRectList);

        ReallocCopyWindowRect(ppdev, clientDrawableInfo, numClipRects);
        if (clientDrawableInfo->copyWindowRect)
        {
            RtlCopyMemory(clientDrawableInfo->copyWindowRect, // dst
                          srcRectList,                        // src
                          numClipRects * sizeof(RECTL));      // count
            ClipRectListToScreen(ppdev, 
                                 srcRectList, numClipRects,
                                 clientDrawableInfo->cxScreen, clientDrawableInfo->cyScreen);
            CharacterizeTheClip(ppdev, clientDrawableInfo, srcRectList, NULL);
        }
    }
}

//*************************************************************************
// CopyClipListToDrawableInfo
//
// This function receives the cliplist for the ICD client window
// from GDI. These rectangles are desktop related ( as all GDI stuff ).
//
// It is important to keep these rectangles in CD_RIGHTDOWN-order in
// ths cliplist because the routine which calculates an exclusive 
// cliplist needs the rectangle in this order
// 
//*************************************************************************
static void
CopyClipListToDrawableInfo(
    PDEV *ppdev,
    WNDOBJ *pwo,
    FLONG fl,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    int   isValidBounds = 0;
    int   isValidClientRect = 0;
    ULONG newNumClipRects, rectListLimit;
    RECT  clientRect;
    RECTL srcRect;
    POINTL ptlSrcMinusDest;
    ULONG i; // just for enumerations

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);

    if (clientDrawableInfo)
    {
        RECTL *windowRectList = NULL;
        RECTL *origRectList = NULL;

        clientDrawableInfo->clipChangedCount++;
        clientDrawableInfo->cachedClipListDirty = TRUE;

        COPY_RECT(srcRect, clientDrawableInfo->rect);
        COPY_RECT(clientDrawableInfo->rect, pwo->rclClient);

        // remember distance between src and destination rectangle
        ptlSrcMinusDest.x = srcRect.left - pwo->rclClient.left;
        ptlSrcMinusDest.y = srcRect.top  - pwo->rclClient.top;

        switch (pwo->coClient.iDComplexity)
            {
            case DC_TRIVIAL:
            case DC_RECT:
                newNumClipRects = 1;
            break;
            case DC_COMPLEX:
            default: 
                {
                    BOOL        bMore;
                    ENUMRECTS   enumRect;
                    ULONG       i, tempRet;

                    rectListLimit = clientDrawableInfo->sizeCopyWindowRectList;
                    newNumClipRects = WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, rectListLimit);
                    if (newNumClipRects == 0xFFFFFFFF) {
                        i = 0;
                        bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);
                        while ((i < (ULONG)(ppdev->cxScreen*ppdev->cyScreen)) && bMore)
                        {
                            i++;
                            bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);
                        }
                        newNumClipRects = i;
                        // restart enumeration again
                        tempRet = WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, i);
                    }
                }

            break;
            }

        if (newNumClipRects > clientDrawableInfo->sizeCopyWindowRectList) {
            ReallocCopyWindowRect(ppdev, clientDrawableInfo, newNumClipRects);
        }

        windowRectList = clientDrawableInfo->copyWindowRect;
        clientDrawableInfo->numClipRects = newNumClipRects;
        if (clientDrawableInfo->bOrigClipList == TRUE)
            {
            origRectList = clientDrawableInfo->origWindowRectList;
            }

        isValidBounds = !IsNullRect(&pwo->coClient.rclBounds);
        COPY_RECT(clientRect, clientDrawableInfo->rect);
        OglClipRectToScreen(
            (RECTL *)&clientRect,
            clientDrawableInfo->cxScreen,
            clientDrawableInfo->cyScreen);
        isValidClientRect = !IsNullRect((RECTL *)&clientRect);

        // Move single-back-depth if necessary => moved behind clipenumeration

        switch (pwo->coClient.iDComplexity)
            {
            case DC_TRIVIAL:
                DISPDBG((2, "DrvClipChanged: DC_TRIVIAL"));
                clientDrawableInfo->numClipRects = 1;
            break;

            case DC_RECT:

                if (isValidBounds)
                {
                    DISPDBG((2, "DrvClipChanged: DC_RECT: SINGLERECTANGLE"));
                    clientDrawableInfo->numClipRects = 1;
                    COPY_RECT(windowRectList[0], pwo->coClient.rclBounds);
                    if (clientDrawableInfo->bOrigClipList == TRUE)
                        {
                        COPY_RECT(origRectList[0], windowRectList[0]);
                        }
                }
                else
                {
                    DISPDBG((2, "DrvClipChanged: DC_RECT: OCCLUDED"));
                    clientDrawableInfo->numClipRects = 0;
                }
            break;

            case DC_COMPLEX:
                {
                BOOL        bMore;
                ENUMRECTS   enumRect;
                ULONG       i;

                DISPDBG((2, "DrvClipChanged: DC_COMPLEX"));

                i = 0;
                bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);
                while (i < clientDrawableInfo->numClipRects && bMore)
                    {
                    COPY_RECT(windowRectList[i], enumRect.arcl[0]);
                    if (clientDrawableInfo->bOrigClipList == TRUE)
                        {
                        COPY_RECT(origRectList[i], windowRectList[i]);
                        }
                    i++;
                    bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);
                    }
                clientDrawableInfo->numClipRects = i;
                break;
                }
            default:
                break;
        }

        // MSchwarzer 10/06/2000  move CLIPPED client area to not overdraw other ogl-windows !!
        if (ppdev->bOglSingleBackDepthSupported &&
            ppdev->bOglSingleBackDepthCreated &&
            isValidBounds && isValidClientRect
            && bWindowHasMoved(&srcRect,&pwo->rclClient))
        {
            // notify GDI syncs that a window move is in progress and a DrvCopyBits will happen.
            ppdev->pOglServer->bWindowInMovement = TRUE;

            switch (pwo->coClient.iDComplexity)
            {
                case DC_TRIVIAL:
                case DC_RECT:
                {
                    srcRect.right  = pwo->coClient.rclBounds.right   + ptlSrcMinusDest.x;
                    srcRect.left   = pwo->coClient.rclBounds.left    + ptlSrcMinusDest.x;
                    srcRect.top    = pwo->coClient.rclBounds.top     + ptlSrcMinusDest.y;
                    srcRect.bottom = pwo->coClient.rclBounds.bottom  + ptlSrcMinusDest.y;

                    OglBltBackDepthBuffer(ppdev, 
                                          clientDrawableInfo,
                                          &srcRect,
                                          &pwo->coClient.rclBounds);
                    break;
                }
                case DC_COMPLEX:
                default: 
                {
                    ULONG       ulNumClips;
                    ULONG       ulDir; // blit direction
                    ULONG       i;
                    BOOL        bMore;
                    ENUMRECTS   enumRect;

                    // we need to know in which direction we have to blit to enumerate
                    // the clipping in the right order !
                    // but we do this only for copyonwindowmove !
                    if(ptlSrcMinusDest.x < 0)       // moving window to right ?
                    {
                        if(ptlSrcMinusDest.y < 0)   // moving window down ?
                            ulDir = CD_LEFTUP;
                        else
                            ulDir = CD_LEFTDOWN;
                    }
                    else
                    {
                        if(ptlSrcMinusDest.y < 0)   // moving window down ?
                            ulDir = CD_RIGHTUP;
                        else
                            ulDir = CD_RIGHTDOWN;
                    }

                    ulNumClips = WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, ulDir, newNumClipRects);

                    do
                    {
                        bMore = WNDOBJ_bEnum(pwo, sizeof(ENUMRECTS), &enumRect.c);

                        // clipping against screen will be done in OglBltBackDepthBuffer
                        // translation is done in OglBltBackDepthBuffer, too
                        for(i=0;i<enumRect.c;i++)
                        {
                            srcRect.right  = enumRect.arcl[i].right   + ptlSrcMinusDest.x;
                            srcRect.left   = enumRect.arcl[i].left    + ptlSrcMinusDest.x;
                            srcRect.top    = enumRect.arcl[i].top     + ptlSrcMinusDest.y;
                            srcRect.bottom = enumRect.arcl[i].bottom  + ptlSrcMinusDest.y;

                            OglBltBackDepthBuffer(ppdev, 
                                                  clientDrawableInfo,
                                                  &srcRect,
                                                  &enumRect.arcl[i]);
                        }
                    }
                    while( bMore );

                    // reset enumeration with values for ICD exclusive cliplist generationg function
                    ulNumClips = WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, newNumClipRects);
                }
            }
        }

        ClipRectListToScreen(ppdev, 
                             windowRectList, clientDrawableInfo->numClipRects,
                             clientDrawableInfo->cxScreen, clientDrawableInfo->cyScreen);
        CharacterizeTheClip(ppdev, clientDrawableInfo, windowRectList, origRectList);
        CheckFullScreen(ppdev, clientDrawableInfo);
    }
}

//******************************************************************************
//
//  Function:   OglClipRectToScreen
//
//  Routine Description:
//
//      Implements a routine that clips a rectangle to the PDEV size.
//
//  Arguments:
//
//  Return Value:
//
//      None
//
//******************************************************************************
void OglClipRectToScreen(
    RECTL *rect,
    LONG cxScreen,
    LONG cyScreen
)
{
    if (rect->left < 0)
        {
        rect->left = 0;
        }
    if (rect->top < 0) 
        {
        rect->top = 0;
        }
    if (rect->right > cxScreen) 
        {
        rect->right = cxScreen;
        }
    if (rect->bottom > cyScreen) 
        {
        rect->bottom = cyScreen;
        }

    if (IsNullRect(rect))
        {
        *rect = nullRect;
        }
}

//******************************************************************************
//
//  Function:   NV4_OglFlushClipped
//
//  Routine Description:
//
//      Implements a routine that flushes a push buffer based on the clip list.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************
ULONG NV4_OglFlushClipped(
    PDEV *ppdev, 
    HWND hWnd, 
    HDC hDC, 
    ULONG hClient, 
    __GLNVflushInfo *flushInfo
)
{
#ifndef NV3 // Do this for NV4 and higher only...
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    ULONG                      *pCmdBuf;
    ULONG                      *pClipStart;
    LONG                       dwCmdBufFreeCount;
    ULONG                      rectCount;
    RECTL                      *rectList;
    ULONG                      *pushBufferBase;
    ULONG                      *pushBufferEnd;
    LONG                       x;
    LONG                       y;
    LONG                       w;
    LONG                       h;
    ULONG                      ulClipHorizontal;
    ULONG                      ulClipVertical;
#ifndef USE_CLIENT_RECT_LIST
    LONG                       windowLeft;
    LONG                       windowTop;
#endif
    ULONG                      listSize;
    RECTL                      *windowRectList;
    LONG                       status;
    __GLNVcmdInfo              *cmdInfo;
    RECTL                      ubbRect;

    if (!flushInfo || 
        ppdev->dwGlobalModeSwitchCount != flushInfo->localModeSwitchCount) 
        {
        //
        // In this case, the client side should increment
        // the push buffer pointers but not render the buffer.
        //
        OglDebugPrint("NV4_OglFlushClipped: bailing OGL_ERROR_MODE_SWITCH\n");
        flushInfo->retStatus = OGL_ERROR_MODE_SWITCH;
        return((ULONG)TRUE);
        }

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("NV4_OglFlushClipped: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    if (clientInfo)
        {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        }
    else
        {
        OglDebugPrint("NV4_OglFlushClipped: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
    }

        try
        {
        cmdInfo = flushInfo->cmdInfo;
        }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        DISPDBG((1, "NV4_OglFlushClipped: cmdInfo: exception = 0x%lx", status));
                return((ULONG)FALSE);
    }    
    // assert(cmdInfo);
    
#ifdef DBG
    nvDebugLevel   = cmdInfo->nvDebugLevel;
    nvDebugOptions = cmdInfo->nvDebugOptions;
    nvDebugMask    = cmdInfo->nvDebugMask;
    nvControlOptions = cmdInfo->nvControlOptions;
#endif

    //
    // If the client side clipChangedCount is out of date the window may
    // have moved or resized.  Kick back to the client so buffer info may
    // be reloaded.
    //
    if (flushInfo->clipChangedCount != clientDrawableInfo->clipChangedCount)
        {
        flushInfo->retStatus = OGL_ERROR_WINDOW_CHANGED_COUNT;
        return((ULONG)TRUE); 
        }

    windowRectList = clientDrawableInfo->copyWindowRect;
    if (clientDrawableInfo->cachedClipListDirty ||
        flushInfo->wndClipRectChanged)
    {
        CombineRectLists((RECTL*) &(cmdInfo->coreClipRect), 1, 
            windowRectList,
            clientDrawableInfo->numClipRects,
            (LONG) (clientDrawableInfo->rect.left - ppdev->left),
            (LONG) (clientDrawableInfo->rect.top - ppdev->top),
            NULL, &listSize);
        
        if (listSize >= clientDrawableInfo->cachedClipListSize)
        {
            // Reallocate the cached clip list
            
            //
            // Free memory associated with cached clip list of client drawable info.
            //
            if (clientDrawableInfo->cachedClipRectList)
            {
                EngFreeMem(clientDrawableInfo->cachedClipRectList);
                clientDrawableInfo->cachedNumClipRects = 0;
                clientDrawableInfo->cachedClipListSize = 0;
            }
            
            // To avoid thrashing, add MAX_OGL_CLIP_RECTS
            listSize += MAX_OGL_CLIP_RECTS;

            // Allocate the cached clip list now.
            clientDrawableInfo->cachedClipRectList = 
                EngAllocMem(FL_ZERO_MEMORY, 
                (sizeof(RECTL) * listSize), ALLOC_TAG);
            
            if (clientDrawableInfo->cachedClipRectList == NULL)
            {
                DISPDBG((1, "NV4_OglFlushClipped  - Failed EngAllocMem  of CachedClipRectList"));
                OglDebugPrint("****************** FAILURE NV4_OglFlushClipped: EngAllocMem  of CachedClipRectList");
                flushInfo->retStatus = OGL_ERROR_REALLOC_FAILURE; 
                return((ULONG)FALSE);
            }
            
            clientDrawableInfo->cachedClipListSize = listSize;
        }
        
        
        CombineRectLists((RECTL*) &(cmdInfo->coreClipRect), 1, 
            windowRectList,
            clientDrawableInfo->numClipRects,
            (LONG) (clientDrawableInfo->rect.left - ppdev->left),
            (LONG) (clientDrawableInfo->rect.top - ppdev->top),
            &(clientDrawableInfo->cachedClipRectList[0]), 
            &(clientDrawableInfo->cachedNumClipRects));
        
        clientDrawableInfo->cachedClipListDirty = FALSE;
        
    }


    //**********************************************************************
    //**********************************************************************
    // Call into the shared library to do the kickoff
    //**********************************************************************
    //**********************************************************************
    cmdInfo->ntDrawable = (void *)clientDrawableInfo;
    cmdInfo->ntOther = ppdev;
   
    __glNV4FlushInternal(cmdInfo);

    flushInfo->retStatus = OGL_ERROR_NO_ERROR;
#endif  // #ifndef NV3  // Do this for NV4 and higher only...
    return (TRUE);


}

/*
 * Take two input rectangle regions and merge them into one.
 * If list1 and list2 are in window coordinates, leftList2 = topList2 = 0
 * If list1 and list2 are in screen coordinates, leftList2 = topList2 = 0
 * If list1 is window coordinates, list2 is in screen coordinates,
 *      leftList2 = windowLeft of list2, topList2 = windowTop oflist2.
 * Last case uninteresting as it should have been called by switching list1 and list2. 
 */
void CombineRectLists(RECTL *rectList1, ULONG count1, 
                 RECTL *rectList2, ULONG count2,
         LONG  leftList2, LONG topList2,
                 RECTL *resultList, ULONG *resultCount)
{
    ULONG i, j , k;
    RECTL *inpRect1, *inpRect2, *outRect;
    LONG l1, l2, r1, r2, t1, t2 ,b1, b2;
    RECTL tmpRect;

    // Error
    if (resultCount == NULL)
        return;

    *resultCount = 0;

    // Output list is null and out count is 0
    if ((rectList1 == NULL) || (rectList2 == NULL) || (count1 == 0) || (count2 == 0))
        return;

    // Assumes left <= right and top <= bottom
    k = 0;

    // If result List is NULL, the caller is just asking for size of output list.

    if (resultList == NULL)
    {
        outRect = &tmpRect;
    }
    else
    {
        outRect = &(resultList[0]);
    }

    for (j = 0, inpRect2 = &(rectList2[0]) ; j < count2; j++, inpRect2++) {

        l2 = inpRect2->left - leftList2;
        r2 = inpRect2->right - leftList2;
        b2 = inpRect2->bottom - topList2;
        t2 = inpRect2->top - topList2;

        for (i = 0, inpRect1 = &(rectList1[0]); i < count1; i++, inpRect1++) { 

            l1 = inpRect1->left; r1 = inpRect1->right; 
            t1 = inpRect1->top; b1 = inpRect1->bottom;


            outRect->left = ((l1 < l2) ? l2 : l1); 
            outRect->right = ((r1 > r2) ? r2 : r1); 
            outRect->top = ((t1 < t2) ? t2 : t1); 
            outRect->bottom = ((b1 > b2) ? b2 : b1); 

            if ((outRect->left < outRect->right) &&
                (outRect->top < outRect->bottom)) {
                k++; // intersection
                if (resultList != NULL)
                    outRect++;
            } else {
                outRect->left = 0;
                outRect->top = 0;
                outRect->right = 0;
                outRect->bottom = 0;
            }
        }
    }
    *resultCount = k;
}

#if (NVARCH >= 0x4)

ULONG NV_OglFlushClipped(
    PDEV *ppdev, 
    HWND hWnd, 
    HDC hDC, 
    ULONG hClient, 
    __GLNVflushInfo *flushInfo
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    __GLNVcmdInfo              *cmdInfo;
    LONG                       status;
    __GLregionRect             boundingRect;
    RECTL                      *windowRectList;
    RECTL                      ubbRect;
 
    if (!flushInfo || 
        ppdev->dwGlobalModeSwitchCount != flushInfo->localModeSwitchCount) 
        {
        //
        // In this case, the client side should increment
        // the push buffer pointers but not render the buffer.
        //
        OglDebugPrint("NV_OglFlushClipped: bailing OGL_ERROR_MODE_SWITCH\n");
        flushInfo->retStatus = OGL_ERROR_MODE_SWITCH;
        return((ULONG)TRUE);
        }

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("NV_OglFlushClipped: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    if (clientInfo)
        {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        }
    else
        {
        OglDebugPrint("NV_OglFlushClipped: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }


    try
    {
        cmdInfo = flushInfo->cmdInfo;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        flushInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        DISPDBG((1, "NV_OglFlushClipped: cmdInfo: exception = 0x%lx", status));
        return((ULONG)FALSE);
    }    
    // assert(cmdInfo);
    
#ifdef DBG
    nvDebugLevel   = cmdInfo->nvDebugLevel;
    nvDebugOptions = cmdInfo->nvDebugOptions;
    nvDebugMask    = cmdInfo->nvDebugMask;
    nvControlOptions = cmdInfo->nvControlOptions;
#endif


    //
    // If the client side clipChangedCount is out of date the window may
    // have moved or resized.  Kick back to the client so buffer info may
    // be reloaded.
    //
    if (!cmdInfo->flushedBetween2D &&
        ((LONG)cmdInfo->windowChangedCount != (LONG)clientDrawableInfo->clipChangedCount))
        {
            flushInfo->retStatus = OGL_ERROR_WINDOW_CHANGED_COUNT;
        return((ULONG)TRUE); 
        }

    cmdInfo->ntDrawable = (void *)clientDrawableInfo;
    cmdInfo->ntOther = (PDEV *)ppdev;


    if (FALSE == NV_OglUpdateClipLists(ppdev, clientDrawableInfo)) {
        flushInfo->retStatus = OGL_ERROR_REALLOC_FAILURE; 
        return((ULONG)FALSE);
    }

    __glNVFlushInternal(cmdInfo, FALSE);

    /***** We might need to send info. to client that there was a switch
    ********from complex to simple case....*****************************/

    flushInfo->retStatus = OGL_ERROR_NO_ERROR;
    return((ULONG)TRUE);

}

void *oglXAlloc(size_t size)
{
    void *ptr;

    if (size == 0) {
        return NULL;
    }
    ptr = (void *) EngAllocMem(FL_ZERO_MEMORY, size, ALLOC_TAG);

    if (ptr == NULL) {
        return NULL;    /* XXX out of memory error */
    }
    return ptr;
}

void oglXFree(void *ptr)
{
    if (ptr) {
        EngFreeMem(ptr);
    }
}


void *oglXRealloc(void *oldPtr, size_t oldSize, size_t newSize)
{
    void *newPtr = NULL;

    if (newSize != 0) {
        newPtr = (void *) EngAllocMem(FL_ZERO_MEMORY, newSize, ALLOC_TAG);
        if (oldPtr && newPtr) {
            memcpy(newPtr, oldPtr, (oldSize <= newSize ? oldSize : newSize));
            EngFreeMem(oldPtr);
        }
    } else if (oldPtr) {
        EngFreeMem(oldPtr);
    }
    if (newPtr == NULL) {
        return NULL;    /* XXX out of memory error */
    }
    return newPtr;
}

RegDataPtr oglXAllocData(int n) 
{
    RegDataPtr retPtr;

    retPtr = (RegDataPtr)oglXAlloc(REGION_SZOF(n));

    return retPtr;
}

void oglXFreeData(RegionPtr reg)
{
    if (reg)
    {
        if (reg->data && reg->data->size) 
            oglXFree((reg)->data);
    }
}

void nvConvertRegionGL2NV(RegionPtr nvRegion, unsigned char useExclusive, 
                          __GLregionRect *inclusiveRects, int numInclusiveRects,
                          __GLregionRect *exclusiveRects, int numExclusiveRects,
                          __GLregionRect *boundingRect){
    
    __GLregionRect *GLrects;
    BoxPtr nvRegionRects;
    int i;

    if (!nvRegion)
        return;

    oglXFreeData(nvRegion);

    if(useExclusive){
        nvRegion->data = oglXAllocData(numExclusiveRects);
        nvRegion->data->numRects = numExclusiveRects;
        GLrects = exclusiveRects;
    } else {
        nvRegion->data = oglXAllocData(numInclusiveRects);
        nvRegion->data->numRects = numInclusiveRects;
        GLrects = inclusiveRects;
    }
    nvRegion->data->size = nvRegion->data->numRects;
    nvRegion->extents.x1 = (short)boundingRect->x0;
    nvRegion->extents.x2 = (short)boundingRect->x1;
    nvRegion->extents.y1 = (short)boundingRect->y0;
    nvRegion->extents.y2 = (short)boundingRect->y1;

    nvRegionRects = REGION_RECTS(nvRegion);
    for (i=0; i<(int)numInclusiveRects; i++) {
        __GLregionRect *rect = &GLrects[i];

        nvRegionRects->x1 = (short)rect->x0;
        nvRegionRects->x2 = (short)rect->x1;
        nvRegionRects->y1 = (short)rect->y0;
        nvRegionRects->y2 = (short)rect->y1;
        nvRegionRects++;
    }
}

void nvConvertRegionNV2GL(RegionPtr nvRegion, unsigned char useExclusive,
                          __GLregionRect **inclusiveRects, int *numInclusiveRects,
                          __GLregionRect **exclusiveRects, int *numExclusiveRects){

    int i;
    BoxRec *nvRegionRects;
    GLint *numrects;
    __GLregionRect **rects;


    if (!nvRegion)
        return;

    nvOptimizeRegion(nvRegion);

    if(useExclusive){
        numrects = numExclusiveRects;
        rects    = exclusiveRects;
    } else {
        numrects = numInclusiveRects;
        rects    = inclusiveRects;
    }

    if(nvRegion->data){

        *numrects = nvRegion->data->numRects;
        if(*rects){
            oglXFree(*rects);
        }
        *rects = oglXAlloc((*numrects) * sizeof(__GLregionRect));

        nvRegionRects = REGION_RECTS(nvRegion);

        for (i=0; i<(int) *numrects; i++) {
            __GLregionRect *rect = &((*rects)[i]);

            // copy region to drawable private
            rect->x0 = nvRegionRects->x1;
            rect->x1 = nvRegionRects->x2;
            rect->y0 = nvRegionRects->y1;
            rect->y1 = nvRegionRects->y2;

            nvRegionRects++;
        }

    } else {
        // If there is no nvRegion->data, then there is just one
        // rect and it is in the 'extents' rect.
        *numrects = 1;
        *rects = oglXAlloc(sizeof(__GLregionRect));
        (*rects)[0].x0 = nvRegion->extents.x1;
        (*rects)[0].x1 = nvRegion->extents.x2;
        (*rects)[0].y0 = nvRegion->extents.y1;
        (*rects)[0].y1 = nvRegion->extents.y2;

    }
}

#endif // (NVARCH >= 0x4)


static void OglBltBackDepthBuffer(
    PDEV *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    RECTL *srcRect,
    RECTL *dstRect
)
{
    RECTL drawableRect;
    ULONG ulView;

    COPY_RECT(drawableRect, (*srcRect));
    // convert to screen relative coords
    drawableRect.left   -= ppdev->left;
    drawableRect.right  -= ppdev->left;
    drawableRect.top    -= ppdev->top;
    drawableRect.bottom -= ppdev->top;

    if ((dstRect->bottom - dstRect->top == 
         drawableRect.bottom - drawableRect.top) && // height of src and dest are equal

        (drawableRect.right - drawableRect.left > 0) && // src width > 0
        (drawableRect.bottom - drawableRect.top > 0) && // src height > 0

        (dstRect->right - dstRect->left > 0 && // dst width > 0
         dstRect->bottom - dstRect->top > 0))  // dst height > 0
    {
        LONG dstLeft, dstTop, dstRight, dstBottom;
        LONG srcLeft, srcTop;

        srcLeft   = drawableRect.left;
        srcTop    = drawableRect.top;

        dstLeft   = dstRect->left;
        dstTop    = dstRect->top;
        dstRight  = dstRect->right;
        dstBottom = dstRect->bottom;


        //****************************************************************
        // If double buffering is enabled, then the display driver is
        // already blitting some views when the window moves.
        // Only move buffers that are not double pumped by 2D.
        //****************************************************************

        // stereo loop 
        for( ulView=0; ulView < ppdev->ulOglActiveViews; ulView++ )
        {

            if (!bDoublePumped(ppdev, ppdev->singleBack1Offset[ulView])) 
            {
                OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                       ppdev->singleBack1Offset[ulView], ppdev->singleBack1Pitch[ulView],
                                       srcLeft, srcTop,
                                       ppdev->singleBack1Offset[ulView], ppdev->singleBack1Pitch[ulView],
                                       dstLeft, dstTop,
                                       dstRight - dstLeft,
                                       dstBottom - dstTop);
            }

            if (!bDoublePumped(ppdev, ppdev->singleDepthOffset[ulView])) 
            {
                OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                       ppdev->singleDepthOffset[ulView], ppdev->singleDepthPitch[ulView],
                                       srcLeft, srcTop,
                                       ppdev->singleDepthOffset[ulView], ppdev->singleDepthPitch[ulView],
                                       dstLeft, dstTop,
                                       dstRight - dstLeft,
                                       dstBottom - dstTop);
            }
            if (ppdev->bOglOverlaySurfacesCreated) 
            {
                if (!bDoublePumped(ppdev, ppdev->singleFrontMainOffset[ulView])) 
                {
                    OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                           ppdev->singleFrontMainOffset[ulView], ppdev->singleFrontMainPitch[ulView],
                                           srcLeft, srcTop,
                                           ppdev->singleFrontMainOffset[ulView], ppdev->singleFrontMainPitch[ulView],
                                           dstLeft, dstTop,
                                           dstRight - dstLeft,
                                           dstBottom - dstTop);
                }

                if (!bDoublePumped(ppdev, ppdev->singleBack1MainOffset[ulView])) 
                {
                    OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                           ppdev->singleBack1MainOffset[ulView], ppdev->singleBack1MainPitch[ulView],
                                           srcLeft, srcTop,
                                           ppdev->singleBack1MainOffset[ulView], ppdev->singleBack1MainPitch[ulView],
                                           dstLeft, dstTop,
                                           dstRight - dstLeft,
                                           dstBottom - dstTop);
                }

                //************************************************************
                // Only blit front and back overlay since the display driver
                // is already multi buffering into front and back main planes
                //************************************************************
                if (!bDoublePumped(ppdev, ppdev->singleFrontOverlayOffset[ulView])) 
                {
                    OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                           ppdev->singleFrontOverlayOffset[ulView], ppdev->singleFrontOverlayPitch[ulView],
                                           srcLeft, srcTop,
                                           ppdev->singleFrontOverlayOffset[ulView], ppdev->singleFrontOverlayPitch[ulView],
                                           dstLeft, dstTop,
                                           dstRight - dstLeft,
                                           dstBottom - dstTop);
                }

                if (!bDoublePumped(ppdev, ppdev->singleBack1OverlayOffset[ulView])) 
                {
                    OglUseDisplayDriverBlt(ppdev, clientDrawableInfo,
                                           ppdev->singleBack1OverlayOffset[ulView], ppdev->singleBack1OverlayPitch[ulView],
                                           srcLeft, srcTop,
                                           ppdev->singleBack1OverlayOffset[ulView], ppdev->singleBack1OverlayPitch[ulView],
                                           dstLeft, dstTop,
                                           dstRight - dstLeft,
                                           dstBottom - dstTop);
                }
            }
        }//stereo loop
    }


}

#define bRcIntersect(a,b,c) bRclIntersect((RECTL*)(a),(const RECTL*)(b),(const RECTL*)(c))

//*************************************************************************
// bOglClientIntersectingWithOtherClients
// 
// returns TRUE if the given client intersects with any visible OpenGL client.
//*************************************************************************
BOOL bOglClientIntersectingWithOtherClients(IN NV_OPENGL_CLIENT_INFO *clientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfoCheck;
    BOOL                   bClipped = FALSE; // assume it isn't clipped

    ASSERTDD(bOglHasDrawableInfo(clientInfo), "give me a valid clientInfo!");

    clientInfoCheck = NULL; // loop through client list, starting at top
    while (bOglGetNextVisibleClient(&clientInfoCheck))
    {
        if (clientInfoCheck->clientDrawableInfo->hWnd != clientInfo->clientDrawableInfo->hWnd)
        {
            if ( bRcIntersect(NULL, 
                               &clientInfoCheck->clientDrawableInfo->rect, 
                               &clientInfo->clientDrawableInfo->rect) )
            {
                // another OGL window intersects our window and it has some exposed pixels.
                bClipped = TRUE;
                break;
            }
        }
    }

    return (bClipped);
}


//*************************************************************************
// Compute the translated inclusive and exclusive clip lists
// 
// returns TRUE if succeeds, FALSE if we fail (out of memory)
//*************************************************************************
BOOL NV_OglUpdateClipLists(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    if (clientDrawableInfo->cachedClipListDirty)
    {
        // Convert Client Drawable List to window coordinates
        // assert(clientDrawableInfo->numClipRects < clientDrawableInfo->cachedClipListSize);
        if (clientDrawableInfo->numClipRects >= clientDrawableInfo->cachedClipListSize)
        {
            // Reallocate the cached clip list
            
            //
            // Free memory associated with cached clip list of client drawable info.
            //
            if (clientDrawableInfo->cachedClipRectList)
            {
                EngFreeMem(clientDrawableInfo->cachedClipRectList);
            }

            // To avoid thrashing
            clientDrawableInfo->cachedClipListSize = clientDrawableInfo->numClipRects + MAX_OGL_CLIP_RECTS;
            
            // Allocate the cached clip list now.
            clientDrawableInfo->cachedClipRectList = 
                EngAllocMem(FL_ZERO_MEMORY, 
                (sizeof(RECTL) * (clientDrawableInfo->cachedClipListSize)), ALLOC_TAG);
            
            if (clientDrawableInfo->cachedClipRectList == NULL)
            {
                DISPDBG((1, "NV_OglUpdateClipLists  - Failed EngAllocMem  of CachedClipRectList"));
                OglDebugPrint("****************** FAILURE NV_OglUpdateClipLists: EngAllocMem of CachedClipRectList");
                clientDrawableInfo->cachedClipListSize = 0;
                clientDrawableInfo->cachedNumClipRects = 0;
                return FALSE;
            }
        }

        OglTranslateCachedClipRectList(ppdev,
                                       clientDrawableInfo->copyWindowRect,
                                       clientDrawableInfo->numClipRects,
                                       clientDrawableInfo->cachedClipRectList,
                                       &clientDrawableInfo->cachedNumClipRects,
                                       (RECTL *) &clientDrawableInfo->rect);

        /* We only need to update the exclusive clip if we are running on
         * CELSIUS or KELVIN, and if the number of inclusive clip rects
         * exceeds the number of clips supported in the hardware.  In the
         * interest of code simplicity, and because this only happens once
         * per clip change, we always update the exclusive clip.
         */
        if (1 /*clientDrawableInfo->cachedNumClipRects > numHWClipRects*/)
        {
            __GLregionRect boundingRect;

            RegionRec nvInclusiveRegion;
            RegionRec nvExclusiveRegion;

            nvInclusiveRegion.data = 0;
            nvExclusiveRegion.data = 0;

            boundingRect.x0 = 0;
            boundingRect.y0 = 0;
            boundingRect.x1 = clientDrawableInfo->rect.right - clientDrawableInfo->rect.left;
            boundingRect.y1 = clientDrawableInfo->rect.bottom - clientDrawableInfo->rect.top;

            // Convert Inclusive to nvRegion
            nvConvertRegionGL2NV(&nvInclusiveRegion, FALSE, 
                (__GLregionRect *)(clientDrawableInfo->cachedClipRectList), 
                clientDrawableInfo->cachedNumClipRects, 
                (__GLregionRect *)(clientDrawableInfo->cachedExclusiveRectList), 
                clientDrawableInfo->cachedNumExclusiveRects, 
                &boundingRect);

            nvInverse(&nvExclusiveRegion,&nvInclusiveRegion,&(nvInclusiveRegion.extents));

            // Convert nvRegion to Exclusive
            // This will free old exclusive rect list if exists...
            nvConvertRegionNV2GL(&nvExclusiveRegion, TRUE,
                             (__GLregionRect **)(&clientDrawableInfo->cachedClipRectList), 
                             &(clientDrawableInfo->cachedNumClipRects),
                             (__GLregionRect **)(&clientDrawableInfo->cachedExclusiveRectList), 
                             &(clientDrawableInfo->cachedNumExclusiveRects));

            oglXFreeData(&nvExclusiveRegion);
            oglXFreeData(&nvInclusiveRegion);
        }
        else
        {
            // Free associated exclusive rect memory
            // and set it so that it is not used.
            oglXFree(clientDrawableInfo->cachedExclusiveRectList);
            clientDrawableInfo->cachedExclusiveRectList = NULL;
            clientDrawableInfo->cachedNumExclusiveRects = 0;
        }

        clientDrawableInfo->cachedClipListDirty = FALSE;
    }

    return TRUE;
}


//*************************************************************************
// bOglClipRectAgainstClipobj
// 
// Clip the incoming pco against the single prcl. 
//
// return TRUE : there is an intersection between pco and prcl,
//        FALSE: no intersection found
//*************************************************************************
BOOL bOglClipRectAgainstClipobj(
    IN  CLIPOBJ *pco, 
    IN  RECTL   *prcl)
{
    BOOL      bRet = FALSE;

    ASSERT(NULL!=prcl);

    if (NULL == pco)
        goto Exit;

    switch (pco->iDComplexity)
    {
        case DC_TRIVIAL:
            // special case, we don't have a valid target rect here!
            // fall back to rclBounds, but better do not call it!
            ASSERT(pco->iDComplexity != DC_TRIVIAL);

        case DC_RECT:
            bRet = bRclIntersect(NULL, prcl, &pco->rclBounds);
            break;

        case DC_COMPLEX:
        {
            ENUMRECT4 ce;
            BOOL      bMore;

            // In complex case loop over clip list
        
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, CLIP_LIMIT);

            do
            {
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);

                while (!bRet && ce.c--)
                {
                    bRet = bRclIntersect(NULL, prcl, &(ce.arcl[ce.c]));
                }
            }
            while (!bRet && bMore);
            break;
        }
    }

Exit:
    return (bRet);
}


//*************************************************************************
// bOglClipBoundsUpdate
// 
// Calculate bounding rect of all visible OpenGL clients
// returns TRUE if there is at least one visible client with a valid rect
// returns FALSE if no client is visible.
//*************************************************************************
BOOL bOglClipBoundsUpdate(struct _OGLSERVER *pOglServer )
{
    BOOL                     bRet               = FALSE; // no client visible, no bounding rect
    NV_OPENGL_CLIENT_INFO   *clientInfo         = NULL;
    RECTL                   *prclBounds;

    ASSERT(NULL!=pOglServer);

    prclBounds = &pOglServer->rclAllClientsBounds;

    if (bOglGetNextVisibleClient(&clientInfo))
    {
        ASSERT(NULL != clientInfo);
        ASSERT(NULL != clientInfo->clientDrawableInfo);

        // start with first clients rect.
        *prclBounds = *((RECTL *)&clientInfo->clientDrawableInfo->rect);

        // find first visible ogl client 
        // and initialize clientInfo with pointer to it
        while (bOglGetNextVisibleClient(&clientInfo))
        {
            ASSERT(NULL != clientInfo);
            ASSERT(NULL != clientInfo->clientDrawableInfo);

            vRclBounds(prclBounds, (RECTL*)&clientInfo->clientDrawableInfo->rect, prclBounds);
        }
        bRet = TRUE;
    }
    else
    {
        // initialize with rectangle completely outside screen
        *prclBounds = rclOutside;
        bRet = FALSE;
    }

    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ogldebug.c ===
//******************************Module*Header***********************************
// Module Name: ogldebug.c
//
// special debug code for ogl server part of display driver
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"

#if DBG
#include "ogldebug.h"

//*************************************************************************
// DrvClipChanged-WOC-Flags stuff:
//                                                        
// szDbg_WOC_flGet
//   return string exactly matching fl
// aDbg_WOC_fl                                             
//   array defining all flags                             
//*************************************************************************
DBG_NAMEINDEX aDbg_WOC_fl[] =
{
    DBG_MAKE_NAMEINDEX(WOC_RGN_CLIENT_DELTA ),
    DBG_MAKE_NAMEINDEX(WOC_RGN_CLIENT       ),
    DBG_MAKE_NAMEINDEX(WOC_RGN_SURFACE_DELTA),
    DBG_MAKE_NAMEINDEX(WOC_RGN_SURFACE      ),
    DBG_MAKE_NAMEINDEX(WOC_CHANGED          ),
    DBG_MAKE_NAMEINDEX(WOC_DELETE           ),
    #if (_WIN32_WINNT >= 0x0500)
    DBG_MAKE_NAMEINDEX(WOC_DRAWN            ),
    DBG_MAKE_NAMEINDEX(WOC_SPRITE_OVERLAP   ),
    DBG_MAKE_NAMEINDEX(WOC_SPRITE_NO_OVERLAP),
    #endif
};

char *szDbg_WOC_flGet(ULONG fl)
{
    return (DBG_GETDBG_NAMEINDEX(aDbg_WOC_fl, fl));
}

#endif // DBG
// End of ogldebug.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglctx.c ===
/******************************Module*Header*******************************\
* Module Name: oglctx.c
*
* This module contains the functions to support the OpenGL client side
* context interface.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvReg.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "nvcom.h"          // drivers/common/inc

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

#define OGL_DEBUG_PREFIX "NV: "

BOOL CALLBACK ClientContextDrvFreeObj(DRIVEROBJ *pDriverObj);

//******************************************************************************
//
//  Function:   OglDebugPrintFunc
//
//  Routine Description:
//
//      This routine prints output messages for the OpenGL portion of the driver.
//
//  Arguments:
//
//  Return Value:
//
//
//******************************************************************************
VOID __cdecl OglDebugPrintFunc(
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;

    va_start(ap, DebugMessage);
    EngDebugPrint(OGL_DEBUG_PREFIX, DebugMessage, ap);
    va_end(ap);
}

//******************************************************************************
//
//  Function:   CreateContextClientInfo
//
//  Routine Description:
//
//      This routine associates a handle to the resource manager client and
//      a HWND with an OpenGL client.  This routine is called in response to
//      a client side escape.
//
//  Arguments:
//
//  Return Value:
//
//      FALSE indicates an allocate problem; otherwise TRUE
//
//******************************************************************************
ULONG CreateContextClientInfo(
    PDEV  *ppdev,
    HWND  hWnd, // for debugging
    ULONG hClient // key for searching for context nodes
)
{
    int i;
    LONG                   status;
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryOut;
    NV_OPENGL_CONTEXT_INFO *clientContextInfo;
    HDRVOBJ                hDrvObj = (HDRVOBJ)NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

    DISPDBG((2, "CreateContextClientInfo - 0x%p %ld", hWnd, hClient));

    clientContextInfo = EngAllocMem(FL_ZERO_MEMORY,
                                    (sizeof(NV_OPENGL_CONTEXT_INFO) + PAGE_SIZE - 1),
                                    ALLOC_TAG);
    if (clientContextInfo == NULL)
    {
        DISPDBG((2, "CreateContextClientInfo - Failed EngAllocMem"));
        return((ULONG)FALSE);
    }

    OglDebugPrint("ALLOC: clientContextInfo = 0x%p\n", clientContextInfo);


    //
    // Get pointer to new client.
    //
    clientList = OglAppendToClientInfoList(ppdev,
                                           0,
                                           0,
                                           NULL,
                                           clientContextInfo);
    if (clientList)
    {
        clientInfo = &clientList->clientInfo;
    }
    else
    {
        EngFreeMem(clientContextInfo);
        return((ULONG)FALSE);
    }

    clientContextInfo->hWnd    = hWnd; // for debugging
    clientContextInfo->hClient = hClient;

    clientInfo->clientContextInfo = clientContextInfo;

    //
    // Set context is present bit in flags.
    //
    clientInfo->flags |= NV_OGL_CLIENT_CONTEXT_INFO;

    OglDebugPrint("****************** CreateContext: client count = %ld\n", globalOpenGLData.oglClientCount);

    //
    // Create driver object that tracks this client index with the client process
    //
    hDrvObj = EngCreateDriverObj((PVOID)clientInfo, ClientContextDrvFreeObj, ppdev->hdevEng);
    if (hDrvObj == NULL)
    {
        DISPDBG((1, "CreateContextClientInfo: FAILED EngCreateDriverObj"));
        OglDebugPrint("****************** FAILURE CreateContext: client count = %ld\n", globalOpenGLData.oglClientCount);
        OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
        OglDebugPrint("FREE: clientContextInfo = 0x%p\n", clientContextInfo);
        OglDecClientCount(ppdev);
        return((ULONG)FALSE);
    }

    //
    // Save driver object and mode switch count.
    //
    clientInfo->hDrvObj         = hDrvObj;
    clientInfo->modeSwitchCount = ppdev->dwGlobalModeSwitchCount;

    OglDebugPrint("CreateContext = 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientContextInfo);

    return((ULONG)TRUE);
}

//******************************************************************************
//
//  Function:   DestroyContextClientInfo
//
//  Routine Description:
//
//      This routine frees the client drawable info structure and unbinds it
//      to the window.  This is called in reponse to the client side escape
//      or when the client side process dies.
//
//  Arguments:
//
//  Return Value:
//
//      VOID
//
//******************************************************************************
void DestroyContextClientInfo(
    PDEV  *ppdev,
    ULONG hClient,
    ULONG deleteFlag
)
{
    int i;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_CONTEXT_INFO     *clientContextInfo = NULL;
    long status;

    DISPDBG((2, "DestroyContextClientInfo - %ld", hClient));

    clientList = OglFindClientInfoHClient(ppdev, hClient);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }

    if (clientInfo && clientInfo->flags & NV_OGL_CLIENT_CONTEXT_INFO && clientInfo->clientContextInfo)
    {
        DISPDBG((1, "DestroyContextClientInfo: hClient = %ld", (ULONG)hClient));

        clientContextInfo = clientInfo->clientContextInfo;

        //
        // Free channel and such.
        //
        NvFree(ppdev->hDriver, hClient, NV01_NULL_OBJECT, hClient);

        //
        // Free client structure memory.
        //
        EngFreeMem(clientContextInfo);
        clientInfo->clientContextInfo = NULL;

        //
        // Mark it as freed.
        //
        clientInfo->flags &= ~NV_OGL_CLIENT_CONTEXT_INFO;

        if (deleteFlag)
            {
            //
            // Delete driver object if possible
            //
            if (OglEngDeleteDriverObj(ppdev, clientInfo, NV_OGL_CLIENT_CONTEXT_INFO) == TRUE)
                {
                OglDebugPrint("****************** DestroyContext: client count = %ld\n", globalOpenGLData.oglClientCount);
                }
            }

        OglDebugPrint("DestroyContext = 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientContextInfo);
    }
}

//******************************************************************************
//
//  Function:   OglFindClientInfoHClient
//
//  Routine Description:
//
//      Find a client information structure given a resource manager hClient.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoHClient(
    PDEV  *ppdev,
    ULONG hClient
)
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.clientContextInfo &&
            node->clientInfo.clientContextInfo->hClient == hClient)
            {
            return(node);
            }
        node = node->next;
        }

    return(NULL);
}


//******************************************************************************
//
//  Function:   OglGetClientInfoHWnd
//
//  Routine Description:
//
//      returns the hWnd belonging to the client info.
//
//  Arguments:      pClientInfo: pointer to the client info
//                  phWnd:       pointer to a hWnd this is the desired returnvalue             
//
//  Return Value:   TRUE: found hWnd
//                  FALSE: found no hWnd
//
//  MSchwarzer 09/28/2000: new
//
//******************************************************************************
BOOL bGetOglClientInfoHWnd( NV_OPENGL_CLIENT_INFO *pClientInfo, HWND* phWnd)
{
    BOOL bRet = FALSE;

    ASSERTDD( NULL != phWnd, "" );

    *phWnd = 0;

    if( pClientInfo )
    {
        if ( bOglHasDrawableInfo(pClientInfo) )
        {
            *phWnd = pClientInfo->clientDrawableInfo->hWnd;
            bRet = TRUE;
        }
        else if(  ( pClientInfo->flags & NV_OGL_CLIENT_CONTEXT_INFO )
                &&( pClientInfo->clientContextInfo )
               )
        {
            *phWnd = pClientInfo->clientContextInfo->hWnd;
            bRet = TRUE;
        }

    }
    return bRet;
}

//******************************************************************************
//
//  Function:   ClientContextDrvFreeObj
//
//  Routine Description:
//
//      This routine is the callback for freeing the driver object.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the resources are freed.
//
//******************************************************************************
BOOL CALLBACK ClientContextDrvFreeObj(
    DRIVEROBJ *pDriverObj
)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    LONG                  status;
    int                   i, clientIndex;
    PDEV                  *ppdev;

    clientInfo = (NV_OPENGL_CLIENT_INFO *)pDriverObj->pvObj;
    ppdev = (PDEV *)pDriverObj->dhpdev;


    OglAcquireGlobalMutex();

    OglDebugPrint("CONTEXT ***************** CONTEXT DrvFreeObj = 0x%p 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientInfo->clientDrawableInfo, clientInfo->clientContextInfo);

    if (OglFindClientListFromClientInfo(ppdev, clientInfo) == NULL)
        {
        // clientInfo was removed from clientList prior to this callback
        // just return because there is nothing to do...
        OglReleaseGlobalMutex();
        return(TRUE);
        }

    //
    // Cleanup context info.
    //
    if (clientInfo->flags & NV_OGL_CLIENT_CONTEXT_INFO)
    {
        if (clientInfo->clientContextInfo)
        {
            DWORD hClient;

            try
            {
                hClient = clientInfo->clientContextInfo->hClient;
                DestroyContextClientInfo(ppdev, hClient, FALSE);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                DISPDBG((1, "DestroyContextClientInfo: exception = 0x%lx", status));
                OglReleaseGlobalMutex();
                return(TRUE);
            }
        }
        clientInfo->flags &= ~NV_OGL_CLIENT_CONTEXT_INFO;
        clientInfo->clientContextInfo = NULL; // just for good measure...
    }

    clientInfo->hDrvObj = 0;
    clientInfo->flags   = 0;

    //
    // Remove from global client list.
    //
    OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));

    OglDebugPrint("****************** Context CALLBACK: client count = %ld\n", globalOpenGLData.oglClientCount);

    OglReleaseGlobalMutex();

    return(TRUE);
}

#if ( NVARCH >= 0x4)
void NV_OglInitState(PDEV *ppdev, void *cmdInfo)
{
    __glNVInitSharedFnPtrs((__GLNVcmdInfo *)cmdInfo);
    ppdev->oglSyncGdi       = ((__GLNVcmdInfo *)cmdInfo)->syncGdi;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglDD.h ===
#ifndef __OGLDD_H
#define __OGLDD_H

// DirectDraw ------------------------------------------------------
#if _WIN32_WINNT >= 0x0500
#include "nvPriv.h"

// ----- Escapes: these are duplicated in escape.h to block out these numbers
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88

// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89

// ----- Prototypes
extern NVS2VERROR __stdcall nvMoComp(LPNVS2VDATATYPE lpS2VData);
extern NVOCERROR __stdcall nvOverlayControl(LPNVOCDATATYPE lpOCData);
#endif  // WINNT >= 0x500

// OGL -------------------------------------------------------------

//*************************************************************************
// OGLSERVER
// 
// This structure is hooked to the display driver ppdev, created at startup
// time of the driver (DrvEnableSurface and deleted in DrvDisableSurface). 
// On creation it is initialized with 0 (zero), you can rely on this!
// It should be used to store all OpenGL server related data. 
// All OpenGL stuff inside ppdev will be moved to this structure (later).
//
// Please add a good comment to all variables!
//*************************************************************************
typedef struct _OGLSERVER
{
    // rclAllClientsBounds is the bounding rectangle around all visible
    // OpenGL clients.
    RECTL rclAllClientsBounds; 

    // bGdiInOglWindowNeedsSync to determine if a GDI command was rendering 
    // to the OGL window and needs to be synced before OGL is allowed to 
    // continue.
    // TRUE:  GDI is rendering to OGL window and needs to be synced before 
    //        OGL is rendering!
    // FALSE: nothing needs to be done
    BOOL  bGdiInOglWindowNeedsSync;   

    // bWindowInMovement is used to notify the oglsync code that a 
    // copy on windowmove of the ogl is in progress.
    // TRUE  : OGL window is moving.
    // TRUE  : OGL window isn't moving.
    BOOL  bWindowInMovement;          

    // ulPageFlipRetryCounter will control how and if bOglPageFlipModeUpdate
    // is allowed to enable pageflipping again, after it was disabled.
    ULONG ulPageFlipRetryCounter;     
} OGLSERVER;


//
// Defines used to work with OGLSERVER->ulPageFlipRetryCounter
// PAGEFLIP_IMMEDIATE_UPDATE
//      An immediate pageflip update is enabled. This is the default 
//      behaviour of the driver. Pageflip updates are not defer and 
//      the retry counter is disabled.
//      
// PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP
//      retry to enable pageflipping in next swap buffers
//
// PAGEFLIP_RETRY_COUNTER_START >= i > PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP
//      countdown area, do not enable pageflipping within this area
//
// PAGEFLIP_RETRY_COUNTER_START
//      Use this to initialize the counter. As long it is within the 
//      countdown area, pageflipping isn't enabled!
#define PAGEFLIP_IMMEDIATE_UPDATE           0
#define PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP  1
#define PAGEFLIP_RETRY_COUNTER_START        (ppdev->ulGDIRefreshRate)


//******************************************************************
// This is the maximum number of ddraw surfaces that we allow to
// exist before we disable window flipping for OpenGL.  This is tested
// against in __glNVDoDACParams() and in NV_OglDDrawSurfaceCreated().
//
// The surface count lives in ppdev->oglDDrawSurfaceCount and is
// incremented by NV_OglDDrawSurfaceCreated() and decremented by
// NV_OglDDrawSurfaceDestroyed().  On NT5, the real ddraw driver calls
// these routines from CreateSurface32/DestroySurface32 in the ddraw
// subtree.  On NT4 they are called from within the display driver in
// DdCreateSurface and Nv4DestroySurface since ddraw is built into the
// display driver.
//
// For NT5 this maximum is 2 since running any opengl app will create 
// 2 ddraw surfaces. On NT4, no ddraw surfaces are created for an opengl
// app so anything above 0 signifies that an actual ddraw app was
// started
//******************************************************************
#if _WIN32_WINNT >= 0x0500
#define OGL_MAX_DDRAW_SURFACES_FOR_FLIPPING 2
#else
#define OGL_MAX_DDRAW_SURFACES_FOR_FLIPPING 0
#endif

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

#ifdef _WIN64
#define __GLNV_FENCE()                                                  \
{                                                                       \
    extern void nvFence(void);                                          \
                                                                        \
    nvFence();                                                          \
}
#else
#define __GLNV_FENCE()                                                  \
{                                                                       \
    GLuint dummy = 0xDEADBEEF;                                          \
    GLuint *fencePtr = &dummy;                                          \
    __asm mov  eax, (fencePtr)                                          \
    __asm xchg [eax], ecx                                               \
}
#endif

#define OGL_CLIENT_DLL_NAME_NV4                 L"nvoglnt.dll"
#define OGL_CLIENT_DLL_NAME_NV3                 L"nv3oglnt.dll"



#define NV_OGL_CLIENT_DRAWABLE_INFO 0x0001 // if bit ON then drawable info exists...
#define NV_OGL_CLIENT_CONTEXT_INFO  0x0002 // if bit ON then context info exits...
#define NV_OGL_CLIENT_SHARED_INFO   0x0004 // if bit ON then context info exits...
#define NV_OGL_CLIENT_WOC_DELETE    0x0008 // if bit ON then WOC_DELETE occured on window...
#define NV_OGL_CLIENT_RM_CLIENT     0x0010 // if bit ON then tracking RM client in node

//
// Use client side rectangle list or display driver side...
//
#undef USE_CLIENT_RECT_LIST
#define USE_CLIENT_RECT_LIST 1


/*******************************************************************************
 *
 *    Useful information for OpenGL support.  Not guaranteed to work.
 *
 ******************************************************************************/


#define     OPENGL_CMD              4352
#define     OPENGL_GETINFO          4353
#define     NV_OPENGL_SET_ENABLE    0x6988
#define     OPENGL_GETINFO_DRVNAME  0

#define     OPENGL_ICD_VER          2
#define     OPENGL_DRIVER_VER       0x10000
#define     OPENGL_KEY_NAME_NV3     L"RIVA128"
#define     OPENGL_KEY_NAME_NV4     L"RIVATNT"

typedef struct {
    unsigned long   ulVersion;
    unsigned long   ulDriverVersion;
    unsigned char   awch[ MAX_PATH + 1 ];
} OPENGL_INFO, FAR *LP_OPENGL_INFO;

#define     ESC_ALLOC_CONTEXT_DMA                   0x6989
#define     ESC_FREE_CONTEXT_DMA                    0x698A
#define     ESC_ALLOC_CHANNEL_DMA                   0x698B
#define     ESC_FREE_CHANNEL_DMA                    0x698C
#define     ESC_DMA_FLOW_CONTROL                    0x698D
#define     ESC_SET_GAMMA_RAMP                      0x698E
#define     ESC_GET_GAMMA_RAMP                      0x698F
#define     ESC_GET_PIXEL_FORMAT                    0x7000
#define     ESC_NV_OPENGL_DMA_PUSH_GO               0x7001

// Reserving Escape for Intel Diagnostics - Escape value is ASCII "nv"+1
#define     ESC_INTEL_DIAGNOSTICS                   0x6e77

/*******************************************************************************
 * Macros for PAGE ALIGNMENT and PAGE SIZE.
 *
 * It would be preferable to grab this out of the DDK header files,
 * but the Windows SDK header files conflict with the DDK header files.
 ******************************************************************************/

#ifdef _M_IA64

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x2000
#endif

#ifndef PAGE_SHIFT
#define PAGE_SHIFT 13L
#endif

#else // #ifdef _M_IA64

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

#ifndef PAGE_SHIFT
#define PAGE_SHIFT 12L
#endif

#endif // #ifdef _M_IA64

#ifndef BYTES_TO_PAGES
#define BYTES_TO_PAGES(Size)  (((ULONG)(Size) >> PAGE_SHIFT) + \
                            (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))
#endif

#ifndef ROUND_TO_PAGES
#define ROUND_TO_PAGES(Size)  (((ULONG)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))
#endif


#define PAGE_ALIGN_UP(Va) ((PVOID)(((ULONG_PTR)(Va) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)))

/************************************WARNING*******************************************/
/********* These are duplicated from OpenGL gl\glcore.h********************************/
/**************************************************************************************/

typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

#ifdef _WIN32
typedef struct __GLregionRectRec {
    /* lower left (inside the rectangle)  = (x0, y0)*/
    /* upper right (outside the rectangle)   = (x1, y1)*/
    /* This structure is modified and arranged so that it matches with win32
     * structure RECT and the structure RECTL used by DDK.
     * This avoids us doing extra copies of the rectangle lists
     * when we share the code in Display Driver.
     * RECT structure is
     * typedef struct _RECT 
     * {    
     *  // rc     
     *      LONG left;     
     *      LONG top;     
     *      LONG right; 
     *      LONG bottom; 
     *  } RECT;  
     * the order of the members (x0, y1, x1, y0).
     */ 
    LONG x0;  /* left */
    LONG y0;  /* top   $%$%$ XXX NEED TO REPAIR nv10pushbufclip to have correct meaning of y1 = TOP, y0 = BOTTOM*/
    LONG x1;  /* right */
    LONG y1;  /* bottom */
} __GLregionRect;
#else // _WIN32
typedef struct __GLregionRectRec {
    /* lower left (inside the rectangle)  = (x0, y0)*/
    /* upper right (outside the rectangle)   = (x1, y1)*/
    /* This structure is modified and arranged so that it matches with win32
     * structure RECT and the structure RECTL used by DDK.
     * This avoids us doing extra copies of the rectangle lists
     * when we share the code in Display Driver.
     * RECT structure is
     * typedef struct _RECT 
     * {    
     *  // rc     
     *      LONG left;     
     *      LONG top;     
     *      LONG right; 
     *      LONG bottom; 
     *  } RECT;  
     * the order of the members (x0, y1, x1, y0).
     */ 
    int x0;  /* left */
    int y0;  /* top   $%$%$ XXX NEED TO REPAIR nv10pushbufclip to have correct meaning of y1 = TOP, y0 = BOTTOM*/
    int x1;  /* right */
    int y1;  /* bottom */
} __GLregionRect;
#endif // _WIN32

#include "nvEscDef.h"
#include "nvcom.h"

//////////////////////////////////////////////////////////////////////
// OpenGL exports.
VOID OglRemoveClient(PDEV *ppdev, NV_OPENGL_CLIENT_INFO_LIST *clientList);
NV_OPENGL_DRAWABLE_INFO *CreateDrawableClientInfo(SURFOBJ *pso, HWND hWnd, HDC hDC, struct tagPIXELFORMATDESCRIPTOR *ppfd);
VOID DestroyDrawableClientInfo(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG deleteFlag);
ULONG CreateContextClientInfo(PDEV *ppdev, HWND hWnd, ULONG hClient);
VOID DestroyContextClientInfo(PDEV *ppdev, ULONG hClient, ULONG deleteFlag);
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWndHDC(PDEV *ppdev, HWND hWnd, HDC hDc);
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWnd(PDEV *ppdev, HWND hWnd);
VOID CALLBACK DrvClipChanged(WNDOBJ *pwo, FLONG fl);
VOID CALLBACK DrvClipChanged1(WNDOBJ *pwo, FLONG fl);
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoHClient(PDEV *ppdev, ULONG hClient);
NV_OPENGL_CLIENT_INFO *OglFindDrawableInClientInfoList(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *inDrawablePtr);
VOID OglDebugPrintFunc(PCHAR DebugMessage, ...);
NV_OPENGL_CLIENT_INFO_LIST *OglAppendToClientInfoList(
    PDEV    *ppdev,
    DWORD   flags,                               // bits indicating allocated/free resources
    HDRVOBJ hDrvObj,                             // driver object handle for this client
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo, // drawable information for this client
    NV_OPENGL_CONTEXT_INFO  *clientContextInfo); // context information for this client
void OglRemoveFromClientInfoList(PDEV *ppdev, NV_OPENGL_CLIENT_INFO_LIST *toFree);
void OglRemovePdevListFromClientList(NV_OPENGL_CLIENT_INFO_LIST *clientList);

NV_OPENGL_CLIENT_INFO_LIST *OglFindClientListFromClientInfo(PDEV *ppdev, NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL OglValidateDrawableInfo(NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
void CreateSharedClientInfo(PDEV *ppdev, ULONG hClient, ULONG processHandle, PVOID *globalData, PVOID *pfifoAddress, PVOID *pbusAddress);
void DestroySharedClientInfo(PDEV *ppdev, ULONG hClient, ULONG processHandle, PVOID globalData, ULONG deleteFlag);
BOOL OglEngDeleteDriverObj(PDEV *ppdev, NV_OPENGL_CLIENT_INFO *clientInfo, ULONG flags);
void OglIncClientCount(PDEV *ppdev);
void OglDecClientCount(PDEV *ppdev);
BOOL OglMapGlobalPageAddress(PDEV *ppdev, PVOID *globalData);
BOOL OglUnmapGlobalPageAddress(PDEV *ppdev, PVOID globalData);
BOOL OglMapPFifoAddress(PDEV *ppdev, PVOID *pfifoAddress);
BOOL OglUnmapPFifoAddress(PDEV *ppdev, PVOID pfifoAddress);
BOOL OglMapPBusAddress(PDEV *ppdev, PVOID *pbusAddress);
BOOL OglUnmapPBusAddress(PDEV *ppdev, PVOID pbusAddress);
BOOL OglAcquireClipMutex(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
VOID OglReleaseClipMutex(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
#if DBG
BOOL OglVerifyClientList(PDEV *ppdev, char *s);
#endif // DBG

void OglChannelWait(PDEV *ppdev, ULONG ourChannelId, ULONG maskOtherChannels);
ULONG NV4_OglSwapBuffers(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG hClient, __GLNVswapInfo *swapInfo);
ULONG NV4_OglFlushClipped(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG hClient, __GLNVflushInfo *flushInfo);
void NV_OglInitState(PDEV *ppdev, void *cmdInfo);
void NV_OglGetAppSupportSettings(PDEV *ppdev);

#if (NVARCH >= 0x4)
ULONG NV_OglSwapBuffers(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG hClient, __GLNVswapInfo *swapInfo);
ULONG NV_OglFlushClipped(PDEV *ppdev, HWND hWnd, HDC hDC, ULONG hClient, __GLNVflushInfo *flushInfo);
ULONG NV_OglOverlayMergeBlit(PDEV *ppdev, HWND hWnd, HDC hDC, __GLNVoverlayMergeBlitInfo *mergeInfo);
ULONG NV_OglOperation(PDEV *ppdev, HWND hWnd, HDC hDC, __GLNVoperation *op);
BOOL NV_OglUpdateClipLists(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);

// This lives in the shared lib and is called into only by the display driver
void STDCALL __glNVKickOffPushBufferNT(__GLNVcmdInfo *cmdInfo);
void STDCALL __glNV4KickOffPushBufferNT(__GLNVcmdInfo *cmdInfo);
#endif  // (NVARCH >= 0x4)

void CombineRectLists(RECTL *, ULONG , RECTL *, ULONG, LONG, LONG, RECTL *, ULONG *);

int OglAllocUnifiedSurfaces(PDEV *ppdev, __GLNVsbdFlags *sbdFlags);
int OglFreeUnifiedSurfaces(PDEV *ppdev);
NvU32 OglGetUnifiedSurfaceInfo(PDEV *ppdev, __GLNVsbdFlags *sbdFlags);
void OglTranslateCachedClipRectList(PDEV *ppdev,
                                    RECTL *srcRects, ULONG srcNumRects, 
                                    RECTL *destRects, ULONG *destNumRects,
                                    RECTL *boundingBox);
void OglTranslateClientRelativeRectListToDevice(PDEV *ppdev,
                                    RECTL *srcRects, ULONG srcNumRects, 
                                    RECTL *destRects, ULONG *destNumRects,
                                    RECTL *boundingBox);
void OglRegisterRmClient(PDEV *ppdev, ULONG rmClient);
void OglUnRegisterRmClient(PDEV *ppdev, ULONG rmClient);
ULONG OglCpuBlit(PDEV *ppdev, __GLNvCpuBltData *oglNVCpuBltData);
void OglReadRegistry(PDEV *ppdev);


void OglUseDisplayDriverBlt(
    PDEV *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    LONG srcOffset,
    LONG srcPitch,
    LONG srcLeft, 
    LONG srcTop, 
    LONG dstOffset,
    LONG dstPitch,
    LONG dstLeft, 
    LONG dstTop, 
    LONG width, 
    LONG height);

BOOL bGetOglClientInfoHWnd(struct _NV_OPENGL_CLIENT_INFO *clientInfo, HWND* phWnd);
BOOL bExchangeClientsFrontAndBack(PPDEV,NV_OPENGL_DRAWABLE_INFO*);//resides in oglsurf.c
VOID vOglFlipChangedUpdate(PPDEV ppdev, NV_OPENGL_CLIENT_INFO*);
VOID vFlipToPrimary(PPDEV);//resides in oglsurf.c
void OglAllocateAndCopyWindowClipList(PDEV *, NV_OPENGL_DRAWABLE_INFO *, RECTL *, ULONG);

#endif // __OGD_DD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglcmd.c ===
//******************************Module*Header***********************************
// Module Name: oglcmd.c
//
// OpenGL command dispatcher
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

// import
#include "precomp.h"
#include "driver.h"
#include "nvdoublebuf.h"
#include "oglDD.h"
#include "oglutils.h"
#include "oglclip.h"
#include "Nvcm.h"

#if (NVARCH >= 0x4)

ULONG
NV_OglOperation(
    PDEV *ppdev,
    HWND hWnd,
    HDC hDC,
    __GLNVoperation *op
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    RECTL                      *windowRectList;
    ULONG                      numWindowRects;

    /* TODO -
     * perform the windowChangedCount test here
     * cache window-relative clip list so we don't have to compute it here
     */

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList) {
        clientInfo = &clientList->clientInfo;
    }  else {
        OglDebugPrint("NV_OglOperation: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        op->retStatus = NVOP_STATUS_ERROR; // OGL_ERROR_CLIENT_NOT_FOUND
        return FALSE;
    }

    if (clientInfo) {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
    } else {
        OglDebugPrint("NV_OglOperation: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        op->retStatus = NVOP_STATUS_ERROR; // OGL_ERROR_CLIENT_NOT_FOUND
        return FALSE;
    }

    if (FALSE == NV_OglUpdateClipLists(ppdev, clientDrawableInfo)) {
        OglDebugPrint("NV_OglOperation: bailing OGL_ERROR_REALLOC_FAILURE\n");
        op->retStatus = NVOP_STATUS_ERROR; // OGL_ERROR_REALLOC_FAILURE;
        return FALSE;
    }

    op->clip.numRects = clientDrawableInfo->cachedNumClipRects;
    op->clip.rects = (__GLregionRect *)clientDrawableInfo->cachedClipRectList;
    
    op->cmdInfo->ntOther      = (void *)ppdev;
    op->cmdInfo->ntDrawable   = (void *)clientDrawableInfo;
    op->cmdInfo->ntClientInfo = clientInfo;
    ASSERT(bOglHasDrawableInfo(op->cmdInfo->ntClientInfo));

    switch (op->opCode) {
    case NVOP_CLEAR:
        //__glNVSetupClear(op);
        return TRUE;
    case NVOP_SWAP: // not yet
    default:
        op->retStatus = NVOP_STATUS_UNKNOWN_OP;
        return FALSE;
    }
}

#endif  // #if (NVARCH >= 0x4)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ogldebug.h ===
#ifndef _OGLDEBUG_H
#define _OGLDEBUG_H
//******************************Module*Header***********************************
// Module Name: ogldebug.h
//
// special debug code for ogl server part of display driver
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

#if DBG
//******************************************************************************
#ifndef _DEBUG_H
#error ogldebug.h needs debug.h!
#endif

// DrvClipChanged-WOC-Flags stuff
char *szDbg_WOC_flGet(ULONG fl);
#define DBG_PRINT_WOC_FL(lvl,str,pfn,fl) vDbg_PrintDBG_NAMEINDEXfl(lvl,str,szDbg_WOC_flGet,fl)

//
//******************************************************************************
#else  // DBG
//******************************************************************************
// In a free build remove all debug defines
//

#define DBG_PRINT_WOC_FL(lvl,str,pfn,fl)


//******************************************************************************
#endif // DBG
#endif // _OGLDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ogldrwbl.c ===
/******************************Module*Header*******************************\
* Module Name: ogldrwbl.c
*
* This module contains the functions to support the OpenGL client side
* drawable interface.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "oglflip.h"
#include "oglOverlay.h"
#include "Nvcm.h"

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

#ifndef WO_RGN_DESKTOP_COORD
#define WO_RGN_DESKTOP_COORD 0x100
#endif

static BOOL MapDrawableClientAddress(PDEV *ppdev, 
                                     NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo, 
                                     NV_SYSMEM_SHARE_MEMORY *sysmemShareMemoryOut);
static BOOL UnmapDrawableClientAddress(PDEV *ppdev,
                                       NV_OPENGL_DRAWABLE_INFO  *clientDrawableInfo);
static BOOL MapDrawableGlobalPageAddress(PDEV *ppdev,
                                         NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
static BOOL UnmapDrawableGlobalPageAddress(PDEV *ppdev, 
                                           NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
static void CopyOrigClipList(PDEV *, NV_OPENGL_DRAWABLE_INFO *);

BOOL CALLBACK ClientDrawableDrvFreeObj(DRIVEROBJ *pDriverObj);

//******************************************************************************
//
//  Function:   CreateDrawableClientInfo
//
//  Routine Description:
//
//      This routine associates a window with client supplied information.  Window
//      change events are tracked by DrvClipChanged and the client information is
//      updated.  This function is called in response to the client side escape.
//
//  Arguments:
//
//  Return Value:
//
//      NULL indicates an allocate problem; otherwise user virtual address
//
//******************************************************************************
NV_OPENGL_DRAWABLE_INFO *CreateDrawableClientInfo(
    SURFOBJ *pso,
    HWND    hWnd,
    HDC     hDC,
    PIXELFORMATDESCRIPTOR *ppfd
)
{
    int i;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    WNDOBJ                  *pwo = (WNDOBJ *)NULL;
    HDRVOBJ                 hDrvObj = (HDRVOBJ)NULL;
    PDEV                    *ppdev = (PDEV *)pso->dhpdev;
    NV_SYSMEM_SHARE_MEMORY  sysmemShareMemoryOut;
    LONG                    status;
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;
    PVOID				    origClientDrawableInfoPtr;
    FLONG                   flWindowTrackingFlags;

    DISPDBG((2, "CreateDrawableClientInfo: hWnd = 0x%p hDC = 0x%p", hWnd, hDC));

    //
    // Create window object to track changes to this window in DrvClipChanged
    //
    flWindowTrackingFlags = 
#if _WIN32_WINNT >= 0x0500
                            WO_RGN_UPDATE_ALL | WO_RGN_CLIENT | WO_RGN_DESKTOP_COORD;
#else
                            WO_RGN_CLIENT;
#endif


    // In an overlay environment we need the delta client messages to 
    // update the overlay layout to not have garbage in our overlaybuffer
    if(ppdev->bOglOverlayDesired)
    {
        flWindowTrackingFlags |= WO_RGN_CLIENT_DELTA   // to clear newly entered overlay region
                              |  WO_RGN_SURFACE_DELTA; // to clear regions without overlay in default transparent color
    }

    //
    // Workstation features need extra functionality
    //
    if(   HWGFXCAPS_UBB(ppdev) 
       && HWGFXCAPS_QUADRO_GENERIC(ppdev))
    {
        // want to get a negative clip list
        // this is only necessary while window flipping is enabled
        flWindowTrackingFlags |= WO_RGN_SURFACE;
    }

    //
    // NOTE: It is very important that all calls to engcreatewnd use the same flWindowTrackingFlags!
    //       All pathes above cannot change while ogl is running!
    //

    pwo = EngCreateWnd(pso,
                       hWnd,DrvClipChanged,
                       flWindowTrackingFlags,
                       0L);

    DISPDBG((1, "CreateDrawableClientInfo: create WNDOBJ (pwo = 0x%p)", pwo));

    clientDrawableInfo = NULL;
    if (pwo == (WNDOBJ *)0) 
    {
        //this is an error case which results in an assertion in the ICD years later
        // => assert it here !!
        ASSERT(pwo != NULL);
        DISPDBG((0, "CreateDrawableClientInfo - Failed EngCreateWnd"));
        return(NULL);
    }
    else if (pwo == (WNDOBJ *)-1)
    {
        DISPDBG((2, "CreateDrawableClientInfo - Already tracking hWnd"));
        clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
        if (clientList)
        {
            clientInfo = &clientList->clientInfo;
        }
        if (clientInfo)
        {
            clientDrawableInfo = clientInfo->clientDrawableInfo;
            clientDrawableInfo->refCount++;
            DISPDBG((1, "CreateDrawableClientInfo: hWnd = 0x%p, refCount=0x%x", hWnd, clientDrawableInfo->refCount));
            return(clientDrawableInfo->userVirtualAddress);
        }
        else
        {
            //
            // Lets see GDI is tracking the window but we can't find it in our
            // list.  This is very bad.
            //
            if (ppdev->numDevices == 1)
                {
                return(NULL);
                }
            //
            // In multi-device world we track the window on multiple devices
            // but EngCreateWnd fails.  So, just create the drawable node and
            // let DrvClipChanged update multiple nodes.  This works around
            // a limitation in EngCreateWnd.
            //
        }
    }

    /* Since we are not guaranteed page aligned allocation,
     * we need to allocate an extra PAGE_SIZE - 1 memory and use
     * memory starting from next page. */
    origClientDrawableInfoPtr = clientDrawableInfo = 
        EngAllocMem(FL_ZERO_MEMORY, (sizeof(NV_OPENGL_DRAWABLE_INFO) + PAGE_SIZE -1), ALLOC_TAG);

    if (clientDrawableInfo == NULL)
    {
        DISPDBG((2, "CreateDrawableClientInfo - Failed EngAllocMem"));
        return(NULL);
    }

    
    clientDrawableInfo = (NV_OPENGL_DRAWABLE_INFO *)PAGE_ALIGN_UP(clientDrawableInfo);
    clientDrawableInfo->origClientDrawableInfoPtr = origClientDrawableInfoPtr;

    clientDrawableInfo->bOrigClipList = FALSE; // do not copy the original clip list by default
    clientDrawableInfo->origWindowRectList = NULL;

    //
    // Initialize the clientDrawableInfo structure
    //
    clientDrawableInfo->hWnd      = hWnd;
    clientDrawableInfo->hDC       = hDC;
    clientDrawableInfo->cachedClipRectList = NULL; // It is already zero..but to clarify..
    clientDrawableInfo->overlayMember = (ppfd->bReserved != 0);

    //
    // If we created a window object then map a system address to the client
    // address and use it for accessing the structure in the display driver.
    //
    DISPDBG((1, "CreateDrawableClientInfo: SetConsumer (pv = 0x%p)", clientDrawableInfo));
    if (MapDrawableClientAddress(ppdev,
                                 clientDrawableInfo,
                                 &sysmemShareMemoryOut) == TRUE)
    {
        //
        // Get pointer to new client.
        //
        clientList = OglAppendToClientInfoList(ppdev, 
                                               0, 
                                               0, 
                                               clientDrawableInfo, 
                                               NULL);
        if (clientList)
            {
            clientInfo = &clientList->clientInfo;
            }
        else
            {
            UnmapDrawableClientAddress(ppdev, clientDrawableInfo);
            EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
            OglDebugPrint("CreateDrawable: OglAppendToClientInfoList: FAILED\n");
            return(NULL);
            }

        OglDebugPrint("ALLOC: clientDrawableInfo = 0x%p\n", clientDrawableInfo);

        if (MapDrawableGlobalPageAddress(ppdev, clientDrawableInfo) == FALSE)
        {
            UnmapDrawableClientAddress(ppdev, clientDrawableInfo);
            EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
            OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
            OglDebugPrint("FREE: clientDrawableInfo = 0x%p\n", origClientDrawableInfoPtr);
            return(NULL);
        }

        OglDebugPrint("****************** CreateDrawable: client count = %ld\n", globalOpenGLData.oglClientCount);

        //
        // Create driver object that tracks this client index with the client process
        //
        hDrvObj = EngCreateDriverObj((PVOID)clientInfo, ClientDrawableDrvFreeObj, ppdev->hdevEng);
        if (hDrvObj == NULL)
        {
            DISPDBG((1, "CreateDrawableClientInfo: FAILED EngCreateDriverObj"));
            OglDebugPrint("****************** FAILURE CreateDrawable: client count = %ld\n", globalOpenGLData.oglClientCount);
            UnmapDrawableGlobalPageAddress(ppdev, clientDrawableInfo);
            UnmapDrawableClientAddress(ppdev, clientDrawableInfo);
            EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
            OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
            OglDebugPrint("FREE: clientDrawableInfo = 0x%p\n", origClientDrawableInfoPtr);
            return(NULL);
        }
        //
        // Save driver object and mode switch count.
        //
        clientInfo->hDrvObj         = hDrvObj;
        clientInfo->modeSwitchCount = ppdev->dwGlobalModeSwitchCount;
        clientInfo->ppdev           = ppdev;
        clientInfo->pfd             = *ppfd;

        // Allocate the cached clip list now.
        clientDrawableInfo->cachedClipRectList = 
            EngAllocMem(FL_ZERO_MEMORY, 
                    (sizeof(RECTL) * MAX_OGL_CLIP_RECTS), ALLOC_TAG);

        if (clientDrawableInfo->cachedClipRectList == NULL)
        {
            DISPDBG((1, "CreateDrawableClientInfo  - Failed EngAllocMem  of CachedClipRectList"));
            OglDebugPrint("****************** FAILURE CreateDrawable: EngAllocMem  of CachedClipRectList");
            UnmapDrawableGlobalPageAddress(ppdev, clientDrawableInfo);
            UnmapDrawableClientAddress(ppdev, clientDrawableInfo);
            EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
            OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));
            OglDebugPrint("FREE: clientDrawableInfo = 0x%p\n", origClientDrawableInfoPtr);
            return(NULL);
        }

        clientDrawableInfo->cachedNumClipRects = 0;
        clientDrawableInfo->cachedClipListSize = MAX_OGL_CLIP_RECTS;
        clientDrawableInfo->cachedClipListDirty = TRUE;
        clientDrawableInfo->cachedExclusiveRectList = NULL; // we will allocate it if needed.
        clientDrawableInfo->cachedNumExclusiveRects = 0; 

        clientDrawableInfo->copyWindowRect = &(clientDrawableInfo->windowRect[0]);
        clientDrawableInfo->sizeCopyWindowRectList = MAX_OGL_CLIP_RECTS;

        //
        // DrvClipChanged is called with the pointer in the second
        // argument to WNDOBJ_vSetConsumer.  We pass in the display driver
        // address mapping to the clientInfo structure.
        //
        if (pwo && pwo != (WNDOBJ *)-1)
        {
            WNDOBJ_vSetConsumer(pwo, (PVOID)clientInfo);
            clientInfo->pwo = pwo;
        }

        //
        // Inititalize width and height of display for this drawable.
        //
        clientDrawableInfo->cxScreen = ppdev->cxScreen;
        clientDrawableInfo->cyScreen = ppdev->cyScreen;

        //
        // Initialize flags for this client.  Drawable is ALWAYS created before context...
        //
        clientInfo->flags = NV_OGL_CLIENT_DRAWABLE_INFO;

        if (ppdev->numDevices > 1)
        {
            if (pwo && pwo != (WNDOBJ *)-1)
            {
                // if we got a valid pwo then this is the first client to start tracking
                // a window.  this client is the one where the original unclipped window
                // rectangle list will be stored.
                clientDrawableInfo->origWindowRectList =  
                    EngAllocMem(FL_ZERO_MEMORY, sizeof(RECTL)*clientDrawableInfo->sizeCopyWindowRectList, ALLOC_TAG);
                if( NULL != clientDrawableInfo->origWindowRectList )
                {
                    clientDrawableInfo->bOrigClipList = TRUE;
                }
                else
                {
                    DISPDBG((0,"CreateDrawableClientInfo could not allocate %d byte for origWindowRectList",
                        (sizeof(RECTL)*clientDrawableInfo->sizeCopyWindowRectList) ));
                }
            }
            else
            {
                // on a multi-monitor system, the first client drawable info copies
                // the window clip list.  this list must be copied into all other 
                // client drawable info structures that are tracking the HWND.
                CopyOrigClipList(ppdev, clientDrawableInfo);
            }
        }

        OglDebugPrint("CreateDrawable = 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientDrawableInfo);
    }
    else
    {
        DISPDBG((1, "CreateDrawableClientInfo: FAILED MapDrawableClientAddress"));
        EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
        OglDebugPrint("FREE: clientDrawableInfo = 0x%p\n", origClientDrawableInfoPtr);
        return(NULL);
    }
    
    globalOpenGLData.oglDrawableClientCount++ ;
    
    clientDrawableInfo->refCount = 1;

    // If we have more than one opengl window than we can't flip.
    // Need to restore the DAC to point to the primary surface.
    // we are now able to decide if a previously found DDraw app is an ICD app in real
    ASSERT(NULL!=clientInfo);
    bRemovePointerFromList(&ppdev->oglDDrawSurfaceCountList,(PULONG)((ULONG_PTR)clientInfo->dwProcessID));
    ppdev->oglDDrawSurfaceCount = ulGetNumberOfPointersInList(&ppdev->oglDDrawSurfaceCountList);
    bOglPageFlipModeUpdate(ppdev);

    return(clientDrawableInfo->userVirtualAddress);
}

//******************************************************************************
//
//  Function:   DestroyDrawableClientInfo
//
//  Routine Description:
//
//      This routine frees the client drawable info structure and unbinds it
//      to the window.  This is called in reponse to the client side escape
//      or when the client side process dies.
//
//  Arguments:
//
//  Return Value:
//
//      VOID
//
//******************************************************************************
void DestroyDrawableClientInfo(
    PDEV *ppdev,
    HWND hWnd,
    HDC hDC,
    ULONG deleteFlag
)
{
    int i;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    PVOID						origClientDrawableInfoPtr;

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }

//    if (OGL_FLIPPED()) {
//        vFlipToPrimary(ppdev);
//    }

    if ( bOglHasDrawableInfo(clientInfo) )
    {
        NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryOut;

        DISPDBG((1, "DestroyDrawableClientInfo: hWnd = 0x%p", hWnd));

        // note: on a call by the drvobj callback refCount will be explicitly
        // set to 1 to make sure all resources get freed
        // (see ClientDrawableDrvFreeObj)
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        ASSERTDD(clientDrawableInfo->refCount, "DestroyDrawableClientInfo: illegal refCount!!");
        if (--clientDrawableInfo->refCount)
        {
            // still referenced ??
            DISPDBG((1, "DestroyDrawableClientInfo: hWnd = 0x%p, refCount=0x%x", hWnd, clientDrawableInfo->refCount));
            return;
        }

        // MSchwarzer 9/28/2000 remove palette from global structure if there is one
        if (   bOglIsOverlayClient(clientInfo)
            && !OglDestroyLayerPalette(hWnd) )
        {
            // no palette or error ?
            DISPDBG((0, "DestroyDrawableClientInfo: OglDestroyLayerPalette( hWnd = 0x%p) failed", hWnd));
        }

        UnmapDrawableGlobalPageAddress(ppdev, clientDrawableInfo);
        UnmapDrawableClientAddress(ppdev, clientDrawableInfo);

        //
        // Free memory associated with cached clip list of client drawable info.
        //
        if (clientDrawableInfo->cachedClipRectList)
        {
            EngFreeMem(clientDrawableInfo->cachedClipRectList);
        }

        //
        // Free memory associated with cached exclusive clip list of client drawable info.
        //
        if (clientDrawableInfo->cachedExclusiveRectList)
        {
            EngFreeMem(clientDrawableInfo->cachedExclusiveRectList);
        }
        //
        // Free memory associated with copy Clip Window rect if allocated
        //
#ifndef NV3
        if ((clientDrawableInfo->sizeCopyWindowRectList > MAX_OGL_CLIP_RECTS) && 
            (clientDrawableInfo->copyWindowRect != NULL) &&
            (clientDrawableInfo->copyWindowRect != (&(clientDrawableInfo->windowRect[0])))) {
            EngFreeMem(clientDrawableInfo->copyWindowRect);
            clientDrawableInfo->sizeCopyWindowRectList = 0;
            clientDrawableInfo->copyWindowRect = NULL;
            if (clientDrawableInfo->origWindowRectList)
                {
                EngFreeMem(clientDrawableInfo->origWindowRectList);
                clientDrawableInfo->origWindowRectList = NULL;
                }
        }
#endif // NV3

        //
        // Free memory associated with client drawable info.
        //
        origClientDrawableInfoPtr = clientDrawableInfo->origClientDrawableInfoPtr;
        EngFreeMem(clientDrawableInfo->origClientDrawableInfoPtr);
        clientDrawableInfo             = NULL;
        clientInfo->clientDrawableInfo = NULL;

        //
        // Clear drawable bit.
        //
        clientInfo->flags &= ~NV_OGL_CLIENT_DRAWABLE_INFO;

        if (deleteFlag)
            {
            //
            // Delete driver object if possible
            //
            if (OglEngDeleteDriverObj(ppdev, clientInfo, NV_OGL_CLIENT_DRAWABLE_INFO) == TRUE)
                {
                OglDebugPrint("****************** DestroyDrawable: client count = %ld\n", globalOpenGLData.oglClientCount);
                }
            }

        globalOpenGLData.oglDrawableClientCount-- ;
        
        if (globalOpenGLData.oglDrawableClientCount == 0)
            {
            OglFreeUnifiedSurfaces(ppdev);
            }

        OglDebugPrint("DestroyDrawable = 0x%p 0x%p 0x%p\n", ppdev, clientInfo, origClientDrawableInfoPtr);
    }    
}

//******************************************************************************
//
//  Function:   OglFindClientInfoFromHWndHDC
//
//  Routine Description:
//
//      Find a client information structure given a HWND and HDC.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWndHDC(
    PDEV *ppdev, 
    HWND hWnd,
    HDC hDC
)
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    if (ppdev->numDevices > 1)
        {
        // Use hWnd AND hDC to find node...
        while (node)
            {
            if (node->clientInfo.clientDrawableInfo &&
                node->clientInfo.clientDrawableInfo->hWnd == hWnd &&
                node->clientInfo.clientDrawableInfo->hDC == hDC)
                {
                return(node);
                }
            node = node->next;
            }
        }
    else
        {
        // Just use hWnd to find node...
        while (node)
            {
            if (node->clientInfo.clientDrawableInfo &&
                node->clientInfo.clientDrawableInfo->hWnd == hWnd)
                {
                return(node);
                }
            node = node->next;
            }
        }
    return(NULL);
}

//******************************************************************************
//
//  Function:   OglFindClientInfoFromHWnd
//
//  Routine Description:
//
//      Find a client information structure given a HWND and HDC.
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
NV_OPENGL_CLIENT_INFO_LIST *OglFindClientInfoFromHWnd(
    PDEV *ppdev, 
    HWND hWnd
)
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
        {
        if (node->clientInfo.clientDrawableInfo &&
            node->clientInfo.clientDrawableInfo->hWnd == hWnd)
            {
            return(node);
            }
        node = node->next;
        }

    return(NULL);
}

//******************************************************************************
//
//  Function:   ClientDrawableDrvFreeObj
//
//  Routine Description:
//
//      This routine is the callback for freeing the driver object.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the resources are freed.
//
//******************************************************************************
BOOL CALLBACK ClientDrawableDrvFreeObj(
    DRIVEROBJ *pDriverObj
)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    LONG                  status;
    int                   i, clientIndex;
    PDEV                  *ppdev;

    clientInfo = (NV_OPENGL_CLIENT_INFO *)pDriverObj->pvObj;
    ppdev = (PDEV *)pDriverObj->dhpdev;

    OglAcquireGlobalMutex();

    OglDebugPrint("DRAWABLE ***************** DRAWABLE DrvFreeObj = 0x%p 0x%p 0x%p 0x%p\n", ppdev, clientInfo, clientInfo->clientDrawableInfo, clientInfo->clientContextInfo);

    if (OglFindClientListFromClientInfo(ppdev, clientInfo) == NULL)
        {
        // clientInfo was removed from clientList prior to this callback
        // just return because there is nothing to do...
        OglReleaseGlobalMutex();
        return(TRUE);
        }

    //
    // Cleanup drawable info.
    //
    if (clientInfo->flags & NV_OGL_CLIENT_DRAWABLE_INFO)
    {
        if (clientInfo->clientDrawableInfo)
        {
            ASSERT(bOglHasDrawableInfo(clientInfo));
            //
            // Free channel and such.
            //
            NvFree(ppdev->hDriver, 
                   clientInfo->clientDrawableInfo->hClient, 
                   NV01_NULL_OBJECT, 
                   clientInfo->clientDrawableInfo->hClient);

            // At this point we know that the user mode process is dead.
            // Therefore we can safely free any drawableInfo etc
            // => override refCount protection to free resources
            clientInfo->clientDrawableInfo->refCount = 1;

            DestroyDrawableClientInfo(ppdev, 
                                      clientInfo->clientDrawableInfo->hWnd,
                                      clientInfo->clientDrawableInfo->hDC, 
                                      FALSE);
        }
        clientInfo->flags &= ~NV_OGL_CLIENT_DRAWABLE_INFO;
        clientInfo->clientDrawableInfo = NULL; // just for good measure...
    }

    clientInfo->hDrvObj = 0;
    clientInfo->flags   = 0;

    //
    // Remove from global client list.
    //
    OglRemoveFromClientInfoList(ppdev, OglFindClientListFromClientInfo(ppdev, clientInfo));

    OglDebugPrint("****************** Drawable CALLBACK: client count = %ld\n", globalOpenGLData.oglClientCount);

    if (globalOpenGLData.oglDrawableClientCount == 0)
        {
        OglFreeUnifiedSurfaces(ppdev);
        }

    OglReleaseGlobalMutex();

    return(TRUE);
}

//******************************************************************************
//
//  Function:   MapDrawableClientAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the kernel, system
//      address for the shared information into the caller's address space.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
static BOOL
MapDrawableClientAddress(
    PDEV                    *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    NV_SYSMEM_SHARE_MEMORY  *sysmemShareMemoryOut
)
{
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "MapDrawableClientAddress - Entry"));

    sysmemShareMemoryIn.pSystemMdl     = NULL; // miniport WILL allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL = FALSE;
    
    sysmemShareMemoryIn.physicalAddress = 0;
    sysmemShareMemoryIn.userVirtualAddress = (PVOID)NULL;

    sysmemShareMemoryIn.ddVirtualAddress = (PVOID)clientDrawableInfo; // kernel or system address
    sysmemShareMemoryIn.byteLength = sizeof(NV_OPENGL_DRAWABLE_INFO);

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_MAP_TO_USER,
        &sysmemShareMemoryIn,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        sysmemShareMemoryOut,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &dwReturnedDataLength))
    {
        clientDrawableInfo->pClientInfoMdl     = (PVOID)NULL;
        clientDrawableInfo->userVirtualAddress = (PVOID)NULL;
        DISPDBG((2, "MapDrawableClientAddress - IOCTL_VIDEO_MAP_TO_USER failed"));
        return(FALSE);
    }

    //
    // Mapping succeeded, save client address information in client drawable info structure.
    //
    clientDrawableInfo->pClientInfoMdl     = (PVOID)sysmemShareMemoryOut->pSystemMdl;
    clientDrawableInfo->userVirtualAddress = (PVOID)sysmemShareMemoryOut->userVirtualAddress;

    DISPDBG((2, "MapDrawableClientAddress - Exit"));

    return(TRUE);
}

//******************************************************************************
//
//  Function:   UnmapDrawableClientAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the user virtual address
//      into system address space where the display driver can get to it.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
static BOOL
UnmapDrawableClientAddress(
    PDEV                     *ppdev,
    NV_OPENGL_DRAWABLE_INFO  *clientDrawableInfo
)
{
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;
    LONG status;

    DISPDBG((2, "UnmapDrawableClientAddress - Entry"));
    if (clientDrawableInfo && 
        clientDrawableInfo->pClientInfoMdl &&
        clientDrawableInfo->userVirtualAddress)
    {
        sysmemShareMemoryIn.pSystemMdl = (PVOID)clientDrawableInfo->pClientInfoMdl;
        sysmemShareMemoryIn.bDontModifyMDL = FALSE;
        sysmemShareMemoryIn.userVirtualAddress = (PVOID)clientDrawableInfo->userVirtualAddress;

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_UNMAP_FROM_USER,
            &sysmemShareMemoryIn,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &sysmemShareMemoryOut,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &dwReturnedDataLength))
        {
            DISPDBG((2, "UnmapDrawableClientAddress - IOCTL_VIDEO_UNMAP_FROM_USER failed"));
        }
        clientDrawableInfo->userVirtualAddress = (PVOID)NULL;
    }
    else
    {
        DISPDBG((2, "UnmapDrawableClientAddress - clientDrawableInfo NULL"));
    }

    DISPDBG((2, "UnmapDrawableClientAddress - Exit"));
    return(TRUE);
}

//******************************************************************************
//
//  Function:   MapDrawableGlobalPageAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to map the display driver OGL 
//      shared page into the client address space.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the mapping was a success.
//
//******************************************************************************
static BOOL
MapDrawableGlobalPageAddress(
    PDEV                    *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
{
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "MapDrawableGlobalPageAddress - Entry"));

    clientDrawableInfo->oglGlobalPagePtr = NULL;

    sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
    sysmemShareMemoryIn.bDontModifyMDL     = TRUE;
    sysmemShareMemoryIn.physicalAddress    = 0;
    sysmemShareMemoryIn.userVirtualAddress = (PVOID)NULL;

    sysmemShareMemoryIn.ddVirtualAddress   = (PVOID)ppdev->oglGlobalPagePtr;
    sysmemShareMemoryIn.byteLength         = ppdev->oglGlobalPageSize;

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_MAP_TO_USER,
        &sysmemShareMemoryIn,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &sysmemShareMemoryOut,
        sizeof(NV_SYSMEM_SHARE_MEMORY),
        &dwReturnedDataLength))
    {
        clientDrawableInfo->oglGlobalPagePtr = NULL;
        DISPDBG((2, "MapDrawableGlobalPageAddress - IOCTL_VIDEO_MAP_TO_USER failed"));
        return(FALSE);
    }

    // save user address in context info structure
    clientDrawableInfo->oglGlobalPagePtr = (PVOID)sysmemShareMemoryOut.userVirtualAddress;

    DISPDBG((2, "MapDrawableGlobalPageAddress - Exit"));

    return(TRUE);
}

//******************************************************************************
//
//  Function:   UnmapDrawableGlobalPageAddress
//
//  Routine Description:
//
//      This routine calls the miniport driver to unmap the display driver
//      OGL shared page of memory.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE indicates that the unmapping was a success.
//
//******************************************************************************
static BOOL
UnmapDrawableGlobalPageAddress(
    PDEV                   *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
{
    NV_SYSMEM_SHARE_MEMORY sysmemShareMemoryIn, sysmemShareMemoryOut;
    ULONG dwReturnedDataLength;
    LONG status;

    DISPDBG((2, "UnmapDrawableGlobalPageAddress - Entry"));
    if (clientDrawableInfo && 
        clientDrawableInfo->oglGlobalPagePtr)
    {
        sysmemShareMemoryIn.userVirtualAddress = (PVOID)clientDrawableInfo->oglGlobalPagePtr;
        sysmemShareMemoryIn.pSystemMdl         = ppdev->oglGlobalPageMdl; // miniport will NOT allocate MDL
        sysmemShareMemoryIn.bDontModifyMDL     = TRUE;  // miniport will NOT free MDL

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_UNMAP_FROM_USER,
            &sysmemShareMemoryIn,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &sysmemShareMemoryOut,
            sizeof(NV_SYSMEM_SHARE_MEMORY),
            &dwReturnedDataLength))
        {
            DISPDBG((2, "UnmapDrawableGlobalPageAddress - IOCTL_VIDEO_UNMAP_FROM_USER failed"));
            clientDrawableInfo->oglGlobalPagePtr = NULL;
            return(FALSE);
        }
    
        clientDrawableInfo->oglGlobalPagePtr = NULL;
    }
    else
    {
        DISPDBG((2, "UnmapDrawableGlobalPageAddress - clientDrawableInfo NULL"));
    }

    DISPDBG((2, "UnmapDrawableGlobalPageAddress - Exit"));
    return(TRUE);
}


static void
CopyOrigClipList(
    PDEV                    *ppdev,
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *cdiNode = NULL;

    // Document assumptions by using ASSERT...
    ASSERT(ppdev);
    ASSERT(ppdev->numDevices > 1);
    ASSERT(clientDrawableInfo);
    ASSERT(clientDrawableInfo->bOrigClipList == FALSE);
    ASSERT(clientDrawableInfo->origWindowRectList == NULL);

    OglAcquireGlobalMutex();

    cdiNode = globalOpenGLData.oglClientListHead.clientList;
    while (cdiNode)
    {
        clientInfo = &cdiNode->clientInfo;
        if (bOglHasDrawableInfo(clientInfo) &&
            clientInfo->clientDrawableInfo != clientDrawableInfo &&
            clientInfo->clientDrawableInfo->hWnd == clientDrawableInfo->hWnd && // same HWND
            clientInfo->clientDrawableInfo->bOrigClipList == TRUE && // 1st drawable with orignal unclipped rectlist
            clientInfo->clientDrawableInfo->origWindowRectList != NULL) // origWindowRectList allocated
        {
            // cdiNode contains the original unclipped window rectangle list
            // copy it to clientDrawableInfo
            // copy windowrect, too !
            clientDrawableInfo->numClipRects = clientInfo->clientDrawableInfo->numClipRects;
            clientDrawableInfo->rect = clientInfo->clientDrawableInfo->rect;
            OglAllocateAndCopyWindowClipList(ppdev, 
                                             clientDrawableInfo,
                                             clientInfo->clientDrawableInfo->origWindowRectList,
                                             clientInfo->clientDrawableInfo->numClipRects);
            break;
        }

        cdiNode = cdiNode->next;
    }

    OglReleaseGlobalMutex();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\ogloverlay.c ===
/******************************Module*Header*******************************\
* Module Name: ogloverlay.c
*
* OpenGL Overlay plane implementation
*
* Copyright (c) 2000 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvReg.h"
#include "nvcm.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "nvdoublebuf.h"
#include "nvcom.h"

extern VOID NV4_DmaPushSend(PDEV *);

//
// Export 
//
#include "ogloverlay.h"


void OglInitLayerPalette(void)
{
    globalOpenGLData.oglLayerPaletteListHead.paletteList = NULL;
    globalOpenGLData.oglLayerPaletteClientCount = 0;
}

/*
** bOglFindGlobalLayerPaletteHWND
** 
** Find LayerPalette entry to given HWND in global linked list.
**
** return: TRUE  - entry found: *ppLayerPalette contains pointer to palette entry
**         FALSE - not found: *ppLayerPalette not valid!
** 
** FNicklisch 28.09.2000: New
*/ 
BOOL bOglFindGlobalLayerPaletteHWND(
    IN  HWND hWnd, 
    OUT NV_LAYER_PALETTE **ppLayerPalette)
{
    NV_LAYER_PALETTE *pLayerPalette = globalOpenGLData.oglLayerPaletteListHead.paletteList;

    while (pLayerPalette && pLayerPalette->windowHandle != hWnd)
    {
        pLayerPalette = pLayerPalette->next;
    }

    *ppLayerPalette = pLayerPalette;

    return (pLayerPalette != NULL);
}


//*************************************************************************
// OglSetLayerPalette
// 
// Create a display driver managed overlay palette for the given window and
// store the user palette to it. If the palette already exists, reuse it.
// Called by ICD through escape to set an overlay palette.
//*************************************************************************
BOOL OglSetLayerPalette(__GLNVpaletteData *pSourcePalette)
{
    NV_LAYER_PALETTE *pLayerPalette;
    ULONG ulIndex;

    ASSERTDD(NULL!=pSourcePalette, "pSourcePalette missing!");

    if (!bOglFindGlobalLayerPaletteHWND(pSourcePalette->windowHandle, &pLayerPalette))
    {
        // Need to create new entry
        pLayerPalette = EngAllocMem(FL_ZERO_MEMORY, sizeof(NV_LAYER_PALETTE), ALLOC_TAG);

        if (NULL != pLayerPalette)
        {
            pLayerPalette->next = globalOpenGLData.oglLayerPaletteListHead.paletteList;
            globalOpenGLData.oglLayerPaletteListHead.paletteList = pLayerPalette;
            globalOpenGLData.oglLayerPaletteClientCount++;
        }
        else
        {
            ASSERTDD(NULL!=pLayerPalette, "failed to allocate palette entry!");
            return FALSE;
        }
    }

    pLayerPalette->windowHandle  = pSourcePalette->windowHandle;
    pLayerPalette->crTransparent = pSourcePalette->crTransparent;
    for (ulIndex = 0; ulIndex < ICD_PALETTE_ENTRIES; ulIndex++)
    {
        pLayerPalette->entries[ulIndex] = pSourcePalette->entries[ulIndex];
    }

    return TRUE;
}   


//*************************************************************************
// OglGetLayerPalette
// 
// return the display driver managed overlay palette to a given window. 
// If the palette doesn't exist, create a default palette.
// Called by ICD through escape to retrieve an overlay palette.
//*************************************************************************
BOOL OglGetLayerPalette(__GLNVpaletteData *pDestPalette)
{
    NV_LAYER_PALETTE *pLayerPalette = globalOpenGLData.oglLayerPaletteListHead.paletteList;
    ULONG ulIndex;
    BOOL bRet=FALSE;

    ASSERTDD(NULL!=pDestPalette, "OglGetLayerPalette: pDestPalette missing!");

    if (!bOglFindGlobalLayerPaletteHWND(pDestPalette->windowHandle, &pLayerPalette))
    {
        // Palette data not found!
        // Initialize input data and call OglSetLayerPalette to create a new global entry.

        // set all to white aka ff
        pDestPalette->crTransparent = ICD_PALETTE_TRANSPARENT_INDEX;
        pDestPalette->entries[0]    = ICD_PALETTE_TRANSPARENT_COLOR;
        //pDestPalette->entries[pDestPalette->crTransparent] = RGB(0, 0, 0); // black
        for (ulIndex = 1; ulIndex<256; ulIndex++)
        {                     //  red   green blue
          pDestPalette->entries[ulIndex] = RGB(0xff, 0xff, 0xff);            // white
        }

        bRet = OglSetLayerPalette(pDestPalette);
    }
    else
    {
        // found existing entry, return that
        pDestPalette->windowHandle    = pLayerPalette->windowHandle;
        pDestPalette->crTransparent   = pLayerPalette->crTransparent;
        for (ulIndex = 0; ulIndex < ICD_PALETTE_ENTRIES; ulIndex++)
        {
            pDestPalette->entries[ulIndex] = pLayerPalette->entries[ulIndex];
        }
        bRet = TRUE;
    }

    ASSERTDD(bRet, "Don't assume OglGetLayerPalette to fail!");
    return bRet;
}


//*************************************************************************
// OglDestroyLayerPalette
// 
// Free the display driver managed overlay palette of the given window.
//*************************************************************************
BOOL OglDestroyLayerPalette(HWND hWnd)
{
    NV_LAYER_PALETTE *pLayerPalette = globalOpenGLData.oglLayerPaletteListHead.paletteList;

    if (bOglFindGlobalLayerPaletteHWND(hWnd, &pLayerPalette))
    {
        if (pLayerPalette == globalOpenGLData.oglLayerPaletteListHead.paletteList)
        {
            globalOpenGLData.oglLayerPaletteListHead.paletteList = pLayerPalette->next;
        }
        else
        {
            NV_LAYER_PALETTE *pPredecessor = globalOpenGLData.oglLayerPaletteListHead.paletteList;

            while (pPredecessor->next != pLayerPalette)
            {
                pPredecessor = pPredecessor->next;
            }
            ASSERTDD(NULL != pPredecessor,"OglDestroyLayerPalette: paletteList invalid !");

            pPredecessor->next = pLayerPalette->next;
        }

        EngFreeMem(pLayerPalette);

        return TRUE;
    }

    return FALSE;
}


/*
** bClearOverlayForClient
**
** Clears the delta area of clipped clientrect on overlay buffers ( newly entered areas )
** ( front for singlebuffered, front + back otherwise )
**
** Return value: FALSE: nothing done
**               TRUE:  if a clear happend
**
** MSchwarz  09/26/2000: derived from ELSA's old code
**           11/14/2000: redesigned interface: now an additional hWnd is possible for identifying client
*/
BOOL bClearOverlayForClient(PPDEV ppdev, WNDOBJ *pwo, HWND hWnd, BOOL bClearFrontBuffer, BOOL bClearBackBuffer)
{
    BOOL                     bRet               = FALSE;
    HWND                     hWndTemp           = NULL;
    NV_LAYER_PALETTE        *pLayerPalette      = NULL;
    NV_OPENGL_CLIENT_INFO   *pClientInfo        = NULL;
    RBRUSH_COLOR             rbc                = {0};    // solid colour brush

    ASSERT(NULL != pwo);
    ASSERT(NULL != ppdev);

    //
    // Whatever we do here it is only neccessary if 
    // overlays are enabled
    //
    if (ppdev->bOglOverlaySurfacesCreated)
    {
        BOOL bMore;

        if(pwo->pvConsumer)
        {
            pClientInfo = (NV_OPENGL_CLIENT_INFO*)pwo->pvConsumer;
            ASSERT(OglFindClientListFromClientInfo(ppdev, pClientInfo));
            bGetOglClientInfoHWnd( pClientInfo, &hWndTemp );
        }
        else
        {
            hWndTemp = hWnd;
        }

        if(hWndTemp)
        {
            //
            // For overlay apps take transparent color from palette 
            // for non overlay apps take default transparent color:
            //
            ULONG ulTransparentColor = ICD_PALETTE_TRANSPARENT_COLOR | 0xFF000000;

            if(bOglFindGlobalLayerPaletteHWND( hWndTemp, &pLayerPalette))
            {
                ASSERT( NULL!=pLayerPalette );
                ASSERT( pLayerPalette->crTransparent < ICD_PALETTE_ENTRIES);
                // if hWnd owns a Palette, it belongs to an overlay client.
                // get the transparent value as solid clearcolor
                ulTransparentColor = pLayerPalette->entries[pLayerPalette->crTransparent];
            }

            bRet = bClearOverlayArea(ppdev, pwo,ulTransparentColor, bClearFrontBuffer, bClearBackBuffer);
        }
    }

    return bRet;
}



/*
** bClearOverlayArea
**
** Clears the area described by a WNDOBJ in overlayfront
** and overlayback ubb-buffers with default transparent 
** color.
**
** Return value: FALSE: nothing done
**               TRUE:  if a clear happend
**
** MSchwarz  11/28/2000: new
*/
BOOL bClearOverlayArea(PPDEV ppdev, WNDOBJ *pwo, ULONG ulTransparentColor, BOOL bClearFrontBuffer, BOOL bClearBackBuffer)
{
    BOOL          bRet = FALSE;
    RBRUSH_COLOR  rbc  = {0};    // solid colour brush

    ASSERT(NULL != pwo);
    ASSERT(NULL != ppdev);

    //
    // Whatever we do here it is only neccessary if 
    // overlays are enabled
    //
    if(   (ppdev->bOglOverlaySurfacesCreated)
        &&(  (bClearFrontBuffer) 
           ||(bClearBackBuffer)
          )
      )
    {
        BOOL bMore;

        rbc.iSolidColor = ulTransparentColor;

        ppdev->pfnAcquireOglMutex(ppdev);
        ppdev->NVFreeCount = 0;
        //**********************************************************************
        // We need to make absolutely sure that the Channel switch
        // from the DMA pusher to the PIO channel has been completed
        //**********************************************************************
        ppdev->pfnWaitForChannelSwitch(ppdev);

        if(bClearBackBuffer)
        {
            // clear delta region on overlay front and back
            ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1OverlayOffset[OGL_STEREO_BUFFER_LEFT] , ppdev->singleBack1OverlayPitch[OGL_STEREO_BUFFER_LEFT] );

            WNDOBJ_cEnumStart(pwo,CT_RECTANGLES,CD_ANY,0) ;
            do 
            {//All cliprects
                CLIPENUM    ce;   // temporary buffer for clip rects

                bMore = WNDOBJ_bEnum(pwo, sizeof(ce), (ULONG *)&ce);

                if (ce.c) // can be 0
                { //Clear the Buffer

                    NV4DmaPushFillSolid( ppdev,
                                          ce.c,
                                          ce.arcl,          // List of rectangles to be filled
                                          0xF0F0,           // PATCOPY
                                          rbc,              // rbc.prb points to brush realization structure
                                          NULL);            // Pattern alignment
                }
            }
            while (bMore) ;
        }

        if(bClearFrontBuffer)
        {
            ppdev->pfnSetDestBase(ppdev, ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT] , ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT] );

            WNDOBJ_cEnumStart(pwo,CT_RECTANGLES,CD_ANY,0) ;
            do 
            {//All cliprects
                CLIPENUM    ce;   // temporary buffer for clip rects

                bMore = WNDOBJ_bEnum(pwo, sizeof(ce), (ULONG *)&ce);

                if (ce.c) // can be 0
                { //Clear the Buffer

                    NV4DmaPushFillSolid( ppdev,
                                          ce.c,
                                          ce.arcl,          // List of rectangles to be filled
                                          0xF0F0,           // PATCOPY
                                          rbc,              // rbc.prb points to brush realization structure
                                          NULL);            // Pattern alignment
                }
            }
            while (bMore) ;
        }

        // set back offset and pitch of 1st frontbuffer
        ppdev->pfnSetDestBase(ppdev, 0 , ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_LEFT] );

        ppdev->pfnReleaseOglMutex(ppdev);

        bRet = TRUE;
    }

    return bRet;
}

/*
** bCopyMainPlaneFrontToPrimaryForClient
**
** Copies the MainPlaneFront to Primary of delta area of clipped clientrect 
** on overlay buffers ( areas we leave next )
** We need this to get rid of the overlay contents in Primary before primary
** area is saved away by 2D commands
** 
** Return value: FALSE: if no OverlayClient
**               TRUE:  otherwise
**
** MSchwarz 09/27/2000: new
*/
BOOL bCopyMainPlaneFrontToPrimaryForClient(PPDEV ppdev, WNDOBJ *pwo, HWND hWnd)
{
    BOOL                     bRet               = FALSE;
    NV_LAYER_PALETTE         LayerPalette;
    NV_LAYER_PALETTE        *pLayerPalette;
    NV_OPENGL_CLIENT_INFO   *pClientInfo         = NULL;

    ASSERTDD(NULL != pwo,"");
    ASSERTDD(NULL != ppdev,"");

    pLayerPalette       = &LayerPalette;

    if( 0 != hWnd )
    {

        // if hWnd owns a Palette, it belongs to an overlay client.
        if(bOglFindGlobalLayerPaletteHWND( hWnd, &pLayerPalette) )
        {
            BOOL bMore;

            ppdev->pfnAcquireOglMutex(ppdev);
            ppdev->NVFreeCount = 0;
            //**********************************************************************
            // We need to make absolutely sure that the Channel switch
            // from the DMA pusher to the PIO channel has been completed
            //**********************************************************************
            ppdev->pfnWaitForChannelSwitch(ppdev);

            ppdev->pfnSetSourceBase(ppdev, ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT] , ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT] );
            ppdev->pfnSetDestBase(ppdev, 0 , ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_LEFT] );

            WNDOBJ_cEnumStart(pwo,CT_RECTANGLES,CD_ANY,0) ;
            do 
            {//All cliprects
                POINTL      ptl;
                CLIPENUM    ce;   // temporary buffer for clip rects

                bMore = WNDOBJ_bEnum(pwo, sizeof(ce), (ULONG *)&ce);

                ptl.x = pwo->rclClient.left;
                ptl.y = pwo->rclClient.top;

                if (ce.c) // can be 0
                { //copy mainplane front to primary

                    NV4DmaPushCopyBlt( ppdev,
                                       ce.c,
                                       ce.arcl,          // List of rectangles to be filled
                                       0xCCCC,           // SrcCopy !!
                                       &ptl,             // Src Ptl 
                                       &pwo->rclClient,   // Dst Ptl
                                       NULL);            // no BlendObj 

                }
            }
            while (bMore) ;

            ppdev->pfnReleaseOglMutex(ppdev);

            bRet = TRUE;

        }// if(bOglFindGlobalLayerPaletteHWND( pClientContextInfo->hWnd, &pLayerPalette)
        else
        {
            DISPDBG((2,"bCopyMainPlaneFrontToPrimaryForClient: Client is no OverlayClient"));
        }

    }//if( 0 != hWnd )

    return bRet;
}



BOOL bIsOverlayClient( PPDEV ppdev, NV_OPENGL_CLIENT_INFO *pClientInfo )
{
    BOOL bIsOverlayClient = FALSE;

    ASSERT(ppdev);

#if DEBUG
    if( OglFindClientListFromClientInfo(ppdev,pClientInfo) )
#else
    if(pClientInfo)
#endif //#if DEBUG
    {
        HWND hWnd;

        if( bGetOglClientInfoHWnd( pClientInfo, &hWnd ) )
        {
            if( 0 != hWnd )
            {
                NV_LAYER_PALETTE *pLayerPalette;
                // if hWnd owns a Palette, it belongs to an overlay client.
                if(bOglFindGlobalLayerPaletteHWND( hWnd, &pLayerPalette) )
                {
                    bIsOverlayClient = TRUE;
                }
            }
        }
    }

    return bIsOverlayClient; 
}


/*
** bCopyIntersectingMainPlaneFrontToPSO
**
** Copies the MainPlaneFront of any intersecting parts of any overlaywindow 
** to destination Surface
** psoDst should point to a surface where the area of a upcoming popup window
** have been saved for later restauration purposes. For Overlay windows we saved
** the Primary including overlays, but we have to extract the overlay part.
** So copy areas of Mainplanbefront over the psoDst.
** 
** Return value: FALSE: if no intersection found
**               TRUE:  if 1 or more intersections found
**
** MSchwarz 10/04/2000: new
*/
BOOL bCopyIntersectingMainPlaneFrontToPSO(PPDEV  ppdev, SURFOBJ *psoSrc, SURFOBJ *psoDst, RECTL* prclDst, POINTL* pptlSrc)
{
    BOOL                        bInterSectionFound  = FALSE;
    BOOL                        bScreenToScreenBlt  = FALSE;
    RECTL                       rclSrc;
    NV_OPENGL_CLIENT_INFO_LIST *pClientInfoList;
    NV_OPENGL_CLIENT_INFO      *pClientInfo         = NULL;

    ASSERT(ppdev);
    ASSERT(psoDst);
    ASSERT(STYPE_DEVICE != psoDst->iType);
    ASSERT(prclDst);
    ASSERT(pptlSrc);

    // calculate src rectangle
    rclSrc.left   = pptlSrc->x;
    rclSrc.right  = rclSrc.left + prclDst->right  - prclDst->left;
    rclSrc.top    = pptlSrc->y;
    rclSrc.bottom = rclSrc.top  + prclDst->bottom - prclDst->top;

    // do we do a Screen to Mem Blt or a Screen to Screen Blt ?
    if(   (psoDst->dhsurf)
        &&(DT_SCREEN == ((DSURF*)psoDst->dhsurf)->dt )
      )
    {
        bScreenToScreenBlt = TRUE;
    }

    pClientInfoList = globalOpenGLData.oglClientListHead.clientList;

    while( pClientInfoList )
    {
        pClientInfo = &pClientInfoList->clientInfo;

        if ( bIsOverlayClient(ppdev, pClientInfo) )
        {
            RECTL   rclIntersectSrc;
            RECTL   rclIntersectDst;
            RECTL  *prcl             = NULL;
            POINTL  ptlIntersectSrc;
            ULONG   cRect            = 0;
            NV_OPENGL_DRAWABLE_INFO *pClientDrawableInfo = pClientInfo->clientDrawableInfo;
            // find intersection with prclDst and copy contents of intersected mainplanefront
            // to prclDst
            if( pClientDrawableInfo->ubbWindowClipFlag )
            {
                cRect = 1;
                prcl = (RECTL*)(&pClientDrawableInfo->rect);
            }
            else
            {
                cRect = pClientDrawableInfo->numClipRects;
                prcl = pClientDrawableInfo->windowRect;
            }

            while( cRect )
            {
                if( bIntersect( &rclSrc, prcl, &rclIntersectSrc) )
                {
                    // calculate intersected pptlSrc / prclDst
                    rclIntersectDst.left   = prclDst->left + ( rclIntersectSrc.left   - pptlSrc->x );
                    rclIntersectDst.right  = prclDst->left + ( rclIntersectSrc.right  - pptlSrc->x );
                    rclIntersectDst.top    = prclDst->top  + ( rclIntersectSrc.top    - pptlSrc->y );
                    rclIntersectDst.bottom = prclDst->top  + ( rclIntersectSrc.bottom - pptlSrc->y );

                    ptlIntersectSrc.x = pptlSrc->x + ( rclIntersectDst.left - prclDst->left );
                    ptlIntersectSrc.y = pptlSrc->y + ( rclIntersectDst.top  - prclDst->top  );

                    // here we have to decide if we use a Screen to Mem or Screen to Screen Blt
                    if( bScreenToScreenBlt )
                    {
                        if( !bInterSectionFound )
                        {
                            (ppdev->pfnSetSourceBase)(ppdev,ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT],ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT]);
                            (ppdev->pfnSetDestBase)(ppdev,
                                                    (ULONG)((BYTE *)(((DSURF*)psoDst->dhsurf)->LinearPtr) - ppdev->pjScreen),
                                                    ((DSURF*)psoDst->dhsurf)->LinearStride);
                        }
                        //copy intersection with mainplanefront to prclDst;
                        NV4DmaPushCopyBlt(ppdev, 1,&rclIntersectDst, 0xCCCC,
                                          &ptlIntersectSrc, &rclIntersectDst, NULL);
                    }
                    else// Screen to Mem Blt
                    {
                        DSURF   *pdhsurfSave;
                        VOID    *LinearPtr;
                        ULONG    LinearStride;

                        // save away psoSrc->dhasurf -> linearpointer/stride , replace it with singleFrontMainOffset
                        //, call NV4ScreenToMemBlt and restore values
                        pdhsurfSave = (DSURF *)psoSrc->dhsurf;

                        LinearPtr       = pdhsurfSave->LinearPtr;
                        LinearStride    = pdhsurfSave->LinearStride;
                        pdhsurfSave->LinearPtr      = (PVOID)(ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT] + ppdev->pjScreen );
                        pdhsurfSave->LinearStride   = ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT];


                        NV4ScreenToMemBlt(  ppdev,1,&rclIntersectDst,psoSrc,psoDst,
                                            &ptlIntersectSrc,&rclIntersectDst,NULL);

                        pdhsurfSave->LinearPtr      = LinearPtr;
                        pdhsurfSave->LinearStride   = LinearStride;
                    }

                    bInterSectionFound = TRUE;
                }
                prcl++;
                cRect--;
            }
        }

        pClientInfoList = pClientInfoList->next;
    }
    return bInterSectionFound;
}
#if (NVARCH >= 0x4)
/*
** bDoMergeBlitOnIntersectingRectangle
**
** Does a Mergeblit on intersecting parts of any overlaywindow .
** This function has to be called after a saved popup-menue background
** behind an overlaywindow has benn restored with the mainplanefront
** contents => overlay has to be merged with rectangle
** 
** Return value: FALSE: if no intersection found
**               TRUE:  if 1 or more intersections found
**
** MSchwarz 10/05/2000: new
*/
BOOL bDoMergeBlitOnIntersectingRectangle(PPDEV  ppdev, RECTL* prclDst)
{
    BOOL                        bInterSectionFound  = FALSE;
    RECTL                       rclSrc;
    NV_OPENGL_CLIENT_INFO_LIST *pClientInfoList;
    NV_OPENGL_CLIENT_INFO      *pClientInfo         = NULL;

    ASSERT(ppdev);
    ASSERT(prclDst);

    pClientInfoList = globalOpenGLData.oglClientListHead.clientList;

    while( pClientInfoList )
    {
        pClientInfo = &pClientInfoList->clientInfo;

        if ( bIsOverlayClient(ppdev, pClientInfo) )
        {
            RECTL   rclIntersect;
            RECTL  *prcl             = NULL;
            ULONG   cRect            = 0;
            NV_OPENGL_DRAWABLE_INFO *pClientDrawableInfo = pClientInfo->clientDrawableInfo;
            // find intersection with prclDst and copy contents of intersected mainplanefront
            // to prclDst
            if( pClientDrawableInfo->ubbWindowClipFlag )
            {
                cRect = 1;
                prcl = (RECTL*)(&pClientDrawableInfo->rect);
            }
            else
            {
                cRect = pClientDrawableInfo->numClipRects;
                prcl = pClientDrawableInfo->windowRect;
            }

            while( cRect )
            {
                if( bIntersect( prclDst, prcl, &rclIntersect) )
                {
                    __GLNVoverlayMergeBlitInfo MergeInfo;
                    ULONG ulTemp;

                    RtlZeroMemory(&MergeInfo, sizeof(MergeInfo));


                    MergeInfo.dwAction = NV_OVERLAY_MERGE_BLIT    // do merge blit
                                       | NV_OVERLAY_RUN_IN_DD     // use display driver code
                                       | NV_OVERLAY_USE_CLIPRECT; // use user clipping given in x,y,w,h

                    // 
                    // NOTE: User cliping in MergeInfo is client relative!
                    //
                    OglTranslateCachedClipRectList(ppdev,
                                                   &rclIntersect,
                                                   1,
                                                   &rclIntersect,
                                                   &ulTemp,
                                                   (RECTL *) &(pClientDrawableInfo->rect));
                    ASSERT(1==ulTemp);

                    MergeInfo.x        = rclIntersect.left;                    
                    MergeInfo.y        = rclIntersect.top;                    
                    MergeInfo.width    = rclIntersect.right - rclIntersect.left;
                    MergeInfo.height   = rclIntersect.bottom - rclIntersect.top;

                    // Now call mergeblit disptatcher
                    // As this will add the clipping it isn't possible to
                    // directly call bOglSwapMergeBlit.
                    NV_OglOverlayMergeBlit(ppdev,
                        pClientDrawableInfo->hWnd,
                        pClientDrawableInfo->hDC,
                        &MergeInfo);

                    ASSERT(MergeInfo.retStatus==OGL_ERROR_NO_ERROR);
                    bInterSectionFound = TRUE;
                }
                prcl++;
                cRect--;
            }
        }

        pClientInfoList = pClientInfoList->next;
    }
    return bInterSectionFound;
}



//*********************************************************************
// bOglSwapMergeBlit
// 
// Main worker routine managing the overlay merge blit. 
// Depending on the mergeblit data it can do some 
// additional work to clean up overlays.
//
// 1. common setup
// 2. a. Loop over clip rects. 
//    b. If necessary clip against user rect
// For all rects do:
// 3. If needed update overlay front with overlay back
// 4. If needed update main front with main back
// 5. Is overlay update necessary?
//    a. No: Main plane to visible directly
//    b. Yes: Merge blit
//
// NOTE: The rects list (prclClip) must already be adjusted to match the 
//       offsets to the buffers.
//       If a offsetPixelsX adjustment is needed, do it outside! 
//       If a desktop clipping is neccessary, do it outside!
// 
// FNicklisch 11.10.2000: New, derived from __glNVSwapMergeBlit
//*********************************************************************
BOOL bOglSwapMergeBlit(
    PPDEV                ppdev,          // hw state to use for rendering
    __GLMergeBlitData   *pMergeBlitData) // structure with all merge blit information
{
    int             colordepth; // 16 or 32 as bpp colordepth
    unsigned int    ulRects   ; // count of clip rects
    __GLregionRect *pRects    ; // pointer to list of clip rects (read notes!)
    RECTL           rclDst    ;
    BOOL            b1=FALSE, b2=FALSE, b3=FALSE;

    ASSERT(NULL!=ppdev);
    ASSERT(NULL!=pMergeBlitData);
    ASSERT(0==pMergeBlitData->cClip || NULL!=pMergeBlitData->prclClip);

    //
    // 1. setup
    //
    ulRects            = pMergeBlitData->cClip     ;
    pRects             = pMergeBlitData->prclClip  ;
    colordepth         = pMergeBlitData->colordepth;

    ppdev->pfnWaitEngineBusy( ppdev );

    //
    // 2 a. Work done per clip rect
    //
    for (/*ulRects*/ ; ulRects > 0; ulRects--, pRects++) 
    {
        //
        // 2 b. calculate final clip rect against user clipping if necessary
        //
        if (pMergeBlitData->dwAction & NV_OVERLAY_USE_CLIPRECT)
        {
            if (!bIntersect((RECTL*)&pMergeBlitData->rclUser, (RECTL*)pRects, &rclDst))
            {
                continue;
            }
        }
        else
        {
            rclDst = *(RECTL*)pRects;
        }

        //
        // Additional pre surface updates
        //

        // 3. overlay back -> overlay front
        if (pMergeBlitData->dwAction & NV_OVERLAY_UPDATE_OVERLAY)
        {
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->OverlayBackOffset , pMergeBlitData->OverlayBackPitch);
            ppdev->pfnSetDestBase(ppdev, pMergeBlitData->OverlayFrontOffset, pMergeBlitData->OverlayFrontPitch);
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);
        }

        // 4. main back -> main front
        if (pMergeBlitData->dwAction & NV_OVERLAY_UPDATE_MAIN)
        {
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->MainBackOffset , pMergeBlitData->MainBackPitch );
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->MainFrontOffset, pMergeBlitData->MainFrontPitch);
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);
        }

        //
        // Make the surface visible to the user
        //
        if (pMergeBlitData->dwAction & NV_OVERLAY_NO_OVERLAY_PLANE)
        {
            // 5 a. This windows doesn't use the overlay plane, so there
            // is no need to do the transparent blit and use the 
            // scratch buffer.

            // main plane to scratch
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->MainFrontOffset   , pMergeBlitData->MainFrontPitch   );
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->PrimaryFrontOffset, pMergeBlitData->PrimaryFrontPitch);
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);
        }
        else if (pMergeBlitData->dwAction & NV_OVERLAY_MERGE_BLIT)
        {
            //
            // 5 b. Merge blit
            //

            // main plane to scratch
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->MainFrontOffset, pMergeBlitData->MainFrontPitch);
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->ScratchOffset  , pMergeBlitData->ScratchPitch  );
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);

            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->OverlayFrontOffset, pMergeBlitData->OverlayFrontPitch);
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->ScratchOffset     , pMergeBlitData->ScratchPitch     );

            // overlay plane to scratch onto main plane
            NV4DmaPushColorKeyBlt(ppdev, 1, &rclDst, (POINTL*)&rclDst, &rclDst, (ULONG)pMergeBlitData->colorref);

            // scratch to primary
            ppdev->pfnSetSourceBase(ppdev, pMergeBlitData->ScratchOffset     , pMergeBlitData->ScratchPitch     );
            ppdev->pfnSetDestBase(ppdev  , pMergeBlitData->PrimaryFrontOffset, pMergeBlitData->PrimaryFrontPitch);
            NV4DmaPushCopyBlt(ppdev, 1, &rclDst, 0xcccc, (POINTL*)&rclDst, &rclDst, NULL);
        }
    }

    NV4_DmaPushSend(ppdev);
    //ppdev->pfnWaitEngineBusy( ppdev );

    return TRUE;
}
#endif


//
// Next 4 functions provide a simple listfunction to store pointer
// values in, delete them, clear the entire list and check if they 
// are in the list . It is implemented as simple array with  
// MAX_POINTER_LIST_ELEMENTS ( defined in driver .h ) number of elements.
// There is no function to retrieve a pointer back from list.
//
// Implemented Functions so far: 
// -bAddPointerToList
// -bIsPointerInList
// -bRemovePointerFromList
// -bClearPointerList
// -bIsPointerListEmpty
// -ulGetNumberOfPointersInList
//

// At this time ( 10/13/2000 ) these functions are only used for overlay
// applications to detect a popup-window Primary to MEM copy to be able to
// remove and restore the overlay context to look more like a hardware
// overlay

/*
** bAddPointerToList
**
** Stores given pointer in list( implemented as
** simple array ) even if it is already inside.
**
** Return value: FALSE: if no place left for storing
**               TRUE:  if pointer was stored in list
**
** MSchwarz 10/13/2000: new
*/
BOOL bAddPointerToList( PPOINTER_LIST pList, PULONG pulPointer)
{
    BOOL  bAdded = FALSE;
    
    ASSERT(pList);
    
    if(pList->cElements < MAX_POINTER_LIST_ELEMENTS)
    {
        ASSERT(NULL==pList->apulElements[pList->cElements]);
        pList->apulElements[pList->cElements] = pulPointer;
        pList->cElements++;
        bAdded = TRUE;
        DISPDBG((20, "  AP:Pointer: 0x%x, cElements: %d",pulPointer,pList->cElements));                
    }
    return bAdded;
}

/*
** bIsPointerInList
**
** Checks if a given pointer is stored in list ( implemented as
** simple array )
**
** Return value: FALSE: if pointer not found
**               TRUE:  if pointer was found inside list
**
** MSchwarz 10/13/2000: new
*/
BOOL bIsPointerInList( PPOINTER_LIST pList, PULONG pulPointer)
{
    BOOL  bFound = FALSE;
    ULONG ul;
    
    ASSERT(pList);
    
    for(ul=0;ul<pList->cElements;ul++)
    {
        if( pulPointer == pList->apulElements[ul] )
        {
            DISPDBG((20, "  FP:Pointer: 0x%x, at Index: %d found",pulPointer,ul));                
            bFound = TRUE;
            break;
        }
    }

    return bFound;
}

/*
** bRemovePointerFromList
**
** removes a given pointer from list ( implemented as
** simple array ) and shifting empty place to end of list
**
** Return value: FALSE: if pointer not found
**               TRUE:  if pointer was removed from list
**
** MSchwarz 10/13/2000: new
*/
#pragma warning(disable: 4296)

BOOL bRemovePointerFromList( PPOINTER_LIST pList, PULONG pulPointer)
{
    BOOL  bRemoved = FALSE;
    ULONG ul;
    
    ASSERT(pList);

    for(ul=0;ul<pList->cElements;ul++)
    {
        if( pulPointer == pList->apulElements[ul] )
        {
            bRemoved = TRUE;
            // shift emtpy place to end of filled up queue
            for(;ul<pList->cElements-1;ul++)
                pList->apulElements[ul] = pList->apulElements[ul+1];
            //erase shifted element
            pList->apulElements[ul] = NULL;
            pList->cElements--;
            ASSERT(pList->cElements>=0);

            DISPDBG((20, "  RP:Pointer: 0x%x, cElements: %d",pulPointer,pList->cElements));                
        }
    }

    return bRemoved;
}

#pragma warning(default: 4296)

/*
** bClearPointerList
**
** completely clears a given list ( implemented as
** simple array )
**
** Return value: FALSE: no clear possible
**               TRUE:  list cleared
**
** MSchwarz 10/13/2000: new
*/
BOOL bClearPointerList( PPOINTER_LIST pList )
{
    BOOL  bCleared = FALSE;
    ULONG ul;
    
    ASSERT(pList);

    for(ul=0;ul<pList->cElements;ul++)
    {
        pList->apulElements[ul] = NULL;
    }
    pList->cElements = 0;
    bCleared = TRUE;

    DISPDBG((20, "  CP:Pointer: 0x%x, cElements: %d",0,pList->cElements));                

    return bCleared;
}


/*
** bIsPointerListEmpty
**
** returns if given pointerlist contains any
** element or not
**
** Return value: FALSE: no clear possible
**               TRUE:  list cleared
**
** MSchwarz 11/14/2000: new
*/
BOOL bIsPointerListEmpty( PPOINTER_LIST pList )
{
    BOOL bIstEmtpy = FALSE;
    ASSERT(pList);

    if( 0 == pList->cElements )
    {
        bIstEmtpy = TRUE;
    }

    return bIstEmtpy;
}


/*
** bRemoveFirstElementFromList
**
** removes the 1st element ( last recently used )
** from list to make space 
**
** Return value: FALSE: no element removed
**               TRUE:  1st element removed
**
** MSchwarz 11/21/2000: new
*/
BOOL bRemoveFirstElementFromList( PPOINTER_LIST pList )
{
    BOOL bElementRemoved = FALSE;
    ASSERT(pList);

    if( 0 != pList->cElements )
    {
        if( bRemovePointerFromList( pList, (ULONG*)(pList->apulElements[0]) ) )
            bElementRemoved = TRUE;
    }

    return bElementRemoved;
}


/*
** ulGetNumberOfPointersInList
**
** returns number af stored pointers in list
*/
BOOL ulGetNumberOfPointersInList( PPOINTER_LIST pList )
{
    ASSERT(pList);

    return pList->cElements;
}


//*************************************************************************
// bOglIsOverlayClient
// returns TRUE if the given clientInfo describes a client running a 
// overlay pixelformat.
//*************************************************************************
BOOL bOglIsOverlayClient(NV_OPENGL_CLIENT_INFO *pClientInfo)
{
    BOOL bIsOverlayClient;

    bIsOverlayClient =  bOglHasDrawableInfo(pClientInfo)
                    && (pClientInfo->pfd.bReserved != 0);

    return (bIsOverlayClient);
}


//*************************************************************************
// bOglGetNextOverlayClient
//
// finds next OpenGL client running on a overlay pixelformat starting with 
// next client after *ppClientInfo or at top of list if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a overlay client was found and returns a pointer to the 
// clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextOverlayClient(
    NV_OPENGL_CLIENT_INFO **ppClientInfo) // 
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextClient(&clientInfo))
    {
        if (bOglIsOverlayClient(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}


//*************************************************************************
// bOglGetNextVisibleOverlayClient
//
// finds next visible OpenGL client running on a overlay pixelformat 
// starting with next client after *ppClientInfo or at top of list 
// if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a overlay client was found and returns a pointer to the 
// clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextVisibleOverlayClient(
    NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextOverlayClient(&clientInfo))
    {
        if (bOglIsVisibleClient(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}



//*************************************************************************
// bOglIsOverlayModeEnabled
// 
// returns TRUE if driver is in overlay mode and handles overlay and main 
// plane buffers (e.g. double pumping).
//*************************************************************************
BOOL bOglIsOverlayModeEnabled(PPDEV ppdev)
{
    ASSERT(NULL != ppdev);

    return(bDoublePumped(ppdev, ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT]));
}


//*************************************************************************
// bOglOverlayModeEnable
// 
// enables overlay mode. For now this is only double pumping to the 
// overlay front main surface. 
//
// Returns TRUE if succeeded
//*************************************************************************
BOOL bOglOverlayModeEnable(PPDEV ppdev)
{
    BOOL bRet = FALSE;

    ASSERT(NULL != ppdev);

    if (   ppdev->bOglOverlaySurfacesCreated
        && ppdev->bOglOverlayDesired
        && !bOglIsOverlayModeEnabled(ppdev))
    {
        ULONG ulSurfaceOffest;

        ASSERT(ppdev->bOglSingleBackDepthCreated);
        ASSERT(bOglGetNextVisibleOverlayClient(NULL));

        ulSurfaceOffest = ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT];

        if (!bDoublePumped(ppdev, ulSurfaceOffest) )
        {
            NV_AddDoubleBufferSurface(ppdev, ulSurfaceOffest);
        }
        bRet = TRUE;
    }
    return (bRet);
}


//*************************************************************************
// bOglOverlayModeDisable
// 
// disable overlay mode. For now this is only double pumping to the 
// overlay front main surface. 
//
// Returns TRUE if succeeded
//*************************************************************************
BOOL bOglOverlayModeDisable(PPDEV ppdev)
{
    BOOL bRet = FALSE;
    if (   ppdev->bOglOverlaySurfacesCreated
        && ppdev->bOglOverlayDesired
        && bOglIsOverlayModeEnabled(ppdev))
    {
        ULONG ulSurfaceOffest;

        ASSERT(ppdev->bOglSingleBackDepthCreated);

        ulSurfaceOffest = ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT];

        if (bDoublePumped(ppdev, ulSurfaceOffest) )
        {
            NV_RemoveDoubleBufferSurface(ppdev, ulSurfaceOffest);
        }
        bRet = TRUE;
    }
    return (bRet);
}


//*************************************************************************
// bOglOverlayModeUpdate
// 
// Update overlay mode. Need to activate double pumping on visible windows.
//
// Returns TRUE if succeeded
//*************************************************************************
BOOL bOglOverlayModeUpdate(PPDEV ppdev)
{
    BOOL                   bRet = FALSE;

    ASSERT(NULL != ppdev);

    if (   ppdev->bOglOverlaySurfacesCreated
        && ppdev->bOglOverlayDesired)
    {
        ASSERT(ppdev->bOglSingleBackDepthCreated);

        // Find next visible overlay client to enable overlay mode
        if (bOglGetNextVisibleOverlayClient(NULL))
        {
            bRet = bOglOverlayModeEnable(ppdev);
        }
        else 
        {
            bRet = bOglOverlayModeDisable(ppdev);
        }
    }

    return bRet;
}


//*************************************************************************
// cOglOverlayClients
// returns the current number of clients running a stereo pixelformat
//*************************************************************************
ULONG cOglOverlayClients(PPDEV ppdev)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    ULONG                  cOverlayClients=0;

    clientInfo = NULL;
    while (bOglGetNextOverlayClient(&clientInfo))
    {
        ASSERT(ppdev->bOglOverlayDesired);
        cOverlayClients++;
    }

    return (cOverlayClients);
}


//******************************************************************************
//
//  Function:   bOglOverlaySurfacesAllowed
//
//  Checks 3 things: 1. is board workstation board 
//                   2. do we have enough framebuffer to allocate all overlay buffers
//                   3. are overlay pixelformats allowed by registry   
//
//  Return Value: TRUE:  overlay pixelformats are allowed and there are enough ressources for them
//                FALSE: overlay pixelformats are not allowed
//
//******************************************************************************
BOOL bOglOverlaySurfacesAllowed( PPDEV ppdev )
{
    ASSERT( ppdev );

    ppdev->bOglOverlayDesired = FALSE;

    if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)
    {
        OglReadRegistry(ppdev);

        // do we have enough frambuffer memory to enable overlay ?
        ASSERT(ppdev->cyScreen > 0);
        ASSERT(ppdev->cyScreen < ppdev->cyMemory);
        //     room for 7 fullscreen buffer:    front+back0+z+mainf+mainb + ovf+ovb
        if(ppdev->cyMemory >= (LONG)(ppdev->cyScreen*7) )
        {
             if (ppdev->oglRegOverlaySupport == NV_REG_OGL_OVERLAY_SUPPORT_ON)
             {
                 ppdev->bOglOverlayDesired = TRUE;
             }
        }
    }
    return (ppdev->bOglOverlayDesired);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglexpor.c ===
//******************************Module*Header*******************************
// Module Name: oglexpor.c
//
// These variables and routines are exported by the Display Driver for use
// by the OpenGL shared library.  This is only used in NV10 and higher processors
//
// Copyright (c) 1998 NVidia Corporation
//*************************************************************************

#include "precomp.h"
#include "driver.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "nvntd3d.h"
    #include "ddmini.h"
#endif


#ifndef NV3

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvReg.h"
#include "oglDD.h"
#include "pixelfmt.h"
#include "nvcom.h"       // drivers/common/inc
#include "nvtracecom.h"  // drivers/common/inc
#include "wincommon.h"   // drivers/common/inc
#include "wglcommon.h"   // drivers/common/inc
#include "Nvcm.h"        // Needed for NV_CFG_VBLANK_COUNTER,

#include "oglclip.h"

int nvControlOptions = 0;
int nvDebugOptions = 0;
int nvDebugMask = 0;
int nvDebugLevel = 0;
int nvDebugStatus = 0;
int nvTraceCountDMAWords = 0;
const int __glInKernel = TRUE;    

__GLNVdata *nvTraceLastPushBufCurrent = NULL;

// This local useful to disable assert's. Handy if assert's are keeping
// debugger control in Display driver, and all you want to do now is get
// back to client mode to terminate the application. May avoid a re-boot.
static int doBreakPoint = 1;

void __cdecl __glNVAssert(void *expString, void *filenameString, unsigned linenumber)
{
    if (doBreakPoint) {
        NV_BREAKPOINT();
    }
}

int __cdecl tprintf(const char *format, ...)
{
    va_list ap;
    
    va_start(ap, format);
    EngDebugPrint("", (char *)format, ap);
    va_end(ap);
    return 0;
}

void __cdecl nvTraceFuncEnter(int clas, nvFunRec *funRec)
{
    if ((nvDebugLevel >= 20) && (nvDebugMask & clas)) {
        tprintf("ENTER %s()\n",funRec->name);
    }
}

void __cdecl nvTraceFuncExit(int clas, nvFunRec *funRec)
{
    if ((nvDebugLevel >= 20) && (nvDebugMask & clas)) {
        tprintf("EXIT %s()\n",funRec->name);
    }
}

void __cdecl nvDebugCountDMAWords(void *cmdBufPtr)
{
}

void * __cdecl __glFlusholdNextPut(void *state)
{
    if (doBreakPoint) {
        NV_BREAKPOINT();
    }
    return NULL;
}

int __cdecl
__glFlusholdCheck2DClip(void *state)
{
    return 1;
}

void __cdecl nvComparePushBuf(void *fLastPut, void *fCurrent, void *fFifo, int fFormatted, int makeRoomWords, void *startOfFlushBlock)
{
}

#if defined(_WIN32) && !defined(_WIN64)
void __cdecl __glNVMemCopy
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount,
    DWORD dwFlags
)
{
    memcpy ((void*)dwDest,(void*)dwSrc,dwCount);
    return;
}
#endif

void __cdecl __glNVFlushInternal(__GLNVcmdInfo *cmdInfo, 
                                   unsigned char forceRealBuf)
{
    PDEV *ppdev = (PDEV *) cmdInfo->ntOther;

    if (forceRealBuf) {
        // forceRealBuf is TRUE when we are called from the lowest level
        // flush code that just wants us to write the Put.  So we just
        // call NV10_KickoffPushBuffer
        if (ppdev->oglSyncGdi) {
            OglChannelWait((PDEV *) cmdInfo->ntOther, cmdInfo->ourChannelId,
                           cmdInfo->maskOtherChannels);
        }
        __glNVKickOffPushBufferNT(cmdInfo);
    } else {
        if (cmdInfo->usingCopyBuf) {
            __glNVCopyPseudoKickoff(cmdInfo, GL_TRUE);
        }
        if (!cmdInfo->isClipped) {
            // If we are not clipped rendering then we were just called from
            // a swap routine (this may change in the future.  In that case
            // all we have to do is write Put then make some jump space just
            // like __glNV10Flush does without all the drawable validation
            // stuff since we are guaranteed to flush before we enter the
            // shared lib.
            if (ppdev->oglSyncGdi) {
                OglChannelWait((PDEV *) cmdInfo->ntOther, cmdInfo->ourChannelId,
                               cmdInfo->maskOtherChannels);
            }
            __glNVKickOffPushBufferNT(cmdInfo);
            __glNVMakeJumpSpaceInPushBuffer(cmdInfo);
        } else {
            // Otherwise, do a full clipped kickoff cuz we might have been
            // writing into the clipbuffer, SetupAndKickoff takes care of
            // this.  This can be recursively called from below SetupAndKickoff
            // or from a swap.

            // Note: Flushold my be busted here if the clipping changes.
            // We may need to revisit this and change the FALSE to a TRUE
            // so that it punts if were going to do a clip change.  The
            // other option is to move the clip test higher up.  
            //    - ibuck

            NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

            clientDrawableInfo = (NV_OPENGL_DRAWABLE_INFO *)cmdInfo->ntDrawable;

            // Test for optimized path
            if (clientDrawableInfo->ubbWindowClipFlag == (ULONG)TRUE &&
                !(clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED) &&
                cmdInfo->backBufferIsEnabled &&
                !__glNVWasFlipped(cmdInfo))
                {
                ULONG numRects;
                RECTL ubbRect;

                // 2D clip is bounds....ignore clip list in this case
                // UBB is ON, window is not occluded, window flipping is OFF, back buffered rendering only
                COPY_RECT(ubbRect, clientDrawableInfo->rect);
                OglClipRectToScreen((RECTL *)&ubbRect,
                                     clientDrawableInfo->cxScreen,
                                     clientDrawableInfo->cyScreen);
                OglTranslateCachedClipRectList(ppdev,
                                               &ubbRect, 1,
                                               &ubbRect, &numRects,
                                               (RECTL *) &(clientDrawableInfo->rect));

                __glNVSetupAndKickoff(cmdInfo,
                          numRects,  (__GLregionRect *)&ubbRect,
                          0, (__GLregionRect *)NULL,  FALSE);
            }
            else
            {
                __glNVSetupAndKickoff(cmdInfo,
                                  clientDrawableInfo->cachedNumClipRects,
                                  (__GLregionRect *)(clientDrawableInfo->cachedClipRectList),
                                  clientDrawableInfo->cachedNumExclusiveRects,
                                  (__GLregionRect *)(clientDrawableInfo->cachedExclusiveRectList),
                                  FALSE);
            }
        }
    }
}

/*
 * FUNCTION: __glNV4FlushInternal
 *
 * DESC: Wait for the DMA Channel and call the SetupAndKickoff routines to update the fifo pointers
 *       and clips.  If we are not clipped, or we have a bad rect list, then we will generate
 *       our own, based on the window position and occlusion.
 *
 * Called from __glNV4SetupSwap, nv4FlipBuffers, and NV4_OglFlushClipped.
 */
void __cdecl __glNV4FlushInternal(__GLNVcmdInfo *cmdInfo)
{
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

    PDEV *ppdev = (PDEV *) cmdInfo->ntOther;
    RECTL ubbRect;
    
    // BugFix for Indexed image blits when OGL running, for NV < NV10 (bug #20000720-213841)
    OglChannelWait((PDEV *) cmdInfo->ntOther, cmdInfo->ourChannelId,
                   cmdInfo->maskOtherChannels);

    clientDrawableInfo = (NV_OPENGL_DRAWABLE_INFO *)cmdInfo->ntDrawable;

    // Otherwise, do a full clipped kickoff cuz we might have been
    // writing into the clipbuffer, SetupAndKickoff takes care of
    // this.  This can be recursively called from below SetupAndKickoff
    // or from a swap.
    if ( (!cmdInfo->isClipped) ||
         ((clientDrawableInfo->ubbWindowClipFlag == (ULONG)TRUE) &&
          !(clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED) &&
          (cmdInfo->backBufferIsEnabled)) )
    {
        extern void CombineRectLists(RECTL *rectList1, ULONG count1, 
                                     RECTL *rectList2, ULONG count2,
                                     LONG  leftList2, LONG topList2,
                                     RECTL *resultList, ULONG *resultCount);
        ULONG numRects;
        
        // 2D clip is bounds....ignore clip list in this case
        // UBB is ON, window is not occluded, window flipping is OFF, back buffered rendering only
        COPY_RECT(ubbRect, clientDrawableInfo->rect);
        OglClipRectToScreen((RECTL *)&ubbRect,
                            clientDrawableInfo->cxScreen,
                            clientDrawableInfo->cyScreen);

        CombineRectLists((RECTL*) &(cmdInfo->coreClipRect), 1, 
                         &ubbRect, 1,
                         (LONG) (clientDrawableInfo->rect.left - ppdev->left),
                         (LONG) (clientDrawableInfo->rect.top - ppdev->top),
                         &ubbRect, &numRects);

        __glNV4SetupAndKickoff(cmdInfo, numRects, (__GLregionRect *)&ubbRect);
    }
    else /* We are clipped in one way or another. */
    {
        __glNV4SetupAndKickoff(cmdInfo, 
                               clientDrawableInfo->cachedNumClipRects,
                               (__GLregionRect *)clientDrawableInfo->cachedClipRectList);
    }
}

void __cdecl __glNV4KickOffPushBuffer(__GLNVcmdInfo *cmdInfo) 
{
    // Call back into the shared lib to do the kickoff since only the
    // shared lib has access to state, nv4state, etc...
    __glNV4KickOffPushBufferNT(cmdInfo);
}


unsigned int __cdecl __glNVGetCurrentScanLine(__GLNVcmdInfo *cmdInfo, int *iCurScanLine) {
    PDEV  *ppdev = (PDEV *) cmdInfo->ntOther;

    *iCurScanLine = ppdev->pfnGetScanline(ppdev);
    return TRUE;
}

unsigned int __cdecl __glNVGetVBlankCounter(__GLNVcmdInfo *cmdInfo, int head, int *iCurSwap) {
    PDEV  *ppdev = (PDEV *) cmdInfo->ntOther;
    NV_CFGEX_VBLANK_COUNTER_MULTI_PARAMS param;
    unsigned int ret;

    param.Head = head;
    param.VBlankCounter = 0;

    ret = (unsigned int) NvConfigGetEx (ppdev->hDriver,
                                        ppdev->hClient,
                                        ppdev->hDevice,
                                        NV_CFGEX_VBLANK_COUNTER_MULTI,
                                        &param,
                                        sizeof(param));
    *iCurSwap = param.VBlankCounter;
    return ret;
}

unsigned int __cdecl __glNVGetVBlankEnabled(__GLNVcmdInfo *cmdInfo, int head, int *enabled) {
    PDEV  *ppdev = (PDEV *) cmdInfo->ntOther;
    NV_CFGEX_VBLANK_ENABLED_PARAMS param;
    unsigned int ret;

    param.Head = head;
    param.Enabled = *enabled;

    ret = (unsigned int) NvConfigGetEx (ppdev->hDriver,
                                        ppdev->hClient,
                                        ppdev->hDevice,
                                        NV_CFGEX_VBLANK_ENABLED,
                                        &param,
                                        sizeof(param));
    *enabled = (int) param.Enabled;
    return ret;
}

//******************************************************************************
// avoid unresolved globals from shared library.
// only needed in ICD.
//******************************************************************************

int __cdecl __glwqExportThreadIndex()
{
    NV_BREAKPOINT();    // should not be called in kernel
    return 0;
}

/*****************************************************************************/
void __cdecl
__glmt0NVWaitForFreeSpace(void *state, int space)
// should only be called from thread 0 (i.e. the master thread)
{
}

//********************************************************************
// This is called by OpenGL when it is going to do a flip.  This sets
// the flipbase to the base address of the buffer we are going to flip
// to.  In addition it also grabs the panning offset that the display
// driver is currently at if we happen to be doing a pan'n'scan type
// of virtual desktop.  This routine returns TRUE if OpenGL should 
// stop flipping due to another OpenGL surface active or if a ddraw
// video surface is also active since this would cause problems with
// window flipping.
//********************************************************************

int __cdecl __glNVDoDACParams(__GLNVcmdInfo *cmdInfo, NvU32 newDACOffset, NvU32 *panningOffset)
{
    int i;
    int stopFlip;
    PDEV *ppdev = (PDEV *) cmdInfo->ntOther;

    for (i = 0; i < NV_NO_DACS; i++) 
        {
        panningOffset[i] = (NvU32)ppdev->ulHeadDisplayOffset[i];
        }

    stopFlip =  !((NV_OPENGL_CLIENT_INFO *)cmdInfo->ntClientInfo)->bFlipping;        
                //((globalOpenGLData.oglDrawableClientCount > 1) ||
                //(ppdev->oglDDrawSurfaceCount > OGL_MAX_DDRAW_SURFACES_FOR_FLIPPING));

    if (!stopFlip)
    {
        NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo;

        // flipping possible, remember new offset
        ppdev->ulFlipBase = (ULONG)newDACOffset;

        // this client is flippping now
        clientDrawableInfo = (NV_OPENGL_DRAWABLE_INFO *)cmdInfo->ntDrawable;
        clientDrawableInfo->bFlipping = TRUE;
    }
    /*
    else if (OGL_FLIPPED()) 
    {
        // flipping and we're on the wrong page 
        // and we need to flip back to primary
        vFlipToPrimary(ppdev);
    }
    */

    return stopFlip;  
}

//********************************************************************
// If video is active, then posting a stall method to the hardware may
// cause the hardware to hang since the resman may not able to service
// the stall method due to interrupts caused by the video driver
//********************************************************************

int __cdecl __glNVDisableStall(__GLNVcmdInfo *cmdInfo)
{
    PDEV *ppdev = (PDEV *) cmdInfo->ntOther;

#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
    if (ppdev->pDriverData->vpp.dwOverlaySurfaces) {
        return TRUE;
    }
#endif          
    return FALSE;

}

int __cdecl __wglNVGetPfdFlags(void *osother, __WINNVpixelFormatFlags *winPFFlags)
{
    PDEV *ppdev = (PDEV *) osother;
    int flags = 0;

    bOglPfdCheckFlags(ppdev, (ULONG *) &flags);
//    flags |= __winNVProcessWinFlags(winPFFlags);
    return flags;
}
int __cdecl __wglGDIDescribePixelFormat(int iPixelFormat,
                                        unsigned int uBytes,
                                        PIXELFORMATDESCRIPTOR *ppfd,
                                        void *osother)
{
    ASSERTDD(0,"__wglGDIDescribePixelFormat should not be called in the server");
    return FALSE;
}
#endif // NV3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglflip.h ===
#ifndef _OGLFLIP_H
#define _OGLFLIP_H
//******************************Module*Header***********************************
// Module Name: oglflip.h
//
// Export file for maintenance code for OpenGL flipping.
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

BOOL bOglPageFlipModeUpdate(PPDEV ppdev);
BOOL bOglPageFlipModeEnable(PPDEV ppdev, struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL bOglPageFlipModeDisable(PPDEV ppdev, struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL bOglPageFlipModeDisableAll(PPDEV ppdev);
BOOL bOglPageFlipModeRetryEnable(PPDEV ppdev);
ULONG cOglFlippingClients(PPDEV ppdev);

#endif // _OGLFLIP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\OglOverlay.h ===
#ifndef __OGLOVERLAY_H
#define __OGLOVERLAY_H
//
// MSchwarzer 09/28/2000: new
//
void OglInitLayerPalette(void);

BOOL bOglFindGlobalLayerPaletteHWND(
    IN  HWND hWnd, 
    OUT NV_LAYER_PALETTE **ppLayerPalette);

BOOL OglSetLayerPalette(__GLNVpaletteData *pSourcePalette);
BOOL OglGetLayerPalette(__GLNVpaletteData *pDestPalette);
BOOL OglDestroyLayerPalette(HWND hWnd);

BOOL bClearOverlayForClient(PPDEV ppdev, WNDOBJ *pwo, HWND hWnd, BOOL bClearFrontBuffer, BOOL bClearBackBuffer);
BOOL bClearOverlayArea(PPDEV ppdev, WNDOBJ *pwo, ULONG ulTransparentColor, BOOL bClearFrontBuffer, BOOL bClearBackBuffer);
BOOL bCopyMainPlaneFrontToPrimaryForClient(PPDEV ppdev, WNDOBJ *pwo, HWND hWnd);
BOOL bCopyIntersectingMainPlaneFrontToPSO(PPDEV  ppdev, SURFOBJ *psoSrc, SURFOBJ *psoDst, RECTL* prclDst, POINTL* pptlSrc);
BOOL bDoMergeBlitOnIntersectingRectangle(PPDEV  ppdev, RECTL* prclDst);
BOOL bOglSwapMergeBlit(PPDEV ppdev, struct __GLMergeBlitDataRec   *pMergeBlitData);

BOOL bAddPointerToList( PPOINTER_LIST, PVOID);
BOOL bIsPointerInList( PPOINTER_LIST, PVOID);
BOOL bRemovePointerFromList( PPOINTER_LIST, PVOID);
BOOL bClearPointerList( PPOINTER_LIST);
BOOL bIsPointerListEmpty( PPOINTER_LIST pList );
BOOL bRemoveFirstElementFromList( PPOINTER_LIST pList );
BOOL ulGetNumberOfPointersInList( PPOINTER_LIST pList );

BOOL bOglGetNextOverlayClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
BOOL bOglGetNextVisibleOverlayClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
BOOL bOglIsOverlayClient(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL bOglIsOverlayModeEnabled(PPDEV ppdev);
BOOL bOglOverlayModeUpdate(PPDEV ppdev);
BOOL bOglOverlayModeEnable(PPDEV ppdev);
BOOL bOglOverlayModeDisable(PPDEV ppdev);

ULONG cOglOverlayClients(PPDEV ppdev);
BOOL  bOglOverlaySurfacesAllowed(PPDEV ppdev);
#endif // __OGLOVERLAY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglflip.c ===
//******************************Module*Header***********************************
// Module Name: oglflip.c
//
// Maintenance code for OpenGL flipping.
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

// import
#include "precomp.h"
#include "driver.h"
#include "nvdoublebuf.h"
#include "oglDD.h"
#include "oglutils.h"
#include "oglclip.h"
#include "Nvcm.h"

// export
#include "oglflip.h"

//*************************************************************************
// bOglClientIsFlipCandidate
// 
// returns TRUE if clientInfo belongs to a client that is allowed to 
// do pageflipping now. A flip candidate must have a exchange pixelformat
// or run in fullscreen and must be visible 
//*************************************************************************
BOOL bOglClientIsFlipCandidate(
    IN PPDEV                          ppdev,
    IN struct _NV_OPENGL_CLIENT_INFO *clientInfo)
{
    BOOL bRet = FALSE;

    ASSERT(NULL!=ppdev);
    ASSERT(NULL!=clientInfo);

    // *****
    // *KEY* Here we decide if a client can flip or not!
    // *****
    if (   (clientInfo->pfd.dwFlags & PFD_SWAP_EXCHANGE)                // must have the exchange (flip) pixelformat
        && (   bOglIsUnclippedClient(clientInfo)                        // unclipped (easy decision)
            || (   !bOglClientIntersectingWithOtherClients(clientInfo)  // or not clipped against other ogl
                && !bOglIsComplexClippedClient(ppdev, clientInfo) )     // and not complex clipped (complex clipping is slower than blitting)
           )
        && (   bOglIsFullscreenClient(clientInfo)                       // either be a quake fullscreen client
            || (   ppdev->bOglSingleBackDepthSupported                  // or needs GDI double pumping
                && ppdev->bOglSingleBackDepthCreated)
           )
       )
    {
        // these assertions catch internal errors, where we export wrong pixelformats
        ASSERT(0 != (clientInfo->pfd.dwFlags & PFD_DOUBLEBUFFER));  // not allowed on single buffered client
        ASSERT(0 == clientInfo->pfd.bReserved);                     // not allowed on overlay client
        ASSERT(0 == (clientInfo->pfd.dwFlags & PFD_STEREO));        // not allowed on stereo client

        bRet = TRUE;
    }

    DISPDBG((3, "bOglClientIsFlipCandidate - 0x%08p %s", clientInfo, bRet ? "is a flip candidate" : "must blit"));

    return (bRet);
}


//*************************************************************************
// bOglGetNextFlipCandidate
// 
// returns next flip candidate starting with given client.
//*************************************************************************
BOOL bOglGetNextFlipCandidate(
    IN     PPDEV                   ppdev, 
    IN OUT NV_OPENGL_CLIENT_INFO **ppClientInfo) 
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    ASSERT(NULL!=ppdev);

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextVisibleClient(&clientInfo))
    {
        // found visible client, but is it a flip candiate, too?
        if (bOglClientIsFlipCandidate(ppdev, clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}


//*************************************************************************
// bOglIsClientFlipping
// 
// returns TRUE if given client is set to flip mode (this doesn't mean it 
// really is flipping if itself doesn't want!)
//*************************************************************************
BOOL bOglIsClientFlipping(
    IN struct _NV_OPENGL_CLIENT_INFO *clientInfo)
{
    return (   bOglHasDrawableInfo(clientInfo)
            && clientInfo->bFlipping);
}


//*************************************************************************
// bOglGetNextFlippingClient                                                 
//                                                                    
// Start with clientInfoStart (not included to search) and find       
// next flipping OpenGL client and return the result to *ppClientInfo.
// If clientInfoStart==START_SEARCH_AT_BEGIN start with first client. 
//                                                                    
// NOTE: There only should be one flipping client at all!             
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a flip client was found and returns a pointer to the 
//              clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextFlippingClient(
    IN OUT NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextClient(&clientInfo))
    {
        // found visible client, but is it a flip candiate, too?
        if (bOglIsClientFlipping(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}


//*************************************************************************
// bOglPageFlipModeUpdate
// 
// Checks the pageflip status of all open OpenGL apps against system 
// conditions and updates status if neccessary. It will disable 
// pageflipping cleaning up the buffers, flipping back to primary, 
// notifiying affected clients. It will enable pageflipping if one single
// client is visible and it is a FlipCandidate. On Quadro it will manage
// double pumping for window flipping.
//
// Pageflip enable will only be done if PAGEFLIP_IMMEDIATE_UPDATE is set!
// Pageflip enable should not be called from within DrvClipChanged!
// 
// return: TRUE  - succeeded        
//         FALSE - failed, any error
//*************************************************************************
BOOL bOglPageFlipModeUpdate(PPDEV ppdev)
{
    BOOL                   bFlipCandidateFound  = FALSE;
    NV_OPENGL_CLIENT_INFO *clientInfoFlipOld    = NULL;
    NV_OPENGL_CLIENT_INFO *clientInfo           = NULL;
    BOOL                   bRet                 = FALSE;
    ULONG                  cVisibleClients;

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);
    ASSERT(ppdev->pOglServer->ulPageFlipRetryCounter <= PAGEFLIP_RETRY_COUNTER_START);

    cVisibleClients = cOglVisibleClients(ppdev);

    if (   bOglDirectDrawAppRunning(ppdev) // direct draw has direct access to primary
        || bOglPOWERlibAppRunning(ppdev)   // POWERlib has direct access to primary
        || !OglIsEnabled(ppdev)            // OpenGL now disabled
       )
    {
        // apps using linear addressing to the FB running
        bRet = bOglPageFlipModeDisableAll(ppdev);
    }
    else if (   (0 == cOglWindows(ppdev)) // all ogls closed
             || (cVisibleClients  > 1)    // multiple visible clients
             || (cVisibleClients == 0)    // all clients invisible
            )
    {
        // conditions for flipping not met        
        bRet = bOglPageFlipModeDisableAll(ppdev);
    }
    else
    {
        // only one ogl visible
        ASSERT(1==cVisibleClients);

        clientInfo          = NULL;
        bFlipCandidateFound = bOglGetNextFlipCandidate(ppdev, &clientInfo);

        clientInfoFlipOld = NULL;
        if ( bOglGetNextFlippingClient(&clientInfoFlipOld) )
        {
            if (clientInfo != clientInfoFlipOld)
            {
                bOglPageFlipModeDisable(ppdev, clientInfoFlipOld);

                ASSERT(!bOglGetNextFlippingClient(NULL));
            }
        }

        if ( bFlipCandidateFound )
        {
            // only enable pageflipping now, if enable isn't deferred to the retry!
            if (PAGEFLIP_IMMEDIATE_UPDATE == ppdev->pOglServer->ulPageFlipRetryCounter)
            {
                //
                // KEY: Enable pageflipping for this client.
                //

                bRet = bOglPageFlipModeEnable(ppdev, clientInfo);
            }
            else
            {
                // leave it as it is!
            }
        }
        else
        {
            bRet = bOglPageFlipModeDisableAll(ppdev);
        }
    }

    return (bRet);
}


//*************************************************************************
// bOglPageFlipModeEnable
// 
// enables pageflipping for the given OpenGL client.
// The client has to be a FlipCandidate. If it isn't already flipping, 
// flipping will be allowed for that client and double pumping is enabled
// on Quadro boards.
// Pageflip enable should not be called from within DrvClipChanged!
// 
// return: TRUE  - succeeded
//         FALSE - failed, any error
//*************************************************************************
BOOL bOglPageFlipModeEnable(
    IN PPDEV                  ppdev, 
    IN NV_OPENGL_CLIENT_INFO *clientInfo)
{
    BOOL bRet=FALSE;

    ASSERT(NULL!=ppdev);
    ASSERT(bOglHasDrawableInfo(clientInfo));
    ASSERT(bOglClientIsFlipCandidate(ppdev, clientInfo));

    if ( !bOglIsClientFlipping(clientInfo) )
    {
        if (bOglIsFullscreenClient(clientInfo))
        {
            // all fullscreen flip candidates may flip!
        }
        else if (HWGFXCAPS_QUADRO_GENERIC(ppdev))
        {
            // Only workstation parts my flip if not fullscreen, but they need ubb buffers
            if (   !ppdev->bOglSingleBackDepthCreated                                                          // need UBB surface                 
                || (   !bDoublePumped(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT])                 // need double pumping              
                    && !NV_AddDoubleBufferSurface(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]) ) ) //   failed to enable double pumping
            {
                // failed to enable double pumping code!
                goto Exit;
            }
        }

        // *****
        // *KEY* here we enable a client to flip.
        // *****
        clientInfo->bFlipping = TRUE;
        clientInfo->clientDrawableInfo->ubbWindowClipFlag = FALSE; // need to disable ubb clip optimization
        ppdev->pOglServer->ulPageFlipRetryCounter         = PAGEFLIP_IMMEDIATE_UPDATE; // no need to retry anymore
        DISPDBG((3, "bOglPageFlipModeEnable: 0x%08p is flip enabled", clientInfo));
    }
    else 
    {
        // already initialized
    }


    bRet = TRUE;

Exit:
    return (bRet);
}


//******************************************************************************
// bOglPageFlipModeDisable
// 
// disables pageflipping for the given OpenGL client.
// This includes flipping back to primary, exchanging front and back if flipped
// and disabling double pumping.
// 
// return: TRUE  - succeeded
//         FALSE - failed, any error
//******************************************************************************
BOOL bOglPageFlipModeDisable(
    IN PPDEV                  ppdev, 
    IN NV_OPENGL_CLIENT_INFO *clientInfo)
{
    BOOL bRet=FALSE;

    ASSERT(NULL!=ppdev);
    ASSERT(bOglHasDrawableInfo(clientInfo));
    ASSERT(bOglIsClientFlipping(clientInfo));

    DISPDBG((3, "bOglPageFlipModeDisable: 0x%08p must blit again", clientInfo));
    //
    // disable double pumping, fix buffer offsets...

    if (OGL_FLIPPED()) 
    {
        vFlipToPrimary(ppdev);
    }

    // Potentially client needs to fix his surface offsets
    clientInfo->clientDrawableInfo->clipChangedCount++;
    clientInfo->bFlipping = FALSE;

    // NOTE: This is an assumption that we only double pump on this buffer for page flipping
    if ( bDoublePumped(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]) )
    {
        NV_RemoveDoubleBufferSurface(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]);
    }

    bRet = TRUE;
        
    return (bRet);
}


//******************************************************************************
// bOglPageFlipModeDisableAll
// 
// disables pageflipping for all OpenGL clients running.
// This includes flipping back to primary, exchanging front and back if flipped
// and disabling double pumping.
// 
// return: TRUE  - succeeded
//         FALSE - failed, any error
//******************************************************************************
BOOL bOglPageFlipModeDisableAll(PPDEV ppdev)
{
    BOOL                   bRet       = FALSE;
    NV_OPENGL_CLIENT_INFO *clientInfo = NULL;

    ASSERT(NULL!=ppdev);

    //
    // This is only done in the case a flipping client wasn't found!
    //

    if (OGL_FLIPPED()) 
    {
        vFlipToPrimary(ppdev);
    }

    clientInfo = NULL;
    while (bOglGetNextFlippingClient(&clientInfo))
    {
        ASSERT(bOglIsClientFlipping(clientInfo));

        bOglPageFlipModeDisable(ppdev, clientInfo);
        
        // I don't think I want to have two simultaneous flipping clients!
        ASSERT(!bOglGetNextFlippingClient(NULL));
    }

    // NOTE: This is an assumption that we only double pump on this buffer for page flipping
    if ( bDoublePumped(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]) )
    {
        NV_RemoveDoubleBufferSurface(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT]);
    }
        
    bRet = TRUE;
        
    return (bRet);
}


//*************************************************************************
// bOglPageFlipModeRetryEnable
// 
// Tries to enalbe pageflipping again depending on retry counter.
// If pageflipping was disabled due to collision with GDI we initialize a
// counter to try again after several swapbuffer calls. 
// If the counter is down to PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP it will 
// try an immediate update of pageflipping.
// DrvClipChanged will set the counter to PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP 
// to invoke a pageflip enable at the next SwapBuffers.
//
// This function must either be called in the context of SwapBuffers or
// in the __glNVDoDACParams (for now it is called in SwapBuffers).
// At lease it MUST be called somewhere!
//*************************************************************************
BOOL bOglPageFlipModeRetryEnable(PPDEV ppdev)
{
    BOOL bRet = FALSE;

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);
    // As it is unsigned this test includes PAGEFLIP_IMMEDIATE_UPDATE
    ASSERT(ppdev->pOglServer->ulPageFlipRetryCounter <= PAGEFLIP_RETRY_COUNTER_START);

    if (PAGEFLIP_DEFER_UPDATE_TO_NEXT_SWAP == ppdev->pOglServer->ulPageFlipRetryCounter)
    {
        DISPDBG((3, "bOglPageFlipModeRetryEnable: retry enable pageflipping"));

        //
        // Key: try again to enable pageflipping
        //
        ppdev->pOglServer->ulPageFlipRetryCounter = PAGEFLIP_IMMEDIATE_UPDATE;
        bRet = bOglPageFlipModeUpdate(ppdev);
    }
    else if (PAGEFLIP_IMMEDIATE_UPDATE != ppdev->pOglServer->ulPageFlipRetryCounter)
    {
        // wait some more time to enable pageflipping
        ppdev->pOglServer->ulPageFlipRetryCounter--;
    }
    else // ppdev->pOglServer->ulPageFlipRetryCounter == PAGEFLIP_IMMEDIATE_UPDATE
    {
        // default, nothing to do!
    }

    ASSERT(ppdev->pOglServer->ulPageFlipRetryCounter <= PAGEFLIP_RETRY_COUNTER_START);

    return bRet;
}


//*************************************************************************
// cOglFlippingClients
// returns the current number of clients in pageflip mode
//*************************************************************************
ULONG cOglFlippingClients(PPDEV ppdev)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    ULONG                  cFlipClients=0;

    clientInfo = NULL;
    while (bOglGetNextFlippingClient(&clientInfo))
    {
        cFlipClients++;
    }

    // current hard- and sw only supports one flip client!
    ASSERT(cFlipClients <= 1);
    return (cFlipClients);
}
// End of oglflip.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglkick.c ===
/******************************Module*Header*******************************\
* Module Name: oglkick.c
*
* This module contains the functions to support the OpenGL kick off.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"

#define NV_JUMP(addr)  (0x20000000 | (addr))

#define DBG_KICKOFF_MESSAGES 1
#undef DBG_KICKOFF_MESSAGES

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

// ripped off from nv4ddrw.c
#define OFFSET_NV_PFIFO_BASE            (0x2000)
#define OFFSET_NV_PFIFO_DMA_REG         (0x2508-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_PUSH1    (0x3204-OFFSET_NV_PFIFO_BASE)
#define OFFSET_NV_PFIFO_CACHE1_DMA_PUSH (0x3220-OFFSET_NV_PFIFO_BASE)
#define CACHE1_PUSH1_MODE_DMA           0x100
#define CACHE1_DMA_PUSH_BUFFER_EMPTY    0x100

extern VOID MagicDelay(void);

//******************************************************************************
//
//  Function: OglChannelWait
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************
void OglChannelWait(
    PDEV  *ppdev,
    ULONG ourChannelId,
    ULONG maskOtherChannels
    )
{
    /*
    volatile ULONG  *pfifoDmaReg;
    volatile ULONG  *pfifoCache1Push1;
    volatile ULONG  *pfifoCache1DmaPush;
    volatile ULONG  regValue;

    pfifoDmaReg        = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_DMA_REG);
    pfifoCache1Push1   = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_PUSH1);
    pfifoCache1DmaPush = (ULONG *)((BYTE *)ppdev->PFIFORegs + OFFSET_NV_PFIFO_CACHE1_DMA_PUSH);

    if (ppdev->oglLastChannel != ourChannelId)
        {
        regValue = READ_REGISTER_ULONG(pfifoDmaReg);
        // wait for all other channels to go to 0 (not active)
        while ((regValue & maskOtherChannels) != 0) 
            {
            (VOID)MagicDelay();
            regValue = READ_REGISTER_ULONG(pfifoDmaReg);
            }

        regValue = READ_REGISTER_ULONG(pfifoCache1Push1);
        if (((regValue & CACHE1_PUSH1_MODE_DMA) != 0) &&
            ((regValue & (0x1F)) != ourChannelId)) 
            {
            regValue = READ_REGISTER_ULONG(pfifoCache1DmaPush);
            while ((regValue & CACHE1_DMA_PUSH_BUFFER_EMPTY) == 0) 
                {
                (VOID)MagicDelay();
                regValue = READ_REGISTER_ULONG(pfifoCache1DmaPush);
                }
            }
        }
    */
    

    if (ppdev->oglLastChannel != ourChannelId)
    {
        ppdev->oglLastChannel = -1;             // FORCE IT TO SYNC...
        ppdev->pfnWaitForChannelSwitch(ppdev);
        ppdev->oglLastChannel = ourChannelId;
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglstereo.h ===
#ifndef __OGLSTEREO_H
#define __OGLSTEREO_H

/*
**
** MODULE: oglstereo.h
**
** OS dependent functions releated to oglstereo reside here
**
** Copyright (C) 2000 NVidia Corporation. All Rights Reserved.
**
*/

BOOL  bOglStereoGlassesSwitchOff(PDEV* ppdev);
BOOL  bOglStereoGlassesSwitchOn(PDEV* ppdev);
BOOL  bOglIsStereoClient(struct _NV_OPENGL_CLIENT_INFO *pClientInfo);
ULONG cOglStereoClients(PPDEV ppdev);
BOOL  bOglIsStereoModeEnabled(PPDEV ppdev);
BOOL  bOglStereoModeUpdate(PPDEV ppdev);
BOOL  bOglStereoModeEnable(PPDEV ppdev);
BOOL  bOglStereoModeDisable(PPDEV ppdev);
BOOL  bOglGetNextActiveStereoClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
BOOL  bOglGetNextStereoClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);


#endif //#ifndef __OGLSTEREO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglstereo.c ===
//******************************Module*Header***********************************
// Module Name: oglstereo.c
//
// OS dependent functions releated to oglstereo reside here
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

// import
#include "precomp.h"
#include "driver.h"
#ifdef NVD3D
    #include "dx95type.h"
    #include "ddmini.h"
#endif  
#include "nvRmStereo.h"
#include "nvdoublebuf.h"
#include "nvReg.h"
#include "oglutils.h"

// export
#include "oglstereo.h"


// Documentation of the stereo implementation
//
// The OpenGL stereo implementation uses the OpenGL API on a window with 
// pixelformat that has PFD_STEREO selected. In stereo mode we run in a
// quad buffered environment. The color buffers are GL_FRONT_LEFT, GL_FRONT_RIGHT, 
// GL_BACK_LEFT and GL_BACK_RIGHT. Also depth and stencil buffers are duplicated
// for the right eye. pic 1.
// Monoscopic apps will default to the left buffers and the broadcast to the
// right buffers has to be handled. We allow a mix of monoscopic and stereo 
// apps in a windowed environment.
//
// If the system in in stereo mode (OGL_EnableStereoSupport) all ICDs, even
// monoscopic ICDs will cause the display driver to allocate and reserve 
// all stereo buffers to guarantee that later stereo apps will succeed to run
// in hardware.
//
// If a stereo ICD is enabled the display driver will enable the shutter glasses
// and double pump GDI to the right front buffer.
//
// If all stereo windows are occluded or disabled through an escape/OGL extension
// we disable the shutter glasses and double pumping. This speeds up the system.
//
// Notes/Limitations:
//
// * We don't want to flip in stereo mode, because we would need to wait 
//   on the vblank. Toggle between hsync and vsync flips causes the screen 
//   to flicker.
// * Monoscopic double buffered will run as in non stereo environment but
//   the ICDs need to allocate and initialize at least the stereo buffers 
//   in the drawable private to allow the swap to be broadcasted. The 
//   broadcast is completely solved in the shared library through the
//   dp->stereoEyeLoop used by the stereo swap, too. It uses different 
//   initialized buffers. pic 4.
// * Monoscopic single buffered ICDs are internally set to stereo.
//   This will cause GL_FRONT to render to both frontbuffers.
//   No need to broadcast outside, but we run through differnt pathes
//   than in a non stereo environment! 
// 
// 
// pic 1) Default mode stereo apps
// 
//  LEFT eye               RIGHT eye
//
// +---------+            +---------+                            
// |  Front  |<- toggle ->|  Front  |                            
// |  left   |    DAC     |  right  |                  
// |         |<-+         |         |<-+                      
// +---------+  |         +---------+  |                      
//              |                      |    
//          swap-left              swap-right
//              |                      |     
// +---------+  |         +---------+  |                      
// |  Back   | -+         |  Back   | -+                      
// |  left   |            |  right  |                  
// |         |            |         |                  
// +---------+            +---------+                            
//                                            
// +---------+            +---------+                             
// |    Z    |            |    Z    |                             
// |  left   |            |  right  |                             
// |         |            |         |                             
// +---------+            +---------+         
//                                           
// A swap buffers needs to swap both back buffers to both front buffers.
// This is done by a loop in the swap blit itself.
//
//
// pic 2) Stereo apps, stereo disabled through extension
// 
//  LEFT eye               RIGHT eye
//
// +---------+            +---------+                            
// |  Front  |            |  Front  |                            
// |  left   |            |  right  |                  
// |         |<-+         |         |                 
// +---------+  |         +---------+                 
//              |          ^         
//          swap-left swap-right (duplicate)
//              |       /              
// +---------+  |     /   +---------+                 
// |  Back   | -+----     |  Back   |                 
// |  left   |            |  right  |          
// |         |            |         |                  
// +---------+            +---------+                            
//                                            
// +---------+            +---------+                             
// |    Z    |            |    Z    |                             
// |  left   |            |  right  |                             
// |         |            |         |                             
// +---------+            +---------+         
//
//
// pic 3) Default mode monoscopic double buffered apps
// 
//  LEFT eye         
//
// +---------+       
// |  Front  |       
// |  left   |       
// |         |<-+    
// +---------+  |    
//              |    
//          swap-left
//              |    
// +---------+  |    
// |  Back   | -+       
// |  left   |         
// |         |         
// +---------+                   
//                
// +---------+                    
// |    Z    |                    
// |  left   |                    
// |         |                    
// +---------+    
//
// doesn't need to take care about right buffers
// 
//
// pic 4) Monoscopic double buffered apps running in 
//        stereo environment
// 
//  LEFT eye               RIGHT eye         
//                                           
//   ICD to 
//  LEFT only
//      V
// +---------+            +---------+        
// |  Front  |            |  Front  |        
// |  left   |            |  right  |        
// |         |<-+         |         |<-+     
// +---------+  |         +---------+  |     
//              |                      |     
//          swap-left              swap-right(duplicate)
//              |                      |     
// +---------+  |                     / 
// |  Back   | -+                   /     
// | left +  |                    /      
// | right   | ---------------- /        
// +---------+                 
//                                           
// +---------+     
// |    Z    |     
// |  left   |     
// |         |     
// +---------+
//
// App renders as before, but swap buffers copies back left
// to front left and to front back.
// ICD needs to allocate and associate right buffers. The 
// back right is maped to back left.
//
//
// pic 5) Monoscopic single buffered apps running in 
//        stereo environment
// 
//  LEFT eye               RIGHT eye
//
//          ICD to GL_FRONT
//           /            \
//         /                \
//        V                  V
// +---------+            +---------+
// |  Front  |<- toggle ->|  Front  |
// |  left   |    DAC     |  right  |
// |         |            |         |
// +---------+            +---------+
//
// More information:
// .\drivers\OpenGL\include\GL\glcore.h
// .\drivers\display\winnt4\displays\nv_disp\oglstereo.c


//
// bOglStereoGlassesSwitchOn
//
// calls the miniport to switch on stereo
// glasses toggling
//
// Return value: FALSE: did not switch glasses toggling on
//               TRUE:  switched on  glasses toggling
//
// MSchwarz 11/16/2000: new
//
BOOL bOglStereoGlassesSwitchOn(PDEV* ppdev)
{
    ULONG                 ul;
    NV_CFG_STEREO_PARAMS  StereoParams;
    ULONG                 ulReturnedDataLength;
    BOOL                  bGlassesSwitchOn = FALSE;

    ASSERT(ppdev);

    if (!ppdev->bOglStereoActive)
    {
        RtlFillMemory(&StereoParams,sizeof(StereoParams),0xFF);

        StereoParams.Flags               =   STEREOCFG_WS_OGL_API_STEREO   // mark structure as used by ogl api stereo
                                           | STEREOCFG_STEREO_INITIALIZE   // switch glasses on
                                           | STEREOCFG_ELSADDC;            // use ELSA DDC switching method
        StereoParams.EyeDisplayed        = 0;
        StereoParams.FlipOffsets[1][0]   = ppdev->singleFrontOffset[OGL_STEREO_BUFFER_LEFT];
        StereoParams.FlipOffsets[1][1]   = ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT];
        // for flipping purposes:
        StereoParams.FlipOffsets[2][0]   = ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT];
        StereoParams.FlipOffsets[2][1]   = ppdev->singleBack1Offset[OGL_STEREO_BUFFER_RIGHT];

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_STEREO_GLASSES_SWITCH,
                               &StereoParams,                       // input buffer
                               sizeof(StereoParams),
                               NULL,                                // no output buffer
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((1, "bOglStereoGlassesSwitchOn - Error switching stereo glasses on"));
            goto Exit;
        }
        ppdev->bOglStereoActive = TRUE;
    }

    bGlassesSwitchOn = TRUE;

Exit:

    return bGlassesSwitchOn;
}



//
// bOglStereoGlassesSwitchOff
//
// calls the miniport to switch off stereo
// glasses toggling
//
// Return value: FALSE: did not switch glasses toggling off
//               TRUE:  switched off glasses toggling
//
// MSchwarz 11/16/2000: new
//
BOOL bOglStereoGlassesSwitchOff(PDEV* ppdev)
{
    NV_CFG_STEREO_PARAMS  StereoParams;
    ULONG                 ulReturnedDataLength;
    BOOL                  bOglStereoGlassesSwitchOff = FALSE;

    ASSERT(ppdev);

    if (ppdev->bOglStereoActive)
    {
        RtlFillMemory(&StereoParams,sizeof(StereoParams),0xFF);

        StereoParams.Flags               =   STEREOCFG_WS_OGL_API_STEREO   // mark structure as used by ogl api stereo
                                           | STEREOCFG_STEREO_DISABLE;     // switch glasses off
        StereoParams.EyeDisplayed        = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_STEREO_GLASSES_SWITCH,
                               &StereoParams,                       // input buffer
                               sizeof(StereoParams),
                               NULL,                                // no output buffer
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((1, "bOglStereoGlassesSwitchOff - Error switching stereo glasses off"));
            goto Exit;
        }

        ppdev->bOglStereoActive    = FALSE;
    }
    bOglStereoGlassesSwitchOff = TRUE;

Exit:

    return bOglStereoGlassesSwitchOff;
}


//*************************************************************************
// bOglIsStereoClient
// returns TRUE if the given clientInfo describes a client running a 
// stereo pixelformat.
//*************************************************************************
BOOL bOglIsStereoClient(NV_OPENGL_CLIENT_INFO *pClientInfo)
{
    BOOL bIsStereoClient;

    bIsStereoClient =  bOglHasDrawableInfo(pClientInfo)
                    && (pClientInfo->pfd.dwFlags & PFD_STEREO);

    return (bIsStereoClient);
}


//*************************************************************************
// bOglGetNextStereoClient
//
// finds next OpenGL client running on a stereo pixelformat starting with 
// next client after *ppClientInfo or at top of list if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a stereo client was found and returns a pointer to the 
// clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextStereoClient(
    NV_OPENGL_CLIENT_INFO **ppClientInfo) // 
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextClient(&clientInfo))
    {
        if (bOglIsStereoClient(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}



//*************************************************************************
// cOglStereoClients
// returns the current number of clients running a stereo pixelformat
//*************************************************************************
ULONG cOglStereoClients(PPDEV ppdev)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    ULONG                  cStereoClients=0;

    clientInfo = NULL;
    while (bOglGetNextStereoClient(&clientInfo))
    {
        ASSERT(ppdev->bOglStereoDesired);
        cStereoClients++;
    }

    return (cStereoClients);
}



//*************************************************************************
// bOglIsStereoModeEnabled
// 
// returns TRUE if driver is in stereo mode (e.g. double pumping 
// and glasses).
//*************************************************************************
BOOL bOglIsStereoModeEnabled(PPDEV ppdev)
{
    ASSERT(NULL != ppdev);
    return(ppdev->bOglStereoActive);
}


//*************************************************************************
// bOglGetNextActiveStereoClient
//
// Same (including interface) as bOglGetNextStereoClient but only finds 
// active clients. An active client is visible and not disabled by escape.
//
// Returns TRUE if a visible stereo client was found and returns a pointer 
//   to the clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextActiveStereoClient(
    NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextStereoClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextStereoClient(&clientInfo))
    {
        // found stereo client, but is it currently visible
        if (   bOglIsVisibleClient(clientInfo)
            && !clientInfo->bStereoDisabled)
        {
            // if wanted return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}
    
    
    
//*************************************************************************
// bOglStereoModeEnable
// 
// enables GDI double pumping to stereo buffer 
// * Shutter glasses will be enabled
// * Tvinview mode will set the second dacs
// * Vertical interlaced stereo will do nothing
//
// Returns TRUE if succeeded, FALSE if failed.
//*************************************************************************
BOOL bOglStereoModeEnable(PPDEV ppdev)
{
    ASSERT(NULL != ppdev);

    if (   ppdev->bOglStereoDesired
        && (OGL_STEREO_NUMBUFFERS == ppdev->ulOglActiveViews) )
    {
        ULONG ulSurfaceOffset = ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT];

        ASSERT(NV_REG_OGL_STEREO_SUPPORT_OFF != ppdev->oglRegApiStereoSupport);
        ASSERT(ppdev->bOglSingleBackDepthCreated);
        ASSERT((bOglGetNextActiveStereoClient(NULL)));

        // at least one visible stereo client
        // need to toggle glasses and double pump
        if (ppdev->bOglStereoActive)
        {
            // already active, nothing to do.
        }
        else
        {
            // Only workstation parts have ubb buffers
            if (   !bDoublePumped(ppdev, ulSurfaceOffset)
                && !NV_AddDoubleBufferSurface(ppdev, ulSurfaceOffset) )
            {
                // failed to enable double pumping code!
                goto Exit;
            }

            switch (ppdev->oglRegApiStereoMode)
            {

                case NV_REG_OGL_API_STEREO_MODE_SHUTTER_GLASSES:
                {
                    // enable it now
                    if (bOglStereoGlassesSwitchOn(ppdev))
                    {
                        ppdev->bOglStereoActive = TRUE;
                    }
                    else
                    {
                        // failed to enable glasses
                        NV_RemoveDoubleBufferSurface(ppdev, ulSurfaceOffset);
                    }
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_LEFT_0 :
                case NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_RIGHT_0:
                {
                    //stereo (perhaps doesn't need double pumping)
                    ppdev->bOglStereoActive = TRUE;
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_TVINVIEW_LEFT_DAC0         :
                {
                    // dac0 and dac1 are defaulting to left buffer, need to set dac1 to right 
                    // needs double pumping
                    ASSERTDD(FALSE, "not tested NV_REG_OGL_API_STEREO_MODE_TVINVIEW!");
                    if (ppdev->ulNumberDacsActive > 1)
                    {
                        NvSetDacImageOffset(ppdev, ppdev->ulDeviceDisplay[1], ppdev->singleFrontMainOffset[1] - ppdev->ulPrimarySurfaceOffset);
                        ppdev->bOglStereoActive = TRUE;
                    }
                    else
                    {
                        DBG_ERROR("ERROR in bOglStereoModeEnable: need twinview clone mode to enable NV_REG_OGL_API_STEREO_MODE_TVINVIEW");
                    }
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_TVINVIEW_RIGHT_DAC0        :
                {
                    // dac0 and dac1 are defaulting to left buffer, need to set dac0 to right 
                    // needs double pumping
                    ASSERTDD(FALSE, "not tested NV_REG_OGL_API_STEREO_MODE_TVINVIEW!");
                    if (ppdev->ulNumberDacsActive > 1)
                    {
                        NvSetDacImageOffset(ppdev, ppdev->ulDeviceDisplay[0], ppdev->singleFrontMainOffset[1] - ppdev->ulPrimarySurfaceOffset);
                        ppdev->bOglStereoActive = TRUE;
                    }
                    else
                    {
                        DBG_ERROR("ERROR in bOglStereoModeEnable: need twinview clone mode to enable NV_REG_OGL_API_STEREO_MODE_TVINVIEW");
                    }
                    break;
                }

                default:
                    DISPDBG((0, "unsupported NV_REG_OGL_API_STEREO_MODE: 0x%x",ppdev->oglRegApiStereoMode));
                    break;
            }

        }

        ASSERT(ppdev->bOglStereoActive);
        ASSERT(ppdev->DoubleBuffer.bEnabled);
        ASSERT(ppdev->DoubleBuffer.NumBuffers > 0);
        ASSERT(ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT] != ppdev->singleFrontOffset[OGL_STEREO_BUFFER_LEFT]);
    }
    ASSERT(bOglIsStereoModeEnabled(ppdev));

Exit:
    return (ppdev->bOglStereoActive);
}


//*************************************************************************
// bOglStereoModeDisable
// 
// disables stereo mode: 
// * Shutter glasses will stop to toggle
// * Tvinview mode will reset the dacs
// * Vertical interlaced stereo will do nothing
// GDI broadcasting to stereo buffers is stopped.
//
// Returns TRUE if succeeded, FALSE if failed.
//*************************************************************************
BOOL bOglStereoModeDisable(PPDEV ppdev)
{
    BOOL bRet = TRUE;

    ASSERT(NULL != ppdev);

    if (   ppdev->bOglStereoDesired
        && (OGL_STEREO_NUMBUFFERS == ppdev->ulOglActiveViews) )
    {
        ASSERT(ppdev->bOglSingleBackDepthCreated);

        // Although running in a stereo environment it isn't necessary 
        // to enable the shutter glasses and double pumping.
        if (ppdev->bOglStereoActive)
        {
            switch (ppdev->oglRegApiStereoMode)
            {
                case NV_REG_OGL_API_STEREO_MODE_SHUTTER_GLASSES:
                {
                    bOglStereoGlassesSwitchOff(ppdev);
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_TVINVIEW_LEFT_DAC0         :
                case NV_REG_OGL_API_STEREO_MODE_TVINVIEW_RIGHT_DAC0        :
                {
                    ASSERTDD(FALSE, "not tested NV_REG_OGL_API_STEREO_MODE_TVINVIEW!");
                    if (ppdev->ulNumberDacsActive > 1)
                    {
                        ULONG ulHead = ppdev->ulDeviceDisplay[1];
                        NvSetDacImageOffset(ppdev, ulHead,
                            ppdev->rclDisplayDesktop[ulHead].left * ppdev->cjPelSize + ppdev->rclDisplayDesktop[ulHead].top * ppdev->lDelta);
                    }
                    break;
                }

                case NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_LEFT_0 :
                case NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_RIGHT_0:
                default:
                {
                    break;
                }
            }

            if ( bDoublePumped(ppdev, ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT]) )
            {
                NV_RemoveDoubleBufferSurface(ppdev, ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT]);
            }

            ppdev->bOglStereoActive = FALSE;
            // active, need to disable it now
        }

        ASSERT(!ppdev->bOglStereoActive);

        bRet = TRUE;
    }
    return (bRet);
}


//*************************************************************************
// bOglStereoModeUpdate
//
// run through client list and compare against system settings to consider 
// if stereo mode (glasses+double pumping) has to be enabled or not.
// This is used to dynamically toggle between glasses on with GDI double 
// pumping and OpenGL broadcasting to right front and glasses off an a 
// monoscopic usage of the left buffers only. Doing this will increase 
// performance for all non stereo apps in a stereo environment or when 
// all stereo apps are occluded.
//
// returns TRUE if stereomode is enabled
//*************************************************************************
BOOL bOglStereoModeUpdate(PPDEV ppdev)
{
    ASSERT(NULL!=ppdev);

    if (   ppdev->bOglStereoDesired
        && (OGL_STEREO_NUMBUFFERS == ppdev->ulOglActiveViews) )
    {
        ASSERT(ppdev->bOglSingleBackDepthCreated);

        if (bOglGetNextActiveStereoClient(NULL))
        {
            bOglStereoModeEnable(ppdev);
        }
        else
        {
            bOglStereoModeDisable(ppdev);
        }
    }

    // return if stero mode is on or off
    return (ppdev->bOglStereoActive);
}

// End of oglstereo.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglsync.c ===
//******************************Module*Header***********************************
// Module Name: oglsync.c
//
// syncing routines GDI against ogl, and ogl against ogl
//
// Copyright (c) 2001, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"
#include "nvReg.h"
#include "nvcm.h"
#include "oglDD.h"
#include "oglclip.h"
#include "oglflip.h"
#include "oglutils.h"

#include "oglsync.h"

/*
** Problem GDI sync:
** Only want to sync if two channels, here GDI and OpenGL render to the same 
** window (rectangle). As we have cliplists for all OpenGL clients, we are able 
** to track if GDI is going to render to an OpenGL client window. If so we sync
** on the GDI entry and set a flag to sync again on the next OpenGL entry.
**
** Affected functions (all GDI driver entries that render) and code used to 
** quickly determine rclBounds:
**
** + DrvBitBlit (1)
**      uses bOglSyncIfGdiInOglWindowBlt
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prcl : pco->rclBounds;
**
** + DrvCopyBits (1)
**      uses bOglSyncIfGdiInOglWindowBlt
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prcl : pco->rclBounds;
**
** + DrvStretchBlt (1)
**      uses bOglSyncIfGdiInOglWindowStretch
**      // can do inversions of x and y when the destination rectangle is not well ordered.
**      prclRectOrder(&rclDstOrdered, prcl);    // creates an ordered rect
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? rclDstOrdered : pco->rclBounds;
**
** + DrvTextOut            
**      uses bOglSyncIfGdiInOglWindowRect
**      if (prclOpaque) 
**        rclBounds = (DC_TRIVIAL==iDComplexity) ? *prclOpaque : pco->rclBounds;
**      else
**        rclBounds = (DC_TRIVIAL==iDComplexity) ? pstro->rclBkGround : pco->rclBounds;
**
** + DrvLineTo             
**      uses bOglSyncIfGdiInOglWindowRect
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prclBounds : pco->rclBounds;
**
** + DrvStrokePath         
**      uses bOglSyncIfGdiInOglWindowPath
**      PATHOBJ_vGetBounds(ppo, &rcfxBounds);
**      rclTrg.left   = rcfxBounds.xLeft>>4;        // round down
**      rclTrg.top    = rcfxBounds.yTop>>4;
**      rclTrg.right  = (rcfxBounds.xRight+15)>>4;  // round up
**      rclTrg.bottom = (rcfxBounds.yBottom+15)>>4;
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? rclTrg : pco->rclBounds;
** 
** + DrvFillPath           
**      uses bOglSyncIfGdiInOglWindowPath
**      PATHOBJ_vGetBounds(ppo, &rcfxBounds);
**      rclTrg.left   = rcfxBounds.xLeft>>4;        // round down
**      rclTrg.top    = rcfxBounds.yTop>>4;
**      rclTrg.right  = (rcfxBounds.xRight+15)>>4;  // round up
**      rclTrg.bottom = (rcfxBounds.yBottom+15)>>4;
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? rclTrg : pco->rclBounds;
** 
** + DrvPaint              
**      uses bOglSyncIfGdiInOglWindowRect
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? rclDstOrdered : pco->rclBounds;
** 
** + DrvAlphaBlend (1)
**      uses bOglSyncIfGdiInOglWindowStretch
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prcl : pco->rclBounds;
**
** + DrvTransparentBlt (1)
**      uses bOglSyncIfGdiInOglWindowStretch
**      rclBounds = (DC_TRIVIAL==iDComplexity) ? *prcl : pco->rclBounds;
**
** + DrvSaveScreenBits
**      uses bOglSyncIfGdiInOglWindowRect
**      rclBounds = *prcl;
**
** - DrvMovePointer        
** - DrvSetPointerShape    
**      left it out for now, if through DAC then I don't care, 
**      otherwise it should come in through copybits again
**
** + DrvEscape
**      calls bOglSyncOglIfGdiRenderedToWindow
**      no render rect (OPENGL_CMD escape needs to track old GDI rendering and sync)
**             
** + DrvSwapBuffers        
**      calls bOglSyncOglIfGdiRenderedToWindow
**      needs to track old GDI rendering and sync
**
** (1) prcl is prclSrc or prclTrg, depending on src/dst pso
**
*/


#if DBG
// global variable to disable smart syncing
BOOL bOglSyncGdiVsOglDisabled = FALSE;
BOOL bOglFillSyncedGdi        = FALSE;
BOOL bOglFillSyncedOgl        = FALSE;

#define OGLSYNC_FILL_GDI(ppdev,prcl)                                                     \
    if (bOglFillSyncedGdi && bRet)                                                       \
    {                                                                                    \
        RBRUSH_COLOR rbc = {0};                                                          \
        rbc.iSolidColor = 0xff;                                                          \
        ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);      \
        ppdev->DoubleBuffer.SavedProcs.pfnFillSolid(ppdev, 1, prcl, 0xF0F0, rbc, NULL);  \
        ppdev->pfnWaitEngineBusy(ppdev);                                                 \
    }
#define OGLSYNC_FILL_OGL(ppdev,prcl)                                                     \
    if (bOglFillSyncedOgl && bRet)                                                       \
    {                                                                                    \
        RBRUSH_COLOR rbc = {0};                                                          \
        rbc.iSolidColor = 0xff00;                                                        \
        ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);      \
        ppdev->DoubleBuffer.SavedProcs.pfnFillSolid(ppdev, 1, prcl, 0xF0F0, rbc, NULL);  \
        ppdev->pfnWaitEngineBusy(ppdev);                                                 \
    }
#else
    #define OGLSYNC_FILL_GDI(ppdev,prcl)
    #define OGLSYNC_FILL_OGL(ppdev,prcl)
#endif


/*
 * FUNCTION: OglSyncEngineUsingPDEV
 *
 * DESC: Using the given PDEV, sync/engine-stall GDI and OGL Rendering Channels.
 */
void OglSyncEngineUsingPDEV(PDEV *ppdev)
{
    ASSERT(ppdev->bEnabled);

    ppdev->pfnAcquireOglMutex(ppdev);

    DISPDBG((4, "OglSyncEngineUsingPDEV"));

    // wait for GDI to finish
//    ppdev->pfnWaitEngineBusy(ppdev);

    // force a sync/engine-stall with GDI channel
    ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
    ppdev->pfnWaitEngineBusy(ppdev);

    // force a sync/engine-stall with all OGL rendering channels
    ppdev->oglLastChannel = -1;  // FORCE IT TO SYNC...
    ppdev->NVFreeCount = 0;
    ppdev->pfnWaitForChannelSwitch(ppdev);

    ppdev->pfnReleaseOglMutex(ppdev);
}

#ifdef DISABLE_OGLSYNC
#pragma message("  FNicklisch 21.05.2001: WARNING: OglSync against GDI is disabled!")
#else

//*************************************************************************
// bOglSyncOglIfGdiRenderedToWindow
// 
// Syncs all channels if we recognized a gdi command that rendered into the
// OpenGL window. Now we need to sync again, as we need to be sure GDI is 
// finished before we continue with OpenGL.
//*************************************************************************
BOOL bOglSyncOglIfGdiRenderedToWindow(
    IN PPDEV ppdev)
{
    BOOL bRet; 

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);
    bRet = ppdev->pOglServer->bGdiInOglWindowNeedsSync;

    if (bRet && ppdev->bEnabled)
    {
        OglSyncEngineUsingPDEV(ppdev);

        ppdev->pOglServer->bGdiInOglWindowNeedsSync = FALSE;
    }

    return (bRet);
}


//*************************************************************************
// bOglSyncIfGdiInOglWindowRect
// 
// Syncs all channels if rcl and pco describe a drawing region that is 
// within any visible OpenGL client. Either prclTrg or pco can be NULL but
// not both at the same time! pso can be NULL!
// 
// Return: TRUE  - sync happend, intersection with OpenGL
//         FALSE - nothing donde, no intersection with OpenGL
//*************************************************************************
BOOL bOglSyncIfGdiInOglWindowRect(
    IN PPDEV    ppdev,
    IN SURFOBJ *pso,        // surface belonging to prclBounds
    IN RECTL   *prclTrg,    // destination rectangle of drawing surface
    IN CLIPOBJ *pco)        // clip obj for destination
{
    BOOL     bRet = FALSE;  // default: no sync necessary, GDI outside all OpenGL clients

    NV_OPENGL_CLIENT_INFO   *clientInfo         = NULL;
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo = NULL;

    ASSERT(NULL != ppdev);

#if DBG
    // debug code can disable fix
    if (bOglSyncGdiVsOglDisabled)
        goto Exit;
#endif

    //
    // Need a enabled hardware and only work on Quadro!
    //
    if (!ppdev->bEnabled)
    {
        // need valid ppdev
        goto Exit;
    }

    //
    // KEY: disable fix code for GeForce!
    //      Only QUADRO will handle sync OGL vs GDI!
    //
    if (!HWGFXCAPS_QUADRO_GENERIC(ppdev))
    {
        // need supported board
        goto Exit;
    }

    //
    // Need a valid surface
    //
    if (   (NULL == pso)
        || !IS_SCREEN(pso) )
    {
        // not rendering to front, no need to sync
        // NOTE: GDI can only render to front (whereever it is)!
        goto Exit;
    }

    //
    // Calculate final rclBounds for rendering on primary surface
    //    
    if (NULL != pco)
    {
        if (   (DC_TRIVIAL != pco->iDComplexity)
            || (NULL == prclTrg) )
        {
            prclTrg = &pco->rclBounds;
        }
    }

    ASSERTDD(NULL != prclTrg, "bOglSyncIfGdiInOglWindowRect either needs pco or prclTrg, use it correctly!");

    // fast out if no intersection with all clients bounding rect
    if (!bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, prclTrg))
    {
        goto Exit;
    }


    // find first visible ogl client 
    // and initialize clientInfo with pointer to it
    if (!bOglGetNextVisibleClient(&clientInfo))
    {
        // no visible OpenGL client, no need to sync
        goto Exit;
    }

    //
    // Enumerate clients and clip against rclBounds
    //
    do
    {
        ASSERT(NULL != clientInfo); // we enter this loop with a valid client!

        clientDrawableInfo = clientInfo->clientDrawableInfo;
        ASSERT(NULL != clientDrawableInfo);

        //
        // check if bounding rects of client and gdi are intersecting
        //
        if (bRclIntersect(NULL, (RECTL *)&clientDrawableInfo->rect, prclTrg))
        {
            ULONG ulRect;

            //
            // This potentially is a critical GDI call. Verify that it is inside 
            // one of the ogl clipping rects.
            //

            // Loop over clients clip list 
            for (ulRect=0; !bRet && (ulRect < clientDrawableInfo->numClipRects); ulRect++)
            {
                // if we have a proper pco 
                // clip each client rect against all clipobj rects

                if (   (NULL != pco)
                    && (DC_TRIVIAL != pco->iDComplexity) )
                {
                    bRet = bOglClipRectAgainstClipobj(pco, (RECTL *)&clientDrawableInfo->copyWindowRect[ulRect]);
                }
                else
                {
                    bRet = bRclIntersect(NULL, (RECTL *)&clientDrawableInfo->copyWindowRect[ulRect], prclTrg);
                }
                OGLSYNC_FILL_OGL(ppdev,(RECTL *)&clientDrawableInfo->copyWindowRect[ulRect]);
                OGLSYNC_FILL_GDI(ppdev,prclTrg);
            }
        }
    } 
    while (!bRet && bOglGetNextVisibleClient(&clientInfo));

    //
    // Handle the sync if needed
    //
    if (bRet)
    {
        ASSERT(NULL != ppdev->pOglServer);
        DISPDBG((3, "bOglSyncIfGdiInOglWindowRect: need sync"));
        // we now know that GDI is rendering from/to an OpenGL window
        // Sync everything, to get a stable base for GDI
        OglSyncEngineUsingPDEV(ppdev);

        //
        // As double pumping to within a Ogl's backbuffer potentially 
        // destroyes its content, we cannot allow this. Unfortunately
        // our double pumping cannot handle this. Therefore we need to
        // disable pageflipping (and with that double pumping) now.
        //

        if (   ppdev->pOglServer->bWindowInMovement
            || (   !bRclIsEqual(prclTrg, (RECTL *)&clientDrawableInfo->rect) // not client size
                && bRclIsIn (prclTrg, (RECTL *)&clientDrawableInfo->rect) )) // bounds is bigger than client
        {
            // this is a GDI that starts outside the window, although we sync
            // we don't disable page flipping as it possibly is a copy of the entire window!
            DISPDBG((3, "bOglSyncIfGdiInOglWindowRect: GDI bounding ogl: copy on window move?"));
        }
        else
        {
            DISPDBG((3, "bOglSyncIfGdiInOglWindowRect: GDI inside ogl: disable pf"));
            // Because of our double pumping code, we cannot pageflip GDI to OpenGL back!
            if (0 != cOglFlippingClients(ppdev))
            {
                bOglPageFlipModeDisableAll(ppdev);

                // try again later: Take any random number, I use refresh rate for now, but
                // could calculate a number depending on window size vs desktop size
                ppdev->pOglServer->ulPageFlipRetryCounter = PAGEFLIP_RETRY_COUNTER_START;
            }
        }

        ppdev->pOglServer->bGdiInOglWindowNeedsSync = TRUE;
    }

Exit:
    return (bRet);
}


//*************************************************************************
// bOglSyncIfGdiInOglWindowPath
// 
// Syncs all channels if rcl and pco describe a drawing region that is 
// within any visible OpenGL client. pco can be NULL.
// 
// Return: TRUE  - sync happend, intersection with OpenGL
//         FALSE - nothing donde, no intersection with OpenGL
//*************************************************************************
BOOL bOglSyncIfGdiInOglWindowPath(
    IN PPDEV    ppdev,
    IN SURFOBJ *pso,        // surface belonging to object
    IN PATHOBJ *ppo,        // pathobject to be rendered on pso
    IN CLIPOBJ *pco)        // clip obj for destination
{
    BOOL     bRet = FALSE;  // default: no sync necessary, GDI outside all OpenGL clients
    RECTFX   rcfxBounds;
    RECTL    rclTrg;

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppo);
    ASSERT(NULL != ppdev->pOglServer);

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);
    rclTrg.left   = rcfxBounds.xLeft >> 4;        // round down
    rclTrg.top    = rcfxBounds.yTop  >> 4;
    rclTrg.right  = (rcfxBounds.xRight+15)  >> 4;  // round up
    rclTrg.bottom = (rcfxBounds.yBottom+15) >> 4;

    // fast out if no intersection with all clients bounding rect
    if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, &rclTrg))
    {
        bRet = bOglSyncIfGdiInOglWindowRect(
            ppdev,
            pso,        // surface belonging to prclBounds
            &rclTrg,    // destination rectangle of drawing surface
            pco);       // clip obj for destination
    }

    return (bRet);
}


//*************************************************************************
// bOglSyncIfGdiInOglWindowBlt
// 
// Simple wrawpper for bOglSyncIfGdiInOglWindowRect to be called from a 
// blt function that uses source point and target rect as blt functions.
//*************************************************************************
BOOL bOglSyncIfGdiInOglWindowBlt(
    IN PPDEV    ppdev,
    IN SURFOBJ *psoDst,     // surface belonging to dst object     
    IN SURFOBJ *psoSrc,     // surface belonging to src object     
    IN CLIPOBJ *pco,        // clip obj for destination        
    IN RECTL   *prclDst,    // destination rectangle
    IN POINTL  *pptlSrc)    // source point
{
    BOOL     bRet = FALSE;  // default: no sync necessary, GDI outside all OpenGL clients

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);

    // fast out if no intersection with all clients bounding rect
    if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, prclDst))
    {
        // try destination first
        bRet = bOglSyncIfGdiInOglWindowRect(ppdev, psoDst, prclDst, pco);
    }

    if (   !bRet
        && (NULL != psoSrc)
        && (NULL != pptlSrc) )
    {
        RECTL rclSrc;

        rclSrc.left   = pptlSrc->x;
        rclSrc.right  = pptlSrc->x + lRclWidth(prclDst);
        rclSrc.top    = pptlSrc->y;
        rclSrc.bottom = pptlSrc->y + lRclHeight(prclDst);

        if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, &rclSrc))
        {
            // Now source, but cannot use destination pco
            bRet = bOglSyncIfGdiInOglWindowRect(ppdev, psoSrc, &rclSrc, NULL);
        }
    }
    ppdev->pOglServer->bWindowInMovement = FALSE;

    return (bRet);
}



//*************************************************************************
// bOglSyncIfGdiInOglWindowStretch
// 
// Simple wrawpper for bOglSyncIfGdiInOglWindowRect to be called from a 
// blt function that uses source and target rects as stretch functions.
//*************************************************************************
BOOL bOglSyncIfGdiInOglWindowStretch(
    IN PPDEV    ppdev,
    IN SURFOBJ *psoDst,     // surface belonging to dst object     
    IN SURFOBJ *psoSrc,     // surface belonging to src object     
    IN CLIPOBJ *pco,        // clip obj for destination        
    IN RECTL   *prclDst,    // destination rectangle
    IN RECTL   *prclSrc)    // source point
{
    BOOL     bRet = FALSE;  // default: no sync necessary, GDI outside all OpenGL clients
    RECTL    rclOrdered;

    ASSERT(NULL != ppdev);
    ASSERT(NULL != ppdev->pOglServer);

    // try destination first
    prclRclOrder(&rclOrdered, prclDst);
    if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, &rclOrdered))
    {
        bRet = bOglSyncIfGdiInOglWindowRect(ppdev, psoDst, &rclOrdered, pco);
    }

    if (   !bRet
        && (NULL != psoSrc)
        && (NULL != prclSrc) )
    {
        // Now source, but cannot use destination pco
        prclRclOrder(&rclOrdered, prclSrc);
        if (bRclIntersect(NULL, &ppdev->pOglServer->rclAllClientsBounds, &rclOrdered))
        {
            bRet = bOglSyncIfGdiInOglWindowRect(ppdev, psoSrc, &rclOrdered, NULL);
        }
    }

    return (bRet);
}
#endif // DISABLE_OGLSYNC
// End of oglsync.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglsync.h ===
#ifndef _OGLSYNC_H
#define _OGLSYNC_H
//******************************Module*Header***********************************
// Module Name: oglsync.h
//
// interface file for syncing routines GDI against ogl, and ogl against ogl
//
// Copyright (c) 2001, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

void OglSyncEngineUsingPDEV(PDEV *ppdev);
#ifdef DISABLE_OGLSYNC
    #pragma message("  FNicklisch: WARNING: OglSync against GDI is disabled, shouldn't be default!")
    #define bOglSyncOglIfGdiRenderedToWindow(ppdev)                                     TRUE
    #define bOglSyncIfGdiInOglWindowRect(ppdev,pso,prclTrg,pco)                         TRUE
    #define bOglSyncIfGdiInOglWindowPath(ppdev,pso,ppo,pco)                             TRUE
    #define bOglSyncIfGdiInOglWindowBlt(ppdev,psoDst,psoSrc,pco,prclDst,pptlSrc)        TRUE
    #define bOglSyncIfGdiInOglWindowStretch(ppdev,psoDst,psoSrc,pco,prclDst,prclSrc)    TRUE
#else

BOOL bOglSyncOglIfGdiRenderedToWindow(
    IN PPDEV ppdev);

BOOL bOglSyncIfGdiInOglWindowRect(
    IN PPDEV    ppdev,
    IN SURFOBJ *pso,        // surface belonging to prclBounds
    IN RECTL   *prclTrg,    // destination rectangle of drawing surface
    IN CLIPOBJ *pco);       // clip obj for destination

BOOL bOglSyncIfGdiInOglWindowPath(
    IN PPDEV    ppdev,
    IN SURFOBJ *pso,        // surface belonging to object
    IN PATHOBJ *ppo,        // pathobject to be rendered on pso
    IN CLIPOBJ *pco);       // clip obj for destination

BOOL bOglSyncIfGdiInOglWindowBlt(
    IN PPDEV    ppdev,
    IN SURFOBJ *psoDst,     // surface belonging to dst object     
    IN SURFOBJ *psoSrc,     // surface belonging to src object     
    IN CLIPOBJ *pco,        // clip obj for destination        
    IN RECTL   *prclDst,    // destination rectangle
    IN POINTL  *pptlSrc);   // source point

BOOL bOglSyncIfGdiInOglWindowStretch(
    IN PPDEV    ppdev,
    IN SURFOBJ *psoDst,     // surface belonging to dst object     
    IN SURFOBJ *psoSrc,     // surface belonging to src object     
    IN CLIPOBJ *pco,        // clip obj for destination        
    IN RECTL   *prclDst,    // destination rectangle
    IN RECTL   *prclSrc);   // source point
#endif //DISABLE_OGLSYNC

#endif // _OGLSYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglswap.c ===
/******************************Module*Header*******************************\
* Module Name: oglswap.c
*
* This module contains the functions to support the OpenGL swap buffers.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "oglOverlay.h"
#include "oglsync.h"
#include "oglflip.h"
#include "Nvcm.h"   // Needed for NV_CFG_VBLANK_COUNTER,

#if (NVARCH >= 0x4)
#include "nvcom.h"          // drivers/common/inc
#include "nvtracecom.h"     // drivers/common/inc
#endif // (NVARCH >= 0x4)


#define DBG_SWAP_MESSAGES 1
#undef DBG_SWAP_MESSAGES


#define __glNV4SetupSwap(a, b, c, d, e, f)

//******************************************************************************
//
//  Function: OglUseDisplayDriverBlt
//
//  Routine Description:
//
//        Utility routine to use display driver channel for a BLIT.
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
void
OglUseDisplayDriverBlt(
    PDEV *ppdev, 
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo,
    LONG srcOffset,
    LONG srcPitch,
    LONG srcLeft, 
    LONG srcTop, 
    LONG dstOffset,
    LONG dstPitch,
    LONG dstLeft, 
    LONG dstTop, 
    LONG width, 
    LONG height
)
    {
    if (srcLeft != dstLeft || srcTop != dstTop)
        {
        LONG dstRight, dstBottom;
        RECTL  rclDst;
        POINTL ptlSrc;

        ppdev->NVFreeCount = 0;

        //**************************************************************
        // Clip to display... (pixels outside of display size are undefined)
        //**************************************************************
        if ((long)dstLeft < (long)0)
            {
            srcLeft -= dstLeft;
            width += dstLeft;
            dstLeft = 0;
            }
        if ((long)dstTop < (long)0)
            {
            srcTop -= dstTop;
            height += dstTop;
            dstTop = 0;
            }

        if ((long)width > 0 && (long)height > 0)
            {
            LONG lDeltaX, lDeltaY;

            dstRight = dstLeft + width;
            dstBottom = dstTop + height;

            if ((long)srcLeft < (long)0)
                {
                ptlSrc.x = 0;
                rclDst.left = -srcLeft + dstLeft;
                }
            else
                {
                ptlSrc.x = srcLeft;
                rclDst.left = dstLeft;
                }
            if ((long)srcTop < (long)0)
                {
                ptlSrc.y = 0;
                rclDst.top = -srcTop + dstTop;
                }
            else
                {
                ptlSrc.y = srcTop;
                rclDst.top = dstTop;
                }

            // right and bottom of source must be inside screen too,
            // because we cannot blit from outside of screen!
            lDeltaX = srcLeft + width - clientDrawableInfo->cxScreen;
            if (lDeltaX > 0)
                {
                width    -= lDeltaX;
                dstRight -= lDeltaX;
                }

            lDeltaY = srcTop + height - clientDrawableInfo->cyScreen;
            if (lDeltaY > 0)
                {
                height    -= lDeltaY;
                dstBottom -= lDeltaY;
                }

            if ((long)dstRight > (long)clientDrawableInfo->cxScreen)
                {
                rclDst.right = clientDrawableInfo->cxScreen;
                }
            else
                {
                rclDst.right = dstRight;
                }

            if ((long)dstBottom > (long)clientDrawableInfo->cyScreen)
                {
                rclDst.bottom = clientDrawableInfo->cyScreen;
                }
            else
                {
                rclDst.bottom = dstBottom;
                }

            if ((long)rclDst.right >= (long)rclDst.left &&
                (long)rclDst.bottom >= (long)rclDst.top)
                {

                ppdev->pfnAcquireOglMutex(ppdev);

                // do complete sync on all ICD channels
                OglSyncEngineUsingPDEV(ppdev);

                (ppdev->pfnSetSourceBase)(ppdev, srcOffset, srcPitch);
                (ppdev->pfnSetDestBase)(ppdev, dstOffset, dstPitch);
                (ppdev->pfnCopyBlt)(ppdev, 1, &rclDst, 0xcccc, &ptlSrc, &rclDst, NULL);

                ppdev->pfnWaitEngineBusy(ppdev);

                ppdev->pfnReleaseOglMutex(ppdev);
                }
            }

        }
    }

// This function builds the intersection of a cliplist with a SwapHintRect list.
// INPUT:   pSwapHintRects points to the list that was passed in by the escape
//          numSwapHintRects is the number of rects in pSwapHintRects
//          windowRectList is the translated cliplist from the clientDrawableInfo
//          numWindowRects is the number of cliprects in windowRectList
//          pSwapRects points to the resulting list of swap rectangles
// OUTPUT:  pSwapRects contains NULL if there are no SwapHintRects in the escape data,
//              otherwise it contains a pointer to the newly allocated list of swap rectangles
//          the return value is the number of resulting swap rectangles

ULONG OglApplySwapHintRects(
    __GLregionRect *pSwapHintRects, 
    ULONG numSwapHintRects, 
    __GLregionRect *windowRectList, 
    ULONG numWindowRects, 
    __GLregionRect *pSwapRects
)
    {
    ULONG ulNumResultRects = 0;

    if ((numSwapHintRects > 0) && (NULL != pSwapHintRects)) 
        {
        __GLregionRect *pSwapRect;
        __GLregionRect *pClipRect;
        __GLregionRect *pResultRect;
        int numSwapRects, numClipRects;

        numSwapRects = numSwapHintRects;

        if (NULL != pSwapRects) 
            {
            // clip each clip rect against each swaphint rect to get the resulting list of swap rectangles 
            pSwapRect = pSwapHintRects;
            ASSERT(NULL != pSwapRect); // if the counter is > 0, there must be a rectangle
            while (numSwapRects > 0) 
                {
                pClipRect       = windowRectList;
                numClipRects    = numWindowRects;
                while (numClipRects > 0) {
                    // Test on intersection                    
                    if (   (pSwapRect->x0 < pClipRect->x1) 
                        && (pSwapRect->x1 > pClipRect->x0)  
                        && (pSwapRect->y0 < pClipRect->y1) 
                        && (pSwapRect->y1 > pClipRect->y0) )
                        {
                        // copy intersection rectangle into resulting swaprect list
                        pResultRect = &pSwapRects[ulNumResultRects];
                        pResultRect->x0 = max(pSwapRect->x0, pClipRect->x0);
                        pResultRect->x1 = min(pSwapRect->x1, pClipRect->x1);
                        pResultRect->y0 = max(pSwapRect->y0, pClipRect->y0);
                        pResultRect->y1 = min(pSwapRect->y1, pClipRect->y1);
                        ulNumResultRects++;
                        }
                    pClipRect++;
                    numClipRects--;
                    }
                pSwapRect++;
                numSwapRects--;
                }    
            }
        }

    return ulNumResultRects;
    }


//******************************************************************************
//
//  Function: NV4_OglSwapBuffers
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
ULONG
NV4_OglSwapBuffers(
    PDEV *ppdev,
    HWND hWnd,
    HDC hDC,
    ULONG hClient,
    __GLNVswapInfo *swapInfo
)
{
#if (NVARCH >= 0x4)
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    __GLNVcmdInfo              *cmdInfo;
    LONG                       status;
    RECTL                      *windowRectList;
    ULONG                      numWindowRects;
    ULONG                      swapHintUsed;

    if (!swapInfo ||
        ppdev->dwGlobalModeSwitchCount != swapInfo->localModeSwitchCount)
        {
        OglDebugPrint("NV4_OglSwapBuffers: bailing OGL_ERROR_MODE_SWITCH\n");
        swapInfo->retStatus = OGL_ERROR_MODE_SWITCH;
        return((ULONG)FALSE);
        }

    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("NV4_OglSwapBuffers: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    if (clientInfo)
        {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        }
    else
        {
        OglDebugPrint("NV4_OglSwapBuffers: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    try
    {
        cmdInfo = swapInfo->cmdInfo;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        DISPDBG((1, "NV4_OglSwapBuffers: cmdInfo: exception = 0x%lx", status));
        return((ULONG)FALSE);
    }    
    
    // If the client side clipChangedCount is out of date the window may
    // have moved or resized.  Kick back to the client so buffer info may
    // be reloaded.
    if ((LONG)swapInfo->clipChangedCount != (LONG)clientDrawableInfo->clipChangedCount)
        {
        swapInfo->retStatus = OGL_ERROR_WINDOW_CHANGED_COUNT;
        return((ULONG)FALSE); 
        }

#ifdef DBG
    nvDebugLevel   = cmdInfo->nvDebugLevel;
    nvDebugOptions = cmdInfo->nvDebugOptions;
    nvDebugMask    = cmdInfo->nvDebugMask;
    nvControlOptions = cmdInfo->nvControlOptions;
#endif
    
    // If the window is not visible, stop
    if (clientDrawableInfo->clipFlags == NV_WINDOW_CLIP_OCCLUDED ||
        clientDrawableInfo->numClipRects == 0)
        {
        swapInfo->retStatus = OGL_ERROR_NO_ERROR;
        return TRUE;
        }

    if (FALSE == NV_OglUpdateClipLists(ppdev, clientDrawableInfo)) {
        swapInfo->retStatus = OGL_ERROR_REALLOC_FAILURE;
        return FALSE;
    }

    //
    // If retry counter is set, try to enable pageflipping again
    //
    bOglPageFlipModeRetryEnable(ppdev);

    windowRectList = clientDrawableInfo->cachedClipRectList;
    numWindowRects = clientDrawableInfo->cachedNumClipRects;

    cmdInfo->ntOther      = (void *)ppdev;
    cmdInfo->ntDrawable   = (void *)clientDrawableInfo;
    cmdInfo->ntClientInfo = clientInfo;
    ASSERT(bOglHasDrawableInfo(cmdInfo->ntClientInfo));

    // RBiermann: apply SwapHintRects on the windowRectList if there is a list in the __GLNVswapInfo
    swapHintUsed = FALSE;
    if (swapInfo->numSwapHintRects > 0)
        {
        __GLregionRect *pSwapRectList = NULL; // ptr to the swaprect list after applying the SwapHintRects extension
        ULONG          numSwapRects = 0;      // number of swaprect after applying the SwapHintRects extension

        // I have to allocate the size of the maximal resulting list because there is no EngReallocMem.
        // But this is not too bad because numSwapHintRects is always 1 in 3DSMax.
        pSwapRectList = EngAllocMem(  FL_ZERO_MEMORY, 
                                      swapInfo->numSwapHintRects * numWindowRects * sizeof(__GLregionRect),
                                      ALLOC_TAG);

        ASSERT(pSwapRectList);
        if (pSwapRectList != NULL)
            {
            swapHintUsed = TRUE;

            numSwapRects = OglApplySwapHintRects(   swapInfo->pSwapHintRects,
                                                    swapInfo->numSwapHintRects, 
                                                    (__GLregionRect *)windowRectList, 
                                                    numWindowRects, 
                                                    pSwapRectList);
            if (numSwapRects > 0)
                {
                // Call into the shared library to do the swap.
                __glNV4SetupSwap(cmdInfo, (void *) swapInfo->drawable, 
                                 numSwapRects,
                                 pSwapRectList,
                                 (int) clientDrawableInfo->cxScreen,
                                 (int) clientDrawableInfo->cyScreen);

                }

            EngFreeMem(pSwapRectList);
            }
        }


    if (FALSE == swapHintUsed)
        {
        // Call into the shared library to do the swap.
        __glNV4SetupSwap(cmdInfo, (void *) swapInfo->drawable, 
                         numWindowRects,
                         (__GLregionRect *)windowRectList,
                         (int) clientDrawableInfo->cxScreen,
                         (int) clientDrawableInfo->cyScreen);
        }

    swapInfo->retStatus = OGL_ERROR_NO_ERROR;
#endif // (NVARCH >= 0x4)
    return((ULONG)TRUE);
}

#if (NVARCH >= 0x4)
//******************************************************************************
//
//  Function: NV_OglSwapBuffers
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
ULONG
NV_OglSwapBuffers(
    PDEV *ppdev,
    HWND hWnd,
    HDC hDC,
    ULONG hClient,
    __GLNVswapInfo *swapInfo
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    __GLNVcmdInfo              *cmdInfo;
    LONG                       status;
    RECTL                      *windowRectList;
    ULONG                      numWindowRects;
    ULONG                      swapHintUsed;

    if (!swapInfo ||
        ppdev->dwGlobalModeSwitchCount != swapInfo->localModeSwitchCount)
        {
        OglDebugPrint("NV_OglSwapBuffers: bailing OGL_ERROR_MODE_SWITCH\n");
        swapInfo->retStatus = OGL_ERROR_MODE_SWITCH;
        return((ULONG)FALSE);
        }
    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    if (clientList)
        {
        clientInfo = &clientList->clientInfo;
        }
    else
        {
        OglDebugPrint("NV_OglSwapBuffers: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    if (clientInfo)
        {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        }
    else
        {
        OglDebugPrint("NV_OglSwapBuffers: bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        return((ULONG)FALSE);
        }

    try
    {
        cmdInfo = swapInfo->cmdInfo;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        swapInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        DISPDBG((1, "NV_OglSwapBuffers: cmdInfo: exception = 0x%lx", status));
        return((ULONG)FALSE);
    }    

    // If the client side clipChangedCount is out of date the window may
    // have moved or resized.  Kick back to the client so buffer info may
    // be reloaded.
    if ((LONG)swapInfo->clipChangedCount != (LONG)clientDrawableInfo->clipChangedCount)
        {
        swapInfo->retStatus = OGL_ERROR_WINDOW_CHANGED_COUNT;
        return((ULONG)FALSE); 
        }

#ifdef DBG
    nvDebugLevel   = cmdInfo->nvDebugLevel;
    nvDebugOptions = cmdInfo->nvDebugOptions;
    nvDebugMask    = cmdInfo->nvDebugMask;
    nvControlOptions = cmdInfo->nvControlOptions;
#endif
    
    // If the window is not visible, stop
    if (clientDrawableInfo->clipFlags == NV_WINDOW_CLIP_OCCLUDED ||
        clientDrawableInfo->numClipRects == 0)
        {
        swapInfo->retStatus = OGL_ERROR_NO_ERROR;
        return TRUE;
        }

    if (FALSE == NV_OglUpdateClipLists(ppdev, clientDrawableInfo)) {
        swapInfo->retStatus = OGL_ERROR_REALLOC_FAILURE;
        return FALSE;
    }

    //
    // If retry counter is set, try to enable pageflipping again
    //
    bOglPageFlipModeRetryEnable(ppdev);

    windowRectList = clientDrawableInfo->cachedClipRectList;
    numWindowRects = clientDrawableInfo->cachedNumClipRects;

    cmdInfo->ntOther      = (void *)ppdev;
    cmdInfo->ntDrawable   = (void *)clientDrawableInfo;
    cmdInfo->ntClientInfo = clientInfo;
    ASSERT(bOglHasDrawableInfo(cmdInfo->ntClientInfo));

    // In a stereo environment enable broadcasting to
    // right buffer if stereo is active. 
    // NOTE: this is also done for monoscopic apps, but we need the right 
    //       buffers to be initialized
    if (ppdev->bOglStereoDesired)
    {
        __glNVPrepareStereoSwap((void *)swapInfo->drawable, ppdev->bOglStereoActive);
    }

    // RBiermann: apply SwapHintRects on the windowRectList if there is a list in the __GLNVswapInfo
    swapHintUsed = FALSE;
    if (swapInfo->numSwapHintRects > 0)
        {
        __GLregionRect *pSwapRectList = NULL; // ptr to the swaprect list after applying the SwapHintRects extension
        ULONG          numSwapRects = 0;      // number of swaprect after applying the SwapHintRects extension

        // I have to allocate the size of the maximal resulting list because there is no EngReallocMem.
        // But this is not too bad because numSwapHintRects is always 1 in 3DSMax.
        pSwapRectList = EngAllocMem(  FL_ZERO_MEMORY, 
                                      swapInfo->numSwapHintRects * numWindowRects * sizeof(__GLregionRect),
                                      ALLOC_TAG);

        ASSERT(pSwapRectList);
        if (pSwapRectList != NULL)
            {
            swapHintUsed = TRUE;

            numSwapRects = OglApplySwapHintRects(   swapInfo->pSwapHintRects,
                                                    swapInfo->numSwapHintRects, 
                                                    (__GLregionRect *)windowRectList, 
                                                    numWindowRects, 
                                                    pSwapRectList);
            if (numSwapRects > 0)
                {
                // Call into the shared library to do the swap.
                __glNVSetupSwap(cmdInfo, (void *) swapInfo->drawable, 
                                numSwapRects,
                                pSwapRectList,
                                (int) clientDrawableInfo->cxScreen,
                                (int) clientDrawableInfo->cyScreen);

                }

            EngFreeMem(pSwapRectList);
            }
        }


    if (FALSE == swapHintUsed)
        {
        // Call into the shared library to do the swap.
        __glNVSetupSwap(cmdInfo, (void *) swapInfo->drawable, 
                        numWindowRects,
                        (__GLregionRect *)windowRectList,
                        (int) clientDrawableInfo->cxScreen,
                        (int) clientDrawableInfo->cyScreen);
        }

    swapInfo->retStatus = OGL_ERROR_NO_ERROR;
    return (TRUE);
}


/*
** NV_OglOverlayMergeBlit
** 
** Derived from NV_OglSwapBuffers.
**
** Display driver version of overlay merge blit implementation. 
** Needs to feed the surface offsets to the blit.
** Needs to feed correct clip information.
** 
** return:
**    TRUE  - succeeded
**    FALSE - failed to do the merge blit
** 
** FNicklisch 26.09.2000: New
*/ 
ULONG NV_OglOverlayMergeBlit(
    PDEV                       *ppdev,
    HWND                        hWnd,
    HDC                         hDC,
    __GLNVoverlayMergeBlitInfo *pMergeInfo
)
{
    NV_OPENGL_CLIENT_INFO      *clientInfo         = NULL;  // Client data...
    NV_OPENGL_CLIENT_INFO_LIST *clientList         = NULL;
    NV_OPENGL_DRAWABLE_INFO    *clientDrawableInfo = NULL;
    __GLNVcmdInfo              *cmdInfo;                    // Common commandinfo passed to merge blit
    RECTL                      *prclWindowClipList;         // local clip list
    ULONG                       numWindowRects;             // number of valid rects inside prclWindowClipList
    __GLMergeBlitData           MergeBlitData;              // Data structure passed to merge blit
    NV_LAYER_PALETTE           *pLayerPalette;              // overlay palette used for this window
    ULONG                       ulRet              = FALSE; // default error Exit
    unsigned int                dwAction           = 0;     // Local mergeblit configuration bits
    ULONG                       ulTemp;

    ASSERT(NULL!=ppdev);
    ASSERT(NULL!=pMergeInfo);

    //
    // check if overlay is possible
    //
    if (!ppdev->bOglOverlaySurfacesCreated)
    {
        // This happens during startup of an overlayed ogl app!
        pMergeInfo->retStatus = OGL_ERROR_SURFACE_INVALID;
        goto Exit;
    }

    try
    {
        cmdInfo = pMergeInfo->cmdInfo;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ASSERTDD(0,"cannot access pMergeInfo, please fix that!");
        DISPDBG((1, "NV_OglOverlayMergeBlit: pMergeInfo: exception = 0x%lx", GetExceptionCode()));
        pMergeInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        goto Exit;
    }    
    
    clientList = OglFindClientInfoFromHWndHDC(ppdev, hWnd, hDC);
    ASSERT(NULL!=clientList);
    if (clientList)
    {
        clientInfo = &clientList->clientInfo;
        ASSERT(NULL!=clientInfo);
    }
    else
    {
        pMergeInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        goto Exit;
    }

    if (clientInfo)
    {
        clientDrawableInfo = clientInfo->clientDrawableInfo;
        ASSERT(NULL!=clientDrawableInfo);
    }
    else
    {
        pMergeInfo->retStatus = OGL_ERROR_CLIENT_NOT_FOUND;
        goto Exit;
    }

    // If the window is not visible, stop
    if (clientDrawableInfo->clipFlags == NV_WINDOW_CLIP_OCCLUDED ||
        clientDrawableInfo->numClipRects == 0)
    {
        pMergeInfo->retStatus = OGL_ERROR_NO_ERROR;
        ulRet = TRUE;
        goto Exit;
    }

    prclWindowClipList =
        EngAllocMem(FL_ZERO_MEMORY, 
                    (sizeof(RECTL) * clientDrawableInfo->numClipRects), ALLOC_TAG);

    if (NULL==prclWindowClipList)
    {
        OglDebugPrint("NV_OglOverlayMergeBlit: EngAllocMem failed for prclWindowClipList, bailing OGL_ERROR_CLIENT_NOT_FOUND\n");
        pMergeInfo->retStatus = OGL_ERROR_CLIP_LIST_BAD;
        goto Exit;
    }


    //
    // FNicklisch: ToDo later...
    // Can spend some time on rewritting the clip list code below.
    // It isn't neccessary to convert to client relative and then back to 
    // desktop relative.
    // 
    
    //
    // Client relative part
    //

    OglTranslateCachedClipRectList(ppdev,
                                   clientDrawableInfo->copyWindowRect,
                                   clientDrawableInfo->numClipRects,
                                   prclWindowClipList,
                                   &numWindowRects,
                                   (RECTL *) &(clientDrawableInfo->rect));
    ASSERT(numWindowRects==clientDrawableInfo->numClipRects);

    // RBiermann: apply SwapHintRects on the windowRectList if there is a list
    if (pMergeInfo->numSwapHintRects > 0)
        {
        __GLregionRect *pSwapRectList = NULL; // ptr to the swaprect list after applying the SwapHintRects extension
        ULONG           numSwapRects  = 0;    // number of swaprect after applying the SwapHintRects extension

        // I have to allocate the size of the maximal resulting list because there is no EngReallocMem.
        // But this is not too bad because numSwapHintRects is always 1 in 3DSMax.
        pSwapRectList = EngAllocMem(  FL_ZERO_MEMORY, 
                                      pMergeInfo->numSwapHintRects * numWindowRects * sizeof(__GLregionRect),
                                      ALLOC_TAG);

        ASSERT(pSwapRectList);
        if (NULL != pSwapRectList)
            {
            ASSERT(NULL != prclWindowClipList);
            ASSERT(numWindowRects>0);

            numSwapRects = OglApplySwapHintRects(pMergeInfo->pSwapHintRects,
                                                 pMergeInfo->numSwapHintRects, 
                                                 (__GLregionRect *)prclWindowClipList, 
                                                 numWindowRects, 
                                                 pSwapRectList);

            // use the swaphint list as current clip list and release the old one
            EngFreeMem(prclWindowClipList);

            prclWindowClipList = (RECTL *) pSwapRectList;
            numWindowRects     = numSwapRects;
            }
        }


    //
    // Use desktop relative coordinates here. In place translation!
    //
    OglTranslateClientRelativeRectListToDevice(ppdev,
                                               prclWindowClipList, numWindowRects,
                                               prclWindowClipList, &ulTemp,
                                               (RECTL *) &(clientDrawableInfo->rect));
    ASSERT(numWindowRects==ulTemp);

    MergeBlitData.prclClip           = (__GLregionRect *)prclWindowClipList;
    MergeBlitData.cClip              = numWindowRects;

    //
    // Setup offset data 
    //
    MergeBlitData.PrimaryFrontOffset = ppdev->ulPrimarySurfaceOffset;
    MergeBlitData.PrimaryFrontPitch  = ppdev->lDelta;
    MergeBlitData.ScratchOffset      = ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.ScratchPitch       = ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_LEFT];

    MergeBlitData.MainFrontOffset    = ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.MainFrontPitch     = ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.MainBackOffset     = ppdev->singleBack1MainOffset[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.MainBackPitch      = ppdev->singleBack1MainPitch[OGL_STEREO_BUFFER_LEFT];

    MergeBlitData.OverlayFrontOffset = ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.OverlayFrontPitch  = ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT];
    MergeBlitData.OverlayBackOffset  = ppdev->singleBack1OverlayOffset[OGL_STEREO_BUFFER_LEFT]; 
    MergeBlitData.OverlayBackPitch   = ppdev->singleBack1OverlayPitch[OGL_STEREO_BUFFER_LEFT]; 


    if (!bOglFindGlobalLayerPaletteHWND(hWnd, &pLayerPalette))
    {
        // 
        // No palette does mean no layer plane!
        // FNicklisch: This is kind of a hack! Should find a better way to check if a window is an overlay window.
        //
        //isn't so critical...OglDebugPrint("NV_OglOverlayMergeBlit: couldn't find layer palette!\n");

        dwAction               = NV_OVERLAY_NO_OVERLAY_PLANE;
        MergeBlitData.colorref = ICD_PALETTE_TRANSPARENT_COLOR;
    }
    else
    {
        ASSERT(NULL!=pLayerPalette);
        MergeBlitData.colorref = pLayerPalette->entries[pLayerPalette->crTransparent];
    }

    ASSERT(2==ppdev->cjPelSize || 4==ppdev->cjPelSize);

    MergeBlitData.colordepth         = ppdev->cjPelSize * 8; // 16 or 32!
    MergeBlitData.dwAction           = pMergeInfo->dwAction | dwAction;

    // Only know these bits
    ASSERT(0==(MergeBlitData.dwAction & ~(  NV_OVERLAY_MERGE_BLIT
                                          | NV_OVERLAY_UPDATE_OVERLAY
                                          | NV_OVERLAY_UPDATE_MAIN
                                          | NV_OVERLAY_USE_CLIPRECT
                                          | NV_OVERLAY_DEFERRED
                                          | NV_OVERLAY_NO_OVERLAY_PLANE
                                          | NV_OVERLAY_RUN_IN_DD
                                          )));

    //
    // If we use the user clipping, transfer it to desktop relative space
    //
    if (MergeBlitData.dwAction & NV_OVERLAY_USE_CLIPRECT)
    {
        // NOTE: User cliping in pMergeInfo is client relative!
        MergeBlitData.rclUser.x0 = pMergeInfo->x;
        MergeBlitData.rclUser.y0 = pMergeInfo->y;
        MergeBlitData.rclUser.x1 = pMergeInfo->x + pMergeInfo->width;
        MergeBlitData.rclUser.y1 = pMergeInfo->y + pMergeInfo->height;

        OglTranslateClientRelativeRectListToDevice(ppdev,
                                                   (RECTL *)&MergeBlitData.rclUser, 1,
                                                   (RECTL *)&MergeBlitData.rclUser, &ulTemp,
                                                   (RECTL *)&(clientDrawableInfo->rect));
        ASSERT(1==ulTemp);
    }

    if (   (NULL==cmdInfo)                                   // this happens if're called from inside display driver
        || (MergeBlitData.dwAction & NV_OVERLAY_RUN_IN_DD) ) // this happens if we want to run in the display driver channel
    {
        // this is a merge blit which has to happen in the display driver!
        // DD channel

        bOglSwapMergeBlit(ppdev,
                          &MergeBlitData);
    }
    else
    {
        // Call into the shared library to do the merge blit.
        // ICD channel
        cmdInfo->ntClientInfo = clientInfo;
        ASSERT(bOglHasDrawableInfo(cmdInfo->ntClientInfo));

        __glNVSetupMergeBlit(cmdInfo,
                             &MergeBlitData);
    }

    //
    // This sync here fixes most of the Softimage problems (preview, texture selectio box...)
    //
    ppdev->pfnAcquireOglMutex(ppdev);
    ppdev->pfnWaitForChannelSwitch(ppdev);
    ppdev->pfnWaitEngineBusy(ppdev);
    ppdev->pfnReleaseOglMutex(ppdev);

    EngFreeMem(prclWindowClipList);
    pMergeInfo->retStatus = OGL_ERROR_NO_ERROR;

    ulRet = TRUE;
Exit:
    return (ulRet);
}

#endif // (NVARCH >= 0x4)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\paint.c ===
//*****************************Module*Header********************************
// 
// Module Name: paint.c
// 
// Copyright (c) 1992-1996 Microsoft Corporation
// 
//*************************************************************************/

/**************************************************************************
 *                                                                        *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.          *
 *                                                                        *
 **************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = gaMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    ROP4 rop4;


    rop4 = ((MIX) gaMix[mix >> 8] << 8) | gaMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

#if 0 // NOTE: needs to be enabled if it doesn't longer call DrvBitBlt!
    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowRect(ppdev,pso,NULL,pco);        
    }
#endif

        
    return(DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                     NULL, pbo, pptlBrush, rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglsurf.c ===
/******************************Module*Header*******************************\
* Module Name: oglsurf.c
*
* Single-back-depth surface API.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "nv32.h"
#include "nv1c_ref.h"
#include "nvalpha.h"
#include "nvsubch.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglutils.h"
#include "rectUtils.h"
#include "oglstereo.h"
#include "ogloverlay.h"
#include "oglflip.h"
#include "oglsync.h"

#if DBG
#define OglDebugPrint OglDebugPrintFunc
#else
#define OglDebugPrint
#endif

//******************************************************************************
//
//  Function: OglAllocOverlaySurfaces
//
//  Routine Description:
//            Allocate 4 auxiliary overlay surfaces for opengl pseudo
//            hardware implementation of overlay planes
//
//  Arguments:
//
//  Return Value:
//            TRUE if succeeds
//
//
//******************************************************************************
static int
OglAllocOverlaySurfaces(
    PDEV  *ppdev,
    ULONG  ulView
)
{
    RBRUSH_COLOR  rbc  = {0};    // solid colour brush
    RECTL         rclScreen;
    int   iRet   = FALSE;
    DWORD   dwStatus;

    //__asm int 3;
    // Alloc front main surface

    rbc.iSolidColor = ICD_PALETTE_TRANSPARENT_COLOR | 0xFF000000;


    // at this time we don't support real stereo-overlay
    ASSERT( OGL_STEREO_BUFFER_LEFT == ulView );
    ASSERT( NULL != ppdev );

    // desktop extend to clear overlaybuffers after creation
    rclScreen.left   = 0;
    rclScreen.top    = 0;
    rclScreen.right  = ppdev->cxScreen;
    rclScreen.bottom = ppdev->cyScreen;

    ppdev->singleFrontMainOffset[ulView] = 0;
    ppdev->singleFrontMainPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
    NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleFrontMainOffset[ulView], (DWORD)ppdev->singleFrontMainPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);

    if (dwStatus!=0)
    {
        ppdev->singleFrontMainPitch[ulView] = 0;
        goto Exit; // failure
    }

    // Alloc back main surface
    ppdev->singleBack1MainOffset[ulView] = 0;
    ppdev->singleBack1MainPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
    NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleBack1MainOffset[ulView], (DWORD)ppdev->singleBack1MainPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);

    if (dwStatus!=0)
    {
        ppdev->singleBack1MainPitch[ulView] = 0;
        goto Exit; // failure
    }

    // Alloc front overlay surface
    ppdev->singleFrontOverlayOffset[ulView] = 0;
    ppdev->singleFrontOverlayPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
    NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleFrontOverlayOffset[ulView], (DWORD)ppdev->singleFrontOverlayPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);

    if (dwStatus!=0)
    {
        ppdev->singleFrontOverlayPitch[ulView] = 0;
        goto Exit; // failure
    }

    // Alloc back overlay surface
    ppdev->singleBack1OverlayOffset[ulView] = 0;
    ppdev->singleBack1OverlayPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
    NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleBack1OverlayOffset[ulView], (DWORD)ppdev->singleBack1OverlayPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);

    if (dwStatus!=0)
    {
        ppdev->singleBack1OverlayPitch[ulView] = 0;
        goto Exit; // failure
    }


    ppdev->pfnAcquireOglMutex(ppdev);
    ppdev->NVFreeCount = 0;
    //**********************************************************************
    // We need to make absolutely sure that the Channel switch
    // from the DMA pusher to the PIO channel has been completed
    //**********************************************************************
    ppdev->pfnWaitForChannelSwitch(ppdev);

    // clear overlay front and back with default transparent color
    ppdev->pfnSetDestBase(ppdev, ppdev->singleFrontOverlayOffset[ulView], ppdev->singleFrontOverlayPitch[ulView] );
    NV4DmaPushFillSolid( ppdev, 1, &rclScreen, 0xF0F0, rbc, NULL);
    ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1OverlayOffset[ulView], ppdev->singleBack1OverlayPitch[ulView] );
    NV4DmaPushFillSolid( ppdev, 1, &rclScreen, 0xF0F0, rbc, NULL);

    ppdev->pfnReleaseOglMutex(ppdev);

    iRet = TRUE;

Exit:

    return iRet;
}

//******************************************************************************
//
//  Function: OglAllocUnifiedSurfaces
//
//  Routine Description:
//            Allocate the single-back-depth buffer that is the size of the
//            display for OpenGL to use.
//            Also allocates the overlay front/back (main/overlay) surfaces
//             for OpenGL pseudo hardware overlay support.
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************
int
OglAllocUnifiedSurfaces(
    PDEV *ppdev,
    __GLNVsbdFlags *sbdFlags
)
{
    int iRet = FALSE;
    DWORD dwStatus;


    if (!ppdev->bOglSingleBackDepthSupported)
    {
        goto Exit;
    }

    // our intension is to allocate all buffers which may be allocated according to the exported
    // pixelformats at the FIRST time an allocation is done, to not run out of offscreen memory e.g.
    // if 1st ICD consumes a lot of it for textures and 2nd ICD wants more UBB buffers than 1st one.
    if (ppdev->bOglSingleBackDepthCreated == FALSE)
    {
        ULONG ulDesiredViews = 0;
        ULONG ulView ;

        ASSERT(FALSE==ppdev->bOglOverlaySurfacesCreated);

        bMoveAllDfbsFromOffscreenToDibs(ppdev);

        // if we export stereo pixelformat, allocate the buffer for it
        if( ppdev->bOglStereoDesired )
            ulDesiredViews = 2;
        else
            ulDesiredViews = 1;


        for( ulView = 0; ulView<ulDesiredViews; ulView++ )
        {
            DWORD depthType;

            // primary is allocated by DD, only handle other front buffers.
            if( ulView > 0 )
            {
                // allocate right front buffer
                ppdev->singleFrontOffset[ulView] = 0;
                ppdev->singleFrontPitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleFrontOffset[ulView], (DWORD)ppdev->singleFrontPitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);
                if (dwStatus!=0)
                    goto Exit;  // failure
            }

            // allocate back buffer
            ppdev->singleBack1Offset[ulView] = 0;
            ppdev->singleBack1Pitch[ulView]  = (ppdev->lDelta + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleBack1Offset[ulView], (DWORD)ppdev->singleBack1Pitch[ulView], (DWORD)ppdev->cyScreen, TYPE_IMAGE);
            if (dwStatus!=0)
                goto Exit;  // failure

            // TODO: allocate back buffer 2 for triple buffering.

            // allocate depth buffer
            ppdev->singleDepthOffset[ulView] = 0;
            ppdev->singleDepthPitch[ulView] = ppdev->singleBack1Pitch[ulView];
            if (sbdFlags->depthCompressed) {
                switch (ppdev->cjPelSize) {
                case 2:
                    depthType = TYPE_DEPTH_COMPR16;
                    break;
                case 4:
                    depthType = TYPE_DEPTH_COMPR32;
                    break;
                default:
                    depthType = TYPE_DEPTH;
                    break;
                }
            } else {
                depthType = TYPE_DEPTH;
            }
            NVHEAP_ALLOC_TILED(dwStatus,ppdev->singleDepthOffset[ulView], (DWORD)ppdev->singleDepthPitch[ulView], (DWORD)ppdev->cyScreen, depthType);
            if (dwStatus!=0)
                goto Exit;

            ppdev->bOglSingleBackDepthCreated = TRUE;
    
            // allocate Overlay surfaces
            if (ppdev->bOglOverlayDesired)
            {
                if(FALSE == OglAllocOverlaySurfaces(ppdev,ulView)) 
                {
                    goto Exit;
                } 
                else 
                {
                    ppdev->bOglOverlaySurfacesCreated = TRUE;
                }
            }

        }//for( ulView = 0; ulView<ulDesiredViews; ulView++ )

        ppdev->ulOglActiveViews = ulDesiredViews;

        // Try to enable pageflipping for that client
        bOglStereoModeUpdate(ppdev);
        bOglOverlayModeUpdate(ppdev);
        bOglPageFlipModeUpdate(ppdev);
    }

    iRet = TRUE;// success

Exit:

    if( FALSE == iRet )
    {
        OglFreeUnifiedSurfaces(ppdev);
    }

    return iRet; 
}

//******************************************************************************
//
//  Function: OglFreeUnifiedSurfaces
//
//  Routine Description:
//            Free a previously allocated single-back-depth buffer that is the size of the
//            display for OpenGL to use.
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//  MSchwarzer  10/09/2000: now we're freeing all surfaces whose offset is not 0
//
//******************************************************************************
int
OglFreeUnifiedSurfaces(
    PDEV *ppdev
)
{
    ULONG ulView;

    // Try to enable pageflipping for that client
    bOglPageFlipModeDisableAll(ppdev);
    bOglOverlayModeDisable(ppdev);
    bOglStereoModeDisable(ppdev);

    NV_DisableDoubleBufferMode(ppdev);
    
    for( ulView=0; ulView < ppdev->ulOglActiveViews; ulView++ )
    {
        // primary is allocated by DD, only handle other front buffers.
        if( ulView > OGL_STEREO_BUFFER_LEFT )
        {   
            if(ppdev->singleFrontOffset[ulView]) 
            {
                NVHEAP_FREE(ppdev->singleFrontOffset[ulView]);
            }
            ppdev->singleFrontOffset[ulView] = 0;
            ppdev->singleFrontPitch[ulView]  = 0;
        }

        if(ppdev->singleBack1Offset[ulView]) 
            NVHEAP_FREE(ppdev->singleBack1Offset[ulView]);
        ppdev->singleBack1Offset[ulView] = 0;
        ppdev->singleBack1Pitch[ulView]  = 0;

        if(ppdev->singleDepthOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleDepthOffset[ulView]);
        ppdev->singleDepthOffset[ulView] = 0;
        ppdev->singleDepthPitch[ulView]  = 0;

        // overlay buffers
        if(ppdev->singleFrontMainOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleFrontMainOffset[ulView]);
        ppdev->singleFrontMainOffset[ulView] = 0;
        ppdev->singleFrontMainPitch[ulView]  = 0;

        if(ppdev->singleFrontOverlayOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleFrontOverlayOffset[ulView]);
        ppdev->singleFrontOverlayOffset[ulView] = 0;
        ppdev->singleFrontOverlayPitch[ulView]  = 0;

        if(ppdev->singleBack1MainOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleBack1MainOffset[ulView]);
        ppdev->singleBack1MainOffset[ulView] = 0;
        ppdev->singleBack1MainPitch[ulView]  = 0;

        if(ppdev->singleBack1OverlayOffset[ulView]) 
            NVHEAP_FREE(ppdev->singleBack1OverlayOffset[ulView]);
        ppdev->singleBack1OverlayOffset[ulView] = 0;
        ppdev->singleBack1OverlayPitch[ulView]  = 0;

    }

    ppdev->bOglSingleBackDepthCreated = FALSE;
    ppdev->bOglOverlaySurfacesCreated = FALSE;
    ppdev->ulOglActiveViews           = 0;

    return 1;
}

NvU32 
OglGetUnifiedSurfaceInfo(
    PDEV *ppdev, 
    __GLNVsbdFlags *sbdFlags
)
{
    if (ppdev->bOglSingleBackDepthSupported &&
        ppdev->bOglSingleBackDepthCreated) {
            switch (sbdFlags->surfaceInfoType) {
                case SBD_BACK_1_OFFSET:
                    return ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_PITCH:
                    return ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_LEFT];
                case SBD_DEPTH_OFFSET:
                    return ppdev->singleDepthOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_DEPTH_PITCH:
                    return ppdev->singleDepthPitch[OGL_STEREO_BUFFER_LEFT];
                
                // Overlays
                case SBD_FRONT_MAIN_OFFSET:
                    return ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_FRONT_MAIN_PITCH:
                    return ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_MAIN_OFFSET:
                    return ppdev->singleBack1MainOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_MAIN_PITCH:
                    return ppdev->singleBack1MainPitch[OGL_STEREO_BUFFER_LEFT];
                case SBD_FRONT_OVERLAY_OFFSET:
                    return ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_FRONT_OVERLAY_PITCH:
                    return ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_OVERLAY_OFFSET:
                    return ppdev->singleBack1OverlayOffset[OGL_STEREO_BUFFER_LEFT];
                case SBD_BACK_1_OVERLAY_PITCH:
                    return ppdev->singleBack1OverlayPitch[OGL_STEREO_BUFFER_LEFT];

                // ogl api stereo buffers
                case SBD_FRONT_RIGHT_OFFSET:
                    return ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_FRONT_RIGHT_PITCH:
                    return ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_RIGHT_OFFSET:
                    return ppdev->singleBack1Offset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_RIGHT_PITCH:
                    return ppdev->singleBack1Pitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_DEPTH_RIGHT_OFFSET:
                    return ppdev->singleDepthOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_DEPTH_RIGHT_PITCH:
                    return ppdev->singleDepthPitch[OGL_STEREO_BUFFER_RIGHT];
                
                // Overlays
                case SBD_FRONT_MAIN_RIGHT_OFFSET:
                    return ppdev->singleFrontMainOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_FRONT_MAIN_RIGHT_PITCH:
                    return ppdev->singleFrontMainPitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_MAIN_RIGHT_OFFSET:
                    return ppdev->singleBack1MainOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_MAIN_RIGHT_PITCH:
                    return ppdev->singleBack1MainPitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_FRONT_OVERLAY_RIGHT_OFFSET:
                    return ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_FRONT_OVERLAY_RIGHT_PITCH:
                    return ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_OVERLAY_RIGHT_OFFSET:
                    return ppdev->singleBack1OverlayOffset[OGL_STEREO_BUFFER_RIGHT];
                case SBD_BACK_1_OVERLAY_RIGHT_PITCH:
                    return ppdev->singleBack1OverlayPitch[OGL_STEREO_BUFFER_RIGHT];

                default:
                    ASSERTDD(0,"Invalid surface info type");
                    return FALSE;
            }
    }
    return FALSE;
}

/*
**  bExchangeClientsFrontAndBack
**
**  Swaps the contents of fullscreen front and backbuffer of
**  complete opengl client area (clipped against screen).
**  It uses a temporary buffer to do its work. 
**
**  return: TRUE  - buffers copied + flipped to primary
**          FALSE - if no buffers copied ( e.g. no UBB-mode ), not flipped to primary
**
**  10/16/2000 MSchwarzer: new
*/
BOOL bExchangeClientsFrontAndBack( PPDEV ppdev, NV_OPENGL_DRAWABLE_INFO *pClientDrawableInfo)
{
    BOOL bBufferExchanged = FALSE;

    ASSERT(ppdev);
    ASSERT(pClientDrawableInfo);


    if(  (ppdev->bOglSingleBackDepthSupported)
       &&( ppdev->bOglSingleBackDepthCreated)
      )
    {
        RECTL rclSrc;
        RECTL rclScreen;

        vRclCopy(&rclSrc,(RECTL*)(&pClientDrawableInfo->rect));

        // convert to screen relative coords
        vRclSubOffset(&rclSrc,&rclSrc,ppdev->left,ppdev->top);

        // set up primary ccordinates
        rclScreen.left   = 0;
        rclScreen.right  = ppdev->cxScreen;
        rclScreen.top    = 0;
        rclScreen.bottom = ppdev->cyScreen;

        // clip clientrect against screen and check if its a empty rect
        if(   (bRclIntersect(&rclSrc,&rclScreen,&rclSrc))
            &&(!bRclIsEmpty(&rclSrc))
           )
        {
            ULONG  ulTempBufferOffset         = 0;
            ULONG  ulTempBufferSize           = 0;
            LONG   lTempBufferStride          = 0;
            BOOL   bAllocatedTempBufferOnHeap = FALSE;
            BOOL   bCopyAtOnce                = FALSE;
            RECTL  rclClipScreen;
            RECTL  rclClipTmpBuffer;
            POINTL ptlSrcScreen;
            POINTL ptlSrcTmpBuffer;
            LONG   lRow;
            LONG   cy;
            DWORD  dwStatus;

            // 32 BYTE- align !
            lTempBufferStride = (( ppdev->cjPelSize * lRclWidth(&rclSrc) ) + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

            ulTempBufferSize = lTempBufferStride * lRclHeight(&rclSrc);

            if( ulTempBufferSize > ppdev->ulTempOffscreenBufferSize )
            {
                NVHEAP_ALLOC(dwStatus, ulTempBufferOffset,  ulTempBufferSize, TYPE_IMAGE)
                if( dwStatus == 0 )
                {
                    bAllocatedTempBufferOnHeap = TRUE;
                    bCopyAtOnce                = TRUE;
                }
            }

            if(!bAllocatedTempBufferOnHeap)
            {
                ASSERT(0 != ppdev->ulTempOffscreenBufferSize);

                if( ulTempBufferSize <= ppdev->ulTempOffscreenBufferSize )
                    bCopyAtOnce = TRUE;

                ulTempBufferSize   = ppdev->ulTempOffscreenBufferSize;
                ulTempBufferOffset = ppdev->ulTempOffscreenBufferOffset;
            }

            // constant values
            ptlSrcTmpBuffer.x = 0;
            ptlSrcTmpBuffer.y = 0;

            // we may have to copy the clientrect via several blockcopies
            cy    = ulTempBufferSize / lTempBufferStride;

            ptlSrcScreen.x = rclSrc.left;
            ptlSrcScreen.y = rclSrc.top;

            rclClipScreen.left   = rclSrc.left;
            rclClipScreen.right  = rclSrc.right;
            rclClipScreen.top    = rclSrc.top;
            rclClipScreen.bottom = rclSrc.top+cy;
           
            rclClipTmpBuffer.left   = 0;
            rclClipTmpBuffer.right  = lRclWidth(&rclSrc);
            rclClipTmpBuffer.top    = 0;
            rclClipTmpBuffer.bottom = cy;

            // loop once for each block ( height/(cy+1) ) but last block
            // may not occupy full tempbuffer 
            for ( lRow=(lRclHeight(&rclSrc)+cy-1)/cy; lRow>0; lRow-- )
            {
                // copy backbuffercontents to tempbuffer
                ppdev->pfnSetSourceBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
                ppdev->pfnSetDestBase(ppdev, ulTempBufferOffset, lTempBufferStride);
                ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                    (ppdev, 1, &rclClipTmpBuffer, 0xcccc, &ptlSrcScreen, &rclClipTmpBuffer, NULL);

                // copy frontbuffercontents to primary
                ppdev->pfnSetSourceBase(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT], ppdev->lDelta);
                ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
                ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                    (ppdev, 1, &rclClipScreen, 0xcccc, &ptlSrcScreen, &rclClipScreen, NULL);

                //flip to primary if offscreen bitmap was big enough for complete clientarea
                if( bCopyAtOnce )
                    NvRestoreDacs(ppdev);

                // copy tempbuffercontents to backbuffer
                ppdev->pfnSetSourceBase(ppdev, ulTempBufferOffset, lTempBufferStride);
                ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT], ppdev->lDelta);
                ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                    (ppdev, 1, &rclClipScreen, 0xcccc, &ptlSrcTmpBuffer, &rclClipScreen, NULL);

                ptlSrcScreen.y       += cy;
                rclClipScreen.top    += cy;
                rclClipScreen.bottom += cy;                

                // next row is last row which may be smaller than others
                if(  (2==lRow)
                   &&(rclClipScreen.bottom > rclSrc.bottom)
                  )
                {
                    rclClipTmpBuffer.bottom = cy - (rclClipScreen.bottom - rclSrc.bottom);
                    rclClipScreen.bottom    = rclSrc.bottom;
                }
            }

            ppdev->pfnWaitEngineBusy(ppdev);

            if(bAllocatedTempBufferOnHeap)
                NVHEAP_FREE(ulTempBufferOffset);

            bBufferExchanged = TRUE;

            // flip to primary here if we could not copy the clientarea at once
            if (!bCopyAtOnce)
                NvRestoreDacs(ppdev);
        }

    }

    return bBufferExchanged;
}


//*************************************************************************
// vOglFlipChangedUpdate
// 
// Run through client list and set notification that primary flipped. 
// This is done for all clients except the given one.
// The exclusion can be used to update all clients that this one has 
// flipped.
//*************************************************************************
VOID vOglFlipChangedUpdate(
    IN PPDEV                  ppdev, 
    IN NV_OPENGL_CLIENT_INFO *clientInfo) // exclude this client from update, can be NULL
{
    NV_OPENGL_CLIENT_INFO_LIST *node = NULL;

    node = globalOpenGLData.oglClientListHead.clientList;
    while (node)
    {
        if (   (NULL != node->clientInfo.clientDrawableInfo)
            && (&node->clientInfo != clientInfo) )
        {
            ASSERT(node->clientInfo.flags & NV_OGL_CLIENT_DRAWABLE_INFO);
            // flipping address has changed, notify ICD
            node->clientInfo.clientDrawableInfo->flipChangedCount++;
            // the client stopped with flipping now
            node->clientInfo.clientDrawableInfo->bFlipping = FALSE;
            break;
        }
        node = node->next;
    }
}


/*
**  vFlipToPrimary
**
**  Swaps the contents of fullscreen front and backbuffer
**  if there are any visible opengl windows and sets the 
**  dac to the primary
**
**  10/17/2000 MSchwarzer: new
**  01/16/2001           : function does a fullscreen swap now
*/
VOID vFlipToPrimary(PPDEV ppdev)
{
    BOOL bFlippedToPrimary = FALSE;

    ASSERT(ppdev);
    ASSERT(OGL_FLIPPED());

    DISPDBG((3, "vFlipToPrimary"));
    
    OglSyncEngineUsingPDEV(ppdev);

    if(  ( ppdev->bOglSingleBackDepthSupported )
       &&( ppdev->bOglSingleBackDepthCreated )
      )
    {
        ULONG  ulTempBufferOffset         = 0;
        ULONG  ulTempBufferSize           = 0;
        BOOL   bCopyAtOnce                = FALSE;
        BOOL   bAllocatedTempBufferOnHeap = FALSE;
        RECTL  rclClipScreen;
        RECTL  rclClipTmpBuffer;
        POINTL ptlSrcScreen;
        POINTL ptlSrcTmpBuffer;
        LONG   lRow;
        LONG   cy;
        DWORD  dwStatus;

        DISPDBG((3, "vFlipToPrimary: exchange buffers"));

        // try to get a full screensize temporary buffer
        ulTempBufferSize  = ppdev->lDelta * ppdev->cyScreen;

        if( ulTempBufferSize > ppdev->ulTempOffscreenBufferSize )
        {
            NVHEAP_ALLOC(dwStatus, ulTempBufferOffset,  ulTempBufferSize, TYPE_IMAGE)
            if( 0 == dwStatus ) // success
            {
                bAllocatedTempBufferOnHeap = TRUE;
                bCopyAtOnce                = TRUE;
            }
        }

        if(!bAllocatedTempBufferOnHeap)
        {
            // not enough room in offscreen to copy at once => copy line by line
            ASSERT(0 != ppdev->ulTempOffscreenBufferSize);
            if( 0 == ppdev->ulTempOffscreenBufferSize )
                goto Exit;

            if( ulTempBufferSize <= ppdev->ulTempOffscreenBufferSize )
                bCopyAtOnce = TRUE;

            ulTempBufferSize   = ppdev->ulTempOffscreenBufferSize;
            ulTempBufferOffset = ppdev->ulTempOffscreenBufferOffset;
        }

        // constant values
        ptlSrcTmpBuffer.x = 0;
        ptlSrcTmpBuffer.y = 0;

        // we may have to copy the clientrect via several blockcopies
        cy    = ulTempBufferSize / ppdev->lDelta;

        ptlSrcScreen.x = 0;
        ptlSrcScreen.y = 0;

        rclClipScreen.left   = 0;
        rclClipScreen.right  = ppdev->cxScreen;
        rclClipScreen.top    = 0;
        rclClipScreen.bottom = cy;
       
        rclClipTmpBuffer     = rclClipScreen;

        // loop once for each block ( height/(cy+1) ) but last block
        // may not occupy full tempbuffer 
        for ( lRow=(ppdev->cyScreen+cy-1)/cy; lRow>0; lRow-- )
        {
            // copy backbuffercontents to tempbuffer
            ppdev->pfnSetSourceBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
            ppdev->pfnSetDestBase(ppdev, ulTempBufferOffset, ppdev->lDelta);
            ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                (ppdev, 1, &rclClipTmpBuffer, 0xcccc, &ptlSrcScreen, &rclClipTmpBuffer, NULL);

            // copy frontbuffercontents to primary
            ppdev->pfnSetSourceBase(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT], ppdev->lDelta);
            ppdev->pfnSetDestBase(ppdev, ppdev->ulPrimarySurfaceOffset, ppdev->lDelta);
            ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                (ppdev, 1, &rclClipScreen, 0xcccc, &ptlSrcScreen, &rclClipScreen, NULL);

            //flip to primary if offscreen bitmap was big enough for complete clientarea
            if( bCopyAtOnce )
            {
                NvRestoreDacs(ppdev);
                bFlippedToPrimary = TRUE;
            }

            // copy tempbuffercontents to backbuffer
            ppdev->pfnSetSourceBase(ppdev, ulTempBufferOffset, ppdev->lDelta);
            ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1Offset[OGL_STEREO_BUFFER_LEFT], ppdev->lDelta);
            ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt
                (ppdev, 1, &rclClipScreen, 0xcccc, &ptlSrcTmpBuffer, &rclClipScreen, NULL);

            ptlSrcScreen.y       += cy;
            rclClipScreen.top    += cy;
            rclClipScreen.bottom += cy;                

            // next row is last row which may be smaller than others
            if(  (2==lRow)
               &&(rclClipScreen.bottom > ppdev->cyScreen)
              )
            {
                rclClipTmpBuffer.bottom = cy - (rclClipScreen.bottom - ppdev->cyScreen);
                rclClipScreen.bottom    = ppdev->cyScreen;
            }
        }

        ppdev->pfnWaitEngineBusy(ppdev);

        if(bAllocatedTempBufferOnHeap)
            NVHEAP_FREE(ulTempBufferOffset);
    }

Exit:

    if( !bFlippedToPrimary )
    {
        // Restore if necessary!
        NvRestoreDacs(ppdev);
    }

    vOglFlipChangedUpdate(ppdev, NULL);

    ASSERT(!OGL_FLIPPED());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglutils.h ===
#ifndef __OGLUTILS_H
#define __OGLUTILS_H

/*
**
** MODULE: oglutils.h
**
** little opengl helper functions should reside here
**
** Copyright (C) 2000 NVidia Corporation. All Rights Reserved.
**
*/

void __cdecl NV_OglDDrawSurfaceCreated(PDEV *);
void __cdecl NV_OglDDrawSurfaceDestroyed(PDEV *);
BOOL  bOglDirectDrawAppRunning(PPDEV);
BOOL  bOglPOWERlibAppRunning(PPDEV);
BOOL  bOglIsVisibleClient(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglIsUnclippedClient(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglIsFullscreenClient(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglIsComplexClippedClient(PPDEV ppdev, struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglHasDrawableInfo(struct _NV_OPENGL_CLIENT_INFO *clientInfo);
BOOL  bOglGetNextClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
BOOL  bOglGetNextVisibleClient(struct _NV_OPENGL_CLIENT_INFO **ppClientInfo);
ULONG cOglVisibleClients(PPDEV ppdev);
ULONG cOglWindows(PPDEV ppdev);

void CreateOglGlobalMemory(PDEV *);
void DestroyOglGlobalMemory(PDEV *);
void OglDisableModeSwitchUpdate(PDEV *);
void OglEnableModeSwitchUpdate(PDEV *);
BOOL OglLockDownMemory(PDEV *, ULONG);
BOOL OglUnlockMemory(PDEV *ppdev);

BOOL bOglServicesInit(PPDEV ppdev);
BOOL bOglServicesDisable(PPDEV ppdev);
BOOL bOglAssertMode(PPDEV ppdev, BOOL bEnable);
BOOL bOglResetPDEV(PPDEV ppdevOld, PPDEV ppdevNew);

#ifdef NV_MAIN_MULTIMON
void OglInitPDEVList(void);
void OglDestroyPDEVList(void);
BOOL OglClientIntersectsDevice(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo);
void OglSyncEngineUsingPDEV(PDEV *ppdev);
void OglAddPDEVToList(PDEV *ppdev);
void OglRemovePDEVFromList(PDEV *ppdev);

BOOL bOglGetNextPdev( IN OUT PPDEV* pppdev );
BOOL bOglRetrieveValidPDEVForDevice( IN OUT PPDEV* pppdev, IN ULONG ulDeviceNumber );
BOOL bOglRetrieveValidPDEVForOrigin( IN OUT PPDEV* pppdev, IN LONG lLeft, IN LONG lTop );
#endif

DWORD GetCurrentProcessID(VOID);
#endif //#ifndef __OGLUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\oglutils.c ===
//*****************************Module*Header*******************************
// Module Name: oglutils.c
//
// all little opengl helperfunctions should reside here
// Copyright (c) 2000 NVidia Corporation
//*************************************************************************

#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"
#include "oglDD.h"
#include "oglflip.h"
#include "nvdoublebuf.h"
#include "oglstereo.h"
#include "ogloverlay.h"
#include "cliplist.h"
#include "pixelfmt.h"
#include "oglclip.h"
#include "Nvcm.h"
#include "nvReg.h"
#ifdef NV_MAIN_MULTIMON
#include "oglutils.h"
#include "linkedlist.h"
#endif

#ifdef NVD3D
    #include "dx95type.h"
    #include "ddmini.h"
#endif  


//
// export
//
#include "oglutils.h"

GLOBAL_OPENGL_DATA globalOpenGLData = { NULL, 0, 0, 0 };
ULONG globalOpenGLMutex = 0;
ULONG globalOpenGLMutexCount = 0;

//*************************************************************************
// For details regarding NV_OglDDrawSurfaceCreated/Destroyed, please see
// the comment in oglDD.h regarding OGL_MAX_DDRAW_SURFACES_FOR_FLIPPING
//*************************************************************************
#if !i386 || _WIN32_WINNT >= 0x0500
typedef HANDLE (*P_PS_GET_CURRENT_PROCESS_ID)(void);
#endif

#pragma warning(disable: 4035)  // no return value
DWORD GetCurrentProcessID(VOID)
{
#if i386 && _WIN32_WINNT >= 0x0400
    __asm
    {
        mov eax, fs:[0x18]
        mov eax, [eax + 0x20] // return value in eax
    }
#else
    HANDLE hPID = NULL;
    HANDLE hDLL;

    hDLL = EngLoadImage(L"NTOSKRNL.EXE");
    if (hDLL)
    {
        P_PS_GET_CURRENT_PROCESS_ID pfPsGetCurrentProcessId;

        pfPsGetCurrentProcessId = (P_PS_GET_CURRENT_PROCESS_ID)EngFindImageProcAddress(hDLL, "PsGetCurrentProcessId");
        if (pfPsGetCurrentProcessId)
        {
            // does NOT work in FREE mode
            hPID = pfPsGetCurrentProcessId();
        }
        EngUnloadImage(hDLL);
    }
    return (DWORD)((DWORD_PTR)hPID);
#endif
}
#pragma warning(default: 4035)  // no return value



//*************************************************************************
// bAddProcessIDToDDrawCounterList
//
// Function removes all stored ProcessId's belonging to an 
// ICD app from list. Then Adds a given ProcessID to 
// DDrawCounterList in ppdev if it does not belong to an ICD.
//
// returns TRUE  if ProcessID was successfully added to list( came from DDraw app )
//         FALSE if ProcessID belongs to ICD app or if there was no space left in list
//
//*************************************************************************
BOOL bAddProcessIDToDDrawCounterList( PPDEV ppdev, ULONG ulProcessID )
{
    NV_OPENGL_CLIENT_INFO *pClientInfo     = NULL;
    BOOL                   bRet            = FALSE;
    BOOL                   bIsICDProcessID = FALSE;

    ASSERT(ppdev);

    while( bOglGetNextClient(&pClientInfo) )
    {
        if( pClientInfo->dwProcessID == ulProcessID )
        {
            bIsICDProcessID = TRUE;
        }

        // remove processid from list if it belongs to an ICD
        while(bRemovePointerFromList( &ppdev->oglDDrawSurfaceCountList, (PULONG)((ULONG_PTR)pClientInfo->dwProcessID)) )
        {
            // remove each stored link to this ICD client
            ;
        }
    }
    // now all ProcessID's belonging to an ICD-app should have been removed from list

    // add given ProcesId to DDrawSurfaceCountList if it does not belong to an ICD
    if( !bIsICDProcessID )
    {
        if(!bAddPointerToList( &ppdev->oglDDrawSurfaceCountList, (PULONG)((ULONG_PTR)ulProcessID)))
        {
            DISPDBG((0,"bAddProcessIDToDDrawCounterList: no space left for ProcessIDCount"));
            goto Exit;
        }

        // added ProcessID to list => ID call came from DDraw app
        bRet = TRUE;
    }
    // now number of saved ProcessID's is number of DDrawappps

Exit:

    return bRet;
}

//*************************************************************************
// bRemoveProcessIDFromDDrawCounterList
//
// Function removes all given ProcessId from list. 
// If ProcessID is not in list and does not belong
// to an ICD Client, then complete list is erased
// because this case indicates us that winlogon.exe
// or csrss.exe or rundll32.exe called DisableAllDirectDrawObject
// to perform  a CTRL-ALT-DEL / Fullscreen DOS-Box 
// or a modeswitch.
//
// returns TRUE  if ProcessID was removed from list( came from DDraw app )
//         FALSE never at this point of implementation
//
//*************************************************************************
BOOL bRemoveProcessIDFromDDrawCounterList( PPDEV ppdev, ULONG ulProcessID )
{
    NV_OPENGL_CLIENT_INFO *pClientInfo     = NULL;
    BOOL                   bRet            = FALSE;
    BOOL                   bIsICDProcessID = FALSE;

    ASSERT(ppdev);

    // did ulProcessID reside in List ?
    if( !bRemovePointerFromList(&ppdev->oglDDrawSurfaceCountList,(PULONG)((ULONG_PTR)ulProcessID)) )
    {
        // check if ulProcessID belongs to an ICD app
        while( bOglGetNextClient(&pClientInfo) )
        {
            if( pClientInfo->dwProcessID == ulProcessID )
            {
                bIsICDProcessID = TRUE;
            }
        }

        if( bIsICDProcessID )
        {
            // an ICD apps is destroying its ddraw context => everything OK
            bRet = TRUE;
        }
        else
        {
            // if we reach this point, either winlogon.exe
            // or csrss.exe or rundll32.exe called DisableAllDirectDrawObject
            // => empty list
            bClearPointerList(&ppdev->oglDDrawSurfaceCountList);

            bRet = TRUE;
        }
    }
    else
    {
        bRet = TRUE;
    }

    return bRet;
}




//*************************************************************************
//  NV_OglDDrawSurfaceCreated
//
//  This function is called when a new DDraw/D3D surface may have been
//  created which may force us to switch off windowflipping.
//*************************************************************************

void __cdecl NV_OglDDrawSurfaceCreated(PDEV *ppdev)
{
    ASSERT(ppdev);

    if( (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC) )
    {
        // look ahead! function automatically removes all ICD processes from list
        // => update counter and PageFlipMode allways
        bAddProcessIDToDDrawCounterList(ppdev,GetCurrentProcessID());

        ppdev->oglDDrawSurfaceCount = ulGetNumberOfPointersInList(&ppdev->oglDDrawSurfaceCountList);
        bOglPageFlipModeUpdate(ppdev);
    }
}

//*************************************************************************
//  NV_OglDDrawSurfaceDestroyed
//
//  This function is called when a DDraw/D3D surface may have been destroyed
//  which may allow us to switch on windowflipping.
//*************************************************************************
void __cdecl NV_OglDDrawSurfaceDestroyed(PDEV *ppdev)
{
    ASSERT(ppdev);

    if( (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC) )
    {
        bRemoveProcessIDFromDDrawCounterList(ppdev,GetCurrentProcessID());
    
        ppdev->oglDDrawSurfaceCount = ulGetNumberOfPointersInList(&ppdev->oglDDrawSurfaceCountList);
        bOglPageFlipModeUpdate(ppdev);
    }
}


//*************************************************************************
// bOglDirectDrawAppRunning
// 
// Returns TRUE if from the OGLs perspective a concurring 
// directdraw or direct3d app is running.
//
// NOTE: After a modeswitch the complete counting is destroyed:
//       ppdev->pDriverData->DDrawVideoSurfaceCount goes to negative values
//       ppdev->oglDDrawSurfaceCount only has one count per ogl
//       ppdev->DDrawVideoSurfaceCount isn't used at all
//
//*************************************************************************
BOOL bOglDirectDrawAppRunning(PPDEV ppdev)
{
    return(ppdev->oglDDrawSurfaceCount > 0);

#pragma message("  MSchwarzer 12/12/2000:  look at this. Optimize for NT4!")
// W2K should work fine now
// On NT4 CTRL-ALT-DEL kill us because it releases all DDraw surfaces but does
// not realloc them :-((
// Fullscreen DOS-Box and Modeswitch works fine now
}


//*************************************************************************
// bOglPOWERlibAppRunning
// 
// Returns TRUE if from the OGLs perspective a concurring 
// POWERlib/POWERdraft is running.
//*************************************************************************
BOOL bOglPOWERlibAppRunning(PPDEV ppdev)
{
    return (FALSE);
}


//*************************************************************************
// bOglHasDrawableInfo
// returns TRUE if the given client has a clientDrawableInfo linked to it.
//*************************************************************************
BOOL bOglHasDrawableInfo(NV_OPENGL_CLIENT_INFO *clientInfo)
{
    if (clientInfo)
    {
        // Need a valid pointer to make my tests!
        ASSERT(OglFindClientListFromClientInfo(NULL, clientInfo));
        return (   (clientInfo->clientDrawableInfo)
                && (clientInfo->flags & NV_OGL_CLIENT_DRAWABLE_INFO) );
    }
    return (FALSE);
}


//*************************************************************************
// bOglIsVisibleClient
// returns TRUE if the client is visible.
//*************************************************************************
BOOL bOglIsVisibleClient(NV_OPENGL_CLIENT_INFO *clientInfo)
{
    return (   bOglHasDrawableInfo(clientInfo)
            && !bRclIsEmpty((RECTL *)&clientInfo->clientDrawableInfo->rect)
            && !(clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_OCCLUDED) );
}


//*************************************************************************
// bOglIsUnclippedClient
// returns TRUE if the client is visible and not clipped
//*************************************************************************
BOOL bOglIsUnclippedClient(NV_OPENGL_CLIENT_INFO *clientInfo)
{
    return (   bOglIsVisibleClient(clientInfo)
            && (   (clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_SINGLERECTANGLE)
                || (clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLYVISIBLE)
                || (clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLSCREEN) ) );
}


//*************************************************************************
// bOglIsFullscreenClient
// returns TRUE if the client is running in fullscreen mode
//*************************************************************************
BOOL bOglIsFullscreenClient(NV_OPENGL_CLIENT_INFO *clientInfo)
{
    return (   bOglIsVisibleClient(clientInfo)
            && (clientInfo->clientDrawableInfo->clipFlags & NV_WINDOW_CLIP_FULLSCREEN) );
}


//*************************************************************************
// bOglIsComplexClippedClient
// 
// returns TRUE if the client is complex clipped. Complex clipped does mean
// it has more clip rect than the hardware can process.
//*************************************************************************
BOOL bOglIsComplexClippedClient(
    IN PPDEV                  ppdev, 
    IN NV_OPENGL_CLIENT_INFO *clientInfo)
{
    BOOL bRet = FALSE; // no it isn't

    ASSERT(NULL!=ppdev);
    ASSERT(bOglHasDrawableInfo(clientInfo));

    if (    bOglIsVisibleClient(clientInfo)      // unvisible -> simple, occluded
         && !bOglIsUnclippedClient(clientInfo)   // unclipped -> simple
         && clientInfo->clientDrawableInfo->numClipRects > HWGFXCAPS_MAXCLIPS(ppdev))
    {
        // could do some checks if exclusive rects would help us,
        // but for now assume we are complex clipped.
        bRet = TRUE;
    }

    return (bRet);
}


//*************************************************************************
// bOglGetNextClient
//
// finds next OpenGL clientinfo that contains a drawable starting with 
// next client after *ppClientInfo or at top of list if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a client was found and returns a pointer to the 
//              clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextClient(
    IN OUT NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    BOOL                        bRet            = FALSE;
    NV_OPENGL_CLIENT_INFO_LIST *pClientInfoList;
    BOOL                        bSearchStart   ;

    pClientInfoList = globalOpenGLData.oglClientListHead.clientList;

    bSearchStart = (   (NULL != ppClientInfo)     // valid pointer
                    && (NULL != *ppClientInfo) ); // initialized for search?

    while (pClientInfoList)
    {
        if (bSearchStart)            
        {
            // need to find start of serach first.
            if (&pClientInfoList->clientInfo == *ppClientInfo)
            {
                // Stop search for head of list and start 
                // search for client with next element
                bSearchStart = FALSE;
            }

        }
        else if (bOglHasDrawableInfo(&pClientInfoList->clientInfo))
        {
            // if wanted return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = &pClientInfoList->clientInfo;
            }
                
            bRet = TRUE;
            break;
        }

        pClientInfoList = pClientInfoList->next;
    }

    return bRet;
}


//*************************************************************************
// bOglGetNextVisibleClient
//
// finds next visible OpenGL client starting with 
// next client after *ppClientInfo or at top of list if *ppClientInfo==NULL. 
//
// ppClientInfo == NULL: Only check if there is a client
// ppClientInfo != NULL: In addition return found client
//                       *ppClientInfo == NULL: Start search at top of 
//                                              client list
//                       *ppClientInfo != NULL: Start search with given 
//                                              client (not included)
// Returns TRUE if a visible client was found and returns a pointer to the 
//              clientInfo in *ppClientInfo if ppClientInfo!=NULL.
// Returns FALSE if client wasn't found, *ppClientInfo isn't touched!
//*************************************************************************
BOOL bOglGetNextVisibleClient(
    IN OUT NV_OPENGL_CLIENT_INFO **ppClientInfo)
{
    NV_OPENGL_CLIENT_INFO *clientInfo;
    BOOL                   bRet = FALSE;

    // use local copy to query bOglGetNextVisibleClient!
    if (NULL==ppClientInfo)
        clientInfo = NULL;
    else
        clientInfo = *ppClientInfo; // can be NULL!

    while (bOglGetNextClient(&clientInfo))
    {
        // found visible client, but is it a flip candiate, too?
        if (bOglIsVisibleClient(clientInfo))
        {
            // if wanted, return found client
            if (NULL != ppClientInfo) 
            {
                *ppClientInfo = clientInfo;
            }
            bRet = TRUE;
            break;
        }
    }

    return (bRet);
}


//*************************************************************************
// cOglVisibleClients
// 
// Returns number of visible opengl clients. 0==no client or all clients 
// occluded.
//*************************************************************************
ULONG cOglVisibleClients(PPDEV ppdev)
{
    BOOL                   bFound     = TRUE;
    ULONG                  ulRet      = 0;
    NV_OPENGL_CLIENT_INFO *clientInfo;

    ASSERT(NULL!=ppdev);

    clientInfo = NULL; // Start search at top of chained list

    while (bOglGetNextVisibleClient(&clientInfo))
    {
        ulRet++;
    }

    return (ulRet);
}


//*************************************************************************
// cOglWindows
// 
// Returns count of/number of OpenGL windows, drawables.
//*************************************************************************
ULONG cOglWindows(PPDEV ppdev)
{
    ULONG                 ulRet=0;
    NV_OPENGL_CLIENT_INFO *clientInfo = NULL;

    ASSERT(NULL!=ppdev);

    clientInfo = NULL;

    while (bOglGetNextClient(&clientInfo))
    {
        ulRet++;
    }

    ASSERT(0==ulRet || OglIsEnabled(ppdev));
    ASSERT(ulRet <= globalOpenGLData.oglClientCount);
    ASSERT(ulRet == globalOpenGLData.oglDrawableClientCount);

    return (ulRet);
}



//******************************************************************************
//
//  Function: CreateOglGlobalMemory
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************

void CreateOglGlobalMemory(
PDEV *ppdev)

    {
    NV_OPENGL_GLOBAL_DATA *nvGlobalData;

    ppdev->oglGlobalPageSize = PAGE_SIZE * BYTES_TO_PAGES(sizeof(ULONG));
    /* Since we are not guaranteed page aligned allocation,
     * we need to allocate an extra PAGE_SIZE - 1 memory and use
     * memory starting from next page. */
    ppdev->origOglGlobalPagePtr = ppdev->oglGlobalPagePtr =
        EngAllocMem(FL_ZERO_MEMORY, (ppdev->oglGlobalPageSize + PAGE_SIZE - 1), ALLOC_TAG);

    if (ppdev->oglGlobalPagePtr != NULL)
        {
        ppdev->oglGlobalPagePtr = PAGE_ALIGN_UP(ppdev->oglGlobalPagePtr);

        DISPDBG((8, "CreateOglGlobalMemory OGLGPPTR = 0x%p, OrigPtr = 0x%p",ppdev->oglGlobalPagePtr, ppdev->origOglGlobalPagePtr));

        if (OglLockDownMemory(ppdev, ppdev->oglGlobalPageSize) == FALSE)
            {
            // NO OpenGL acceleration...
            EngFreeMem(ppdev->origOglGlobalPagePtr);
            ppdev->oglGlobalPagePtr = NULL;
            ppdev->origOglGlobalPagePtr = NULL;
            ppdev->oglMutexPtr      = NULL;
            ppdev->oglModeSwitchPtr = NULL;
            ppdev->bReleaseOglMutex = 0;
            return;
            }
        }
    else
        {
        DISPDBG((2, "CreateOglGlobalMemory - Failed EngAllocMem"));
        }

    nvGlobalData = (NV_OPENGL_GLOBAL_DATA *)ppdev->oglGlobalPagePtr;
    if (nvGlobalData)
        {
        ppdev->oglMutexPtr      = &nvGlobalData->oglMutex;
        ppdev->oglModeSwitchPtr = &nvGlobalData->oglModeSwitch;
        }

    ppdev->bReleaseOglMutex = 0;

    ppdev->oglLastChannel = 0;
}

//******************************************************************************
//
//  Function: DestroyOglGlobalMemory
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//******************************************************************************
void DestroyOglGlobalMemory(
PDEV *ppdev)

    {
    if (ppdev->oglGlobalPageMdl)
        {
        OglUnlockMemory(ppdev);
        }
    ppdev->oglGlobalPageMdl = NULL;
    if ((ppdev->oglGlobalPagePtr) && (ppdev->origOglGlobalPagePtr))
        {
        EngFreeMem(ppdev->origOglGlobalPagePtr);
        }

    ppdev->oglGlobalPagePtr = NULL;
    ppdev->origOglGlobalPagePtr = NULL;
    ppdev->oglMutexPtr      = NULL;
    ppdev->oglModeSwitchPtr = NULL;
    ppdev->bReleaseOglMutex = 0;
}

//******************************************************************************
//
//  Function: OglDisableModeSwitchUpdate
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************

void OglDisableModeSwitchUpdate(
PDEV *ppdev)

    {
    int i;
    ppdev->dwGlobalModeSwitchCount = ppdev->dwGlobalModeSwitchCount + 2;
    ppdev->dwGlobalModeSwitchCount |= 0x1;
    if (ppdev->oglModeSwitchPtr) *ppdev->oglModeSwitchPtr = ppdev->dwGlobalModeSwitchCount;

    if (ppdev->bOglSingleBackDepthCreated ||
        ppdev->bOglOverlaySurfacesCreated)  
        {
        // Free single-back-depth - client side must recover this...
        OglFreeUnifiedSurfaces(ppdev);
        }
    } // end of OglDisableModeSwitchUpdate

//******************************************************************************
//
//  Function: OglEnableModeSwitchUpdate
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************

void OglEnableModeSwitchUpdate(
PDEV *ppdev)

    {
    ppdev->dwGlobalModeSwitchCount = ppdev->dwGlobalModeSwitchCount + 2;
    ppdev->dwGlobalModeSwitchCount &= 0xFFFFFFFE;
    if (ppdev->oglModeSwitchPtr) *ppdev->oglModeSwitchPtr = ppdev->dwGlobalModeSwitchCount;

    //******************************************************************************
    // Wait for other DMA channels to drain at this point.
    //******************************************************************************
    // Check pfnWaitForChannelSwitch for NULL pointer because in bAssertModeHardware
    // the driver call OglEnableModeSwitchUpdate and the ppdev function pointers are
    // not setup yet.  The function pointers should be setup first before calling
    // bAssertModeHardware...
    //******************************************************************************

    if (OglIsEnabled(ppdev) && ppdev->pfnWaitForChannelSwitch)
        {
        ppdev->pfnWaitForChannelSwitch(ppdev);
        ppdev->NVFreeCount = 0;
        }
    } // end of OglEnableModeSwitchUpdate

//******************************************************************************
//
//  Function: OglLockDownMutexMemory
//
//  Routine Description:
//
//     Lock down memory shared between display driver and client side.
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************
BOOL OglLockDownMemory(
    PDEV *ppdev,
    ULONG numBytes)

    {
    NV_LOCK_DOWN_MEMORY lockDownMemoryIn;
    NV_LOCK_DOWN_MEMORY lockDownMemoryOut;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "OglLockDownMemory - Entry"));

    lockDownMemoryIn.virtualAddress = (PVOID)ppdev->oglGlobalPagePtr;
    lockDownMemoryIn.byteLength     = ROUND_TO_PAGES(numBytes);
    lockDownMemoryIn.pMdl           = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_LOCK_DOWN_MEMORY,
        &lockDownMemoryIn,
        sizeof(NV_LOCK_DOWN_MEMORY),
        &lockDownMemoryOut,
        sizeof(NV_LOCK_DOWN_MEMORY),
        &dwReturnedDataLength))
    {
        DISPDBG((2, "OglLockDownMemory - IOCTL_VIDEO_LOCK_DOWN_MEMORY failed"));
        ppdev->oglGlobalPageMdl = NULL;
        return(FALSE);
    }

    ppdev->oglGlobalPageMdl = lockDownMemoryOut.pMdl;

    DISPDBG((2, "OglLockDownMemory - Exit"));

    return(TRUE);
    }

//******************************************************************************
//
//  Function: OglUnlockMemory
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//            NONE
//
//
//******************************************************************************
BOOL OglUnlockMemory(
PDEV *ppdev)

    {
    NV_UNLOCK_MEMORY unlockMemoryIn;
    NV_UNLOCK_MEMORY unlockMemoryOut;
    ULONG dwReturnedDataLength;

    DISPDBG((2, "OglUnlockMemory - Entry"));

    unlockMemoryIn.pMdl = (PVOID)ppdev->oglGlobalPageMdl;

    if (EngDeviceIoControl(ppdev->hDriver,
        IOCTL_VIDEO_UNLOCK_MEMORY,
        &unlockMemoryIn,
        sizeof(NV_UNLOCK_MEMORY),
        &unlockMemoryOut,
        sizeof(NV_UNLOCK_MEMORY),
        &dwReturnedDataLength))
    {
        DISPDBG((2, "OglUnlockMemory - IOCTL_VIDEO_SYSMEM_SHARE_MEMORY failed"));
        return(FALSE);
    }

    DISPDBG((2, "OglUnlockMemory - Exit"));

    return(TRUE);
    }

//******************************************************************************
//
// Function: OglAcquireGlobalMutex
//
// Routine Description:
//
//     Acquire the mutex that protects the OpenGL global variables.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
VOID OglAcquireGlobalMutex(void)
{
    LONGLONG stime, ctime, dtime;
    ULONG    *oglMutexPtr;
    ULONG     key;
    ULONG     firstTime;

    oglMutexPtr = &globalOpenGLMutex;

    firstTime = 0;
    key = 1;
    do
        {
        NV_EXCHANGE(oglMutexPtr, key);
        if (key == 1)
            {

            if (firstTime == 0)
                {
                firstTime = 1;
                EngQueryPerformanceCounter((LONGLONG *)&stime);
                }
            else
                {

                EngQueryPerformanceCounter((LONGLONG *)&ctime);
                dtime = (ctime - stime);
                if (dtime >= 3) // 3 seconds
                    {
                    // TIMEOUT force reset of mutex
                    *oglMutexPtr = 1;                // report mutex acquired
                    key = 0;                         // force out of loop
                    }
                }
            }
        }
    while (key == 1);

    globalOpenGLMutexCount = 1;
}

//******************************************************************************
//
// Function: OglReleaseGlobalMutex
//
// Routine Description:
//
//     Release the mutex that protects OpenGL global variables
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
VOID OglReleaseGlobalMutex(void)
{
    globalOpenGLMutex = 0;
    globalOpenGLMutexCount = 0;
}


//*************************************************************************
// bOglServicesDisable
// 
// free everything that was allocated to run opengl especially stuff
// allocated in bOglServicesInit
//
// returns TRUE  if succeeded
//         FALSE if failed
//*************************************************************************
BOOL bOglServicesDisable(PPDEV ppdev)
{
    ASSERT (NULL!=ppdev);


    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        bOglNegativeClipListDestroy(ppdev);
    }

    OglDisableModeSwitchUpdate(ppdev);

    if (NULL != ppdev->pOglServer)
    {
        EngFreeMem(ppdev->pOglServer);
        ppdev->pOglServer = NULL;
    }

    // for now cannot fail
    return (TRUE);
}


//*************************************************************************
// bOglServicesInit
// 
// Initialize everything needed to run the OpenGL server side.
// This has to be called after a ppdev has been created before the first
// OpenGL app is started.
//
// Call bOglServicesDisable to free this stuff again.
//
// returns TRUE  if succeeded
//         FALSE if failed
//*************************************************************************
BOOL bOglServicesInit(PPDEV ppdev)
{
    BOOL bRet = FALSE; // default error exit

    ASSERT (NULL!=ppdev);

    ppdev->pOglServer = EngAllocMem(FL_ZERO_MEMORY, sizeof(OGLSERVER), ALLOC_TAG);
    if (NULL == ppdev->pOglServer)
    {
        DBG_ERROR("bOglServicesInit: failed to initialize ppdev->pOglServer");
        goto Exit;
    }

    OglEnableModeSwitchUpdate(ppdev);

    NV_InitDoubleBufferSavedProcs(ppdev);

    if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
    {
        bOglStereoSurfacesAllowed(ppdev);
        bOglOverlaySurfacesAllowed(ppdev);

        bOglNegativeClipListCreate(ppdev);
    }

    bRet = TRUE;
Exit:
    return (bRet);
}

#if (NVARCH >= 0x4)
//*************************************************************************
// OglReadRegDword
//
// Utility function for OglReadRegistry to read one opengl registry
// entry.  If this fails or if the registry does not exist then
// outVal is not modified
//*************************************************************************

static void OglReadRegDword(
    PDEV *ppdev,
    CHAR *rawName,
    DWORD *outVal)
{
    CHAR fullName[NV_MAX_REG_KEYNAME_LEN + 4];
    WCHAR keyName[NV_MAX_REG_KEYNAME_LEN];
    DWORD fullNameLen, keyNameLen;
    DWORD retStatus;
    DWORD keyVal, keyValSize;

    /* Build a wide name */
    fullName[0] = 0;
    strcat(fullName, "OGL_");
    strcat(fullName, rawName);
    fullNameLen = strlen(fullName)+1;
    ASSERTDD(fullNameLen <= NV_MAX_REG_KEYNAME_LEN, "Key name too long");

    EngMultiByteToUnicodeN(keyName,
                           NV_MAX_REG_KEYNAME_LEN*sizeof(WCHAR),
                           &keyNameLen,
                           (PCHAR)fullName,
                           fullNameLen*sizeof(CHAR));

    retStatus = EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                                   (LPVOID)keyName,
                                   keyNameLen,
                                   (LPVOID)&keyVal,
                                   sizeof(DWORD),
                                   &keyValSize);

    if (retStatus == NO_ERROR) {
        *outVal = keyVal;
    } 
}

//*************************************************************************
// OglReadRegistry
//
// Reads in opengl related regisry settings into ppdev->oglRegXXXX
// entries into the pdev.  This calls into the shared library
// to initialize default registry values consistent with the ICD and
// also calls into the shared library to hack the registry values on
// a per chip/chip type/OS basis.
//*************************************************************************

void OglReadRegistry(
    PDEV *ppdev)
{
    DWORD doUnifiedBuffers;
    DWORD doWindowFlipping;
    DWORD flippingControl;
    DWORD applicationKey;
    DWORD appSupportBits;
    DWORD overlaySupport;
    DWORD apiStereoSupport;
    DWORD apiStereoMode;
#if 0    
    // Grab the defaults from the opengl shared library to be consistent with
    // the ICD.
    __glNVLoadRegistryDefaults(ppdev->hwGfxCaps,
                               &doUnifiedBuffers,
                               &doWindowFlipping,
                               &flippingControl,
                               &applicationKey,
                               &appSupportBits,
                               &overlaySupport,
                               &apiStereoSupport,
                               &apiStereoMode);
#endif
    OglReadRegDword(ppdev, NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER, &doUnifiedBuffers);
    OglReadRegDword(ppdev, NV_REG_OGL_WINDOW_FLIPPING, &doWindowFlipping);
    OglReadRegDword(ppdev, NV_REG_OGL_OVERLAY_SUPPORT, &overlaySupport);
    OglReadRegDword(ppdev, NV4_REG_OGL_BUFFER_FLIPPING_CONTROL, &flippingControl);
    OglReadRegDword(ppdev, NV_REG_OGL_STEREO_SUPPORT, &apiStereoSupport);
    OglReadRegDword(ppdev, NV_REG_OGL_API_STEREO_MODE, &apiStereoMode);
#if 0
    // Apply per OS per chip hacks to the registry through the shared library to
    // be consistent with the ICD.
    __glNVDoRegistryHacks(ppdev->hwGfxCaps,
                          &flippingControl,
                          &doUnifiedBuffers,
                          &doWindowFlipping,
                          &applicationKey,
                          &appSupportBits,
                          &overlaySupport,
                          &apiStereoSupport,
                          &apiStereoMode);
#endif                          
    ppdev->oglRegUBB              = doUnifiedBuffers;
    ppdev->oglRegWindowFlipping   = doWindowFlipping;
    ppdev->oglRegFlippingControl  = flippingControl;
    ppdev->oglRegOverlaySupport   = overlaySupport;
    ppdev->oglRegApiStereoSupport = apiStereoSupport;
    ppdev->oglRegApiStereoMode    = apiStereoMode;
}
#endif // NVARCH >= 0x4


//*************************************************************************
// bOglAssertMode
// 
// has to be called within DrvAssertMode at a point where the hardware 
// is accessible.
//
// returns TRUE  if succeeded
//         FALSE if failed
//*************************************************************************
BOOL bOglAssertMode(PPDEV ppdev, BOOL bEnable)
{
    ASSERT (NULL!=ppdev);

    if (bEnable)
    {
        //
        // Enable paused mode again
        //

        if (OglIsEnabled(ppdev))
        {
            // try to enable necessary ogl features.
            bOglPageFlipModeUpdate(ppdev);
            bOglOverlayModeUpdate(ppdev);
            bOglStereoModeUpdate(ppdev);
        }
    }
    else
    {
        //
        // Pause mode (temporariliy disabled)
        //

        if (OglIsEnabled(ppdev))
        {
            // Disable GDI broadcasting
            // pageflipping, stereo shuttering, merge blits, ...
            bOglPageFlipModeDisableAll(ppdev);
            bOglOverlayModeDisable(ppdev);
            bOglStereoModeDisable(ppdev);
        }

        // need to free allocated UBB buffers
        if (ppdev->bOglSingleBackDepthCreated)  
        {
            // Free UBB surfaces, clients must recover
            OglFreeUnifiedSurfaces(ppdev);
        }
    }

    // for now cannot fail
    return TRUE;
}


//*************************************************************************
// bOglResetPDEV
// 
// has to be called in DrvResetPDEV to check if a mode switch is allowed 
// depending on OpenGL settings and active applications.
//
// returns TRUE  if modeswitch is allowed
//         FALSE if modeswitch is not allowed
//*************************************************************************
BOOL bOglResetPDEV(
    PPDEV ppdevOld, // ppdev of mode we're leaving (old mode)
    PPDEV ppdevNew) // ppdev of mode we're switching to (new mode)
{
    BOOL bRet = FALSE; // default error, cannot allow to switch resolution
    BOOL bOld;         // remember old value

    ASSERT(NULL!=ppdevNew);
    ASSERT(NULL!=ppdevOld);

    // Overlays are not supported in all resolutions
    if (   (   (bOld = ppdevOld->bOglOverlayDesired)                   //    overlay was enabled
            || bOglOverlaySurfacesAllowed(ppdevOld) )                  //    or overlays is still enabled
        && (cOglWindows(ppdevOld)>0)                                   // and opengl running
        && !bOglOverlaySurfacesAllowed(ppdevNew)                       // new mode doesn't support overlay
       )
    {
        DISPDBG((0, "ERROR: cannot switch to new mode because OpenGL overlays won't work!"));
        // if registry has changed in the meantime, we lost this value. Reset it!
        ppdevOld->bOglOverlayDesired = bOld; 
        goto Exit;
    }

    // Stereo isn't supported in all resolutions
    if (   (   (bOld = ppdevOld->bOglStereoDesired)                    //    stereo was enabled
            || bOglStereoSurfacesAllowed(ppdevOld) )                   //    or stereo is still enabled
        && (cOglWindows(ppdevOld)>0)                                   // and opengl running
        && !bOglStereoSurfacesAllowed(ppdevNew)                        // new mode doesn't support stereo
       )
    {
        DISPDBG((0, "ERROR: cannot switch to new mode because OpenGL stereo won't work!"));
        // if registry was changed in the meantime, we lost this value. Reset it!
        ppdevOld->bOglStereoDesired = bOld; 
        goto Exit;
    }

    // everything is okay!
    bRet=TRUE;
Exit:
    return (bRet);
}

#ifdef NV_MAIN_MULTIMON
/***************** OGL Multi-Monitor Support functions ******************/
/* See MAIN - oglmultimon.c for similar code.                           */
/************************************************************************/

/*
 * FUNCTION: OglClientIntersectsDevice
 *
 * DESC: Intersects the clientDrawableInfo rect with that of the PDEV
 */ 
BOOL OglClientIntersectsDevice(PDEV *ppdev, NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo)
{
    if (!ppdev->bEnabled) return GL_FALSE;
    if ((int)clientDrawableInfo->rect.bottom <= (int)ppdev->top) return GL_FALSE;
    if ((int)clientDrawableInfo->rect.top >= (int)(ppdev->top + ppdev->cyScreen)) return GL_FALSE;
    if ((int)clientDrawableInfo->rect.left >= (int)(ppdev->left + ppdev->cxScreen)) return GL_FALSE;
    if ((int)clientDrawableInfo->rect.right <= (int)ppdev->left) return GL_FALSE;
  
    return TRUE;
}

/************************ Global PDEV management ************************/

/*
 * FUNCTION: OglInitPDEVList
 * 
 * DESC: Initialize the globalOpenGLData PDEV list to NULL 
 * 
 * Called by DrvEnableDriver
 */
void OglInitPDEVList(void)
{
    if (!bLinkedListCreate(&(globalOpenGLData.oglpdevList), LL_CLASS_OGLPDEV))
    {
        /* For some reason our initialization failed */
        DISPDBG((1, "OglInitPDEVList: Error! Can't create the PDEV linked list!"));
        ASSERT(FALSE);
    }
}

/*
 * FUNCTION: OglDestroyPDEVList
 *
 * DESC: Destroys the PDEV List
 *
 * Called by DrvDisableDriver
 */
void OglDestroyPDEVList(void)
{
    /* If we failed here, we are either calling DrvDisableDriver too many times, or 
     * something went terribly wrong.  Either way, we need to print Debug
     * information about this.
     */
    if (!bLinkedListDestroy(&(globalOpenGLData.oglpdevList)))
    { 
        DISPDBG((1, "OglInitPDEVList: Error! Can't destroy the PDEV linked list!"));
        ASSERT(FALSE);
    }
}

/*
 * FUNCTION: OglAddPDEVToList
 *
 * DESC: Adds a PDEV reference node to the globalOpenGLData structure.
 *
 * Called by DrvEnablePDEV
 */
void OglAddPDEVToList(PDEV *ppdev)
{
    bLinkedListAddElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, (ULONG_PTR)ppdev, (PVOID)ppdev, 0);
}

/*
 * FUNCTION: OglRemovePDEVFromList
 *
 * DESC: Removes a matching PDEV from the globalOpenGLData PDEV list.
 *
 * Called by DrvDisablePDEV
 */
void OglRemovePDEVFromList(PDEV *ppdev)
{
    bLinkedListRemoveElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, (ULONG_PTR)ppdev);
}

//
//  bOglGetNextPdev
//
//  Function is an interface for struct LINKEDLIST with. 
//  class LL_CLASS_OGLPDEV. It returns next element in inked. 
//  If *pul is 0, function returns head of list.
//  Function returns TRUE while a new element is found.
//
//  Function should be used as follows:
//
//  PDEV       *ppdevLoop   = NULL;
//
//  while(bOglGetNextPdev(&ppdevLoop))  // loop thru entire oglpdevlist until we find desired listentry
//  {
//      // do something here
//   }
//
BOOL bOglGetNextPdev( IN OUT PPDEV* pppdev )
{
    BOOL   bRet       = FALSE;
    PVOID  pvData     = NULL;

    // we need a valid ppdevlist here
    ASSERT(globalOpenGLData.oglpdevList);
    ASSERT(pppdev);

    if( NULL==*pppdev )
    {
        bRet = bLinkedListGetFirstElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, (ULONG_PTR*)pvData, &pvData);
        if( bRet )
        {
            *pppdev = (PPDEV)pvData;
        }
    }
    else
    {
        bRet = bLinkedListGetNextElement(globalOpenGLData.oglpdevList, LL_CLASS_OGLPDEV, (ULONG_PTR*)pvData, &pvData);
        if( bRet )
        {
            *pppdev = (PPDEV)pvData;
        }
    }

    return bRet;
}


//
//  bOglRetrieveValidPDEVForDevice
//
//  Function loops thru global ddevList and returns ppdev 
//  which is enabled and belongs to given ulDeviceNumber.
//
BOOL bOglRetrieveValidPDEVForDevice( IN OUT PPDEV* pppdev, IN ULONG ulDeviceNumber )
{
    BOOL bRet = FALSE;
    ASSERT(pppdev);

    *pppdev = NULL;                 // start enumeration at root

    while(bOglGetNextPdev(pppdev))  // loop thru entire ppdevlist until we find desired listentry
    {
        if(  ((*pppdev)->bEnabled)                             // is the ppdev initialized and enabled ?
           &&((*pppdev)->ulDeviceReference == ulDeviceNumber)  // is this the number of coresponding device
          )
        {
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}


//
//  bOglRetrieveValidPDEVForOrigin
//
//  Function loops thru global ddevList and returns ppdev 
//  which is enabled and has origin described by lLeft and lTop.
//
BOOL bOglRetrieveValidPDEVForOrigin( IN OUT PPDEV* pppdev, IN LONG lLeft, IN LONG lTop )
{
    BOOL bRet = FALSE;

    ASSERT(pppdev);

    *pppdev = NULL;                             // start enumeration at root

    while(bOglGetNextPdev(pppdev))              // loop thru entire ppdevlist until we find desired listentry
    {
        if(  ((*pppdev)->bEnabled)              // is the ppdev initialized and enabled ?
           &&((*pppdev)->left == (ULONG)lLeft)  // does origin fit devices origin ?
           &&((*pppdev)->top  == (ULONG)lTop )  // does origin fit devices origin ?
          )
        {
            bRet = TRUE;
            break;
        }
    }
    return bRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\pixelfmt.c ===
/******************************Module*Header*******************************\
* Module Name: pixelfmt.c
*
* This module contains the functions that set and describe pixel formats.
*
* Copyright (c) 1998 NVidia Corporation
\**************************************************************************/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop

#if (NVARCH >= 0x4)
#include "wincommon.h"
#include "wglcommon.h"
#include "nvapi.h"
#include "Nvcm.h"
#endif // (NVARCH >= 0x4)
#include "oglDD.h"
#include "OglOverlay.h"

#include "nvReg.h"

//
// export
//


#ifdef NV3
#define NUM_NV_PIXELFORMATS_16BPP  4

static PIXELFORMATDESCRIPTOR
NVPixelFormats16Bpp555[NUM_NV_PIXELFORMATS_16BPP] =
{
    /*
    ** 16 bit
    */
    // Single Buffer, No Stencil
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // size
        1,                                          // version
        PFD_SUPPORT_OPENGL |                        // flags
        PFD_DRAW_TO_WINDOW |
        PFD_SUPPORT_GDI,
        PFD_TYPE_RGBA,                              // pixel type
        16, 5, 10, 5, 5, 5, 0,                      // color buffer
        0, 0,                                       // alpha buffer
        64, 16, 16, 16, 16,                         // accumulation buffer
        16,                                         // depth buffer
        0,                                          // NO stencil buffer
        0,                                          // aux buffers
        PFD_MAIN_PLANE,                             // layer type
        0,                                          // (reserved)
        0, 0, 0,                                    // layer masks
    },
    // Single Buffer, With Stencil
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // size
        1,                                          // version
        PFD_SUPPORT_OPENGL |                        // flags
        PFD_DRAW_TO_WINDOW |
        PFD_SUPPORT_GDI,
        PFD_TYPE_RGBA,                              // pixel type
        16, 5, 10, 5, 5, 5, 0,                      // color buffer
        0, 0,                                       // alpha buffer
        64, 16, 16, 16, 16,                         // accumulation buffer
        16,                                         // depth buffer
        8,                                          // stencil buffer
        0,                                          // aux buffers
        PFD_MAIN_PLANE,                             // layer type
        0,                                          // (reserved)
        0, 0, 0,                                    // layer masks
    },
    // Double Buffer, No Stencil
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // size
        1,                      // version
        PFD_SUPPORT_OPENGL |                        // flags
        PFD_DRAW_TO_WINDOW |
        PFD_DOUBLEBUFFER |
        PFD_SWAP_COPY,
        PFD_TYPE_RGBA,                              // pixel type
        16, 5, 10, 5, 5, 5, 0,                      // color buffer
        0, 0,                                       // alpha buffer
        64, 16, 16, 16, 16,                         // accumulation buffer
        16,                                         // depth buffer
        0,                                          // NO stencil buffer
        0,                                          // aux buffers
        PFD_MAIN_PLANE,                             // layer type
        0,                                          // (reserved)
        0, 0, 0,                                    // layer masks
    },
    // Double Buffer, With Stencil
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // size
        1,                      // version
        PFD_SUPPORT_OPENGL |                        // flags
        PFD_DRAW_TO_WINDOW |
        PFD_DOUBLEBUFFER |
        PFD_SWAP_COPY,
        PFD_TYPE_RGBA,                              // pixel type
        16, 5, 10, 5, 5, 5, 0,                      // color buffer
        0, 0,                                       // alpha buffer
        64, 16, 16, 16, 16,                         // accumulation buffer
        16,                                         // depth buffer
        8,                                          // stencil buffer
        0,                                          // aux buffers
        PFD_MAIN_PLANE,                             // layer type
        0,                                          // (reserved)
        0, 0, 0,                                    // layer masks
    }
};

LONG APIENTRY NV3DescribePixelFormat(
    LONG                  iPixelFormat,
    ULONG                 cjpfd,
    PIXELFORMATDESCRIPTOR *ppfd)
{
    DWORD size;

    if (ppfd &&
        (iPixelFormat > 0) &&
        (iPixelFormat <= NUM_NV_PIXELFORMATS_16BPP)) {
        size = (cjpfd < sizeof(PIXELFORMATDESCRIPTOR)) ?
            cjpfd : sizeof(PIXELFORMATDESCRIPTOR);
        memcpy(ppfd, &NVPixelFormats16Bpp555[iPixelFormat-1], size);
    }

    return NUM_NV_PIXELFORMATS_16BPP;
}
#endif

//******************************************************************************
//
//  Function:   DrvSetPixelFormat
//
//  Routine Description:
//
//      Implements the set pixel format ICD routine.  This routine is called
//      by OpenGL32.DLL to set the pixel format to the value in iPixelFormat.
//
//  Arguments:
//
//  Return Value:
//
//      TRUE is the pixel format is set, FALSE otherwise.
//
//******************************************************************************
BOOL APIENTRY DrvSetPixelFormat(
    SURFOBJ *pso,
    LONG    iPixelFormat,
    HWND    hWnd
)
{
    int i;
    PDEV                  *ppdev = (PDEV *)pso->dhpdev;
    NV_OPENGL_CLIENT_INFO      *clientInfo = NULL;
    NV_OPENGL_CLIENT_INFO_LIST *clientList = NULL;

    if (ppdev)
        {

        if (OglSupportEnabled(ppdev) == (ULONG)FALSE)
                    {
            DISPDBG((2, "SetPixelFormat: OglSupportEnable FAILED!", 0, ppdev->cBitsPerPel));
            return FALSE;
                    }

        clientList = OglFindClientInfoFromHWnd(ppdev, hWnd);
        if (clientList)
            {
            clientInfo = &clientList->clientInfo;
            }

        if (clientInfo && clientInfo->clientDrawableInfo)
        {
            clientInfo->clientDrawableInfo->iPixelFormat = iPixelFormat;
        }
    
        return TRUE;
        }
        
    else
    
        {
        return(FALSE);
        }

}

//*************************************************************************
// bOglStereoSurfacesAllowed
// 
// returns TRUE if the current environment, depending on quadro, 
// resolution and registry allows stereo
//*************************************************************************
BOOL bOglStereoSurfacesAllowed(PPDEV ppdev)
{
    ASSERT( ppdev );

    ppdev->bOglStereoDesired = FALSE;

#if (NVARCH >= 0x4)
    if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)
    {
        // do we have enough frambuffer memory to enable overlay ?
        ASSERT(ppdev->cyScreen > 0);
        ASSERT(ppdev->cyScreen < ppdev->cyMemory);
        OglReadRegistry(ppdev);

        //     room for 6 fullscreen buffer:    front*2+back*2+Z*2
        if(ppdev->cyMemory >= (LONG)(ppdev->cyScreen*6) )
        {
            if (ppdev->oglRegApiStereoSupport != NV_REG_OGL_STEREO_SUPPORT_OFF)
            {
                ppdev->bOglStereoDesired = TRUE;
            }
        }
    }
#endif //(NVARCH >= 0x4)
    return (ppdev->bOglStereoDesired);
}


/*
** bOglPfdCheckFlags
** 
** depending on registry, frambuffer size and other restricting 
** things return a mask with pixelformats types we allow.
** 
** FNicklisch 13.11.2000: New
*/ 
BOOL bOglPfdCheckFlags(PPDEV ppdev, ULONG *pulPfdCheckFlags)
{
#if (NVARCH >= 0x4)
    ASSERTDD(!bOglOverlaySurfacesAllowed(ppdev) || !bOglStereoSurfacesAllowed(ppdev), "stereo AND overlays not supported!");

    if( bOglOverlaySurfacesAllowed(ppdev) )
    {
        *pulPfdCheckFlags |= WIN_PFD_SUPPORTS_OVERLAYS;
        *pulPfdCheckFlags |= WIN_PFD_SUPPORTS_SWAP_LAYER_BUFFERS;
    }
         //
    else // KEY: workaround for never overlays and stereo at same time!
         //
    if( bOglStereoSurfacesAllowed(ppdev) )
    {
        *pulPfdCheckFlags |= WIN_PFD_SUPPORTS_STEREO;
    }
#else
    ppdev;            // unused parameter
    pulPfdCheckFlags;
#endif
    return (TRUE);
}

//******************************************************************************
//
//  Function:   DrvDescribePixelFormat
//
//  Routine Description:
//
//      Implements the routine which informs OpenGL32.DLL of our supported
//      pixel formats.
//
//  Known Problems:
//     
//     Make sure tbis method is consistent with icdcmd.c/DrvDescribePixelFormat [only NT4/NT5 goes through disp]
//
//  Arguments:
//
//  Return Value:
//
//      Number of pixel formats supported
//
//******************************************************************************
LONG APIENTRY DrvDescribePixelFormat(
    DHPDEV                  dhpdev,
    LONG                    iPixelFormat,
    ULONG                   cjpfd,
    PIXELFORMATDESCRIPTOR   *ppfd
)
{
    LONG result;
    DWORD size;
    PDEV  *ppdev;
    __WINNVpixelFormatFlags winPFFlags;

    DISPDBG((1, "DrvDescribePixelFormat: Entry iPixelFormat %ld",
             iPixelFormat));

    ppdev = (PDEV *)dhpdev;

#ifdef _WIN64
    // For some reason we die with an unspeakable backtrace when we
    // call __wglNVDescribePixelFormat after returning FALSE for
    // the OPENGL_INFO escape.  Return to it someday, but for now ...

    if (!(ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC)) {
        DISPDBG((2, "DrvDescribePixelFormat: !ppdev->oglWorkStationPart!"));
        result = 0;
    } else
#endif
    if (OglSupportEnabled(ppdev) == (ULONG)FALSE) {
        DISPDBG((2, "DrvDescribePixelFormat: OglSupportEnabled FAILED!"));
        result = 0;
    } else {
#ifdef NV3
        if (ppdev->cBitsPerPel == 16) {
            result = NV3DescribePixelFormat(iPixelFormat, cjpfd, ppfd);
        } else {
            result = 0;
        }
#else        
        OglReadRegistry(ppdev);
                                     
        winPFFlags.color16depth32  = ppdev->oglColor16Depth32;
        winPFFlags.color32depth16  = ppdev->oglColor32Depth16; 
        winPFFlags.multisample     = ppdev->oglMultisample;
        winPFFlags.flippingControl = ppdev->oglRegFlippingControl;
        winPFFlags.unifiedBuffers  = ppdev->oglRegUBB; 

        result = 0;
#if 0
         __wglNVDescribePixelFormat(
            (int)ppdev->cBitsPerPel,
            0,
            (int)iPixelFormat,
            (UINT)cjpfd,
            ppfd,
            NULL,
            NULL,
            &winPFFlags,
            FALSE,
            (void *) ppdev);
#endif
#endif // NV3
    }
    
    DISPDBG((2, "DrvDescribePixelFormat: Exit %ld %ld",
             0, ppdev->cBitsPerPel));

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\palette.c ===
//******************************Module*Header***********************************
//
// Module Name: palette.c
//
// Palette support.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "nv32.h"
#include "driver.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.
PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

//******************************************************************************
//
//  Function:   bInitializePalette
//
//  Routine Description:
//
//      Initializes default palette for PDEV.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)

    {
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    //**********************************************************************
    // Allocate our palette. We create a default 256 color palette for
    // all the video modes. The reason for this is that we need to store
    // an 8BPP palette in the PDEV since DrvSetCursorShape can be called
    // with an 8BPP bitmap and an XLATEOBJ with no RGB values. In this case
    // we use the default palette RGB values to convert it to 16BPP, which
    // is what our color cursor hw requires.
    //**********************************************************************

    ppal = (PALETTEENTRY *) EngAllocMem(FL_ZERO_MEMORY, sizeof(PALETTEENTRY) * 256, ALLOC_TAG);
    if (ppal == NULL)
        goto ReturnFalse;

    ppdev->pPal = ppal;

    //**********************************************************************
    // Generate 256 (8*4*4) RGB combinations to fill the palette
    //**********************************************************************

    jRed = 0;
    jGre = 0;
    jBlu = 0;

    ppalTmp = ppal;

    for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
        ppalTmp->peRed   = jRed;
        ppalTmp->peGreen = jGre;
        ppalTmp->peBlue  = jBlu;
        ppalTmp->peFlags = 0;

        ppalTmp++;

        if (!(jRed += 32))
            if (!(jGre += 32))
                jBlu += 64;
        }

    //**********************************************************************
    // Fill in Windows reserved colours from the WIN 3.0 DDK
    // The Window Manager reserved the first and last 10 colours for
    // painting windows borders and for non-palette managed applications.
    //**********************************************************************

    for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
        //******************************************************************
        // First 10
        //******************************************************************

        ppal[ulLoop]       = gapalBase[ulLoop];

        //******************************************************************
        // Last 10
        //******************************************************************

        ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

    //**********************************************************************
    // Get handle for palette from GRE.
    //**********************************************************************

    if (ppdev->iBitmapFormat == BMF_8BPP)
        {
        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
        }
    else

        {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
         (ppdev->iBitmapFormat == BMF_24BPP) ||
         (ppdev->iBitmapFormat == BMF_32BPP),
         "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
        }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((2, "Failed bInitializePalette"));
    return(FALSE);
    }

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

//******************************************************************************
//
//  Function:   bEnablePalette
//
//      Initialize the hardware's 8bpp palette registers.
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL bEnablePalette(PDEV* ppdev)

    {
    ULONG i, j;
    ULONG ulHead, ulOffset;



    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        //**********************************************************************
        // Set palette using hardware specific routine
        // (Specify start and length)
        //**********************************************************************

		for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    	{
        	ulHead = ppdev->ulDeviceDisplay[i];
	        ulOffset = ulHead*256;
   
    	    for(j = 0 ; j < 256; j++)
        	{
	            ppdev->ajClutData[j + ulOffset].Red =    ppdev->pPal[j].peRed >>
                                          ppdev->cPaletteShift;
    	        ppdev->ajClutData[j + ulOffset].Green =  ppdev->pPal[j].peGreen >>
                                          ppdev->cPaletteShift;
        	    ppdev->ajClutData[j + ulOffset].Blue =   ppdev->pPal[j].peBlue >>
                                          ppdev->cPaletteShift;
	            ppdev->ajClutData[j + ulOffset].Unused = 0;
    	    }
	    }
        ppdev->pfnSetPalette(ppdev, 0, 256 * sizeof(VIDEO_CLUTDATA));
    }


    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
    }

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PDEV*           ppdev = (PDEV *) dhpdev;
    UCHAR   cTemp;
    ULONG i;
    ULONG ulHead, ulCount;
    ULONG ulOffset;

    UNREFERENCED_PARAMETER(fl);

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);
    
    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.
   	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
    {
        ulCount = cColors;
        ulOffset = ppdev->ulDeviceDisplay[i] * 256;

        if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                         (ULONG*) (ppdev->ajClutData+ulOffset)))
        {
            DISPDBG((2, "DrvSetPalette failed PALOBJ_cGetColors"));
            RELEASE_CRTC_CRITICAL_SECTION(ppdev);
            return (FALSE);
        }

        if (ppdev->cPaletteShift)
        {
            while(ulCount--)
            {
                cTemp = ppdev->ajClutData[ulCount+ulOffset].Red >> ppdev->cPaletteShift;
                ppdev->ajClutData[ulCount+ulOffset].Red = ppdev->ajClutData[ulCount+ulOffset].Blue >> ppdev->cPaletteShift;
                ppdev->ajClutData[ulCount+ulOffset].Blue = cTemp;
                ppdev->ajClutData[ulCount+ulOffset].Green >>= ppdev->cPaletteShift;
                ppdev->ajClutData[ulCount+ulOffset].Unused = 0;
            }
        }
        else
        {
            while(ulCount--)
            {
                cTemp = ppdev->ajClutData[ulCount+ulOffset].Red;
                ppdev->ajClutData[ulCount+ulOffset].Red = ppdev->ajClutData[ulCount+ulOffset].Blue;
                ppdev->ajClutData[ulCount+ulOffset].Blue = cTemp;
                ppdev->ajClutData[ulCount+ulOffset].Unused = 0;
            }
        }
    }

    //**************************************************************************
    // Setup the palette using hardware specific routine
    // (Specify start and length)
    //**************************************************************************

    if(ppdev->bEnabled) // Incomplete fix for the av in V4DmaPushSetPalette if acceleration is disabled.
        ppdev->pfnSetPalette(ppdev, 0, 256 * sizeof(VIDEO_CLUTDATA));
    else
    {
        PVIDEO_CLUTDATA pScreenClutData;

        ulCount = cColors;
        pScreenClutData = (PVIDEO_CLUTDATA)(&(pScreenClut->LookupTable[0]));

        if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                         (ULONG*)pScreenClutData))
        {
            DISPDBG((2, "DrvSetPalette failed PALOBJ_cGetColors"));
            RELEASE_CRTC_CRITICAL_SECTION(ppdev);
            return (FALSE);
        }

        if(ppdev->cPaletteShift)
        {
            while(ulCount--)
            {
                pScreenClutData[ulCount].Red >>= ppdev->cPaletteShift;
                pScreenClutData[ulCount].Green >>= ppdev->cPaletteShift;
                pScreenClutData[ulCount].Blue >>= ppdev->cPaletteShift;
                pScreenClutData[ulCount].Unused = 0;
            }
        }
        else
        {
            while(ulCount--)
            {
                pScreenClutData[ulCount].Unused = 0;
            }
        }

        if(EngDeviceIoControl(ppdev->hDriver,
                              IOCTL_VIDEO_SET_COLOR_REGISTERS,
                              pScreenClut,
                              MAX_CLUT_SIZE,
                              NULL,
                              0,
                              &ulCount))
        {
            RELEASE_CRTC_CRITICAL_SECTION(ppdev);
            return(FALSE);
        }
    }

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    return(TRUE);

}

/******************************Public*Routine******************************\
* ULONG nvSetGammaRamp
*
* DDI entry point for setting gamma ramp.
*
\**************************************************************************/
ULONG
nvSetGammaRamp(PDEV *ppdev, PUSHORT fpRampVals)
{
    ULONG nNumEntries = 256;
    ULONG nStartIndex = 0;
    ULONG i, ulHead, ulDevice, ulOffset;

    if (!ppdev) return(FALSE);

    if(ppdev->iBitmapFormat != BMF_8BPP)
    {
        for(ulDevice = 0; ulDevice < ppdev->ulNumberDacsActive; ulDevice++)
        {
            ulHead = ppdev->ulDeviceDisplay[ulDevice];
            ulOffset = ulHead * 256;

            for (i = 0; i < nNumEntries; i++) 
            {
                ppdev->ajClutData[i + ulOffset].Blue  = (UCHAR) (fpRampVals[512 + i] >> 8); /* blue value */
                ppdev->ajClutData[i + ulOffset].Green = (UCHAR) (fpRampVals[256 + i] >> 8); /* green value */
                ppdev->ajClutData[i + ulOffset].Red   = (UCHAR) (fpRampVals[i] >> 8); /* red value */
            }
        }

        ppdev->pfnSetPalette(ppdev, (nStartIndex << 2) , (nNumEntries << 2) );
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* ULONG nvGetGammaRamp
*
* DDI entry point for getting gamma ramp.
*
\**************************************************************************/
ULONG
nvGetGammaRamp(PDEV *ppdev, PUSHORT fpRampVals)
{

    unsigned short i;
    unsigned long nNumEntries = 256;

    if (!ppdev) return(FALSE);

    if(ppdev->iBitmapFormat != BMF_8BPP)
    {
        for (i = 0; i < nNumEntries; i++) 
        {
            fpRampVals[512 + i] = ((USHORT)ppdev->ajClutData[i].Blue << 8); // blue value
            fpRampVals[256 + i] = ((USHORT)ppdev->ajClutData[i].Green << 8);// green value
            fpRampVals[i]       = ((USHORT)ppdev->ajClutData[i].Red << 8);  // red value
        }
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


#if _WIN32_WINNT >= 0x0500
/*****************************************************************************\
*   BOOL    DrvIcmSetDeviceGammaRamp
*
*   DDI entry point for setting gamma ramp.
*
*   iFormat == IGRF_RGB_256WORDS (always)
*   lpRamp == pointer to GAMMARAMP structure.
*   where       typedef struct _GAMMARAMP {
*                   WORD Red[256];
*                   WORD Green[256];
*                   WORD Blue[256];
*               } GAMMARAMP, *PGAMMARAMP;
*
\*****************************************************************************/

BOOL
DrvIcmSetDeviceGammaRamp(
    DHPDEV  dhpdev,
    ULONG   iFormat,
    LPVOID  lpRamp
)
{
    PPDEV           ppdev = (PPDEV)dhpdev;
    WORD *          pwGamma;
    ULONG i, ulHead, ulDevice, ulOffset;

    //
    //  Sanity check
    //

    if(iFormat == IGRF_RGB_256WORDS)
    {
        pwGamma = lpRamp;

        //
        //  Enable PIXMIX
        //
//        dwRet = EngDeviceIoControl(
//            ppdev->hDriver,
//            IOCTL_VIDEO_ENABLE_PIXMIX_INDEX,
//            NULL, 0,
//            NULL, 0,
//            &dwReturnedDataLength
//            );

        //
        //  Copy gamma ramp
        //
        for(ulDevice = 0; ulDevice < ppdev->ulNumberDacsActive; ulDevice++)
        {
            ulHead = ppdev->ulDeviceDisplay[ulDevice];
            ulOffset = ulHead * 256;

            for(i = 0; i < 256; i++)
            {
                ppdev->ajClutData[i + ulOffset].Red = (UCHAR)(pwGamma[i] >> 8);
                ppdev->ajClutData[i + ulOffset].Green = (UCHAR)(pwGamma[256 + i] >> 8);
                ppdev->ajClutData[i + ulOffset].Blue = (UCHAR)(pwGamma[(2*256) + i] >> 8);
                ppdev->ajClutData[i + ulOffset].Unused = 0;
            }
        }

        ppdev->pfnSetPalette(ppdev, 0, 256 * sizeof(VIDEO_CLUTDATA));

        return(TRUE);
    }
    
    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\pixelfmt.h ===
#ifndef _PIXELFMT_H
#define _PIXELFMT_H
//******************************Module*Header***********************************
// Module Name: pixelfmt.h
//
// export header for pixelfmt.c
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

BOOL bOglStereoSurfacesAllowed(PPDEV ppdev);
BOOL bOglPfdCheckFlags(PPDEV ppdev, ULONG *pulPfdCheckFlags);
int cGetWindowFlippingControl(PPDEV ppdev);

#endif // _PIXELFMT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\precomp.h ===
/******************************Module*Header***********************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1996 Microsoft Corporation
\******************************************************************************/

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#ifndef _WIN32_WINNT     // NT 3.5
#include <stdio.h>
#endif                  // NT 3.5
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>

#if _WIN32_WINNT < 0x0500
typedef  ULONG ULONG_PTR;
__inline ULONG PtrToUlong(PVOID p) { return((ULONG) p); }
#endif

#if _WIN32_WINNT >= 0x0500
#define  __NTDDKCOMP__
#if DX8
#include <d3d8.h>
#include <ddrawint.h>
#else
#include <d3d.h>
#endif
#endif

#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
#ifndef _WIN32_WINNT    // If this is NT 3.5x
#include <windows.h>    // NT 3.5, need Win32 API Fct Protos
#endif                  // If this is >= NT 4.0
#include <gl\gl.h>

#include "lines.h"
#ifdef NVD3D
#include "nvProcMan.h"
    #include "dmemmgr.h"
#endif
#include "memstruc.h"
#include "nvos.h"
#include "nvntioctl.h"
#include "nvEscDef.h"
#if defined(_WIN64)
#include "nvEscDef32.h"
#endif

// This file used to include driver.h but that included (indirectly) nv32.h
// Some of the files in the winnt4/displays/nv_disp directory needed to use specialized (older)
// versions of nv32.h (eg: nv1_32.h, oldnv332.h).  To resolve this issue (for now)
// I've moved the inclusion of driver.h into each of the files that needed it.  This allows
// each to include any specialized version of the nv32 header as needed.  -mlavoie

#include "debug.h"
#include "machdep.h"
#include "nvMultiMon.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\rectutils.c ===
/*
** $Header$
**
** MODULE:   rectutils.c
**
** AUTHOR:   FNicklisch, (c) nVidia GmbH
**
** DESCR:    Basic rectangle functions for Top Down coordinates
**           Bottom Up coordinates have BU at end of name
**
** History:
**   FNicklis 28.03.1996: created      
**   db       23.09.1996: RectDrawSingle added
**   KLux     05.11.1997: New enumeration functions for complex lists
**   FNicklis 11.12.1997: moved prototypes from enum.h
**   FNicklis 13.05.1998: remaming of inlines completed
**   FNicklis 19.06.1999: used in nVidia single and multiboard driver branches
**   FNicklis 10.08.1999: ported to OpenGL project
**   FNicklis 25.08.1999: new functions for Bottom Up coordinate space
**   FNicklisch 05.07.2001: ported to nvidia
*/

#include "precomp.h"
#include "driver.h"

// export
#include "rectutils.h"

/*
** ************************************************************************ 
** * main routines, chip independent                                      *
** ************************************************************************
*/

/*
** lRclMinusRcl
**
** calculates rclBounds - rclMinus, which may have 0 to 4 
** resulting rectangles stored in the prclResult array.
**
** return:
**   1-4 number of resulting rects stored in prclResult
**   0   nothing left from rclBounds, no rectangle stored.
**
** FNicklis 11.07.97: New
** FNicklis 21.10.98: simplified interface
*/
LONG lRclMinusRcl(OUT RECTL prclResult[],
                    IN  const RECTL *prclBounds, 
                    IN  const RECTL *prclMinus)
{
    RECTL rclWork;          // Copy of rclBounds we work on.
    RECTL rclHelp = {0};    // Intersecting rect between bounds and minus (part of minus within bounds)
    LONG  lRects  = 0;      // default exit
    
    ASSERTDD(NULL!=prclResult, "lRclMinusRcl: NULL==prclResult");
    ASSERTDD(NULL!=prclBounds, "lRclMinusRcl: NULL==prclBounds");
    //ASSERTDD(NULL!=prclMinus,   "lRclMinusRcl: NULL==prclMinus");
    
    // Minus is a non recangle (point) inside Bounds?
    if (   (NULL==prclMinus)
        || ( bRclIsEmpty(prclMinus) && bRclIsIn(prclBounds, prclMinus) ) ) 
    { 
        // e.g. where pwo->coClient.rclBounds is a nul-rect on OGL-startup
        // Nothing to substract
        DISPDBG((DBG_LVL_RECT, "minus is 0 and inside prclBounds"));
        *prclResult = *prclBounds;
        lRects        = 1;
        goto Exit;
    }
    
    // if bounds is completely inside minus -> trivial case
    if (bRclIsIn (prclMinus, prclBounds)) 
    { // Bounds inside Minus?
        DISPDBG((DBG_LVL_RECT, "bounds is inside minus, nothing left"));
        *prclResult = *prclBounds;
        lRects        = 0;
        goto Exit;
    }
    
    // if bounds isn't intersecting minus -> trivial case
    if (   !bRclIntersect(&rclHelp, prclBounds, prclMinus)
        || bRclIsEmpty(&rclHelp) )
    {
        DISPDBG((DBG_LVL_RECT, "not intersection (trivial case)"));
        *prclResult = *prclBounds;
        lRects        = 1;
        goto Exit;
    }
    
    // No we have the rect that has to be cut form bounds inside 
    // rclHelp. We make a copy of bounds (work) and run around help cutting
    // of overlapping parts from work. These parts are stored to the array.
    // The last remaing rect in work has to be equal help!
    
    //              H=minus rect
    //   111111111               11 111 111 11
    //   111111111               2H hhh 2H3 H2
    //   222HHH333               
    //   222HHH333               11      1  11
    //   222444333               2H 1H2  H  H2
    //   222444333               23      2  32
    //                           
    //
    rclWork = *prclBounds;
    
    // take rect above rclHelp
    prclResult[lRects].top    = rclWork.top;    
    prclResult[lRects].left   = rclWork.left;   
    prclResult[lRects].right  = rclWork.right;
    prclResult[lRects].bottom = rclHelp.top;  // ***
    
    if (!bRclIsEmpty(&prclResult[lRects])) 
    {
        // shrink rclWork and count rect
        rclWork.top = rclHelp.top;
        lRects++;
    }
    
    // take rect on the left side of rclHelp
    prclResult[lRects].top    = rclWork.top;
    prclResult[lRects].left   = rclWork.left;
    prclResult[lRects].right  = rclHelp.left; // ***
    prclResult[lRects].bottom = rclWork.bottom;
    
    if (!bRclIsEmpty(&prclResult[lRects])) 
    {
        // shrink rclWork and count rect
        rclWork.left = rclHelp.left;
        lRects++;
    }
    
    // take rect on the right side of rclHelp
    prclResult[lRects].top    = rclWork.top;
    prclResult[lRects].left   = rclHelp.right; // ***
    prclResult[lRects].right  = rclWork.right;
    prclResult[lRects].bottom = rclWork.bottom;
    
    if (!bRclIsEmpty(&prclResult[lRects])) 
    {
        // shrink rclWork and count rect
        rclWork.right = rclHelp.right;
        lRects++;
    }
    
    // take remaing rect below rclHelp
    prclResult[lRects].top    = rclHelp.bottom; // ***
    prclResult[lRects].left   = rclWork.left;
    prclResult[lRects].right  = rclWork.right;
    prclResult[lRects].bottom = rclWork.bottom;
    
    if (!bRclIsEmpty(&prclResult[lRects])) 
    {
        // shrink rclWork and count rect
        rclWork.bottom = rclHelp.bottom;
        lRects++;
    }
    
Exit:
    return(lRects);
} // lRclMinusRcl


/*
** lRclIntersectExclude
**
** stores a In rect to a Out rect cliped against bounds minus Exclude.
** This can result in up to four rectangles!
**
** out = (In - Exclude) & Bounds
**
** bounds, 
**
** Returns number of resulting rects.
**
** FNicklis 08.10.98: New
*/
LONG lRclIntersectExclude(
  OUT RECTL *prclOut,        // array of up to four resulting rectangles
  IN const RECTL  *prclIn,         // rect stored to Out
  IN const RECTL  *prclBounds,     // Has to be clipped against In
  IN const RECTL  *prclExclude)    // exclude must not be part of Out
{
  LONG lRet = 0;

  if (prclBounds)
  {
    // calculate intersection
    if (bRclIntersect(prclOut, prclIn, prclBounds))
    {
      lRet++;
    }
  }
  else
  {
    *prclOut = *prclIn;
    lRet++;
  }

  if ( (0 != lRet) && (NULL!=prclExclude) )
  {
    RECTL rclTemp = *prclOut; // Make a copy!

    // exclude prclExclude this rectangle from prclOut
    // this gives up to four new rectangles!

    // substract exclude from out
    lRet = lRclMinusRcl(prclOut, &rclTemp, prclExclude);
  }

#ifdef DEBUG
  // preset the unused rectangles to show a failure in screen!
  if ( 0 == lRet )
  {
    LONG l;
    for (l=0;l<4;l++)
      prclRclSetXYWH(prclOut+l, 0,0, 1024,768); // don't have ppdev, hardcoded rectangle
  }
#endif

  return (lRet);
}


// functions tests if prclSubject is left or above the prclReference
BOOL bIsLeftOrAbove(RECTL *prclSubject, RECTL *prclReference)
{
  BOOL bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_RECT, bIsLeftOrAbove);
  ASSERT(NULL!=prclSubject);
  ASSERT(NULL!=prclReference);

  if (prclSubject->right <= prclReference->left)
    bRet = TRUE;
  else
    if (prclSubject->bottom <= prclReference->top)
      bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_RECT, bRet);
  return bRet;
}

// functions tests if prclSubject is right or above the prclReference
BOOL bIsRightOrAbove(RECTL *prclSubject, RECTL *prclReference)
{
  BOOL bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_RECT, bIsRightOrAbove);
  ASSERT(NULL!=prclSubject);
  ASSERT(NULL!=prclReference);

  if (prclSubject->left >= prclReference->right)
    bRet = TRUE;
  else
    if (prclSubject->bottom <= prclReference->top)
      bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_RECT, bRet);
  return bRet;
}

// functions tests if prclSubject is left or below the prclReference
BOOL bIsLeftOrBelow(RECTL *prclSubject, RECTL *prclReference)
{
  BOOL bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_RECT, bIsLeftOrBelow);
  ASSERT(NULL!=prclSubject);
  ASSERT(NULL!=prclReference);

  if (prclSubject->right <= prclReference->left)
    bRet = TRUE;
  else
    if (prclSubject->top >= prclReference->bottom)
      bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_RECT, bRet);
  return bRet;
}

// functions tests if prclSubject is right or below the prclReference
BOOL bIsRightOrBelow(RECTL *prclSubject, RECTL *prclReference)
{
  BOOL bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_RECT, bIsRightOrBelow);
  ASSERT(NULL!=prclSubject);
  ASSERT(NULL!=prclReference);

  if (prclSubject->left >= prclReference->right)
    bRet = TRUE;
  else
    if (prclSubject->top >= prclReference->bottom)
      bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_RECT, bRet);
  return bRet;
}


#if 0 //disabled

/*
** bRclDrawSingle_SW
**
** handles all rop2 with P and D, but only Solid brushes
**
** 290797 FNicklis new
*/
BOOL bRclDrawSingle_SW (SURFOBJ  *pso, 
                         RECTL    *prcl, 
                         BRUSHOBJ *pbo, 
                         POINTL   *pptlBrushOrg, 
                         ROP4     rop4) 
{
  PPDEV ppdev;
  UNALIGNED BYTE *pjData;
  BOOL  bRet=FALSE;
  BOOL  bReadAndModify=FALSE;
  ULONG ulSolidColor;
  ULONG ulColor;
  BYTE  *pjColor= (BYTE *)&ulColor;
  WORD  *pwColor= (WORD *)&ulColor;
  LONG  x,y;
  ULONG rop3;
  BOOL  bValidGDI;

  DISPDBG((DBG_LVL_SUBENTRY, "  bRclDrawSingle_SW {"));
  ASSERTDD(NULL != pso,          "bRclDrawSingle_SW: pso == NULL");
  ASSERTDD(NULL != pso->dhpdev,  "bRclDrawSingle_SW: pso->dhpdev == NULL");
  ASSERTDD(NULL != prcl,         "bRclDrawSingle_SW: prcl == NULL");
  ASSERTDD(!bRectIsEmpty(prcl), "bRclDrawSingle_SW: prcl is empty rect");

  ppdev = (PPDEV)pso->dhpdev;

  ulSolidColor = pbo->iSolidColor;
  if ((ULONG)-1 == ulSolidColor) {
    DISPDBG((DBG_LVL_PUNT, "    ERROR in bRclDrawSingle_SW: Not a solid brush -> leaving"));
    goto Exit;
  }

  rop3 = (rop4>>8) & 0xff;

  if ((rop4 & 0xff) != rop3) {
    DISPDBG((DBG_LVL_PUNT, "    ERROR in bRclDrawSingle_SW: FG!=BG ROP:0x%x",rop4));
    goto Exit;
  }

  // Check basic 16 rops, 5 do not need to read destination -> set ulColor
  if (rop3==ROP3_P) {
    // Copy
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:P"));
    ulColor=ulSolidColor;

  } else if (rop3==ROP3_0) {
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:0"));
    ulColor=0;

  } else if (rop3==ROP3_1) {
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:1"));
    ulColor=1;

  } else if (rop3==ROP3_D) {
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:D(nop)"));
    bRet = TRUE; // NOP
    goto Exit;

  } else if (rop3==ROP3_Pn) {
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:Pn"));
    ulColor=~ulSolidColor;

  } else {
    // Have to read destination
    DISPDBG((DBG_LVL_FLOW1,    "    rop3:0x%x", rop3));
    if (rop3==ROP3_DPna ||
        rop3==ROP3_DPno){
      DISPDBG((DBG_LVL_FLOW1,    " ?Pn?"));
      ulSolidColor=~ulSolidColor; // remember inverted solid color
    }
    bReadAndModify=TRUE;
  }

  pjData = ((BYTE *)pso->pvScan0) + prcl->top*pso->lDelta + prcl->left*ppdev->cjPelSize;

  DISPDBG((DBG_LVL_FLOW1,    " ulSolidColor:0x%x",ulSolidColor));
  vDbg_PrintRECTL(DBG_LVL_FLOW1, "    prcl:",prcl);
  DISPDBG((DBG_LVL_FLOW1,    "    iBytePerPixel:%d, ulBitCount:%d",iBytePerPixel,ppdev->ulBitCount));
  DISPDBG((DBG_LVL_FLOW1,    "    pvScan0:0x%x, lDelta:0x%x", pso->pvScan0,pso->lDelta));

  for (y=0; y<lRectHeight(prcl); y++) {
    UNALIGNED BYTE *pujWork  = (BYTE *)pjData;
    UNALIGNED WORD *puwWork =  (WORD *)pjData;
    ULONG *pulWork = (ULONG *)pjData;

    //DISPDBG((DBG_LVL_FLOW1, "    %d: pjData:0x%x", y, pjData));
    for (x=0; x<lRectWidth(prcl); x++) {

      // handle rops that need to read the destination?
      if (bReadAndModify) {
        // Read Destination
        UCDISPDBG(("WARNING bRclDrawSingle_SW called with rop, but not testet! - remove this line when OK"));
        switch (iBytePerPixel) {
          case 1:
            pjColor[0] = *pujWork;
            break;
          case 2:
            pwColor[0] = *puwWork;
            break;
          case 3:
            pjColor[0] = pujWork[0];
            pjColor[1] = pujWork[1];
            pjColor[2] = pujWork[2];
            break;
          case 4:
            ulColor = *pulWork;
            break;
          default:
            DISPDBG((DBG_LVL_ERROR, "    ERROR in bRclDrawSingle_SW: unknown iBytePerPixel=%d",iBytePerPixel));
            break;
        }
        // Destination Data from framebuffer now in ulColor

        if (ROP3_PDna==rop3 ||  
            ROP3_PDno==rop3 ||
            ROP3_Dn  ==rop3) {
          // Invert Destination
          ulColor = ~ulColor; 
        }

        // Now combine D and P
        if (ROP3_DPna==rop3 ||
            ROP3_PDna==rop3 ||
            ROP3_DPan==rop3 ||
            ROP3_DPa==rop3) {
          // D and P
          ulColor = ulColor & ulSolidColor; 
        } else if (ROP3_DPno==rop3 ||
                   ROP3_PDno==rop3 ||
                   ROP3_DPo ==rop3 ||
                   ROP3_DPon==rop3) {
          // D or P
          ulColor = ulColor | ulSolidColor; 
        } else if (ROP3_DPx ==rop3 ||
                   ROP3_PDxn==rop3) {
          // D xor P
          ulColor = ulColor ^ ulSolidColor;
        } 

        // Now if necesssary invert the result
        if (ROP3_DPan ==rop3 ||
            ROP3_PDxn==rop3 ||
            ROP3_DPon==rop3) {
          ulColor = ~ulColor; 
        }
      } // if ..bReadAndModify (ROPS)

      // Come here and copy the resulting color to the destination
      switch (iBytePerPixel) {
        case 1:
          *pujWork++ = pjColor[0];
          break;
        case 2:
          *puwWork++ = pwColor[0];
          break;
        case 3:
          *pujWork++ = pjColor[0];
          *pujWork++ = pjColor[1];
          *pujWork++ = pjColor[2];
          break;
        case 4:
          *pulWork++ = ulColor;
          break;
        default:
          DISPDBG((DBG_LVL_ERROR, "    ERROR in bRclDrawSingle_SW: unknown iBytePerPixel=%d",iBytePerPixel));
          break;
      }
    }
    pjData += pso->lDelta;
  }
  if (bValidGDI) ppdev->ReenableHwAccelAccess(ppdev); 

  bRet = TRUE;

Exit:
  DISPDBG((DBG_LVL_SUBENTRY, "  } RDS_SW: %s", bRet?"TRUE":"FALSE"));
  return bRet;
} // end of bRclDrawSingle_SW

#endif

/*
** same as vRclAddOffset but working on array
*/
VOID vRclListAddOffset(
       OUT RECTL *pTrg,     // output array long enough to store c rects
  const IN RECTL *pSrc,     // input array with c rects
        IN ULONG  c,        // number of rects to transform
        IN LONG   lXOffset, // x offset to add 
        IN LONG   lYOffset) // x offste to add
{
  ULONG cRect;
  ASSERT(NULL!=pTrg);
  ASSERT(NULL!=pSrc);

  for (cRect=0; cRect<c; cRect++)
  {
    vRclAddOffset(pTrg+cRect, pSrc+cRect, lXOffset, lYOffset);
  }
}

/*
** same as vRclSubOffset but working on array
*/
VOID vRclListSubOffset(
       OUT RECTL *pTrg,     // output array long enough to store c rects
  const IN RECTL *pSrc,     // input array with c rects
        IN ULONG  c,        // number of rects to transform
        IN LONG   lXOffset, // x offset to add 
        IN LONG   lYOffset) // x offste to add
{
  ULONG cRect;
  ASSERT(NULL!=pTrg);
  ASSERT(NULL!=pSrc);

  for (cRect=0; cRect<c; cRect++)
  {
    vRclSubOffset(pTrg+cRect, pSrc+cRect, lXOffset, lYOffset);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\RectUtils.h ===
#ifndef _RECT_UTILS_H
#define _RECT_UTILS_H

/*
** $Header$
**
** MODULE:   Rect_Utils.h
**
** AUTHOR:   FNicklis, (c) nVidia GmbH
**
** DESCR:    Basic rectangle functions for Top Down coordinates
**           Bottom Up coordinates have BU at end of name
**
** History:
**   MSchwarzer 10/17/2000: integrated from other codebase
*/

/* *** Basic Rectangle Functions *** */

static RECTL rclEmpty   = { 0,0,0,0 };
static RECTL rclOutside = {-1,-1,-1,-1};

// returns TRUE if Src1 intersects Src2 and intersection rect is stored to Trg
BOOL _inline bRclIntersect (
        OUT RECTL *Trg,  // can be NULL
  const IN  RECTL *Src1, // NULL not allowed
  const IN  RECTL *Src2) // NULL not allowed
{
  BOOL bRet=FALSE;

  ASSERT(NULL!=Src1);
  ASSERT(NULL!=Src2);

  if (   (Src1->left   >= Src2->right ) 
      || (Src1->right  <= Src2->left  ) 
      || (Src1->top    >= Src2->bottom) 
      || (Src1->bottom <= Src2->top   ) ) 
  {
    //Skuklik : If NO intersection, the resulting rectangle should be empty (0,0,0,0)
    if (Trg)
    {
      *Trg = rclEmpty;
    }
    goto Exit;
  }

  bRet = TRUE;

  if (NULL == Trg) 
  {
    goto Exit;
  }

  Trg->left     = max(Src1->left,   Src2->left);
  Trg->right    = min(Src1->right,  Src2->right);
  Trg->top      = max(Src1->top,    Src2->top);
  Trg->bottom   = min(Src1->bottom, Src2->bottom);

Exit:
  return(bRet);
}

// NULL params not allowed
BOOL _inline bRclIntersectBU (RECTL *Trg, const RECTL *Src1, const RECTL *Src2)
{
  BOOL bRet=FALSE;

  ASSERT(NULL!=Src1);
  ASSERT(NULL!=Src2);

  if (   (Src1->left   >= Src2->right ) 
      || (Src1->right  <= Src2->left  ) 
      || (Src1->bottom >= Src2->top   ) 
      || (Src1->top    <= Src2->bottom) ) 
  {
    goto Exit;
  }

  bRet = TRUE;

  if (NULL == Trg) 
  {
    goto Exit;
  }

  Trg->left     = max(Src1->left,   Src2->left);
  Trg->right    = min(Src1->right,  Src2->right);
  Trg->top      = min(Src1->top,    Src2->top);
  Trg->bottom   = max(Src1->bottom, Src2->bottom);

Exit:
  return(bRet);
}

// NULL params not allowed
BOOL _inline bRclIsEmpty(const RECTL *Src)
{
  BOOL bRet=FALSE;

  ASSERT(NULL!=Src);
  if ( ((Src->right  - Src->left) <= 0) || 
       ((Src->bottom - Src->top) <= 0) ) 
  {
    bRet = TRUE;
  }

  return(bRet);
}

// NULL params not allowed
LONG _inline lRclWidth(const RECTL *pSrc)   
{
  ASSERT(NULL!=pSrc);
  return (pSrc->right - pSrc->left); 
}

// NULL params not allowed
LONG _inline lRclHeight(const RECTL *pSrc)   
{
  ASSERT(NULL!=pSrc);
  return (pSrc->bottom - pSrc->top); 
}

// NULL params not allowed
LONG _inline lRclHeightBU(const RECTL *pSrc)   
{
  ASSERT(NULL!=pSrc);
  return (pSrc->top - pSrc->bottom); 
}

// NULL params not allowed
void _inline vRclSubOffset(OUT RECTL *pTrg, const IN RECTL *pSrc, IN LONG lXOffset, IN LONG lYOffset)
{

  ASSERT(NULL!=pSrc);
  ASSERT(NULL!=pTrg);

  pTrg->left     = pSrc->left   - lXOffset;
  pTrg->right    = pSrc->right  - lXOffset;
  pTrg->top      = pSrc->top    - lYOffset;
  pTrg->bottom   = pSrc->bottom - lYOffset;

  return;
}

//
// add the origin of the src rect to the dest rect
//
void __inline vRclAddOrigin(IN OUT PRECTL prclDest, const IN PRECTL prclSrc)
{
  LONG xOrigin, yOrigin;

  ASSERT(NULL != prclDest);
  ASSERT(NULL != prclSrc);
  
  xOrigin = prclSrc->left;
  yOrigin = prclSrc->top;

  prclDest->left   += xOrigin;
  prclDest->top    += yOrigin;
  prclDest->right  += xOrigin;
  prclDest->bottom += yOrigin;
}

// NULL params not allowed
void _inline vRclAddOffset (OUT RECTL *pTrg, const IN RECTL *pSrc, IN LONG lXOffset, IN LONG lYOffset)
{

  ASSERT(NULL!=pSrc);
  ASSERT(NULL!=pTrg);

  pTrg->left     = pSrc->left   + lXOffset;
  pTrg->right    = pSrc->right  + lXOffset;
  pTrg->top      = pSrc->top    + lYOffset;
  pTrg->bottom   = pSrc->bottom + lYOffset;

  return;
}


// NULL params not allowed
void _inline vRclBounds (OUT RECTL *Trg, IN const RECTL *Src1, IN const RECTL *Src2) 
{

  ASSERT(NULL!=Src1);
  ASSERT(NULL!=Src2);
  ASSERT(NULL!=Trg );

  Trg->left     = min(Src1->left,   Src2->left);
  Trg->right    = max(Src1->right,  Src2->right);
  Trg->top      = min(Src1->top,    Src2->top);
  Trg->bottom   = max(Src1->bottom, Src2->bottom);

  return;
}

// NULL params not allowed
BOOL _inline bRclCombine(IN OUT RECTL *prclInOut, IN const RECTL *prclNew)  
{
  BOOL bRet=TRUE;


  ASSERT(NULL != prclInOut);
  ASSERT(NULL != prclNew);

  if (prclNew->top == prclInOut->bottom)
  {
    if (prclNew->left == prclInOut->left && prclNew->right == prclInOut->right)
    {
      prclInOut->bottom = prclNew->bottom;
      goto Exit;
    }
  }
  if (prclNew->bottom == prclInOut->top)
  {
    if (prclNew->left == prclInOut->left && prclNew->right == prclInOut->right)
    {
      prclInOut->top = prclNew->top;
      goto Exit;
    }
  }
  if (prclNew->left == prclInOut->right)
  { 
    if (prclNew->top == prclInOut->top && prclNew->bottom == prclInOut->bottom)
    {
      prclInOut->right = prclNew->right;
      goto Exit;
    }
  }
  if (prclNew->right == prclInOut->left)
  {
    if (prclNew->top == prclInOut->top && prclNew->bottom == prclInOut->bottom)
    {
      prclInOut->left = prclNew->left;
      goto Exit;
    }
  }
  bRet=FALSE;

Exit:
  return(bRet);
}

/*
** Checks if inner rectangle is completly inside or equal 
** the outer rectangle.
** TRUE:  inner is completly surrounded by outer.
** FALSE: inner intersects outer or is outside
**
** 20.06.96 fi
*/ 
//FN it was time enough to use the new name: #define E_RclIsIn bRclIsIn 
// NULL params not allowed
_inline BOOL bRclIsIn (IN const RECTL *outer, IN const RECTL *inner) 
{
  BOOL bRet;

  ASSERT(NULL != outer);
  ASSERT(NULL != inner);
  bRet = ((outer->left <= inner->left) && (outer->right  >= inner->right) &&  // x-check
          (outer->top  <= inner->top)  && (outer->bottom >= inner->bottom));   // y-check

  return bRet;
} // end of bRclIsIn


/*
** Checks if inner rectangle is completly inside or equal 
** the outer rectangle.
** TRUE:  inner is completly surrounded by outer.
** FALSE: inner intersects outer or is outside
**
** 20.06.96 fi
*/ 
//FN it was time enough to use the new name: #define E_RclIsIn bRclIsIn 
// NULL params not allowed
_inline BOOL bRclIsInBU (IN const RECTL *outer, IN const RECTL *inner) 
{
  BOOL bRet;

  ASSERT(NULL != outer);
  ASSERT(NULL != inner);
  bRet = ((outer->left <= inner->left) && (outer->right  >= inner->right) &&  // x-check
          (outer->top  >= inner->top)  && (outer->bottom <= inner->bottom));   // y-check

  return bRet;
} // end of bRclIsInBU


// Checks whether a point is inside the rect
// NULL params not allowed
BOOL _inline bRclPtlInside (IN const RECTL *prcl, IN const POINTL *pptl)
{
  BOOL bRet;

  ASSERT(NULL!=prcl);
  ASSERT(NULL!=pptl);

  if ((pptl->x      < prcl->left)    || 
	    (pptl->x      >= prcl->right)  ||  // right border is outside the rect
      (pptl->y      < prcl->top)     || 
	    (pptl->y      >= prcl->bottom) )   // bottom border is outside
  { 
    // bottom border is outside the rect
    bRet = FALSE;
  }
  else
  {
    // Point is inside
    bRet = TRUE;
  }

  return(bRet);
}

// Checks whether a point is inside the rect
// NULL params not allowed
BOOL _inline bRclPtlInsideBU(IN const RECTL *prcl, IN const POINTL *pptl)
{
  BOOL bRet;

  ASSERT(NULL!=prcl);
  ASSERT(NULL!=pptl);

  if ((pptl->x      < prcl->left)    || 
	    (pptl->x      >= prcl->right)  ||  // right border is outside the rect
      (pptl->y      >= prcl->top)    ||  // top border is outside
	    (pptl->y      < prcl->bottom) ) 
  { 
    // bottom border is outside the rect
    bRet = FALSE;
  }
  else
  {
    // Point is inside
    bRet = TRUE;
  }

  return(bRet);
}

// Sets all members to 0
// NULL param allowed
VOID _inline vRclClear (OUT RECTL *prcl)
{
  if (prcl) {
    prcl->left   =
    prcl->right  =
    prcl->top    =
    prcl->bottom = 0;
  }
}

// **FN** 100697 Compares two rects either by pointer or members
// NULL params allowed
_inline BOOL bRclIsEqual (IN const RECTL *prcl1, IN const RECTL *prcl2)
{
  BOOL bRet;
 
  if (prcl1==prcl2) 
  {
    // both are equal pointers or NULL
    bRet = TRUE;

  } 
  else if (prcl1 && prcl2) 
  {
    // both point to a rect, compare members
    bRet =  (prcl1->left   == prcl2->left   &&
            prcl1->right  == prcl2->right  &&
            prcl1->top    == prcl2->top    &&
            prcl1->bottom == prcl2->bottom);
  } 
  else 
  {
    // One is NULL
    bRet = FALSE;
  }
  return (bRet);
} // end of bRclIsEqual 

__inline RECTL *prclRclOrder(OUT RECTL *prclOrdered, IN RECTL *prclIn)
{
  *prclOrdered = *prclIn; // Make a copy of the src rect

  ASSERT(prclOrdered!=prclIn);
  ASSERT(prclOrdered!=NULL);
  ASSERT(prclIn!=NULL);

  // Then check for ordering
  if (prclIn->left>prclIn->right)  {
    prclOrdered->left  = prclIn->right;
    prclOrdered->right = prclIn->left;
  }
  if (prclIn->top>prclIn->bottom)  {
    prclOrdered->top = prclIn->bottom;
    prclOrdered->bottom = prclIn->top;
  }

  return (prclOrdered);
}


// FN 031197
// Exchanges data of both input structs and returns a pointer to the first param if successful or NULL
__inline RECTL *prclRclSwap(IN OUT RECTL *prcl1, IN OUT RECTL *prcl2)
{
  RECTL rclTemp;

  if (NULL==prcl1 || NULL==prcl2) 
  {
    DISPDBG((0, "  ERROR in prclRclSwap: NULL rect - prcl1:0x%x, prcl2:0x%x",prcl1, prcl2));
    prcl1 = NULL;
  } 
  else 
  {
    rclTemp = *prcl1;
    *prcl1  = *prcl2;
    *prcl2  = rclTemp;
  }
  return (prcl1);
} // end of prclRclSwap


// FN 031197
// Exchanges data of both input structs and returns a pointer to the first param if successful or NULL
__inline SIZEL *psizSizeSwap(IN OUT SIZEL *psiz1, IN OUT SIZEL *psiz2)
{
  SIZEL sizTemp;

  if (NULL==psiz1 || NULL==psiz2) {
    DISPDBG((0, "  ERROR in psizSizeSwap: NULL size - psiz1:0x%x, psiz2:0x%x",psiz1, psiz2));
    psiz1 = NULL;
  } else {
    sizTemp = *psiz1;
    *psiz1  = *psiz2;
    *psiz2  = sizTemp;
  }
  return (psiz1);
} // end of psizSizeSwap

__inline RECTL *prclRclSetXYWH(OUT RECTL *prcl, IN LONG left, LONG top, 
                                   LONG width, LONG height)
{
  if (NULL!=prcl) {
    prcl->left   = left;
    prcl->right  = left + width;
    prcl->top    = top;
    prcl->bottom = top + height;
  }
  return prcl;
}

// FNicklis 01.11.98: counts the pixels in a rect (w*h)
__inline LONG lRclPixelCount(IN const RECTL *prcl)
{
  return (lRclWidth(prcl) * lRclHeight(prcl));
}

/*
** vRclTopDownToBottomUp
** transformation from TopDown to BottomUp coordinate space
*/
__inline VOID vRclTopDownToBottomUp(
  OUT RECTL *prclBottomUp,
  IN  RECTL *prclTopDown,
  IN  RECTL *prclReference) // taken as reference to perform transformation (need height)
{
  LONG lReferenceHeight;

  ASSERT(NULL!=prclBottomUp);
  ASSERT(NULL!=prclTopDown);

  lReferenceHeight = lRclHeight(prclReference);

  prclBottomUp->left   = prclTopDown->left;
  prclBottomUp->right  = prclTopDown->right;

  prclBottomUp->bottom = lReferenceHeight - prclTopDown->bottom;
  prclBottomUp->top    = lReferenceHeight - prclTopDown->top;
}

// vRclBottomUpToTopDown is simply the same as vRclTopDownToBottomUp
#define vRclBottomUpToTopDown vRclTopDownToBottomUp


// prclSrc copies contents of prclSrc to prclDst
__inline VOID vRclCopy(OUT RECTL *prclDst, IN RECTL *prclSrc)
{
    ASSERT(prclDst);
    ASSERT(prclSrc);
    *prclDst = *prclSrc; // Make a copy of the src rect
}


LONG lRclMinusRcl(OUT RECTL prclDest[], IN const RECTL *prclSrc, IN const RECTL *prclMinus);

LONG lRclIntersectExclude(
  OUT RECTL *prclOut,              // array of up to four resulting rectangles
  IN const RECTL  *prclIn,         // rect stored to Out
  IN const RECTL  *prclBounds,     // Has to be clipped against In
  IN const RECTL  *prclExclude);   // exclude must not be part of Out

BOOL bIsLeftOrAbove(RECTL *prclSubject, RECTL *prclReference);
BOOL bIsRightOrAbove(RECTL *prclSubject, RECTL *prclReference);
BOOL bIsLeftOrBelow(RECTL *prclSubject, RECTL *prclReference);
BOOL bIsRightOrBelow(RECTL *prclSubject, RECTL *prclReference);
VOID vRclListAddOffset(OUT RECTL *pTrg, const IN RECTL *pSrc, IN ULONG c, IN LONG lXOffset, IN LONG lYOffset);
VOID vRclListSubOffset(OUT RECTL *pTrg, const IN RECTL *pSrc, IN ULONG c, IN LONG lXOffset, IN LONG lYOffset);

#endif //#define _RECT_SUP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\savescreenbits.c ===
//************************* Module Header **************************************
//                                                                             *
//  Module Name: SaveScreenBits.c                                              *
//                                                                             *
//  This module contains the DrvSaveScreenBits realization                     *
//                                                                             *
//   Copyright (C) 2000 NVidia Corporation. All Rights Reserved.               *
//                                                                             *
//                                                                             *
//  DrvSaveScreenBits it needed for use of opengl overlay to be able to exract *
//  and to restore the correct overlay contents                                *
//                                                                             *
//  This function is NV4 or better only !                                      * 
//                                                                             *
//******************************************************************************
#include "precomp.h"
#include "driver.h"
#include "oglDD.h"
#include "OglOverlay.h"
#include "oglstereo.h"
#include "oglsync.h"
#include "linkedlist.h"
#include "rectutils.h"
#include "nv32.h"
#include "nvcm.h"


#include "savescreenbits.h"

// Number of maximum stored screenbits before garbage collection is called.
#define MAX_SAVESCREENBITS 20

static BOOL bSaveScreenBitsFree(
    IN PPDEV        ppdev, 
    IN ULONG_PTR    ident, 
    IN SURFOBJ     *psoFree);

//
//  DrvSaveScreenBits
//
//  Saves away contents of the desktop before a popup-menue 
//  will apear and restores it after the popup has gone.
//  Function is mainly needed for opengl overlay apps for whom
//  we have to handle the overlay merging in this call.
//
//  NOTE: GDI has a bug. Starting an application from the start menu
//        will create (SS_SAVE) a couple of ScreenBits but not free 
//        them (SS_RESTORE/SS_FREE). Because of this bug we would 
//        leak memory and therefore we need a garbage collection which
//        is called from time to time. 
//        BTW: If any OpenGL is started, GDI behaves correctly. 
//
//  Return value: FALSE:   no action succeeded
//                TRUE:    if SS_RESTORE or SS_FREE succeeded
//                psoSave: if SS_SAVE succeeded   
//
ULONG_PTR APIENTRY DrvSaveScreenBits(
    SURFOBJ  *pso,
    ULONG    iMode,
    ULONG_PTR ident,
    RECTL    *prcl
    )
{
    ULONG_PTR  ulRet              = FALSE;
    PPDEV      ppdev              = NULL;
    POINTL     ptlSrc             = {0, 0};
    SURFOBJ   *psoSave            = NULL;  
    DSURF*     pdsurf             = NULL;
    HBITMAP    hbmpSave           = NULL;

    ASSERT(pso);

    ppdev = (PPDEV)pso->dhpdev;
    ASSERT(ppdev);

    DISPDBG((3,"DrvSaveScreenBits { pso:0x%p, iMode:%8s, ident:0x%08x, prcl:0x%p",pso,iMode==SS_SAVE?"SAVE":(iMode==SS_RESTORE?"RESTORE":(iMode==SS_FREE?"FREE":"unknown")),ident,prcl));

    // Disable DrvSaveScreenBits for NV4/NV5 for now since this causes
    // a crash in the kernel.  Not sure why but this is an urgent 
    // showstopper so we'll just disable it until we can talk to Yoko
    // about it.  Crash does not occur on NV10 and higher chips so
    // this should not affect overlays since they only run on NV10 and
    // higher.
    
    if (!(   HWGFXCAPS_QUADRO_GENERIC(ppdev)
          && (   bOglIsOverlayModeEnabled(ppdev)
              || bOglIsStereoModeEnabled(ppdev)
             ) 
       ) )
    {
        switch(iMode) 
        {
            case SS_SAVE:
                // Cleanup all collected screenbits as they're not longer used.
                if (   HWGFXCAPS_QUADRO_GENERIC(ppdev)
                    && (ppdev->lSavedScreenBits > 0) )
                {
                    bSaveScreenBitsGarbageCollection(ppdev,0);
                }
                break;
            case SS_RESTORE:
                break;
            case SS_FREE:
                ulRet = TRUE;
                break;
            default:
                ASSERT(SS_SAVE==iMode);
                break;
        }
        goto Exit;
    }

#if (NVARCH >= 0x4)
    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowRect(ppdev,pso,prcl,NULL);        
    }

    ASSERT(NULL!=ppdev->pLinkedListSaveScreenBits)
    ASSERT(NULL!=ppdev->pfnCopyBlt);
    ASSERT(NULL!=ppdev->pfnScreenToMemBlt);
    ASSERT(NULL!=ppdev->pfnMemToScreenBlt);

    switch(iMode)
    {

        // The driver should save the data from the rectangle defined by prcl. 
        // The driver is responsible for managing this data in its off-screen 
        // memory. The ident parameter is ignored. 
        // Upon success, DrvSaveScreenBits should return an identifier for the 
        // saved data. The driver can return a handle or even a pointer to its 
        // off-screen memory. This function returns zero if it fails. 
        case SS_SAVE:
        {
            RECTL     rclTrg;
            SIZEL     sizlRect;
            ULONG     ulIdent;

            ASSERT(NULL!=prcl);
            DISPDBG((20,"DrvSaveScreenBits: iMode = SS_SAVE"));

            ppdev->ulSaveScreenBitsRefCounter++;
            if (0==ppdev->ulSaveScreenBitsRefCounter) // case of wrap around, avoid 0!
                ppdev->ulSaveScreenBitsRefCounter++;

            ulIdent = ppdev->ulSaveScreenBitsRefCounter;

            sizlRect.cx = lRclWidth(prcl);
            sizlRect.cy = lRclHeight(prcl);

            if( bOglIsOverlayModeEnabled(ppdev) )
                sizlRect.cy += lRclHeight(prcl);
            if( bOglIsStereoModeEnabled(ppdev) )
                sizlRect.cy += lRclHeight(prcl);

            // try to use offscreen memory
            hbmpSave = DrvCreateDeviceBitmap((DHPDEV)ppdev, sizlRect, pso->iBitmapFormat);

            if (!hbmpSave)
            {   
                //Not enough room in OFFSCREEN
                DISPDBG((2,"DrvSaveScreenBits: Not enough room in OffScreen for Bitmap")); 

                hbmpSave = EngCreateBitmap(sizlRect, 0, pso->iBitmapFormat, BMF_TOPDOWN, NULL);
                if(hbmpSave)
                {
                    EngAssociateSurface((HSURF)hbmpSave, ppdev->hdevEng, 0);
                }
                else
                {
                    DISPDBG((0, "DrvSaveScreenBits failed to get offscreen and host memory!"));
                    break;
                }
            }

            ASSERT(hbmpSave);
            ptlSrc.x = prcl->left;
            ptlSrc.y = prcl->top;

            psoSave = EngLockSurface((HSURF)hbmpSave);
            pdsurf  = (DSURF*)psoSave->dhsurf;

            rclTrg.left   = 0;
            rclTrg.right  = lRclWidth(prcl);
            rclTrg.top    = 0;
            rclTrg.bottom = lRclHeight(prcl);

            // stereo:  save frontleft + frontrigth
            // overlay: save frontleft (with mainplanefront for overlay clients) + overlayfront 

            // 1st screen to offscreen copy 
            if(IS_DEV_DEVICEBITMAP(psoSave))
            {
                ULONG      ulDstOffset;
                LONG       lDstStride;

                // source is our primary
                ppdev->pfnSetSourceBase(ppdev,ppdev->ulPrimarySurfaceOffset,ppdev->lDelta);
                // destination is device bitmap
                ulDstOffset = (ULONG)((BYTE *)(pdsurf->LinearPtr) - ppdev->pjFrameBufbase);
                lDstStride  = pdsurf->LinearStride;
                ppdev->pfnSetDestBase(ppdev, ulDstOffset , lDstStride);

                ppdev->pfnCopyBlt(ppdev, 1, &rclTrg, 0xcccc, &ptlSrc, &rclTrg, NULL);

                // special case handling for saving away overlay frontbuffer
                if( bOglIsOverlayModeEnabled(ppdev) )
                {
                    // if rclTrg intersects with opengl overlay application,copy frontbuffer
                    // contents without overlay of this client
                    bCopyIntersectingMainPlaneFrontToPSO( ppdev, pso, psoSave, &rclTrg, &ptlSrc);

                    rclTrg.top    += lRclHeight(prcl);
                    rclTrg.bottom += lRclHeight(prcl);

                    ASSERT(rclTrg.bottom <= psoSave->sizlBitmap.cy);

                    // source is our overlay frontbuffer
                    ppdev->pfnSetSourceBase(ppdev,
                                            ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT],
                                            ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT]);

                    ASSERT(NULL != ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt);
                    ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, &rclTrg, 0xcccc, &ptlSrc, &rclTrg, NULL);
                }
                    
                // special case handling for saving away stereo frontbufferleft
                if( bOglIsStereoModeEnabled(ppdev) )
                {
                    rclTrg.top    += lRclHeight(prcl);
                    rclTrg.bottom += lRclHeight(prcl);

                    ASSERT(rclTrg.bottom <= psoSave->sizlBitmap.cy);

                    // source is our overlay frontbuffer
                    ppdev->pfnSetSourceBase(ppdev,
                                            ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT],
                                            ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT]);

                    ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt );
                    ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, &rclTrg, 0xcccc, &ptlSrc, &rclTrg, NULL);
                }

            }
            // screen to mem copy
            else
            {
                ASSERT(!IS_DEVICEBITMAP(psoSave));
                // source is our primary
                ppdev->pfnSetSourceBase(ppdev,ppdev->ulPrimarySurfaceOffset,ppdev->lDelta);
                // destination is mainmemory => no call to ppdev->pfnSetDestBase needed

                ppdev->pfnScreenToMemBlt( ppdev, 1, &rclTrg, pso, psoSave, &ptlSrc, &rclTrg, NULL);

                if( bOglIsOverlayModeEnabled(ppdev) )
                {
                    PVOID pvLastDstOffset;

                    // if rclTrg intersects with opengl overlay application,copy frontbuffer
                    // contents without overlay of this client
                    bCopyIntersectingMainPlaneFrontToPSO( ppdev, pso, psoSave, &rclTrg, &ptlSrc);

                    // we need this structure for NV4ScreenToMemBlt
                    rclTrg.top    += lRclHeight(prcl);
                    rclTrg.bottom += lRclHeight(prcl);

                    ASSERT(rclTrg.bottom <= psoSave->sizlBitmap.cy);

                    // source is overlay frontbuffer
                    ppdev->pfnSetSourceBase(ppdev,
                                            ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT],
                                            ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT]);

                    // pfnScreenToMemBlt needs pso->dhsurf to determine src offset
                    pvLastDstOffset = ((DSURF*)pso->dhsurf)->LinearPtr;
                    ((DSURF*)pso->dhsurf)->LinearPtr = ppdev->pjFrameBufbase + ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT];
        
                    ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt );
                    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt( ppdev, 1, &rclTrg, pso, psoSave, &ptlSrc, &rclTrg, NULL);

                    // repair primary's LinearPtr
                    ((DSURF*)pso->dhsurf)->LinearPtr = pvLastDstOffset;
                }

                // special case handling for saving away stereo frontbufferleft
                if( bOglIsStereoModeEnabled(ppdev) )
                {
                    PVOID pvLastDstOffset;

                    rclTrg.top    += lRclHeight(prcl);
                    rclTrg.bottom += lRclHeight(prcl);

                    ASSERT(rclTrg.bottom <= psoSave->sizlBitmap.cy);

                    // source is our overlay frontbuffer
                    ppdev->pfnSetSourceBase(ppdev,
                                            ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT],
                                            ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT]);

                    // pfnScreenToMemBlt needs pso->dhsurf to determine src offset
                    pvLastDstOffset = ((DSURF*)pso->dhsurf)->LinearPtr;
                    ((DSURF*)pso->dhsurf)->LinearPtr = ppdev->pjFrameBufbase + ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT];
        
                    ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt );
                    ppdev->DoubleBuffer.SavedProcs.pfnScreenToMemBlt( ppdev, 1, &rclTrg, pso, psoSave, &ptlSrc, &rclTrg, NULL);

                    // repair primary's LinearPtr
                    ((DSURF*)pso->dhsurf)->LinearPtr = pvLastDstOffset;
                }

            }

            // remember number of actually stored popups to keep opengl overlay happy
            ppdev->lSavedScreenBits++;
            bLinkedListAddElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ulIdent, psoSave, 0);

            bSaveScreenBitsGarbageCollection(ppdev, MAX_SAVESCREENBITS);

            ulRet = (ULONG_PTR)ulIdent;
            break;
        }

        // The driver should restore the data identified by ident to the 
        // rectangle prcl on the display; that is, the driver should restore 
        // the bitmap to its original position. The driver can assume that 
        // the rectangle at prcl is exactly the same size as the rectangle 
        // that was saved. The data should be discarded after this call. 
        // DrvSaveScreenBits should return TRUE if the data has been restored 
        // to the display, or FALSE if the data cannot be restored. 
        case SS_RESTORE:
        {
            HSURF hsurf;
            DISPDBG((20,"DrvSaveScreenBits: iMode = SS_RESTORE"));

            //
            // special case handling for restoring overlay frontbuffer and stereo
            // frontbuffer left. Overlay/stereo mode may have been switched on 
            // between saving and restoring => check if overlay/stereo has been saved 
            // !!  we ( may get problems with stereo + overlay at the same time )
            //
            ASSERT(NULL!=prcl);
            if (bLinkedListGetElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ident, &psoSave))
            {
                ASSERT(NULL!= psoSave);
                pdsurf     = (DSURF*)psoSave->dhsurf;

                ptlSrc.x = 0;
                ptlSrc.y = 0;

                // offscreen to primary
                if(IS_DEV_DEVICEBITMAP(psoSave))
                {
                    ULONG      ulSrcOffset;
                    LONG       lSrcStride;

                    // source is device bitmap
                    ulSrcOffset = (ULONG)((BYTE *)(pdsurf->LinearPtr) - ppdev->pjFrameBufbase);
                    lSrcStride  = pdsurf->LinearStride;

                    ppdev->pfnSetSourceBase(ppdev, ulSrcOffset, lSrcStride);
                    // destination is our primary
                    ppdev->pfnSetDestBase(ppdev,ppdev->ulPrimarySurfaceOffset,ppdev->lDelta);

                    // for stereo case we don't allow bufferflipping and have to handle
                    // access to stereo frontbuffer in a NOT doublepumped case

                    // doublepump normal/overlay or flipped case
                    ppdev->pfnCopyBlt(ppdev, 1, prcl, 0xcccc, &ptlSrc, prcl, NULL);

                    if(   (bOglIsOverlayModeEnabled(ppdev))
                        &&( (ptlSrc.y + lRclHeight(prcl)) < psoSave->sizlBitmap.cy)
                       )
                    {
                        // set src pointer to saved away overlay content
                        ptlSrc.y += lRclHeight(prcl);

                        // destination is overlay frontbuffer
                        ppdev->pfnSetDestBase(ppdev,
                                              ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT],
                                              ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT]);



                        ASSERT(NULL!=ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt)
                        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, prcl, 0xcccc, &ptlSrc, prcl, NULL);

                        // if prcl intersects with opengl overlay application, do merge
                        // overlay of this client to desktop
                        bDoMergeBlitOnIntersectingRectangle(ppdev, prcl);
                    }

                    if(   (bOglIsStereoModeEnabled(ppdev))
                        &&( (ptlSrc.y + lRclHeight(prcl)) < psoSave->sizlBitmap.cy)
                       )
                    {
                        // set src pointer to saved away stereo content
                        ptlSrc.y += lRclHeight(prcl);

                        // destination is overlay frontbuffer
                        ppdev->pfnSetDestBase(ppdev,
                                              ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT],
                                              ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT]);

                        ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt );
                        ppdev->DoubleBuffer.SavedProcs.pfnCopyBlt(ppdev, 1, prcl, 0xcccc, &ptlSrc, prcl, NULL);
                    }

                }
                else
                // mainmemory to primary
                {
                    // destination is our primary
                    ppdev->pfnSetDestBase(ppdev,ppdev->ulPrimarySurfaceOffset,ppdev->lDelta);
                    // straight (maybe double pumped )mem to screen BLT.
                    ppdev->pfnMemToScreenBlt(ppdev, psoSave, &ptlSrc, prcl);

                    if(   (bOglIsOverlayModeEnabled(ppdev))
                        &&( (ptlSrc.y + lRclHeight(prcl)) < psoSave->sizlBitmap.cy)
                       )
                    {
                        // set src pointer to saved away overlay content
                        ptlSrc.y += lRclHeight(prcl);

                        // destination is overlay frontbuffer
                        ppdev->pfnSetDestBase(ppdev,
                                              ppdev->singleFrontOverlayOffset[OGL_STEREO_BUFFER_LEFT],
                                              ppdev->singleFrontOverlayPitch[OGL_STEREO_BUFFER_LEFT]);
                    
                        ASSERT( NULL != ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt );
                        ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt(ppdev, psoSave, &ptlSrc, prcl);

                        // if prcl intersects with opengl overlay application, do merge
                        // overlay of this client to desktop
                        bDoMergeBlitOnIntersectingRectangle(ppdev, prcl);
                    }

                    if(   (bOglIsStereoModeEnabled(ppdev))
                        &&( (ptlSrc.y + lRclHeight(prcl)) < psoSave->sizlBitmap.cy)
                       )
                    {
                        // set src pointer to saved away overlay content
                        ptlSrc.y += lRclHeight(prcl);

                        // destination is overlay frontbuffer
                        ppdev->pfnSetDestBase(ppdev,
                                              ppdev->singleFrontOffset[OGL_STEREO_BUFFER_RIGHT],
                                              ppdev->singleFrontPitch[OGL_STEREO_BUFFER_RIGHT]);

                        ASSERT(NULL!=ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt)
                        ppdev->DoubleBuffer.SavedProcs.pfnMemToScreenBlt(ppdev, psoSave, &ptlSrc, prcl);

                        // if prcl intersects with opengl overlay application, do merge
                        // overlay of this client to desktop
                        bDoMergeBlitOnIntersectingRectangle(ppdev, prcl);
                    }

                }

                // free it now
                ulRet = (ULONG_PTR)bSaveScreenBitsFree(ppdev, ident, psoSave);
            }
            else
            {
                DISPDBG((0, "DrvSaveScreenBits: tried to restore ident 0x%08x which is unknown", ident));
                ulRet = FALSE;
            }

            break;
        }

        
        // The data identified by ident is no longer needed and can be freed. 
        // The value of prcl is undefined and should not be used. The driver 
        // should not restore the saved rectangle to the display. 
        // DrvSaveScreenBits should return TRUE. 
        case SS_FREE:
        {
            DISPDBG((20,"DrvSaveScreenBits: iMode = SS_FREE"));
            
            // find ident and free it
            if (bLinkedListGetElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ident, &psoSave))
            {
                bSaveScreenBitsFree(ppdev, ident, psoSave);
            }
            else
            {
                DISPDBG((0, "DrvSaveScreenBits: tried to free ident 0x%08x which is unknown", ident));
            }
            ulRet = TRUE;
            break;
        }

        default:
        {
            ASSERT(SS_SAVE==iMode);
            ulRet = FALSE;
            break;
        }
    }

#endif //#if (NVARCH >= 0x4)
Exit:
    DISPDBG((3,"} DrvSaveScreenBits: 0x%08x, lSavedScreenBits:%d", ulRet,ppdev->lSavedScreenBits));
    return ulRet;
}


//*************************************************************************
// bSaveScreenBitsGarbageCollection
// 
// free and remove all saved ScreenBits data and only keep the given number
// of elements.
//*************************************************************************
BOOL bSaveScreenBitsGarbageCollection(
    IN PPDEV ppdev,
    IN ULONG ulKeep) // number of screenbits to keep.
{
    BOOL bRet = TRUE;

    while (ulKeep < ulLinkedListGetCountOfElements(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS))
    {
        ULONG_PTR ulIdent;
        SURFOBJ   *psoFree;

        
        ulIdent = 0;
        psoFree = NULL;
        if (bLinkedListGetOldestElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, &ulIdent, &psoFree))
        {
            ASSERT(NULL != psoFree);
            ASSERT(0    != ulIdent);

            DISPDBG((0, "bSaveScreenBitsGarbageCollection removing 0x%08x", ulIdent));

            bSaveScreenBitsFree(ppdev, ulIdent, psoFree);
        }
        else
        {
            bRet = FALSE;
            break;
        }
    }
    return (bRet);
}


//*************************************************************************
// bSaveScreenBitsFree
// 
// called to free a ScreenBits element and remove it from the linked list. 
// Is called in SS_FREE and the garbage collection routine.
//*************************************************************************
static BOOL bSaveScreenBitsFree(
    IN PPDEV        ppdev,
    IN ULONG_PTR    ident,   // Linked list identifier of node to free
    IN SURFOBJ     *psoFree) // surface to delete
{
    BOOL  bRet = FALSE;
    HSURF hsurf;

    ASSERT(NULL != ppdev);
    ASSERT(0    != ident);
    ASSERT(NULL != psoFree);

    ASSERT(bLinkedListGetElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ident, &psoFree));

    hsurf = psoFree->hsurf;

#if 0 // This code is necessary if DrvDeleteDeviceBitmap isn't exported!
// It is tested with 1.09 million popups over three days without
// any leakage.
    if(IS_DEVICEBITMAP(psoFree))
    {
        DrvDeleteDeviceBitmap(psoFree->dhsurf);
    }
#endif
    // NOTE: if hsurf is a device bitmap (created through EngCreateDeviceBitmap)
    //   EngDeleteSurface will call DrvDeleteDeviceBitmap if exported, to destroy 
    //   the pdsurf and poh.
    EngUnlockSurface(psoFree);

    EngDeleteSurface((HSURF)hsurf);

    // remove from linked list
    bLinkedListRemoveElement(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS, ident);

    // remember number of actually stored popups to keep opengl overlay happy
    ppdev->lSavedScreenBits--;

    ASSERT(ppdev->lSavedScreenBits >= 0);
    ASSERT(ppdev->lSavedScreenBits==(LONG)ulLinkedListGetCountOfElements(ppdev->pLinkedListSaveScreenBits, LL_CLASS_SAVESCREENBITS));

    bRet = TRUE;
    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\pointer.c ===
//******************************Module*Header***********************************
//
// Module Name: pointer.c
//
// This module contains the hardware pointer support for the display
// driver.  This supports both the built-in S3 hardware pointer and
// some common DAC hardware pointers.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 - 2000 NVidia Corporation. All Rights Reserved.        *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "nv32.h"

//******************************************************************************
// External declarations
//******************************************************************************

VOID ShowPointer(PDEV*   ppdev, BOOL bShow);

#ifdef NV3
extern VOID NV3MovePointer(PDEV *,LONG,LONG);
extern VOID NV3EnablePointer(PDEV *,BOOL);
extern ULONG NV3SetPointerShape(SURFOBJ *,SURFOBJ*,SURFOBJ*,XLATEOBJ*,LONG,LONG,LONG,LONG,LONG,LONG,BOOL);
#else
extern VOID NVMovePointer(PDEV *,LONG,LONG);
extern VOID NVEnablePointer(PDEV *,BOOL);
extern ULONG NVSetPointerShapeOn16BppHwMode(SURFOBJ *,SURFOBJ*,SURFOBJ*,XLATEOBJ*,LONG,LONG,LONG,LONG,LONG,LONG,BOOL);
extern ULONG NVSetPointerShapeOn32BppHwMode(SURFOBJ *,SURFOBJ*,SURFOBJ*,XLATEOBJ*,LONG,LONG,LONG,LONG,LONG,LONG,BOOL);
#endif
//******************************************************************************
//
//  Function:   DrvMovePointer
//
//  Routine Description:
//
//  NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
//        time, even while we're executing another drawing call!
//
//        Consequently, we have to explicitly synchronize any shared
//        resources.  In our case, since we touch the CRTC register here
//        and in the banking code, we synchronize access using a critical
//        section.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PDEV*   ppdev;
    BOOL    bRet;

    ppdev = (PDEV*) pso->dhpdev;
    if (x == -1)
    {
    //**************************************************************************
    // This is a request to hide the cursor.
    //**************************************************************************
    ppdev->pfnShowPointer(ppdev, FALSE);
    }
    else
    {
        //**************************************************************************
        // Move cursor to appropriate location
        //**************************************************************************
        ppdev->pfnMovePointer(ppdev, x, y);

#if _WIN32_WINNT >= 0x0500
        if(ppdev->ulPuntCursorToGDI)
            {
            ppdev->pfnWaitEngineBusy(ppdev);
            EngMovePointer(pso, x, y, prcl);
            }
#endif

    }

}

//******************************************************************************
//
//  Function:   DrvSetPointerShape
//
//  Routine Description:
//
//      Sets the new pointer shape.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)

    {
    PDEV*   ppdev;
    DWORD*  pul;
    ULONG   cx;
    ULONG   cy;
    BOOL    AlphaBlendedCursor;
    ULONG   ulReturnValue;
        
    ppdev = (PDEV*) pso->dhpdev;

    ulReturnValue = SPS_DECLINE;

    if (ppdev->flCaps & CAPS_SW_POINTER || !ppdev->bEnabled)
        goto DoneDrvSetPointerShape;

#if _WIN32_WINNT >= 0x0500

    if ( (fl & SPS_ALPHA) && (psoMsk == NULL) && (psoColor != NULL) )
        {
        //**********************************************************************
        // Handle Win2k Alpha blended cursors (ONLY if OpenGL is enabled)
        // Normally, we wouldn't attempt to handle alpha blended cursors because
        // our hardware doesn't support alpha blended cursors.
        // Unfortunately, when OpenGL is enabled, the alpha blended software cursor
        // is not visible on top of an OpenGL app.  So we're forced to 'handle' 
        // this case with our opaque hardware cursor, so that we can see the cursor.
        //
        // 2 side effects:
        //      1) Hardware only supports 32x32 cursors (up to NV5)
        //         So Alpha Blended cursors which width > 32 and height > 32
        //         may get clipped abruptly.
        //
        //      2) We ignore the alpha blended component of the bitmap
        //          and just make it transparent.
        //**********************************************************************

        cx = psoColor->sizlBitmap.cx;           
        cy = psoColor->sizlBitmap.cy;           
        AlphaBlendedCursor = TRUE;

        }    


    else

#endif
    
        {

        //**********************************************************************
        // Our old documentation says that 'psoMsk' may be NULL, which means
        // that the pointer is transparent.  Well, trust me, that's wrong.
        // I've checked GDI's code, and it will never pass us a NULL psoMsk:
        //**********************************************************************

        AlphaBlendedCursor = FALSE;

        // psoMsk is for monochrome cursors
        //
        cx = psoMsk->sizlBitmap.cx;             // Note that 'sizlBitmap.cy' accounts
        cy = psoMsk->sizlBitmap.cy >> 1;        //   for the double height due to the
                                                //   inclusion of both the AND masks
                                                //   and the XOR masks.  For now, we're
                                                //   only interested in the true
                                                //   pointer dimensions, so we divide
                                                //   by 2.
        }
        
    ulReturnValue = (ULONG)(ppdev->pfnSetPointerShape(pso, psoMsk, psoColor, pxlo, x,y, xHot, yHot, cx, cy, AlphaBlendedCursor));

    if(ulReturnValue == SPS_DECLINE)
    {
        //**************************************************************************
        // Hide HW cursor going to SW cursor
        //**************************************************************************

        ppdev->pfnShowPointer(ppdev, FALSE);
    }

DoneDrvSetPointerShape:

    if( ulReturnValue == SPS_DECLINE)
    {
        ppdev->ulDriverNotSupportPanScan = TRUE;
        ppdev->bIsSWPointer              = TRUE;

#if _WIN32_WINNT >= 0x0500
        // punt back to GDI and keep track of mouse movement in DrvMovePointer
        if(EngSetPointerShape(pso, psoMsk, psoColor, pxlo, xHot, yHot, x, y, prcl, fl) != SPS_ACCEPT_EXCLUDE)
        {
            ppdev->ulPuntCursorToGDI = FALSE;
        }
        else
        {
            ulReturnValue = SPS_ACCEPT_NOEXCLUDE;
            ppdev->ulDriverNotSupportPanScan = FALSE;
            ppdev->ulPuntCursorToGDI = TRUE;
        }
#endif

    }
    else
    {
        ppdev->ulDriverNotSupportPanScan = FALSE;
        ppdev->bIsSWPointer              = FALSE;
    }

    return(ulReturnValue);

    }

//******************************************************************************
//
//  Function:   vDisablePointer
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID vDisablePointer(
PDEV*   ppdev)
    {
        if (ppdev->flCaps & CAPS_SW_POINTER)
            return;

        if(ppdev->pfnEnablePointer)
        {
            ppdev->pfnEnablePointer(ppdev, FALSE);
        }
    }

//******************************************************************************
//
//  Function:   vAssertModePointer
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)

    {
    ULONG*  pulDst;
    LONG    i;
    LONG    lPointerShape;

    //**************************************************************************
    // With a software pointer, we don't have to do anything.
    //**************************************************************************

    if (ppdev->flCaps & CAPS_SW_POINTER)
        return;

    //**************************************************************************
    // Turn off the hardware cursor
    //**************************************************************************

    if(ppdev->pfnEnablePointer)
        ppdev->pfnEnablePointer(ppdev, bEnable);

    }

//******************************************************************************
//
//  Function:   bEnablePointer
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL bEnablePointer(
PDEV*   ppdev)

    {
    RECTL       rclDraw;
    RECTL       rclBank;
    LONG        iBank;
    LONG        cjOffset;
    LONG        cjOffsetInBank;

    //**************************************************************************
    // With a software pointer, we don't have to do anything.
    //**************************************************************************

    if (ppdev->flCaps & CAPS_SW_POINTER)
        return(TRUE);

    //**************************************************************************
    // Check what type of hardware cursor to enable (NV1/NV3)
    //**************************************************************************

    ppdev->pfnShowPointer     = ShowPointer;
#ifdef NV3
    ppdev->pfnMovePointer     = NV3MovePointer;
    ppdev->pfnSetPointerShape = NV3SetPointerShape;
    ppdev->pfnEnablePointer   = NV3EnablePointer;
#else
    if (ppdev->CurrentClass.VideoLutCursorDac == NV15_VIDEO_LUT_CURSOR_DAC ||
        ppdev->CurrentClass.VideoLutCursorDac == NV10_VIDEO_LUT_CURSOR_DAC ||
        ppdev->CurrentClass.VideoLutCursorDac == NV05_VIDEO_LUT_CURSOR_DAC ||
        ppdev->CurrentClass.VideoLutCursorDac == NV04_VIDEO_LUT_CURSOR_DAC) {
        ppdev->pfnMovePointer     = NVMovePointer;
        ppdev->pfnEnablePointer   = NVEnablePointer;
    } else {
        // Error
        ASSERTDD(0,"No supported VIDEO_LUT_CURSOR_DAC object created");
    }

    switch(ppdev->CurrentClass.VideoLutCursorDac)
    {
        case NV10_VIDEO_LUT_CURSOR_DAC:
        case NV05_VIDEO_LUT_CURSOR_DAC:
        case NV04_VIDEO_LUT_CURSOR_DAC:
            ppdev->pfnSetPointerShape = NVSetPointerShapeOn16BppHwMode;
            break;
        default:
            // all NV newer chips should be able to handle 32Bpp cursor.
            ppdev->pfnSetPointerShape = NVSetPointerShapeOn32BppHwMode;
            break;
    }
#endif // NV3
    
    //**************************************************************************
    // Actually turn on the pointer:
    //**************************************************************************

    vAssertModePointer(ppdev, TRUE);

    DISPDBG((5, "Passed bEnablePointer"));

    return(TRUE);
    }



//******************************************************************************
//
//  Function:   ShowPointer
//
//  Routine Description:
//
//      Show or hide the hardware pointer.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ShowPointer(
PDEV*   ppdev,
BOOL    bShow)      // If TRUE, show the pointer.  If FALSE, hide the pointer.

    {
    LONG    x;
    LONG    y;

    if (bShow)
        {
        //**********************************************************************
        // Make the hardware pointer visible:
        //**********************************************************************

        x  = ppdev->xPointer;
        y  = ppdev->yPointer;
        }

    else

        {
        //**********************************************************************
        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:
        //**********************************************************************

        x  = ppdev->cxScreen + 64;
        y  = ppdev->cyScreen + 64;
        }

    //*************************************************************************
    // Enable/Disable cursor by moving to new position
    //*************************************************************************

    ppdev->pfnMovePointer(ppdev, x, y);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\textout.c ===
//******************************Module*Header***********************************
//
// Module Name: textout.c
//
// On every TextOut, GDI provides an array of 'GLYPHPOS' structures
// for every glyph to be drawn.  Each GLYPHPOS structure contains a
// glyph handle and a pointer to a monochrome bitmap that describes
// the glyph.  (Note that unlike Windows 3.1, which provides a column-
// major glyph bitmap, Windows NT always provides a row-major glyph
// bitmap.)  As such, there are three basic methods for drawing text
// with hardware acceleration:
//
// 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
//       (probably in off-screen memory), and text is drawn by
//       referring the hardware to the cached glyph locations.
//
// 2) Glyph expansion -- Each individual glyph is colour-expanded
//       directly to the screen from the monochrome glyph bitmap
//       supplied by GDI.
//
// 3) Buffer expansion -- The CPU is used to draw all the glyphs into
//       a 1bpp monochrome bitmap, and the hardware is then used
//       to colour-expand the result.
//
// The fastest method depends on a number of variables, such as the
// colour expansion speed, bus speed, CPU speed, average glyph size,
// and average string length.
//
// For the S3 with normal sized glyphs, I've found that caching the
// glyphs in off-screen memory is typically the slowest method.
// Buffer expansion is typically fastest on the slow ISA bus (or when
// memory-mapped I/O isn't available on the x86), and glyph expansion
// is best on fast buses such as VL and PCI.
//
// Glyph expansion is typically faster than buffer expansion for very
// large glyphs, even on the ISA bus, because less copying by the CPU
// needs to be done.  Unfortunately, large glyphs are pretty rare.
//
// An advantange of the buffer expansion method is that opaque text will
// never flash -- the other two methods typically need to draw the
// opaquing rectangle before laying down the glyphs, which may cause
// a flash if the raster is caught at the wrong time.
//
// This driver implements glyph expansion and buffer expansion --
// methods 2) and 3).  Depending on the hardware capabilities at
// run-time, we'll use whichever one will be faster.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"


RECTL grclMax = { 0, 0, 0x7fff, 0x7fff };



//******************************************************************************
//
//  Function:   vClipSolid
//
//  Routine Description:
//
//      Fills the specified rectangles with the specified colour, honouring
//      the requested clipping.  No more than four rectangles should be passed in.
//      Intended for drawing the areas of the opaquing rectangle that extend
//      beyond the text box.  The rectangles must be in left to right, top to
//      bottom order.  Assumes there is at least one rectangle in the list.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)

    {
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    //**************************************************************************
    // Safety checks
    //**************************************************************************

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                       "Expected a non-null clip object");

    rbc.iSolidColor = iColor;

    //**********************************************************************
    // Bottom of last rectangle to fill
    //**********************************************************************

    iLastBottom = prcl[crcl - 1].bottom;

    //**********************************************************************
    // Initialize the clip rectangle enumeration to right-down so we can
    // take advantage of the rectangle list being right-down:
    //**********************************************************************

    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

    //**********************************************************************
    // Scan through all the clip rectangles, looking for intersects
    // of fill areas with region rectangles:
    //**********************************************************************

    do {
        //******************************************************************
        // Get a batch of region rectangles:
        //******************************************************************

        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

        //******************************************************************
        // Clip the rect list to each region rect:
        //******************************************************************

        for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
            //**************************************************************
            // Since the rectangles and the region enumeration are both
            // right-down, we can zip through the region until we reach
            // the first fill rect, and are done when we've passed the
            // last fill rect.
            //**************************************************************

            if (prclClip->top >= iLastBottom)
                {
                //**********************************************************
                // Past last fill rectangle; nothing left to do:
                //**********************************************************

                return;
                }

            //**************************************************************
            // Do intersection tests only if we've reached the top of
            // the first rectangle to fill:
            //**************************************************************

            if (prclClip->bottom > prcl->top)
                {
                //**********************************************************
                // We've reached the top Y scan of the first rect, so
                // it's worth bothering checking for intersection.
                //**********************************************************

                //**********************************************************
                // Generate a list of the rects clipped to this region
                // rect:
                //**********************************************************

                prclTmp     = prcl;
                prclClipTmp = arclTmp;

                for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                    //******************************************************
                    // Intersect fill and clip rectangles
                    //******************************************************

                    if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                        //**************************************************
                        // Add to list if anything's left to draw:
                        //**************************************************

                        crclTmp++;
                        prclClipTmp++;
                        }
                    }

                //**********************************************************
                // Draw the clipped rects
                //**********************************************************

                if (crclTmp != 0)
                    {
                    (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                          0xf0f0, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }


//******************************************************************************
//
//  Function:   DrvTextOut
//
//  Routine Description:
//
//      Calls the appropriate text drawing routine.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,    // Always unused, unless GCAPS_ARBRUSHOPAQUE set
MIX       mix)          // Always a copy mix -- 0x0d0d

    {
    PDEV*       ppdev;
    DSURF*      pdsurfDst;
    SURFOBJ*    TempDstSurfObjPtr;
    ULONG*      DstBits;
    ULONG*      ScreenBitmap;
    BOOL        result;
    ULONG       DstOffset;
    ULONG       DstStride;

    //**************************************************************************
    // Get variables to determine if we're drawing to system memory or VRAM
    //**************************************************************************

    pdsurfDst = (DSURF*) pso->dhsurf;
    ppdev  = (PDEV*) pso->dhpdev;

    ASSERTDD(ppdev != NULL, "Null ppdev in DrvTextOut");

    // NV HW is not enabled.
    if(!ppdev->bEnabled)
        goto Do_EngTextOut;


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowRect(ppdev,pso, (NULL != prclOpaque) ? prclOpaque : &pstro->rclBkGround, pco);        
    }

        
    //**************************************************************************
    // There will always be a destination so we don't have to check
    // for psoDst == NULL.
    //**************************************************************************

    DstBits         = (ULONG *)(pso->pvBits);
    ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

    //**************************************************************************
    // Set linear offset and stride for source and destination buffers
    //**************************************************************************

    if ((pdsurfDst != NULL) && (pdsurfDst->dt == DT_SCREEN))     // offscreen bitmap
        {
        DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
        DstStride = pdsurfDst->LinearStride;
        }
    else if ((pdsurfDst == NULL) && (DstBits == ScreenBitmap))  // screen bitmap
        {
        DstOffset = ppdev->ulPrimarySurfaceOffset;
        DstStride = ppdev->lDelta;
        }
        
    //**************************************************************************
    // Only handle cases where destination is VRAM.  This must be a DFB that is
    // stored in system memory. We need to send this case to GDI.
    // GDI is allowed to call us to update DFBs that are stored in system
    // memory when in Full Screen DOS (typically during a STRESS test). Note that
    // the ppdev value might not be valid, and might contain bad data.
    //**************************************************************************

    else
        goto Do_EngTextOut;

//**************************************************************************
    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:
    //**************************************************************************

    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    (ppdev->pfnSetDestBase)(ppdev,DstOffset , DstStride);

    result = (ppdev->pfnTextOut(pso, pstro, pfo, pco, prclOpaque, pboFore, pboOpaque));

    return(result);


Do_EngTextOut:

    //**************************************************************************
    // Default to using original SURFOBJ. This will work for GDI managed surfaces
    // which is the case for all bitmaps stored in on-screen VRAM. 
    //**************************************************************************

    TempDstSurfObjPtr = pso;

    //**************************************************************************
    // Check whether surface is a DFB or the primary screen surface. DFB's stored
    // in off screen VRAM need to use a "wrapper" object so GDI will understand it.
    //**************************************************************************

    if (pdsurfDst != NULL)
        {
        if (pdsurfDst->dt == DT_SCREEN)
        
            {
        //**********************************************************************
        // If this is a DFB, and we want to use GDI to draw, use the 'wrapper'
        // surface object.  (The surface object must be locked)
        //**********************************************************************

        //**********************************************************************
        // SurfOBJ that will be used if we are drawing to a DFB
        //**********************************************************************

            TempDstSurfObjPtr = ppdev->psoPunt;

            TempDstSurfObjPtr->dhsurf       = 0;                    // Behave like a standard DIB
            TempDstSurfObjPtr->sizlBitmap   = pdsurfDst->sizl;
            TempDstSurfObjPtr->cjBits       = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            TempDstSurfObjPtr->pvBits       = pdsurfDst->LinearPtr;
            TempDstSurfObjPtr->pvScan0      = pdsurfDst->LinearPtr;
            TempDstSurfObjPtr->lDelta       = pdsurfDst->LinearStride;

            TempDstSurfObjPtr->iBitmapFormat = ppdev->iBitmapFormat;

            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in system memory as a DIB. If we are called
            // when in Full Screen DOS, ppdev might not be valid, so just return here
            // without waiting for the engine to be busy.
            //**********************************************************************
            TempDstSurfObjPtr = pdsurfDst->pso;
            ppdev->pfnWaitEngineBusy(ppdev);
            return (ppdev->pfnEngTextOut(TempDstSurfObjPtr, pstro, pfo, pco, prclExtra, prclOpaque,
                                         pboFore, pboOpaque, pptlBrush, mix));
            }
        }

    //**************************************************************************
    // Let the DIBEngine draw it
    //**************************************************************************
    ppdev->pfnWaitEngineBusy(ppdev);
    return (ppdev->pfnEngTextOut(TempDstSurfObjPtr, pstro, pfo, pco, prclExtra, prclOpaque,
                                 pboFore, pboOpaque, pptlBrush, mix));
    }

//******************************************************************************
//
//  Function:   bEnableText
//
//  Routine Description:
//
//      Performs the necessary setup for the text drawing subcomponent.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL bEnableText(
PDEV*   ppdev)
    {
    SIZEL   sizl;
    HBITMAP hbm;

    //**************************************************************************
    // We don't do glyph caching for NV
    //**************************************************************************

    return(TRUE);
    }

//******************************************************************************
//
//  Function:   vDisableText
//
//  Routine Description:
//
//      Performs the necessary clean-up for the text drawing subcomponent.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID vDisableText(PDEV* ppdev)

    {
    HSURF       hsurf;
    SURFOBJ*    psoText;

    //**************************************************************************
    // Here we free any stuff allocated in 'bEnableText'.
    // We don't do glyph caching for NV
    //**************************************************************************


    }

//******************************************************************************
//
//  Function:   vAssertModeText
//
//  Routine Description:
//
//      Disables or re-enables the text drawing subcomponent in preparation for
//      full-screen entry/exit.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
    {
    //**************************************************************************
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
    //**************************************************************************
    }

//******************************************************************************
//
//  Function:   DrvDestroyFont
//
//  Routine Description:
//
//      Note: Don't forget to export this call in 'enable.c', otherwise you'll
//              get some pretty big memory leaks!
//
//      We're being notified that the given font is being deallocated; clean up
//      anything we've stashed in the 'pvConsumer' field of the 'pfo'.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID DrvDestroyFont(
FONTOBJ*    pfo)

    {
    CACHEDFONT* pcf;

    pcf = pfo->pvConsumer;
    if (pcf != NULL)
        {
//        vFreeCachedFont(pcf);
        pfo->pvConsumer = NULL;
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\savescreenbits.h ===
#ifndef _SAVESCREENBITS_H
#define _SAVESCREENBITS_H
//******************************Module*Header***********************************
// Module Name: savescreenbits.h
//
//  This module contains the DrvSaveScreenBits realization
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************

ULONG_PTR APIENTRY DrvSaveScreenBits(
    SURFOBJ  *pso,
    ULONG    iMode,
    ULONG_PTR ident,
    RECTL    *prcl);

BOOL bSaveScreenBitsGarbageCollection(
    PPDEV ppdev,
    ULONG ulKeep);



#endif // _SAVESCREENBITS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\stretch.c ===
//******************************Module*Header***********************************
//
// Module Name: stretch.c
//
// Copyright (c) 1993-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "oglsync.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)

    {
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;

    RECTL       rclClip;
    RECTL*      prclClip;
    ULONG       DstWidth;
    ULONG       DstHeight;
    ULONG       SrcWidth;
    ULONG       SrcHeight;
    BOOL        bMore;
    CLIPENUM    ce;
    LONG        c;
    LONG        i;
    FNXFER*         pfnXfer;
    POINTL      ptlSrc;

    //**************************************************************************
    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:
    //**************************************************************************

    //**************************************************************************
    // For NV: Our primary surface is NOT a device surface.
    // It is a GDI managed, standard DIB surface...
    //**************************************************************************

    pdsurfSrc = NULL;
    pdsurfDst = NULL;

    if ((VOID *)psoSrc != NULL)
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    if ((VOID *)psoDst != NULL)
        pdsurfDst = (DSURF*) psoDst->dhsurf;


    ppdev = (PDEV*) psoDst->dhpdev;


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowStretch(ppdev,psoDst,psoSrc,pco,prclDst,prclSrc);        
    }


    //**************************************************************************
    // NV: This function is NOT currently implemented/hooked
    // TODO:  Add punt/wrapper functionality same as BitBlt!
    //**************************************************************************

    return(TRUE);




    //**************************************************************************
    // It's quicker for GDI to do a StretchBlt when the source surface
    // is NOT a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.
    //
    // NV:  This works much better with our driver since we use GDI-MANAGED
    //      surfaces.  No need to call DrvCopyBits so performance is better.
    //      (We can directly read the source bits, no problem)
    //**************************************************************************

    //**************************************************************************
    // Currently, we only support the following type of stretch DIB
    //      - No mask
    //      - Source is a DIB (STYPE_BITMAP), 1 bpp with pxlo->flXlate = XO_TABLE
    //          which means we get 1 colors, one for foreground and one for background
    //      - Destination is screen
    //      - 1 to 1 stretching (no stretching)
    //      - Clipping is DC_TRIVIAL
    //**************************************************************************

    if (    (psoSrc->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            (pxlo != NULL) &&
            (pxlo->flXlate & XO_TABLE) &&
            (pxlo->cEntries == 2) &&
            (psoSrc->iBitmapFormat == BMF_1BPP) &&
            (pco !=NULL) &&
            (pco->iDComplexity == DC_TRIVIAL)
        )

        {
        DstWidth  = prclDst->right - prclDst->left;
        DstHeight = prclDst->bottom - prclDst->top;

        SrcWidth  = prclSrc->right - prclSrc->left;
        SrcHeight = prclSrc->bottom - prclSrc->top;

        //**********************************************************************
        // Right now, we don't really do stretching.
        // We only support 1 to 1 copies with a monochrome source bitmap.
        // DeviceBitmapBit calls come thru here.
        //**********************************************************************

        if ( (DstWidth == SrcWidth) &&
             (DstHeight == SrcHeight))
            {

            pfnXfer = ppdev->pfnXfer1bpp;

            //******************************************************************
            // Specify 1 'clip' rectangle (same as original destination rectangle)
            // Manually specify 0xCCCC for Source Copy ROP
            // PatternColor doesn't matter in this case since this is a SRCCOPY rop
            //   (no pattern involved) so we'll just send 0x00000000
            // Send the origin of the source rectangle in ptlSrc..for now
            // we just care about the origin since we're not doing stretching
            //******************************************************************

            ptlSrc.x = prclSrc->left;
            ptlSrc.y = prclSrc->top;

            pfnXfer(ppdev, 1, prclDst, 0xCCCC, psoSrc, &ptlSrc, prclDst, pxlo,0x00000000,NULL);
            return(TRUE);
            }

        else
            {
            //******************************************************************
            // Eventually, we'll add the stretch functionality
            // For now, just fall through to GDI.
            //******************************************************************
            }

        }

    //**************************************************************************
    // Send call back to GDI, we didn't handle it.
    //**************************************************************************

    //**************************************************************************
    // TODO:  Add punt/wrapper functionality same as BitBlt!
    //**************************************************************************

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\thunk.c ===
//*****************************Module*Header************************************
//
// Module Name: thunk.c
//
// This module exists solely for testing, to make it is easy to instrument
// all the driver's Drv calls.
//
// Note that most of this stuff will only be compiled in a checked (debug)
// build.
//
// Copyright (c) 1993-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG


// This entire module is only enabled for Checked builds, or when we
// have to explicitly synchronize bitmap access ourselves.

////////////////////////////////////////////////////////////////////////////
// By default, GDI does not synchronize drawing to device-bitmaps.  Since
// our hardware dictates that only one thread can access the accelerator
// at a time, we have to synchronize bitmap access.
//
// If we're running on Windows NT 3.5, we can ask GDI to do it by setting
// HOOK_SYNCHRONIZEACCESS when we associate a device-bitmap surface.

// These macros are merely for testing that GDI's HOOK_SYNCHRONIZEACCESS
// actually works:

#define SYNCH_ENTER()
#define SYNCH_LEAVE()

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)


DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
#ifdef _WIN32_WINNT         // If >= NT 4.x
HDEV        hdev,
#else
PWSTR       pwszDataFile,
#endif                      // If >= NT 4.x
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV ppdev;

    SYNCH_ENTER();
    DISPDBG((1, ">> DrvEnablePDEV(%d x %d %d bpp %d Hz)",
        pDevmode->dmPelsWidth,
        pDevmode->dmPelsHeight,
        pDevmode->dmBitsPerPel,
        pDevmode->dmDisplayFrequency));

    ppdev = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
#ifdef _WIN32_WINNT         // If >= NT 4.x
                hdev,
#else
                pwszDataFile,
#endif                      // If >= NT 4.x
                pwszDeviceName,
                hDriver);

    DISPDBG((1, "<< DrvEnablePDEV: 0x%p",ppdev));
    SYNCH_LEAVE();

    return(ppdev);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((1, ">> DrvCompletePDEV(ppdev:0x%p, hdev:0x%p)", dhpdev, hdev));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((1, "<< DrvCompletePDEV"));
    SYNCH_LEAVE();
}

VOID DbgSynchronize(
DHPDEV dhpdev,
RECTL  *prcl)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DrvSynchronize"));

    DrvSynchronize(
                dhpdev,
                prcl);

    DISPDBG((6, "<< DrvSynchronize"));
    SYNCH_LEAVE();
}



VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((1, ">> DrvDisablePDEV(ppdev:0x%p)",dhpdev));

    DrvDisablePDEV(dhpdev);

    DISPDBG((1, "<< DrvDisablePDEV"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((1, ">> DrvEnableSurface(ppdev:0x%p)",dhpdev));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((1, "<< DrvEnableSurface"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((1, ">> DrvDisableSurface(ppdev:0x%p)",dhpdev));

    DrvDisableSurface(dhpdev);

    DISPDBG((1, "<< DrvDisableSurface"));
    SYNCH_LEAVE();
}

#ifdef _WIN32_WINNT         // If >= NT 4.x
BOOL  DbgAssertMode(
#else
void  DbgAssertMode(
#endif                      // If >= NT 4.x
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((1, ">> DrvAssertMode: ppdev: 0x%x, bEnable: %d", dhpdev, bEnable));

#ifdef _WIN32_WINNT     // If >= NT 4.x
    b = DrvAssertMode(dhpdev,bEnable);
#else
    DrvAssertMode(dhpdev,bEnable);
#endif                  // If >= NT 4.x

    DISPDBG((1, "<< DrvAssertMode: ppdev: 0x%x, bEnable: %d", dhpdev, bEnable));
    SYNCH_LEAVE();

#ifdef _WIN32_WINNT     // If >= NT 4.x
    return (b);
#else
    return;
#endif                  // If >= NT 4.x
}

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((1, ">> DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((1, "<< DrvGetModes"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    // Note: Because we set GCAPS_ASYNCMOVE, we don't want to do a
    //       SYNCH_ENTER/LEAVE here.

    DISPDBG((5, ">> DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((6, "<< DrvMovePointer"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "<< DrvSetPointerShape"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, ">> DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "<< DrvDitherColor"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "<< DrvSetPalette"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvCopyBits"));

#if 0 // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.
    {
        BRUSHOBJ bo = {0};
        bo.iSolidColor = 0;
        DrvBitBlt(psoDst,NULL,NULL,pco,NULL,prclDst,NULL,NULL,&bo,NULL,0xF0F0);
    }
#endif // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "<< DrvCopyBits"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvBitBlt"));

#if 0 // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.
    {
        BRUSHOBJ bo = {0};
        bo.iSolidColor = 0;
        DrvBitBlt(psoDst,NULL,NULL,pco,NULL,prclDst,NULL,NULL,&bo,NULL,0xF0F0);
    }
#endif // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((6, "<< DrvBitBlt"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "<< DrvTextOut"));
    SYNCH_LEAVE();

    return(u);
}

#ifdef _WIN32_WINNT         // If >= NT 4.x
BOOL DbgLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvLineTo"));

    u = DrvLineTo(
                pso,
                pco,
                pbo,
                x1,
                y1,
                x2,
                y2,
                prclBounds,
                mix);

    DISPDBG((6, "<< DrvLineTo"));
    SYNCH_LEAVE();

    return(u);
}
#endif _WIN32_WINNT         // If >= NT 4.x

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "<< DrvStrokePath"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "<< DrvFillPath"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((6, "<< DrvPaint"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, ">> DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "<< DrvRealizeBrush"));

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "<< DrvCreateDeviceBitmap"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "<< DrvDeleteDeviceBitmap"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvStretchBlt"));

    // Our DrvStretchBlt routine calls back to EngStretchBlt, which
    // calls back to our DrvCopyBits routine -- so we have to be
    // re-entrant for synchronization...

    SYNCH_LEAVE();

    DISPDBG((0, "DSB: %s %s src:%s %s (%d,%d %d*%d), dst:%s %s (%d,%d %d*%d), msk:%s %s (%d,%d)",
        pco?szDbg_CLIPOBJiDComplexity(pco->iDComplexity):"DC_trivial",
        pxlo?szDbg_XLATEOBJflXlate(pxlo->flXlate):"XO_trivial",
        psoSrc?szDbg_SURFOBJiBitmapFormat(psoSrc->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoSrc), prclSrc->left, prclSrc->top, prclSrc->right-prclSrc->left, prclSrc->bottom-prclSrc->top, 
        psoDst?szDbg_SURFOBJiBitmapFormat(psoDst->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoDst), prclDst->left, prclDst->top, prclDst->right-prclDst->left, prclDst->bottom-prclDst->top, 
        psoMask?szDbg_SURFOBJiBitmapFormat(psoMask->iBitmapFormat):"NULL", szDbg_SURFOBJ_surf(psoMask), psoMask?pptlMask->x:0, psoMask?pptlMask->y:0));

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    SYNCH_ENTER();
    DISPDBG((6, "<< DrvStretchBlt"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgEscape(
SURFOBJ*    pso,
ULONG       iEsc,
ULONG       cjIn,
VOID*       pvIn,
ULONG       cjOut,
VOID*       pvOut)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    // Most escapes are not synchronized by GDI...

    DISPDBG((5, "DrvEscape: 0x%x %s %s", iEsc, szDbg_iEscGet(iEsc), ESC_NV_OPENGL_ESCAPE==iEsc?szDbg_NV_OPENGL_ESCAPE(((NV_OPENGL_COMMAND *)pvIn)->command):(QUERYESCSUPPORT==iEsc?szDbg_iEscGet(*(ULONG *)pvIn):"") ));

    u = DrvEscape(pso,
                  iEsc,
                  cjIn,
                  pvIn,
                  cjOut,
                  pvOut);

    DISPDBG((6, "DrvEscape done"));

    return(u);
}

ULONG DbgDrawEscape(
SURFOBJ *pso,
ULONG    iEsc,
CLIPOBJ *pco,
RECTL   *prcl,
ULONG    cjIn,
PVOID    pvIn)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    // Most escapes are not synchronized by GDI...

    DISPDBG((5, "DrvDrawEscape"));

    u = DrvDrawEscape(pso,
                      iEsc,
                      pco,
                      prcl,
                      cjIn,
                      pvIn);

    DISPDBG((6, "DrvDrawEscape done"));

    return(u);
}

BOOL DbgResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((1, ">> DrvResetPDEV(ppdevOld:0x%p -> ppdevNew:0x%p)", dhpdevOld, dhpdevNew));

    bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);

    DISPDBG((1, "<< DrvResetPDEV"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgDestroyFont(FONTOBJ *pfo)
{
    DISPDBG((5, ">> DbgDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "<< DbgDestroyFont"));
}

#ifdef _WIN32_WINNT     // If >= NT 4.x
BOOL DbgGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          lpdwNumHeaps,
VIDEOMEMORY*    pvmList,
DWORD*          lpdwNumFourCC,
DWORD*          lpdwFourCC)
{
    BOOL b;

    DISPDBG((5, ">> DbgQueryDirectDrawInfo"));

    b = DrvGetDirectDrawInfo(dhpdev,
                             pHalInfo,
                             lpdwNumHeaps,
                             pvmList,
                             lpdwNumFourCC,
                             lpdwFourCC);

    DISPDBG((6, "<< DbgQueryDirectDrawInfo"));

    return(b);
}

BOOL DbgEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgEnableDirectDraw"));

    b = DrvEnableDirectDraw(dhpdev,
                            pCallBacks,
                            pSurfaceCallBacks,
                            pPaletteCallBacks);

    DISPDBG((6, "<< DbgEnableDirectDraw"));
    SYNCH_LEAVE();

    return(b);
}

VOID DbgDisableDirectDraw(
DHPDEV      dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDisableDirectDraw"));

    DrvDisableDirectDraw(dhpdev);

    DISPDBG((6, "<< DbgDisableDirectDraw"));
    SYNCH_LEAVE();
}

#if _WIN32_WINNT >= 0x0500

BOOL	DbgIcmSetDeviceGammaRamp(
	DHPDEV	dhpdev,
	ULONG	iFormat,
	LPVOID	lpRamp
)
{
	BOOL	b;

	DISPDBG((5, ">> DbgIcmSetDeviceGammaRamp"));

	b = DrvIcmSetDeviceGammaRamp(dhpdev, iFormat, lpRamp);

	DISPDBG((6, "<< DbgIcmSetDeviceGammaRamp"));

	return(b);
}


HBITMAP	DbgDeriveSurface(
	DD_DIRECTDRAW_GLOBAL	*pDirectDraw,
	DD_SURFACE_LOCAL		*pSurface
)
{
	HBITMAP	hbm;

	DISPDBG((1, ">> DbgDeriveSurface"));

	hbm	= DrvDeriveSurface(pDirectDraw, pSurface);

	DISPDBG((1, "<< DbgDeriveSurface"));

	return(hbm);
}

void DbgDrvNotify(
    SURFOBJ *hsurf,
    ULONG iType,
    PVOID pvData
)
{
	DISPDBG((1, ">> DbgDrvNotify"));

	DrvNotify(hsurf, iType, pvData);

	DISPDBG((1, "<< DbgDrvNotify"));
}

BOOL DbgAlphaBlend(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ  *pxlo,
    RECTL  *prclDest,
    RECTL  *prclSrc,
    BLENDOBJ  *pBlendObj) 
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvAlphaBlend"));

#if 0 // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.
    {
        BRUSHOBJ bo = {0};
        bo.iSolidColor = 0;
        DrvBitBlt(psoDest,NULL,NULL,pco,NULL,prclDest,NULL,NULL,&bo,NULL,0xF0F0);
    }
#endif // FNicklisch 29.01.2001: Disabled for now. It will fill the destination prior to the call.

    u = DrvAlphaBlend(
        psoDest,
        psoSrc,
        pco,
        pxlo,
        prclDest,
        prclSrc,
        pBlendObj); 

    DISPDBG((6, "<< DrvAlphaBlend"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTransparentBlt(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDest,
    RECTL    *prclSrc,
    ULONG     iTransColor,
    ULONG     Reserved) 
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvTransparentBlt"));

    u = DrvTransparentBlt(
        psoDest,
        psoSrc,
        pco,
        pxlo,
        prclDest,
        prclSrc,
        iTransColor,
        Reserved); 

    DISPDBG((6, "<< DrvTransparentBlt"));
    SYNCH_LEAVE();

    return(u);
}

#endif //_WIN32_WINNT >= 0x0500

#endif      // If >= NT 4.x

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\swap.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.53 $
** $Date: 1993/06/03 17:06:13 $
*/

#include "precomp.h"
#include "driver.h"

#include "excpt.h"
#pragma hdrstop
#include "oglDD.h"
#include "oglsync.h"

BOOL APIENTRY DrvSwapBuffers(SURFOBJ *psoDst, WNDOBJ *pwo)
{
    PDEV  *ppdev = NULL;
    NV_OPENGL_CLIENT_INFO *clientInfo = NULL;
    NV_OPENGL_DRAWABLE_INFO *clientDrawableInfo = NULL;
    POINTL  ptlSrc;
    RECTL   prclDst;
    RECTL   rcl;
    LONG                       status;

    ppdev = (PDEV *)pwo->psoOwner->dhpdev;

    if (!ppdev->bEnabled)
    {
        DBG_ERROR("DrvSwapBuffers called in VGA mode -> ignoring");
        return TRUE;
    }

    //**************************************************************
    // Actually do the swap
    //**************************************************************
    try // just in case...
    {
        clientInfo = (NV_OPENGL_CLIENT_INFO *)pwo->pvConsumer;
        if (OglFindClientListFromClientInfo(ppdev, clientInfo) != NULL)
        {
            clientDrawableInfo = clientInfo->clientDrawableInfo;

            // if the swap was already done by the client, don't do it again
            if (clientDrawableInfo->ulSwapDoneByClient)
            {
                // nothing to do, swap taken care of by ICD
                clientDrawableInfo->ulSwapDoneByClient = 0;
                return TRUE;
            }

            if (OglValidateDrawableInfo(clientDrawableInfo) == TRUE)
            {
                ULONG ulView; // stereo loop enumerator

                // If the window is not visible, stop
                if (clientDrawableInfo->clipFlags == NV_WINDOW_CLIP_OCCLUDED ||
                    clientDrawableInfo->numClipRects == 0)
                {
                    return TRUE;
                }

                // Currently only handle display driver channel swaps with UBB
                // enabled.
                if (!ppdev->bOglSingleBackDepthCreated) 
                {
                    return TRUE;
                }

                //************************************************************************** 
                // Need to do smart sync between OpenGL and GDI depending on 
                // clip intersection.
                //**************************************************************************
                bOglSyncOglIfGdiRenderedToWindow(ppdev);

                //**************************************************
                // We now have screen relative clips for the swap
                //**************************************************
                rcl.left   = 0;
                rcl.top    = 0;
                rcl.right  = ppdev->cxScreen;
                rcl.bottom = ppdev->cyScreen;
                ptlSrc.x   = 0;
                ptlSrc.y   = 0;

                // need to wait until ICD has finished rendering
                ASSERT(NULL!=ppdev->pfnWaitEngineBusy);
                ppdev->pfnWaitEngineBusy(ppdev);

                for( ulView=0; ulView < ppdev->ulOglActiveViews; ulView++ )
                {
                    ULONG ulPrimarySurfaceOffset;
                    LONG  lPrimarySurfacePitch;

                    if (OGL_STEREO_BUFFER_LEFT == ulView)
                    {
                        ulPrimarySurfaceOffset = ppdev->ulPrimarySurfaceOffset;
                        lPrimarySurfacePitch   = ppdev->lDelta;
                    }
                    else
                    {
                        ulPrimarySurfaceOffset = ppdev->singleFrontOffset[ulView];
                        lPrimarySurfacePitch   = ppdev->singleFrontPitch[ulView];
                    }

                    // perhaps previous swaps succeeded in the ICD but we're displaying back,
                    // then we need to blit from primary to back
                    if (OGL_FLIPPED())
                    {
                        ppdev->pfnSetSourceBase(ppdev, ulPrimarySurfaceOffset, lPrimarySurfacePitch);
                        ppdev->pfnSetDestBase(ppdev, ppdev->singleBack1Offset[ulView], ppdev->singleBack1Pitch[ulView]);
                    }
                    else
                    {
                        ppdev->pfnSetSourceBase(ppdev, ppdev->singleBack1Offset[ulView], ppdev->singleBack1Pitch[ulView]);
                        ppdev->pfnSetDestBase(ppdev, ulPrimarySurfaceOffset, lPrimarySurfacePitch);
                    }
                    ppdev->pfnCopyBlt(ppdev, 
                                      clientDrawableInfo->numClipRects,
                                      clientDrawableInfo->copyWindowRect, 
                                      0xCCCC, &ptlSrc, &rcl, NULL);
                }
                ppdev->pfnWaitEngineBusy(ppdev);
            }
            else
            {
                DISPDBG((1, "DrvSwapBuffers: BOGUS clientDrawableInfo"));
            }
        }
        else
        {
            DISPDBG((1, "DrvSwapBuffers: BOGUS clientInfo"));
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        DISPDBG((1, "DrvSwapBuffers: WOC_RGN_CLIENT: exception = 0x%lx", status));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\vpe_nt.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: vpe_nt.c                                                          *
* Copyright Microsoft, 1996. All rights reserved.
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           6/29/98                                          *
*                                                                           *
\***************************************************************************/


/* #includes ---------------------------------------------*/



#include "precomp.h"
#include "nvos.h"
#include "nvapi.h"
#include "nvsubch.h"
#include "vpe_nt.h"
#include "surfaces.h"

//#if DX5

DWORD WINAPI GetDriverInfo32(LPDDHAL_GETDRIVERINFODATA lpInput);
DWORD WINAPI SyncSurfaceData32(LPDDHAL_SYNCSURFACEDATA lpInput);
DWORD WINAPI SyncVideoPortData32(LPDDHAL_SYNCVIDEOPORTDATA lpInput);
DWORD WINAPI ColorControl32(LPDDHAL_COLORCONTROLDATA lpInput);



/*
** Callback tables exported through the GetDriverInfo32 interface
*/
const DDHAL_DDKERNELCALLBACKS KernelCallbacks =
{
    sizeof(DDHAL_DDKERNELCALLBACKS),
    0,
    NULL,
    NULL
};

const GUID *guids[] =
{
    &DDVPTYPE_CCIR656,
};

#define MAX_VP_TYPES    (sizeof(guids)/sizeof(void*))
#define CCIR656     0

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif // mmioFOURCC

const DDPIXELFORMAT InputFormats[] =
{
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC, mmioFOURCC('U','Y','V','Y'),16,(DWORD)-1,(DWORD)-1,(DWORD)-1}
};




#define MAX_INPUT_FORMATS (sizeof(InputFormats)/sizeof(DDPIXELFORMAT))
#define INPUTFORMAT_UYVY    0

const DDVIDEOPORTCAPS ddLPBVideoPortCaps =
{
    sizeof(DDVIDEOPORTCAPS),    // size of the DDVIDEOPORTCAPS structure
    DDVPD_WIDTH             |
    DDVPD_HEIGHT            |
    DDVPD_ID                |
    DDVPD_CAPS              |
    DDVPD_FX                |
    DDVPD_AUTOFLIP          |
    DDVPD_ALIGN             |
    0,
    1024,                       // VP max width (limited by FF24)
    1024,                       // max VBI data width (limited by FF24)
    512,                        // VP max height (limited by FF24)
    0,                          // VP ID (0 - (dwMaxVideoPorts-1))
    DDVPCAPS_AUTOFLIP       |   // LPB supports 2 autoflip buffers
    DDVPCAPS_INTERLACED     |
    DDVPCAPS_NONINTERLACED  |
    DDVPCAPS_READBACKFIELD  |
//  DDVPCAPS_READBACKLINE   |   // LPB doesn't support this
//  DDVPCAPS_SHAREABLE      |   // LPB doesn't support this
    DDVPCAPS_SKIPEVENFIELDS |   // when does FF00_5 start dropping ?BJT
    DDVPCAPS_SKIPODDFIELDS  |   // when does FF00_5 start dropping ?BJT
//  DDVPCAPS_SYNCMASTER     |   // LPB doesn't support this
    DDVPCAPS_VBISURFACE     |   // GX2 places VBI data in same surface
//  DDVPCAPS_COLORCONTROL   |   // LPB doesn't support this. SP does.
    0,
//  DDVPFX_CROPTOPDATA      |   // We don't know VBI size without being told
//  DDVPFX_CROPX            |
//  DDVPFX_CROPY            |
    DDVPFX_INTERLEAVE       |
//  DDVPFX_MIRRORLEFTRIGHT  |   // LPB doesn't support this
//  DDVPFX_MIRRORUPDOWN     |   // LPB doesn't support this
//  DDVPFX_PRESHRINKX       |   // LPB can't arbitrarily shrink
//  DDVPFX_PRESHRINKY       |   // LPB can't arbitrarily shrink
//  DDVPFX_PRESHRINKXS      |   // LPB shrinks by byte/pixel dropping
//  DDVPFX_PRESHRINKYS      |   // LPB shrinks by byte/pixel dropping
    DDVPFX_PRESHRINKXB      |   // down to 1/2, 1/4, 1/8 or 1/16
    DDVPFX_PRESHRINKYB      |   // as above
//  DDVPFX_PRESTRETCHX      |   // LPB never stretches
//  DDVPFX_PRESTRETCHY      |   // LPB never stretches
//  DDVPFX_PRESTRETCHXN     |   // LPB never stretches
//  DDVPFX_PRESTRETCHYN     |   // LPB never stretches
//  DDVPFX_VBICONVERT       |   // LPB doesn't have special VBI conversion
//  DDVPFX_VBINOSCALE       |   // TBD: GX2 has some VBI support
    0,
    5,                          // Number of autoflippable surfaces
    8,                          // Byte restriction of placement within surface
    1,                          // Byte restriction of width after prescaling
    1,                          // Byte restriction of left cropping
    1,                          // Byte restriction of cropping width
    16,                         // shrink in steps of original width
    32,                         // shrink in steps of original height
};

const DDHAL_DDVIDEOPORTCALLBACKS LPBVideoPortCallbacks =
{
    sizeof(DDHAL_DDVIDEOPORTCALLBACKS),
    DDHAL_VPORT32_CANCREATEVIDEOPORT |
    DDHAL_VPORT32_CREATEVIDEOPORT |
    DDHAL_VPORT32_FLIP |
    DDHAL_VPORT32_GETBANDWIDTH |
    DDHAL_VPORT32_GETINPUTFORMATS |
    DDHAL_VPORT32_GETOUTPUTFORMATS |
    DDHAL_VPORT32_GETFIELD |
    DDHAL_VPORT32_GETLINE |
    DDHAL_VPORT32_GETCONNECT |
    DDHAL_VPORT32_DESTROY |
    DDHAL_VPORT32_GETFLIPSTATUS |
    DDHAL_VPORT32_UPDATE |
    DDHAL_VPORT32_WAITFORSYNC |
    DDHAL_VPORT32_GETSIGNALSTATUS |
    //DDHAL_VPORT32_COLORCONTROL |
    0,
    &CanCreateVideoPort32,
    &CreateVideoPort32,
    &FlipVideoPort32,
    &GetVideoPortBandwidth32,
    &GetVideoPortInputFormat32,
    &GetVideoPortOutputFormat32,
    (LPVOID)0,
    &GetVideoPortField32,
    &GetVideoPortLine32,
    &GetVideoPortConnectInfo,
    &DestroyVideoPort32,
    &GetVideoPortFlipStatus32,
    &UpdateVideoPort32,
    &WaitForVideoPortSync32,
    &GetVideoSignalStatus32,
    (LPVOID)0
};

const DWORD dwConnectionCaps=	//DDVPCONNECT_DOUBLECLOCK			|
											//DDVPCONNECT_VACT					|
											//DDVPCONNECT_INVERTPOLARITY		|
											/* we discard at least until the V bit goes low, and potentially more depending
											  on the setting of YCROP  as well as the current VBI situation  */
											DDVPCONNECT_DISCARDSVREFDATA	|
											//DDVPCONNECT_HALFLINE				|
											/*  these next are "client" only 
											//DDVPCONNECT_INTERLACED			|
											//DDVPCONNECT_SHAREEVEN			|
											//DDVPCONNECT_SHAREODD				|
											*/
											0;

#if 0

const DWORD dwConnectionCaps=
                          //      DDVPCONNECT_INVERTPOLARITY      |
                                DDVPCONNECT_DISCARDSVREFDATA    |
                                DDVPCONNECT_HALFLINE            |
                                DDVPCONNECT_INTERLACED          |
                                DDVPCONNECT_SHAREEVEN           |
                                DDVPCONNECT_VACT                |
                                DDVPCONNECT_DOUBLECLOCK         |
                                DDVPCONNECT_SHAREODD            |
                                0
                                ;

#endif
#if 0

#ifdef WINNT
    /* fpVidMem is already an offset on NT */
    #define SCREENOFFSET(sData, offset) (offset)
    #define UPDATEOVERLAYFLIPOFFSET(sData) (sData->dwOverlayFlipOffset)

    #define LPS3THKINFO PPDEV
    /* our private instance data */
    #define VP_GETSDATA(x) ((LPS3THKINFO)(x->lpDD->lpGbl->dhpdev))
    #define pLPB (&(sData->LPBData))

//    #define SWORD SHORT

    #define TRACE
    #define INT3
    #define assert(x)
#else
    /* fpVidMem is an actual address on Win95 */
    #define SCREENOFFSET(sData, offset) ((offset) - sData->dwScreenFlatAddr)
    #define UPDATEOVERLAYFLIPOFFSET(sData) (dwUpdateOverlayFlipOffset)

    /* our private instance data */
    #define VP_GETSDATA(x) VERIFYSDATA((LPS3THKINFO)(x->lpDD->lpGbl->dwReserved3))
    #define pLPB (&(sData->LPBData))

    /* debugging support */
    #ifdef DEBUG
    #define TRACE   Msg
    #define DPF		Msg
    #define INT3 _asm int 3
    extern void __cdecl Msg( LPSTR szFormat, ... );
    #define assert(test) ((test) ? (void) 0 : DPF("* FAILURE * assertion %s: %s line %d",#test,__FILE__,__LINE__))
    #else
    #define INT3    (void)0
    #define DPF		1 ? (void)0 : (void)
    #define TRACE   1 ? (void)0 : (void)
    #define assert  1 ? (void)0 : (void)
    #endif
#endif

#endif


extern const DDHAL_DDVIDEOPORTCALLBACKS LPBVideoPortCallbacks;
extern vpSurfaces MySurfaces;
vpSurfaces*			pMySurfaces = &MySurfaces;
NvNotification*	nvMyVPNotifiers;
OSSpecificGlobals   OSSpecGlobal;


DWORD VPE_DriverInit(PDEV*  ppdev)
{
    ppdev->hVPEChannel = NULL;
	 ppdev->pMySurfaces = (void*)pMySurfaces;
	 MySurfaces.pDrvDat = (void*) ppdev;
	 MySurfaces.dwVideoPortsAvailable = 1;
    return 0;
}


#ifdef VPE_NT
void	getCurrentNanoTimer(U032* pBigTime, U032* pSmallTime)
{
    // XXX do this for real
    *pBigTime = 0;
	*pSmallTime = 0;
}
#endif

U032	getMilliTime(void) {
	U032	bigTime = 0;
	U032	smallTime = 0;
	
	getCurrentNanoTimer(&bigTime, &smallTime);
	return (smallTime / 1000000) + bigTime * (0xFFFFFFFF/1000000);
			
}
	
	

/*
 * CanCreateVideoPort32
 *
 * This function is required
 */

DWORD __stdcall CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput)
{
    /*
     * If the lpInput->lpDDVideoPortDesc can not be supported, set
     * lpInput->ddRVal to the correct error code and return
     * DDHAL_DRIVER_HANDLED
     */		
	/* 	this is only a query to see if VideoPort can handle a certain requirement, 
		no structures are defined here, or even chip query */
	DPF("***CanCreateVideoPort32");

	ASSERT(lpInput!=NULL);
	ASSERT(lpInput->lpDDVideoPortDesc !=NULL);	
	
	// Ok, if we got to here that means we're talking to the VXD MiniVDD properly... onward ho!
	
	// Check structure size
	if(lpInput->lpDDVideoPortDesc->dwSize   < sizeof( DDVIDEOPORTDESC ) ) {
		DPF("   ***VideoPort not creatable  -->  stucture length is not large enough");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// check input connection GUID
	if ( !IsEqualGUID(&(lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), &DDVPTYPE_CCIR656) )	 {
		DPF("   ***VideoPort not creatable  -->  GUID should be DDVPTYPE_CCIR656");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// check to see if there are ports available... by looking at IDs
   if (lpInput->lpDDVideoPortDesc->dwVideoPortID >= NV_MAX_VIDEOPORTS) {
		DPF("   ***VideoPort not creatable  --> not enough video ports");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	// check to see if there are ports available... by looking at local allocation
	if (MySurfaces.dwVideoPortsAvailable <=0 ) {
		DPF("   ***VideoPort not creatable  --> not enough video ports according to our globals");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have FieldWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...
	if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_FIELDWIDTH) {
		DPF("   ***VideoPort not creatable  --> field Width is too great");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have VBIWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...  but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV_MAX_VBIWIDTH) {
		DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have on Field Height are dependant on maximum length specifiable
	//  length is 2^19 in size... which is but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwFieldHeight * lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_BUFFERLENGTH) {
		DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV_MAX_PIXELRATE) {
		DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	// we don't have any restrictions on Microseconds per field that I know of....
	//    lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField;	// Microseconds per video field
    
	if ( lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  != 8 ) {
		DPF("   ***VideoPort not creatable  --> incoming connection width is not 8");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
#ifdef NOCHECKHERE
			// the ones I'm not capable of   ANDed   with the ones Dx is asking for
	if( (~MY_CONNECTION_CAPS) & lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags ) {
		// if we get here this should indicate that Dx is asking for a capability we're incapable of
		DPF("   ***VideoPort not creatable  --> Some of the capability flags bits are wrong");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	
	}
#endif
		
	//  Ok, we've pretty much checked everything we can possibly check here... let's tell'em that
	// we can work!		

	lpInput->ddRVal = DD_OK;
	DPF("   ***VideoPort creatable! ***");
	return DDHAL_DRIVER_HANDLED;
}


/*
 * CreateVideoPort32
 *
 * This function is optional
 */
DWORD __stdcall CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput)
{
    /*
     * This function allows the HAL to set internal flags and
     * become aware that a video port has been created. It should
     * always return DDHAL_DRIVER_NOTHANDLED.
     */

	/* According to DDHAL documentation, this procedure can return DDHAL_DRIVER_NOTHANDLED
	   as well, signifying that the createvideoport fn could not be completed
	   
	   DirectDraw MS layer will prevent creating more videoports that is
	   available.

	   */
		     
	DWORD		returnVal;
	// we should only have to get this once on creation
	{
		long i;
		
		nvMyVPNotifiers = pMySurfaces->pTheNotifiers;
		pMySurfaces->numberOfSurfaces =0;
		
		
		for(i=0;i<MAXVPSURFACES;i++) {
			pMySurfaces->Surfaces[i] = NULL;
		}
		pMySurfaces->CurrentBufferSurface[4];				// to associate the HW buffer with an arrary index
		
		if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INTERLACED ) {
			pMySurfaces->bInputInterLaced = TRUE;		
		} else {
			pMySurfaces->bInputInterLaced = FALSE;		
		}
		
		 
		if(pMySurfaces->bInputInterLaced)
			pMySurfaces->CurrentCaptureMode =EVENODD;		// indicates which fields will be capture Even	
		else 
			pMySurfaces->CurrentCaptureMode =PROGRESSIVE;	// we're assuming progressive is ALWAYS even even even
			
		pMySurfaces->CurrentScanMode =SEPERATEBUF;		// seperate or interleaved buffersx
		pMySurfaces->lastField= ODD;							// Always start on odd field   //CODE problem if even only capture.. or 
		pMySurfaces->VBIstart = 0;;
		// general information
		pMySurfaces->bSkipNextField = FALSE;
		pMySurfaces->dwOutHeight = 0;
		pMySurfaces->dwOutWidth = 0;
		pMySurfaces->dwImageStartLine =10;				// ditch a minimum of 10 lines
		pMySurfaces->dwVBIStartLine = 0;
		pMySurfaces->dwVBIHeight = 0;
		pMySurfaces->dwPreHeight = 0;					// height and width before prescaling
		pMySurfaces->dwPreWidth = 0;
		pMySurfaces->dwOriginX = 0;						// orgins to move data within the surface
		pMySurfaces->dwOriginY = 0;
		pMySurfaces->bThreadDead = TRUE;
		pMySurfaces->bThreadRunning = FALSE;
		pMySurfaces->hVPInterruptEvent = NULL;
		pMySurfaces->VpInterruptId = 0;	// the thread ID
		pMySurfaces->hThreadHandle = NULL;
		pMySurfaces->bStopVP = FALSE;							// indicates to the thread that it should NOT reprogram
		pMySurfaces->loopCount = 0;
		pMySurfaces->pBuffer0Mem = (U032) NULL;
		pMySurfaces->pBuffer1Mem = (U032) NULL;
		pMySurfaces->curOverlay = 0;			// this way we should start into 0
		
		// initialize all the callback stuff	
		pMySurfaces->ImageCallbackRoutine = NULL;			
		pMySurfaces->VBICallbackRoutine = NULL;			
		pMySurfaces->myIMGCallbackInfo.intCount = 0;			
		pMySurfaces->myVBICallbackInfo.intCount = 0;	
		pMySurfaces->myIMGCallbackInfo.dwFlags = 0;
		pMySurfaces->myVBICallbackInfo.dwFlags = 0;
		pMySurfaces->myIMGCallbackInfo.dwVersion = 0x100;
		pMySurfaces->myVBICallbackInfo.dwVersion = 0x100;		
		pMySurfaces->myIMGCallbackInfo.curBufferAddr = (U032)NULL;			
		pMySurfaces->myVBICallbackInfo.curBufferAddr = (U032)NULL;			
		pMySurfaces->myIMGCallbackInfo.lastBufferAddr = (U032)NULL;			
		pMySurfaces->myVBICallbackInfo.lastBufferAddr = (U032)NULL;			
		pMySurfaces->myIMGCallbackInfo.dwSize = sizeof(sCallBack);			
		pMySurfaces->myVBICallbackInfo.dwSize = sizeof(sCallBack);	
		
	}


	DPF("***CreateVideoPort32");


	DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
	DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
	DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
	DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
	DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
	DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
	DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
	DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);
	
	DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
	DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
	DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
	DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);
	
	DPF("	Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved2);
	DPF("	Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved3);

	
	// We'll assume for now that since CanCreate passed that our parameters are valid at this point
	// we need to setup the entire NV object system at this point

	// theorectically we should not have a channel open... let's check that?


	
	((PDEV*)MySurfaces.pDrvDat)->hVPEChannel = DD_PIO_VPE_CHANNEL_OBJECT_HANDLE;
	if (NvAllocChannelPio(  ((PDEV*)MySurfaces.pDrvDat)->hDriver,
			((PDEV*)MySurfaces.pDrvDat)->hClient,
			((PDEV*)MySurfaces.pDrvDat)->hDevice,
			((PDEV*)MySurfaces.pDrvDat)->hVPEChannel,
			NV03_CHANNEL_PIO,
			0,
			(PVOID)&pMySurfaces->pVPChanPtr,
			0
			) != NVOS04_STATUS_SUCCESS)
	{
	   DISPDBG((1, "NVDD: Cannot get NV PIO channel"));
	   NvFree(((PDEV*)MySurfaces.pDrvDat)->hDriver, ((PDEV*)MySurfaces.pDrvDat)->hClient, 
				NV01_NULL_OBJECT, ((PDEV*)MySurfaces.pDrvDat)->hClient);
	   NvClose(((PDEV*)MySurfaces.pDrvDat)->hDriver);
	   return FALSE;
	}
	
	returnVal = SetupVP ( lpInput);
	

	// For the overlay flip, store away a channel pointer
#ifndef VPE_NT
#ifdef NV4
	pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;
#else
	pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevFlatPio;
#endif	
	pMySurfaces->dwOverlaySubChan = NV_DD_SPARE;
	pMySurfaces->dwOverlayObjectID = NV_DD_YUV422_VIDEO_FROM_MEMORY;
	pMySurfaces->dwScalerObjectID = NV_DD_VIDEO_SCALER;
#else

  //CODE
  
#endif //VPE_NT		
	// don't forget to decrement the number of video ports avail number which is 
	lpInput->ddRVal = DD_OK;
	
	return returnVal;
}


/*
 * FlipVideoPort32
 *
 * This function is required
 */
DWORD __stdcall FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput)
{

    /*
     * Program registers to do the actual flip
     */

    /*
     * Save information for BOTH lpSurfCurr so we can know in the future
     * when the physical flip has occurred.
     */


	// Check that both surfaces are in our list
	U032	newSurfaceIndex;
	U032	oldSurfaceIndex;
	
	DPF("***FlipVideoPort32");
	

	oldSurfaceIndex = findSurface(lpInput->lpSurfCurr);
	if(oldSurfaceIndex  != SURFACENOTFOUND ) {
		newSurfaceIndex = findSurface(lpInput->lpSurfTarg);
		if(newSurfaceIndex != SURFACENOTFOUND ) {
			//  Now do some stuff... uh.. what?
			
			// Find out which of the buffers what programmed for the old surface
			U032	dwBufferIndex = NOSURFACEPROGRAMED;
			{
				U032 i;
				for(i=0;i<4;i++) {
					if(oldSurfaceIndex == pMySurfaces->CurrentBufferSurface[i] ) {
						dwBufferIndex = i;
						break;
					}
				}
				if (i == 4 ) {
					DPF("   Not sure which buffer was attached to the Current Surface in FlipVideoPort");
					return DDHAL_DRIVER_NOTHANDLED;
				}	
			}
			
			
			//  We could wait here until we know the hardware is done...
			//  instead we'll just check it real quick and print a whiner if it's not done
			//  and then fail
			{
				NvNotification* 	pNotify = pMySurfaces->Surfaces[oldSurfaceIndex]->pNvNotify;
				if(pNotify != NULL) {
					if (pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) {
						DPF("   Attempting to flip out a surface which is still in progress");
						return DDHAL_DRIVER_NOTHANDLED;
					}
					// check to see if we've had an error 
					//    there are LOTS of these....
					if ( (pNotify->status != NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) |
						  (pNotify->status != NV04D_NOTIFICATION_STATUS_DONE_SUCCESS ) |
						  (pNotify->status != NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED ) ){
						DPF("   Attempting to flip out a surface which had an error during capture");
						return DDHAL_DRIVER_NOTHANDLED;
					}
				} else {
					DPF("   Attempting to flip out a surface where the notifier was NULL");
					return DDHAL_DRIVER_NOTHANDLED;
				}
			}
			
			// Ok, program up the switch
			ProgramBufferWithSurface(dwBufferIndex,newSurfaceIndex,FALSE);
			
		
		} else {
			DPF("   Unable to find Target Surface during FlipVideoPort32");
			DPF("   There was a note that we could be receiving new surfaces ");
			DPF("                      ( Tobin or MS ?)..... need to add code for this");
			
			return DDHAL_DRIVER_NOTHANDLED;
		}
	
	} else {
		DPF("   Unable to find Current Surface during FlipVideoPort32");
		return DDHAL_DRIVER_NOTHANDLED;
	}
  	
	lpInput->ddRVal = DD_OK;
	
	return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortBandwidth32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput)
{

	DPF("***GetVideoPortBandwidth32");
	/*
	 * Determine how much bandwidth is available for the specified
	 * output format and fill in the information.
	 */
	 
	 // we are lucky in that we basically only support ONE format  YEAH!
	 
	 
	if (lpInput->dwFlags & DDVPB_TYPE) {
		lpInput->lpBandwidth->dwCaps = DDVPBCAPS_DESTINATION;  // we are limited by the "shrink" of the overlay 			
	}
	 
	if (lpInput->dwFlags & DDVPB_VIDEOPORT) {
		// The following four should indicate the MINIMUM stretch values represented as percentages times 10
		//  so if we could not stretch below 75% of the orginal size, the we should put in 750
		// for now I'll leave these "as is" because I need to collect the correct values -CJS
		lpInput->lpBandwidth->dwOverlay 				= 1000;
		lpInput->lpBandwidth->dwColorkey 				= 1000;  // Overlay/video port/colorkey works at 1X
		lpInput->lpBandwidth->dwYInterpolate			= 1000;	 // Overlay/video port works at 1X
		lpInput->lpBandwidth->dwYInterpAndColorkey		= 1000;  // Overlay/video port/interpolation works at 2X
	}
	
	
	if (lpInput->dwFlags & DDVPB_OVERLAY) {
		DPF("   We are NOT an overlay limited device but a destination ");
		DPF("      limited device we should not have been called");
	}
	
	lpInput->ddRVal = DD_OK;
	return DDHAL_DRIVER_HANDLED; 
}

/*
 * GetVideoPortInputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput)
{
   /* Only 1 input format supported UYVY 4:2:2 */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */
	DPF("   ***GetVideoPortInputFormat32");
	/*
	* The HAL is gaurenteed that the buffer in lpInput->lpddpfFormat
	* is large enough to hold the information
	*/

	DPF("   ***GetVideoPortInputFormat32");

	if (lpInput->dwFlags & DDVPFORMAT_VIDEO ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &InputFormats[0],  sizeof (DDPIXELFORMAT));
		}
	}

	if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &InputFormats[0],  sizeof (DDPIXELFORMAT));
		}
	}

	lpInput->ddRVal = DD_OK;
	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortOutputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput)
{
  	/* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

	DPF("***GetVideoPortOutputFormat32");


	/* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

	// default
	lpInput->dwNumFormats = 1;
	if (lpInput->lpddpfOutputFormats != NULL) {
		memcpy (lpInput->lpddpfOutputFormats, lpInput->lpddpfInputFormat, sizeof (DDPIXELFORMAT));
	}

	// for the video data
	if (lpInput->dwFlags & DDVPFORMAT_VIDEO) {// video formats
		// is input format a FOURCC
		if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
			// is it UYVY
			if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y')) {
				// translation of UYVY is UYVY (ie no translation)
   	    	lpInput->dwNumFormats = 1;
	   	   if (lpInput->lpddpfOutputFormats != NULL) {
					memcpy (lpInput->lpddpfOutputFormats, InputFormats, sizeof (DDPIXELFORMAT) );
		    	}
			}
		}
	}
	
	// for the VBI data
	if (lpInput->dwFlags & DDVPFORMAT_VBI) {// VBI formats
		// is input format a FOURCC
		if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
			// is it UYVY
			if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y')) {
				// translation of UYVY is UYVY (ie no translation)
   	    	lpInput->dwNumFormats = 1;
	   	   if (lpInput->lpddpfOutputFormats != NULL) {
					memcpy (lpInput->lpddpfOutputFormats, InputFormats, sizeof (DDPIXELFORMAT) );
		    	}
			}
		}
	}
	
	lpInput->ddRVal = DD_OK;
   return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortConnect32
 *
 * Returns the GUIDs describing the connections that can be supported.
 * Think of a GUID simply as a 128 bit FOURCC that you don't have to
 * register.  This function is required.
 */
DWORD __stdcall GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput)
{
    /*
     * If lpInput->lpGUIDs is NULL, simply return the number of GUIDS
     * supported
     */

	// eventually we should check dwPortId if there are more than one port in operation.
	// however since all the port will likely have the same capabilities maybe it's not an
	// issue
	
	DPF("***GetVideoPortConnectInfo");

	lpInput->dwNumEntries = 1;
	if(lpInput->lpConnect == NULL) {
		// this means that Dx is looking for the number of ways you can connect so that it can
		// allocate a structure for the next time around
		lpInput->ddRVal = DD_OK;
	} else {
		// fill in the one structure that we asked for..	
		memcpy (&(lpInput->lpConnect->guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
		lpInput->lpConnect->dwPortWidth = 8;
		lpInput->lpConnect->dwFlags = MY_CONNECTION_CAPS;	
	}

	return DDHAL_DRIVER_HANDLED;

}


/*
 * DestroyVideoPort32
 *
 * This optional function notifies the HAL when the video port
 * has been destroyed.
 */
DWORD __stdcall DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput)
{
	
	DPF("***DestroyVideoPort32");
	
	pMySurfaces->ImageCallbackRoutine = NULL;			
	pMySurfaces->VBICallbackRoutine = NULL;			
		
	tearDownVP();
	
	lpInput->ddRVal = DD_OK;
	
	return DDHAL_DRIVER_HANDLED;
}




/*
 * GetVideoPortFlipStatus32
 *
 * This required function allows DDRAW to restrict access to a surface
 * until the physical flip has occurred, allowing doubled buffered capture.
 */

DWORD __stdcall GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput)
{
	
	U032	dwIndex;
	
	//DPF("***GetVideoPortFlipStatus32");
	if( MySurfaces.dwVideoPortStatus == VP_NOT_RUNNING ) {
   	lpInput->ddRVal = DD_OK;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// search through all of our known surfaces looking for the one it's curious about
	for (dwIndex = 0; dwIndex < pMySurfaces->numberOfSurfaces ; dwIndex++) {
		if (pMySurfaces->Surfaces[dwIndex]->pVidMem == lpInput->fpSurface) {
			// this means we've found the surface that DX is curious about												
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify == NULL ) {
				ASSERT(1==0);
				DPF("   NOTIFY WAS NULL  !!!!!!!!!!!");
   			lpInput->ddRVal = DD_OK;
				return DDHAL_DRIVER_HANDLED;
			}
			
			if(pMySurfaces->Surfaces[dwIndex]->pNvNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) {
				lpInput->ddRVal = DDERR_WASSTILLDRAWING;
			} else {
				lpInput->ddRVal = DD_OK;
			}
			// return here... we found the surface
			return DDHAL_DRIVER_HANDLED;
		}
	}
	
	DPF("   ***FlipStatus having trouble  --> Surface does");
	DPF("          not exist in my list of surfaces");
	lpInput->ddRVal = DD_OK;

	return DDHAL_DRIVER_HANDLED;
}



U032 startSurfaces(U032	bInterleave, VPSTATE*	pVideoPortStatus ) {
	U032	rValue = DD_OK;
	VPSTATE	myState = *pVideoPortStatus;
	// figure out which buffers to program up and launch them...
	if(bInterleave) {
		 DPF("   Now Launching surfaces.... INTERLEAVED");
	} else {
		 DPF("   Now Launching surfaces.... NOT INTERLEAVED");
	}
	// zero out the last overlay scaler size so we're sure it gets reprogrammed
	pMySurfaces->lastsrcDeltaY = 0;
	pMySurfaces->bStopVP = FALSE;	
	if( bInterleave ) {
		// both buffers will point to the same surface
		if( pMySurfaces->VBIstart >0 ) {
			if( ProgramBufferWithSurface(0,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			
			// since this is interleave always start the second buffer with the first surface
			if( ProgramBufferWithSurface(1,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			myState |= VP_IMAGE_CAPTURING;
		}
	} else {
	
		// buffers will point to consecutive surfaces
		if( pMySurfaces->VBIstart >0 ) {
			if( ProgramBufferWithSurface(0,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			myState |= VP_IMAGE_CAPTURING;
		}
		// check for another surface
		if( pMySurfaces->VBIstart > 1 ) {
			if( ProgramBufferWithSurface(1,1,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
		} else {
			// fire up the second buffer at the first surface
			if( ProgramBufferWithSurface(1,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
		}
	}
			
	// Now do VBI
	// start first vbi on first surface
	if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 0 ) {
		if( ProgramBufferWithSurface(2,pMySurfaces->VBIstart,FALSE))
				rValue = DDERR_INVALIDPARAMS;
		myState |= VP_VBI_CAPTURING;
	
		// now check to see if we have another surface
		if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 1 ) {
			if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+1,FALSE))
					rValue = DDERR_INVALIDPARAMS;
		} else {
			// set second buffer to first surface
			if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+0,FALSE))
					rValue = DDERR_INVALIDPARAMS;
		}
	}	
	*pVideoPortStatus = myState;
	
	return rValue;
}


/*
** UpdateVideoPort32
**
** This required function sets up the video port
*/
 
DWORD __stdcall UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput)
{

	VPERRORS myErrors;
	U032		bAutoflip;
#ifndef NV4
	U032		bDelayNV3;
#endif
	
	DPF("***UpdateVideoPort32");


	
	lpInput->ddRVal = DD_OK;
		
	{		
		/*
		 * Turn off the video port
		 */
//CODE
		DPF("   now Stopping the Video Port");

		StopVP();
	
		MySurfaces.dwVideoPortStatus = VP_NOT_RUNNING;
    
	} 
	
	if (lpInput->dwFlags != DDRAWI_VPORTSTOP) { 
#ifndef NV4
		bDelayNV3 = FALSE;
#endif //NV4
		if (lpInput->dwFlags == DDRAWI_VPORTSTART) {
			DPF("   now Starting Video Port for the first time");

		// This is the first round....
#ifndef NV4
			bDelayNV3 = TRUE;
#endif	//NV4

		} 
		
		DPF("   now updating the video port");

		{
			// print some stuff out about the flags we're lookin at:
			
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP	) {
				DPF("      FLAG DVP_AUTOFLIP            on");	
			} else {
				DPF("      FLAG DVP_AUTOFLIP            off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CONVERT		) {
				DPF("      FLAG DDVP_CONVERT            on");	
			} else {
				DPF("      FLAG DDVP_CONVERT            off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP					) {
				DPF("      FLAG DDVP_CROP               on");	
			} else {
				DPF("      FLAG DDVP_CROP               off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE			) {
				DPF("      FLAG DDVP_INTERLEAVE         on");	
			} else {
				DPF("      FLAG DDVP_INTERLEAVE         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT		) {
				DPF("      FLAG DDVP_MIRRORLEFTRIGHT    on");	
			} else {
				DPF("      FLAG DDVP_MIRRORLEFTRIGHT    off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN			) {
				DPF("      FLAG DDVP_MIRRORUPDOWN       on");	
			} else {
				DPF("      FLAG DDVP_MIRRORUPDOWN       off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE				) {
				DPF("      FLAG DDVP_PRESCALE           on");	
			} else {
				DPF("      FLAG DDVP_PRESCALE           off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS		) {
				DPF("      FLAG DDVP_SKIPEVENFIELDS     on");	
			} else {
				DPF("      FLAG DDVP_SKIPEVENFIELDS     off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS			) {
				DPF("      FLAG DDVP_SKIPODDFIELDS      on");	
			} else {
				DPF("      FLAG DDVP_SKIPODDFIELDS      off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SYNCMASTER				) {
				DPF("      FLAG DDVP_SYNCMASTER         on");	
			} else {
				DPF("      FLAG DDVP_SYNCMASTER         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBICONVERT				) {
				DPF("      FLAG DDVP_VBICONVERT         on");	
			} else {
				DPF("      FLAG DDVP_VBICONVERT         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBINOSCALE				) {
				DPF("      FLAG DDVP_VBINOSCALE         on");	
			} else {
				DPF("      FLAG DDVP_VBINOSCALE         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_OVERRIDEBOBWEAVE		) {
				DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   on");	
			} else {
				DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP		) {
				DPF("      FLAG DDVP_IGNOREVBIXCROP     on");	
			} else {
				DPF("      FLAG DDVP_IGNOREVBIXCROP     off");	
			}
			
		
		}
		
		// Decide which capture mode to be in given if we're trying to skip some types of fields
		
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS ) {
			pMySurfaces->CurrentCaptureMode = ODDODD;
		} else if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS ) {
			pMySurfaces->CurrentCaptureMode = EVENEVEN;
		} else {
			if(pMySurfaces->bInputInterLaced)
				pMySurfaces->CurrentCaptureMode = EVENODD;
			else
				pMySurfaces->CurrentCaptureMode = PROGRESSIVE;
		}
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP ) {
			bAutoflip = TRUE;
		} else {
			bAutoflip = FALSE;
		}
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE ) {
			pMySurfaces->CurrentScanMode = INTERLEAVBUF;
		} else {
			pMySurfaces->CurrentScanMode = SEPERATEBUF;
		}
		
		{	
			// Here's where we're going to try to figure out where to put things in the vertical and horz
			// dimensions
			
			// At key thing here are the two different modes which people are using to capture VBI
			// one is that the VBI data is captured to the very beginning of the VIDEO surface in one big surface
			// the other mode is with a seperate surface
			
			// we can detect which mode by examining the number of VBI surface if > 0 we're in the second mode
		
			// When there ARE VBI surfaces, then we should jam the Video data right to the very beginning of the
			// video surface, since we know this is where it will be expected.
			
			// additionally we've reported DDVPCONNECT_DISCARDSVREFDATA is true which means 
			// "/*
			//	 * Indicates that any data written to the video port during the VREF
			//	 * period will not be written into the frame buffer. This flag is read only.
			//	 */"
		   //  MS of course not really defining what the VREF period means in their land.
			
				
#define VBIVALIDDATALINE  (0x4)	

			pMySurfaces->dwVBIStartLine = VBIVALIDDATALINE;	// at least we're not starting with zero this first four are always
																			// empty as best as I know
			
			pMySurfaces->dwVBIHeight = lpInput->lpVideoInfo->dwVBIHeight;
			
			
			pMySurfaces->dwImageStartLine = pMySurfaces->dwVBIHeight + pMySurfaces->dwVBIStartLine - VBIVALIDDATALINE;
			
			// if  	dwImageStartLine < 1  then things don't work to well
			if(pMySurfaces->dwImageStartLine < 1) pMySurfaces->dwImageStartLine = 1;
			
			// this is the only way I know how to do the check for vertical cropping
			if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
				pMySurfaces->dwOutHeight = (DWORD)lpInput->lpVideoInfo->rCrop.bottom - lpInput->lpVideoInfo->rCrop.top;				
				pMySurfaces->dwOutWidth  = lpInput->lpVideoInfo->rCrop.right - lpInput->lpVideoInfo->rCrop.left;		
				DPF("   UPDATE:         crop TOP %d",lpInput->lpVideoInfo->rCrop.top);				
				if(lpInput->lpVideoInfo->rCrop.top > (signed long) pMySurfaces->dwImageStartLine ) {
					pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
				}		
			} else {
				pMySurfaces->dwOutHeight = lpInput->lpVideoPort->ddvpDesc.dwFieldHeight;
				pMySurfaces->dwOutWidth  = lpInput->lpVideoPort->ddvpDesc.dwFieldWidth;
			}
			
			// this is something of a hack I suppose
			pMySurfaces->dwOutHeight = pMySurfaces->dwOutHeight;			
						
			// if we're prescaling then do something
			if (DDVP_PRESCALE & lpInput->lpVideoInfo->dwVPFlags) {
				pMySurfaces->dwPreHeight = lpInput->lpVideoInfo->dwPrescaleHeight;				
				pMySurfaces->dwPreWidth  = lpInput->lpVideoInfo->dwPrescaleWidth;
			} else {
				pMySurfaces->dwPreHeight = pMySurfaces->dwOutHeight;
				pMySurfaces->dwPreWidth = pMySurfaces->dwOutWidth;
			}
			
			
			pMySurfaces->dwOriginX = lpInput->lpVideoInfo->dwOriginX;
			pMySurfaces->dwOriginY = lpInput->lpVideoInfo->dwOriginY;
		}
		
		switch (pMySurfaces->CurrentCaptureMode) {
				case EVENODD:
					DPF("   UPDATE:     capture mode EVENODD");	
					break;
				case EVENEVEN:
					DPF("   UPDATE:     capture mode EVENEVEN");							
					break;
				case ODDODD:
					DPF("   UPDATE:     capture mode ODDODD");	
					break;
		}
		switch (pMySurfaces->CurrentScanMode) {
				case SEPERATEBUF:
					DPF("   UPDATE:        scan mode SEPERATEBUF");	
					break;
				case INTERLEAVBUF:
					DPF("   UPDATE:        scan mode INTERLEAVBUF");	
					break;
		}
		
		DPF("   UPDATE: image start line %d",pMySurfaces->dwImageStartLine);
		DPF("   UPDATE: image out dimens %d,%d",pMySurfaces->dwOutWidth,pMySurfaces->dwOutHeight);
		DPF("   UPDATE: image pre dimens %d,%d",pMySurfaces->dwPreWidth,pMySurfaces->dwPreHeight);
		DPF("   UPDATE:   image position %d,%d",pMySurfaces->dwOriginX,pMySurfaces->dwOriginY);

		myErrors = replaceSurfaceList(lpInput->dwNumAutoflip,lpInput->dwNumVBIAutoflip,
										lpInput->lplpDDSurface, lpInput->lplpDDVBISurface,bAutoflip);
		if( myErrors == NOVPERROR ) {
#ifndef NV4
			lpInput->ddRVal = startSurfaces( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(MySurfaces.dwVideoPortStatus));
#else
			{
				lpInput->ddRVal = startSurfaces( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(MySurfaces.dwVideoPortStatus));
			}
#endif //NV4
#ifndef NV4
						
		} else {
			DPF("   Problem updating the Video Port = %d",myErrors);

			switch (myErrors) {
					case CANTCREATESURFACE:
						lpInput->ddRVal = DDERR_OUTOFMEMORY;
						break;
					case TOOMANYSURFACESERROR:
					case  SURFACENOTFOUND:
					default:
						lpInput->ddRVal = DDERR_INVALIDPARAMS;
						break;
			}
				
			return DDHAL_DRIVER_HANDLED;
	
		
			
#endif //NV4
		}	// NOVPERROR
	}  // DDRAWI_VPORTSTOP

	return DDHAL_DRIVER_HANDLED;
}



/*
 * WaitForVideoPortSync32
 *
 * Wait for the LPB Video VSYNC (note: this is entirely
 * different from the screen refresh VGA VSYNC).
 *
 * TBD: No hard polling loops.  Must use lpInput->dwTimeOut
 */
DWORD __stdcall WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput)
{
	DPF("***WaitForVideoPortSync32");
	
	lpInput->ddRVal = DDVPSQ_NOSIGNAL;
	
	// if the port is running then
	if (MySurfaces.dwVideoPortStatus != VP_NOT_RUNNING) {
		if( lpInput->dwFlags & DDVPWAIT_BEGIN ) {
			// wait for a vsync start.   timeout in lpInput->dwTimeOut
			U032	bigTime;
			U032	smallTime;
			U032	milliTime;
			U032	recentTime[MAXVPSURFACES];
			U032 	dwIndex;
			U032	searchMAX;
	
		// find out what time it is now
			getCurrentNanoTimer(&bigTime, &smallTime);
			milliTime = getMilliTime();
			
			if( pMySurfaces->VBIstart == 0 ) {
				// we're only running VBI so check ALL the surfaces
				searchMAX = pMySurfaces->numberOfSurfaces;
			} else {
				// there is at least one image surface, so check for that
				searchMAX = pMySurfaces->VBIstart;
			}
			//find the current notifiers for the IMAGE surfaces
			for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
				if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
					recentTime[dwIndex] = pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
				} else {
					recentTime[dwIndex] = 0;
				}
			}
			while( (getMilliTime() < ( milliTime + lpInput->dwTimeOut)) && ( lpInput->ddRVal == DDVPSQ_NOSIGNAL) ) {
				for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
					if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
						if( recentTime[dwIndex] < pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] ) {
							// ok, ONE Of the notifiers moved foward
							lpInput->ddRVal = DD_OK; 	//  We found a sync
						}
					}
				}
			}
			// start a while		
		} else if (lpInput->dwFlags & DDVPWAIT_END ) {
			//  timeout in lpInput->dwTimeOut
			// we could wait for ysync that then see which buffer we're on then wait for the line counter
			// to change  .. YUCK
			DPF("   Sorry, don't handle waiting for the end");
	
			return DDHAL_DRIVER_NOTHANDLED;
		} else if (lpInput->dwFlags & DDVPWAIT_LINE ) {
			//timeout in lpInput->dwTimeOut
				// lpInput ->dwLine
			DPF("   Sorry, can't wait for a particular line");
			return DDHAL_DRIVER_NOTHANDLED;
		};
		
	}// videoport status
	
	return DDHAL_DRIVER_HANDLED;
}


DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput) {	
	
	U032	dwIndex;
	ASSERT(lpInput != NULL);

	DPF("***GetVideoSignalStatus32");
	if( lpInput == NULL)
	{
		DPF("   Input NULL in GetVideoSignalStatus32");
		return DDHAL_DRIVER_NOTHANDLED;
	}
	// If the video port is not running, then we just don't know...
	if( MySurfaces.dwVideoPortStatus == VP_NOT_RUNNING ) {
		DPF("   could not get the signal status, the video port is not running");
		// we'll return no signal in this case....
		lpInput->dwStatus = DDVPSQ_NOSIGNAL;
		lpInput->ddRVal = DDERR_VIDEONOTACTIVE;

		return DDHAL_DRIVER_HANDLED;
	}
	
	lpInput->ddRVal = DD_OK;
	// default for now is that the signal is good
	lpInput->dwStatus = DDVPSQ_SIGNALOK;
	// first check the notifiers to see if there has been ANY sync
	//     do this by seeing if the notify times are none zero
	{
		U032	probablyRunning = FALSE;
		for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
				if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
					probablyRunning = TRUE;
					break;
				}
			}
		}
		
		// if the timer are zero then wait at least 1/24 of a second and check again.
		if(!probablyRunning) {
			// find current time
			U032	 tempTime;
			tempTime = getMilliTime();
			//now wait for 1/24 of a second
			while(tempTime + (1000/24) > getMilliTime()); 
			// and then check one more time for a possible completion
			for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
				if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
					if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
						probablyRunning = TRUE;
						break;
					}
				}
			}
			
			// if it's still non zero report no signal
			if(!probablyRunning) {
				lpInput->dwStatus = DDVPSQ_NOSIGNAL;
			}

		}	
	}
	
	// have we already decided that the signal is bad...?
	if( lpInput->dwStatus != DDVPSQ_NOSIGNAL ) {
		
		// Now the default is that the signal is bad
		lpInput->dwStatus = DDVPSQ_NOSIGNAL;
		
		// check to see that at least one of of the notifiers is LESS than 1/24 of a second
		for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
				if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
					U032 diff;
					// ok, we've got a non-zero surface, let's check to see how recent it is
					U032	BigCurrentTime;
					U032	SmallCurrentTime;
					
					getCurrentNanoTimer(&BigCurrentTime,&SmallCurrentTime);
					if(pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[1] < BigCurrentTime ) {
						// we've got a wrap around situation.  this means that we need to work in weirder math
						diff = (
									((0x80000000)  - (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] >> 1))
									+  (SmallCurrentTime >> 1)
								 ) << 1;
					} else {
						// do a simple subtraction
						diff = SmallCurrentTime - pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
					}
					//diff now has the delta between the notify and "now"  
					// if the notifier is LESS than a frame period then we've got a signal
					if(diff < MAXFRAMEPERIOD ) {
						lpInput->dwStatus = DDVPSQ_SIGNALOK;
					}
					
				}
			}
		}

	}
	
	return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortField32
 *
 * This function is only required if readback of the current
 * field is supported.
 */

DWORD __stdcall GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput)
{
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

    /*
     * Readback whether the field is even or odd.  lpInput->bField is
     * set to TRUE if the current field is even.
     */
	//DPF("***GetVideoPortField32");
	
	if (MySurfaces.dwVideoPortStatus == VP_NOT_RUNNING) {
		//DPF("   Video is not active!!!");
		lpInput->bField = 0;
	   lpInput->ddRVal = DDERR_VIDEONOTACTIVE;	
	} else {
	 /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

		lpInput->bField = GetField();
		
		lpInput->ddRVal = DD_OK;

		lpInput->bField = 0;
	}	
	
	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortLine32
 *
 * This function is only required if readback of the current
 * video line number (0 relative) is supported.
 */
DWORD __stdcall GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput)
{

	DPF("***GetVideoPortLine32");
 
 
	if (MySurfaces.dwVideoPortStatus == VP_NOT_RUNNING) {
		//DPF("   Video is not active!!!");
		lpInput->dwLine = 0;
	   lpInput->ddRVal = DDERR_VIDEONOTACTIVE;	
	} else {
	 /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

		lpInput->dwLine = getCurLine();
		lpInput->ddRVal = DD_OK;
		
	}	
	
	return DDHAL_DRIVER_HANDLED;
}

/*
 ** SyncVideoPortData32
 *
 *  FILENAME: C:\win9x\display\mini\s3\S3_DD32.C
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
#if 0
DWORD WINAPI SyncVideoPortData32(LPDDHAL_SYNCVIDEOPORTDATA lpInput)
{
    LPS3THKINFO sData = VP_GETSDATA(lpInput);

    DPF("SyncVideoPortData");

    lpInput->dwOriginOffset = pLPB->dwBaseOffset;

    /*
    ** !! KMVT Field dropping functionality requires a
    ** place to cache the "real" decimation pattern.  So
    ** we (S3) will reserve dwDriverReserved1 for this
    ** purpose.
    */
    lpInput->dwDriverReserved1 = pLPB->dwVDecimationPattern;

    return DDHAL_DRIVER_HANDLED;
}

#endif

/*
 ** SyncSurfaceData32
 *
 *  FILENAME: C:\win9x\display\mini\s3\S3_DD32.C
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
#if 0
DWORD WINAPI SyncSurfaceData32(LPDDHAL_SYNCSURFACEDATA lpInput)
{
    LPS3THKINFO sData = VP_GETSDATA(lpInput);

    lpInput->dwSurfaceOffset
        = SCREENOFFSET(sData, lpInput->lpDDSurface->lpGbl->fpVidMem);
    lpInput->dwOverlayOffset
        = lpInput->dwSurfaceOffset + UPDATEOVERLAYFLIPOFFSET(sData);

    DPF("SyncSurfaceData dwOverlayOffset=%lx", lpInput->dwOverlayOffset);

    return DDHAL_DRIVER_HANDLED;
}

#endif


/*
** IndexFromGUID
**
** Get the index into our supported connection table,
** given a GUID.  returns 0 if it isn't a supported
** connection type
*/
int IndexFromGUID(GUID *pGUID)
{
    int i, index;

    index = -1;                          // assume not found

    for (i=0; i<MAX_VP_TYPES; i++)
    {
        if (memcmp(guids[i], pGUID, sizeof(GUID)) == 0)
        {
            index = i;                  // found a match
            break;
        }
    }

    //TRACE("IndexFromGUID found GUID %d",i);

    return index;
}

//#endif // DX5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\vpe_nt.h ===
// this will bring over alot of types which are useful

#include <dx95type.h>

#ifndef DEBUG
	#ifndef DPF
	    #define DPF         1 ? (void)0 : (void)
	#endif
#else
/*
 * Msg
 * Defined in ddsamp.c
 */
extern void __cdecl DPF( LPSTR szFormat, ... );
#endif

/* Debug stuff */
#ifdef DEBUG
	#define ASSERT(ParamAssert) 	(ParamAssert)? \
			(void)0:DPF("Assertion failed in %s at line %i\n", __FILE__, __LINE__)

	#define strASSERT( Condition, string )	(Condition)?\
			(void)0:DPF("Assertion failed in %s at line %i, %s", __FILE__, __LINE__, strAssert)		

#else
	#define Assert( ParamAssert )
	#define ASSERT( ParamAssert )
	#define strASSERT( Condition, string )
#endif
	
/* Prototypes for VPE_NT.c */
                                   
DWORD PASCAL CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput);
DWORD __stdcall CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput);
DWORD __stdcall FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput);
DWORD __stdcall GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput);
DWORD __stdcall GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput);
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput);
DWORD __stdcall GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput);
DWORD __stdcall GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput);
DWORD __stdcall GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput);
DWORD __stdcall DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput);
DWORD __stdcall GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput);
DWORD __stdcall UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput);
DWORD __stdcall WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput);
DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput);	


// This structure will be used to store all of the OS specific stuff which might 
// otherwise be part of the vpSurfaces  structure

typedef struct _OSSpecificGlobals {
	long	dwVideoPortsAvailable;		// the number of video ports available.. inited as one usually
												// and decremented per useage
												
												
} OSSpecificGlobals;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wksappsupport.c ===
/**************************************************************************
** wksappsupport.c
**
** This module handles the ESC_NV_WKS_APP_SUPPORT escape to 
** support the workstation tools interface.
**
** Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
**
** FNicklisch 09.11.2000: New
** FNicklisch 21.11.2000: Implemented SUBESC_WKS_WINDOW_STEREOMODE
**************************************************************************/

// import
#include "precomp.h"
#include "driver.h"
#include "Nvcm.h"
#include "nvapi.h"
#include "nv32.h"
#include "oglDD.h"
#include "oglstereo.h"
#include "wincommon.h"
#include "pixelfmt.h"

// export
#include "wksappsupport.h"


static BOOL bWksWindowStereoSupport(
    IN     PPDEV ppdev,
    IN     NV_WKS_WINDOW_STEREOMODE_IN  *pWindowStereoModeIn ,
       OUT NV_WKS_WINDOW_STEREOMODE_OUT *pWindowStereoModeOut);


#define CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cj, cjNeeded, lRet, pHeadOut, lErrorCode); \
    if (cj != cjNeeded)                     \
    {                                       \
        if (NULL != pHeadOut)               \
        {                                   \
            pHeadOut->ulSize  = cjNeeded;   \
            pHeadOut->lResult = lErrorCode; \
        }                                   \
        lRet = WKS_ESC_SUCCEED;             \
        goto Exit;                          \
    }

#define CHECK_CJINOUT_AND_GOTO_EXIT_IF_FAIL(cjIn, cjInNeeded, cjOut, cjOutNeeded, lRet, pHeadOut);   \
    CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjIn , cjInNeeded , lRet, pHeadOut, NV_WKS_RESULT_ERROR_INSIZE ); \
    CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjOut, cjOutNeeded, lRet, pHeadOut, NV_WKS_RESULT_ERROR_OUTSIZE);


//*************************************************************************
// lWksAppSupport
//
// handles all ESC_NV_WKS_APP_SUPPORT subescapes.
// return WKS_ESC_SUCCEED     - escape was handled, detailed status
//                              in NV_WKS_HEAD_OUT.
//        WKS_ESC_UNSUPPORTED - unsupported escape
//        WKS_ESC_FAILED      - escape failed
//*************************************************************************
LONG lWksAppSupport(
    SURFOBJ *pso, 
    ULONG   cjIn, 
    VOID    *pvIn,
    ULONG   cjOut, 
    VOID    *pvOut)
{
    LONG             lRet        = WKS_ESC_FAILED; // default to error
    NV_WKS_HEAD_IN  *pHeadIn     = (NV_WKS_HEAD_IN *)pvIn;
    NV_WKS_HEAD_OUT *pHeadOut    = NULL;
    PPDEV            ppdev       = NULL;

    ASSERT(NULL != pso);
    ASSERT(NULL != pvIn);
    ASSERT(cjIn > 0);

    if (   (NULL == pvIn)
        || (cjIn < sizeof(NV_WKS_HEAD_IN))
        || ( (cjOut != 0) && (NULL == pvOut) ) 
        || ( (cjOut != 0) && (cjOut < sizeof(NV_WKS_HEAD_OUT) ) )
       )
    {
        // interface error, escape used in a wrong manner
        goto Exit;
    }

    //
    // Check and initialize out structure
    //
    if (cjOut != 0)        
    {
        ASSERT(NULL != pvOut);
        ASSERT(cjOut>= sizeof(NV_WKS_HEAD_OUT));

        RtlZeroMemory(pvOut, cjOut);

        pHeadOut            = (NV_WKS_HEAD_OUT *)pvOut;
        pHeadOut->ulVersion = NV_WKS_VERSION;

        CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjIn , pHeadIn->ulInSize , lRet, pHeadOut, NV_WKS_RESULT_ERROR_INSIZE );
        CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjOut, pHeadIn->ulOutSize, lRet, pHeadOut, NV_WKS_RESULT_ERROR_OUTSIZE);

        pHeadOut->ulSize    = pHeadIn->ulOutSize;
        pHeadOut->lResult   = NV_WKS_RESULT_ERROR; // until now we assume we fail
    }

    ppdev = (PDEV *)pso->dhpdev;

    //
    // handle known escapes
    //
    switch (pHeadIn->ulSubEsc)
    {
        case SUBESC_WKS_GET_CAPS:
        {
            ULONG               status;
            NV_WKS_GET_CAPS_IN  *pGetCapsIn  = pvIn;
            NV_WKS_GET_CAPS_OUT *pGetCapsOut = pvOut;

            CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjIn , sizeof(NV_WKS_GET_CAPS_IN ), lRet, pHeadOut, NV_WKS_RESULT_ERROR_INSIZE );
            CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjOut, sizeof(NV_WKS_GET_CAPS_OUT), lRet, pHeadOut, NV_WKS_RESULT_ERROR_OUTSIZE);

            //
            // Get data
            //

            // translate the config bits that possibly change in future to a stable interface
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_AA_LINES       ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_AA_LINES       ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_AA_POLYS       ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_AA_POLYS       ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_AKILL_USERCLIP ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_AKILL_USERCLIP ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_LOGIC_OPS      ) 
                pGetCapsOut->flGr