DBG)
	// checked by caller
	if (NULL == pszHardwareID || NULL == pszLocalDir || NULL == pszDisplayName)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
#endif


	// Load newdev.dll and get pointer to our function
	if (NULL == (hLibModule = LoadLibraryFromSystemDir(_T("newdev.dll"))))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (NULL == (pfnInstallWindowsUpdateDriver = (PFN_InstallWindowsUpdateDriver)GetProcAddress(hLibModule,"InstallWindowsUpdateDriver")))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
		
	// Industry Update RAID # 461 waltw	May need to massage HWID's for site Driver Install for Win2K
	//
	// Linked to: RAID # 12021 in Windows Update Database - This logic (required for Win2K) is implemented
	// on the server rather than the client in IU (V3 Wuv3is implements this on the client)
	//
    // first, we search for a matching SPDRP_HARDWAREID
	// if we didn't find a Hardware ID, we search for a matching SPDRP_COMPATIBLEID, 
	// and we pass the last SPDRP_HARDWAREID associated with the same device.
#if (defined(UNICODE) || defined(_UNICODE))
    LOG_Driver (_T("InstallWindowsUpdateDriver(GetActiveWindow(), %s, %s, %s, fForce=%d, fBackup=%d)"), 
				pszHardwareID, pszLocalDir, pszDisplayName, FALSE, TRUE);
#endif
	// 
	// NOTES on calling InstallWindowsUpdateDriver():
	// * Never pass TRUE  in Force flag (only used if we are doing uninstall, which we don't support).
	// * Always pass TRUE in Backup flag.
	// * OK to cast away const-ness on strings since InstallWindowsUpdateDriver takes const wide strings
	if(!(pfnInstallWindowsUpdateDriver)(GetActiveWindow(),
				T2OLE(const_cast<TCHAR*>(pszHardwareID)),
				T2OLE(const_cast<TCHAR*>(pszLocalDir)),
				T2OLE(const_cast<TCHAR*>(pszDisplayName)), FALSE, TRUE, pdwReboot))
    {
        LOG_Driver(_T("InstallWindowsUpdateDriver returned false. Driver was not be updated."));
		Win32MsgSetHrGotoCleanup(GetLastError());
    }

CleanUp:

    if (NULL != hLibModule)
	{
		FreeLibrary(hLibModule);
		hLibModule = NULL;
	}

	return hr;
}

//
// MatchHardwareID (used only on Windows 2000)
//
// Takes as input a hardware or compatible ID and returns an allocated
// buffer with the same hardware ID or, if it was a compatible ID the
// most general hardware ID for the device node that matched the
// given compatible ID.
//
// Return: S_OK if a match was found, else a failure code
//
// *ppszMatchingHWID must be NULL on entry, and if S_OK is returned
// the buffer must be heap-freed by the caller.
//
HRESULT MatchHardwareID(LPCWSTR pwszHwOrCompatID, LPWSTR * ppszMatchingHWID)
{
	LOG_Block("MatchHardwareID");

	HRESULT hr = E_FAIL;

    SP_DEVINFO_DATA DeviceInfoData;
    DWORD           dwIndex = 0;
    DWORD           dwSize = 0;

    LPWSTR          pwszHardwareIDList = NULL;
    LPWSTR          pwszCompatibleIDList = NULL;
    LPWSTR          pwszSingleID = NULL;

    HDEVINFO		hDevInfo = INVALID_HANDLE_VALUE;
	BOOL			fRet;

    ZeroMemory((void*)&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

	if (NULL == pwszHwOrCompatID || NULL == ppszMatchingHWID || NULL != *ppszMatchingHWID)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}

	// get a handle to the class devices
    hDevInfo = SetupDiGetClassDevs(NULL,
                                   NULL,
                                   GetActiveWindow(),
                                   DIGCF_ALLCLASSES | DIGCF_PRESENT
                                   );

    if (INVALID_HANDLE_VALUE == hDevInfo)
	{
		Win32MsgSetHrGotoCleanup(ERROR_INVALID_HANDLE);
    }

    //loop through all devices
	DWORD dwBufLen=0;
	while ((NULL == *ppszMatchingHWID) && SetupDiEnumDeviceInfo(hDevInfo,
								 dwIndex++,
								 &DeviceInfoData
								 ))
	{
		//
		// Free up buffers for each device node loop (if allocated)
		//
		SafeHeapFree(pwszHardwareIDList);
		SafeHeapFree(pwszCompatibleIDList);
		dwSize = 0;
		//
		// Get the list of Hardware Ids for this device
		//
		fRet = SetupDiGetDeviceRegistryPropertyW(hDevInfo,
										 &DeviceInfoData,
										 SPDRP_HARDWAREID,
										 NULL,
										 NULL,
										 0,
										 &dwSize
										 );

		if (0 == dwSize || (FALSE == fRet && ERROR_INSUFFICIENT_BUFFER != GetLastError()))
		{
			//
			// FIX: NTRAID#NTBUG9-500223-2001/11/28- IU - Dual mode USB camera install fails while installing of web site
			//
			// If we hit a node without a HWID before finding device node we are looking for, just continue. If the node
			// we ARE looking for doesn't have a HWID then we will fail later anyway when we run out of nodes.
			//
 			LOG_Out(_T("No HWID's found for device node"));
			continue;
		}

		if (MAX_SETUP_MULTI_SZ_SIZE_W < dwSize)
		{
			//
			// Something is very wrong - bail
			//
			CleanUpIfFailedAndSetHrMsg(ERROR_INSUFFICIENT_BUFFER);
		}

		//
		// We got the expected ERROR_INSUFFICIENT_BUFFER with a reasonable dwSize
		//
		// Now guarantee we are double-NULL terminated by allocating two extra WCHARs we don't tell SetupDi about
		//
		pwszHardwareIDList = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize + (sizeof(WCHAR) * 2));
		CleanUpFailedAllocSetHrMsg(pwszHardwareIDList);

		if (SetupDiGetDeviceRegistryPropertyW(hDevInfo,
											 &DeviceInfoData,
											 SPDRP_HARDWAREID,
											 NULL,
											 (PBYTE)pwszHardwareIDList,
											 dwSize,
											 &dwSize
											 ))
		{
			//
			// If any of the devices HardwareIDs match the input ID then
			// we copy the incoming argument to a new buffer and return true 
			//
          
			for (pwszSingleID = pwszHardwareIDList;
				 *pwszSingleID;
				 pwszSingleID += lstrlenW(pwszSingleID) + 1)
			{

				if (0 == lstrcmpiW(pwszSingleID, pwszHwOrCompatID))
				{
                    // return the hardware ID we matched
					dwBufLen=(lstrlenW(pwszHwOrCompatID) + 1);
                    *ppszMatchingHWID = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
									dwBufLen * sizeof(WCHAR));
					CleanUpFailedAllocSetHrMsg(*ppszMatchingHWID);
                   
					hr=StringCchCopyExW(*ppszMatchingHWID,dwBufLen,pwszHwOrCompatID,NULL,NULL,MISTSAFE_STRING_FLAGS);
				     goto CleanUp;
				}
			}
		}

		//
		// Hardware match not found, let's try to match to a
		// compatible ID then return the (most generic) Hardware ID 
		// associated with the same device node
		//
		fRet = SetupDiGetDeviceRegistryPropertyW(hDevInfo,
										 &DeviceInfoData,
										 SPDRP_COMPATIBLEIDS,
										 NULL,
										 NULL,
										 0,
										 &dwSize
										 );

		if (0 == dwSize || (FALSE == fRet && ERROR_INSUFFICIENT_BUFFER != GetLastError()))
		{
 			LOG_Out(_T("No Compatible ID's found for device node"));
			continue;
		}

		if (MAX_SETUP_MULTI_SZ_SIZE_W < dwSize)
		{
			//
			// Something is very wrong - bail
			//
			CleanUpIfFailedAndSetHrMsg(ERROR_INSUFFICIENT_BUFFER);
		}

		//
		// We got the expected ERROR_INSUFFICIENT_BUFFER with a reasonable dwSize
		//
		// Now guarantee we are double-NULL terminated by allocating two extra WCHARs we don't tell SetupDi about
		//
		pwszCompatibleIDList = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize + (sizeof(WCHAR) * 2));
		CleanUpFailedAllocSetHrMsg(pwszCompatibleIDList);

		if (SetupDiGetDeviceRegistryPropertyW(hDevInfo,
												 &DeviceInfoData,
												 SPDRP_COMPATIBLEIDS,
												 NULL,
												 (PBYTE)pwszCompatibleIDList,
												 dwSize,
												 &dwSize
												 ))
		{
			for (pwszSingleID = pwszCompatibleIDList;
				 *pwszSingleID;
				 pwszSingleID += lstrlenW(pwszSingleID) + 1)
			{

				if (0 == lstrcmpiW(pwszSingleID, pwszHwOrCompatID))
				{
					//
					// We found a compatible match, now return the most general HWID
					// for this device node. Must be at least one character long.
					//
					if (NULL != pwszHardwareIDList && NULL != *pwszHardwareIDList)
					{
						LPWSTR lpwszLastID = NULL;

						for(pwszSingleID = pwszHardwareIDList;
							 *pwszSingleID;
							 pwszSingleID += lstrlenW(pwszSingleID) + 1)
						{
							//
							// Remember last ID before NULL string
							//
							lpwszLastID = pwszSingleID;
						}

						// copy the last HWID into a new buffer
						dwBufLen=(lstrlenW(lpwszLastID) + 1);
						*ppszMatchingHWID = (LPWSTR) HeapAlloc(GetProcessHeap(), 0,
											dwBufLen * sizeof(WCHAR));
						CleanUpFailedAllocSetHrMsg(*ppszMatchingHWID);
						hr=StringCchCopyExW(*ppszMatchingHWID,dwBufLen,lpwszLastID,NULL,NULL,MISTSAFE_STRING_FLAGS);
						goto CleanUp;
					}
				}
			}
		}
    }	// end while

	
CleanUp:
	
	if (INVALID_HANDLE_VALUE != hDevInfo)
	{
	    SetupDiDestroyDeviceInfoList(hDevInfo);
	}

	//
	// Free up any allocated buffers (except *ppszMatchingHWID)
	//
	if(FAILED(hr))
	{
		SafeHeapFree(*ppszMatchingHWID);
	}

	SafeHeapFree(pwszHardwareIDList);
	SafeHeapFree(pwszCompatibleIDList);

	return hr;
}

//This function handles installation of a Device driver package.
HRESULT InstallDriver(
	LPCTSTR pszLocalDir,				// Local directory where installation files are.
	LPCTSTR pszDisplayName,				// Description of package, Device Manager displays this in its install dialog.
	LPCTSTR pszHardwareID,				// ID from XML matched to client hardware via GetManifest()
	DWORD* pdwStatus
	)
{
	LOG_Block("InstallDriver");
	USES_IU_CONVERSION;

	HRESULT hr;
	OSVERSIONINFO osvi;
	DWORD dwReboot = 0;
	LPWSTR pszwMatchingHWID = NULL;

	if (NULL == pszLocalDir || NULL == pszDisplayName || NULL == pszHardwareID || NULL == pdwStatus)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}

	//
	// DecompressFolderCabs may return S_FALSE if it didn't find a cab to decompress...
	//
	hr = DecompressFolderCabs(pszLocalDir);
	if (S_OK != hr)
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}
	
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if(VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && 4 < osvi.dwMajorVersion)
	{
		//
		// Win2K or higher NT
		//
		if (5 == osvi.dwMajorVersion && 0 == osvi.dwMinorVersion)
		{
			//
			// Windows 2000
			// NTBUG9-485554 Convert compatible IDs to hardware IDs for site Driver Install for Win2K
			//
			// OK to cast away const-ness on string params so T2OLE works, since it doesn't modify them anyway
			CleanUpIfFailedAndSetHr(MatchHardwareID(T2OLE((LPTSTR)pszHardwareID), &pszwMatchingHWID));

			hr = InstallNT(OLE2T(pszwMatchingHWID), pszLocalDir, pszDisplayName, &dwReboot);

			// pszMatchingHWID must be non-null if we got here
			SafeHeapFree(pszwMatchingHWID);
		}
		else
		{
			//
			// Normal case, just install
			//
			CleanUpIfFailedAndSetHr(InstallNT(pszHardwareID, pszLocalDir, pszDisplayName, &dwReboot));
		}
	}
	else if (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId && 
			(4 < osvi.dwMajorVersion)	||
					(	(4 == osvi.dwMajorVersion) &&
						(0 < osvi.dwMinorVersion)	)	)
	{
		//
		// Win98 or higher (WinME)
		//
		CleanUpIfFailedAndSetHr(Install98(pszHardwareID, pszLocalDir, pszDisplayName, &dwReboot));
	}
	else
	{
		*pdwStatus = ITEM_STATUS_FAILED;
		SetHrMsgAndGotoCleanUp(E_NOTIMPL);
	}

	if (DI_NEEDRESTART & dwReboot || DI_NEEDREBOOT & dwReboot)
		*pdwStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
	else
		*pdwStatus = ITEM_STATUS_SUCCESS;

CleanUp:

	if (FAILED(hr))
	{
        if (NULL != pdwStatus)
        {
	    	*pdwStatus = ITEM_STATUS_FAILED;
        }
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\download\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	util
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.download

TARGETNAME=download
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
        download.cpp \
        dlutil.cpp \
        dlhttp.cpp \
        dlcache.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\install\install.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   install.cpp
//
//  Description:
//
//      Functions called to install Active Setup/Windows Installer/and Custom Installer
//      type components.
//
//=======================================================================

#include <windows.h>
#include <iucommon.h>
#include <tchar.h>
#include <shlwapi.h>
#include <install.h>
#include <advpub.h>
#include <memutil.h>
#include <fileutil.h>
#include <WaitUtil.h>
#include <strsafe.h>
#include <wusafefn.h>

typedef struct 
{
    char  szInfname[MAX_PATH];
    char  szSection[MAX_PATH];
    char  szDir[MAX_PATH];
    char  szCab[MAX_PATH];
    DWORD dwFlags;
    DWORD dwType;
} INF_ARGUMENTS;

DWORD WINAPI LaunchInfCommand(void *p);

HRESULT InstallSoftwareItem(LPTSTR pszInstallSourcePath, BOOL fRebootRequired, LONG lNumberOfCommands,
                      PINSTALLCOMMANDINFO pCommandInfoArray, DWORD *pdwStatus)
{
    LOG_Block("InstallASItem");

    HRESULT hr = S_OK;
    TCHAR szCommand[MAX_PATH+1]; // sourcepath + commandname from INSTALLCOMMANDINFO array
    TCHAR szCommandTemp[MAX_PATH+1]; // temporary buffer used to wrap the command line in quotes for CreateProcess
    TCHAR szDecompressFile[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hProc;
    HANDLE hFind;
    BOOL fMore;
    LONG lCnt;
    DWORD dwRet;
    DWORD dwThreadId;

    USES_IU_CONVERSION;

    if ((NULL == pszInstallSourcePath) || (NULL == pCommandInfoArray) || (0 == lNumberOfCommands) || (NULL == pdwStatus))
    {
        hr = E_INVALIDARG;
        hr = LOG_ErrorMsg(hr);
        return hr;
    }

    *pdwStatus = ITEM_STATUS_FAILED; // default to failed in case no commands match known installers

    // Need to enumerate all .CAB files in the Install Source Path and Decompress them
    // before executing commands.
    hr = PathCchCombine(szCommand, ARRAYSIZE(szCommand), pszInstallSourcePath, _T("*.cab"));
    if (FAILED(hr)) {
        LOG_ErrorMsg(hr);
        return hr;
    }
    hFind = FindFirstFile(szCommand, &fd);
    fMore = (INVALID_HANDLE_VALUE != hFind);
    while (fMore)
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            hr = PathCchCombine(szDecompressFile, ARRAYSIZE(szDecompressFile), pszInstallSourcePath, fd.cFileName);
            if (FAILED(hr)) 
            {
                LOG_ErrorMsg(hr);
            } else {
                if (!IUExtractFiles(szDecompressFile, pszInstallSourcePath))
                {
                    LOG_Software(_T("Failed to Decompress file %s"), szDecompressFile);
                    // ISSUE: do we abort this item?, or try the install anyway?
                }
            }
        }
        fMore = FindNextFile(hFind, &fd);
    }

    if (INVALID_HANDLE_VALUE != hFind)
    {
        FindClose(hFind);
    }

    for (lCnt = 0; lCnt < lNumberOfCommands; lCnt++)
    {
        // the szCommand variable is used to launch a process (msi or exe installer), but because of 
        // oddities in the CreateProcess API's handling of the commandline parameter we need to wrap
        // the command line in quotes.
        hr = SafePathCombine(szCommandTemp, ARRAYSIZE(szCommandTemp), pszInstallSourcePath, pCommandInfoArray[lCnt].szCommandLine, SPC_FILE_MUST_EXIST);
        if (SUCCEEDED(hr))
            hr = StringCchPrintf(szCommand, ARRAYSIZE(szCommand), _T("\"%s\""), szCommandTemp);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            return hr;
        }

        switch (pCommandInfoArray[lCnt].iCommandType)
        {
        case COMMANDTYPE_INF:
        case COMMANDTYPE_ADVANCEDINF:
            {
                // Call INF Installer Passing Commandline and Parameters (if any)
                INF_ARGUMENTS infArgs;
                infArgs.dwType = pCommandInfoArray[lCnt].iCommandType;

                hr = StringCchCopyA(infArgs.szInfname, ARRAYSIZE(infArgs.szInfname), 
                            T2A(pCommandInfoArray[lCnt].szCommandLine));
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCopyA(infArgs.szSection, ARRAYSIZE(infArgs.szSection), ""); // use default
                     
                }
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCopyA(infArgs.szDir, ARRAYSIZE(infArgs.szDir), T2A(pszInstallSourcePath));
                }
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCopyA(infArgs.szCab, ARRAYSIZE(infArgs.szCab), "");
                }
                if (FAILED(hr)) {
                    LOG_ErrorMsg(hr);
                    break;
                }

                infArgs.dwFlags = StrToInt(pCommandInfoArray[lCnt].szCommandParameters);
                
                LOG_Software(_T("Launching Inf - inf: %hs, section: %hs"), infArgs.szInfname, lstrlenA(infArgs.szSection) ? infArgs.szSection : "Default");

                hr = E_FAIL; // default INF result to E_FAIL.. if GetExitCodeThread fails so did the install

                hProc = CreateThread(NULL, 0, LaunchInfCommand, &infArgs, 0, &dwThreadId);
                if (NULL != hProc)
                {
                    WaitAndPumpMessages(1, &hProc, QS_ALLINPUT);
                    if (GetExitCodeThread(hProc, &dwRet))
                    {
                        hr = HRESULT_FROM_WIN32(dwRet);
                        if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                        {
                            *pdwStatus = ITEM_STATUS_SUCCESS;
                            if (hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                            {
                                hr = S_OK;
                                *pdwStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
                            }
                        }
                        else
                        {
                            LOG_Error(_T("Inf Failed - return code %x"), hr);
                        }
                    }
                    else
                    {
                        LOG_Software(_T("Failed to get Install Thread Exit Code"));
                    }
                }
                else
                {
                    hr = GetLastError();
                    LOG_ErrorMsg(hr);
                }
                CloseHandle(hProc);
                break;
            }
        case COMMANDTYPE_EXE:
            {
                // Call EXE Installer Passing Commandline and Parameters (if any)
                STARTUPINFO startInfo;
                PROCESS_INFORMATION processInfo;
                ZeroMemory(&startInfo, sizeof(startInfo));
                startInfo.cb = sizeof(startInfo);
                startInfo.dwFlags |= STARTF_USESHOWWINDOW;
                startInfo.wShowWindow = SW_SHOWNORMAL;

                if (NULL != pCommandInfoArray[lCnt].szCommandParameters)
                {
                    hr = StringCchCat(szCommand, ARRAYSIZE(szCommand), _T(" "));
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        break;
                    }
                    hr = StringCchCat(szCommand, ARRAYSIZE(szCommand), pCommandInfoArray[lCnt].szCommandParameters);
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        break;
                    }
                }

                if (CreateProcess(NULL, szCommand, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, pszInstallSourcePath, &startInfo, &processInfo))
                {
                    CloseHandle(processInfo.hThread);
                    hr = S_OK; // Default EXE result to S_OK, if GetExitCodeProcess fails result was unknown assume success
                    WaitAndPumpMessages(1, &processInfo.hProcess, QS_ALLINPUT);
                    if (GetExitCodeProcess(processInfo.hProcess, &dwRet))
                    {
                        hr = HRESULT_FROM_WIN32(dwRet);
                        if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                        {
                            *pdwStatus = ITEM_STATUS_SUCCESS;
                            if (hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                            {
                                hr = S_OK;
                                *pdwStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
                            }
                        }
                        else
                        {
                            LOG_Software(_T("EXE Install Failed - return code %x"), hr);
                        }
                    }
                    else
                    {
                        LOG_Software(_T("Failed to get Install Process Exit Code"));
                    }
                }
                else
                {
                    hr = GetLastError();
                    LOG_ErrorMsg(hr);
                }
                CloseHandle(processInfo.hProcess);
                break;
            }
        case COMMANDTYPE_MSI:
            {
                // Call MSI Installer Passing MSI Package and Parameters (if any)
                STARTUPINFO startInfo;
                PROCESS_INFORMATION processInfo;
                ZeroMemory(&startInfo, sizeof(startInfo));
                startInfo.cb = sizeof(startInfo);
                startInfo.dwFlags |= STARTF_USESHOWWINDOW;
                startInfo.wShowWindow = SW_SHOWNORMAL;

                // The MSI Installer is run a little differently than a normal EXE package. The command line in
                // CommandInfo Array will actually be the MSI package name. We are going to form a new set of
                // parameters to include the MSI package name and command line will be MSIEXEC.

                TCHAR szCommandLine[MAX_PATH];
                hr = StringCchPrintf( szCommandLine, ARRAYSIZE(szCommandLine), 
                         _T("msiexec.exe /i %s %s"), 
                         pCommandInfoArray[lCnt].szCommandLine, 
                         pCommandInfoArray[lCnt].szCommandParameters );
                if (FAILED(hr)) 
                {
                    LOG_ErrorMsg(hr);
                    break;
                }
                
                if (CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, pszInstallSourcePath, &startInfo, &processInfo))
                {
                    CloseHandle(processInfo.hThread);
                    hr = E_FAIL; // Default MSI install result to Error
                    WaitAndPumpMessages(1, &processInfo.hProcess, QS_ALLINPUT);
                    if (GetExitCodeProcess(processInfo.hProcess, &dwRet))
                    {
                        hr = HRESULT_FROM_WIN32(dwRet);
                        if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                        {
                            *pdwStatus = ITEM_STATUS_SUCCESS;
                            if (hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                            {
                                hr = S_OK;
                                *pdwStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
                            }
                        }
                        else
                        {
                            LOG_Software(_T("MSI Install Failed - return code %x"), hr);
                        }
                    }
                    else
                    {
                        LOG_Software(_T("Failed to get Install Process Exit Code"));
                    }
                }
                else
                {
                    hr = GetLastError();
                    LOG_ErrorMsg(hr);
                }
                CloseHandle(processInfo.hProcess);
                break;
            }
        case COMMANDTYPE_CUSTOM:
            LOG_Software(_T("Custom Install Command Type Not Implemented Yet"));
            break;
        default:
            LOG_Software(_T("Unknown Command Type, No Install Action"));
            break;
        }
    }

    return hr;
}


DWORD WINAPI LaunchInfCommand(void *p)
{
    HRESULT hr = S_OK;

    INF_ARGUMENTS *pinfArgs = (INF_ARGUMENTS *)p;

    if(pinfArgs->dwType == COMMANDTYPE_ADVANCEDINF)
    {
        CABINFO cabinfo;
        cabinfo.pszCab = pinfArgs->szCab;
        cabinfo.pszInf = pinfArgs->szInfname;
        cabinfo.pszSection = pinfArgs->szSection;

        // cabinfo.szSrcPath is a char[MAXPATH] in the CABINFO struct
        StringCchCopyA(cabinfo.szSrcPath, ARRAYSIZE(cabinfo.szSrcPath), pinfArgs->szDir);
        cabinfo.dwFlags = pinfArgs->dwFlags;

        hr = ExecuteCab(NULL, &cabinfo, 0);
    }
    else
    {
        hr = RunSetupCommand(NULL, pinfArgs->szInfname,
                   lstrlenA(pinfArgs->szSection) ? pinfArgs->szSection : NULL,
                   pinfArgs->szDir, NULL, NULL, pinfArgs->dwFlags, NULL );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\download\dlhttp.cpp ===
#include <windows.h>
#include <winhttp.h>
#include <shlwapi.h>
#include <logging.h>
#include "iucommon.h"
#include "download.h"
#include "dllite.h"
#include "dlutil.h"
#include "malloc.h"

#include "trust.h"
#include "fileutil.h"
#include "dlcache.h"
#include "wusafefn.h"

///////////////////////////////////////////////////////////////////////////////
// typedefs


// winhttp
extern "C"
{
typedef BOOL      (WINAPI *pfn_WinHttpCrackUrl)(LPCWSTR, DWORD, DWORD, LPURL_COMPONENTS);
typedef HINTERNET (WINAPI *pfn_WinHttpOpen)(LPCWSTR, DWORD, LPCWSTR, LPCWSTR, DWORD);
typedef HINTERNET (WINAPI *pfn_WinHttpConnect)(HINTERNET, LPCWSTR, INTERNET_PORT, DWORD);
typedef HINTERNET (WINAPI *pfn_WinHttpOpenRequest)(HINTERNET, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR FAR *, DWORD);
typedef BOOL      (WINAPI *pfn_WinHttpSendRequest)(HINTERNET, LPCWSTR, DWORD, LPVOID, DWORD, DWORD, DWORD_PTR);
typedef BOOL      (WINAPI *pfn_WinHttpReceiveResponse)(HINTERNET, LPVOID);
typedef BOOL      (WINAPI *pfn_WinHttpQueryHeaders)(HINTERNET, DWORD, LPCWSTR, LPVOID, LPDWORD, LPDWORD);
typedef BOOL      (WINAPI *pfn_WinHttpReadData)(HINTERNET, LPVOID, DWORD, LPDWORD);
typedef BOOL      (WINAPI *pfn_WinHttpCloseHandle)(HINTERNET);
typedef BOOL      (WINAPI *pfn_WinHttpGetIEProxyConfigForCurrentUser)(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG *);
typedef BOOL      (WINAPI *pfn_WinHttpGetProxyForUrl)(HINTERNET, LPCWSTR, WINHTTP_AUTOPROXY_OPTIONS *, WINHTTP_PROXY_INFO *);
typedef BOOL      (WINAPI *pfn_WinHttpSetOption)(HINTERNET, DWORD, LPVOID, DWORD);
}

struct SWinHTTPFunctions
{
    pfn_WinHttpGetIEProxyConfigForCurrentUser   pfnWinHttpGetIEProxyConfigForCurrentUser;
    pfn_WinHttpGetProxyForUrl   pfnWinHttpGetProxyForUrl;
    pfn_WinHttpCrackUrl         pfnWinHttpCrackUrl;
    pfn_WinHttpOpen             pfnWinHttpOpen;
    pfn_WinHttpConnect          pfnWinHttpConnect;
    pfn_WinHttpOpenRequest      pfnWinHttpOpenRequest;
    pfn_WinHttpSendRequest      pfnWinHttpSendRequest;
    pfn_WinHttpReceiveResponse  pfnWinHttpReceiveResponse;
    pfn_WinHttpQueryHeaders     pfnWinHttpQueryHeaders;
    pfn_WinHttpReadData         pfnWinHttpReadData;
    pfn_WinHttpCloseHandle      pfnWinHttpCloseHandle;
    pfn_WinHttpSetOption        pfnWinHttpSetOption;
    HMODULE                     hmod;
};

typedef struct tagSAUProxyInfo
{
    WINHTTP_PROXY_INFO  ProxyInfo;
    LPWSTR              wszProxyOrig;
    LPWSTR              *rgwszProxies;
    DWORD               cProxies;
    DWORD               iProxy;
} SAUProxyInfo;

typedef enum tagETransportUsed
{
    etuNone = 0,
    etuWinHttp,
    etuWinInet,
} ETransportUsed;

#define SafeWinHTTPCloseHandle(sfns, x) if (NULL != x) { (*sfns.pfnWinHttpCloseHandle)(x); x = NULL; }
#define StringOrConstW(wsz, wszConst) (((wsz) != NULL) ? (wsz) : (wszConst))


///////////////////////////////////////////////////////////////////////////////
// globals

#if defined(UNICODE)

CWUDLProxyCache g_wudlProxyCache;
CAutoCritSec    g_csCache;

#endif

HMODULE         g_hmodWinHttp = NULL;
HMODULE         g_hmodWinInet = NULL;

///////////////////////////////////////////////////////////////////////////////
// utility functions

// **************************************************************************
static
LPTSTR MakeFullLocalFilePath(LPCTSTR szUrl, 
                             LPCTSTR szFileName, 
                             LPCTSTR szPath)
{
    LOG_Block("MakeFullLocalFilePath()");

    HRESULT hr = NOERROR;
    LPTSTR  pszRet, pszFileNameToUse = NULL, pszQuery = NULL;
    LPTSTR  pszFullPath = NULL;
    DWORD   cchFile;
    TCHAR   chTemp = _T('\0');

    // if we got a local filename passed to us, use it.
    if (szFileName != NULL)
    {
        pszFileNameToUse = (LPTSTR)szFileName;
    } 

    // otherwise, parse the filename out of the URL & use it instead
    else
    {
        // first get a pointer to the querystring, if any
        pszQuery = _tcschr(szUrl, _T('?'));

        // next, find the last slash before the start of the querystring
        pszFileNameToUse = StrRChr(szUrl, pszQuery, _T('/'));

        // if we don't have a filename at this point, we can't continue
        //  cuz there's nowhere to download the file to.
        if (pszFileNameToUse == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto done;
        }
        
        pszFileNameToUse++;

        // temporarily NULL out the first character of the querystring, if
        //  we have a querystring.  This makes the end of the filename the
        //  end of the string.
        if (pszQuery != NULL)
        {
            chTemp = *pszQuery;
            *pszQuery  = _T('\0');
        }
    }

    // add 2 for a possible backslash & the null terminator
    cchFile = 2 + _tcslen(szPath) + _tcslen(pszFileNameToUse);

    pszFullPath = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, cchFile * sizeof(TCHAR));
    if (pszFullPath == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        if (pszQuery != NULL)
            *pszQuery = chTemp;
        goto done;
    }

    // construct the path
    hr = SafePathCombine(pszFullPath, cchFile, szPath, pszFileNameToUse, 0);

    // if we nuked the first character of the querystring, restore it.
    if (pszQuery != NULL)
        *pszQuery = chTemp;

    if (FAILED(hr))
    {
		SetLastError(HRESULT_CODE(hr));
		SafeHeapFree(pszFullPath);
		goto done;
    }

done:
    return pszFullPath;
}

// **************************************************************************
static
ETransportUsed LoadTransportDll(SWinHTTPFunctions *psfns, HMODULE *phmod, 
                                  DWORD dwFlags)
{
    LOG_Block("LoadTransportDll()");

    ETransportUsed  etu = etuNone;
    HMODULE hmod = NULL;
    HRESULT hr = NOERROR;
    BOOL    fAllowWininet;
    BOOL    fAllowWinhttp;
    BOOL    fPersistTrans = ((dwFlags & WUDF_PERSISTTRANSPORTDLL) != 0);

    if (psfns == NULL || phmod == NULL || 
        (dwFlags & WUDF_TRANSPORTMASK) == WUDF_TRANSPORTMASK)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    dwFlags = GetAllowedDownloadTransport(dwFlags);
    fAllowWininet = ((dwFlags & WUDF_ALLOWWINHTTPONLY) == 0);
    fAllowWinhttp = ((dwFlags & WUDF_ALLOWWININETONLY) == 0);

    ZeroMemory(psfns, sizeof(SWinHTTPFunctions));
    *phmod = NULL;

    // first try to load the winhttp dll
    if (fAllowWinhttp)
    {
        if (g_hmodWinHttp == NULL)
        {
            hmod = LoadLibraryFromSystemDir(c_szWinHttpDll);
            
            if (hmod != NULL && fPersistTrans && 
                InterlockedCompareExchangePointer((LPVOID *)&g_hmodWinHttp,
                                                  hmod, NULL) != NULL)
            {
                FreeLibrary(hmod);
                hmod = g_hmodWinHttp;
            }
        }
        else
        {
            hmod = g_hmodWinHttp;
        }
    }
    if (hmod != NULL)
    {
        psfns->hmod                      = hmod;
        psfns->pfnWinHttpGetProxyForUrl  = (pfn_WinHttpGetProxyForUrl)GetProcAddress(hmod, "WinHttpGetProxyForUrl");
        psfns->pfnWinHttpCrackUrl        = (pfn_WinHttpCrackUrl)GetProcAddress(hmod, "WinHttpCrackUrl");
        psfns->pfnWinHttpOpen            = (pfn_WinHttpOpen)GetProcAddress(hmod, "WinHttpOpen");
        psfns->pfnWinHttpConnect         = (pfn_WinHttpConnect)GetProcAddress(hmod, "WinHttpConnect");
        psfns->pfnWinHttpOpenRequest     = (pfn_WinHttpOpenRequest)GetProcAddress(hmod, "WinHttpOpenRequest");
        psfns->pfnWinHttpSendRequest     = (pfn_WinHttpSendRequest)GetProcAddress(hmod, "WinHttpSendRequest");
        psfns->pfnWinHttpReceiveResponse = (pfn_WinHttpReceiveResponse)GetProcAddress(hmod, "WinHttpReceiveResponse");
        psfns->pfnWinHttpQueryHeaders    = (pfn_WinHttpQueryHeaders)GetProcAddress(hmod, "WinHttpQueryHeaders");
        psfns->pfnWinHttpReadData        = (pfn_WinHttpReadData)GetProcAddress(hmod, "WinHttpReadData");
        psfns->pfnWinHttpCloseHandle     = (pfn_WinHttpCloseHandle)GetProcAddress(hmod, "WinHttpCloseHandle");
        psfns->pfnWinHttpSetOption       = (pfn_WinHttpSetOption)GetProcAddress(hmod, "WinHttpSetOption");
        psfns->pfnWinHttpGetIEProxyConfigForCurrentUser = (pfn_WinHttpGetIEProxyConfigForCurrentUser)GetProcAddress(hmod, "WinHttpGetIEProxyConfigForCurrentUser");
        if (psfns->pfnWinHttpCrackUrl == NULL || 
            psfns->pfnWinHttpOpen == NULL ||
            psfns->pfnWinHttpConnect == NULL || 
            psfns->pfnWinHttpOpenRequest == NULL ||
            psfns->pfnWinHttpSendRequest == NULL || 
            psfns->pfnWinHttpReceiveResponse == NULL ||
            psfns->pfnWinHttpQueryHeaders == NULL || 
            psfns->pfnWinHttpReadData == NULL ||
            psfns->pfnWinHttpCloseHandle == NULL || 
            psfns->pfnWinHttpGetProxyForUrl == NULL ||
            psfns->pfnWinHttpGetIEProxyConfigForCurrentUser == NULL || 
            psfns->pfnWinHttpSetOption == NULL)
        {
            // do this logging here cuz we'll try wininet afterward & we want
            //  to make sure to log this error as well
            LOG_ErrorMsg(ERROR_PROC_NOT_FOUND);
            SetLastError(ERROR_PROC_NOT_FOUND);
            
            ZeroMemory(psfns, sizeof(SWinHTTPFunctions));
            FreeLibrary(hmod);
            hmod = NULL;
        }
        else
        {
            LOG_Internet(_T("Successfully loaded WinHttp.dll"));
            
            etu     = etuWinHttp;
            *phmod  = hmod;
        }
    }

    // if hmod is NULL at this point, then try to fall back to wininet.  If
    //  that fails, we can only bail...
    if (fAllowWininet && hmod == NULL)
    {
        if (g_hmodWinInet == NULL)
        {
            hmod = LoadLibraryFromSystemDir(c_szWinInetDll);
            if (hmod == NULL)
                goto done;

            if (fPersistTrans &&
                InterlockedCompareExchangePointer((LPVOID *)&g_hmodWinInet, 
                                                  hmod, NULL) != NULL)
            {
                FreeLibrary(hmod);
                hmod = g_hmodWinInet;
            }
        }

        LOG_Internet(_T("Successfully loaded WinInet.dll (no functions yet)"));

        etu    = etuWinInet;
        *phmod = hmod;
    }

done:    
    return etu;
}

// **************************************************************************
static
BOOL UnloadTransportDll(SWinHTTPFunctions *psfns, HMODULE hmod)
{
    LOG_Block("UnloadTransportDll()");

    if (hmod != NULL && hmod != g_hmodWinHttp && hmod != g_hmodWinInet)
        FreeLibrary(hmod);

    if (psfns != NULL)
        ZeroMemory(psfns, sizeof(SWinHTTPFunctions));

    return TRUE;
}

// we only care about winhttp on unicode platforms!
#if defined(UNICODE)

// **************************************************************************
static
BOOL ProxyListToArray(LPWSTR wszProxy, LPWSTR **prgwszProxies, DWORD *pcProxies)
{
    LPWSTR  pwszProxy = wszProxy;
    LPWSTR  *rgwszProxies = NULL;
    DWORD   cProxies = 0, iProxy;
    BOOL    fRet = FALSE;

    if (prgwszProxies == NULL || pcProxies == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *prgwszProxies = NULL;
    *pcProxies     = 0;

    if (wszProxy == NULL || *wszProxy == L'\0')
        goto done;
    
    // walk the string & count how many proxies we have
    for(;;)
    {
        for(;
            *pwszProxy != L';' && *pwszProxy != L'\0';
            pwszProxy++);

        cProxies++;

        if (*pwszProxy == L'\0')
            break;
        else
            pwszProxy++;
    }

    // alloc an array to hold 'em
    rgwszProxies = (LPWSTR *)GlobalAlloc(GPTR, sizeof(LPWSTR) * cProxies);
    if (rgwszProxies == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    // fill the array
    pwszProxy = wszProxy;
    for(iProxy = 0; iProxy < cProxies; iProxy++)
    {
        rgwszProxies[iProxy] = pwszProxy;

        for(;
            *pwszProxy != L';' && *pwszProxy != L'\0';
            pwszProxy++);


        if (*pwszProxy == L'\0')
        {
            break;
        }
        else
        {
            *pwszProxy = L'\0';
            pwszProxy++;
        }
    }
        
    *prgwszProxies = rgwszProxies;
    *pcProxies     = cProxies;

    rgwszProxies   = NULL;

    fRet = TRUE;

done:
    if (rgwszProxies != NULL)
        GlobalFree(rgwszProxies);

    return fRet;    
}

// **************************************************************************
static
DWORD GetInitialProxyIndex(DWORD cProxies)
{
    SYSTEMTIME  st;
    DWORD       iProxy;

    GetSystemTime(&st);

    // this would be incredibly weird, but it's easy to deal with so do so
    if (st.wMilliseconds >= 1000)
        st.wMilliseconds = st.wMilliseconds % 1000;

    // so we don't have to use the crt random number generator, just fake it
    return (st.wMilliseconds * cProxies) / 1000;
}

// **************************************************************************
static
BOOL GetWinHTTPProxyInfo(SWinHTTPFunctions &sfns, BOOL fCacheResults,
                         HINTERNET hInternet, LPCWSTR wszURL, LPCWSTR wszSrv,
                         SAUProxyInfo *pAUProxyInfo)
{
    LOG_Block("GetWinHTTPProxyInfo()");

    WINHTTP_CURRENT_USER_IE_PROXY_CONFIG    IEProxyCfg;
    WINHTTP_AUTOPROXY_OPTIONS               AutoProxyOpt;
    DWORD                                   dwErr = ERROR_SUCCESS;
    BOOL                                    fUseAutoProxy = FALSE;
    BOOL                                    fGotProxy = FALSE;
    BOOL                                    fRet = FALSE;
    
    ZeroMemory(&IEProxyCfg, sizeof(IEProxyCfg));
    ZeroMemory(&AutoProxyOpt, sizeof(AutoProxyOpt));

    // only need to acquire the CS if we're caching results
    if (fCacheResults)
        g_csCache.Lock();
    
    if (pAUProxyInfo == NULL || hInternet == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }
    
    ZeroMemory(pAUProxyInfo, sizeof(SAUProxyInfo));

    // if we're not caching results, skip directly to the proxy fetch
    if (fCacheResults && 
        g_wudlProxyCache.Find(wszSrv, &pAUProxyInfo->ProxyInfo.lpszProxy,
                              &pAUProxyInfo->ProxyInfo.lpszProxyBypass,
                              &pAUProxyInfo->ProxyInfo.dwAccessType))
    {
        LOG_Internet(_T("WinHttp: Cached proxy settings Proxy: %ls | Bypass: %ls | AccessType: %d"),
                     StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxy, L"(none)"),
                     StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxyBypass, L"(none)"),
                     pAUProxyInfo->ProxyInfo.dwAccessType);

        pAUProxyInfo->wszProxyOrig = pAUProxyInfo->ProxyInfo.lpszProxy;

        // we'll deal with this function failing later on when we cycle thru
        //  the proxies.  We'll basically only use the first and never cycle
        if (ProxyListToArray(pAUProxyInfo->wszProxyOrig,
                             &pAUProxyInfo->rgwszProxies,
                             &pAUProxyInfo->cProxies))
        {
            DWORD iProxy;
            
            iProxy = GetInitialProxyIndex(pAUProxyInfo->cProxies);
            pAUProxyInfo->ProxyInfo.lpszProxy = pAUProxyInfo->rgwszProxies[iProxy];
            pAUProxyInfo->iProxy              = iProxy;
            
        }
        
        goto done;
    }
        
    // first try to get the current user's IE configuration
    fRet = (*sfns.pfnWinHttpGetIEProxyConfigForCurrentUser)(&IEProxyCfg);
    if (fRet)
    {
        LOG_Internet(_T("WinHttp: Read IE user proxy settings"));
        
        if (IEProxyCfg.fAutoDetect)
        {
            AutoProxyOpt.dwFlags           = WINHTTP_AUTOPROXY_AUTO_DETECT;
            AutoProxyOpt.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP |
                                             WINHTTP_AUTO_DETECT_TYPE_DNS_A;
            fUseAutoProxy = TRUE;
        }

        if (IEProxyCfg.lpszAutoConfigUrl != NULL)
        {
            AutoProxyOpt.dwFlags           |= WINHTTP_AUTOPROXY_CONFIG_URL;
            AutoProxyOpt.lpszAutoConfigUrl = IEProxyCfg.lpszAutoConfigUrl;
            fUseAutoProxy = TRUE;
        }

        AutoProxyOpt.fAutoLogonIfChallenged = TRUE;
        
    }

    // couldn't get current user's config options, so just try autoproxy
    else 
    {
        AutoProxyOpt.dwFlags           = WINHTTP_AUTOPROXY_AUTO_DETECT;
        AutoProxyOpt.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP |
                                         WINHTTP_AUTO_DETECT_TYPE_DNS_A;
        AutoProxyOpt.fAutoLogonIfChallenged = TRUE;

        fUseAutoProxy = TRUE;
    }

    if (fUseAutoProxy)
    {
        LOG_Internet(_T("WinHttp: Doing autoproxy detection"));

        fGotProxy = (*sfns.pfnWinHttpGetProxyForUrl)(hInternet, wszURL, 
                                                     &AutoProxyOpt, 
                                                     &pAUProxyInfo->ProxyInfo);
    }

    // if we didn't try to autoconfigure the proxy or we did & it failed, then
    //  check and see if we had one defined by the user
    if ((fUseAutoProxy == FALSE || fGotProxy == FALSE) && 
        IEProxyCfg.lpszProxy != NULL)
    {
        // the empty string and L':' are not valid server names, so skip them
        //  if they are what is set for the proxy
        if (!(IEProxyCfg.lpszProxy[0] == L'\0' ||
              (IEProxyCfg.lpszProxy[0] == L':' && 
               IEProxyCfg.lpszProxy[1] == L'\0')))
        {
            pAUProxyInfo->ProxyInfo.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
            pAUProxyInfo->ProxyInfo.lpszProxy    = IEProxyCfg.lpszProxy;
            IEProxyCfg.lpszProxy                 = NULL;
        }
        
        // the empty string and L':' are not valid server names, so skip them
        //  if they are what is set for the proxy bypass
        if (IEProxyCfg.lpszProxyBypass != NULL && 
            !(IEProxyCfg.lpszProxyBypass[0] == L'\0' ||
              (IEProxyCfg.lpszProxyBypass[0] == L':' && 
               IEProxyCfg.lpszProxyBypass[1] == L'\0')))
        {
            pAUProxyInfo->ProxyInfo.lpszProxyBypass = IEProxyCfg.lpszProxyBypass;
            IEProxyCfg.lpszProxyBypass              = NULL;
        }
    }

    LOG_Internet(_T("WinHttp: Proxy settings Proxy: %ls | Bypass: %ls | AccessType: %d"),
                 StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxy, L"(none)"),
                 StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxyBypass, L"(none)"),
                 pAUProxyInfo->ProxyInfo.dwAccessType);

    // don't really care if this fails.  It'll just mean a perf hit the next
    //  time we go fetch the proxy info
    if (fCacheResults &&
        g_wudlProxyCache.Set(wszSrv, pAUProxyInfo->ProxyInfo.lpszProxy,
                             pAUProxyInfo->ProxyInfo.lpszProxyBypass,
                             pAUProxyInfo->ProxyInfo.dwAccessType) == FALSE)
    {
        LOG_Internet(_T("WinHttp: Attempt to cache proxy info failed: %d"), 
                     GetLastError());
    }

    pAUProxyInfo->wszProxyOrig = pAUProxyInfo->ProxyInfo.lpszProxy;

    // we'll deal with this function failing later on when we cycle thru the
    //  proxies.  We'll basically only use the first and never cycle
    // Note that this function call has to be AFTER the cache call since we 
    //  modify the proxy list by embedding null terminators in it in place of
    //  the separating semicolons.
    if (ProxyListToArray(pAUProxyInfo->wszProxyOrig, &pAUProxyInfo->rgwszProxies,
                         &pAUProxyInfo->cProxies))
    {
        DWORD iProxy;
        
        iProxy = GetInitialProxyIndex(pAUProxyInfo->cProxies);
        pAUProxyInfo->ProxyInfo.lpszProxy = pAUProxyInfo->rgwszProxies[iProxy];
        pAUProxyInfo->iProxy              = iProxy;
        
    }

    fRet = TRUE;

done:
    // only need to release the CS if we're caching results
    if (fCacheResults)
        g_csCache.Unlock();
    
    dwErr = GetLastError();
    
    if (IEProxyCfg.lpszAutoConfigUrl != NULL)
        GlobalFree(IEProxyCfg.lpszAutoConfigUrl);
    if (IEProxyCfg.lpszProxy != NULL)
        GlobalFree(IEProxyCfg.lpszProxy);
    if (IEProxyCfg.lpszProxyBypass != NULL)
        GlobalFree(IEProxyCfg.lpszProxyBypass);

    SetLastError(dwErr);

    return fRet;
}

// **************************************************************************
static
HRESULT MakeRequest(SWinHTTPFunctions   &sfns,
                    HINTERNET hConnect, 
                    HINTERNET hRequest,
                    LPCWSTR wszSrv,
                    LPCWSTR wszVerb, 
                    LPCWSTR wszObject, 
                    SAUProxyInfo *pAUProxyInfo, 
                    HANDLE *rghEvents, 
                    DWORD cEvents, 
                    HINTERNET *phRequest)
{
    LOG_Block("MakeRequest()");

    HINTERNET   hOpenRequest = hRequest;
    LPCWSTR     wszAcceptTypes[] = {L"*/*", NULL};
    HRESULT     hr = S_OK;
    DWORD       iProxy = 0, dwErr;
    BOOL        fProxy, fContinue = TRUE;

    fProxy = (pAUProxyInfo != NULL && pAUProxyInfo->ProxyInfo.lpszProxy != NULL);

    LOG_Internet(_T("WinHttp: Making %ls request for %ls"), wszVerb, wszObject);

    // if we were passed in a request handle, then use it.  Otherwise, gotta 
    //  open one
    if (hOpenRequest == NULL)
    {
        hOpenRequest = (*sfns.pfnWinHttpOpenRequest)(hConnect, wszVerb, wszObject, 
                                                     NULL, NULL, wszAcceptTypes, 0);
        if (hOpenRequest == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto done;
        }
    }

    if (HandleEvents(rghEvents, cEvents) == FALSE)
    {
        hr = E_ABORT;
        goto done;
    }
    
    // if we have a list of proxies & the first one is bad, winhttp won't try
    //  any others.  So we have to do it ourselves.  That is the purpose of this 
    //  loop.
    if (fProxy && 
        pAUProxyInfo->cProxies > 1 && pAUProxyInfo->rgwszProxies != NULL)
        iProxy = (pAUProxyInfo->iProxy + 1) % pAUProxyInfo->cProxies;
    for(;;)
    {
        
       if (fProxy)
       {
            LOG_Internet(_T("WinHttp: Using proxy: Proxy: %ls | Bypass %ls | AccessType: %d"),
                         StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxy, L"(none)"),
                         StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxyBypass, L"(none)"),
                         pAUProxyInfo->ProxyInfo.dwAccessType);

            if ((*sfns.pfnWinHttpSetOption)(hOpenRequest, WINHTTP_OPTION_PROXY, 
                                            &pAUProxyInfo->ProxyInfo, 
                                            sizeof(WINHTTP_PROXY_INFO)) == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_ErrorMsg(hr);
                goto done;
            }
        }

        hr = S_OK;
        SetLastError(ERROR_SUCCESS);
        
        if ((*sfns.pfnWinHttpSendRequest)(hOpenRequest, NULL, 0, NULL, 0, 0, 0) == FALSE)
        {
//            dwErr = GetLastError();
//            LOG_Internet(_T("WinHttp: WinHttpSendRequest failed: %d.  Request object at: 0x%x"), 
//                         dwErr, hOpenRequest);
//            SetLastError(dwErr);

            goto loopDone;
        }
        
        if ((*sfns.pfnWinHttpReceiveResponse)(hOpenRequest, 0) == FALSE)
        {
//            dwErr = GetLastError();
//            LOG_Internet(_T("WinHttp: WinHttpReceiveResponse failed: %d.  Request object at: 0x%x"), 
//                         dwErr, hOpenRequest);
//            SetLastError(dwErr);

            goto loopDone;
        }

loopDone:
        fContinue = FALSE;
        dwErr = GetLastError();
        if (dwErr != ERROR_SUCCESS)
            hr = HRESULT_FROM_WIN32(dwErr);
        else
            hr = S_OK;

        // if we succeeded, then we're done here...
        if (SUCCEEDED(hr))
        {
            if (fProxy)
            {
                if (g_csCache.Lock() == FALSE)
                {
                    hr = E_FAIL;
                    goto done;
                }
                
                g_wudlProxyCache.SetLastGoodProxy(wszSrv, pAUProxyInfo->iProxy);
   
                // Unlock returns FALSE as well, but we should never get here cuz 
                //  we should not have been able to take the lock above.
                g_csCache.Unlock();
            }
            
            break;
        }
        
        LOG_ErrorMsg(hr);

        // we only care about retrying if we have a proxy server & get a 
        //  'cannot connect' error.
        if (fProxy && 
            (dwErr == ERROR_WINHTTP_CANNOT_CONNECT ||
             dwErr == ERROR_WINHTTP_CONNECTION_ERROR ||
             dwErr == ERROR_WINHTTP_NAME_NOT_RESOLVED ||
             dwErr == ERROR_WINHTTP_TIMEOUT))
        {
            LOG_Internet(_T("WinHttp: Connection failure: %d"), dwErr);
            if (pAUProxyInfo->cProxies > 1 && pAUProxyInfo->rgwszProxies != NULL && 
                iProxy != pAUProxyInfo->iProxy)
            {
                pAUProxyInfo->ProxyInfo.lpszProxy = pAUProxyInfo->rgwszProxies[iProxy];
                iProxy = (iProxy + 1) % pAUProxyInfo->cProxies;
                fContinue = TRUE;
            }
            else
            {
                LOG_Internet(_T("WinHttp: No proxies left.  Failing download."));
            }
        }

        if (fContinue == FALSE)
            goto done;
    }

    
    if (FAILED(hr))
        goto done;


    if (HandleEvents(rghEvents, cEvents) == FALSE)
    {
        hr = E_ABORT;
        goto done;
    }

    *phRequest   = hOpenRequest;
    hOpenRequest = NULL;
    
done:
    // don't want to free the handle if we didn't open it.
    if (hRequest != hOpenRequest)
        SafeWinHTTPCloseHandle(sfns, hOpenRequest);
    return hr;
}

// **************************************************************************
static
HRESULT CheckFileHeader(SWinHTTPFunctions   &sfns,
                        HINTERNET hOpenRequest, 
                        HANDLE *rghEvents, 
                        DWORD cEvents, 
                        LPCWSTR wszFile,
                        DWORD *pcbFile,
                        FILETIME *pft)
{
    LOG_Block("CheckFileHeader()");

    SYSTEMTIME  st;
    FILETIME    ft;
    HRESULT     hr = S_OK;
    DWORD       dwLength, dwStatus, dwFileSize, dwErr;

    dwLength = sizeof(st);
    if ((*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                       WINHTTP_QUERY_LAST_MODIFIED | WINHTTP_QUERY_FLAG_SYSTEMTIME, 
                                       NULL, (LPVOID)&st, &dwLength, NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    SystemTimeToFileTime(&st, &ft);

    // Now Get the FileSize information from the Server
    dwLength = sizeof(dwFileSize);
    if ((*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                       WINHTTP_QUERY_CONTENT_LENGTH | WINHTTP_QUERY_FLAG_NUMBER, 
                                       NULL, (LPVOID)&dwFileSize, &dwLength, NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }
    
    if (HandleEvents(rghEvents, cEvents) == FALSE)
    {
        hr = E_ABORT;
        goto done;
    }

    if (pcbFile != NULL)
        *pcbFile = dwFileSize;
    if (pft != NULL)
        CopyMemory(pft, &ft, sizeof(FILETIME));

    hr = IsServerFileDifferentW(ft, dwFileSize, wszFile) ? S_OK : S_FALSE;

done:
    return hr;
}

// **************************************************************************
static
HRESULT GetContentTypeHeader(SWinHTTPFunctions &sfns,
                             HINTERNET hOpenRequest,
                             LPWSTR *pwszContentType)
{
    LOG_Block("GetContentTypeHeader()");

    HRESULT hr = S_OK;
    LPWSTR  wszContentType = NULL;
    DWORD   dwLength, dwErr;
    BOOL    fRet;

    *pwszContentType = NULL;

    dwLength = 0;
    fRet = (*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                          WINHTTP_QUERY_CONTENT_TYPE, 
                                          NULL, (LPVOID)NULL, &dwLength, 
                                          NULL);
    if (fRet == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    if (dwLength == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_HEADER_NOT_FOUND);
        goto done;
    }

    wszContentType = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                                       dwLength);
    if (wszContentType == NULL)
    {
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
        goto done;
    }

    if ((*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                       WINHTTP_QUERY_CONTENT_TYPE, 
                                       NULL, (LPVOID)wszContentType, &dwLength, 
                                       NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    *pwszContentType = wszContentType;
    wszContentType   = NULL;

done:
    SafeHeapFree(wszContentType);

    return hr;
}


// **************************************************************************
static
HRESULT StartWinHttpDownload(SWinHTTPFunctions &sfns,
                             LPCWSTR wszUrl, 
                             LPCWSTR wszLocalFile,
                             DWORD   *pcbDownloaded,
                             HANDLE  *rghQuitEvents,
                             UINT    cQuitEvents,
                             PFNDownloadCallback pfnCallback,
                             LPVOID  pvCallbackData,
                             DWORD   dwFlags,
                             DWORD   cbDownloadBuffer)
{
    LOG_Block("StartWinHttpDownload()");

    URL_COMPONENTS  UrlComponents;
    SAUProxyInfo    AUProxyInfo;

    HINTERNET   hInternet = NULL;
    HINTERNET   hConnect = NULL;
    HINTERNET   hOpenRequest = NULL;
    DWORD       dwStatus, dwAccessType;

    LPWSTR      wszServerName = NULL;
    LPWSTR      wszObject = NULL;
    LPWSTR      wszContentType = NULL;
    WCHAR       wszUserName[UNLEN + 1];
    WCHAR       wszPasswd[UNLEN + 1];
    WCHAR       wszScheme[32];

    // NULL (equivalent to "GET") MUST be the last verb in the list
    LPCWSTR     rgwszVerbs[] = { L"HEAD", NULL };
    DWORD       iVerb;

    HRESULT     hr = S_OK, hrToReturn = S_OK;
    BOOL        fRet = TRUE;

    FILETIME    ft;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       cbRemoteFile;

    DWORD       dwLength;
    DWORD       dwTickStart = 0, dwTickEnd = 0;

    int         iRetryCounter = -1;         // non-negative during download mode

    BOOL        fAllowProxy = ((dwFlags & WUDF_DONTALLOWPROXY) == 0);
    BOOL        fCheckStatusOnly = ((dwFlags & WUDF_CHECKREQSTATUSONLY) != 0);
    BOOL        fAppendCacheBreaker = ((dwFlags & WUDF_APPENDCACHEBREAKER) != 0);
    BOOL        fSkipDownloadRetry = ((dwFlags & WUDF_DODOWNLOADRETRY) == 0);
    BOOL        fDoCabValidation = ((dwFlags & WUDF_SKIPCABVALIDATION) == 0);
    BOOL        fCacheProxyInfo = ((dwFlags & WUDF_SKIPAUTOPROXYCACHE) == 0);

    ZeroMemory(&AUProxyInfo, sizeof(AUProxyInfo));

    if ((wszUrl == NULL) || 
        (wszLocalFile == NULL && fCheckStatusOnly == FALSE))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (pcbDownloaded != NULL)
        *pcbDownloaded = 0;

    wszServerName = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, c_cchMaxURLSize * sizeof(WCHAR));
    wszObject     = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, c_cchMaxURLSize * sizeof(WCHAR));
    if (wszServerName == NULL || wszObject == NULL)
    {
        LOG_ErrorMsg(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    wszServerName[0] = L'\0';
    wszObject[0]     = L'\0';
    wszUserName[0]   = L'\0';
    wszPasswd[0]     = L'\0';

    if (HandleEvents(rghQuitEvents, cQuitEvents) == FALSE)
    {
        hr = E_ABORT;
        goto CleanUp;
    }

    // Break down the URL into its various components for the InternetAPI calls.
    //  Specifically we need the server name, object to download, username and 
    //  password information.
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszHostName     = wszServerName;
    UrlComponents.dwHostNameLength = c_cchMaxURLSize;
    UrlComponents.lpszUrlPath      = wszObject;
    UrlComponents.dwUrlPathLength  = c_cchMaxURLSize;
    UrlComponents.lpszUserName     = wszUserName;
    UrlComponents.dwUserNameLength = ARRAYSIZE(wszUserName);
    UrlComponents.lpszPassword     = wszPasswd;
    UrlComponents.dwPasswordLength = ARRAYSIZE(wszPasswd);
    UrlComponents.lpszScheme       = wszScheme;
    UrlComponents.dwSchemeLength   = ARRAYSIZE(wszScheme);

    LOG_Internet(_T("WinHttp: Downloading URL %ls to FILE %ls"), wszUrl, wszLocalFile);

    if ((*sfns.pfnWinHttpCrackUrl)(wszUrl, 0, 0, &UrlComponents) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    if (wszUrl[0] == L'\0' || wszScheme[0] == L'\0' || wszServerName[0] == L'\0' ||
        _wcsicmp(wszScheme, L"http") != 0)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (fAppendCacheBreaker)
    {
        SYSTEMTIME  stCB;
        WCHAR       wszCacheBreaker[12];
        
        GetSystemTime(&stCB);
        hr = StringCchPrintfExW(wszCacheBreaker, ARRAYSIZE(wszCacheBreaker),
                                NULL, NULL, MISTSAFE_STRING_FLAGS,
                                L"?%02d%02d%02d%02d%02d", 
                                stCB.wYear % 100,
                                stCB.wMonth,
                                stCB.wDay,
                                stCB.wHour,
                                stCB.wMinute);
        if (FAILED(hr))
            goto CleanUp;

        hr = StringCchCatExW(wszObject, c_cchMaxURLSize, wszCacheBreaker, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto CleanUp;
    }

    if (fAllowProxy)
        dwAccessType = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    else
        dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;
    
    dwTickStart = GetTickCount();
    
START_INTERNET:
    // start to deal with Internet    
    iRetryCounter++; 
    
    // If the connection has already been established re-use it.
    hInternet = (*sfns.pfnWinHttpOpen)(c_wszUserAgent, dwAccessType, NULL, NULL, 0);
    if (hInternet == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    if (fAllowProxy != NULL)
    {
        GetWinHTTPProxyInfo(sfns, fCacheProxyInfo, hInternet, wszUrl, 
                            wszServerName, &AUProxyInfo);
    }

    hConnect = (*sfns.pfnWinHttpConnect)(hInternet, wszServerName, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    // if we're only doing a status check, then may as well just make a GET 
    //  request
    iVerb = (DWORD)((fCheckStatusOnly) ? ARRAYSIZE(rgwszVerbs) - 1 : 0);
    for(; iVerb < ARRAYSIZE(rgwszVerbs); iVerb++)
    {
        SafeWinHTTPCloseHandle(sfns, hOpenRequest);

        hr = MakeRequest(sfns, hConnect, NULL, wszServerName, rgwszVerbs[iVerb], 
                         wszObject, ((fAllowProxy) ? &AUProxyInfo : NULL),
                         rghQuitEvents, cQuitEvents, &hOpenRequest);
        if (FAILED(hr))
            goto CleanUp;
        
        dwLength = sizeof(dwStatus);
        if ((*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                           WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, 
                                           NULL, (LPVOID)&dwStatus, &dwLength, NULL) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        LOG_Internet(_T("WinHttp: Request result: %d"), dwStatus);

        if (dwStatus == HTTP_STATUS_OK || dwStatus == HTTP_STATUS_PARTIAL_CONTENT)
        {
            break;
        }
        else
        {
            // since a server result is not a proper win32 error code, we can't 
            //  really do a HRESULT_FROM_WIN32 here.  Otherwise, we'd return
            //  a bogus code.  However, we do want to pass an error HRESULT back
            //  that contains this code.
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, dwStatus);
            LOG_Error(_T("WinHttp: got failed status code from server %d\n"), dwStatus);

            // if it's the last verb in the list, then bail...
            if (rgwszVerbs[iVerb] == NULL)
                goto CleanUp;
        }
    }

    // if we made it here & we're only trying to check status, then we're done
    if (fCheckStatusOnly)
    {
        LOG_Internet(_T("WinHttp: Only checking status.  Exiting before header check and download."));
        hr = S_OK;
        goto CleanUp;
    }

    // CheckFileHeader will return S_OK if we need to download the file, S_FALSE
    //  if we don't, and some other HRESULT if a failure occurred
    hr = CheckFileHeader(sfns, hOpenRequest, rghQuitEvents, cQuitEvents, 
                         wszLocalFile, &cbRemoteFile, &ft);
    if (FAILED(hr))
        goto CleanUp;

    // unless we have a flag that explicitly allows it, do not retry downloads 
    //  here.  The reasoning is that we could be in the middle of a large 
    //  download and have it fail...
    if (fSkipDownloadRetry)
        iRetryCounter = c_cMaxRetries;

    if (hr == S_OK)
    {
        DWORD cbDownloaded;
        BOOL  fCheckForHTML = fDoCabValidation;

        LOG_Internet(_T("WinHttp: Server file was newer.  Downloading file"));
        
        // if we didn't open with a GET request above, then we gotta open a new
        //  request.  Otherwise, can reuse the request object...
        if (rgwszVerbs[iVerb] != NULL)
            SafeWinHTTPCloseHandle(sfns, hOpenRequest);

        // now we know we need to download this file
        hr = MakeRequest(sfns, hConnect, hOpenRequest, wszServerName, NULL, 
                         wszObject, ((fAllowProxy) ? &AUProxyInfo : NULL), 
                         rghQuitEvents, cQuitEvents, &hOpenRequest);
        if (FAILED(hr))
            goto CleanUp;

        // sometimes, we can get fancy error pages back from the site instead of 
        //  a nice nifty HTML error code, so check & see if we got back a html
        //  file when we were expecting a cab.
        if (fCheckForHTML)
        {
            hr = GetContentTypeHeader(sfns, hOpenRequest, &wszContentType);
            if (SUCCEEDED(hr) && wszContentType != NULL)
            {
                fCheckForHTML = FALSE;
                if (_wcsicmp(wszContentType, L"text/html") == 0)
                {
                    LOG_Internet(_T("WinHttp: Content-Type header is text/html.  Bailing."));
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto CleanUp;
                }
                else
                {
                    LOG_Internet(_T("WinHttp: Content-Type header is %ls.  Continuing."), wszContentType);
                }
            }

            hr = NOERROR;
        }

        // open the file we're gonna spew into
        hFile = CreateFileW(wszLocalFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
                            FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        LOG_Internet(_T("WinHttp: downloading to FILE %ls"), wszLocalFile);

        // bring down the bits
        hr = PerformDownloadToFile(sfns.pfnWinHttpReadData, hOpenRequest, 
                                   hFile, cbRemoteFile,
                                   cbDownloadBuffer, 
                                   rghQuitEvents, cQuitEvents, 
                                   pfnCallback, pvCallbackData, &cbDownloaded);
        if (FAILED(hr))
        {
            LOG_Internet(_T("WinHttp: Download failed: hr: 0x%08x"), hr);
            SafeCloseInvalidHandle(hFile);
            DeleteFileW(wszLocalFile);
            goto CleanUp;
        }

        LOG_Internet(_T("WinHttp: Download succeeded"));

        // set the file time to match the server file time since we just 
        //  downloaded it. If we don't do this the file time will be set 
        //  to the current system time.
        SetFileTime(hFile, &ft, NULL, NULL);
        SafeCloseInvalidHandle(hFile);

        if (pcbDownloaded != NULL)
            *pcbDownloaded = cbRemoteFile;

        // sometimes, we can get fancy error pages back from the site instead of 
        //  a nice nifty HTML error code, so check & see if we got back a html
        //  file when we were expecting a cab.
        if (fCheckForHTML)
        {
            hr = IsFileHtml(wszLocalFile);
            if (SUCCEEDED(hr))
            {
                if (hr == S_FALSE)
                {
                    LOG_Internet(_T("WinHttp: Download is not a html file"));
                    hr = S_OK;
                }
                else
                {
                    LOG_Internet(_T("WinHttp: Download is a html file.  Failing download."));
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    DeleteFileW(wszLocalFile);
                    goto CleanUp;
                }
            }
            else
            {
                LOG_Internet(_T("WinHttp: Unable to determine if download is a html file or not.  Failing download."));
            }
        }
        else if (fDoCabValidation == FALSE)
        {
            LOG_Internet(_T("WinHttp: Skipping cab validation."));
        }
    }
    else
    {
        hr = S_OK;
        
        LOG_Internet(_T("WinHttp: Server file is not newer.  Skipping download."));
        
        // The server ain't newer & the file is already on machine, so
        //  send progress callback indicating file downloadeded ok
        if (pfnCallback != NULL)
        {
            // fpnCallback(pCallbackData, DOWNLOAD_STATUS_FILECOMPLETE, dwFileSize, dwFileSize, NULL, NULL);
            pfnCallback(pvCallbackData, DOWNLOAD_STATUS_OK, cbRemoteFile, cbRemoteFile, NULL, NULL);
        }
    }

CleanUp:
    SafeWinHTTPCloseHandle(sfns, hOpenRequest);
    SafeWinHTTPCloseHandle(sfns, hConnect);
    SafeWinHTTPCloseHandle(sfns, hInternet);

    SafeHeapFree(wszContentType);

    // free up the proxy strings- they were allocated by WinHttp
    if (AUProxyInfo.ProxyInfo.lpszProxyBypass != NULL)
        GlobalFree(AUProxyInfo.ProxyInfo.lpszProxyBypass);
    if (AUProxyInfo.wszProxyOrig != NULL)
        GlobalFree(AUProxyInfo.wszProxyOrig);
    if (AUProxyInfo.rgwszProxies != NULL)
        GlobalFree(AUProxyInfo.rgwszProxies);
    ZeroMemory(&AUProxyInfo, sizeof(AUProxyInfo));
    
    // if we failed, see if it's ok to continue (quit events) and whether
    //  we've tried enuf times yet.
    if (FAILED(hr) &&
        HandleEvents(rghQuitEvents, cQuitEvents) &&
        iRetryCounter >= 0 && iRetryCounter < c_cMaxRetries)
    {
        DWORD dwElapsedTime;

        dwTickEnd = GetTickCount();
        if (dwTickEnd > dwTickStart)   
            dwElapsedTime = dwTickEnd - dwTickStart;
        else
            dwElapsedTime = (0xFFFFFFFF - dwTickStart) + dwTickEnd;
        
        // We haven't hit our retry limit, so log & error and go again
        if (dwElapsedTime < c_dwRetryTimeLimitInmsWinHttp)
        {
            LogError(hr, "Library download error. Will retry.");

            // in the case where we're gonna retry, keep track of the very first
            //  error we encoutered cuz the ops guys say that this is the most
            //  useful error to know about.
            if (iRetryCounter == 0)
            {
                LOG_Internet(_T("First download error saved: 0x%08x."), hr);
                hrToReturn = hr;
            }
            else
            {
                LOG_Internet(_T("Subsequent download error: 0x%08x."), hr);
            }
            hr = S_OK;
            goto START_INTERNET;
        }

        // We've completely timed out, so bail
        else
        {
            LogError(hr, "Library download error and timed out (%d ms). Will not retry.", dwElapsedTime);
        }
    }
    
    // make a callback indicating a download error
    if (FAILED(hr) && pfnCallback != NULL)
        pfnCallback(pvCallbackData, DOWNLOAD_STATUS_ERROR, cbRemoteFile, 0, NULL, NULL);

    // if we haven't saved off an error, just use the current error.  We can't
    //  have set hrToReturn previously if we didn't fail and want to attempt 
    //  a retry.
    // However, if we've got a success from this pass, be sure to return that 
    //  and not a fail code.
    if (FAILED(hr) && SUCCEEDED(hrToReturn))
        hrToReturn = hr;
    else if (SUCCEEDED(hr) && FAILED(hrToReturn))
        hrToReturn = hr;

    SafeHeapFree(wszServerName);
    SafeHeapFree(wszObject);
    
    return hrToReturn;
}

#endif // defined(UNICODE)

///////////////////////////////////////////////////////////////////////////////
// exported functions

#if defined(UNICODE)

// **************************************************************************
HRESULT  GetAUProxySettings(LPCWSTR wszUrl, SAUProxySettings *paups)
{
    LOG_Block("GetAUProxySettings()");

    URL_COMPONENTS      UrlComponents;
    LPWSTR              wszServerName = NULL;
    LPWSTR              wszObject = NULL;
    WCHAR               wszUserName[UNLEN + 1];
    WCHAR               wszPasswd[UNLEN + 1];
    WCHAR               wszScheme[32];

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    BOOL                fRet, fLocked = FALSE;

    if (wszUrl == NULL || paups == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    ZeroMemory(paups, sizeof(SAUProxySettings));

    etu = LoadTransportDll(&sfns, &hmod, WUDF_ALLOWWINHTTPONLY);
    if (etu == etuNone)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }
    else if (etu != etuWinHttp)
    {
        hr = E_FAIL;
        LOG_Internet(_T("GetAUProxySettings called when in WinInet mode."));
        goto done;
    }

    wszServerName = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, c_cchMaxURLSize * sizeof(WCHAR));
    wszObject     = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, c_cchMaxURLSize * sizeof(WCHAR));
    if (wszServerName == NULL || wszObject == NULL)
    {
        LOG_ErrorMsg(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszHostName     = wszServerName;
    UrlComponents.dwHostNameLength = c_cchMaxURLSize;
    UrlComponents.lpszUrlPath      = wszObject;
    UrlComponents.dwUrlPathLength  = c_cchMaxURLSize;
    UrlComponents.lpszUserName     = wszUserName;
    UrlComponents.dwUserNameLength = ARRAYSIZE(wszUserName);
    UrlComponents.lpszPassword     = wszPasswd;
    UrlComponents.dwPasswordLength = ARRAYSIZE(wszPasswd);
    UrlComponents.lpszScheme       = wszScheme;
    UrlComponents.dwSchemeLength   = ARRAYSIZE(wszScheme);
    
    if ((*sfns.pfnWinHttpCrackUrl)(wszUrl, 0, 0, &UrlComponents) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    if (wszUrl[0] == L'\0' || wszScheme[0] == L'\0' || wszServerName[0] == L'\0' ||
        (_wcsicmp(wszScheme, L"http") != 0 && _wcsicmp(wszScheme, L"https") != 0))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        hr = E_INVALIDARG;
        goto done;
    }
   
    if (g_csCache.Lock() == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }
    fLocked = TRUE;

    // get the proxy list 
    if (g_wudlProxyCache.GetLastGoodProxy(wszServerName, paups) == FALSE)
    {
        
        // proxy was not in list
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            SAUProxyInfo    aupi;
            HINTERNET       hInternet = NULL;

            LOG_Internet(_T("GetLastGoodProxy did not find a proxy object.  Doing autodetect."));
            
            hInternet = (*sfns.pfnWinHttpOpen)(c_wszUserAgent, 
                                               WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, 
                                               NULL, NULL, 0);
            if (hInternet == NULL)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_ErrorMsg(hr);
                goto done;
            }

            fRet = GetWinHTTPProxyInfo(sfns, TRUE, hInternet, wszUrl, 
                                       wszServerName, &aupi);
            (*sfns.pfnWinHttpCloseHandle)(hInternet);
            if (fRet == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_ErrorMsg(hr);
                goto done;
            }

            paups->wszProxyOrig = aupi.wszProxyOrig;
            paups->wszBypass    = aupi.ProxyInfo.lpszProxyBypass;
            paups->dwAccessType = aupi.ProxyInfo.dwAccessType;
            paups->cProxies     = aupi.cProxies;
            paups->rgwszProxies = aupi.rgwszProxies;
            paups->iProxy       = (DWORD)-1;

            SetLastError(ERROR_SUCCESS);
            
        }
        else
        {
            LOG_Internet(_T("GetLastGoodProxy failed..."));
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto done;
        }
    }
    else
    {
        if (paups->wszProxyOrig != NULL)
        {
            // break it up into an array
            if (ProxyListToArray(paups->wszProxyOrig, &paups->rgwszProxies,
                                &paups->cProxies) == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_ErrorMsg(hr);
                goto done;
            }
        }
        else
        {
            paups->iProxy       = (DWORD)-1;
        }
    }
       
done:
    // Unlock returns FALSE as well, but we should never get here cuz we should
    //  not have been able to take the lock above.
    if (fLocked)
        g_csCache.Unlock();
    if (wszServerName != NULL)
        HeapFree(GetProcessHeap(), 0, wszServerName);
    if (wszObject != NULL)
        HeapFree(GetProcessHeap(), 0, wszObject);
        
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    
    return hr;
}

// **************************************************************************
HRESULT FreeAUProxySettings(SAUProxySettings *paups)
{
    LOG_Block("FreeAUProxySettings()");

    if (paups == NULL)
        goto done;
    
    if (paups->rgwszProxies != NULL)
        GlobalFree(paups->rgwszProxies);
    if (paups->wszBypass != NULL)
        GlobalFree(paups->wszBypass);
    if (paups->wszProxyOrig != NULL)
        GlobalFree(paups->wszProxyOrig);

done:
    return S_OK;
}

// **************************************************************************
HRESULT CleanupDownloadLib(void)
{
    LOG_Block("CleanupDownloadLib()");

    HRESULT hr = S_OK;

    if (g_hmodWinHttp != NULL)
    {
        FreeLibrary(g_hmodWinHttp);
        g_hmodWinHttp = NULL;        
    }

    if (g_hmodWinInet != NULL)
    {
        FreeLibrary(g_hmodWinInet);
        g_hmodWinInet = NULL;        
    }

    if (g_csCache.Lock() == FALSE)
        return E_FAIL;

    __try { g_wudlProxyCache.Empty(); }
    __except(EXCEPTION_EXECUTE_HANDLER) { hr = E_FAIL; }

    // this returns FALSE as well, but we should never get here cuz we should
    //  not have been able to take the lock above.
    g_csCache.Unlock();

    return hr;
}

// **************************************************************************
HRESULT DownloadFile(
            LPCWSTR wszServerUrl,            // full http url
            LPCWSTR wszLocalPath,            // local directory to download file to
            LPCWSTR wszLocalFileName,        // optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
            PDWORD  pdwDownloadedBytes,      // bytes downloaded for this file
            HANDLE  *hQuitEvents,            // optional events causing this function to abort
            UINT    nQuitEventCount,         // number of quit events, must be 0 if array is NULL
            PFNDownloadCallback fpnCallback, // optional call back function
            VOID*   pCallbackData,           // parameter for call back function to use
            DWORD   dwFlags
)
{
    LOG_Block("DownloadFile()");

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    LPWSTR              wszLocalFile = NULL;
    DWORD               dwFlagsToUse;

    // for full download, disable cache breaker.
    dwFlagsToUse = dwFlags & ~WUDF_APPENDCACHEBREAKER;
    
    ZeroMemory(&sfns, sizeof(sfns));

    if (wszServerUrl == NULL || wszLocalPath == NULL)
    {
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        hr = E_INVALIDARG;
        goto done;
    }

    etu = LoadTransportDll(&sfns, &hmod, dwFlagsToUse);
    if (etu == etuNone)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    else if (etu != etuWinHttp && etu != etuWinInet)
    {
        hr = E_FAIL;
        LogError(hr, "Unexpected answer from LoadTransportDll(): %d", etu);
        goto done;
    }

    // Since StartDownload just takes a full path to the file to download, build
    //  it here...  
    // Note that we don't need to do this if we're just in status 
    //  checking mode)
    if ((dwFlags & WUDF_CHECKREQSTATUSONLY) == 0)
    {
        wszLocalFile = MakeFullLocalFilePath(wszServerUrl, wszLocalFileName, 
                                             wszLocalPath);
        if (wszLocalFile == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto done;
        }
    }

    if (etu == etuWinHttp)
    {
        hr = StartWinHttpDownload(sfns, wszServerUrl, wszLocalFile, 
                                  pdwDownloadedBytes, hQuitEvents, nQuitEventCount,
                                  fpnCallback, pCallbackData, dwFlagsToUse,
                                  c_cbDownloadBuffer);
    }

    else
    {
        hr = StartWinInetDownload(hmod, wszServerUrl, wszLocalFile, 
                                  pdwDownloadedBytes, hQuitEvents, nQuitEventCount, 
                                  fpnCallback, pCallbackData, dwFlagsToUse,
                                  c_cbDownloadBuffer);
    }

done:
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    SafeHeapFree(wszLocalFile);
    return hr;
}

// **************************************************************************
HRESULT DownloadFileLite(LPCWSTR wszDownloadUrl, 
                         LPCWSTR wszLocalFile,  
                         HANDLE hQuitEvent,
                         DWORD dwFlags)
{
    LOG_Block("DownloadFileLite()");

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    DWORD               dwFlagsToUse;


    // for lite download, force cache breaker & download retry
    dwFlagsToUse = dwFlags | WUDF_APPENDCACHEBREAKER | WUDF_DODOWNLOADRETRY;

    ZeroMemory(&sfns, sizeof(sfns));

    etu = LoadTransportDll(&sfns, &hmod, dwFlagsToUse);

    switch (etu)
    {
        case etuNone:
            LOG_ErrorMsg(GetLastError());
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;

        case etuWinHttp:
            hr = StartWinHttpDownload(sfns, wszDownloadUrl, wszLocalFile, 
                                      NULL, 
                                      ((hQuitEvent != NULL) ? &hQuitEvent : NULL),
                                      ((hQuitEvent != NULL) ? 1 : 0),
                                      NULL, NULL, dwFlagsToUse,
                                      c_cbDownloadBuffer);
            break;

        case etuWinInet:
            hr = StartWinInetDownload(hmod, wszDownloadUrl, wszLocalFile,  
                                      NULL, 
                                      ((hQuitEvent != NULL) ? &hQuitEvent : NULL),
                                      ((hQuitEvent != NULL) ? 1 : 0),
                                      NULL, NULL, dwFlagsToUse,
                                      c_cbDownloadBuffer);
            break;
            
        default:
            LogError(hr, "Unexpected answer from LoadTransportDll(): %d", etu);
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
    }

done:
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    return hr;
}

#else // !defined(UNICODE)

// **************************************************************************
HRESULT  GetAUProxySettings(LPCWSTR wszUrl, SAUProxySettings *paups)
{
    return E_NOTIMPL;
}

// **************************************************************************
HRESULT FreeAUProxySettings(SAUProxySettings *paups)
{
    return E_NOTIMPL;
}

// **************************************************************************
HRESULT CleanupDownloadLib(void)
{
    if (g_hmodWinInet != NULL)
    {
        FreeLibrary(g_hmodWinInet);
        g_hmodWinInet = NULL;        
    }
    
    return NOERROR;
}

// **************************************************************************
HRESULT DownloadFile(
            LPCSTR  pszServerUrl,            // full http url
            LPCSTR  pszLocalPath,            // local directory to download file to
            LPCSTR  pszLocalFileName,        // optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
            PDWORD  pdwDownloadedBytes,      // bytes downloaded for this file
            HANDLE  *hQuitEvents,            // optional events causing this function to abort
            UINT    nQuitEventCount,         // number of quit events, must be 0 if array is NULL
            PFNDownloadCallback fpnCallback, // optional call back function
            VOID*   pCallbackData,            // parameter for call back function to use
            DWORD   dwFlags
)
{
    LOG_Block("DownloadFile()");

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    LPSTR               pszLocalFile = NULL;
    DWORD               dwFlagsToUse;

    // for ansi, force wininet & disable any request to force winhttp 
    // for full download, disable cache breaker.
    dwFlagsToUse = dwFlags | WUDF_ALLOWWININETONLY;
    dwFlagsToUse &= ~(WUDF_ALLOWWINHTTPONLY | WUDF_APPENDCACHEBREAKER);

    ZeroMemory(&sfns, sizeof(sfns));

    etu = LoadTransportDll(&sfns, &hmod, dwFlagsToUse);
    if (etu == etuNone)
    {
        LOG_ErrorMsg(GetLastError());
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    else if (etu != etuWinInet)
    {
        hr = E_FAIL;
        LogError(hr, "Unexpected answer from LoadTransportDll(): %d", etu);
        goto done;
    }

    // Since StartDownload just takes a full path to the file to download, build
    //  it here...  
    // Note that we don't need to do this if we're just in status 
    //  checking mode)
    if ((dwFlags & WUDF_CHECKREQSTATUSONLY) == 0)
    {
        pszLocalFile = MakeFullLocalFilePath(pszServerUrl, pszLocalFileName, 
                                             pszLocalPath);
        if (pszLocalFile == NULL)
        {
            LOG_ErrorMsg(GetLastError());
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }
    }

    hr = StartWinInetDownload(hmod, pszServerUrl, pszLocalFile, 
                              pdwDownloadedBytes, hQuitEvents, nQuitEventCount, 
                              fpnCallback, pCallbackData, dwFlagsToUse,
                              c_cbDownloadBuffer);

done:
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    SafeHeapFree(pszLocalFile);
    
    return hr;
}

// **************************************************************************
HRESULT DownloadFileLite(LPCSTR pszDownloadUrl, 
                         LPCSTR pszLocalFile,  
                         HANDLE hQuitEvent,
                         DWORD dwFlags)

{
    LOG_Block("DownloadFileLite()");

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    DWORD               dwFlagsToUse;

    // for ansi, force wininet & disable any request to force winhttp 
    // for lite download, force cache breaker & download retry
    dwFlagsToUse = dwFlags | WUDF_APPENDCACHEBREAKER | WUDF_ALLOWWININETONLY |
                   WUDF_DODOWNLOADRETRY;
    dwFlagsToUse &= ~WUDF_ALLOWWINHTTPONLY;
    
    ZeroMemory(&sfns, sizeof(sfns));

    etu = LoadTransportDll(&sfns, &hmod, dwFlagsToUse);
    switch (etu)
    {
        case etuNone:
            LOG_ErrorMsg(GetLastError());
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;

        case etuWinInet:
            hr = StartWinInetDownload(hmod, pszDownloadUrl, pszLocalFile,  
                                      NULL, 
                                      ((hQuitEvent != NULL) ? &hQuitEvent : NULL),
                                      ((hQuitEvent != NULL) ? 1 : 0),
                                      NULL, NULL, dwFlagsToUse,
                                      c_cbDownloadBuffer);
            break;
            
        default:
        case etuWinHttp:
            LogError(hr, "Unexpected answer from LoadTransportDll(): %d", etu);
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
    }

done:
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    return hr;
}

#endif // defined(UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\install\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	detect
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.util

TARGETNAME=install
#TARGETPATH=$(_IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=0

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);..\..\..\inc

SOURCES= \
	drvinst.cpp \
        install.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\download\download.cpp ===
#include <windows.h>
#include <wininet.h>
#include <shlwapi.h>
#include <logging.h>
#include "iucommon.h"
#include "download.h"
#include "dlutil.h"

#include "trust.h"
#include "fileutil.h"
#include "malloc.h"

extern "C"
{
// wininet 
typedef BOOL      (STDAPICALLTYPE *pfn_InternetCrackUrl)(LPCTSTR, DWORD, DWORD, LPURL_COMPONENTS);
typedef HINTERNET (STDAPICALLTYPE *pfn_InternetOpen)(LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD);
typedef HINTERNET (STDAPICALLTYPE *pfn_InternetConnect)(HINTERNET, LPCTSTR, INTERNET_PORT, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR);
typedef HINTERNET (STDAPICALLTYPE *pfn_HttpOpenRequest)(HINTERNET, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR FAR *, DWORD, DWORD_PTR);
typedef BOOL      (STDAPICALLTYPE *pfn_HttpSendRequest)(HINTERNET, LPCTSTR, DWORD, LPVOID, DWORD);
typedef BOOL      (STDAPICALLTYPE *pfn_HttpQueryInfo)(HINTERNET, DWORD, LPVOID, LPDWORD, LPDWORD);
typedef BOOL      (STDAPICALLTYPE *pfn_InternetReadFile)(HINTERNET, LPVOID, DWORD, LPDWORD);
typedef BOOL      (STDAPICALLTYPE *pfn_InternetCloseHandle)(HINTERNET);
};


struct SWinInetFunctions
{
    // wininet function pointers
    pfn_InternetCrackUrl    pfnInternetCrackUrl;
    pfn_InternetOpen        pfnInternetOpen;
    pfn_InternetConnect     pfnInternetConnect;
    pfn_HttpOpenRequest     pfnHttpOpenRequest;
    pfn_HttpSendRequest     pfnHttpSendRequest;
    pfn_HttpQueryInfo       pfnHttpQueryInfo;
    pfn_InternetReadFile    pfnInternetReadFile;
    pfn_InternetCloseHandle pfnInternetCloseHandle;
    HMODULE                 hmod;
};

#define SafeInternetCloseHandle(sfns, x) if (NULL != x) { (*sfns.pfnInternetCloseHandle)(x); x = NULL; }

// **************************************************************************
BOOL LoadWinInetFunctions(HMODULE hmod, SWinInetFunctions *psfns)
{
    LOG_Block("LoadWinInetFunctions()");

    BOOL    fRet = FALSE;

    psfns->hmod                   = hmod;
#if defined(UNICODE)
    psfns->pfnInternetCrackUrl    = (pfn_InternetCrackUrl)GetProcAddress(hmod, "InternetCrackUrlW");
    psfns->pfnInternetOpen        = (pfn_InternetOpen)GetProcAddress(hmod, "InternetOpenW");
    psfns->pfnInternetConnect     = (pfn_InternetConnect)GetProcAddress(hmod, "InternetConnectW");
    psfns->pfnHttpOpenRequest     = (pfn_HttpOpenRequest)GetProcAddress(hmod, "HttpOpenRequestW");
    psfns->pfnHttpSendRequest     = (pfn_HttpSendRequest)GetProcAddress(hmod, "HttpSendRequestW");
    psfns->pfnHttpQueryInfo       = (pfn_HttpQueryInfo)GetProcAddress(hmod, "HttpQueryInfoW");
    psfns->pfnInternetReadFile    = (pfn_InternetReadFile)GetProcAddress(hmod, "InternetReadFile");
    psfns->pfnInternetCloseHandle = (pfn_InternetCloseHandle)GetProcAddress(hmod, "InternetCloseHandle");
#else
    psfns->pfnInternetCrackUrl    = (pfn_InternetCrackUrl)GetProcAddress(hmod, "InternetCrackUrlA");
    psfns->pfnInternetOpen        = (pfn_InternetOpen)GetProcAddress(hmod, "InternetOpenA");
    psfns->pfnInternetConnect     = (pfn_InternetConnect)GetProcAddress(hmod, "InternetConnectA");
    psfns->pfnHttpOpenRequest     = (pfn_HttpOpenRequest)GetProcAddress(hmod, "HttpOpenRequestA");
    psfns->pfnHttpSendRequest     = (pfn_HttpSendRequest)GetProcAddress(hmod, "HttpSendRequestA");
    psfns->pfnHttpQueryInfo       = (pfn_HttpQueryInfo)GetProcAddress(hmod, "HttpQueryInfoA");
    psfns->pfnInternetReadFile    = (pfn_InternetReadFile)GetProcAddress(hmod, "InternetReadFile");
    psfns->pfnInternetCloseHandle = (pfn_InternetCloseHandle)GetProcAddress(hmod, "InternetCloseHandle");
#endif
    if (psfns->pfnInternetCrackUrl == NULL || 
        psfns->pfnInternetOpen == NULL ||
        psfns->pfnInternetConnect == NULL || 
        psfns->pfnHttpOpenRequest == NULL ||
        psfns->pfnHttpSendRequest == NULL || 
        psfns->pfnHttpQueryInfo == NULL ||
        psfns->pfnInternetReadFile == NULL || 
        psfns->pfnInternetCloseHandle == NULL)
    {
        // don't free the library here.  It should be freed 
        SetLastError(ERROR_PROC_NOT_FOUND);
        ZeroMemory(psfns, sizeof(SWinInetFunctions));
        goto done;
    }

    LOG_Internet(_T("Successfully loaded WinInet functions"));

    fRet = TRUE;

done:
    return fRet;
}

// **************************************************************************
static
HRESULT MakeRequest(SWinInetFunctions   &sfns,
                    HINTERNET hConnect, 
                    HINTERNET hRequest, 
                    LPCTSTR szVerb, 
                    LPCTSTR szObject, 
                    HANDLE *rghEvents, 
                    DWORD cEvents, 
                    HINTERNET *phRequest)
{
    LOG_Block("MakeRequest()");

    HINTERNET   hOpenRequest = NULL;
    LPCTSTR     szAcceptTypes[] = { _T("*/*"), NULL };
    HRESULT     hr = S_OK;

    LOG_Internet(_T("WinInet: Making %s request for %s"), szVerb, szObject);

    if (hRequest == NULL)
    {
        // Open a HEAD request to ask for information about this file
        hOpenRequest = (*sfns.pfnHttpOpenRequest)(hConnect, szVerb, szObject, NULL, NULL, 
                                                  szAcceptTypes, INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_UI, 0);
        if (!hOpenRequest)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
    }
    else
    {
        hOpenRequest = hRequest;
    }

    if (!HandleEvents(rghEvents, cEvents))
    {
        hr = E_ABORT;
        goto CleanUp;
    }

    if (! (*sfns.pfnHttpSendRequest)(hOpenRequest, NULL, 0, NULL, 0) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    if (HandleEvents(rghEvents, cEvents) == FALSE)
    {
        hr = E_ABORT;
        goto CleanUp;
    }

    *phRequest   = hOpenRequest;
    hOpenRequest = NULL;
    
CleanUp:
    // don't want to free handle if we didn't open it.
    if (hRequest != hOpenRequest)
        SafeInternetCloseHandle(sfns, hOpenRequest);
    return hr;
}

// **************************************************************************
static
HRESULT GetContentTypeHeader(SWinInetFunctions &sfns,
                             HINTERNET hOpenRequest,
                             LPTSTR *pszContentType)
{
    LOG_Block("GetContentTypeHeader()");

    HRESULT hr = S_OK;
    LPTSTR  szContentType = NULL;
    DWORD   dwLength, dwErr;
    BOOL    fRet;

    *pszContentType = NULL;

    dwLength = 0;
    fRet = (*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_CONTENT_TYPE, 
                                    (LPVOID)NULL, &dwLength, NULL);
    if (fRet == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    if (dwLength == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_HTTP_HEADER_NOT_FOUND);
        goto done;
    }

    szContentType = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength);
    if (szContentType == NULL)
    {
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
        goto done;
    }

    if ((*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_CONTENT_TYPE, 
                                 (LPVOID)szContentType, &dwLength, 
                                 NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    *pszContentType = szContentType;
    szContentType   = NULL;

done:
    SafeHeapFree(szContentType);

    return hr;
}

// **************************************************************************
HRESULT StartWinInetDownload(HMODULE hmodWinInet,
                             LPCTSTR pszServerUrl, 
                             LPCTSTR pszLocalFile,
                             DWORD *pdwDownloadedBytes,
                             HANDLE *rghQuitEvents,
                             UINT cQuitEvents,
                             PFNDownloadCallback pfnCallback,
                             LPVOID pvCallbackData,
                             DWORD dwFlags,
                             DWORD cbDownloadBuffer)
{
    LOG_Block("StartWinInetDownload()");

    URL_COMPONENTS UrlComponents;
    
    SWinInetFunctions sfns;
    HINTERNET   hInternet = NULL;
    HINTERNET   hConnect = NULL;
    HINTERNET   hOpenRequest = NULL;
    DWORD       dwStatus, dwAccessType;
    
    LPTSTR      pszServerName = NULL;
    LPTSTR      pszObject = NULL;
    LPTSTR      pszContentType = NULL;
    TCHAR       szUserName[UNLEN + 1];
    TCHAR       szPasswd[UNLEN + 1];
    TCHAR       szScheme[32];
    
    // NULL (equivalent to "GET") MUST be the last verb in the list
    LPCTSTR     rgszVerbs[] = { _T("HEAD"), NULL };
    DWORD       iVerb;
    
    HRESULT     hr = S_OK, hrToReturn = S_OK;
    BOOL        fRet = TRUE;

    SYSTEMTIME  st;
    FILETIME    ft;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       cbRemoteFile = 0;

    DWORD       dwLength;
    DWORD       dwTickStart = 0, dwTickEnd = 0;
    
    int         iRetryCounter = -1;         // non-negative during download mode

    BOOL        fAllowProxy = ((dwFlags & WUDF_DONTALLOWPROXY) == 0);
    BOOL        fCheckStatusOnly = ((dwFlags & WUDF_CHECKREQSTATUSONLY) != 0);
    BOOL        fAppendCacheBreaker = ((dwFlags & WUDF_APPENDCACHEBREAKER) != 0);
    BOOL        fSkipDownloadRetry = ((dwFlags & WUDF_DODOWNLOADRETRY) == 0);
    BOOL        fDoCabValidation = ((dwFlags & WUDF_SKIPCABVALIDATION) == 0);
    
    ZeroMemory(&sfns, sizeof(sfns));

    if ((pszServerUrl == NULL) || 
        (pszLocalFile == NULL && fCheckStatusOnly == FALSE))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }
   
    if (NULL != pdwDownloadedBytes)
        *pdwDownloadedBytes = 0;

    if (LoadWinInetFunctions(hmodWinInet, &sfns) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        return hr;
    }

    pszServerName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, c_cchMaxURLSize * sizeof(TCHAR));
    pszObject     = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, c_cchMaxURLSize * sizeof(TCHAR));
    if ((pszServerName == NULL) || (pszObject == NULL))
    {
        hr = E_OUTOFMEMORY;
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    pszServerName[0] = L'\0';
    pszObject[0]     = L'\0';
    szUserName[0]    = L'\0';
    szPasswd[0]      = L'\0';

    if (HandleEvents(rghQuitEvents, cQuitEvents) == FALSE)
    {
        hr = E_ABORT;
        goto CleanUp;
    }

    // Break down the URL into its various components for the InternetAPI calls.
    //  Specifically we need the server name, object to download, username and 
    //  password information.
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszHostName     = pszServerName;
    UrlComponents.dwHostNameLength = c_cchMaxURLSize;
    UrlComponents.lpszUrlPath      = pszObject;
    UrlComponents.dwUrlPathLength  = c_cchMaxURLSize;
    UrlComponents.lpszUserName     = szUserName;
    UrlComponents.dwUserNameLength = ARRAYSIZE(szUserName);
    UrlComponents.lpszPassword     = szPasswd;
    UrlComponents.dwPasswordLength = ARRAYSIZE(szPasswd);
    UrlComponents.lpszScheme       = szScheme;
    UrlComponents.dwSchemeLength   = ARRAYSIZE(szScheme);

    LOG_Internet(_T("WinInet: Downloading URL %s to FILE %s"), pszServerUrl, pszLocalFile);

    if ((*sfns.pfnInternetCrackUrl)(pszServerUrl, 0, 0, &UrlComponents) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    if (pszServerUrl[0] == L'\0' || szScheme[0] == L'\0' || pszServerName[0] == L'\0' ||
        _tcsicmp(szScheme, _T("http")) != 0)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (fAppendCacheBreaker)
    {
        SYSTEMTIME  stCB;
        TCHAR       szCacheBreaker[12];
        
        GetSystemTime(&stCB);
        hr = StringCchPrintfEx(szCacheBreaker, ARRAYSIZE(szCacheBreaker),
                               NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("?%02d%02d%02d%02d%02d"),
                               stCB.wYear % 100,
                               stCB.wMonth,
                               stCB.wDay,
                               stCB.wHour,
                               stCB.wMinute);
        if (FAILED(hr))
            goto CleanUp;

        hr = StringCchCatEx(pszObject, c_cchMaxURLSize, szCacheBreaker, 
                            NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto CleanUp;
    }

    if (fAllowProxy)
        dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    else
        dwAccessType = INTERNET_OPEN_TYPE_DIRECT;

    dwTickStart = GetTickCount();
    
START_INTERNET:
    // start to deal with Internet
    iRetryCounter++;

    // If the connection has already been established re-use it.
    hInternet = (*sfns.pfnInternetOpen)(c_tszUserAgent, dwAccessType, NULL, NULL, 0);
    if (hInternet == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    
    hConnect = (*sfns.pfnInternetConnect)(hInternet, pszServerName, INTERNET_DEFAULT_HTTP_PORT, 
                                          szUserName, szPasswd,
                                          INTERNET_SERVICE_HTTP,
                                          INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD | INTERNET_FLAG_KEEP_CONNECTION,
                                          0);
    if (hConnect == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    iVerb = (DWORD)((fCheckStatusOnly) ? ARRAYSIZE(rgszVerbs) - 1 : 0);
    for(; iVerb < ARRAYSIZE(rgszVerbs); iVerb++)
    {
        SafeInternetCloseHandle(sfns, hOpenRequest);

        hr = MakeRequest(sfns, hConnect, NULL, rgszVerbs[iVerb], pszObject, rghQuitEvents, cQuitEvents,
                         &hOpenRequest);
        if (FAILED(hr))
            goto CleanUp;

        dwLength = sizeof(dwStatus);
        if ((*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, 
                                     (LPVOID)&dwStatus, &dwLength, NULL) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        LOG_Internet(_T("WinInet: Request result: %d"), dwStatus);

        if (dwStatus == HTTP_STATUS_OK || dwStatus == HTTP_STATUS_PARTIAL_CONTENT)
        {
            break;
        }
        else
        {
            // since a server result is not a proper win32 error code, we can't 
            //  really do a HRESULT_FROM_WIN32 here.  Otherwise, we'd return
            //  a bogus code.  However, we do want to pass an error HRESULT back
            //  that contains this code.
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, dwStatus);
            LOG_Error(_T("WinInet: got failed status code from server %d\n"), dwStatus);

            // if it's the last verb in the list, then bail...
            if (rgszVerbs[iVerb] == NULL)
                goto CleanUp;
        }
    }

    // if we made it here & we're only trying to check status, then we're done
    if (fCheckStatusOnly)
    {
        LOG_Internet(_T("WinInet: Only checking status.  Exiting before header check and download."));
        hr = S_OK;
        goto CleanUp;
    }

    dwLength = sizeof(st);
    if ((*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
                                 (LPVOID)&st, &dwLength, NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    SystemTimeToFileTime(&st, &ft);

    // Now Get the FileSize information from the Server
    dwLength = sizeof(cbRemoteFile);
    if ((*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
                                 (LPVOID)&cbRemoteFile, &dwLength, NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    
    if (HandleEvents(rghQuitEvents, cQuitEvents) == FALSE)
    {
        hr = E_ABORT;
        goto CleanUp;
    }
    
    // unless we have a flag that explicitly allows it, do not retry downloads 
    //  here.  The reasoning is that we could be in the middle of a large 
    //  download and have it fail...
    if (fSkipDownloadRetry)
        iRetryCounter = c_cMaxRetries;

    if (IsServerFileDifferent(ft, cbRemoteFile, pszLocalFile))
    {
        DWORD cbDownloaded;
        BOOL  fCheckForHTML = fDoCabValidation;

        LOG_Internet(_T("WinInet: Server file was newer.  Downloading file"));
        
        // if we didn't open with a GET request above, then we gotta open a new
        //  request.  Otherwise, can reuse the request object...
        if (rgszVerbs[iVerb] != NULL)
            SafeInternetCloseHandle(sfns, hOpenRequest);

        hr = MakeRequest(sfns, hConnect, hOpenRequest, NULL, pszObject,
                         rghQuitEvents, cQuitEvents, &hOpenRequest);
        if (FAILED(hr))
            goto CleanUp;

        // sometimes, we can get fancy error pages back from the site instead of 
        //  a nice nifty HTML error code, so check & see if we got back a html
        //  file when we were expecting a cab.
        if (fCheckForHTML)
        {
            hr = GetContentTypeHeader(sfns, hOpenRequest, &pszContentType);
            if (SUCCEEDED(hr) && pszContentType != NULL)
            {
                fCheckForHTML = FALSE;
                if (_tcsicmp(pszContentType, _T("text/html")) == 0)
                {
                    LOG_Internet(_T("WinInet: Content-Type header is text/html.  Bailing."));
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto CleanUp;
                }
                else
                {
                    LOG_Internet(_T("WinInet: Content-Type header is %s.  Continuing."), pszContentType);
                }
            }

            hr = NOERROR;
        }

        // open the file we're gonna spew into
        hFile = CreateFile(pszLocalFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
                           FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        
        LOG_Internet(_T("WinInet: downloading to FILE %s"), pszLocalFile);

        // bring down the bits
        hr = PerformDownloadToFile(sfns.pfnInternetReadFile, hOpenRequest, 
                                   hFile, cbRemoteFile,
                                   cbDownloadBuffer, 
                                   rghQuitEvents, cQuitEvents, 
                                   pfnCallback, pvCallbackData, &cbDownloaded);
        if (FAILED(hr))
        {
            LOG_Internet(_T("WinInet: Download failed: hr: 0x%08x"), hr);
            SafeCloseInvalidHandle(hFile);
            DeleteFile(pszLocalFile);
            goto CleanUp;
        }

        LOG_Internet(_T("WinInet: Download succeeded"));

        // set the file time to match the server file time since we just 
        //  downloaded it. If we don't do this the file time will be set 
        //  to the current system time.
        SetFileTime(hFile, &ft, NULL, NULL); 
        SafeCloseInvalidHandle(hFile);

        if (pdwDownloadedBytes != NULL)
            *pdwDownloadedBytes = cbRemoteFile;

        // sometimes, we can get fancy error pages back from the site instead of 
        //  a nice nifty HTML error code, so check & see if we got back a html
        //  file when we were expecting a cab.
        if (fCheckForHTML)
        {
            hr = IsFileHtml(pszLocalFile);
            if (SUCCEEDED(hr))
            {
                if (hr == S_FALSE)
                {
                    LOG_Internet(_T("WinInet: Download is not a html file"));
                    hr = S_OK;
                }
                else
                {
                    LOG_Internet(_T("WinInet: Download is a html file.  Failing download."));
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    SafeCloseInvalidHandle(hFile);
                    DeleteFile(pszLocalFile);
                    goto CleanUp;
                }
            }
            else
            {
                LOG_Internet(_T("WinInet: Unable to determine if download is a html file or not.  Failing download."));
            }
        }
        else
        {
            LOG_Internet(_T("WinInet: Skipping cab validation."));
        }
    }
    else
    {
        hr = S_OK;
        
        LOG_Internet(_T("WinInet: Server file is not newer.  Skipping download."));

        // The server ain't newer & the file is already on machine, so
        //  send progress callback indicating file downloadeded ok
        if (pfnCallback != NULL)
        {
            // fpnCallback(pCallbackData, DOWNLOAD_STATUS_FILECOMPLETE, dwFileSize, dwFileSize, NULL, NULL);
            pfnCallback(pvCallbackData, DOWNLOAD_STATUS_OK, cbRemoteFile, cbRemoteFile, NULL, NULL);
        }
    }

CleanUp:
 
    SafeInternetCloseHandle(sfns, hOpenRequest);
    SafeInternetCloseHandle(sfns, hConnect);
    SafeInternetCloseHandle(sfns, hInternet);

    SafeHeapFree(pszContentType);

    // if we failed, see if it's ok to continue (quit events) and whether
    //  we've tried enuf times yet.
    if (FAILED(hr) &&
        HandleEvents(rghQuitEvents, cQuitEvents) &&
        iRetryCounter >= 0 && iRetryCounter < c_cMaxRetries)
    {
        // in case of failure and have no enough retries yet, we retry
        // as long as not timeout yet
        DWORD dwElapsedTime;

        dwTickEnd = GetTickCount();
        if (dwTickEnd > dwTickStart)   
            dwElapsedTime = dwTickEnd - dwTickStart;
        else
            dwElapsedTime = (0xFFFFFFFF - dwTickStart) + dwTickEnd;

        // We haven't hit our retry limit, so log & error and go again
        if (dwElapsedTime < c_dwRetryTimeLimitInmsWiuInet)
        {
            LogError(hr, "Library download error. Will retry.");

            // in the case where we're gonna retry, keep track of the very first
            //  error we encoutered cuz the ops guys say that this is the most
            //  useful error to know about.
            if (iRetryCounter == 0)
            {
                LOG_Internet(_T("First download error saved: 0x%08x."), hr);
                hrToReturn = hr;
            }
            else
            {
                LOG_Internet(_T("Subsequent download error: 0x%08x."), hr);
            }
            hr = S_OK;
            goto START_INTERNET;
        }

        // We've completely timed out, so bail
        else
        {
            LogError(hr, "Library download error and timed out (%d ms). Will not retry.", dwElapsedTime);
        }
    }
    
    // make a callback indicating a download error
    if (FAILED(hr) && pfnCallback != NULL)
        pfnCallback(pvCallbackData, DOWNLOAD_STATUS_ERROR, cbRemoteFile, 0, NULL, NULL);

    // if we haven't saved off an error, just use the current error.  We can't
    //  have set hrToReturn previously if we didn't fail and want to attempt 
    //  a retry.
    // However, if we've got a success from this pass, be sure to return that 
    //  and not a fail code.
    if (FAILED(hr) && SUCCEEDED(hrToReturn))
        hrToReturn = hr;
    else if (SUCCEEDED(hr) && FAILED(hrToReturn))
        hrToReturn = hr;
    
    SafeHeapFree(pszServerName);
    SafeHeapFree(pszObject);

    return hrToReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\logging\freelog.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   FreeLog.cpp
//
//  Owner:  KenSh
//
//  Description:
//
//      Runtime logging for use in both checked and free builds.
//
//=======================================================================

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <malloc.h>
#include "FreeLog.h"
#include <MISTSAFE.h>

#ifndef _countof
#define _countof(ar) (sizeof(ar)/sizeof((ar)[0]))
#endif

// Unicode files start with the 2 bytes { FF FE }.
// This is the little-endian version of those 2 bytes.
#define UNICODE_FILE_HEADER 0xFEFF

#define MUTEX_TIMEOUT       1000    // Don't wait more than 1 second to write to logfile
#define MAX_MUTEX_WAITS     4       // Don't keep trying after this many failures

#define LOG_FILE_BIG_SIZE   50000   // Don't bother trimming if file is smaller than this
#define LOG_LINES_TRIM_FROM 1000    // Start trimming if more than this many lines
#define LOG_LINES_TRIM_TO   750     // Trim til the log file is this many lines

#define LOG_LEVEL_SUCCESS   0
#define LOG_LEVEL_FAILURE   1

#define MAX_MSG_LENGTH (MAX_PATH + 20)
#define MAX_ERROR_LENGTH 128

static const TCHAR c_szUnknownModuleName[] = _T("?");

// Local functions
void LogMessageExV(UINT nLevel, DWORD dwError, LPCSTR pszFormatA, va_list args);





//============================================================================
//
// Private CFreeLogging class to keep track of log file resources
//
//============================================================================

class CFreeLogging
{
public:
	CFreeLogging(LPCTSTR pszModuleName, LPCTSTR pszLogFileName);
	~CFreeLogging();

	void WriteLine(LPCTSTR pszText, UINT nLevel, DWORD dwError);

private:
	inline static HANDLE CreateMutex(LPCTSTR pszMutexName);
	inline HANDLE OpenLogFile(LPCTSTR pszFileName);
	inline void CloseLogFile();
	void TrimLogFile();

	BOOL AcquireMutex();
	void ReleaseMutex();

private:
	HANDLE m_hFile;
	HANDLE m_hMutex;
	int m_cLinesWritten;
	int m_cFailedWaits;
	LPTSTR m_pszModuleName;
};
CFreeLogging* g_pFreeLogging;

//============================================================================
//
// Public functions
//
//============================================================================

void InitFreeLogging(LPCTSTR pszModuleName, LPCTSTR pszLogFileName)
{
	if (g_pFreeLogging == NULL)
	{
		g_pFreeLogging = new CFreeLogging(pszModuleName, pszLogFileName);
	}
}

void TermFreeLogging()
{
	delete g_pFreeLogging;
	g_pFreeLogging = NULL;
}

void LogMessage(LPCSTR pszFormatA, ...)
{
	va_list arglist;
	va_start(arglist, pszFormatA);
	LogMessageExV(LOG_LEVEL_SUCCESS, 0, pszFormatA, arglist);
	va_end(arglist);
}

void LogError(DWORD dwError, LPCSTR pszFormatA, ...)
{
	va_list arglist;
	va_start(arglist, pszFormatA);
	LogMessageExV(LOG_LEVEL_FAILURE, dwError, pszFormatA, arglist);
	va_end(arglist);
}


void LogMessageExV(UINT nLevel, DWORD dwError, LPCSTR pszFormatA, va_list args)
{
	if (g_pFreeLogging != NULL)
	{
		char szBufA[MAX_MSG_LENGTH];
		
		size_t nRem=0;
		StringCchVPrintfExA(szBufA, _countof(szBufA), NULL, &nRem, MISTSAFE_STRING_FLAGS, pszFormatA, args);
		int cchA = _countof(szBufA) - nRem;

#ifdef UNICODE
		WCHAR szBufW[MAX_MSG_LENGTH];
		MultiByteToWideChar(CP_ACP, 0, szBufA, cchA+1, szBufW, _countof(szBufW));
		g_pFreeLogging->WriteLine(szBufW, nLevel, dwError);
#else
		g_pFreeLogging->WriteLine(szBufA, nLevel, dwError);
#endif
	}
}

//============================================================================
//
// CFreeLogging implementation
//
//============================================================================

CFreeLogging::CFreeLogging(LPCTSTR pszModuleName, LPCTSTR pszLogFileName)
	: m_cFailedWaits(0),
	  m_cLinesWritten(0)
{
	m_pszModuleName = _tcsdup(pszModuleName);
	if (m_pszModuleName == NULL)
		m_pszModuleName = (LPTSTR)c_szUnknownModuleName;

	m_hMutex = CreateMutex(pszLogFileName);
	m_hFile = OpenLogFile(pszLogFileName);
}

CFreeLogging::~CFreeLogging()
{
	CloseLogFile();
	if (m_hMutex != NULL)
		CloseHandle(m_hMutex);

	if (m_pszModuleName != c_szUnknownModuleName)
		free(m_pszModuleName);
}

inline HANDLE CFreeLogging::CreateMutex(LPCTSTR pszMutexName)
{
	// Create a mutex in the global namespace (works across TS sessions)
	HANDLE hMutex = ::CreateMutex(NULL, FALSE, pszMutexName);
	return hMutex;
}

inline HANDLE CFreeLogging::OpenLogFile(LPCTSTR pszLogFileName)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;

	TCHAR szPath[MAX_PATH+1];

	int cch = GetWindowsDirectory(szPath, _countof(szPath)-1);
		
	if(cch >0)
	{
		if (szPath[cch-1] != _T('\\'))
			szPath[cch++] = _T('\\');

		HRESULT hr = StringCchCopyEx(szPath + cch, _countof(szPath)-cch, pszLogFileName, NULL, NULL, MISTSAFE_STRING_FLAGS);

		if(FAILED(hr))
			return hFile;

		hFile = CreateFile(szPath, GENERIC_READ | GENERIC_WRITE, 
						FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
						OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	}


#ifdef UNICODE
	if (hFile != INVALID_HANDLE_VALUE)
	{
		if (AcquireMutex())
		{
			//
			// Check for the unicode header { FF FE }
			//
			WORD wHeader = 0;
			DWORD cbRead;
			(void)ReadFile(hFile, &wHeader, sizeof(wHeader), &cbRead, NULL);

			//
			// Write the header if there isn't one. This may be due to the
			// file being newly created, or to an ANSI-formatted file.
			//
			if (wHeader != UNICODE_FILE_HEADER)
			{
				SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

				DWORD cbWritten;
				wHeader = UNICODE_FILE_HEADER;
				WriteFile(hFile, &wHeader, sizeof(wHeader), &cbWritten, NULL);
				SetEndOfFile(hFile);
			}

			ReleaseMutex();
		}
	}
#endif

	return hFile;
}

inline void CFreeLogging::CloseLogFile()
{
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		// Trim old stuff from the log before closing the file
		TrimLogFile();

		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE; 
	}
}

BOOL CFreeLogging::AcquireMutex()
{
	// In rare case where mutex not created, we allow file operations
	// with no synchronization
	if (m_hMutex == NULL)
		return TRUE;

	// Don't keep waiting if we've been blocked in the past
	if (m_cFailedWaits >= MAX_MUTEX_WAITS)
		return FALSE;

	BOOL fResult = TRUE;
	if (WaitForSingleObject(m_hMutex, MUTEX_TIMEOUT) != WAIT_OBJECT_0)
	{
		fResult = FALSE;
		m_cFailedWaits++;
	}

	return fResult;
}

void CFreeLogging::ReleaseMutex()
{
	if (m_hMutex != NULL) // Note: AcquireMutex succeeds even if m_hMutex is NULL
	{
		::ReleaseMutex(m_hMutex);
	}
}

void CFreeLogging::WriteLine(LPCTSTR pszText, UINT nLevel, DWORD dwError)
{
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		DWORD cbText = lstrlen(pszText) * sizeof(TCHAR);

		if (AcquireMutex())
		{
			DWORD cbWritten;

			SetFilePointer(m_hFile, 0, NULL, FILE_END);

			//
			// Write time/date/module as a prefix
			//
			//     2001-05-03 13:49:01  21:49:01   CDM      Failed   Loading module (Error 0x00000005: Access is denied.)
			//
			// NOTE: ISO 8601 format for date/time. Local time first, then GMT.
			//
			TCHAR szPrefix[60];
			SYSTEMTIME sysTime, gmtTime;
			GetLocalTime(&sysTime);
			GetSystemTime(&gmtTime);
			LPCTSTR pszStatus = (nLevel == LOG_LEVEL_SUCCESS) ? _T("Success") : _T("Error  ");

			StringCchPrintfEx(szPrefix, _countof(szPrefix), NULL, NULL, MISTSAFE_STRING_FLAGS,
				_T("%04d-%02d-%02d %02d:%02d:%02d  %02d:%02d:%02d   %s   %-13s  "),
					sysTime.wYear, sysTime.wMonth, sysTime.wDay, 
					sysTime.wHour, sysTime.wMinute, sysTime.wSecond,
					gmtTime.wHour, gmtTime.wMinute, gmtTime.wSecond,
					pszStatus, m_pszModuleName);
			
			WriteFile(m_hFile, szPrefix, lstrlen(szPrefix) * sizeof(TCHAR), &cbWritten, NULL);

			//
			// Write the message followed by error info (if any) and a newline
			//
			WriteFile(m_hFile, pszText, cbText, &cbWritten, NULL);

			if (nLevel != LOG_LEVEL_SUCCESS)
			{
				TCHAR szError[MAX_ERROR_LENGTH];
				HRESULT hr=S_OK;
				size_t nRem=0;

				// nRem contains the remaining characters in the buffer including the null terminator
				// To get the number of characters written in to the buffer we use
				// int cchErrorPrefix = _countof(szError) - nRem;

				StringCchPrintfEx(szError, _countof(szError), NULL, &nRem, MISTSAFE_STRING_FLAGS, _T(" (Error 0x%08X: "), dwError);

				// Get the number of characters written in to the buffer
				int cchErrorPrefix = _countof(szError) - nRem;
				int cchErrorText = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0, 
												 szError + cchErrorPrefix, _countof(szError) - cchErrorPrefix - 1, NULL);
				int cchError = cchErrorPrefix + cchErrorText;
				cchError -= 2; // backup past ": " or "\r\n"

				StringCchCopyEx(szError + cchError, _countof(szError)-cchError, _T(")"), NULL, NULL, MISTSAFE_STRING_FLAGS);

				WriteFile(m_hFile, szError, (cchError + 1) * sizeof(TCHAR), &cbWritten, NULL);
			}

			WriteFile(m_hFile, _T("\r\n"), 2 * sizeof(TCHAR), &cbWritten, NULL);

			//
			// If we've written a ton of stuff, trim now rather than waiting
			// for the module to unload. (This check is only for how much this
			// module has written, not how big the log file itself is.)
			//
			if (++m_cLinesWritten > LOG_LINES_TRIM_FROM)
			{
				TrimLogFile();
				m_cLinesWritten = LOG_LINES_TRIM_TO;
			}

			ReleaseMutex();
		}
	}
}

// Checks the size of the log file, and trims it if necessary.
void CFreeLogging::TrimLogFile()
{
	if (AcquireMutex())
	{
		DWORD cbFile = GetFileSize(m_hFile, NULL);

		if (cbFile > LOG_FILE_BIG_SIZE)
		{
			DWORD cbFileNew = cbFile;

			//
			// Create a memory-mapped file so we can use memmove
			//
			HANDLE hMapping = CreateFileMapping(m_hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
			if (hMapping != NULL)
			{
				LPTSTR pszFileStart = (LPTSTR)MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0);
				if (pszFileStart != NULL)
				{
					LPTSTR pszEnd = (LPTSTR)((LPBYTE)pszFileStart + cbFile);

					LPTSTR pszTextStart = pszFileStart;
			#ifdef UNICODE
					pszTextStart++; // skip the 2-byte header
			#endif

					//
					// Count newlines
					//
					int cLines = 0;
					for (LPTSTR pch = pszTextStart; pch < pszEnd; )
					{
						if (*pch == _T('\n'))
							cLines++;

						// REVIEW: in Ansi builds should we call CharNextExA?
						//   If so, what code page is the log file in?
						pch++;
					}

					if (cLines > LOG_LINES_TRIM_FROM)
					{
						int cTrimLines = cLines - LOG_LINES_TRIM_TO;
						for (pch = pszTextStart; pch < pszEnd; )
						{
							if (*pch == _T('\n'))
								cTrimLines--;

							// REVIEW: in Ansi builds should we call CharNextExA?
							//   If so, what code page is the log file in?
							pch++;

							if (cTrimLines <= 0)
								break;
						}

						// Move more recent data to beginning of file
						int cchMove = (int)(pszEnd - pch);
						memmove(pszTextStart, pch, cchMove * sizeof(TCHAR));
						cbFileNew = (cchMove * sizeof(TCHAR));

			#ifdef UNICODE
						cbFileNew += sizeof(WORD);
			#endif
					}
					UnmapViewOfFile(pszFileStart);
				}
				CloseHandle(hMapping);

				if (cbFileNew != cbFile)
				{
					// Truncate the file, now that we've moved data as needed
					SetFilePointer(m_hFile, cbFileNew, NULL, FILE_BEGIN);
					SetEndOfFile(m_hFile);
				}
			}
		}

		ReleaseMutex();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\schemamisc\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	schema
#
# Abstract:		schema and xml utility functions used by IU and AU
#
MAJORCOMP=windows.com
MINORCOMP=lib.schemamisc

TARGETNAME=schemamisc
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

INCLUDES= $(INCLUDES);$(WINDOWS_COM)\inc

SOURCES= schemamisc.CPP \
	 schemakeys.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\logging\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	util
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.Logging

TARGETNAME=Logging
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc
TARGETLIBS= $(IU_UTIL_LIB_DIR)\*\util.lib

SOURCES= \
	..\IULogger.cpp  \
	..\FreeLog.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\testkeys\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	WUTestKeys
#
# Abstract:		Verify if test keys should be allowed or not
#
MAJORCOMP=windows.com
MINORCOMP=lib.WUTestKeys

TARGETNAME=WUTestKeys
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\WUTestKeys.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\schemamisc\schemakeys.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   SchemaKeys.cpp
//
//	Author:	Charles Ma
//			2000.12.4
//
//  Description:
//
//      implementation of CSchemaKeys class
//
//=======================================================================

//#include <iuengine.h>
#include "schemakeys.h"

const TCHAR	CKEY_REGKEYEXISTS[]	= _T("regKeyExists");
const TCHAR	CKEY_REGKEYVALUE[]		= _T("regKeyValue");
const TCHAR	CKEY_REGKEYSUBSTR[]	= _T("regKeySubstring");
const TCHAR	CKEY_REGKEYVERSION[]	= _T("regKeyVersion");
const TCHAR	CKEY_FILEVERSION[]		= _T("fileVersion");
const TCHAR	CKEY_FILEEXISTS[]		= _T("fileExists");
const TCHAR	CKEY_AND[]				= _T("and");
const TCHAR	CKEY_OR[] 				= _T("or");
const TCHAR	CKEY_NOT[] 				= _T("not");


// ---------------------------------------------------------------------
//
// constructor
//
// ---------------------------------------------------------------------

CSchemaKeys::CSchemaKeys()
{
	//
	// create these BSTRs
	//
	SCHEMA_KEY_XML_NAMESPACE	= SysAllocString(L"xmlns");
	SCHEMA_KEY_XML				= SysAllocString(L"xml");
	SCHEMA_KEY_SYSTEMINFO		= SysAllocString(L"systemInfo");
	SCHEMA_KEY_COMPUTERSYSTEM	= SysAllocString(L"computerSystem");
	SCHEMA_KEY_MANUFACTURER		= SysAllocString(L"manufacturer");
	SCHEMA_KEY_MODEL			= SysAllocString(L"model");
	SCHEMA_KEY_SUPPORTSITE		= SysAllocString(L"supportSite");
	SCHEMA_KEY_ADMINISTRATOR	= SysAllocString(L"administrator");
	SCHEMA_KEY_WU_DISABLED		= SysAllocString(L"windowsUpdateDisabled");
	SCHEMA_KEY_AU_ENABLED		= SysAllocString(L"autoUpdateEnabled");
	SCHEMA_KEY_DRIVESPACE		= SysAllocString(L"driveSpace");
	SCHEMA_KEY_DRIVE			= SysAllocString(L"drive");
	SCHEMA_KEY_KBYTES			= SysAllocString(L"kbytes");
	SCHEMA_KEY_REGKEYS			= SysAllocString(L"regKeys");
	SCHEMA_KEY_REG_HKLM			= SysAllocString(L"HKEY_LOCAL_MACHINE");
	SCHEMA_KEY_REG_SW			= SysAllocString(L"SOFTWARE");

	SCHEMA_KEY_NAME				= SysAllocString(L"name");			
	SCHEMA_KEY_COMSERVER		= SysAllocString(L"comserverID");	
	SCHEMA_KEY_KEY				= SysAllocString(L"key");			
	SCHEMA_KEY_ENTRY			= SysAllocString(L"entry");
	SCHEMA_KEY_VALUE			= SysAllocString(L"value");
	SCHEMA_KEY_VERSION			= SysAllocString(L"version");
	SCHEMA_KEY_VERSIONSTATUS	= SysAllocString(L"versionStatus");
	SCHEMA_KEY_FILEPATH			= SysAllocString(L"filePath");
	SCHEMA_KEY_TIMESTAMP		= SysAllocString(L"timestamp");
	SCHEMA_KEY_GUID				= SysAllocString(L"guid");

	SCHEMA_KEY_CATALOG_PROVIDER	= SysAllocString(L"catalog/provider");
	SCHEMA_KEY_ITEMS			= SysAllocString(L"items");
	SCHEMA_KEY_ITEM_SEARCH		= SysAllocString(L"catalog/provider/item");
	SCHEMA_KEY_ITEM				= SysAllocString(L"item");
	SCHEMA_KEY_ITEM_ITEMSTATUS	= SysAllocString(L"items/itemStatus");
	SCHEMA_KEY_ITEMSTATUS		= SysAllocString(L"itemStatus");
	SCHEMA_KEY_DETECTION		= SysAllocString(L"detection");
    SCHEMA_KEY_INSTALLATION     = SysAllocString(L"installation");
    SCHEMA_KEY_INSTALLSTATUS    = SysAllocString(L"installStatus");
	SCHEMA_KEY_INSTALLERTYPE    = SysAllocString(L"installerType");
	SCHEMA_KEY_EXCLUSIVE		= SysAllocString(L"exclusive");
	SCHEMA_KEY_NEEDSREBOOT		= SysAllocString(L"needsReboot");
	SCHEMA_KEY_COMMAND			= SysAllocString(L"command");
	SCHEMA_KEY_SWITCHES			= SysAllocString(L"switches");
	SCHEMA_KEY_COMMANDTYPE		= SysAllocString(L"commandType");
	SCHEMA_KEY_INFINSTALL		= SysAllocString(L"infInstallSection");
	SCHEMA_KEY_CODEBASE			= SysAllocString(L"codeBase");
	SCHEMA_KEY_CRC				= SysAllocString(L"crc");
	SCHEMA_KEY_PATCHAVAILABLE	= SysAllocString(L"patchAvailable");
	SCHEMA_KEY_SIZE				= SysAllocString(L"size");
	SCHEMA_KEY_DOWNLOADPATH		= SysAllocString(L"downloadPath");
	SCHEMA_KEY_DOWNLOADSTATUS	= SysAllocString(L"downloadStatus");
    SCHEMA_KEY_DEPENDENCIES     = SysAllocString(L"dependencies");
    SCHEMA_KEY_DESCRIPTION      = SysAllocString(L"description");
	SCHEMA_KEY_HREF				= SysAllocString(L"href");
	SCHEMA_KEY_LANGUAGE			= SysAllocString(L"language");
	SCHEMA_KEY_PLATFORM			= SysAllocString(L"platform");
	SCHEMA_KEY_PROCESSORARCHITECTURE = SysAllocString(L"processorArchitecture");
	SCHEMA_KEY_SUITE			= SysAllocString(L"suite");
	SCHEMA_KEY_PRODUCTTYPE		= SysAllocString(L"productType");
	SCHEMA_KEY_LOCALE			= SysAllocString(L"locale");
	SCHEMA_KEY_CONTEXT			= SysAllocString(L"context");
	SCHEMA_KEY_MAJOR			= SysAllocString(L"major");
	SCHEMA_KEY_MINOR			= SysAllocString(L"minor");
	SCHEMA_KEY_BUILD			= SysAllocString(L"build");
	SCHEMA_KEY_SERVICEPACKMAJOR	= SysAllocString(L"servicePackMajor");
	SCHEMA_KEY_SERVICEPACKMINOR	= SysAllocString(L"servicePackMinor");
    SCHEMA_KEY_COMPATIBLEHARDWARE = SysAllocString(L"compatibleHardware");
    SCHEMA_KEY_DEVICES           = SysAllocString(L"devices");
    SCHEMA_KEY_DEVICE           = SysAllocString(L"device");
    SCHEMA_KEY_PRINTERINFO      = SysAllocString(L"printerInfo");
    SCHEMA_KEY_CDM_PINFO		= SysAllocString(L"device/printerInfo");
    SCHEMA_KEY_DRIVERNAME       = SysAllocString(L"driverName");
    SCHEMA_KEY_HWID             = SysAllocString(L"hwid");
    SCHEMA_KEY_CDM_HWIDPATH     = SysAllocString(L"device/hwid");
    SCHEMA_KEY_DESCRIPTIONTEXT  = SysAllocString(L"descriptionText");
    SCHEMA_KEY_TITLE            = SysAllocString(L"title");
	SCHEMA_KEY_ITEMID           = SysAllocString(L"itemID");
	SCHEMA_KEY_HIDDEN           = SysAllocString(L"hidden");
    SCHEMA_KEY_ISPRINTER        = SysAllocString(L"isPrinter");
    SCHEMA_KEY_DEVICEINSTANCE   = SysAllocString(L"deviceInstance");
    SCHEMA_KEY_DRIVERPROVIDER	= SysAllocString(L"driverProvider");
    SCHEMA_KEY_MFGNAME			= SysAllocString(L"mfgName");
	SCHEMA_KEY_DRIVERVER		= SysAllocString(L"driverVer");
	SCHEMA_KEY_RANK				= SysAllocString(L"rank");
	SCHEMA_KEY_READMORE			= SysAllocString(L"description/descriptionText/details");
	SCHEMA_KEY_ERRORCODE		= SysAllocString(L"errorCode");

    SCHEMA_KEY_CATALOGSTATUS    = SysAllocString(L"catalogStatus");
    SCHEMA_KEY_PID              = SysAllocString(L"pid");

	SCHEMA_KEY_DETECTRESULT		= SysAllocString(L"detectResult");
	SCHEMA_KEY_INSTALLED		= SysAllocString(L"installed");
	SCHEMA_KEY_UPTODATE			= SysAllocString(L"upToDate");
	SCHEMA_KEY_NEWERVERSION		= SysAllocString(L"newerVersion");
	SCHEMA_KEY_EXCLUDED			= SysAllocString(L"excluded");
	SCHEMA_KEY_FORCE			= SysAllocString(L"force");

	SCHEMA_KEY_VERSTATUS_HI		= SysAllocString(L"HIGHER");
	SCHEMA_KEY_VERSTATUS_HE		= SysAllocString(L"HIGHER_OR_SAME");
	SCHEMA_KEY_VERSTATUS_EQ		= SysAllocString(L"SAME");
	SCHEMA_KEY_VERSTATUS_LE		= SysAllocString(L"LOWER_OR_SAME");
	SCHEMA_KEY_VERSTATUS_LO		= SysAllocString(L"LOWER");

	SCHEMA_KEY_IDENTITY			= SysAllocString(L"identity");
	SCHEMA_KEY_PUBLISHERNAME	= SysAllocString(L"publisherName");
	SCHEMA_KEY_FILE				= SysAllocString(L"path");
	SCHEMA_KEY_REGKEY			= SysAllocString(L"regKey");
	SCHEMA_KEY_PATH				= SysAllocString(L"path");
	SCHEMA_KEY_STATUS_COMPLETE	= SysAllocString(L"COMPLETE");
	SCHEMA_KEY_STATUS_FAILED	= SysAllocString(L"FAILED");

	SCHEMA_KEY_CLIENT			= SysAllocString(L"client");
	SCHEMA_KEY_CLIENTINFO		= SysAllocString(L"clientInfo");
	SCHEMA_KEY_CLIENTNAME		= SysAllocString(L"clientName");

	SCHEMA_KEY_REGKEYEXISTS		= CKEY_REGKEYEXISTS		;	
	SCHEMA_KEY_REGKEYVALUE		= CKEY_REGKEYVALUE		;
	SCHEMA_KEY_REGKEYSUBSTR		= CKEY_REGKEYSUBSTR		;
	SCHEMA_KEY_REGKEYVERSION	= CKEY_REGKEYVERSION	;	
	SCHEMA_KEY_FILEVERSION		= CKEY_FILEVERSION		;
	SCHEMA_KEY_FILEEXISTS		= CKEY_FILEEXISTS		;	
	SCHEMA_KEY_AND				= CKEY_AND				;
	SCHEMA_KEY_OR 				= CKEY_OR 				;
	SCHEMA_KEY_NOT	 			= CKEY_NOT	 			;


}




// ---------------------------------------------------------------------
//
// destructor
//
// ---------------------------------------------------------------------

CSchemaKeys::~CSchemaKeys()
{
	//
	// release BSTRs
	//
	SysFreeString(SCHEMA_KEY_XML_NAMESPACE);
	SysFreeString(SCHEMA_KEY_XML);
	SysFreeString(SCHEMA_KEY_SYSTEMINFO);
	SysFreeString(SCHEMA_KEY_COMPUTERSYSTEM);
	SysFreeString(SCHEMA_KEY_MANUFACTURER);
	SysFreeString(SCHEMA_KEY_MODEL);
	SysFreeString(SCHEMA_KEY_SUPPORTSITE);
	SysFreeString(SCHEMA_KEY_ADMINISTRATOR);
	SysFreeString(SCHEMA_KEY_WU_DISABLED);
	SysFreeString(SCHEMA_KEY_AU_ENABLED);
	SysFreeString(SCHEMA_KEY_DRIVESPACE);
	SysFreeString(SCHEMA_KEY_DRIVE);
	SysFreeString(SCHEMA_KEY_KBYTES);
	SysFreeString(SCHEMA_KEY_REGKEYS);
	SysFreeString(SCHEMA_KEY_REG_HKLM);
	SysFreeString(SCHEMA_KEY_REG_SW);

	SysFreeString(SCHEMA_KEY_NAME);
	SysFreeString(SCHEMA_KEY_COMSERVER);
	SysFreeString(SCHEMA_KEY_KEY);
	SysFreeString(SCHEMA_KEY_ENTRY);
	SysFreeString(SCHEMA_KEY_VALUE);
	SysFreeString(SCHEMA_KEY_VERSION);
	SysFreeString(SCHEMA_KEY_VERSIONSTATUS);
	SysFreeString(SCHEMA_KEY_FILEPATH);
	SysFreeString(SCHEMA_KEY_TIMESTAMP);
	SysFreeString(SCHEMA_KEY_GUID);

	SysFreeString(SCHEMA_KEY_CATALOG_PROVIDER);
	SysFreeString(SCHEMA_KEY_ITEMS);
	SysFreeString(SCHEMA_KEY_ITEM_SEARCH);
	SysFreeString(SCHEMA_KEY_ITEM);
	SysFreeString(SCHEMA_KEY_ITEM_ITEMSTATUS);
	SysFreeString(SCHEMA_KEY_ITEMSTATUS);
	SysFreeString(SCHEMA_KEY_DETECTION);
    SysFreeString(SCHEMA_KEY_INSTALLATION);
    SysFreeString(SCHEMA_KEY_INSTALLSTATUS);
    SysFreeString(SCHEMA_KEY_INSTALLERTYPE);
    SysFreeString(SCHEMA_KEY_EXCLUSIVE);
    SysFreeString(SCHEMA_KEY_NEEDSREBOOT);
    SysFreeString(SCHEMA_KEY_COMMAND);
    SysFreeString(SCHEMA_KEY_SWITCHES);
    SysFreeString(SCHEMA_KEY_COMMANDTYPE);
    SysFreeString(SCHEMA_KEY_INFINSTALL);
	SysFreeString(SCHEMA_KEY_CODEBASE);
	SysFreeString(SCHEMA_KEY_CRC);
	SysFreeString(SCHEMA_KEY_PATCHAVAILABLE);
	SysFreeString(SCHEMA_KEY_SIZE);
	SysFreeString(SCHEMA_KEY_DOWNLOADPATH);
	SysFreeString(SCHEMA_KEY_DOWNLOADSTATUS);
    SysFreeString(SCHEMA_KEY_DEPENDENCIES);
    SysFreeString(SCHEMA_KEY_DESCRIPTION);
	SysFreeString(SCHEMA_KEY_HREF);
	SysFreeString(SCHEMA_KEY_LANGUAGE);
	SysFreeString(SCHEMA_KEY_PLATFORM);
	SysFreeString(SCHEMA_KEY_PROCESSORARCHITECTURE);
	SysFreeString(SCHEMA_KEY_SUITE);
	SysFreeString(SCHEMA_KEY_PRODUCTTYPE);
	SysFreeString(SCHEMA_KEY_LOCALE);
	SysFreeString(SCHEMA_KEY_CONTEXT);
	SysFreeString(SCHEMA_KEY_MAJOR);
	SysFreeString(SCHEMA_KEY_MINOR);
	SysFreeString(SCHEMA_KEY_BUILD);
	SysFreeString(SCHEMA_KEY_SERVICEPACKMAJOR);
	SysFreeString(SCHEMA_KEY_SERVICEPACKMINOR);
    SysFreeString(SCHEMA_KEY_COMPATIBLEHARDWARE);
    SysFreeString(SCHEMA_KEY_DEVICES);
    SysFreeString(SCHEMA_KEY_DEVICE);
    SysFreeString(SCHEMA_KEY_PRINTERINFO);
    SysFreeString(SCHEMA_KEY_CDM_PINFO);
	SysFreeString(SCHEMA_KEY_DRIVERNAME);
	SysFreeString(SCHEMA_KEY_HWID);
    SysFreeString(SCHEMA_KEY_CDM_HWIDPATH);
    SysFreeString(SCHEMA_KEY_DESCRIPTIONTEXT);
    SysFreeString(SCHEMA_KEY_TITLE);
    SysFreeString(SCHEMA_KEY_ITEMID);
    SysFreeString(SCHEMA_KEY_HIDDEN);
    SysFreeString(SCHEMA_KEY_ISPRINTER);
    SysFreeString(SCHEMA_KEY_DEVICEINSTANCE);
    SysFreeString(SCHEMA_KEY_DRIVERPROVIDER);
    SysFreeString(SCHEMA_KEY_MFGNAME);
    SysFreeString(SCHEMA_KEY_DRIVERVER);
    SysFreeString(SCHEMA_KEY_RANK);
    SysFreeString(SCHEMA_KEY_READMORE);
    SysFreeString(SCHEMA_KEY_ERRORCODE);
    
    SysFreeString(SCHEMA_KEY_CATALOGSTATUS);
    SysFreeString(SCHEMA_KEY_PID);

	SysFreeString(SCHEMA_KEY_DETECTRESULT);
	SysFreeString(SCHEMA_KEY_INSTALLED);
	SysFreeString(SCHEMA_KEY_UPTODATE);
	SysFreeString(SCHEMA_KEY_NEWERVERSION);
	SysFreeString(SCHEMA_KEY_EXCLUDED);
	SysFreeString(SCHEMA_KEY_FORCE);

	SysFreeString(SCHEMA_KEY_VERSTATUS_HI);
	SysFreeString(SCHEMA_KEY_VERSTATUS_HE);
	SysFreeString(SCHEMA_KEY_VERSTATUS_EQ);
	SysFreeString(SCHEMA_KEY_VERSTATUS_LE);
	SysFreeString(SCHEMA_KEY_VERSTATUS_LO);

	SysFreeString(SCHEMA_KEY_CLIENT);
	SysFreeString(SCHEMA_KEY_CLIENTINFO);
	SysFreeString(SCHEMA_KEY_CLIENTNAME);

	SysFreeString(SCHEMA_KEY_IDENTITY);
	SysFreeString(SCHEMA_KEY_PUBLISHERNAME);
	SysFreeString(SCHEMA_KEY_FILE);
	SysFreeString(SCHEMA_KEY_REGKEY);
	SysFreeString(SCHEMA_KEY_PATH);
	SysFreeString(SCHEMA_KEY_STATUS_COMPLETE);
	SysFreeString(SCHEMA_KEY_STATUS_FAILED);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\logging\iulogger.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   IULogger.cpp: implementation of the CIULogger class.
//
//  Description:
//
//      See IULogger.h
//
//=======================================================================

#if defined(DBG)

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <MemUtil.h>

#include <fileutil.h>
#include <Logging.h>
#include <strsafe.h>


//
// declare constants used to control log exclusions
//
const DWORD    LOG_BLOCK                = 0x00000001;    // log function/block in/out
const DWORD LOG_XML_DETAIL            = 0x00000002;    // log detailed XML operation
const DWORD LOG_INTERNET            = 0x00000004;    // log action related to Internet activities, e.g., downld
const DWORD LOG_SOFTWARE            = 0x00000008;    // log details about software detection/installation
const DWORD LOG_DRIVER                = 0x00000010;    // log actions related to driver detection/installation
const DWORD LOG_TRUST                = 0x00000020;    // log actions related to wintrust checking
const DWORD    LOG_DOWNLOAD            = 0x00000040;    // log actions related to download
const DWORD LOG_XML_BSTR_DETAIL        = 0x00000080;    // log XML BSTRs
const DWORD LOG_ERROR                = 0x00008000;    // you can not exclude this type of logs from output
const DWORD LOG_ALL                    = 0xFFFFFFFF;    // default, all above

//
// const for longest line of XML we will output
//
const DWORD LOG_XML_BUFF_LEN        = 128;

//
// const for specifying the intent array size increament.
// each element in array holds indent data for one thread
//
const int c_IndentArrayChunk = 16;

//
// define the log header format
//
// It is constructed as: <date> <time> <thread id>
//
const TCHAR szLogHeaderFmt[]        = _T("yyyy/mm/dd hh:nn:ss:sss xxxxxxxx  ");

//
// initialization of static members
//

int                CIULogger::m_Size            = 0;
int                CIULogger::m_siIndentStep    = 0;    // init to use tab char
CIULogger::_THREAD_INDENT* CIULogger::m_psIndent = NULL;

DWORD            CIULogger::m_sdwLogMask        = LOG_ALL;
HANDLE            CIULogger::m_shFile            = INVALID_HANDLE_VALUE;
bool            CIULogger::m_fLogDebugMsg    = false;
bool            CIULogger::m_fLogFile        = false;
bool            CIULogger::m_fLogUsable        = false;
HANDLE            CIULogger::m_hMutex            = NULL;
int                CIULogger::m_cFailedWaits    = 0;
int                CIULogger::m_fFlushEveryTime = FALSE;

//
// Defines for Mutex (borrowed from freelog)
//
// NOTE: globals and statics are per-module (e.g. iuctl, iuengine), but Mutex is per-processes
// due to the name being constructed from the log file name (contains process ID).
//
#define MUTEX_TIMEOUT       1000    // Don't wait more than 1 second to write to logfile
#define MAX_MUTEX_WAITS     4       // Don't keep trying after this many failures

//
// global variable
//

//
// reference count to control log file open/close
//
LONG g_RefCount = 0;

//
// critical sectoin handling multi-threading
// access of indent array case
//
//
CRITICAL_SECTION g_LogCs;



//
// we need to declare a global object so refcount wont't
// be zero, otherwise in multi-threading mode ref count
// can be fooled and AV when one object thinks m_psIdent not NULL
// but another object in another (parent) thread freed m_psIndent
// in destructor (only if parent thread quits)
//
CIULogger g_DummyLogObj(NULL);


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CIULogger::CIULogger(char* szBlockName)
: m_Index(-1), m_LineNum(0)
{
    if (0 == g_RefCount)
    {
        //
        // This must be the g_DummyLogObj (or another global
        // instance) during initialization of globals. Since
        // this is the first instance created, we must init CS
        //
        InitializeCriticalSection(&g_LogCs);
    }

    //
    // Protect the statics while in the ctor
    //
    EnterCriticalSection(&g_LogCs);

    m_dwTickBegin    = GetTickCount();
    m_dwThreadId    = GetCurrentThreadId();
    m_fProcessLog    = (NULL == szBlockName);
    ZeroMemory(m_szBlockName, sizeof(m_szBlockName)); 

    g_RefCount++;

    if (1 == g_RefCount)
    {
        //
        // this is the first time to call this class, we need to 
        // find out whether we should log and where to log to
        //

        ReadRegistrySettings();

        //
        // allocate memory for thread indent array initially
        //
        SetIndent(0);

        //
        // if the indent level is not negative, then it's okay to log
        //
        m_fLogFile = (INVALID_HANDLE_VALUE != m_shFile);
        m_fLogUsable = (m_fLogFile || m_fLogDebugMsg) && (NULL != m_psIndent);
    }


    if (m_fLogUsable)
    {
        if (!m_fProcessLog)
        {
            //
            // this is probably a new thread, so we need to find the index
            // for this thread.
            //
            SetIndent(0);

            //
            // do block logging, if permitted
            //
            if (0x0 != (m_sdwLogMask & LOG_BLOCK) && szBlockName && _T('\0') != szBlockName[0]) 
            {
                StringCchCopyA(m_szBlockName, ARRAYSIZE(m_szBlockName), szBlockName);
                USES_IU_CONVERSION;
                
                char szOut[sizeof(m_szBlockName) + 10];
                //
                // Implicit "Enter " before block name to save log space
                //
                if (SUCCEEDED(StringCchPrintfA(szOut, ARRAYSIZE(szOut), "%hs\r\n", szBlockName)))
                {
                    _LogOut(A2T(szOut));
                }
            }
            SetIndent(+1);
        }

    }
    LeaveCriticalSection(&g_LogCs);
}



CIULogger::~CIULogger()
{
    EnterCriticalSection(&g_LogCs);

    if (m_fLogUsable)
    {
        //
        // decrease the indent level by 1 if we increased indent
        //
        if (!m_fProcessLog)
        {
            SetIndent(-1);
        }

        //
        // write log file for exiting block, if allowed and block name exists
        //
        if (0x0 != (m_sdwLogMask & LOG_BLOCK) && _T('\0') != m_szBlockName[0]) 
        {
            USES_IU_CONVERSION; 
            char szOut[1024];
            //
            // "Exit " shortened to "~" to save log space
            //
            if (SUCCEEDED(StringCchPrintfA(szOut, ARRAYSIZE(szOut), "~%hs, %d msec\r\n", m_szBlockName, GetTickCount() - m_dwTickBegin)))
            {
                _LogOut(A2T(szOut));
            }
        }
    }

    //
    // reduce reference cnt
    //
    g_RefCount--;

    //
    // g_RefCount will go to zero before leaving dtor if this is the last global instance
    // in this module
    //
    if (0 == g_RefCount)
    {
        //
        // close file if the file is open
        //
        if (m_fLogFile && INVALID_HANDLE_VALUE != m_shFile)    // redundent?
        {
            CloseHandle(m_shFile);
            m_shFile = INVALID_HANDLE_VALUE;
        }
        if(NULL != m_hMutex)
        {
            CloseHandle(m_hMutex);
        }
        //
        // free memory of indent array
        //
        if (NULL != m_psIndent)
        {
            HeapFree(GetProcessHeap(), 0, m_psIndent);
            m_psIndent = NULL;
        }
    }

    LeaveCriticalSection(&g_LogCs);

    //
    // This is the last global instance (probably g_DummyLogObj) and is
    // being destructed before the DLL unloads
    //
    if (0 == g_RefCount)
    {
        DeleteCriticalSection(&g_LogCs);
    }
}

//
// Mutex stuff borrowed from freelog
// fixcode: This should not be required here since chk logging is per process only
BOOL CIULogger::AcquireMutex()
{
    // In rare case where mutex not created, we allow file operations
    // with no synchronization
    if (m_hMutex == NULL)
        return TRUE;

    // Don't keep waiting if we've been blocked in the past
    if (m_cFailedWaits >= MAX_MUTEX_WAITS)
        return FALSE;

    BOOL fResult = TRUE;
    if (WaitForSingleObject(m_hMutex, MUTEX_TIMEOUT) != WAIT_OBJECT_0)
    {
        fResult = FALSE;
        m_cFailedWaits++;
    }

    return fResult;
}

void CIULogger::ReleaseMutex()
{
    if (m_hMutex != NULL) // Note: AcquireMutex succeeds even if m_hMutex is NULL
    {
        ::ReleaseMutex(m_hMutex);
    }
}

////////////////////////////////////////////////////////////////////////
//
// log with no flag, so can not be removed by excluding directives
//
////////////////////////////////////////////////////////////////////////
void CIULogger::Log(LPCTSTR szLogFormat, ...)
{

    if (m_fLogUsable) 
    {
        USES_IU_CONVERSION;
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_ALL, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// log error, so can not be removed by excluding directives
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogError(LPCTSTR szLogFormat, ...)
{

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_ERROR, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// Helper for LogErrorMsg and LogInfoMsg (which supply message to prepend)
//
////////////////////////////////////////////////////////////////////////
void CIULogger::_LogFormattedMsg(DWORD dwErrCode, LPCTSTR pszErrorInfo)
{
    if (m_fLogUsable)
    {
        //
        // try to retrive system msg
        //
        LPTSTR lpszBuffer = NULL, lpszLogMsg = NULL;
        LPVOID lpMsg = NULL;
        FormatMessage(
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL,    // no source, use system msg
                      dwErrCode,
                      MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                      (LPTSTR)&lpMsg,
                      0,
                      NULL);
        if (NULL == lpMsg)
        {
            //
            // if we failed to get the msg, then output generic 
            // error/info log
            //
            LogError(_T("Unknown %s Line %d: 0x%08x\n"), pszErrorInfo, m_LineNum, dwErrCode);
        }
        else
        {
            lpszBuffer = (LPTSTR) lpMsg;
            int nLen = lstrlen(lpszBuffer);
            lpszLogMsg = (LPTSTR) LocalAlloc(0, (nLen + 128) * sizeof(TCHAR));
            if (NULL != lpszLogMsg)
            {
                //
                // insert Error/Info keyword
                //
                if (FAILED(StringCchPrintf(lpszLogMsg, ARRAYSIZE(lpszLogMsg), _T("%s Line %d: 0x%08x: %s"), pszErrorInfo, m_LineNum, dwErrCode, lpszBuffer)))
                {
                    // Couldn't build the right string, so just output the system msg
                    LocalFree(lpszLogMsg);
                    lpszLogMsg = lpszBuffer;
                }
            }
            else
            {
                //
                // failed to get buffer? unlikely, anyway, 
                // we have no option but just output the system msg
                //
                lpszLogMsg = lpszBuffer;
            }

            //
            // write log out
            //
            _LogOut(lpszLogMsg);

            //
            // clean up buffer
            //
            if (lpszLogMsg != lpszBuffer)
            {
                LocalFree(lpszLogMsg);
            }
            LocalFree(lpszBuffer);
        }

    }
}

////////////////////////////////////////////////////////////////////////
//
// similar to LogError, but try to log the system msg based
// on the error code. If the sysmsg not avail, log 
//    "Unknown error with error code 0x%08x"
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogErrorMsg(DWORD dwErrCode)
{
    _LogFormattedMsg(dwErrCode, _T("Error"));
}

////////////////////////////////////////////////////////////////////////
//
// similar to LogErrorMsg but prepends with "Info" rather than "Error"
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogInfoMsg(DWORD dwErrCode)
{
    _LogFormattedMsg(dwErrCode, _T("Info"));
}


////////////////////////////////////////////////////////////////////////
//
// log with type INTERNET, this function will do nothing
// if the Internet exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogInternet(LPCTSTR szLogFormat, ...)
{

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_INTERNET, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// log with type XML, this function will do nothing
// if the XML exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogXML(LPCTSTR szLogFormat, ...)
{

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_XML_DETAIL, szLogFormat, va);
        va_end (va);
    }
}

void CIULogger::_NukeCrLf(LPTSTR pszBuffer)
{
    while (*pszBuffer)
    {
        if (_T('\r') == *pszBuffer || _T('\n') == *pszBuffer)
        {
            //
            // Overwrite <CR> and <LF> with space
            //
            *pszBuffer = _T(' ');
        }
        pszBuffer++;
    }
}

////////////////////////////////////////////////////////////////////////
//
// log BSTR containing valid XML. This gets around length limitations
// of LogOutput and attempts to break lines following ">". This
// output is sent for both fre and chk builds unless excluded from reg.
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogXmlBSTR(BSTR bstrXML)
{
    USES_IU_CONVERSION;

    LPTSTR pszLine;
    LPTSTR pszTemp;
    LPTSTR pszStop;
    LPTSTR pszLastGT;
    TCHAR  szXmlBuff[LOG_XML_BUFF_LEN];
	HRESULT hr;
    
    if (NULL == bstrXML)
    {
        return;
    }

    if (m_fLogUsable && (m_sdwLogMask & LOG_XML_BSTR_DETAIL) )
    {
#if !(defined(UNICODE) || defined(_UNICODE))
        DWORD dwANSIBuffLen = SysStringLen(bstrXML) + 1;
        LPSTR pszANSIBuff = (LPSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwANSIBuffLen);

        if (NULL == pszANSIBuff)
        {
            //
            // We're toast - just return without logging
            //
            return;
        }
        LPTSTR pTempTchar = OLE2T(bstrXML);
        if (NULL != pTempTchar)
        {
            if (FAILED(StringCchCopyA(pszANSIBuff, dwANSIBuffLen, pTempTchar)))
            {
                goto done;
            }
        }
        pszLine = pszANSIBuff;
#else
        pszLine = bstrXML;
#endif

        while (*pszLine)
        {
            //
            // Skip <CR> & <LF> chars
            //
            while (_T('\r') == *pszLine || _T('\n') == *pszLine)
            {
                pszLine++;
                if (NULL == *pszLine)
                {
                    break;
                }
            }
            if (NULL == *pszLine)
            {
                break;
            }

            pszTemp = pszLine;
            pszStop = pszLine + LOG_XML_BUFF_LEN - 1;
            pszLastGT = NULL;

            //
            // Try to find the last '>' char that will fit in buffer
            //
            while (*pszTemp && pszTemp < pszStop)
            {
                if (_T('>') == *pszTemp)
                {
                    pszLastGT = pszTemp;
                }
                pszTemp++;
            }

            if (pszLastGT)
            {
                //
                // Break the line at the last '>' that fits into LOG_XML_BUFF_LEN
                //
				hr = StringCchCopy(szXmlBuff, (int) (pszLastGT - pszLine) + 2, pszLine);
				//
				// STRSAFE_E_INSUFFICIENT_BUFFER is returned if the string is truncated.
				// This is normal since we are just copying a portion of the XML at
				// a time so it won't be too long to log.
				//
                if (SUCCEEDED(hr) || STRSAFE_E_INSUFFICIENT_BUFFER == hr)
                {
                    _NukeCrLf(szXmlBuff);
                    _LogOut(szXmlBuff);
                    pszLine = pszLastGT + 1;
                }
				else
				{
					break;
				}
            }
            else if (*pszTemp)
            {
                //
                // We're forced to break the line at LOG_XML_BUFF_LEN with no '>' in range
                //
				hr = StringCchCopy(szXmlBuff, LOG_XML_BUFF_LEN, pszLine);
                if (SUCCEEDED(hr) || STRSAFE_E_INSUFFICIENT_BUFFER == hr)
                {
                    _NukeCrLf(szXmlBuff);
                    _LogOut(szXmlBuff);
                    pszLine += LOG_XML_BUFF_LEN -1;
                }
				else
				{
					break;
				}
            }
            else
            {
                //
                // Output any leftover XML to end of BSTR
                //
                _NukeCrLf(pszLine);
                _LogOut(pszLine);
                //
                // Set to end of BSTR so we bust out of outer while
                //
                pszLine += lstrlen(pszLine);
			}
		}

#if !(defined(UNICODE) || defined(_UNICODE))
done:
        if (pszANSIBuff)
        {
            HeapFree(GetProcessHeap(), 0, pszANSIBuff);
            pszANSIBuff = NULL;
        }
#endif
	}
}

////////////////////////////////////////////////////////////////////////
//
// log with type SOFTWARE, this function will do nothing
// if the SOFTWARE exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogSoftware(LPCTSTR szLogFormat, ...)
{
    USES_IU_CONVERSION;

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_SOFTWARE, szLogFormat, va);
        va_end (va);
    }
}



////////////////////////////////////////////////////////////////////////
//
// log with type DOWNLOAD, this function will do nothing
// if the LogDownload exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogDownload(LPCTSTR szLogFormat, ...)
{
    USES_IU_CONVERSION;

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_DOWNLOAD, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// log with type DRIVER, this function will do nothing
// if the DRIVER exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogDriver(LPCTSTR szLogFormat, ...)
{
    USES_IU_CONVERSION;

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_DRIVER, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// log with type CHECKTRUST, this function will do nothing
// if the CHECKTRUST exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogTrust(LPCTSTR szLogFormat, ...)
{

    USES_IU_CONVERSION;

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_TRUST, szLogFormat, va);
        va_end (va);
    }

}



////////////////////////////////////////////////////////////////////////
//
// actual base logging function
// if it actually logged, or just returned
// because directives say don't make this kind of log
//
////////////////////////////////////////////////////////////////////////
void CIULogger::_Log(DWORD LogType, LPCTSTR pszLogFormat, va_list va)
{

    USES_IU_CONVERSION;
    TCHAR szOut[5 * 1024];
    LPTSTR pszFormat;
    DWORD dwFormatLen;

    if (!m_fLogUsable || (0x0 == (m_sdwLogMask & LogType)) || NULL == pszLogFormat)
    {
        return;
    }

    if (LOG_ERROR == LogType)
    {
        //
        // for error case, we try to add "Error Line %d: " in front of the log
        //
        dwFormatLen = lstrlen(pszLogFormat) + 128;
        pszFormat = (TCHAR*) MemAlloc(dwFormatLen * sizeof(TCHAR));
        if (NULL != pszFormat)
        {
            if (FAILED(StringCchPrintf(pszFormat, dwFormatLen, _T("Error Line %d: %s"), m_LineNum, pszLogFormat)))
            {
                pszFormat = (LPTSTR)pszLogFormat;
            }
        }
        else
        {
            pszFormat = (LPTSTR)pszLogFormat;
        }
    }
    else
    {
        pszFormat = (LPTSTR)pszLogFormat;
    }

    if (SUCCEEDED(StringCchVPrintf(szOut, ARRAYSIZE(szOut), pszFormat, va)))
    {
        _LogOut(szOut);
    }
    return;
}



//
// function to write the log to log file
// also taking care of indentation
//
void CIULogger::_LogOut(LPTSTR pszLog)
{

    if (NULL == pszLog)
        return;

    //
    // Protect static variables and indent values
    //
    EnterCriticalSection(&g_LogCs);

    int n = GetIndent();
    int i, 
        nLogLen,    // length of log string passed in
        nTotalLen;    // length of constructed 

    HANDLE    hHeap = GetProcessHeap();
    LPTSTR    pszWholeLog;
    LPTSTR    pszCurrentPos;
    DWORD     dwCurrentLen;
    DWORD     dwWritten;
    TCHAR     szTab = (m_siIndentStep < 1) ? szTab = _T('\t') : szTab = _T(' ');

    //
    // find out length for log header
    //
    if (m_siIndentStep > 0)
    {
        //
        // if positive number, it means the number of
        // space chars to use for each indent, rather
        // than using a tab
        //
        n *= m_siIndentStep;
    }

    nLogLen = lstrlen(pszLog);
    //
    // verify this log is \r\n ended
    //
    if (nLogLen > 1 && _T('\n') == pszLog[nLogLen-1])
    {
        //
        // if there is no catriege return, just a \n,
        // then remove \n 
        //
        if (_T('\r') != pszLog[nLogLen-2])
        {
            nLogLen--;
            pszLog[nLogLen] = _T('\0');
        }
    }

    nTotalLen = n + sizeof(szLogHeaderFmt)/sizeof(TCHAR) + nLogLen + 3;
    
    //
    // allocate memory to construct the log
    //
    pszWholeLog = (LPTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, nTotalLen * sizeof(TCHAR));

    if (NULL == pszWholeLog)
    {
        //
        // nothing we can do in this case, bail.
        //
        LeaveCriticalSection(&g_LogCs);
        return;
    }

    //
    // get log header
    //
    GetLogHeader(pszWholeLog, nTotalLen);

    //
    // construct indent
    //
    pszCurrentPos = pszWholeLog + lstrlen(pszWholeLog);
    dwCurrentLen = nTotalLen - lstrlen(pszWholeLog);
    for (i = 0; i < n; i++) 
    {
        pszCurrentPos[i] = szTab;
    }
    pszCurrentPos[i] = _T('\0');

    //
    // add log to whilelog buffer
    //
    if (FAILED(StringCchCat(pszCurrentPos, dwCurrentLen, pszLog)))
    {
        goto done;
    }
    
    //
    // Always terminate lines with <CR> <LF>
    //
    if (_T('\n') != pszLog[nLogLen-1])
    {
        if (FAILED(StringCchCat(pszCurrentPos, dwCurrentLen, _T("\r\n"))))
        {
            goto done;
        }
    }
    
    //
    // write log
    //
    nTotalLen = lstrlen(pszWholeLog);
    
    if (m_fLogFile)
    {
        if (TRUE == AcquireMutex())
        {
            //
            // Another module (e.g. if we are iuengine, maybe iuctl) may have written
            // to the iu_xxx.log file, so we need to seek to the end before writing
            //
            SetFilePointer(m_shFile, 0, NULL, FILE_END);
            WriteFile(m_shFile, pszWholeLog, nTotalLen * sizeof(TCHAR), &dwWritten, NULL);
            if (m_fFlushEveryTime)
            {
                FlushFileBuffers(m_shFile);
            }

            ReleaseMutex();
        }
    }

    if (m_fLogDebugMsg)
    {
        OutputDebugString(pszWholeLog);
    }

done:

    HeapFree(hHeap, 0, pszWholeLog);

    LeaveCriticalSection(&g_LogCs);
    return;
}



//////////////////////////////////////////////////////////////////////
//
// Timestamp Helper
//
//////////////////////////////////////////////////////////////////////

void CIULogger::GetLogHeader(LPTSTR pszBuffer, DWORD cchBufferLen)
{
    SYSTEMTIME st = {0};

    if (pszBuffer == NULL)
    {
        return;
    }

    GetLocalTime(&st);

    //
    // print out as the pre-defined format:
    //    szTimeStampFmt[]
    //
    if (FAILED(StringCchPrintf(pszBuffer, cchBufferLen,
                        _T("%4d/%02d/%02d|%02d:%02d:%02d:%03d|%08x| "), 
                        st.wYear,
                        st.wMonth,
                        st.wDay,
                        st.wHour,
                        st.wMinute,
                        st.wSecond,
                        st.wMilliseconds,
                        m_dwThreadId)))
    {
        // It wont fit, just set it to an empty string
        pszBuffer[0] = 0;
    }
}



//
// function to retrieve the indent of current thread
//
int CIULogger::GetIndent(void)
{

    if (m_Index < 0 || !m_fLogUsable)
    {
        return 0;
    }
    else
    {
        return m_psIndent[m_Index].iIndent;
    }

}


//
// function to change indention of current thread
//
void CIULogger::SetIndent(int IndentDelta)
{
    int i;
    bool fQuit = false;

    EnterCriticalSection(&g_LogCs);

    if (m_Index < 0)
    {
        //
        // try to find the index
        //

        if (NULL == m_psIndent)
        {
            //
            // if no indent array created yet
            //
            m_psIndent = (_THREAD_INDENT*)
                         HeapAlloc(
                                   GetProcessHeap(),
                                   HEAP_ZERO_MEMORY,
                                   c_IndentArrayChunk * sizeof(_THREAD_INDENT)
                                   );
            if (NULL != m_psIndent)
            {
                m_Size = c_IndentArrayChunk;
            }
            else
            {
                LeaveCriticalSection(&g_LogCs);
                return;
            }
    
        }


        for (i = 0; i < m_Size && m_psIndent[i].dwThreadId != 0; i++)
        {
            if (m_psIndent[i].dwThreadId == m_dwThreadId)
            {
                m_Index = i;
                break;
            }
        }

        if (m_Index < 0)
        {
            //
            // this thread is not in the array yet
            //
            for (i = 0; i < m_Size; i++)
            {
                if (0 == m_psIndent[i].dwThreadId)
                {
                    break;
                }
            }
            if (i < m_Size)
            {
                //
                // fill the next empty slot in array
                //
                m_psIndent[i].dwThreadId = m_dwThreadId;
                m_psIndent[i].iIndent = 0;
                m_Index = i;
            }
            else
            {
                //
                // array is full, no empty slot anymore
                // need to increase the indent array size
                //
                int iSize = m_Size + c_IndentArrayChunk;

                _THREAD_INDENT* pNewArray = (_THREAD_INDENT*)
                                            HeapReAlloc(
                                                        GetProcessHeap(), 
                                                        HEAP_ZERO_MEMORY, 
                                                        m_psIndent, 
                                                        iSize * sizeof(_THREAD_INDENT)
                                                        );
                if (NULL != pNewArray)
                {
                    m_psIndent = pNewArray;
                    m_Size = iSize;

                    m_psIndent[i].dwThreadId = m_dwThreadId;
                    m_psIndent[i].iIndent = 0;
                    m_Index = i;
                }
            }

        }
    }
    

    if (m_Index >= 0)
    {
        m_psIndent[m_Index].iIndent += IndentDelta;
    }

    LeaveCriticalSection(&g_LogCs);

}






//
// read registry value helper -- protected by g_LogCs in ctor
//
void CIULogger::ReadRegistrySettings(void)
{

    //
    // declare constants used to retrive logging settings
    //
    const TCHAR REGKEY_IUTCTL[]            = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControlLogging");
    const TCHAR REGVAL_LOGFILE[]        = _T("Logging File");
    const TCHAR REGVAL_LOGDEBUGMSG[]    = _T("Logging DebugMsg");
    const TCHAR REGVAL_LOGINDENT[]        = _T("LogIndentStep");
    const TCHAR REGVAL_LOGNOBLOCK[]        = _T("LogExcludeBlock");
    const TCHAR REGVAL_LOGNOXML[]        = _T("LogExcludeXML");
    const TCHAR REGVAL_LOGNOXMLBSTR[]    = _T("LogExcludeXmlBSTR");
    const TCHAR REGVAL_LOGNOINET[]        = _T("LogExcludeInternet");
    const TCHAR REGVAL_LOGNODRIVER[]    = _T("LogExcludeDriver");
    const TCHAR REGVAL_LOGNOSW[]        = _T("LogExcludeSoftware");
    const TCHAR REGVAL_LOGNOTRUST[]        = _T("LogExcludeTrust");
    const TCHAR REGVAL_LOGDOWNLOAD[]    = _T("LogExcludeDownload");
    const TCHAR REGVAL_LOGFLUSH[]        = _T("FlushLogEveryTime");    // added by charlma 11/27/01 to improve logging performance
                                                                    // only flush everytime if this flag is set to 1


    HKEY    hKey = NULL;
    TCHAR    szFilePath[MAX_PATH] = {0};
    DWORD    dwSize = sizeof(szFilePath);
    DWORD    dwData;
    
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUTCTL, 0, KEY_READ, &hKey))
    {
        //
        // there is no reg key setting available, so we will not 
        // output any log to anywhere - this is the released mode
        //
        return;
    }


    //
    // try to read out the file path for log file.
    //
    if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGVAL_LOGFILE, 0, 0, (LPBYTE)&szFilePath, &dwSize) && dwSize  > 0 && szFilePath[0] != _T('\0'))
    {
        TCHAR szLogFile[MAX_PATH];
        TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
        //
        // TODO: changed to use private version splitpath()
        //
        //_tsplitpath(szFilePath, szDrive, szDir, szFName, szExt);
        MySplitPath(szFilePath, szDrive, szDir, szFName, szExt);

        //
        // construct the log file name with process id embedded
        //
        if (FAILED(StringCchPrintf(szLogFile, ARRAYSIZE(szLogFile),
                             _T("%s%s%s_%d%s"), 
                             szDrive, 
                             szDir, 
                             szFName, 
                             GetCurrentProcessId(), 
                             szExt)))
        {
            // Can't construct log filename, so nothing we can do.
            RegCloseKey(hKey);
            return;
        }
        
        m_shFile = CreateFile(
                             szLogFile,
                             GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_ALWAYS,
                             0,
                             NULL);
        if (INVALID_HANDLE_VALUE != m_shFile)
        {
            if (INVALID_SET_FILE_POINTER == SetFilePointer(m_shFile, 0, NULL, FILE_END))
            {
                CloseHandle(m_shFile);
                m_shFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                //
                // we have successfully opened the log file
                // so increase the indent level to 0 for
                // top level logging. this will cause
                // the indent array created
                //
                SetIndent(0);

                //
                // Unicode files need a 0xFEFF header
                //
                #if defined(UNICODE) || defined(_UNICODE)
                const WORD wUnicodeHeader = 0xFEFF;

                //
                // if the file is zero length, then this is a new file
                // we need to add unicode header
                //
                DWORD dwFileSize;

                if ( -1 != (dwFileSize = GetFileSize(m_shFile, NULL)))
                {
                    if (0 == dwFileSize)
                    {
                        WriteFile(m_shFile, &wUnicodeHeader, sizeof(WORD), &dwFileSize, NULL);
                    }
                } 
                #endif

            }
            //
            // Now create the Mutex we will use to protect future writes (we are in global ctor now...)
            //
            // construct the log file name with process id embedded, but no drive or '\' in path
            // so we can use it to name our mutex (file will be per-process).
            //
            if (FAILED(StringCchPrintf(szLogFile, ARRAYSIZE(szLogFile),
                                 _T("%s_%d%s"),  
                                 szFName, 
                                 GetCurrentProcessId(), 
                                 szExt)))
            {
                // If that doesn't work, just use a simple named mutex 
                m_hMutex = ::CreateMutex(NULL, FALSE, szFName);
            }
            else
            {
                m_hMutex = ::CreateMutex(NULL, FALSE, szLogFile);
            }
        }
    }

    
    //
    // try to find out if we should output debug msg to debugger
    //
    
    dwData = 0x0;
    dwSize = sizeof(dwData);

    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGDEBUGMSG, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        m_fLogDebugMsg = true;
    }


    //
    // keep reading other *optional* log directives
    //

    //
    // read whether we should exlude block data
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOBLOCK, 0, 0, (LPBYTE)&dwData, &dwSize) 
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_BLOCK);
    }

    //
    // read whether we should exlude XML related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOXML, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_XML_DETAIL);
    }

    //
    // read whether we should exlude XML BSTR related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOXMLBSTR, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_XML_BSTR_DETAIL);
    }

    //
    // read whether we should exlude internet related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOINET, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_INTERNET);
    }

    //
    // read whether we should exlude driver related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNODRIVER, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_DRIVER);
    }

    //
    // read whether we should exlude driver related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOSW, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_SOFTWARE);
    }

    //
    // read whether we should exlude wintrust checking related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOTRUST, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_TRUST);
    }
    
    //
    // read whether we should exlude wintrust checking related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGDOWNLOAD, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_DOWNLOAD);
    }


    //
    // read whether we should use tab or space(s) for each indent step
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGINDENT, 0, 0, (LPBYTE)&dwData, &dwSize)
            && ((int)dwData > 0))
    {
        //
        // use space char(s) (_T(' ')). If nagetive or 0, _Logout will use tab char
        //
        m_siIndentStep = (int) dwData;
    }


    //
    // read whether we should flush everytime we do file logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (m_shFile != INVALID_HANDLE_VALUE &&
        (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGFLUSH, 0, 0, (LPBYTE)&dwData, &dwSize)))
    {
        
        m_fFlushEveryTime = (0x1 == dwData);
    }

    //
    // finished registry checking
    //
    RegCloseKey(hKey);

}

#endif // defined(DBG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\schemamisc\schemamisc.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   SchemaMisc.CPP
//
//	Author:	Charles Ma
//			2000.10.27
//
//  Description:
//
//      Implement helper functions related to IU schemas
//
//=======================================================================

//#include "iuengine.h"	// PCH - must include first
#include <windows.h>
#include <tchar.h>
#include <ole2.h>
//#include "iu.h"
#include <iucommon.h>

#include "schemamisc.h"
#include <MemUtil.h>
#include "regutil.h"
#include "fileutil.h"
#include "stringutil.h"
#include <shlwapi.h>	// pathappend() api
#include "schemakeys.h"
#include <URLLogging.h>
#include <MISTSAFE.h>

#include<wusafefn.h>

//
// max length of platform when being converted into string
// this is an artificial number that we think enough to
// take any MS platform data.
//
const UINT MAX_PLATFORM_STR_LEN = 1024;

//
// private flags used by functions to retrieve string data
//
const DWORD SKIP_SUITES				= 0x1;
const DWORD SKIP_SERVICEPACK_VER	= 0x2;

const long	MAX_VERSION = 256;

const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR REGVAL_SCHEMAVALIDATION[] = _T("ValidateSchema");

//
// Global pointer gets initialized to NULL by runtime. Any module including schemamisc.h must
// allocate this object following its call to CoInitialize, and delete the object before
// calling CoUninitialize.
//
CSchemaKeys * g_pGlobalSchemaKeys /* = NULL */;

#define QuitIfNull(p) {if (NULL == p) {hr = E_INVALIDARG; return hr;}}
#define QuitIfFail(x) {hr = x; if (FAILED(hr)) goto CleanUp;}


/////////////////////////////////////////////////////////////////////////////
// FindSingleDOMNode()
//
// Retrieve the first xml node with the given tag name under the given parent node
// Return value:
//		S_OK if *ppNode returns matching node value
//		HRESULT_FROM_WIN32(ERROR_NOT_FOUND)		if node not found
//		FAILED()								otherwise
// Caller is responsible for releasing *ppNode.
/////////////////////////////////////////////////////////////////////////////
HRESULT FindSingleDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode)
{
	HRESULT		hr	= S_OK;

	QuitIfNull(ppNode);
	*ppNode = NULL;
	QuitIfNull(pParentNode);
	QuitIfNull(bstrName);

	hr = pParentNode->selectSingleNode(bstrName, ppNode);
	if (S_FALSE == hr)
	{
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	}
	if (FAILED(hr))
	{
		*ppNode = NULL;
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindSingleDOMNode()
//
// Retrieve the first xml node with the given tag name in the given xml doc
// Return value:
//		S_OK if *ppNode returns matching node value
//		HRESULT_FROM_WIN32(ERROR_NOT_FOUND)		if node not found
//		FAILED()								otherwise
// Caller is responsible for releasing *ppNode.
/////////////////////////////////////////////////////////////////////////////
HRESULT FindSingleDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode)
{
	HRESULT		hr	= S_OK;
	IXMLDOMNode	*pParentNode = NULL;

	QuitIfNull(ppNode);
	*ppNode = NULL;
	QuitIfNull(pDoc);
	QuitIfNull(bstrName);
	if (SUCCEEDED(hr = pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode)))
	{
		hr = FindSingleDOMNode(pParentNode, bstrName, ppNode);
		SafeRelease(pParentNode);
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindDOMNodeList()
//
// Retrieve the xml nodelist with the given tag name under the given parent node
// Return value: NULL if failed or no match; matching node list otherwise.
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* FindDOMNodeList(IXMLDOMNode* pParentNode, BSTR bstrName)
{
	HRESULT		hr	= S_OK;
	IXMLDOMNodeList *pNodeList = NULL;
	LONG	lLength = 0;

	if (NULL == pParentNode ||
		NULL == bstrName ||
		FAILED(pParentNode->selectNodes(bstrName, &pNodeList)) ||
		NULL == pNodeList)
	{
		return NULL;
	}

	if (SUCCEEDED(pNodeList->get_length(&lLength)) &&
		lLength > 0)
	{
		return pNodeList;
	}

	SafeRelease(pNodeList);
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// FindDOMNodeList()
//
// Retrieve the xml nodelist with the given tag name in the given xml doc
// Return value: NULL if failed or no match; matching node list otherwise.
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* FindDOMNodeList(IXMLDOMDocument* pDoc, BSTR bstrName)
{	
	IXMLDOMNode		*pParentNode = NULL;
	IXMLDOMNodeList *pNodeList = NULL;

	if (NULL != pDoc &&
		NULL != bstrName &&
		SUCCEEDED(pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode)))
	{
		pNodeList = FindDOMNodeList(pParentNode, bstrName);
		pParentNode->Release();
	}
	return pNodeList;
}

	
/////////////////////////////////////////////////////////////////////////////
// CreateDOMNode()
//
// Create an xml node of the given type
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNode* CreateDOMNode(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI /*= NULL*/)
{
	if (NULL == pDoc ||
		(NODE_TEXT != nType && NULL == bstrName))
	{
		return NULL;
	}

    IXMLDOMNode	*pNode = NULL;
    VARIANT		vType;
	VariantInit(&vType);

    vType.vt = VT_I2;
    vType.iVal = nType;

	if (S_OK != pDoc->createNode(vType, bstrName, bstrNamespaceURI, &pNode))
	{
		return NULL;
	}

    return pNode;
}


/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// Get attribute (integer) from the xml node
// If function fails, *piAttr preserves original value.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, INT* piAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);
    QuitIfNull(piAttr);

	VARIANT		vAttr;
    IXMLDOMElement		*pElement = NULL;
    IXMLDOMAttribute	*pAttrNode = NULL;;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
	QuitIfFail(pElement->getAttributeNode(bstrName, &pAttrNode));
	if (NULL == pAttrNode) goto CleanUp;

	QuitIfFail(pAttrNode->get_value(&vAttr));
	if (VT_INT == vAttr.vt)
	{
		*piAttr = vAttr.intVal;
	}
	else if (VT_BSTR == vAttr.vt)
	{
		*piAttr = (INT)MyBSTR2L(vAttr.bstrVal);
	}
	else if (VT_I2 == vAttr.vt)
	{
		*piAttr = vAttr.iVal;
	}
	else
	{
		hr = E_FAIL;
	}
	VariantClear(&vAttr);

CleanUp:
    SafeRelease(pElement);
    SafeRelease(pAttrNode);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// Get attribute (long) from the xml node
// If function fails, *piAttr preservers original value.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, LONG* plAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);
    QuitIfNull(plAttr);

	VARIANT		vAttr;
    IXMLDOMElement		*pElement = NULL;
    IXMLDOMAttribute	*pAttrNode = NULL;;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
	QuitIfFail(pElement->getAttributeNode(bstrName, &pAttrNode));
	if (NULL == pAttrNode) goto CleanUp;

	QuitIfFail(pAttrNode->get_value(&vAttr));
	if (VT_I4 == vAttr.vt)
	{
		*plAttr = vAttr.lVal;
	}
	else if (VT_BSTR == vAttr.vt)
	{
		*plAttr = MyBSTR2L(vAttr.bstrVal);
	}
	else
	{
		hr = E_FAIL;
	}
	VariantClear(&vAttr);

CleanUp:
    SafeRelease(pElement);
    SafeRelease(pAttrNode);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// Get attribute (BOOL) from the xml node
// If function fails, *piAttr preservers original value.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttributeBOOL(IXMLDOMNode* pNode, BSTR bstrName, BOOL * pfAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);
    QuitIfNull(pfAttr);

	VARIANT		vAttr;
	VARIANT		vAttrBool;
    IXMLDOMElement		*pElement = NULL;
    IXMLDOMAttribute	*pAttrNode = NULL;;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
	QuitIfFail(pElement->getAttributeNode(bstrName, &pAttrNode));
	if (NULL == pAttrNode) goto CleanUp;

	QuitIfFail(pAttrNode->get_value(&vAttr));

    QuitIfFail(VariantChangeType(&vAttr, &vAttrBool, 0, VT_BOOL));              

    VariantClear(&vAttr);

    *pfAttr = (VARIANT_TRUE == vAttrBool.boolVal) ? TRUE : FALSE;

CleanUp:
    SafeRelease(pElement);
    SafeRelease(pAttrNode);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// Get attribute (BSTR) from the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, BSTR* pbstrAttr)
{
	HRESULT		hr = S_OK;
    QuitIfNull(pbstrAttr);
	*pbstrAttr = NULL;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);

	VARIANT		vAttr;
    IXMLDOMElement		*pElement = NULL;
    IXMLDOMAttribute	*pAttrNode = NULL;;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
	QuitIfFail(pElement->getAttributeNode(bstrName, &pAttrNode));
	if (NULL == pAttrNode) goto CleanUp;

	QuitIfFail(pAttrNode->get_value(&vAttr));
	if (VT_BSTR == vAttr.vt)
	{
		*pbstrAttr = SysAllocString(vAttr.bstrVal);
	}
	else
	{
		hr = E_FAIL;
	}
	VariantClear(&vAttr);

CleanUp:
    SafeRelease(pElement);
    SafeRelease(pAttrNode);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (integer) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, INT iAttr)
{
    VARIANT		vAttr;
	VariantInit(&vAttr);
	vAttr.vt = VT_INT;
    vAttr.intVal = iAttr;
    return SetAttribute(pNode, bstrName, vAttr);
}


/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (BSTR) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, BSTR bstrAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(bstrAttr);

    VARIANT		vAttr;
	VariantInit(&vAttr);
    vAttr.vt = VT_BSTR;
    vAttr.bstrVal = bstrAttr;
    return SetAttribute(pNode, bstrName, vAttr);
}


/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (VARIANT) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, VARIANT vAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);

    IXMLDOMElement	*pElement = NULL;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
    QuitIfFail(pElement->setAttribute(bstrName, vAttr));

CleanUp:
    SafeRelease(pElement);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetText()
//
// Get text (BSTR) from the xml node
// Returns
//		S_OK if *pbstrText returns text of 1st child of the given node
//		S_FALSE if node has no child or 1st child has no text
//		FAILED() otherwise
/////////////////////////////////////////////////////////////////////////////
HRESULT GetText(IXMLDOMNode* pNode, BSTR* pbstrText)
{
	//USES_IU_CONVERSION;

	HRESULT		hr = E_FAIL;
	QuitIfNull(pbstrText);
	*pbstrText = NULL;
	QuitIfNull(pNode);

	DOMNodeType		nNodeType;
    IXMLDOMNode*	pNodeText = NULL;

	QuitIfFail(pNode->get_firstChild(&pNodeText));
	if (NULL == pNodeText) goto CleanUp;

	QuitIfFail(pNodeText->get_nodeType(&nNodeType));
	if (NODE_TEXT == nNodeType)
	{
		QuitIfFail(pNodeText->get_text(pbstrText));	
	}
	else
	{
		hr = E_UNEXPECTED;
	}

CleanUp:
	SafeRelease(pNodeText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SetValue()
//
// Set value (integer) for the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT SetValue(IXMLDOMNode* pNode, INT iValue)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);

    VARIANT		vValue;
	VariantInit(&vValue);
    vValue.vt = VT_INT;
    vValue.intVal = iValue;
    return (pNode->put_nodeValue(vValue));
}


/////////////////////////////////////////////////////////////////////////////
// SetValue()
//
// Set value (BSTR) for the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT SetValue(IXMLDOMNode* pNode, BSTR bstrValue)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);

    VARIANT		vValue;
	VariantInit(&vValue);
    vValue.vt = VT_BSTR;
    vValue.bstrVal = bstrValue;
    return (pNode->put_nodeValue(vValue));
}


/////////////////////////////////////////////////////////////////////////////
// InsertNode()
//
// Insert a child node to the parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT InsertNode(IXMLDOMNode* pParentNode, IXMLDOMNode* pChildNode, IXMLDOMNode* pChildNodeRef /*= NULL*/)
{
	HRESULT		hr = S_OK;

	QuitIfNull(pParentNode);
	QuitIfNull(pChildNode);

	IXMLDOMNode	*p = NULL;
    if (NULL != pChildNodeRef)	// insert before the ref child node
	{
		VARIANT	vChildNodeRef;
	    VariantInit(&vChildNodeRef);
		vChildNodeRef.vt = VT_UNKNOWN;
		vChildNodeRef.punkVal = pChildNodeRef;
		QuitIfFail(pParentNode->insertBefore(pChildNode, vChildNodeRef, &p));
	}
	else						// append to the child list
	{
		VARIANT	vEmpty;
	    VariantInit(&vEmpty);
		vEmpty.vt = VT_EMPTY;
		QuitIfFail(pParentNode->insertBefore(pChildNode, vEmpty, &p));
	}

CleanUp:
    SafeRelease(p);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CopyNode()
//
// Create an xml node as a copy of the given node;
// this is different from cloneNode() as it copies node across xml document
/////////////////////////////////////////////////////////////////////////////
HRESULT CopyNode(IXMLDOMNode* pNodeSrc, IXMLDOMDocument* pDocDes, IXMLDOMNode** ppNodeDes)
{
	HRESULT hr = S_OK;
	BSTR	bstrNodeName = NULL;
	BSTR	bstrText = NULL;
	BSTR	bstrAttrName = NULL;
	IXMLDOMNode			*pChild = NULL;
	IXMLDOMNamedNodeMap	*pAttrs = NULL;

	LOG_Block("CopyNode()");

	QuitIfNull(ppNodeDes);
	*ppNodeDes = NULL;
	QuitIfNull(pNodeSrc);
	QuitIfNull(pDocDes);

	DOMNodeType		nNodeType;
	CleanUpIfFailedAndSetHrMsg(pNodeSrc->get_nodeType(&nNodeType));

	switch (nNodeType)
	{
	case NODE_TEXT:
	{
		CleanUpFailedAllocSetHrMsg(*ppNodeDes = CreateDOMNode(pDocDes, NODE_TEXT, NULL));
		CleanUpIfFailedAndSetHrMsg(pNodeSrc->get_text(&bstrText));
		CleanUpIfFailedAndSetHrMsg(SetValue(*ppNodeDes, bstrText));
		break;
	}
	case NODE_ELEMENT:
	{
		CleanUpIfFailedAndSetHrMsg(pNodeSrc->get_nodeName(&bstrNodeName));
		CleanUpFailedAllocSetHrMsg(*ppNodeDes = CreateDOMNode(pDocDes, NODE_ELEMENT, bstrNodeName));

		if (SUCCEEDED(pNodeSrc->get_attributes(&pAttrs)) && (NULL != pAttrs))
		{
			pAttrs->nextNode(&pChild);
			while (pChild)
			{
				CleanUpIfFailedAndSetHrMsg(pChild->get_nodeName(&bstrAttrName));

				VARIANT vAttrValue;
				CleanUpIfFailedAndSetHrMsg(pChild->get_nodeValue(&vAttrValue));
				hr = SetAttribute(*ppNodeDes, bstrAttrName, vAttrValue);
				VariantClear(&vAttrValue);
				CleanUpIfFailedAndMsg(hr);

				SafeSysFreeString(bstrAttrName);
				SafeReleaseNULL(pChild);
				pAttrs->nextNode(&pChild);
			}
			pAttrs->Release();
			pAttrs = NULL;
		}

		pNodeSrc->get_firstChild(&pChild);
		while (pChild)
		{
			IXMLDOMNode *pChildDes = NULL;
			CleanUpIfFailedAndSetHrMsg(CopyNode(pChild, pDocDes, &pChildDes));
			hr = InsertNode(*ppNodeDes, pChildDes);
			SafeRelease(pChildDes);
			CleanUpIfFailedAndMsg(hr);

			IXMLDOMNode *pNext = NULL;
			CleanUpIfFailedAndMsg(pChild->get_nextSibling(&pNext));
			pChild->Release();
			pChild = pNext;
		}
		hr = S_OK;
		break;
	}
	default:
		//
		// for now, do nothing for other node types
		//
		;
	}

CleanUp:
	if (FAILED(hr))
	{
		SafeReleaseNULL(*ppNodeDes);
	}
	SysFreeString(bstrNodeName);
	SysFreeString(bstrText);
	SysFreeString(bstrAttrName);
	SafeRelease(pChild);
	SafeRelease(pAttrs);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AreNodesEqual()
//
// Return TRUE if two nodes are identical, return FALSE if function failed or
// if they're different (including order of attributes).
/////////////////////////////////////////////////////////////////////////////
BOOL AreNodesEqual(IXMLDOMNode* pNode1, IXMLDOMNode* pNode2)
{
	if (pNode1 == pNode2)
	{
		return TRUE;
	}
	if ((NULL == pNode1) || (NULL == pNode2))
	{
		return FALSE;
	}

	BOOL fResult = FALSE;
	BOOL fSkipAttribute = FALSE;
	BOOL fSkipChildNode = FALSE;
	LONG lenAttr1= -1 , lenAttr2= -1;
	LONG lenNode1= -1 , lenNode2= -1;
	DOMNodeType	nNodeType1, nNodeType2;
	BSTR bstrText1 = NULL, bstrText2 = NULL;
	BSTR bstrNodeName1 = NULL, bstrNodeName2 = NULL;
	BSTR bstrAttrName1 = NULL, bstrAttrName2 = NULL;
	IXMLDOMNodeList *pChildNodes1 = NULL, *pChildNodes2 = NULL;
	IXMLDOMNode	*pChild1= NULL, *pNext1 = NULL;
	IXMLDOMNode	*pChild2= NULL, *pNext2 = NULL;
	IXMLDOMNamedNodeMap	*pAttrs1 = NULL, *pAttrs2 = NULL;
	VARIANT vAttrValue1, vAttrValue2;

	VariantInit(&vAttrValue1);
	VariantInit(&vAttrValue2);

	if (FAILED(pNode1->get_nodeType(&nNodeType1)) ||
		FAILED(pNode2->get_nodeType(&nNodeType2)) ||
		(nNodeType1 != nNodeType2))
	{
		goto CleanUp;
	}

	switch (nNodeType1)
	{
	case NODE_TEXT:
	{
		if (FAILED(pNode1->get_text(&bstrText1)) ||
			FAILED(pNode2->get_text(&bstrText2)) ||
			!CompareBSTRsEqual(bstrText1, bstrText2))
		{
			goto CleanUp;
		}
		break;
	}
	case NODE_ELEMENT:
	{
		if (FAILED(pNode1->get_nodeName(&bstrNodeName1)) ||
			FAILED(pNode2->get_nodeName(&bstrNodeName2)) ||
			!CompareBSTRsEqual(bstrNodeName1, bstrNodeName2))
		{
			goto CleanUp;
		}

		//
		// 1. compare number of attributes
		//
		if (FAILED(pNode1->get_attributes(&pAttrs1)) ||
			FAILED(pNode2->get_attributes(&pAttrs2)))
		{
			// this shouldn't happen, but...
			goto CleanUp;
		}
		if ((NULL != pAttrs1) && (NULL != pAttrs2))
		{
			if (FAILED(pAttrs1->get_length(&lenAttr1)) ||
				FAILED(pAttrs2->get_length(&lenAttr2)) ||
				(abs(lenAttr1-lenAttr2) > 1))
			{
				// known bug in MSXML3.dll: xmlns="" could be one of the attribute
				goto CleanUp;
			}
		}
		else if (pAttrs1 == pAttrs2)
		{
			// pAttrs1 and pAttrs2 are both NULL,
			// set flag to ingore comparison of each individual attribute,
			// go ahead compare the number of child nodes
			fSkipAttribute = TRUE;
		}
		else
		{
			// one of pAttrs1 and pAttrs2 is NULL, the nodes are obviously different
			goto CleanUp;
		}

		//
		// 2. compare number of child nodes
		//
		if (FAILED(pNode1->get_childNodes(&pChildNodes1)) ||
			FAILED(pNode2->get_childNodes(&pChildNodes2)))
		{
			// this shouldn't happen, but...
			goto CleanUp;
		}
		if ((NULL != pChildNodes1) && (NULL != pChildNodes2))
		{
			if (FAILED(pChildNodes1->get_length(&lenNode1)) ||
				FAILED(pChildNodes2->get_length(&lenNode2)) ||
				(lenNode1 != lenNode2))
			{
				goto CleanUp;
			}
		}
		else if (pChildNodes1 == pChildNodes2)
		{
			// pChildNodes1 and pChildNodes2 are both NULL,
			// set flag to ingore comparison of each individual child node,
			// go ahead compare each attribute in next step
			fSkipChildNode = TRUE;
		}
		else
		{
			// one of pChildNodes1 and pChildNodes2 is NULL, the nodes are obviously different
			goto CleanUp;
		}
		
		//
		// 3. compare each attribute
		//
		if (!fSkipAttribute)
		{
			pAttrs1->nextNode(&pChild1);
			pAttrs2->nextNode(&pChild2);
			while (pChild1 && pChild2)
			{
				if (NULL == bstrAttrName1)
				{
					if (FAILED(pChild1->get_nodeName(&bstrAttrName1)))
					{
						goto CleanUp;
					}
				}
				if (NULL == bstrAttrName2)
				{
					if (FAILED(pChild2->get_nodeName(&bstrAttrName2)))
					{
						goto CleanUp;
					}
				}
				if (!CompareBSTRsEqual(bstrAttrName1, bstrAttrName2))
				{					
					if (CompareBSTRsEqual(bstrAttrName1, KEY_XML_NAMESPACE) && lenAttr1 == lenAttr2+1)
					{
						// ignore xmlns=""
						SafeSysFreeString(bstrAttrName1);
						pChild1->Release();
						pAttrs1->nextNode(&pChild1);
						continue;
					}
					else if (CompareBSTRsEqual(bstrAttrName2, KEY_XML_NAMESPACE) && lenAttr1 == lenAttr2-1)
					{
						// ignore xmlns=""
						SafeSysFreeString(bstrAttrName2);
						pChild2->Release();
						pAttrs2->nextNode(&pChild2);
						continue;
					}
					else
					{
						goto CleanUp;
					}
				}
				else
				{
					VariantInit(&vAttrValue1);
					VariantInit(&vAttrValue2);
					if (FAILED(pChild1->get_nodeValue(&vAttrValue1)) ||
						FAILED(pChild2->get_nodeValue(&vAttrValue2)) ||
						(vAttrValue1.vt != vAttrValue2.vt))
					{
						goto CleanUp;
					}
					switch (vAttrValue1.vt)
					{
					case VT_INT:	// integer
						{
							if (vAttrValue1.intVal != vAttrValue2.intVal)
							{
								goto CleanUp;
							}
							break;
						}
					case VT_I2:		// short
						{
							if (vAttrValue1.iVal != vAttrValue2.iVal)
							{
								goto CleanUp;
							}
							break;
						}
					case VT_I4:		// long
						{
							if (vAttrValue1.lVal != vAttrValue2.lVal)
							{
								goto CleanUp;
							}
							break;
						}
					case VT_BOOL:	// bool
						{
							if (vAttrValue1.boolVal != vAttrValue2.boolVal)
							{
								goto CleanUp;
							}
							break;
						}
					case VT_BSTR:	// BSTR
						{
							if (!CompareBSTRsEqual(vAttrValue1.bstrVal, vAttrValue2.bstrVal))
							{
								goto CleanUp;
							}
							break;
						}
					default:
						//
						// for now, do nothing for other attribute types
						//
						;
					}
					SafeSysFreeString(bstrAttrName1);
					SafeSysFreeString(bstrAttrName2);
					VariantClear(&vAttrValue1);
					VariantClear(&vAttrValue2);
					pChild1->Release();
					pChild2->Release();
					pAttrs1->nextNode(&pChild1);
					pAttrs2->nextNode(&pChild2);
				}
			}

			if (pChild1 != pChild2)
			{
				if (NULL == pChild1)
				{
					// this is the case that we looped through all the attributes in the
					// first node but we still found attribute left in the second node;
					// if it's xmlns="", that's ok; otherwise these two nodes are different.
					if (FAILED(pChild2->get_nodeName(&bstrAttrName2)) ||
						(!CompareBSTRsEqual(bstrAttrName2, KEY_XML_NAMESPACE)))
					{
						goto CleanUp;
					}
				}
				else
				{
					if (FAILED(pChild1->get_nodeName(&bstrAttrName1)) ||
						(!CompareBSTRsEqual(bstrAttrName1, KEY_XML_NAMESPACE)))
					{
						goto CleanUp;
					}
				}
			}
		}

		//
		// 4. compare each child node
		//
		if (!fSkipChildNode)
		{
			pNode1->get_firstChild(&pChild1);
			pNode2->get_firstChild(&pChild2);
			while (pChild1)
			{
				if (!pChild2)
				{
					goto CleanUp;
				}
				if (!AreNodesEqual(pChild1, pChild2))
				{
					goto CleanUp;
				}
				pChild1->get_nextSibling(&pNext1);
				pChild2->get_nextSibling(&pNext2);
				pChild1->Release();
				pChild2->Release();
				pChild1 = pNext1;
				pChild2 = pNext2;
			}
		}
		break;
	}
	default:
		//
		// for now, do nothing for other node types
		//
		;
	}

	fResult = TRUE;

CleanUp:
	SafeSysFreeString(bstrText1);
	SafeSysFreeString(bstrText2);
	SafeSysFreeString(bstrNodeName1);
	SafeSysFreeString(bstrNodeName2);
	SafeSysFreeString(bstrAttrName1);
	SafeSysFreeString(bstrAttrName2);
	SafeRelease(pChildNodes1);
	SafeRelease(pChildNodes2);
	SafeRelease(pChild1);
	SafeRelease(pChild2);
	SafeRelease(pAttrs1);
	SafeRelease(pAttrs2);
	if (vAttrValue1.vt != VT_EMPTY)
		VariantClear(&vAttrValue1);
	if (vAttrValue2.vt != VT_EMPTY)
		VariantClear(&vAttrValue2);

    return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDoc()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT LoadXMLDoc(BSTR bstrXml, IXMLDOMDocument** ppDoc, BOOL fOffline /*= TRUE*/)
{
	HRESULT	hr	= E_FAIL;
	VARIANT_BOOL fSuccess = VARIANT_FALSE, fValidate = VARIANT_FALSE;

	QuitIfNull(ppDoc);
	*ppDoc = NULL;
	QuitIfNull(bstrXml);
 	hr = CoCreateInstance(CLSID_DOMDocument,
						  NULL,
						  CLSCTX_INPROC_SERVER,
						  IID_IXMLDOMDocument,
						  (void **) ppDoc);
    if (FAILED(hr))
	{
		return hr;
	}

	fValidate = fOffline ? VARIANT_FALSE : VARIANT_TRUE;

	//
	// we don't do validation unless the reg key is set on to do so
	//
	if (fValidate)
	{
		HKEY	hKey = NULL;
		DWORD	dwValue = 0x0;
		DWORD	dwSize = sizeof(dwValue);
		DWORD	dwType = REG_DWORD;

		fValidate = VARIANT_FALSE;
		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hKey))
		{
			if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGVAL_SCHEMAVALIDATION, NULL, &dwType, (LPBYTE)&dwValue, &dwSize))
			{
				if (REG_DWORD == dwType && sizeof(dwValue) == dwSize && 1 == dwValue)
				{
					fValidate = VARIANT_TRUE;
				}
			}
			RegCloseKey(hKey);
		}
	}

	//
	// force validation on parse if not offline
	//
	hr = (*ppDoc)->put_validateOnParse(fValidate);
	if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// force resolving external definition if not offline
	//
	hr = (*ppDoc)->put_resolveExternals(fValidate);
	if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// do synchronized loading
	//
    hr = (*ppDoc)->put_async(VARIANT_FALSE);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// load the XML Doc from input string
	//
	hr = (*ppDoc)->loadXML(bstrXml, &fSuccess);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}
	//
	// S_FALSE may be returned even if load fails, but
	// fSuccess will return VARIANT_FALSE if there was
	// an error so we call ValidateDoc to log the error
	// and get the correct HRESULT.
	//
	if (S_FALSE == hr || VARIANT_FALSE == fSuccess)
	{
		hr = ValidateDoc(*ppDoc);

		if (SUCCEEDED(hr))
		{
			hr = E_INVALIDARG;
		}
		SafeReleaseNULL(*ppDoc);
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LoadDocument()
//
// Load an XML Document from the specified file
/////////////////////////////////////////////////////////////////////////////
HRESULT LoadDocument(BSTR bstrFilePath, IXMLDOMDocument** ppDoc, BOOL fOffline /*= TRUE*/)
{
	HRESULT	hr	= E_FAIL;
	VARIANT_BOOL fSuccess = VARIANT_FALSE, fValidate = VARIANT_FALSE;;
    VARIANT vFilePath;

	QuitIfNull(ppDoc);
	*ppDoc = NULL;
	QuitIfNull(bstrFilePath);
 	hr = CoCreateInstance(CLSID_DOMDocument,
						  NULL,
						  CLSCTX_INPROC_SERVER,
						  IID_IXMLDOMDocument,
						  (void **) ppDoc);
    if (FAILED(hr))
	{
		return hr;
	}

	//
	// do synchronized loading
	//
    hr = (*ppDoc)->put_async(VARIANT_FALSE);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	fValidate = fOffline ? VARIANT_FALSE : VARIANT_TRUE;
	//
	// force validation on parse if not offline
	//
	hr = (*ppDoc)->put_validateOnParse(fValidate);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// force resolving external definition if not offline
	//
	hr = (*ppDoc)->put_resolveExternals(fValidate);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// load the XML Doc from the given file path
	//
    VariantInit(&vFilePath);
    vFilePath.vt = VT_BSTR;
    vFilePath.bstrVal = bstrFilePath;
    hr = (*ppDoc)->load(vFilePath, &fSuccess);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}
	//
	// S_FALSE may be returned even if load fails, but
	// fSuccess will return VARIANT_FALSE if there was
	// an error so we call ValidateDoc to log the error
	// and get the correct HRESULT.
	//
	if (VARIANT_FALSE == fSuccess)
	{
	  hr = ValidateDoc(*ppDoc);
	  if (SUCCEEDED(hr))
	  {
		 hr = E_INVALIDARG;
	  }
	  SafeReleaseNULL(*ppDoc);
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SaveDocument()
//
// Save an XML Document to the specified location
/////////////////////////////////////////////////////////////////////////////
HRESULT SaveDocument(IXMLDOMDocument* pDoc, BSTR bstrFilePath)
{
	HRESULT	hr	= E_FAIL;
	QuitIfNull(pDoc);
	QuitIfNull(bstrFilePath);

    //
	// save the XML Doc to the given location
	//
    VARIANT vFilePath;
    VariantInit(&vFilePath);
    vFilePath.vt = VT_BSTR;
    vFilePath.bstrVal = bstrFilePath;
    hr = pDoc->save(vFilePath);
                    
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ReportParseError()
//
// Report parsing error information
/////////////////////////////////////////////////////////////////////////////
HRESULT ReportParseError(IXMLDOMParseError *pXMLError)
{
    USES_IU_CONVERSION;

    HRESULT	hr = S_OK;
    LONG	lLine, lLinePos, lErrCode;
    BSTR	bstrErrText = NULL, bstrReason = NULL;

	QuitIfNull(pXMLError);
    QuitIfFail(pXMLError->get_errorCode(&lErrCode));
	hr = lErrCode;
    QuitIfFail(pXMLError->get_line(&lLine));
    QuitIfFail(pXMLError->get_linepos(&lLinePos));
    QuitIfFail(pXMLError->get_srcText(&bstrErrText));
    QuitIfFail(pXMLError->get_reason(&bstrReason));

    if (lLine > 0)
	{
		LOG_Block("ReportParseError()");
		LOG_Error(_T("XML line %ld, pos %ld error 0x%08x: %s)"),
				  lLine,
				  lLinePos,
				  lErrCode,
				  OLE2T(bstrReason));
		LOG_Error(_T("XML starts: %s"), OLE2T(bstrErrText));

#if defined(_UNICODE) || defined(UNICODE)
		LogError(lErrCode, "loadXML: line %ld, pos %ld, %S",
				  lLine,
				  lLinePos,
				  bstrReason);
		LogMessage("%S", bstrErrText);
#else
		LogError(lErrCode, "loadXML: line %ld, pos %ld, %s",
				  lLine,
				  lLinePos,
				  bstrReason);
		LogMessage("%s", bstrErrText);
#endif
/*
		//
		// We want to ping this error even though we don't have the
		// client information. This most likely indicates a server
		// content error.
		//
		CUrlLog pingSvr;

#define MAX_XML_PING_MSG	512

		TCHAR szMsg[MAX_XML_PING_MSG];
		lstrcpyn(szMsg, OLE2T(bstrErrText), MAX_XML_PING_MSG);

        pingSvr.Ping(
					FALSE,						// on-line (we don't know, so be safe)
					URLLOGDESTINATION_DEFAULT,	//fixcode: should depend of client and corp WU settings
					NULL,						// pt to cancel events
					0,							// number of events
					URLLOGACTIVITY_Detection,	// activity
					URLLOGSTATUS_Failed,		// status code
					lErrCode,					// error code
					NULL,						// itemID
					NULL,						// device data
					szMsg			// first MAX_XML_PING_MSG chars of XML for context
					);
*/
	}

CleanUp:
    SysFreeString(bstrErrText);
    SysFreeString(bstrReason);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ValidateDoc()
//
// Validate the xml doc against the schema
/////////////////////////////////////////////////////////////////////////////
HRESULT ValidateDoc(IXMLDOMDocument* pDoc)
{
	HRESULT		hr = S_OK;
    QuitIfNull(pDoc);

    LONG				lErrCode = 0;
    IXMLDOMParseError	*pXMLError = NULL;

	QuitIfFail(pDoc->get_parseError(&pXMLError));
    QuitIfFail(pXMLError->get_errorCode(&lErrCode));

    if (lErrCode != 0)
    {
        hr = ReportParseError(pXMLError);
    }
    else
    {
		//
		// no error, so hr = S_FALSE. reset it --- charlma 1/17/01
		//
		hr = S_OK;
    }

CleanUp:
    SafeRelease(pXMLError);
    return hr;
}



//----------------------------------------------------------------------
//
// Helper function FindNode()
//	retrieve the named node
//
//	Input:
//		an IXMLDomNode and a bstr name
//
//	Return:
//		BOOL, tells succeed or not
//
//	Assumption:
//		input parameter not NULL
//		in case of fail, variant not touched
//
//----------------------------------------------------------------------

BOOL
FindNode(
	IXMLDOMNode* pCurrentNode, 
	BSTR bstrName, 
	IXMLDOMNode** ppFoundNode
)
{
	BSTR			bstrTag		= NULL;
	LONG			lLength		= 0L;
	IXMLDOMNode*	pChild		= NULL;
	IXMLDOMNode*	pNextChild	= NULL;

	if (NULL == pCurrentNode ||
		NULL == bstrName ||
		NULL == ppFoundNode)
	{
		return FALSE;
	}

	*ppFoundNode = NULL;

	if (S_OK == pCurrentNode->selectSingleNode(bstrName, &pChild))
	{
		*ppFoundNode = pChild;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



//----------------------------------------------------------------------
//
// Helper function FindNodeValue()
//	retrieve the named data from child of the current node, 
//
//	Input:
//		an IXMLDomNode
//
//	Return:
//		BOOL, tells succeed or not
//
//	Assumption:
//		input parameter not NULL
//		in case of fail, variant not touched
//
//----------------------------------------------------------------------
BOOL
FindNodeValue(
	IXMLDOMNode* pCurrentNode, 
	BSTR bstrName, 
	BSTR* pbstrValue)
{
	IXMLDOMNode* pChild	= NULL;

	if (NULL == pbstrValue)
	{
		return FALSE;
	}
	
	*pbstrValue = NULL;

	if (FindNode(pCurrentNode, bstrName, &pChild))
	{
		pChild->get_text(pbstrValue);
		SafeRelease(pChild);
		return TRUE;
	}

    return FALSE;
}



//----------------------------------------------------------------------
//
// public function Get3IdentiStrFromIdentNode()
//	retrieve the name, publisherName and GUID from an identity node 
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT Get3IdentiStrFromIdentNode(IXMLDOMNode* pIdentityNode, BSTR* pbstrName, BSTR* pbstrPublisherName, BSTR* pbstrGUID)
{
	HRESULT		hr = E_FAIL;
	BOOL		fPublisherNameExist = FALSE, fGUIDExist = FALSE;

	LOG_Block("Get3IdentiStrFromIdentNode()");

	if (NULL == pIdentityNode || NULL == pbstrName || NULL == pbstrPublisherName || NULL == pbstrGUID)
	{
		return E_INVALIDARG;
	}

	*pbstrName = NULL;
	*pbstrPublisherName = NULL;
	*pbstrGUID = NULL;

	//
	// get name attr
	//
	hr = GetAttribute(pIdentityNode, KEY_NAME, pbstrName);
	CleanUpIfFailedAndMsg(hr);

	//
	// try to get publisherName
	//
	fPublisherNameExist = FindNodeValue(pIdentityNode, KEY_PUBLISHERNAME, pbstrPublisherName);

	fGUIDExist = FindNodeValue(pIdentityNode, KEY_GUID, pbstrGUID);

	hr = (fPublisherNameExist || fGUIDExist) ? S_OK : E_FAIL;

CleanUp:
	
	if (FAILED(hr))
	{
		SysFreeString(*pbstrName);
		SysFreeString(*pbstrPublisherName);
		SysFreeString(*pbstrGUID);
		*pbstrName = NULL;
		*pbstrPublisherName = NULL;
		*pbstrGUID = NULL;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// MakeUniqNameString()
//
// This is a utility function to construct the identity name string 
// based on name|publiser|GUID and the rule to make this name string.
//
// This function defines the logic about what components can be used
// to define the uniqueness of an item based on the 3 parts of data from
// GetIdentity().
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MakeUniqNameString(
					BSTR bstrName,
					BSTR bstrPublisher,
					BSTR bstrGUID,
					BSTR* pbstrUniqIdentifierString)
{
    LPWSTR pszResult = NULL;
	DWORD dwLen=0;
	HRESULT hr=S_OK;

	if (NULL == bstrName || SysStringLen(bstrName) == 0 || NULL == pbstrUniqIdentifierString)
	{
		return E_INVALIDARG;
	}

	*pbstrUniqIdentifierString = NULL;

	if (NULL != bstrPublisher && SysStringLen(bstrPublisher) > 0)
	{
		//
		// if we have publisherName, we expect it is
		// reverse DNS name (e.g., com.microsoft), and Name is 
		// the reverse DNS name (e.g., windowsupdate.autoupdate.client)
		// inside that publisher. We combine them with a dot (.)
		//
        // Length of Publisher + Length of Name + 1 for the dot + 1 for null
		dwLen=(SysStringLen(bstrPublisher) + SysStringLen(bstrName) + 2);
        pszResult = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,  dwLen * sizeof(WCHAR));
        
		if (NULL == pszResult)
        {
            return E_OUTOFMEMORY;
        }

		//
		// since we need to work on Win9x too, so we can not use Win32 API
		// for UNICODE, and have to use shlwapi verison
		//

		hr=StringCchCopyExW(pszResult,dwLen,bstrPublisher,NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszResult);
			return hr;
		}


		hr=StringCchCatExW(pszResult,dwLen,L".",NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszResult);
			return hr;
		}

		
		hr=StringCchCatExW(pszResult,dwLen,bstrName,NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszResult);
			return hr;
		}

        *pbstrUniqIdentifierString = SysAllocString(pszResult);
        SafeHeapFree(pszResult);
        if (NULL == *pbstrUniqIdentifierString)
        {
            return E_OUTOFMEMORY;
        }
	}
	else
	{
		if (NULL == bstrGUID || SysStringLen(bstrGUID) == 0)
		{
			return E_INVALIDARG;
		}

		//
		// if no suitable publisherName, then we use GUID
		//
		*pbstrUniqIdentifierString = SysAllocString(bstrGUID);
		if (NULL == *pbstrUniqIdentifierString)
		{
			return E_OUTOFMEMORY;
		}
	}
	return S_OK;
}



//----------------------------------------------------------------------
//
// public function UtilGetUniqIdentityStr()
//	retrieve the unique string that make this <identity> node unique
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetUniqIdentityStr(
	IXMLDOMNode* pIdentityNode, 
	BSTR* pbstrUniqIdentifierString, 
	DWORD dwFlag)
{
	DWORD dwLen=0;
	LOG_Block("UtilGetUniqIdentityStr");

    IXMLDOMNode *pNodeVersion = NULL;
	IXMLDOMNode *pNodeIdentity = NULL;
	BSTR		bstrName = NULL, 
				bstrPublisher = NULL, 
				bstrGuid = NULL,
				bstrResult = NULL;

	USES_IU_CONVERSION;

	if (NULL == pIdentityNode || NULL == pbstrUniqIdentifierString)
	{
		return E_INVALIDARG;
	}
	//
	// retrive string
	//
	HRESULT hr = Get3IdentiStrFromIdentNode(pIdentityNode, &bstrName, &bstrPublisher, &bstrGuid);
	CleanUpIfFailedAndMsg(hr);

	//
	// construct string to make it unique
	//
	hr = MakeUniqNameString(bstrName, bstrPublisher, bstrGuid, &bstrResult);
	CleanUpIfFailedAndMsg(hr);

	//
	// check if this identity has version node. not all have <identity> nodes have <version>
	//
	if (FindNode(pNodeIdentity, KEY_VERSION, &pNodeVersion) && NULL != pNodeVersion)
	{
		TCHAR szVersion[MAX_VERSION];
        LPWSTR pszUniqueString = NULL;

		hr = UtilGetVersionStr(pNodeVersion, szVersion, dwFlag);
		CleanUpIfFailedAndMsg(hr);

		dwLen=(SysStringLen(bstrResult) + lstrlen(szVersion) + 2);
        pszUniqueString = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLen* sizeof(WCHAR));
        CleanUpFailedAllocSetHrMsg(pszUniqueString);
        
		hr=StringCchCopyExW(pszUniqueString,dwLen,bstrResult,NULL,NULL,MISTSAFE_STRING_FLAGS);
		
		if(FAILED(hr))
		{
			SafeHeapFree(pszUniqueString);
			SetHrMsgAndGotoCleanUp(hr);
		}
		hr=StringCchCatExW(pszUniqueString,dwLen,L".",NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszUniqueString);
			SetHrMsgAndGotoCleanUp(hr);
		}

		hr=StringCchCatExW(pszUniqueString,dwLen,T2W(szVersion),NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszUniqueString);
			SetHrMsgAndGotoCleanUp(hr);
		}

        *pbstrUniqIdentifierString = SysAllocString(pszUniqueString);
        SafeHeapFree(pszUniqueString);
	}
	else
	{
		*pbstrUniqIdentifierString = SysAllocString(bstrResult);
	}

    CleanUpFailedAllocSetHrMsg(*pbstrUniqIdentifierString);

    hr = S_OK;

CleanUp:

	SysFreeString(bstrName);
	SysFreeString(bstrPublisher);
	SysFreeString(bstrGuid);
	SysFreeString(bstrResult);

	SafeRelease(pNodeVersion);
	SafeRelease(pNodeIdentity);

	return hr;

}



//----------------------------------------------------------------------
//
// public function UtilGetPlatformStr()
//	retrieve the unique string that make this <platform> node unique
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetPlatformStr(
	IXMLDOMNode* pNodePlatform, 
	BSTR* pbstrPlatform, 
	DWORD dwFlag)
{
	HRESULT hr = E_INVALIDARG;
	IXMLDOMNode*	pNodeVersion = NULL;
	IXMLDOMNode*	pNodeSuite = NULL;
	IXMLDOMNodeList* pSuiteList = NULL;
	IXMLDOMElement* pElement = NULL;

	TCHAR	szPlatformStr[MAX_PLATFORM_STR_LEN],
			szVersion[256];			// should be enough for any version
	
	const TCHAR PART_CONNECTOR[2] = _T("_");
	const HRESULT RET_OVERFLOW = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);


	BSTR	bstrName = NULL,
			bstrProcessor = NULL,
			bstrType = NULL,
			bstrSuite = NULL;

	long	iCount = 0,
			iLength = 0;

	LOG_Block("UtilGetPlatformStr");

	USES_IU_CONVERSION;

	szPlatformStr[0] = _T('\0');

	if (NULL == pNodePlatform || NULL == pbstrPlatform)
	{
		return E_INVALIDARG;
	}

	//
	// get platform name
	//
	if (SUCCEEDED(GetAttribute(pNodePlatform, KEY_NAME, &bstrName)) &&
		NULL != bstrName && SysStringLen(bstrName) > 0)
	{
		iLength = SysStringLen(bstrName);
		CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),OLE2T(bstrName),NULL,NULL,MISTSAFE_STRING_FLAGS));

	}

	//
	// if there is a valid processor architecture, like x86 or alpha, append it
	//
	if (FindNodeValue(pNodePlatform, KEY_PROCESSORARCHITECTURE, &bstrProcessor) &&
		NULL != bstrProcessor && SysStringLen(bstrProcessor) > 0)
	{
		//
		// processor architector should directly append to name, without
		// the connect char "_"
		iLength += SysStringLen(bstrProcessor) ;
		CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),OLE2T(bstrProcessor),NULL,NULL,MISTSAFE_STRING_FLAGS));
	}

	//
	// try to get version code
	//
	hr = (TRUE == FindNode(pNodePlatform, KEY_VERSION, &pNodeVersion)) ? S_OK : E_FAIL;
	
	//
	// if return code is not saying we don't have version node, 
	// then it must be an error
	//
	if (FAILED(hr) && HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	//
	// if we have a version node, try to find the version string
	//
	if (SUCCEEDED(hr))
	{
		hr = UtilGetVersionStr(pNodeVersion, szVersion, dwFlag);
		SafeReleaseNULL(pNodeVersion);
		//
		// if we have a version node, it better be a good one
		//
		CleanUpIfFailedAndMsg(hr);
		iLength += lstrlen(szVersion) + 1 ;
		CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),PART_CONNECTOR,NULL,NULL,MISTSAFE_STRING_FLAGS));
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),szVersion,NULL,NULL,MISTSAFE_STRING_FLAGS));

	}

	//
	// try to get a list of suite nodes
	//
	if (0x0 == (dwFlag & SKIP_SUITES))
	{
		hr = pNodePlatform->QueryInterface(IID_IXMLDOMElement, (void**)&pElement);
		CleanUpIfFailedAndMsg(hr);
		hr = pElement->getElementsByTagName(KEY_SUITE, &pSuiteList);
		CleanUpIfFailedAndMsg(hr);

		//
		// try to get the length of the list, i.e., how many suite node(s)
		//
		hr = pSuiteList->get_length(&iCount);
		CleanUpIfFailedAndMsg(hr);

		//
		// loop through each suite, if any
		//
		pSuiteList->reset();
		for (int i = 0; i < iCount; i++)
		{
			hr = pSuiteList->get_item(i, &pNodeSuite);
			CleanUpIfFailedAndMsg(hr);
			if (pNodeSuite)
			{
				hr = pNodeSuite->get_text(&bstrSuite);
				CleanUpIfFailedAndMsg(hr);
				iLength += SysStringLen(bstrSuite) + 1;
				CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
				
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),PART_CONNECTOR,NULL,NULL,MISTSAFE_STRING_FLAGS));
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),OLE2T(bstrSuite),NULL,NULL,MISTSAFE_STRING_FLAGS));

				pNodeSuite->Release();
				pNodeSuite = NULL;
				SafeSysFreeString(bstrSuite);
			}
		}
		pSuiteList->Release();
		pSuiteList = NULL;
	}

	//
	// if we find a productType node, append its text data
	//
	if (FindNodeValue(pNodePlatform, KEY_PRODUCTTYPE, &bstrType) &&
		NULL != bstrType && SysStringLen(bstrType) > 0)
	{
		iLength += SysStringLen(bstrType) + 1;
		CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),PART_CONNECTOR,NULL,NULL,MISTSAFE_STRING_FLAGS));
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),OLE2T(bstrType),NULL,NULL,MISTSAFE_STRING_FLAGS));
	}

	*pbstrPlatform = SysAllocString(T2OLE(szPlatformStr));

	LOG_XML(_T("Got platform string %s"), szPlatformStr);

	hr = S_OK;

CleanUp:

	SysFreeString(bstrName);
	SysFreeString(bstrProcessor);
	SysFreeString(bstrSuite);
	SysFreeString(bstrType);
	SafeRelease(pNodeVersion);
	SafeRelease(pNodeSuite);
	SafeRelease(pSuiteList);
	SafeRelease(pElement);
	return hr;
}

    

//----------------------------------------------------------------------
//
// public function UtilGetVersionStr()
//	retrieve the data from this <version> in string format
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetVersionStr(
	IXMLDOMNode* pVersionNode, 
	LPTSTR pszVersion, 
	DWORD dwFlag)
{
	HRESULT hr = E_INVALIDARG;
	LONG iMajor = -1,
		iMinor = -1,
		iBuild = -1,
		iSvcPackMajor = -1,
		iSvcPackMinor = -1;

	LOG_Block("UtilGetVersionStr()");

	BSTR bstrTimestamp = NULL;
	BSTR bstrVersion = NULL;
	TCHAR szNumber[16];			// enough to store a positive integer

	BOOL fLastChunkExists = FALSE;

	USES_IU_CONVERSION;

	if (NULL == pVersionNode || NULL == pszVersion)
	{
		return hr;
	}

	*pszVersion = _T('\0');

	//
	// a version node can contain either text version data (for binaries), 
	// or attribute version data (for OS). If both exist, we prefer text data
	// 
	if (SUCCEEDED(pVersionNode->get_text(&bstrVersion)) && NULL != bstrVersion &&
		SysStringLen(bstrVersion) > 0)
	{
		lstrcpyn(pszVersion, OLE2T(bstrVersion), MAX_VERSION);
	}
	else
	{
		if (SUCCEEDED(GetAttribute(pVersionNode, KEY_MAJOR, &iMajor)) && iMajor > 0)
		{
		
			//It's an  assumption that  the pszVersion will be atleast MAX_VERSION characters wide
			CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(pszVersion,MAX_VERSION,NULL,NULL,MISTSAFE_STRING_FLAGS, _T("%d"),iMajor));
		
			if (SUCCEEDED(GetAttribute(pVersionNode, KEY_MINOR, &iMinor)) && iMinor >= 0)
			{
				
				CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szNumber,ARRAYSIZE(szNumber),NULL,NULL,MISTSAFE_STRING_FLAGS, _T(".%d"),iMinor));
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,szNumber,NULL,NULL,MISTSAFE_STRING_FLAGS));
				
				if (SUCCEEDED(GetAttribute(pVersionNode, KEY_BUILD, &iBuild)) && iBuild >= 0)
				{
					CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szNumber,ARRAYSIZE(szNumber),NULL,NULL,MISTSAFE_STRING_FLAGS, _T(".%d"),iBuild));
					CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,szNumber,NULL,NULL,MISTSAFE_STRING_FLAGS));
				}
			}
			fLastChunkExists = TRUE;
		}

		if (0x0 == (dwFlag & SKIP_SERVICEPACK_VER) &&
			SUCCEEDED(GetAttribute(pVersionNode, KEY_SERVICEPACKMAJOR, &iSvcPackMajor)) &&
			iSvcPackMajor > 0)
		{
			if (fLastChunkExists)
			{
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,_T(","),NULL,NULL,MISTSAFE_STRING_FLAGS));
			}
			
			
			CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szNumber,ARRAYSIZE(szNumber),NULL,NULL,MISTSAFE_STRING_FLAGS, _T("%d"),iSvcPackMajor));
			CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,szNumber,NULL,NULL,MISTSAFE_STRING_FLAGS));
			
			if (SUCCEEDED(GetAttribute(pVersionNode, KEY_SERVICEPACKMINOR, &iSvcPackMinor)) &&
				iSvcPackMinor >= 0)
			{	
				CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szNumber,ARRAYSIZE(szNumber),NULL,NULL,MISTSAFE_STRING_FLAGS,_T(".%d"),iSvcPackMinor));
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,szNumber,NULL,NULL,MISTSAFE_STRING_FLAGS));
			}
			fLastChunkExists = TRUE;
		}
		else
		{
			fLastChunkExists = FALSE;
		}

		if (SUCCEEDED(GetAttribute(pVersionNode, KEY_TIMESTAMP, &bstrTimestamp)) &&
			NULL != bstrTimestamp && SysStringLen(bstrTimestamp) > 0)
		{
			if (fLastChunkExists)
			{
				
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,_T(","),NULL,NULL,MISTSAFE_STRING_FLAGS));
				
			}
			else
			{
				//
				// if we need to append timestamp, and we didn't get service pack
				// data, we want to leave extra separator "," to tell the following
				// part is timestamp and service pack data missing.
				//
				if (*pszVersion != _T('\0'))
				{
					CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,_T(",,"),NULL,NULL,MISTSAFE_STRING_FLAGS));
					
				}
				//
				// if this is the first chunk we found, then no prefix needed
				// 
			}

			CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,OLE2T(bstrTimestamp),NULL,NULL,MISTSAFE_STRING_FLAGS));
		}
	}

	//
	// if we got something, then this is a valid version node and
	// we can pass back whatever we got. Otherwise we return E_INVALIDARG
	//
	if (*pszVersion != _T('\0'))
	{
		LOG_XML(_T("Got version str %s"), pszVersion);
		hr = S_OK;	
	}

CleanUp:
	SysFreeString(bstrTimestamp);
	SysFreeString(bstrVersion);

	return hr;
}



//-----------------------------------------------------------------------
//
// function GetFullFilePathFromFilePathNode()
//
//	retrieve the full qualified file path from a filePath node
//
// Input:
//		a filePath XMLDom node
//		a pointer to a buffer to receive path, assumes MAX_PATH long.
//
// Return:
//		HRESULT
//		Found path: S_OK
//		Not found path: S_FALSE, lpszFilePath is empty
//		otherwise, error code
//
//		
//-----------------------------------------------------------------------

HRESULT GetFullFilePathFromFilePathNode(
			IXMLDOMNode* pFilePathNode,
			LPTSTR lpszFilePath
)
{
	HRESULT hr = S_OK;
	LOG_Block("GetFullFilePathFromFilePathNode");

	USES_IU_CONVERSION;

	IXMLDOMNode* pRegKeyNode = NULL;
	
	TCHAR	szPath[MAX_PATH] = {_T('\0')};

	LPTSTR	lpszFileName	= NULL;
	LPTSTR	lpszKey			= NULL;
	LPTSTR	lpszValue		= NULL;
	LPTSTR	lpszPath		= NULL;

	BSTR	bstrName		= NULL;
	BSTR	bstrPath		= NULL;
	BSTR	bstrKey			= NULL;
	BSTR	bstrValue		= NULL;

	BOOL	fPathExists		= FALSE;

	UINT	nReqSize		= 0;


	if (NULL == pFilePathNode || NULL == lpszFilePath)
	{
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	//
	// init path buffer
	//
	*lpszFilePath = _T('\0');

	//
	// try to get name data, note: S_FALSE won't do, it means everything is
	// fine but this attribute does not exist.
	//
	if (S_OK == (hr = GetAttribute(pFilePathNode, KEY_NAME, &bstrName)))
	{
		//
		// found name attribute
		//
		lpszFileName = OLE2T(bstrName);		
		LOG_XML(_T(" file name=%s"), lpszFileName);
		fPathExists = TRUE;
	}


	if (FindNode(pFilePathNode, KEY_REGKEY, &pRegKeyNode) && NULL != pRegKeyNode)
	{
		//
		// found a reg key node
		//
		if (!FindNodeValue(pRegKeyNode, KEY_KEY, &bstrKey))
		{
			//
			// key node is required!
			//
			hr = E_INVALIDARG;
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}

		lpszKey = OLE2T(bstrKey);
		LOG_XML(_T("Found key=%s"), lpszKey);

		//
		// get optional value name
		//
		if (FindNodeValue(pRegKeyNode, KEY_ENTRY, &bstrValue))
		{
			lpszValue = OLE2T(bstrValue);
			LOG_XML(_T("found entry=%s"), lpszValue);
		}
		else
		{
			LOG_XML(_T("found no value, use default"));
		}

		if (GetFilePathFromReg(lpszKey, lpszValue, NULL, NULL, szPath) && _T('\0') != *szPath)
		{
			//
			// various reason can me this call fail, such as
			// reg key wrong, no access to reg key, out of memory, etc
			// 
			fPathExists = TRUE;
		}

	}

	if (FindNodeValue(pFilePathNode, KEY_PATH, &bstrPath) && SysStringLen(bstrPath) > 0)
	{
		//
		// found path element
		//
		lpszPath = OLE2T(bstrPath);
		fPathExists = TRUE;
	}

	if (!fPathExists)
	{
		//
		// nothing exist
		//
		lpszFilePath[0] = _T('\0');
		LOG_XML(_T("empty node!"));
		hr = S_FALSE;
		goto CleanUp;
	}

	nReqSize = lstrlen(szPath) + SysStringLen(bstrPath) + SysStringLen(bstrName);

	if (nReqSize >= MAX_PATH ||
		NULL != lpszPath && FAILED(PathCchAppend(szPath,MAX_PATH,lpszPath)) ||			// append path to reg path
		NULL != lpszFileName && FAILED(PathCchAppend(szPath,MAX_PATH,lpszFileName)))		// append name
	{
		LOG_ErrorMsg(ERROR_BUFFER_OVERFLOW);
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		goto CleanUp;
	}

	if (FAILED (hr = ExpandFilePath(szPath, lpszFilePath, MAX_PATH)))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

CleanUp:

	SysFreeString(bstrName);
	SysFreeString(bstrPath);
	SysFreeString(bstrKey);
	SysFreeString(bstrValue);
	SafeRelease(pRegKeyNode);
	return hr;

}



HRESULT GetBstrFullFilePathFromFilePathNode(
			IXMLDOMNode* pFilePathNode,
			BSTR* pbstrFilePath
)
{
	HRESULT hr = S_OK;
	
	USES_IU_CONVERSION;

	TCHAR szPath[MAX_PATH];

	QuitIfNull(pbstrFilePath);
	*pbstrFilePath = NULL;
	if (SUCCEEDED(hr = GetFullFilePathFromFilePathNode(pFilePathNode, szPath)))
	{
		*pbstrFilePath = SysAllocString(T2OLE(szPath));
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
//
// Helper function DoesNodeHaveName()
//
//	find out the the current node has a matching name
//
//	Input:
//			a node
//
//	Return:
//			TRUE/FALSE
//
/////////////////////////////////////////////////////////////////////////////
BOOL DoesNodeHaveName(IXMLDOMNode* pNode, BSTR bstrTagName)
{
	BSTR	bstrName;
	BOOL	fRet = FALSE;
	IXMLDOMElement* pElement = NULL;

	if (NULL == pNode)
	{
		return fRet;
	}

	if (FAILED(pNode->QueryInterface(IID_IXMLDOMElement, (void**) &pElement)) || NULL == pElement)
	{
		return FALSE;
	}

	if (SUCCEEDED(pElement->get_nodeName(&bstrName)))
	{
		fRet = CompareBSTRsEqual(bstrName, bstrTagName);
	}

	SysFreeString(bstrName);
	SafeReleaseNULL(pElement);

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\testkeys\wutestkeys.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:	WUTESTKEYS.CPP
//  Module: WUTESTKEYS.LIB
//
//***********************************************************************************
#include <iucommon.h>
#include <fileutil.h>
#include <trust.h>
#include <shlobj.h>
#include <memutil.h>
#include <advpub.h>
#include <WUTestKeys.h>

#define HOUR (60 * 60)
#define DAY (24 * HOUR)
#define TWO_WEEKS (14 * DAY)

const DWORD MAX_FILE_SIZE = 200;    //Maximum expected file size in bytes
const TCHAR WU_DIR[] = _T("\\WindowsUpdate\\");
const CHAR WU_SENTINEL_STRING[] = "Windows Update Test Key Authorization File\r\n";

//function to check if the specified file is a valid WU test file
BOOL IsValidWUTestFile(LPCTSTR lpszFilePath);

// This function returns true if the specified file is a valid WU Test Authorization file
BOOL WUAllowTestKeys(LPCTSTR lpszFileName)
{
    TCHAR szWUDirPath[MAX_PATH + 1];
    TCHAR szFilePath[MAX_PATH + 1];
    TCHAR szTxtFilePath[MAX_PATH+1];
    TCHAR szTextFile[MAX_PATH+1];          

    if (S_OK != SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, szWUDirPath) ||
        FAILED(StringCchCatEx(szWUDirPath, ARRAYSIZE(szWUDirPath), WU_DIR, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {        
        return FALSE;
    } 
    if (NULL == lpszFileName || 
        FAILED(StringCchCopyEx(szFilePath, ARRAYSIZE(szFilePath), szWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
        FAILED(StringCchCatEx(szFilePath, ARRAYSIZE(szFilePath), lpszFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
        !FileExists(szFilePath))
    {
        return FALSE;
    }
    //The filename of the compressed text file should be the same as the name of the cab file
    _tsplitpath(lpszFileName, NULL, NULL, szTextFile, NULL);    
    if(FAILED(StringCchCatEx(szTextFile, ARRAYSIZE(szTextFile), _T(".txt"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        return FALSE;
    }
    //Verify the cab is signed with a Microsoft Cert and extract the file 
    if (FAILED(VerifyFileTrust(szFilePath, NULL, FALSE, TRUE)) ||
        !IUExtractFiles(szFilePath, szWUDirPath, szTextFile))
    {
        return FALSE;
    }
    //Generate path to the txt file. The filename should be the same as the name of the cab file
    if (!ReplaceFileExtension(szFilePath, _T(".txt"), szTxtFilePath, ARRAYSIZE(szTxtFilePath)))
    {
    	return FALSE;
    }
    //Check if it is a valid WU test file
    BOOL fRet = IsValidWUTestFile(szTxtFilePath);
    DeleteFile(szTxtFilePath);       //Delete the uncabbed file
    return fRet;
}

/*****************************************************************************************
//This function will open the specified file and parse it to make sure:
//  (1) The file has the WU Test Sentinel string at the top
//  (2) The time stamp on the file is not more than 2 weeks old and 
//      that it is not a future time stamp.
//   The format of a valid file should be as follows:
//      WINDOWSUPDATE_SENTINEL_STRING
//      YYYY.MM.DD HH:MM:SS
*****************************************************************************************/
BOOL IsValidWUTestFile(LPCTSTR lpszFilePath)
{
    USES_IU_CONVERSION;
    DWORD cbBytesRead = 0;
    const DWORD cbSentinel = ARRAYSIZE(WU_SENTINEL_STRING) - 1;     //Size of the sentinel string
    //Ansi buffer to read file data
    CHAR szFileData[MAX_FILE_SIZE+1];                        
    ZeroMemory(szFileData, ARRAYSIZE(szFileData));
    BOOL fRet = FALSE;
 
    HANDLE hFile = CreateFile(lpszFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) 
    {
        goto done;
    }
    //If the file size is greater than MAX_FILE_SIZE then bail out
    DWORD cbFile = GetFileSize(hFile, NULL);
    if(cbFile == INVALID_FILE_SIZE || cbFile > MAX_FILE_SIZE)
    {
        goto done;
    }
    if(!ReadFile(hFile, &szFileData, cbFile, &cbBytesRead, NULL) ||
        cbBytesRead != cbFile)
    {
        goto done;
    }
    //Compare with sentinel string
    if(0 != memcmp(szFileData, WU_SENTINEL_STRING, cbSentinel))
    {     
        goto done;
    }

    LPTSTR tszTime = A2T(szFileData + cbSentinel);
    if(tszTime == NULL)
    {
        goto done;
    }
    SYSTEMTIME tmCur, tmFile;
    if(FAILED(String2SystemTime(tszTime, &tmFile)))
    {
        goto done;
    }
	GetSystemTime(&tmCur);
    int iSecs = TimeDiff(tmFile, tmCur);  
    //If the time stamp is less than 2 weeks old and not newer than current time than it is valid
    fRet = iSecs > 0 && iSecs < TWO_WEEKS;
    
done:
    if(hFile != INVALID_HANDLE_VALUE)
    {
		CloseHandle(hFile);
	}
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\trust\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	trust
#
# Abstract:		trust checking for use by IU project
#
MAJORCOMP=windows.com
MINORCOMP=lib.Trust

TARGETNAME=Trust
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\Trust.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\trust\stdafx.h ===
//
// StdAfx.h
//
//		Stand-in for precompiled header, so that trust.cpp can be properly
//		included in projects that use precompiled headers.
//
// History:
//
//		2001-11-05  KenSh     Created
//

#pragma once

#include <windows.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\trust\trustpriv.h ===
//
// TrustPriv.h
//
//		Some private trust settings for trust.cpp
//
// History:
//
//		2001-11-05  KenSh     Created
//

#pragma once

//
// Disable IU logging if requested
//
#ifdef DISABLE_IU_LOGGING
inline void __cdecl LOG_Block(LPCSTR, ...) { }
inline void __cdecl LOG_Error(LPCTSTR, ...) { }
inline void __cdecl LOG_Trust(LPCTSTR, ...) { }
inline void __cdecl LogError(HRESULT, LPCSTR, ...) { }
inline void LOG_ErrorMsg(HRESULT) { }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\urlagent\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	util
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.UrlAgent

TARGETNAME=UrlAgent
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\UrlAgent.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\trust\trust.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//      No portion of this source code may be reproduced
//      without express written permission of Microsoft Corporation.
//
//      This source code is proprietary and confidential.
//
//  SYSTEM:     Industry Update
//
//  CLASS:      N/A
//  MODULE:     TRUST.LIB
//  FILE:       Trust.CPP
//
/////////////////////////////////////////////////////////////////////
//
//  DESC:   this file implements the functions used to make cabs 
//			signed by certain providers trusted.
//          
//
//  AUTHOR: Charles Ma, converted from WU CDMLIB
//  DATE:   10/4/2000
//
/////////////////////////////////////////////////////////////////////
//
//  Revision History:
//
//  Date    Author          Description
//  ~~~~    ~~~~~~          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <wintrust.h>
#include <softpub.h>
#include "trust.h"
#include "TrustPriv.h"
#include "wusafefn.h"

#if !defined(DISABLE_IU_LOGGING)
#include <MemUtil.h>
#include <logging.h>
#endif

#if defined(DEBUG) || defined(DBG)
	#ifdef DISABLE_IU_POLICY		// in debug mode, we enable pop up check
		#undef DISABLE_IU_POLICY
	#endif
#else
	#define DISABLE_IU_POLICY		// in release mode, we never allow cert pop up!
#endif

#if defined(__WUIUTEST) || !defined(DISABLE_IU_POLICY)
const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
#endif

/////////////////////////////////////////////////////////////////////////////
// 
// typedefs for APIs used in the CheckTrust() function
//
//      Since some of these APIs are new and only available on IE5 we have to
//      try to dynamicaly use them when available and do without the extra checks
//      when we are on an OS that has not been upgraded to the new crypto code.
//
/////////////////////////////////////////////////////////////////////////////


#define WINTRUST _T("wintrust.dll")
#define CRYPT32  _T("crypt32.dll")

#if !defined(USES_IU_CONVERSION) && defined(USES_CONVERSION)
#define USES_IU_CONVERSION USES_CONVERSION
#endif

//
// declare a global crypt32.dll library handler, so we don't
// need to load the library every time these functions are called.
// NOTE: we do not release the library though. When the process of
// calling this feature exits, the library is released.
// same as wintrust.dll
//
static HINSTANCE shWinTrustDllInst = NULL;
static HINSTANCE shCrypt32DllInst = NULL;


//
// define prototype for function WinVerifyTrust()
// and declare a global variable to point to this function
//
typedef HRESULT 
(WINAPI * PFNWinVerifyTrust)(
                        HWND hwnd, GUID *ActionID, LPVOID ActionData);
PFNWinVerifyTrust pfnWinVerifyTrust = NULL; 


//
// define prototype for function WTHelperProvDataFromStateData()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_DATA * 
(WINAPI * PFNWTHelperProvDataFromStateData)(
						HANDLE hStateData);
PFNWTHelperProvDataFromStateData pfnWTHelperProvDataFromStateData = NULL;


//
// define prototype for function WTHelperGetProvSignerFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_SGNR * 
(WINAPI * PFNWTHelperGetProvSignerFromChain)(
						CRYPT_PROVIDER_DATA *pProvData,
						DWORD idxSigner,
						BOOL fCounterSigner,
						DWORD idxCounterSigner);
PFNWTHelperGetProvSignerFromChain pfnWTHelperGetProvSignerFromChain = NULL;


//
// define prototype for function PFNWTHelperGetProvCertFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_CERT * 
(WINAPI * PFNWTHelperGetProvCertFromChain)(
						CRYPT_PROVIDER_SGNR *pSgnr,
						DWORD idxCert);
PFNWTHelperGetProvCertFromChain pfnWTHelperGetProvCertFromChain = NULL;


//
// define prototype for function CryptHashPublicKeyInfo()
// and declare a global variable to point to this function
//
typedef BOOL 
(WINAPI * PFNCryptHashPublicKeyInfo)(
						HCRYPTPROV hCryptProv,
						ALG_ID Algid,
						DWORD dwFlags,
						DWORD dwCertEncodingType,
						PCERT_PUBLIC_KEY_INFO pInfo,
						BYTE *pbComputedHash,
						DWORD *pcbComputedHash);
PFNCryptHashPublicKeyInfo pfnCryptHashPublicKeyInfo = NULL;


//
// define prototype for function CertGetCertificateContextProperty()
// and declare a global variable to point to this function
//
typedef BOOL 
(WINAPI * PFNCertGetCertificateContextProperty)(
						PCCERT_CONTEXT pCertContext,          
						DWORD dwPropId,                       
						void *pvData,                         
						DWORD *pcbData);
PFNCertGetCertificateContextProperty pfnCertGetCertificateContextProperty = NULL;



/////////////////////////////////////////////////////////////////////////////
// 
// pre-defined cert data to check against
//
/////////////////////////////////////////////////////////////////////////////

//
// The following is the sha1 key identifier for the Microsoft root
//
static const BYTE rgbSignerRootKeyIds[40] = {
    0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,		// the original MS root
    0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D,

	0x0E, 0xAC, 0x82, 0x60, 0x40, 0x56, 0x27, 0x97, 0xE5, 0x25,		// the new "son of MS root"
    0x13, 0xFC, 0x2A, 0xE1, 0x0A, 0x53, 0x95, 0x59, 0xE4, 0xA4

};


//
// define the size of each hash values in the known id buffer
// for special certs.
//
const size_t ExpectedKnownCertHashSize = 20;

//
// this is the size of buffer to receive the cert hash value
// it must be not less than the largest number in the
// above-defined array
//
const size_t ShaBufSize = 20;

//
// id buffer to store SH1 hashing values of known Microsoft
// certs (signature) that we should recognize.
// Warning: the size of this buffer should match the sum 
// of size_t values defined above.
//
static const BYTE rgbSpecialCertId[200] = {
	0xB1,0x59,0xA5,0x2E,0x3D,0xD8,0xCE,0xCD,0x3A,0x9A,0x4A,0x7A,0x73,0x92,0xAA,0x8D,0xA7,0xE7,0xD6,0x7F,	// MS cert
	0xB1,0xC7,0x75,0xE0,0x4A,0x9D,0xFD,0x23,0xB6,0x18,0x97,0x11,0x5E,0xF6,0xEA,0x6B,0x99,0xEC,0x76,0x1D,	// MSN cert
	0x11,0xC7,0x10,0xF3,0xCB,0x6C,0x43,0xE1,0x66,0xEC,0x64,0x1C,0x7C,0x01,0x17,0xC4,0xB4,0x10,0x35,0x30,	// MSNBC cert
	0x95,0x25,0x58,0xD4,0x07,0xDE,0x4A,0xFD,0xAE,0xBA,0x13,0x72,0x83,0xC2,0xB3,0x37,0x04,0x90,0xC9,0x8A,	// MSN Europe
	0x72,0x54,0x14,0x91,0x1D,0x6E,0x10,0x84,0x8E,0x0F,0xFA,0xA0,0xB0,0xA1,0x65,0xBF,0x44,0x8F,0x9F,0x6D,	// MS Europe
	0x20,0x5E,0x48,0x43,0xAB,0xAD,0x54,0x77,0x71,0xBD,0x8D,0x1A,0x3C,0xE0,0xE5,0x9D,0xF5,0xBD,0x25,0xF9,	// Old MS cert: 97~98
	0xD6,0xCD,0x01,0x90,0xB3,0x1B,0x31,0x85,0x81,0x12,0x23,0x14,0xB5,0x17,0xA0,0xAA,0xCE,0xF2,0x7B,0xD5,	// Old MS cert: 98~99
	0x8A,0xA1,0x37,0xF5,0x03,0x9F,0xE0,0x28,0xC9,0x26,0xAA,0x55,0x90,0x14,0x19,0x68,0xFA,0xFF,0xE8,0x1A,	// Old MS cert: 99~00
	0xF3,0x25,0xF8,0x67,0x07,0x29,0xE5,0x27,0xF3,0x77,0x52,0x34,0xE0,0x51,0x57,0x69,0x0F,0x40,0xC6,0x1C,	// Old MS Europe cert: 99~00
	0x6A,0x71,0xFE,0x54,0x8A,0x51,0x08,0x70,0xF9,0x8A,0x56,0xCA,0x11,0x55,0xF6,0x76,0x45,0x92,0x02,0x5A     // Old MS Europe cert: 98~99

};




/////////////////////////////////////////////////////////////////////////////
// 
// Private Function ULONG CompareMem(PVOID pBlock1, PVOID pBlock2, ULONG Length)
//
//      This function acts in the same way as RtlCompareMemory() 
//
//
// Input:   two pointers to two memory blocks, and a byte size to compare
// Return:  the number of bytes that compared as equal. 
//			If all bytes compare as equal, the input Length is returned.
//			If any pointer is NULL, 0 is returned.
//
/////////////////////////////////////////////////////////////////////////////
ULONG CompareMem(const BYTE* pBlock1, const BYTE* pBlock2, ULONG Length)
{
	ULONG uLen = 0L;
	if (pBlock1 != NULL && pBlock2 != NULL)
	{
		for (; uLen < Length; uLen++, pBlock1++, pBlock2++)
		{
			if (*pBlock1 != *pBlock2) return uLen;
		}
	}
	return uLen;
}






/////////////////////////////////////////////////////////////////////////////
// 
// Private Function VerifyMSRoot()
//
//      This function takes the passed-in certificate as a root cert,
//		and verifies its public key hash value is the same as 
//		known "Microsoft Root Authority" cert value.
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//			pRootCert - the certificate context of the root cert
//
// Return:  HRESULT - result of execution, S_OK if matched.
//			the result code, in case of error, are code retuned by
//			crypt32.dll, with these the exception of E_INVALIDARG if
//			the passed-in parameters are NULL.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT VerifyMSRoot(
					 HINSTANCE hCrypt32DllInst,			// handle point to loaded crypt32.dll librar
					 PCCERT_CONTEXT pRootCert
					 )
{
	HRESULT hr = S_OK;
	BYTE	rgbKeyId[ExpectedKnownCertHashSize];
    DWORD	cbKeyId = sizeof(rgbKeyId);

	LOG_Block("VerifyMSRoot()");

	//
	// valid parameter values
	//
	if (NULL == hCrypt32DllInst || NULL == pRootCert)
	{
		hr = E_INVALIDARG;
		goto ErrHandler;
	}

	//
	// get the function we need from the passed in library handle
	// If not available, return error
	//
	if (NULL == (pfnCryptHashPublicKeyInfo = (PFNCryptHashPublicKeyInfo)
		GetProcAddress(hCrypt32DllInst, "CryptHashPublicKeyInfo")))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto ErrHandler;
	}

	//
	// get the public key hash value of this cert
	//
	ZeroMemory(rgbKeyId, sizeof(rgbKeyId));
    if (!pfnCryptHashPublicKeyInfo(
							0,						// use default crypto svc provider
							CALG_SHA1,				// use SHA algorithm
							0,						// dwFlags
							X509_ASN_ENCODING,
							&pRootCert->pCertInfo->SubjectPublicKeyInfo,
							rgbKeyId,
							&cbKeyId
							))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ErrHandler;
	}

	//
	// compare the hash value of public key of this root cert with the known MS root cert value
	//
	if (ExpectedKnownCertHashSize != cbKeyId || 
		(cbKeyId != CompareMem(rgbSignerRootKeyIds, rgbKeyId, cbKeyId) &&
		 cbKeyId != CompareMem(rgbSignerRootKeyIds + ExpectedKnownCertHashSize, rgbKeyId, cbKeyId)
		)
	   )
	{
		hr = S_FALSE;
	}


ErrHandler:

	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		LOG_Trust(_T("Exit VerifyMSRoot() with %s"), (S_OK == hr) ? _T("S_OK") : _T("S_FALSE"));
	}

	return hr;
}





/////////////////////////////////////////////////////////////////////////////
// 
// Private Function VerifySpecialMSCerts()
//
//      This function takes the passed-in certificate as a leaf cert,
//		and verifies its hash value matches the hash value of one of
//		known Microsoft special certs that does not have MS root.
//
//		The known certs are, in comparing order:
//			Microsoft Corporation
//			Microsoft Corporation MSN
//			MSNBC Interactive News LLC
//			Microsoft Corporation MSN (Europe)
//			Microsoft Corporation (Europe)
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//			pRootCert - the certificate context of the root cert
//			pbSha1HashVal - if not NULL, compare to this one, instead of
//							hard-coded hash values. this is the case
//							of working on 3rd party package
//
// Return:  HRESULT - result of execution, S_OK if matched.
//			if not matched, CERT_E_UNTRUSTEDROOT, or
//			E_INVALIDARG if arguments not right, or
//			crypt32.dll error returned by API calls
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyKnownCerts(					 
							 HINSTANCE hCrypt32DllInst,			// handle point to loaded crypt32.dll librar
							 PCCERT_CONTEXT pLeafCert,
							 pCERT_HASH_ARRAY pKnownCertsData
							 )
{
	HRESULT hr = S_FALSE;
	BYTE	btShaBuffer[ShaBufSize];
	DWORD	dwSize = sizeof(btShaBuffer);
	BYTE const * pId;

	LOG_Block("VerifyKnownCerts()");

	//
	// valid parameter values
	//
	if (NULL == hCrypt32DllInst || NULL == pLeafCert)
	{
		hr = E_INVALIDARG;
		goto ErrHandler;
	}

	//
	// get the function we need from the passed in library handle
	// If not available, return error
	//
	if (NULL == (pfnCertGetCertificateContextProperty = (PFNCertGetCertificateContextProperty)
		GetProcAddress(hCrypt32DllInst, "CertGetCertificateContextProperty")))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto ErrHandler;
	}
	
	//
	// find out the id hash of leaf cert
	//
	ZeroMemory(btShaBuffer, dwSize);
	if (!pfnCertGetCertificateContextProperty(
						pLeafCert,					// pCertContext
						CERT_SHA1_HASH_PROP_ID,	// dwPropId
						btShaBuffer,
						&dwSize
						))
	{
		hr = GetLastError();
		goto ErrHandler;
	}


	if (NULL == pKnownCertsData)
	{
		int		i;
		//
		// iterrate through all known id hash values to see if this file is signed
		// with any of these special certs.
		//
		hr = S_FALSE;
		for (i = 0,pId = rgbSpecialCertId; 
			 i < sizeof(rgbSpecialCertId)/ExpectedKnownCertHashSize; 
			 i++, pId += ExpectedKnownCertHashSize)
		{
			if (ExpectedKnownCertHashSize == dwSize &&
				dwSize == CompareMem(btShaBuffer, pId, dwSize))
			{
				//
				// found a matching known cert!
				//
				hr = S_OK;
				LOG_Trust(_T("Found hash matching on #%d of %d MS certs!"), i, sizeof(rgbSpecialCertId)/ExpectedKnownCertHashSize);
				break;
			}
		}
	}
	else
	{
		//
		// check if the retrieved hashing value matches the one passed in.
		//
		UINT i;
		LOG_Trust(_T("Comparing retrieved hash value with passed-in key"));
		hr = S_FALSE;
		for (i = 0, pId = pKnownCertsData->pCerts; i < pKnownCertsData->uiCount;
			i++, pId += HASH_VAL_SIZE)
		{
			if (dwSize == HASH_VAL_SIZE &&
				HASH_VAL_SIZE == CompareMem(btShaBuffer, pId, HASH_VAL_SIZE))
			{
				hr = S_OK;
				LOG_Trust(_T("Found hash matching #%d of %d passed-in certs!"),
							i, pKnownCertsData->uiCount);
				break;
			}
		}
	}

ErrHandler:

	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		LOG_Trust(_T("Exit VerifyKnownCerts() with %s"), (S_OK == hr) ? _T("S_OK") : _T("S_FALSE"));
	}

	return hr;


}





/////////////////////////////////////////////////////////////////////////////
// 
// Private Function CheckWinTrust()
//
//      This function will return the HRESULT for the trust state on the
//      specified file. The file can be pointing to any URL or local file.
//      The verification will be done by the wintrust.dll. 
//
//      dwUIChoice is WTD_UI_NONE, WTD_UI_ALL, etc. (defined in wintrust.h).
//		dwCheckRevocation is WTD_REVOKE_NONE (default) or WTD_REVOKE_WHOLE_CHAIN.
//
// Input:   Fully qualified filename, UIChoice, dwCheckRevocation
// Return:  HRESULT - result of execution
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CheckWinTrust(LPCTSTR pszFileName, pCERT_HASH_ARRAY pCertsData, DWORD dwUIChoice, DWORD dwCheckRevocation)
{

	LOG_Block("CheckWinTrust()");

#if !defined(UNICODE) && !defined(_UNICODE)
	USES_IU_CONVERSION;
#endif

    // Now verify the file
    WINTRUST_DATA               winData;
    WINTRUST_FILE_INFO          winFile;
    GUID                        gAction = WINTRUST_ACTION_GENERIC_VERIFY_V2; 
    CRYPT_PROVIDER_DATA const   *pProvData = NULL;
    CRYPT_PROVIDER_SGNR         *pProvSigner = NULL;
    CRYPT_PROVIDER_CERT	        *pProvCert = NULL;
    HRESULT                     hr = S_OK;


#ifdef __WUIUTEST
	{
		LOG_Trust(_T("CheckWinTrust _IUTEST Handling Begins"));
		//
		// handling test case:
		// if a reg key value is set to 1, then we will see if we need to pop up ALL certs
		//
		// NOTE:
		//
		// for the certs that user has checked "Always trust this provider..." previously, 
		// WinCheckTrust() API will still NOT show any UI even if we signal Show-ALL flag
		//
		HKEY	hkey;
		DWORD	dwWinTrustUI = 0;
		DWORD	dwSize = sizeof(dwWinTrustUI);

		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ, &hkey)) 
		{
			RegQueryValueEx(hkey, _T("WinTrustUI"), 0, 0, (LPBYTE)&dwWinTrustUI, &dwSize);
			RegCloseKey(hkey);
			LOG_Trust(_T("Found regval %s\\WinTrustUI=%x"), REGKEY_IUCTL, dwWinTrustUI);
		}
		if (0x1 == dwWinTrustUI && WTD_UI_NONE != dwUIChoice)
		{
			//
			// if there is a WinTrustUI reg key exist, and value is 1
			// and caller does not request silence, then we
			// pop up all certs
			//
			LOG_Trust(_T("Change UI choice to WTD_UI_ALL"));
			dwUIChoice = WTD_UI_ALL;
		}

		if (0x2 == dwWinTrustUI)
		{
			//
			// if reg vlaue is 2, we pop up any cert no matter caller 
			// says showing UI or not
			//
			LOG_Trust(_T("Changed UI choice from %d to WTD_UI_NOGOOD"));
			dwUIChoice = WTD_UI_ALL;
		}

		if (0x3 == dwWinTrustUI)
		{
			//
			// if reg value is 3, we pop up bad (include test) cert no matter
			// caller allow showing UI or not
			// 
			LOG_Trust(_T("Changed UI choice from %d to WTD_UI_NOGOOD"));
			dwUIChoice = WTD_UI_NOGOOD;
		}

	}
#endif


	//
	// dynamically load the wintrust.dll
	//
	if (NULL == shWinTrustDllInst)
	{
		if (NULL == (shWinTrustDllInst = LoadLibraryFromSystemDir(WINTRUST)))
		{
			LOG_Error(_T("Failed to load libary %s, exit function."), WINTRUST);
            hr = HRESULT_FROM_WIN32(GetLastError());
		    goto Done;
		}
	}

	//
	// dynamically load the crypt32.dll, which will be used by the two
	// helper functions to verify the cert is MS cert
	//
	if (NULL == shCrypt32DllInst)
	{
		if (NULL == (shCrypt32DllInst = LoadLibraryFromSystemDir(CRYPT32)))
		{
			LOG_Error(_T("Failed to load libary %s, exit function."), CRYPT32);
            hr = HRESULT_FROM_WIN32(GetLastError());
		    goto Done;
		}
	}
	//
	// find the functions we need
	//
	if (NULL == (pfnWinVerifyTrust = (PFNWinVerifyTrust)
				GetProcAddress(shWinTrustDllInst, "WinVerifyTrust")) ||
		NULL == (pfnWTHelperProvDataFromStateData = (PFNWTHelperProvDataFromStateData)
				GetProcAddress(shWinTrustDllInst, "WTHelperProvDataFromStateData")) ||
		NULL == (pfnWTHelperGetProvSignerFromChain = (PFNWTHelperGetProvSignerFromChain) 
				GetProcAddress(shWinTrustDllInst, "WTHelperGetProvSignerFromChain")) ||
		NULL == (pfnWTHelperGetProvCertFromChain = (PFNWTHelperGetProvCertFromChain)
				GetProcAddress(shWinTrustDllInst, "WTHelperGetProvCertFromChain")))
	{
		//
		// at least one function was not found in the loaded cryp32.dll libary.
		// we can not continue, jsut quit. 
		// NOTE: this shouldn't happen since we have tried to get 
		// the least common denomination of different version of this dll
		// on both IE4 and IE5
		//
		LOG_Error(_T("CheckWinTrust() did not find functions needed from %s"), CRYPT32);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto Done;
	}


	//
	// initialize the data structure used to verify trust
	//
    winFile.cbStruct       = sizeof(WINTRUST_FILE_INFO);
    winFile.hFile          = INVALID_HANDLE_VALUE;
    winFile.pcwszFilePath  = T2COLE(pszFileName);
    winFile.pgKnownSubject = NULL;

    winData.cbStruct            = sizeof(WINTRUST_DATA);
    winData.pPolicyCallbackData = NULL;
    winData.pSIPClientData      = NULL;
    winData.dwUIChoice          = (WTD_UI_ALL == dwUIChoice) ? dwUIChoice : WTD_UI_NONE;
    winData.fdwRevocationChecks = WTD_REVOKE_NONE;
    winData.dwUnionChoice       = WTD_CHOICE_FILE;
    winData.dwStateAction       = WTD_STATEACTION_VERIFY;
    winData.hWVTStateData       = 0;
    winData.dwProvFlags         = WTD_REVOCATION_CHECK_NONE;
    winData.pFile               = &winFile;

	if (dwCheckRevocation == WTD_REVOKE_WHOLECHAIN)
	{
		winData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
		winData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN;
	}

	//
	// verify the signature
	//
    hr = pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

	//
	// Ignore errors when retrieving Cert Revocation List (CRL). This
	// just means the list itself couldn't be retrieved, not that the
	// current cert was invalid or revoked. (KenSh, 2002/01/17)
	//
	if (hr == CERT_E_REVOCATION_FAILURE)
	{
		hr = S_OK;
	}

    if (FAILED(hr))
    {
        //
        // The object isn't even trusted so just get out here
        //
		LOG_Error(_T("When processing %s found error 0x%0x."), pszFileName, hr);
        goto Return;
    }


	//
	// the real usage should never pass in WTD_UI_ALL. If this is the case, 
	// then we are calling this recursively in order to force the show
	// a good but non-MS cert only, so no need to check MS cert again.
	//
	// or, in test mode, we always do this part
	//
	if (WTD_UI_ALL != dwUIChoice)
	{
		//
		// if come to here, it means all above verified okay.
		//
		// the rset of code is used to verify the signed cert is
		// a known cert.
		//
		
		hr = S_FALSE;

		pProvData = pfnWTHelperProvDataFromStateData(winData.hWVTStateData);
    
		pProvSigner = pfnWTHelperGetProvSignerFromChain(
										(PCRYPT_PROVIDER_DATA) pProvData, 
										0,      // first signer
										FALSE,  // not a counter signer
										0);

		//
		// check root cert then check leaf (signing) cert if that fails
		//
		// 0 is signing cert, csCertChain-1 is root cert
		//


		if (NULL == pCertsData)
		{
			//
			// if caller does not specify a hash value, then it means we want
			// to verify if this cert is known MS cert. We will first
			// try to find out if it is signed with a cert that has MS as root.
			//
			pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, pProvSigner->csCertChain - 1);
			hr = VerifyMSRoot(shCrypt32DllInst, pProvCert->pCert);	
		}

		if (S_OK != hr)
		{
			pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, 0);

			hr = VerifyKnownCerts(shCrypt32DllInst, pProvCert->pCert, pCertsData);
		}


	}

Return:

    //
    // free the wintrust state that was used to get the cert in the chain
    //
    winData.dwStateAction = WTD_STATEACTION_CLOSE;
    pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

	//
	// recursively call this function if not in test mode so we can show
	// UI for this non-MS but good cert.
	// Only the two functions checking MS cert will return S_FALSE
	//
	if (S_OK != hr)
	{
		if (WTD_UI_NOGOOD == dwUIChoice)
		{
			//
			// we need to show UI, so we will have to call this thing again
			// in case this is not a MS cert. From UI, if user clicks YES
			// then the return value will be S_OK;
			//
			hr = CheckWinTrust(pszFileName, NULL, WTD_UI_ALL, dwCheckRevocation);
			LOG_Error(_T("CheckWinTrust() found file not signed by a known MS cert. If user has not checked \"Always trust this\", UI should be shown, and user selected %s"), 
				SUCCEEDED(hr) ? _T("YES") : _T("NO"));
		}
		else
		{
			LOG_Error(_T("CheckWinTrust() found file not signed by a known cert!"));
#if defined(UNICODE) || defined(_UNICODE)
			LogError(hr, "Digital Signatures on file %ls are not trusted",  pszFileName);
#else
			LogError(hr, "Digital Signatures on file %s are not trusted",  pszFileName);
#endif
			hr = TRUST_E_SUBJECT_NOT_TRUSTED;
		}
	}

	if (WTD_UI_ALL != dwUIChoice)
	{
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
#if defined(UNICODE) || defined(_UNICODE)
			LogError(hr, "Digital Signatures on file %ls are not trusted",  pszFileName);
#else
			LogError(hr, "Digital Signatures on file %s are not trusted",  pszFileName);
#endif
		}
		else
		{
			LOG_Trust(_T("CheckWinTrust(%s) returns S_OK"), pszFileName);
		}
	}

Done:
    if (NULL != shWinTrustDllInst)
    {
        FreeLibrary(shWinTrustDllInst);
        shWinTrustDllInst = NULL;
    }
    if (NULL != shCrypt32DllInst)
    {
        FreeLibrary(shCrypt32DllInst);
        shCrypt32DllInst = NULL;
    }

    return (hr); 
}    



/////////////////////////////////////////////////////////////////////////////
// 
// Public Function VerifyFileTrust()
//
// This is a wrapper function for CheckWinTrust that both Whistler 
// and WU classic code should use.
//
// Input:	szFileName - the file with complete path
//			pbSha1HashVal - hash value of a known good cert
//			fShowBadUI - whether pop up UI in cases 
//						 (1) inproperly signed signature, 
//						 (2) properly signed but not signed by a known cert
//
// Return:	HRESULT - S_OK the file is signed with a valid known cert
//					  or error code.
//
// Note:	If _WUV3TEST flag is set (for test build), then fShowBadUI is
//			ignored:
//				if reg key SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\wuv3test\WinTrustUI
//				is set to 1, then no UI is shown, and this function always return S_OK;
//				otherwise, UI always show no matter what cert, and return value is same
//				as the live build.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyFileTrust(
						IN LPCTSTR szFileName,
						IN pCERT_HASH_ARRAY pCertsData,
						BOOL fShowBadUI,
						BOOL fCheckRevocation /*=FALSE*/
						)
{
	DWORD dwUIChoice = fShowBadUI ? WTD_UI_NOGOOD : WTD_UI_NONE;
	DWORD dwCheckRevocation = fCheckRevocation ? WTD_REVOKE_WHOLECHAIN : WTD_REVOKE_NONE;

	return CheckWinTrust(szFileName, pCertsData, dwUIChoice, dwCheckRevocation);
}


/////////////////////////////////////////////////////////////////////////////
// 
// Public Function ReadWUPolicyShowTrustUI()
//
// Input:   void
//
// Return:  BOOL - FALSE means ShowTrustUI regkey is not present, or is set to 0
//                 TRUE means ShowTrustUI regkey is present and is set to 1
//
//
/////////////////////////////////////////////////////////////////////////////
BOOL ReadWUPolicyShowTrustUI()
{
#if !defined(DISABLE_IU_POLICY)
    LOG_Block("ReadWUPolicyShowTrustUI()");
    HKEY hkey;
    DWORD dwShowTrustUI = 0; // if the key is not present, default to not showing any UI
    DWORD dwSize = sizeof(dwShowTrustUI);

    if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ, &hkey)) 
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, _T("WUPolicyShowTrustUI"), 0, 0, (LPBYTE)&dwShowTrustUI, &dwSize))
        {
            LOG_Trust(_T("Found regval %s\\WUPolicyShowTrustUI=%x"), REGKEY_IUCTL, dwShowTrustUI);
        }
        RegCloseKey(hkey);
    }

    return (1 == dwShowTrustUI);    
#else
	//
	// for released build, we never show up UI
	//
	return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\urllogging\urllogging.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	URLLogging.cpp
//
//  Description:
//
//		URL logging utility class
//		This class helps you construct the server ping URL and
//		then send the ping to the designed server.
//
//		The default base URL is defined in IUIdent, under section [IUPingServer]
//		and entry is "ServerUrl".
//
//		This class implements single-thread version only. So it is suitable
//		to call it at operation level, i.e., create a separate object
//		for each operation in a single thread.
//
//		The ping string send to the ping server has the following format:
//			/wutrack.bin
//			?U=<user>
//			&C=<client>
//			&A=<activity>
//			&I=<item>
//			&D=<device>
//			&P=<platform>
//			&L=<language>
//			&S=<status>
//			&E=<error>
//			&M=<message>
//			&X=<proxy>
//		where
//			<user>		a static 128-bit value that unique-ifies each copy
//						of Windows installed.  The class will automatically
//						reuse one previously assigned to the running OS; or
//						will generate one if it does not exist.
//			<client>	a string that identifies the entity that performed
//						activity <activity>.  Here are the possible values
//						and their meanings:
//							"iu"			IU control
//							"au"			Automatic Updates
//							"du"			Dynamic Update
//							"CDM"			Code Download Manager
//							"IU_SITE"		IU Consumer site
//							"IU_Corp"		IU Catalog site
//			<activity>	a letter that identifies the activity performed.
//						Here are the possible values and their meanings:
//							"n"				IU control initization
//							"d"				detection
//							"s"				self-update
//							"w"				download
//							"i"				installation
//			<item>		a string that identifies an update item.
//			<device>	a string that identifies either a device's PNPID when
//						device driver not found during detection; or a
//						PNPID/CompatID used by item <item> for activity
//						<activity> if the item is a device driver.
//			<platform>	a string that identifies the platform of the running
//						OS and processor architecture.  The class will
//						compute this value for the pingback.
//			<language>	a string that identifies the language of the OS
//						binaries.  The class will compute this value for the
//						pingback.
//			<status>	a letter that specifies the status that activity
//						<activity> reached.  Here are the possible values and
//						 their meanings:
//							"s"				succeeded
//							"r"				succeeded (reboot required)
//							"f"				failed
//							"c"				cancelled by user
//							"d"				declined by user
//							"n"				no items
//							"p"				pending
//			<error>		a 32-bit error code in hex (w/o "0x" as prefix).
//			<message>	a string that provides additional information for the
//						status <status>.
//			<proxy>		a 32-bit random value in hex for overriding proxy
//						caching.  This class will compute this value for
//						each pingback.
//
//=======================================================================

#include <tchar.h>
#include <windows.h>		// ZeroMemory()
#include <shlwapi.h>		// PathAppend()
#include <stdlib.h>			// srand(), rand(), malloc() and free()
#include <sys/timeb.h>		// _ftime() and _timeb
#include <malloc.h>			// malloc() and free()

#include <fileutil.h>		// GetIndustryUpdateDirectory()
#include <logging.h>		// LOG_Block, LOG_ErrorMsg, LOG_Error and LOG_Internet
#include <MemUtil.h>		// USES_IU_CONVERSION, W2T() and T2W()
#include <osdet.h>			// LookupLocaleString()
#include <download.h>		// DownloadFile()
#include <wusafefn.h>		// PathCchAppend()
#include <safefunc.h>		// SafeFreeNULL()
#include <MISTSafe.h>

#include <URLLogging.h>

// Header of the log file
typedef struct tagULHEADER
{
	WORD wVersion;		// file version
} ULHEADER, PULHEADER;

#define ARRAYSIZE(x)	(sizeof(x)/sizeof(x[0]))

#define CACHE_FILE_VERSION	((WORD) 10004)	// must be bigger what we had in V3 (10001)

// bug 600602: must end all server URL with '/'
const TCHAR c_tszLiveServerUrl[] = _T("http://wustat.windows.com/");


HRESULT ValidateFileHeader(HANDLE hFile, BOOL fCheckHeader, BOOL fFixHeader);

#ifdef DBG
BOOL MustPingOffline(void)
{
	BOOL fRet = FALSE;
	HKEY hkey;

	if (NO_ERROR == RegOpenKeyEx(
						HKEY_LOCAL_MACHINE,
						_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate"),
						0,
						KEY_QUERY_VALUE | KEY_SET_VALUE,
						&hkey))
	{
		DWORD	dwForceOfflinePing;
		DWORD	dwSize = sizeof(dwForceOfflinePing);
		DWORD	dwType;

		if (NO_ERROR == RegQueryValueEx(
							hkey,
							_T("ForceOfflinePing"),
							0,
							&dwType,
							(LPBYTE) &dwForceOfflinePing,
							&dwSize))
		{
			if (REG_DWORD == dwType &&
				sizeof(dwForceOfflinePing) == dwSize &&
				1 == dwForceOfflinePing)
			{
				fRet = TRUE;
			}
		}
		RegCloseKey(hkey);
	}
	return fRet;
}
#endif

// ----------------------------------------------------------------------------------
//
// PUBLIC MEMBER FUNCTIONS
//
// ----------------------------------------------------------------------------------

CUrlLog::CUrlLog(void)
: m_ptszLiveServerUrl(NULL), m_ptszCorpServerUrl(NULL)
{
	Init();
	m_tszDefaultClientName[0] = _T('\0');
}


CUrlLog::CUrlLog(LPCTSTR ptszClientName, LPCTSTR ptszLiveServerUrl, LPCTSTR ptszCorpServerUrl)
: m_ptszLiveServerUrl(NULL), m_ptszCorpServerUrl(NULL)
{
	Init();
	(void) SetDefaultClientName(ptszClientName);
	(void) SetLiveServerUrl(ptszLiveServerUrl);
	(void) SetCorpServerUrl(ptszCorpServerUrl);
}


CUrlLog::~CUrlLog(void)
{
	if (NULL != m_ptszLiveServerUrl)
	{
		free(m_ptszLiveServerUrl);
	}
	if (NULL != m_ptszCorpServerUrl)
	{
		free(m_ptszCorpServerUrl);
	}
}

// Assume ptszServerUrl, if non-NULL, is of size INTERNET_MAX_URL_LENGTH in TCHARs
BOOL CUrlLog::SetServerUrl(LPCTSTR ptszUrl, LPTSTR & ptszServerUrl)
{
	LPTSTR ptszEnd = NULL;
	size_t cchRemaining = 0;

	if (NULL == ptszUrl ||
		_T('\0') == *ptszUrl)
	{
		SafeFreeNULL(ptszServerUrl);
	}
	else if (
		// Ensure ptszServerUrl is malloc'ed
		(NULL == ptszServerUrl &&
		 NULL == (ptszServerUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH))) ||
		// Copy URL
		FAILED(StringCchCopyEx(ptszServerUrl, INTERNET_MAX_URL_LENGTH, ptszUrl, &ptszEnd, &cchRemaining, MISTSAFE_STRING_FLAGS)) ||
		// Ensure URL ending with '/'
		(_T('/') != ptszEnd[-1] &&
		 FAILED(StringCchCopyEx(ptszEnd, cchRemaining, _T("/"), NULL, NULL, MISTSAFE_STRING_FLAGS))))
	{
		SafeFreeNULL(ptszServerUrl);
		return FALSE;
	}
	return TRUE;
}


// Watch out for the size of m_tszDefaultClientName.
BOOL CUrlLog::SetDefaultClientName(LPCTSTR ptszClientName)
{
	if (NULL == ptszClientName)
	{
		// E_INVALIDARG
		m_tszDefaultClientName[0] = _T('\0');
		return FALSE;
	}

	return SUCCEEDED(StringCchCopyEx(m_tszDefaultClientName, ARRAYSIZE(m_tszDefaultClientName), ptszClientName, NULL, NULL, MISTSAFE_STRING_FLAGS));
}


HRESULT CUrlLog::Ping(
				BOOL fOnline,			// online or offline ping
				URLLOGDESTINATION destination,	// live or corp WU ping server
				PHANDLE phQuitEvents,	// ptr to handles for cancelling the operation
				UINT nQuitEventCount,	// number of handles
				URLLOGACTIVITY activity,// activity code
				URLLOGSTATUS status,	// status code
				DWORD dwError,			// error code
				LPCTSTR ptszItemID,		// uniquely identify an item
				LPCTSTR ptszDeviceID,	// PNPID or CompatID
				LPCTSTR ptszMessage,	// additional info
				LPCTSTR ptszClientName)	// client name string
{
	LOG_Block("CUrlLog::Ping");

	LPTSTR	ptszUrl = NULL;
	HRESULT hr = E_FAIL;

	switch (activity)
	{
	case URLLOGACTIVITY_Initialization:	// fall thru
	case URLLOGACTIVITY_Detection:		// fall thru
	case URLLOGACTIVITY_SelfUpdate:		// fall thru
	case URLLOGACTIVITY_Download:		// fall thru
	case URLLOGACTIVITY_Installation:
		break;
	default:
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	switch (status)
	{
	case URLLOGSTATUS_Success:		// fall thru
	case URLLOGSTATUS_Reboot:		// fall thru
	case URLLOGSTATUS_Failed:		// fall thru
	case URLLOGSTATUS_Cancelled:	// fall thru
	case URLLOGSTATUS_Declined:		// fall thru
	case URLLOGSTATUS_NoItems:		// fall thru
	case URLLOGSTATUS_Pending:
		break;
	default:
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	//
	// handle optional (nullable) arguments
	//
	if (NULL == ptszClientName)
	{
		ptszClientName = m_tszDefaultClientName;
	}

	if (_T('\0') == *ptszClientName)
	{
		LOG_Error(_T("client name not initialized"));
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	switch (destination)
	{
	case URLLOGDESTINATION_DEFAULT:
		destination = (
			NULL == m_ptszCorpServerUrl ||
			_T('\0') == *m_ptszCorpServerUrl) ?
			URLLOGDESTINATION_LIVE :
			URLLOGDESTINATION_CORPWU;
		break;
	case URLLOGDESTINATION_LIVE:	// fall thru
	case URLLOGDESTINATION_CORPWU:
		break;
	default:
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	LPCTSTR ptszServerUrl;

	if (URLLOGDESTINATION_LIVE == destination)
	{
		if (NULL != m_ptszLiveServerUrl)
		{
			ptszServerUrl = m_ptszLiveServerUrl;
		}
		else
		{
			ptszServerUrl = c_tszLiveServerUrl;
		}
	}
	else
	{
		ptszServerUrl = m_ptszCorpServerUrl;
	}

	if (NULL == ptszServerUrl ||
		_T('\0') == *ptszServerUrl)
	{
		LOG_Error(_T("status server Url not initialized"));
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	if (NULL == (ptszUrl = (TCHAR*) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)))
	{
		hr = E_OUTOFMEMORY;
		goto CleanUp;
	}

	if (FAILED(hr = MakePingUrl(
						ptszUrl,
						INTERNET_MAX_URL_LENGTH,
						ptszServerUrl,
						ptszClientName,
						activity,
						ptszItemID,
						ptszDeviceID,
						status,
						dwError,
						ptszMessage)))
	{
		goto CleanUp;
	}

	if (fOnline)
	{
		hr = PingStatus(destination, ptszUrl, phQuitEvents, nQuitEventCount);
		if (SUCCEEDED(hr))
		{
			(void) Flush(phQuitEvents, nQuitEventCount);
			goto CleanUp;
		}
	}

	{
		USES_IU_CONVERSION;

		LPWSTR pwszUrl = T2W(ptszUrl);
		HRESULT hr2;

		if (NULL == pwszUrl)
		{
			hr = E_OUTOFMEMORY;
			goto CleanUp;
		}

		ULENTRYHEADER ulentryheader;
		ulentryheader.progress = URLLOGPROGRESS_ToBeSent;
		ulentryheader.destination = destination;
		ulentryheader.wRequestSize = lstrlen(ptszUrl) + 1;
		ulentryheader.wServerUrlLen = (WORD) lstrlen(ptszServerUrl);

		if (SUCCEEDED(hr2 = SaveEntry(ulentryheader, pwszUrl)))
		{
			hr = S_FALSE;
		}
		else if (SUCCEEDED(hr))
		{
			hr = hr2;
		}
	}

CleanUp:
	if (NULL != ptszUrl)
	{
		free(ptszUrl);
	}

	return hr;
}


// ----------------------------------------------------------------------------------
//
// PRIVATE MEMBER FUNCTIONS
//
// ----------------------------------------------------------------------------------

// Init member variables within a constructor.  No memory clean-up done here.
void CUrlLog::Init()
{
	LookupPingID();
	LookupPlatform();
	LookupSystemLanguage();
	GetLogFileName();
}


// ----------------------------------------------------------------------------------
//	Construct a URL used to ping server
//
//	Returned value indicates success/failure
// ----------------------------------------------------------------------------------
HRESULT CUrlLog::MakePingUrl(
			LPTSTR	ptszUrl,			// buffer to receive result
			int		cChars,				// the number of chars this buffer can take, including ending null
			LPCTSTR ptszBaseUrl,		// server URL
			LPCTSTR ptszClientName,		// which client called
			URLLOGACTIVITY activity,
			LPCTSTR ptszItemID,
			LPCTSTR ptszDeviceID,
			URLLOGSTATUS status,
			DWORD	dwError,			// return code of activity
			LPCTSTR	ptszMessage)
{
	HRESULT hr = E_FAIL;
	LPTSTR ptszEscapedItemID = NULL;
	LPTSTR ptszEscapedDeviceID = NULL;
	LPTSTR ptszEscapedMessage = NULL;

	LOG_Block("CUrlLog::MakePingUrl");

	// Retry to get info strings if we failed within the constructor.
	if (_T('\0') == m_tszPlatform[0] ||
		_T('\0') == m_tszLanguage[0])
	{
		LOG_Error(_T("Invalid platform or language info string"));
		hr = E_UNEXPECTED;
		goto CleanUp;
	}

	// allocate enough memory for URL manipulation. Since the buffer needs
	// to be at least 2Kbytes in size, stack buffer is not suitable here.
	// we involve mem utility to similate stack memory allocation
	if ((NULL != ptszItemID &&
		 (NULL == (ptszEscapedItemID = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) ||
		  !EscapeString(ptszItemID, ptszEscapedItemID, INTERNET_MAX_URL_LENGTH))) ||
		(NULL != ptszDeviceID &&
		 (NULL == (ptszEscapedDeviceID = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) ||
		  !EscapeString(ptszDeviceID, ptszEscapedDeviceID, INTERNET_MAX_URL_LENGTH))) ||
		(NULL != ptszMessage &&
		 (NULL == (ptszEscapedMessage = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) ||
		  !EscapeString(ptszMessage, ptszEscapedMessage, INTERNET_MAX_URL_LENGTH))))
	{
		// Either out-of-memory or the escaped string is too lengthy.
		LOG_Error(_T("Out of memory or EscapeString failure"));
		hr = E_OUTOFMEMORY;	// actually could be HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) as well
		goto CleanUp;
	}

	const TCHAR c_tszEmpty[] = _T("");

	// Use system time as proxy cache breaker
	SYSTEMTIME st;

	GetSystemTime(&st);

	hr = StringCchPrintfEx(
				ptszUrl,
				cChars,
				NULL,
				NULL,
				MISTSAFE_STRING_FLAGS,
				_T("%swutrack.bin?U=%s&C=%s&A=%c&I=%s&D=%s&P=%s&L=%s&S=%c&E=%08x&M=%s&X=%02d%02d%02d%02d%02d%02d%03d"),
				NULL == ptszBaseUrl ? c_tszEmpty : ptszBaseUrl,					// server URL
				m_tszPingID,														// ping ID
				ptszClientName,													// client name
				activity,														// activity code
				NULL == ptszEscapedItemID ? c_tszEmpty : ptszEscapedItemID,		// escaped item ID
				NULL == ptszEscapedDeviceID ? c_tszEmpty : ptszEscapedDeviceID,	// escaped device ID
				m_tszPlatform,													// platform info
				m_tszLanguage,													// sys lang info
				status,															// status code
				dwError,														// activity error code
				NULL == ptszEscapedMessage ? c_tszEmpty : ptszEscapedMessage,	// escaped message str
				st.wYear % 100,													// proxy override
				st.wMonth,
				st.wDay,
				st.wHour,
				st.wMinute,
				st.wSecond,
				st.wMilliseconds);

CleanUp:
	if (NULL != ptszEscapedItemID)
	{
		free(ptszEscapedItemID);
	}
	if (NULL != ptszEscapedDeviceID)
	{
		free(ptszEscapedDeviceID);
	}
	if (NULL != ptszEscapedMessage)
	{
		free(ptszEscapedMessage);
	}

	return hr;
}



// Obtain the existing ping ID from the registry, or generate one if not available.
void CUrlLog::LookupPingID(void)
{
	const TCHAR c_tszRegKeyWU[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate");
	const TCHAR c_tszRegUrlLogPingID[] = _T("PingID");

	BOOL	fRet = FALSE;
	LONG	lErr;
	HKEY	hkey;
	UUID	uuidPingID;

	LOG_Block("CUrlLog::LookupPingID");

	//fixcode: wrap registry manipulation w/ a critical section

	if (NO_ERROR == (lErr = RegOpenKeyEx(
								HKEY_LOCAL_MACHINE,
								c_tszRegKeyWU,
								0,
								KEY_QUERY_VALUE | KEY_SET_VALUE,
								&hkey)))
	{
		BOOL	fFixValue = TRUE;
		DWORD	dwSize = sizeof(uuidPingID);
		DWORD	dwType;

		lErr = RegQueryValueEx(
					hkey,
					c_tszRegUrlLogPingID,
					0,
					&dwType,
					(LPBYTE) &uuidPingID,
					&dwSize);
		if (NO_ERROR == lErr)
		{
			if (REG_BINARY == dwType && sizeof(uuidPingID) == dwSize)
			{
				// successfully read ping ID from registry
				fFixValue = FALSE;
				fRet = TRUE;
			}
		}
		else if (ERROR_MORE_DATA == lErr || ERROR_FILE_NOT_FOUND == lErr)
		{
			// Data not of right length or not found.
			// We will try to fix it.  Treat it as no error for now.
			lErr = NO_ERROR;
		}

		if (NO_ERROR == lErr)
		{
			if (fFixValue)
			{
				MakeUUID(&uuidPingID);
				lErr = RegSetValueEx(
							hkey,
							c_tszRegUrlLogPingID,
							0,
							REG_BINARY,
							(CONST BYTE*) &uuidPingID,
							sizeof(uuidPingID));
				if (NO_ERROR == lErr)
				{
					fRet = TRUE;	// This is not a final value yet. Still depends on RegCloseKey().
				}
#ifdef DBG
				else
				{
					LOG_ErrorMsg(lErr);
				}
#endif
			}
		}
#ifdef DBG
		else
		{
			LOG_ErrorMsg(lErr);
		}
#endif

		if (NO_ERROR != (lErr = RegCloseKey(hkey)))
		{
			if (fFixValue)
			{
				fRet = FALSE;
			}
			LOG_ErrorMsg(lErr);
		}
	}
#ifdef DBG
	else
	{
		LOG_ErrorMsg(lErr);
	}
#endif

	if (!fRet)
	{
		// Only happens if something failed.
		// Make a ping ID of zeroes.
		ZeroMemory(&uuidPingID, sizeof(uuidPingID));
	}

	LPTSTR p = m_tszPingID;
	LPBYTE q = (LPBYTE) &uuidPingID;
	for (int i = 0; i<sizeof(uuidPingID); i++, q++)
	{
		BYTE nibble = *q >> 4;	// high nibble
		*p++ = nibble >= 0xA ? _T('a') + (nibble - 0xA) : _T('0') + nibble;
		nibble = *q & 0xF;	// low nibble
		*p++ = nibble >= 0xA ? _T('a') + (nibble - 0xA) : _T('0') + nibble;
	}
	*p = _T('\0');
}



// Obtain platfrom info for ping
void CUrlLog::LookupPlatform(void)
{
	LOG_Block("CUrlLog::LookupPlatform");

	m_tszPlatform[0] = _T('\0');

	OSVERSIONINFOEX osversioninfoex;

	ZeroMemory(&osversioninfoex, sizeof(osversioninfoex));

	// pretend to be OSVERSIONINFO for W9X/Mil
	osversioninfoex.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (!GetVersionEx((LPOSVERSIONINFO) &osversioninfoex))
	{
		LOG_ErrorMsg(GetLastError());
		return;
	}

	if (VER_PLATFORM_WIN32_NT == osversioninfoex.dwPlatformId &&
		(5 <= osversioninfoex.dwMajorVersion ||
		 (4 == osversioninfoex.dwMajorVersion &&
		  6 <= osversioninfoex.wServicePackMajor)))
	{
		// OS is Windows NT/2000 or later: Windows NT 4.0 SP6 or later.
		// It supports OSVERSIONINFOEX.
		osversioninfoex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);	// use actual size

		if (!GetVersionEx((LPOSVERSIONINFO) &osversioninfoex))
		{
			LOG_ErrorMsg(GetLastError());
			return;
		}
	}

	SYSTEM_INFO systeminfo;

	GetSystemInfo(&systeminfo);

	(void) StringCchPrintfEx(
						m_tszPlatform,
						ARRAYSIZE(m_tszPlatform),
						NULL,
						NULL,
						MISTSAFE_STRING_FLAGS,
						_T("%lx.%lx.%lx.%lx.%x.%x.%x"),
						osversioninfoex.dwMajorVersion,
						osversioninfoex.dwMinorVersion,
						osversioninfoex.dwBuildNumber,
						osversioninfoex.dwPlatformId,
						osversioninfoex.wSuiteMask,
						osversioninfoex.wProductType,
						systeminfo.wProcessorArchitecture);
}



// Obtain system language info for ping
void CUrlLog::LookupSystemLanguage(void)
{
	LOG_Block("CUrlLog::LookupSystemLanguage");

	(void) LookupLocaleString(m_tszLanguage, ARRAYSIZE(m_tszLanguage), FALSE);

	if (0 == _tcscmp(m_tszLanguage, _T("Error")))
	{
		LOG_Error(_T("call to LookupLocaleString() failed."));
		m_tszLanguage[0] = _T('\0');
	}
}

	
// Ping server to report status
//		ptszUrl - the URL string to be pinged
//		phQuitEvents - ptr to handles for cancelling the operation
//		nQuitEventCount - number of handles
HRESULT CUrlLog::PingStatus(URLLOGDESTINATION destination, LPCTSTR ptszUrl, PHANDLE phQuitEvents, UINT nQuitEventCount) const
{
#ifdef DBG
	LOG_Block("CUrlLog::PingStatus");

	LOG_Internet(_T("Ping request=\"%s\""), ptszUrl);

	if (MustPingOffline())
	{
		LOG_Internet(_T("ForceOfflinePing = 1"));
		return HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
	}
#endif

	if (!IsConnected(ptszUrl, URLLOGDESTINATION_LIVE == destination))
	{
		// There is no connection.
		LOG_ErrorMsg(ERROR_CONNECTION_INVALID);
		return HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
	}

	if (!HandleEvents(phQuitEvents, nQuitEventCount))
	{
		LOG_ErrorMsg(E_ABORT);
		return E_ABORT;
	}

	TCHAR tszIUdir[MAX_PATH];

	GetIndustryUpdateDirectory(tszIUdir);

	DWORD dwFlags = WUDF_CHECKREQSTATUSONLY;	// we don't actually need a file,
												//  just need to check return code
	if (URLLOGDESTINATION_CORPWU == destination)
	{
		// don't allow proxy if destination is corp WU
		dwFlags |= WUDF_DONTALLOWPROXY;
	}

	HRESULT hr = DownloadFile(
					ptszUrl, 
					tszIUdir,	// local directory to download file to
					NULL,		// optional local file name for downloaded file
								// if pszLocalPath doesn't contain a file name
					NULL,		// ptr to bytes downloaded for this file
					phQuitEvents,	// quit event, if signalled, abort downloading
					nQuitEventCount,
					NULL,
					NULL,		// parameter for call back function to use
					dwFlags
					);
#ifdef DBG
	if (FAILED(hr))
	{
		LOG_Error(_T("DownloadFile() returned error %lx"), hr);
	}
#endif

	return hr;
}



// Obtain file names for offline ping
void CUrlLog::GetLogFileName(void)
{
	const TCHAR c_tszLogFile_Local[] = _T("urllog.dat");

	GetIndustryUpdateDirectory(m_tszLogFile);

	if (FAILED(PathCchAppend(m_tszLogFile, ARRAYSIZE(m_tszLogFile), c_tszLogFile_Local)))
	{
		m_tszLogFile[0] = _T('\0');
	}
}


// Read cache entry header and request in entry
//		hFile - an open file handle to read the entry from
//		ulentryheader - reference to the struct to store the entry header
//		pwszBuffer - the WCHAR buffer to store the request (including trailing null character) in the entry
//		dwBufferSize - the size of buffer in WCHARs
// Returned value:
//		S_OK - entry successfully read
//		S_FALSE - no more entry to read from the file
//		other - error codes
HRESULT CUrlLog::ReadEntry(HANDLE hFile, ULENTRYHEADER & ulentryheader, LPWSTR pwszBuffer, DWORD dwBufferSize) const
{
	LOG_Block("CUrlLog::ReadEntry");

	DWORD dwBytes;
	DWORD dwErr;

	if (!ReadFile(
			hFile,
			&ulentryheader,
			sizeof(ulentryheader),
			&dwBytes,
			NULL))
	{
		// We failed to read the entry header.
		// There is nothing we can do at this point.
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		return HRESULT_FROM_WIN32(dwErr);
	}

	if (0 == dwBytes)
	{
		// This is the end of the file.
		// There is no other entries after this point.
		return S_FALSE;
	}

	if (sizeof(ulentryheader) < dwBytes ||
		(URLLOGPROGRESS_ToBeSent != ulentryheader.progress &&
		 URLLOGPROGRESS_Sent != ulentryheader.progress) ||
		(URLLOGDESTINATION_LIVE != ulentryheader.destination &&
		 URLLOGDESTINATION_CORPWU != ulentryheader.destination) ||
		dwBufferSize < ulentryheader.wRequestSize ||
		ulentryheader.wRequestSize <= ulentryheader.wServerUrlLen)
	{
		LOG_Error(_T("Invalid entry header"));
		return E_FAIL;
	}

	if (!ReadFile(
				hFile,
				pwszBuffer,
				sizeof(WCHAR) * ulentryheader.wRequestSize,
				&dwBytes,
				NULL))
	{
		// We failed to read the string in the entry.
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		return HRESULT_FROM_WIN32(dwErr);
	}

	if (dwBytes < sizeof(WCHAR) * ulentryheader.wRequestSize ||
		_T('\0') != pwszBuffer[ulentryheader.wRequestSize-1] ||
		ulentryheader.wRequestSize-1 != lstrlenW(pwszBuffer))
	{
		// The entry does not contain the complete string.
		return E_FAIL;
	}

	return S_OK;
}


// Save a string to the log file
//		destination - going to the live or corp WU ping server
//		wServerUrlLen - length of server URL part of the request, in WCHARs (not including trailing NULL)
//		pwszString - the string to be saved into the specific log file
// Returned value:
//		S_OK - entry was written to file
//		S_FALSE - the file was created by a CUrlLog class of newer version than this; entry was not written to file
//		other - error codes; entry was not written to file
HRESULT CUrlLog::SaveEntry(ULENTRYHEADER & ulentryheader, LPCWSTR pwszString) const
{
	HRESULT		hr;
	BOOL		fDeleteFile = FALSE;
	HANDLE		hFile = INVALID_HANDLE_VALUE;
	DWORD		dwBytes;

	LOG_Block("CUrlLog::SaveEntry");

	LOG_Internet(
			_T("destination = %s"),
			URLLOGDESTINATION_LIVE == ulentryheader.destination ? _T("live") : _T("corp WU"));

	if (_T('\0') == m_tszLogFile[0])
	{
		hr = E_UNEXPECTED;
		LOG_Error(_T("log file name not initialized"));
		goto CleanUp;
	}

	if(INVALID_HANDLE_VALUE == (hFile = CreateFile(
							m_tszLogFile,
							GENERIC_READ | GENERIC_WRITE,
							0,						// no sharing
							NULL,
							OPEN_ALWAYS,
							FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_RANDOM_ACCESS,
							NULL)))
	{
		// We failed to open or create the file.
		// Someone may be currently using it.

		//fixcode: allow multiple pingback users
		// access the file sequentially.
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}


	hr = ValidateFileHeader(hFile, ERROR_ALREADY_EXISTS == GetLastError(), TRUE);
	if (S_OK != hr)
	{
		if (S_FALSE != hr)
		{
			// The file header is bad or there was problem validating it.
			fDeleteFile = TRUE;		// destroy the file and fail the function
		}
		// else
			// The file header has a newer version than this library code.
			// Keep the file around.

		goto CleanUp;
	}


	// Set outselves to the right position before writing to the file.
	DWORD nCurrPos;

	if (INVALID_SET_FILE_POINTER == (nCurrPos = SetFilePointer(
										hFile,
										0,
										NULL,
										FILE_END)))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	// Write the entry to the log.
	if (!WriteFile(
			hFile,
			&ulentryheader,
			sizeof(ulentryheader),
			&dwBytes,
			NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG_ErrorMsg(hr);
	}

	if (SUCCEEDED(hr) &&
		sizeof(ulentryheader) != dwBytes)
	{
		LOG_Error(_T("Failed to write entry header to file (%d bytes VS %d bytes)"), sizeof(ulentryheader), dwBytes);
		hr = E_FAIL;
	}

	if (SUCCEEDED(hr) &&
		!WriteFile(
			hFile,
			pwszString,
			sizeof(WCHAR) * ulentryheader.wRequestSize,
			&dwBytes,
			NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG_ErrorMsg(hr);
	}

	if (SUCCEEDED(hr) &&
		sizeof(WCHAR) * ulentryheader.wRequestSize != dwBytes)
	{
		LOG_Error(_T("Failed to write entry header to file (%d bytes VS %d bytes)"), sizeof(WCHAR) * ulentryheader.wRequestSize, dwBytes);
		hr = E_FAIL;
	}

	// We failed to wrote the entry into the log.
	if (FAILED(hr))
	{
		// We don't want to get rid of the other entries.
		// We can only try to remove the portion of the entry
		// we have appended from the file.
		if (INVALID_SET_FILE_POINTER == SetFilePointer(
											hFile,
											nCurrPos,
											NULL,
											FILE_BEGIN) ||
			!SetEndOfFile(hFile))
		{
			// We failed to remove the new entry.
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
			fDeleteFile = TRUE;
		}
		// else
			// We successfully got rid of this entry.
			// And preserved existing entries in log.
	}

CleanUp:
	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
	}
	if (fDeleteFile)
	{
		(void) DeleteFile(m_tszLogFile);
		// We don't delete the log file if the operation was successful.
		// Thus, no need to modify the fRet value even if DeleteFile() failed.
	}

	return hr;
}



// Send all pending (offline) ping requests to server
HRESULT CUrlLog::Flush(PHANDLE phQuitEvents, UINT nQuitEventCount)
{
	LPWSTR	pwszBuffer = NULL;
	LPTSTR	ptszUrl = NULL;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	BOOL	fKeepFile = FALSE;
	DWORD	dwErr;
	HRESULT	hr;

	LOG_Block("CUrlLog::Flush");

	if (NULL == (pwszBuffer = (LPWSTR) malloc(sizeof(WCHAR) * INTERNET_MAX_URL_LENGTH)) ||
		NULL == (ptszUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)))
	{
		hr = E_OUTOFMEMORY;
		goto CleanUp;
	}

	if (_T('\0') == m_tszLogFile[0])
	{
		hr = E_UNEXPECTED;
		LOG_Error(_T("log file name not initialized"));
		goto CleanUp;
	}

	// Open existing log
	if(INVALID_HANDLE_VALUE == (hFile = CreateFile(
							m_tszLogFile,
							GENERIC_READ | GENERIC_WRITE,
							0,						// no sharing
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_RANDOM_ACCESS,
							NULL)))
	{
		// We failed to open the file.
		// The file may not exist or someone may be currently using it.
		dwErr = GetLastError();

		if (ERROR_FILE_NOT_FOUND == dwErr)
		{
			// We are done.  There is nothing more to do.
			hr = S_OK;
		}
		else
		{
			//fixcode: allow multiple pingback users
			// access the file sequentially.
			LOG_ErrorMsg(dwErr);
			hr = HRESULT_FROM_WIN32(dwErr);
		}
		goto CleanUp;
	}


	// File opened.  Check header.
	hr = ValidateFileHeader(hFile, TRUE, FALSE);

	if (S_OK != hr)
	{
		if (S_FALSE == hr)
		{
			// The file header has a newer version than this library code.
			goto CleanUp; // Keep the file around.
		}
		// else
			// The file header is bad or there was problem validating it.
			// destroy the file and fail the function
	}
	else
	{
		BOOL fLiveServerFailed = FALSE;
		BOOL fCorpServerFailed = FALSE;

		// It is time to read an entry.
		for (;;)
		{
			ULENTRYHEADER ulentryheader;

			if (!HandleEvents(phQuitEvents, nQuitEventCount))
			{
				hr = E_ABORT;
				LOG_ErrorMsg(hr);
				break;
			}

			// Assume we are in the right position to read
			// the next entry from the file.

			// Read the entry header and request in entry.
			if (FAILED(hr = ReadEntry(hFile, ulentryheader, pwszBuffer, INTERNET_MAX_URL_LENGTH)))
			{
				LOG_Error(_T("Failed to read entry from cache (%#lx)"), hr);
				break;
			}

			if (S_FALSE == hr)
			{
				// There are no more unprocessed entries.
				hr = S_OK;
				break;
			}

			// We have successfully read the entry from the cache file.
			if (URLLOGPROGRESS_Sent != ulentryheader.progress)
			{
				// The entry hasn't been successfully sent yet.
				LPCTSTR	ptszBaseUrl = NULL;
				BOOL *pfWhichServerFailed;

				if (URLLOGDESTINATION_LIVE == ulentryheader.destination)
				{
					ptszBaseUrl = m_ptszLiveServerUrl;
					pfWhichServerFailed = &fLiveServerFailed;
				}
				else
				{
					ptszBaseUrl = m_ptszCorpServerUrl;
					pfWhichServerFailed = &fCorpServerFailed;
				}

				if (*pfWhichServerFailed)
				{
					continue;	// this base URL has failed before.  go on to the next entry.
				}

				LPTSTR ptszRelativeUrl;

				USES_IU_CONVERSION;

				if (NULL == (ptszRelativeUrl = W2T(pwszBuffer + ulentryheader.wServerUrlLen)))
				{
					// Running out of memory.  Will retry later.
					hr = E_OUTOFMEMORY;
					break;
				}

				if (NULL != ptszBaseUrl)
				{
					// Form the request URL
					DWORD dwUrlLen = INTERNET_MAX_URL_LENGTH;

					if (S_OK != UrlCombine(	// requires IE3 for 95/NT4
										ptszBaseUrl,
										ptszRelativeUrl,
										ptszUrl,
										&dwUrlLen,
										URL_DONT_SIMPLIFY))
					{
						// Either the buffer is too small to hold both the base and
						// the relative URLs, or the host name is invalid.
						// We will retry this entry just in case we will have a
						// shorter/better host name.
						fKeepFile = TRUE;
						continue;	// go on to the next entry
					}
				}
				else
				{
#if defined(UNICODE) || defined(_UNICODE)
					if (FAILED(hr = StringCchCopyExW(ptszUrl, INTERNET_MAX_URL_LENGTH, pwszBuffer, NULL, NULL, MISTSAFE_STRING_FLAGS)))
					{
						LOG_Error(_T("Failed to construct ping URL (%#lx)"), hr);
						break;
					}
#else
					if (0 == AtlW2AHelper(ptszUrl, pwszBuffer, INTERNET_MAX_URL_LENGTH))
					{
						// The buffer is probably too small to hold both the base and
						// the relative URLs.  We will retry this entry just in case
						// we will have a shorter/better host name.
						fKeepFile = TRUE;
						continue;	// go on to the next entry
					}
#endif
				}

				hr = PingStatus(ulentryheader.destination, ptszUrl, phQuitEvents, nQuitEventCount);

				if (FAILED(hr))
				{
					if (E_ABORT == hr)
					{
						break;
					}

					// We will resend this entry later.
					LOG_Internet(_T("Failed to send message (%#lx).  Will retry later."), hr);
					*pfWhichServerFailed = TRUE;
					fKeepFile = TRUE;

					if (fLiveServerFailed && fCorpServerFailed)
					{
						// Failed to send ping messages to both destinations.
						hr = S_OK;
						break;
					}
					continue;
				}

				DWORD	dwBytes;

				// Mark the entry off the cache file.
				ulentryheader.progress = URLLOGPROGRESS_Sent;
				// Go to the beginning of the current entry and change the entry header.
				if (INVALID_SET_FILE_POINTER == SetFilePointer(
													hFile,
													- ((LONG) (sizeof(ulentryheader) +
															   sizeof(WCHAR) * ulentryheader.wRequestSize)),
													NULL,
													FILE_CURRENT) ||
					!WriteFile(
							hFile,
							&ulentryheader,
							sizeof(ulentryheader),
							&dwBytes,
							NULL))
				{
					// We failed to mark this entry 'sent'.
					hr = HRESULT_FROM_WIN32(GetLastError());
					LOG_ErrorMsg(hr);
					break;
				}

				if (sizeof(ulentryheader) != dwBytes)
				{
					// We failed to write the header.
					LOG_Error(_T("Failed to write header (%d bytes VS %d bytes)"), sizeof(ulentryheader), dwBytes);
					hr = E_FAIL;
					break;
				}

				// Set the file pointer to the start of the next entry
				if (INVALID_SET_FILE_POINTER == SetFilePointer(
													hFile,
													sizeof(WCHAR) * ulentryheader.wRequestSize,
													NULL,
													FILE_CURRENT))
				{
					// We failed to skip the current entry.
					hr = HRESULT_FROM_WIN32(GetLastError());
					LOG_ErrorMsg(hr);
					break;
				}
			}
		}
	}

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	if ((FAILED(hr) && E_ABORT != hr && E_OUTOFMEMORY != hr) ||
		(SUCCEEDED(hr) && !fKeepFile))
	{
		(void) DeleteFile(m_tszLogFile);
	}

CleanUp:
	if (NULL != pwszBuffer)
	{
		free(pwszBuffer);
	}
	if (NULL != ptszUrl)
	{
		free(ptszUrl);
	}
	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
	}

	return hr;
}



// Escape unsafe chars in a TCHAR string
// Returned value: non-zero if successful; zero otherwise
BOOL EscapeString(
			LPCTSTR	ptszUnescaped,
			LPTSTR	ptszBuffer,
			DWORD	dwCharsInBuffer)
{
	BOOL fRet = FALSE;

	LOG_Block("CUrlLog::EscapeString");

	if (NULL != ptszUnescaped &&
		NULL != ptszBuffer &&
		0 != dwCharsInBuffer)
	{
		for (DWORD i=0, j=0; _T('\0') != ptszUnescaped[i] && j+1<dwCharsInBuffer; i++, j++)
		{
			TCHAR tch = ptszUnescaped[i];

			if ((_T('a') <= tch && _T('z') >= tch) ||
				(_T('A') <= tch && _T('Z') >= tch) ||
				(_T('0') <= tch && _T('9') >= tch) ||
				NULL != _tcschr(_T("-_.!~*'()"), tch))
			{
				ptszBuffer[j] = tch;
			}
			else if (j+3 >= dwCharsInBuffer)
			{
				// We don't have enough buffer to hold the escaped string.
				// Bail out.
				break;
			}
			else
			{
				TCHAR nibble = tch >> 4;

				ptszBuffer[j++]	= _T('%');
				ptszBuffer[j++]	= nibble + (nibble >= 0x0a ? _T('A') - 0x0a : _T('0'));
				nibble = tch & 0x0f;
				ptszBuffer[j]	= nibble + (nibble >= 0x0a ? _T('A') - 0x0a : _T('0'));
			}
		}

		if (_T('\0') == ptszUnescaped[i])
		{
			ptszBuffer[j] = _T('\0');
			fRet = TRUE;
		}
#ifdef DBG
		else
		{
			// Couldn't escape the whole string due to insufficient buffer.
			LOG_ErrorMsg(ERROR_INSUFFICIENT_BUFFER);
		}
#endif
	}
#ifdef DBG
	else
	{
		LOG_ErrorMsg(E_INVALIDARG);
	}
#endif

	return fRet;
}



// Create a UUID that is not linked to MAC address of a NIC, if any, on the system.
//		pUuid - ptr to the UUID structure to hold the returning value.
void MakeUUID(UUID* pUuid)
{
	HRESULT			hr;
	OSVERSIONINFO	osverinfo;

	LOG_Block("CUrlLog::MakeUUID");

	// check OS version
	osverinfo.dwOSVersionInfoSize = sizeof(osverinfo);
	if (!(GetVersionEx(&osverinfo)))
	{
		hr = GetLastError();
#ifdef DBG
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);	// log this error
		}
#endif
	}
	else if (5 <= osverinfo.dwMajorVersion &&					// Check for Win2k & up
			 VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId)
	{
		// The OS is Win2K & up.
		// We can safely use CoCreateGuid().
		hr = CoCreateGuid(pUuid);
		if (SUCCEEDED(hr))
		{
			goto Done;
		}

		LOG_ErrorMsg(hr);	// log this error
	}

	// Either the OS is something older than Win2K, or
	// somehow we failed to get a GUID with CoCreateGuid.
	// We still have to do something to resolve the proxy caching problem.
	// Here we construct this psudo GUID by using:
	// -	ticks since last reboot
	// -	the current process ID
	// -	time in seconds since 00:00:00 1/1/1970 UTC
	// -	fraction of a second in milliseconds for the above time.
	// -	a 15-bit unsigned random number
	//
	pUuid->Data1 = GetTickCount();
	*((DWORD*) &pUuid->Data2) = GetCurrentProcessId();

	// Use the first 6 bytes of m_uuidPingID.Data1 to store sys date/time.
	{
		_timeb tm;

		_ftime(&tm);
		*((DWORD*) &pUuid->Data4) = (DWORD) tm.time;
		((WORD*) &pUuid->Data4)[2] = tm.millitm;
	}

	// Use the last 2 bytes of m_uuidPingID.Data1 to store another random number.
	srand(pUuid->Data1);
	((WORD*) &pUuid->Data4)[3] = (WORD) rand();	// rand() returns only positive values.


Done:
	return;
}


// Check and/or fix (if necessary) the header of the log file.
//
// Returned value:
//		S_OK - the header has been fixed or the file contains
//			   a valid header. The file pointer now points to
//			   the first entry in the log file.
//		S_FALSE - the file has a valid header but the version
//				  of the file is newer than this library code.
//				  The caller should not try to overwrite the
//				  file's contents.
//		Others (failure) - the header is invalid or there was
//						   a problem accessing the file.  The
//						   file should be deleted.
HRESULT ValidateFileHeader(HANDLE hFile, BOOL fCheckHeader, BOOL fFixHeader)
{
	ULHEADER ulheader;
	DWORD dwBytes;
	HRESULT hr = E_FAIL;

	LOG_Block("ValidateFileHeader");

	if (fCheckHeader)
	{
		DWORD dwFileSize = GetFileSize(hFile, NULL);
		// Log file existed before we opened it
		if (INVALID_FILE_SIZE == dwFileSize)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
		}
		else if (1024 * 100 < dwFileSize)	// no more than 100Kbytes
		{
			LOG_Error(_T("too many stale entries in cache."));
		}
		else if (!ReadFile(hFile, &ulheader, sizeof(ulheader), &dwBytes, NULL))
		{
			// We failed to read the header.  We must then fix up the
			// header.
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
		}
		else if (sizeof(ulheader) == dwBytes)
		{
			if (CACHE_FILE_VERSION < ulheader.wVersion)
			{
				// A log file of newer version already exists.
				// We should not mess it up with an entry of older
				// format.  The query string will not be saved.
				LOG_Internet(_T("log file is of a newer version. operation cancelled."));
				return S_FALSE;
			}

			if (CACHE_FILE_VERSION == ulheader.wVersion)
			{
				// Correct version number.  We're done.
				return S_OK;
			}
			// else
				// out-dated header
				// We don't care about the entries in it.  We will replace everything
				// in order to fix the header.
		}
		// else
			// incorrect header size
			// We don't care about the entries in it.  We will replace everything
			// in order to fix the header.

		if (!fFixHeader)
		{
			return hr;
		}

		// Truncate the file to zero byte.
		if (INVALID_SET_FILE_POINTER == SetFilePointer(
										hFile,
										0,
										NULL,
										FILE_BEGIN) ||
			!SetEndOfFile(hFile))
		{
			// Nothing we can do if we failed to clear the
			// contents of the file in order to fix it up.
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
			return hr;
		}
	}
	else if (!fFixHeader)
	{
		// The caller needs to pick at least one operation.
		return E_INVALIDARG;
	}


	// Assume we are at the beginning of the file.
	// We need to (re)initialize the file.
	if (fFixHeader)
	{
		ZeroMemory(&ulheader, sizeof(ulheader));

		ulheader.wVersion = CACHE_FILE_VERSION;
		if (!WriteFile(hFile, &ulheader, sizeof(ulheader), &dwBytes, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
			return hr;
		}
		else if (sizeof(ulheader) != dwBytes)
		{
			LOG_Error(_T("Failed to write file header (%d bytes VS %d bytes)"), sizeof(ulheader), dwBytes);
			return E_FAIL;
		}
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\urllogging\internet.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    internet.cpp
//
//  Creator: PeterWi
//
//  Purpose: internet functions.
//
//=======================================================================

#pragma hdrstop

#include <tchar.h>
#include <winsock2.h>	// for LPWSADATA, struct hostent
#include <wininet.h>	// for InternetGetConnectedState(), InternetQueryOptionA()
#include <iphlpapi.h>	// for IPAddr
#include <sensapi.h>	// for NETWORK_ALIVE_*

#include <logging.h>	// for LOG_Block, LOG_Error and LOG_Internet
#include <MemUtil.h>	// USES_IU_CONVERSION, T2A(), MemAlloc
#include <wusafefn.h>
#include <shlwapi.h>	// UrlGetPart
#include <MISTSafe.h>

#include <URLLogging.h>

#define ARRAYSIZE(a)	(sizeof(a)/sizeof((a)[0]))

typedef BOOL	(WINAPI * ISNETWORKALIVE)(LPDWORD);
//typedef BOOL	(WINAPI * INETCONNECTSTATE)(LPDWORD, DWORD);
//typedef BOOL	(WINAPI * INETQUERYOPTION)(HINTERNET, DWORD, LPVOID, LPDWORD);
typedef DWORD	(WINAPI * GETBESTINTERFACE)(IPAddr, DWORD *);
typedef ULONG	(WINAPI * INET_ADDR)(const char FAR *);
typedef struct hostent FAR * (WINAPI * GETHOSTBYNAME)(const char FAR *name);
typedef int		(WINAPI * WSASTARTUP)(WORD, LPWSADATA);
typedef int		(WINAPI * WSACLEANUP)(void);
#ifdef DBG
typedef int		(WINAPI * WSAGETLASTERROR)(void);
#endif

const char c_szWU_PING_URL[] = "207.46.226.17"; // current ip addr for windowsupdate.microsoft.com

// forward declarations
BOOL IsConnected_2_0(void);

// HKLM\Software\Microsoft\Windows\CurrentVersion\WindowsUpdate\IsConnected DWORD reg value
#define ISCONNECTEDMODE_Unknown				-1		// static variable not initialized yet
#define ISCONNECTEDMODE_Default				0
	// live: use AU 2.0 logic
	//       test = InternetGetConnectedState + InternetQueryOption + GetBestInterface on static IP
	// CorpWU: same as ISCONNECTEDMODE_IsNetworkAliveAndGetBestInterface
#define ISCONNECTEDMODE_AlwaysConnected		1
	// live/CorpWU: Assume the destination is always reachable. e.g. via D-tap connection.
#define ISCONNECTEDMODE_IsNetworkAliveOnly	2
	// live/CorpWU: test = IsNetworkAlive.
#define ISCONNECTEDMODE_IsNetworkAliveAndGetBestInterface	3
	// live: test = IsNetworkAlive + GetBestInterface on static IP
	// CorpWU: test = IsNetworkAlive + gethostbyname + GetBestInterface

#define ISCONNECTEDMODE_MinValue			0
#define ISCONNECTEDMODE_MaxValue			3

inline DWORD GetIsConnectedMode(void)
{
	static DWORD s_dwIsConnectedMode = ISCONNECTEDMODE_Unknown;

	if (ISCONNECTEDMODE_Unknown == s_dwIsConnectedMode)
	{
		// Assume using default connection detection mechanism
		s_dwIsConnectedMode = ISCONNECTEDMODE_Default;

		const TCHAR c_tszRegKeyWU[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate");
		const TCHAR c_tszRegUrlLogIsConnectedMode[] = _T("IsConnectedMode");

		HKEY	hkey;

		if (NO_ERROR == RegOpenKeyEx(
							HKEY_LOCAL_MACHINE,
							c_tszRegKeyWU,
							0,
							KEY_QUERY_VALUE,
							&hkey))
		{
			DWORD	dwSize = sizeof(s_dwIsConnectedMode);
			DWORD	dwType;

			if (NO_ERROR != RegQueryValueEx(
								hkey,
								c_tszRegUrlLogIsConnectedMode,
								0,
								&dwType,
								(LPBYTE) &s_dwIsConnectedMode,
								&dwSize) ||
				REG_DWORD != dwType ||
				sizeof(s_dwIsConnectedMode) != dwSize ||
// comment out the next line to avoid error C4296: '>' : expression is always false
//				ISCONNECTEDMODE_MinValue > s_dwIsConnectedMode ||
				ISCONNECTEDMODE_MaxValue < s_dwIsConnectedMode)
			{
				s_dwIsConnectedMode = ISCONNECTEDMODE_Default;
			}

			RegCloseKey(hkey);
		}
	}

	return s_dwIsConnectedMode;
}

// ----------------------------------------------------------------------------------
// IsConnected()
//          detect if there is a connection currently that can be used to
//          connect to Windows Update site.
//          If yes, we activate the shedule DLL
//
// Input :  ptszUrl - Url containing host name to check for connection
//			fLive - whether the destination is the live site
// Output:  None
// Return:  TRUE if we are connected and we can reach the web site.
//          FALSE if we cannot reach the site or we are not connected.
// ----------------------------------------------------------------------------------

BOOL IsConnected(LPCTSTR ptszUrl, BOOL fLive)
{
    BOOL bRet = FALSE;
	DWORD dwFlags = 0;
	ISNETWORKALIVE pIsNetworkAlive = NULL;
    HMODULE hIphlp = NULL, hSock = NULL, hSens = NULL;
	DWORD dwIsConnectedMode = GetIsConnectedMode();

	LOG_Block("IsConnected");

	if (ISCONNECTEDMODE_AlwaysConnected == dwIsConnectedMode)
	{
		LOG_Internet(_T("AlwaysConnected"));
		bRet = TRUE;
		goto lFinish;
	}

	if (fLive && ISCONNECTEDMODE_Default == dwIsConnectedMode)
	{
		LOG_Internet(_T("Use 2.0 algorithm"));
		bRet = IsConnected_2_0();
		goto lFinish;
	}

// InternetGetConnectedState() returns FALSE if Wininet/IE AutoDial is configured.
// Thus we can't rely on it to see if we have network connectivity.
#if 0
    DWORD dwConnMethod = 0, dwState = 0, dwSize = sizeof(DWORD);

    bRet = InternetGetConnectedState(&dwConnMethod, 0);

#ifdef DBG
	
	LOG_Internet(_T("Connection Method is %#lx"), dwConnMethod);  
	LOG_Internet(_T("InternetGetConnectedState() return value %d"), bRet);

    if (dwConnMethod & INTERNET_CONNECTION_MODEM)
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_MODEM"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_LAN )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_LAN"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_PROXY )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_PROXY"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_MODEM_BUSY"));
    }
#endif

    if (bRet)
    {
        // modem is dialing
        if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY)
        {
            bRet = FALSE;
			goto lFinish;
        }

        // check if there is a proxy but currently user is offline
        if (dwConnMethod & INTERNET_CONNECTION_PROXY)
        {
            if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
            {
                if (dwState & (INTERNET_STATE_DISCONNECTED_BY_USER | INTERNET_STATE_DISCONNECTED))
				{
                    bRet = FALSE;
					goto lFinish;
				}
            }
            else
            {
                LOG_Error(_T("IsConnected() fail to get InternetQueryOption (%#lx)"), GetLastError());
            }
        }
    }
    else
    {
        //
        // further test the case that user didn't run icw but is using a modem connection
        //
        const DWORD dwModemConn = (INTERNET_CONNECTION_MODEM | INTERNET_CONNECTION_MODEM_BUSY);
        if ((dwConnMethod & dwModemConn) == dwModemConn)
        {
            bRet = TRUE;
        }
    }

    //one final check for connectivity by pinging microsoft.com
    //if (bRet)
    //{
    //  bRet = CheckByPing(szURL);
    //}
    //bugfix for InternetGetConnectedState API - if LAN card is disabled it still returns LAN connection
    //use GetBestInterface and see if there is any error trying to reach an outside IP address
    //this may fix scenarios in homelan case where there is no actual connection to internet??
    if (!bRet || (dwConnMethod & INTERNET_CONNECTION_LAN))  //LAN card present
		//bug 299338
	{
		// do gethostbyname and GetBestInterface
	}
#endif

	if (NULL == (hSens = LoadLibraryFromSystemDir(TEXT("sensapi.dll"))) ||
		NULL == (pIsNetworkAlive = (ISNETWORKALIVE)::GetProcAddress(hSens, "IsNetworkAlive")))
	{
		LOG_Error(_T("failed to load IsNetworkAlive() from sensapi.dll"));
		goto lFinish;
	}

	if (pIsNetworkAlive(&dwFlags))
    {
#ifdef DBG
		if (NETWORK_ALIVE_LAN & dwFlags)
		{
			LOG_Internet(_T("active LAN card(s) detected"));
		}
		if (NETWORK_ALIVE_WAN & dwFlags)
		{
			LOG_Internet(_T("active RAS connection(s) detected"));
		}
		if (NETWORK_ALIVE_AOL & dwFlags)
		{
			LOG_Internet(_T("AOL connection detected"));
		}
#endif
		if (ISCONNECTEDMODE_IsNetworkAliveOnly == dwIsConnectedMode)
		{
			LOG_Internet(_T("IsNetworkAliveOnly ok"));
			bRet = TRUE;
			goto lFinish;
		}

		// can't be moved into where ptszHostName and pszHostName are
		// MemAlloc'ed since pszHostName will be used outside that block.
		USES_IU_CONVERSION;

		GETBESTINTERFACE pGetBestInterface = NULL;
		INET_ADDR pInetAddr = NULL;
		LPCSTR pszHostName = NULL;

		if (fLive && ISCONNECTEDMODE_IsNetworkAliveAndGetBestInterface == dwIsConnectedMode)
		{
			pszHostName = c_szWU_PING_URL;
		}
		else
		{
			// !fLive && (ISCONNECTEDMODE_Default == dwIsConnectedMode ||
			// ISCONNECTEDMODE_IsNetworkAliveAndGetBestInterface == dwIsConnectedMode)
			if (NULL == ptszUrl || _T('\0') == ptszUrl[0])
			{
				LOG_Error(_T("IsConnected() invalid parameter"));
			}
			else
			{
				TCHAR tszHostName[40];	// arbitrary buffer size that should work with most domain names
				DWORD dwCchHostName = ARRAYSIZE(tszHostName);
				LPTSTR ptszHostName = tszHostName;

				HRESULT hr = UrlGetPart(ptszUrl, tszHostName, &dwCchHostName, URL_PART_HOSTNAME, 0);

				if (E_POINTER == hr)
				{
					if (NULL != (ptszHostName = (LPTSTR) MemAlloc(sizeof(TCHAR) * dwCchHostName)))
					{
						hr = UrlGetPart(ptszUrl, ptszHostName, &dwCchHostName, URL_PART_HOSTNAME, 0);
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}

				if (FAILED(hr))
				{
					LOG_Error(_T("failed to extract hostname (error %#lx)"), hr);
				}
				else
				{
					pszHostName = T2A(ptszHostName);
				}
			}
		}

		if (NULL == pszHostName)
		{
			LOG_Error(_T("call to T2A (IU version) failed"));
		}
		else if (
			NULL != (hIphlp = LoadLibraryFromSystemDir(TEXT("iphlpapi.dll"))) &&
			NULL != (hSock = LoadLibraryFromSystemDir(TEXT("ws2_32.dll"))) &&
			NULL != (pGetBestInterface = (GETBESTINTERFACE)::GetProcAddress(hIphlp, "GetBestInterface")) &&
			NULL != (pInetAddr = (INET_ADDR)::GetProcAddress(hSock, "inet_addr")))
		{
			IPAddr dest;

			LOG_Internet(_T("checking connection to %hs..."), pszHostName);

			//fixcode: should check against broadcasting IP addresses
			if (INADDR_NONE == (dest = pInetAddr(pszHostName)))
			{
				GETHOSTBYNAME pGetHostByName = NULL;
				WSASTARTUP pWSAStartup = NULL;
				WSACLEANUP pWSACleanup = NULL;
#ifdef DBG
				WSAGETLASTERROR pWSAGetLastError = NULL;
#endif
				WSADATA wsaData;
				int iErr = 0;

				if (NULL != (pGetHostByName = (GETHOSTBYNAME)::GetProcAddress(hSock, "gethostbyname")) &&
#ifdef DBG
					NULL != (pWSAGetLastError = (WSAGETLASTERROR)::GetProcAddress(hSock, "WSAGetLastError")) &&
#endif
					NULL != (pWSAStartup = (WSASTARTUP)::GetProcAddress(hSock, "WSAStartup")) &&
					NULL != (pWSACleanup = (WSACLEANUP)::GetProcAddress(hSock, "WSACleanup")) &&

					//fixcode: should be called at the constructor of CUrlLog and when IU (when online) or AU starts.
					0 == pWSAStartup(MAKEWORD(1, 1), &wsaData))
				{
#ifdef DBG
					DWORD dwStartTime = GetTickCount();
#endif
					struct hostent *ptHost = pGetHostByName(pszHostName);

					if (NULL != ptHost &&
						AF_INET == ptHost->h_addrtype &&
						sizeof(IPAddr) == ptHost->h_length &&
						NULL != ptHost->h_addr_list &&
						NULL != ptHost->h_addr)
					{
						// take the first IP address
						dest = *((IPAddr FAR *) ptHost->h_addr);
#ifdef DBG
						LOG_Internet(
								_T("Host name %hs resolved to be %d.%d.%d.%d, took %d msecs"),
								pszHostName,
								(BYTE) ((ptHost->h_addr)[0]),
								(BYTE) ((ptHost->h_addr)[1]),
								(BYTE) ((ptHost->h_addr)[2]),
								(BYTE) ((ptHost->h_addr)[3]),
								GetTickCount() - dwStartTime);
#endif
					}
#ifdef DBG
					else
					{
						LOG_Internet(_T("Host name %hs couldn't be resolved (error %d), took %d msecs"), pszHostName, pWSAGetLastError(), GetTickCount() - dwStartTime);
					}
#endif
					//fixcode: should be called at the destructor of CUrlLog and when IU (when online) or AU ends.
					if (iErr = pWSACleanup())
					{
						LOG_Error(_T("failed to clean up winsock (error %d)"), iErr);
					}
				}
				else
				{
					LOG_Error(_T("failed to load winsock procs or WSAStartup() failed"));
				}
			}

			if (INADDR_NONE != dest)
			{
				DWORD dwErr, dwIndex;

				if (bRet = (NO_ERROR == (dwErr = pGetBestInterface(dest, &dwIndex))))
				{
					LOG_Internet(_T("route found on interface #%d"), dwIndex);
				}
				else
				{
					LOG_Internet(_T("GetBestInterface() failed w/ error %d"), dwErr);
				}
			}
		}
		else
		{
			LOG_Error(_T("failed to load procs from winsock/ip helper (error %d)"), GetLastError());
		}
    }
	else
	{
		LOG_Internet(_T("no active connection detected"));
	}

lFinish:
    if (hIphlp != NULL)
    {
        FreeLibrary(hIphlp);
    }
	if (hSock != NULL)
	{
		FreeLibrary(hSock);
	}
	if (hSens != NULL)
	{
		FreeLibrary(hSens);
	}

    return (bRet);
}


// ----------------------------------------------------------------------------------
//
// Function IsConnected_2_0()
//          detect if there is a cunection currently can be used to
//          connect to live Windows Update site.
//          If yes, we activate the shedule DLL
//
// Input :   None
// Output:  None
// Return:  TRUE if we are connected and we can reach the web site.
//          FALSE if we cannot reach the live site or we are not connected.
//
//
// ----------------------------------------------------------------------------------

BOOL IsConnected_2_0()
{
    BOOL bRet = FALSE;
    DWORD dwConnMethod, dwState = 0, dwSize = sizeof(DWORD), dwErr, dwIndex;
    GETBESTINTERFACE pGetBestInterface = NULL;
    INET_ADDR pInet_addr = NULL;
    HMODULE hIphlp = NULL, hSock = NULL;

	LOG_Block("IsConnected");

    bRet = InternetGetConnectedState(&dwConnMethod, 0);

/*
#ifdef DBG
	
	LOG_Internet(_T("Connection Method is %#lx"), dwConnMethod);  
	LOG_Internet(_T("InternetGetConnectedState() return value %d"), bRet);

    if (dwConnMethod & INTERNET_CONNECTION_MODEM)
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_MODEM"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_LAN )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_LAN"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_PROXY )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_PROXY"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_MODEM_BUSY"));
    }
#endif
*/

    if (bRet)
    {
        // modem is dialing
        if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY)
        {
            bRet = FALSE;
			goto lFinish;
        }

        // check if there is a proxy but currently user is offline
        if (dwConnMethod & INTERNET_CONNECTION_PROXY)
        {
            if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
            {
                if (dwState & (INTERNET_STATE_DISCONNECTED_BY_USER | INTERNET_STATE_DISCONNECTED))
				{
                    bRet = FALSE;
					goto lFinish;
				}
            }
            else
            {
                LOG_Error(_T("IsConnected() fail to get InternetQueryOption (%#lx)"), GetLastError());
            }
        }
    }
    else
    {
        //
        // further test the case that user didn't run icw but is using a modem connection
        //
        const DWORD dwModemConn = (INTERNET_CONNECTION_MODEM | INTERNET_CONNECTION_MODEM_BUSY);
        if ((dwConnMethod & dwModemConn) == dwModemConn)
        {
            bRet = TRUE;
        }
    }
    //one final check for connectivity by pinging microsoft.com
    //if (bRet)
    //{
    //  bRet = CheckByPing(szURL);
    //}
    //bugfix for InternetGetConnectedState API - if LAN card is disabled it still returns LAN connection
    //use GetBestInterface and see if there is any error trying to reach an outside IP address
    //this may fix scenarios in homelan case where there is no actual connection to internet??
    if ((bRet && (dwConnMethod & INTERNET_CONNECTION_LAN)) ||  //LAN card present
		(!bRet)) //bug 299338
    {
        struct sockaddr_in dest;
        hSock = LoadLibraryFromSystemDir(TEXT("ws2_32.dll"));
        hIphlp = LoadLibraryFromSystemDir(TEXT("iphlpapi.dll"));
        if ((hIphlp == NULL) || (hSock == NULL))
        {
            goto lFinish;
        }

        pGetBestInterface = (GETBESTINTERFACE)::GetProcAddress(hIphlp, "GetBestInterface");
        pInet_addr = (INET_ADDR)::GetProcAddress(hSock, "inet_addr");
        if ((pGetBestInterface == NULL) || (pInet_addr == NULL))
        {
            goto lFinish;
        }
        if ((dest.sin_addr.s_addr = pInet_addr(c_szWU_PING_URL)) == INADDR_ANY)
        {
            goto lFinish;
        }
        if (NO_ERROR != (dwErr = pGetBestInterface(dest.sin_addr.s_addr, &dwIndex)))
        {
            LOG_ErrorMsg(dwErr);
            bRet = FALSE;
            //any error bail out for now
            /*
            if (dwErr == ERROR_NETWORK_UNREACHABLE)     //winerror.h
            {
                bRet = FALSE;
            }
            */
        }
		else
		{
			bRet = TRUE;
		}
    }

lFinish:
    if (hIphlp != NULL)
    {
        FreeLibrary(hIphlp);
    }
    if (hSock != NULL)
    {
        FreeLibrary(hSock);
    }

    LOG_Internet(_T("%s"), bRet ? _T("Connected") : _T("Not connected"));
    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\trust\testtrust\testtrust.cpp ===
// TestTrust.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <tchar.h>
#include <logging.h>
#include <stdlib.h>
#include <stdio.h>
//#include <malloc.h>	// use _alloc

const TCHAR TestQuitEvent[] = _T("B4715050-ED35-4a7c-894A-1DF04F4F7F27");

LOG_Process;

HANDLE g_QuitEvent = NULL;
long g_Cnt = 0;

void Randomize()
{
	srand(GetTickCount());
}

int RandomNum(int _max)
{
	int n = rand();
	float f = (float)n / RAND_MAX;
	n = (int) (f * _max);
	return n;
}



inline bool ShouldQuit()
{
	return (WaitForSingleObject(g_QuitEvent, 0) == WAIT_OBJECT_0);
}


void RandomGenLogs(int _max)
{
	LOG_Block("WriteLog");
	
	Randomize();

	for (int i = 0; i < RandomNum(_max); i++)
	{
		int n = RandomNum(10);
		if (n >= 5)
		{
			if (RandomNum(2) > 1)
			{
				LOG_Error(_T("Error: %d"), RandomNum(100));
			}
			else
			{
				LOG_ErrorMsg(RandomNum(128));
			}
		}
		else
		{
			switch (n)
			{
			case 0:
				LOG_XML(_T("XML Error"));
				break;
			case 1:
				LOG_Driver(_T("Driver Log sample"));
				break;
			case 2:
				LOG_Internet(_T("Internet related log"));
				break;
			case 3:
				LOG_Software(_T("Software related log"));
				break;
			case 4:
				LOG_Trust(_T("Trust related log"));
				break;

			}
		}
	}

}


DWORD TestLog(int nDepth)
{
	int i;

	char szTitle[16];
	wsprintfA(szTitle, "TestLog(%d)", nDepth);
	LOG_Block(szTitle);
	
	Randomize();

	if (ShouldQuit())
		return 0;

	if (nDepth <= 0)
	{
		RandomGenLogs(10);
		return 0;
	}

	RandomGenLogs(4);

	for (i = 0; i < RandomNum(2); i++)
	{
		if (ShouldQuit())
		{
			LOG_Out(_T("Got quit signal!"));
			return 0;
		}


		TestLog(nDepth - 1); 
	}

	RandomGenLogs(6);

	return 0;
}


DWORD WINAPI ThreadProc(LPVOID Param)
{
	LOG_Block("ThreadProc");

	InterlockedIncrement(&g_Cnt);
	int n = (int) Param;
	printf("\t\tThread %d starts with depth %d\n", GetCurrentThreadId(), n);
	while (!ShouldQuit())
		TestLog(n);
	LOG_Out(_T("ThreadProc:::::::::Got quit signal!"));
	printf("\t\tThread %d quits\n", GetCurrentThreadId());
	InterlockedDecrement(&g_Cnt);
	return 0;
}


void StartThreadTesting(int nTotalThreads)
{
	LOG_Block("StartThreadTesting()");
	DWORD dwThreadId;
	int Num, i;

	HANDLE* pHandles = (HANDLE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nTotalThreads * sizeof(HANDLE));

	Randomize();

	for (i = 0; i < nTotalThreads; i++)
	{
		Num = RandomNum(6);
		//LOG_Out(_T("Generate thread #%d with depth %d"), i, Num);
		printf("\tGenerate thread #%d with depth %d\n", i, Num);
		if (pHandles != NULL)
			pHandles[i] = CreateThread(NULL, 0, ThreadProc, (LPVOID) Num, CREATE_SUSPENDED, &dwThreadId); 
		else
			CreateThread(NULL, 0, ThreadProc, (LPVOID) Num, 0, &dwThreadId); 

	}

	if (pHandles != NULL)
	{
		//
		// start all threads
		//
		for (i = 0; i < nTotalThreads; i++)
		{
			ResumeThread(pHandles[i]);
		}
		HeapFree(GetProcessHeap(), 0, (LPVOID)pHandles);
	}

}


int main(int argc, char* argv[])
{
	LOG_Block("main");
	int nWaitSeconds = 5 * 1000;;
	int nThreads= 20;
	if (argc > 1)
	{
		nWaitSeconds = abs(atoi(argv[1])) * 1000;
	}
	LOG_Out(_T("Found timing %d seconds"), nWaitSeconds/1000);
	if (argc > 2)
	{
		nThreads = abs(atoi(argv[2]));
	}
	LOG_Out(_T("Found number of threads: %d"), nThreads);

		
	g_QuitEvent = CreateEvent(NULL, TRUE, FALSE, TestQuitEvent);

	printf("Start threading ....\n");

	StartThreadTesting(nThreads);

	printf("Finished threading\n");

	int iStart = (int)GetTickCount();
	int nNow = (int)GetTickCount();
	while (nNow <  iStart + nWaitSeconds)
	{
		printf("Wait for %d more seconds...\n", (nWaitSeconds - (nNow - iStart))/1000);
		Sleep(2000);
		nNow = (int)GetTickCount();
	}

	//
	// tell that we need to quit
	//
	SetEvent(g_QuitEvent);

	//
	// wait for threads to quit
	//
	int nCnt = g_Cnt;
	iStart = (int)GetTickCount();

	while (nCnt > 0)
	{
		Sleep(1000);
		printf("Seconds: %d, Threads: %d\n", ((int)GetTickCount() - iStart)/1000, nCnt);
		nCnt = g_Cnt;
	}



	//
	// quit
	//
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\urllogging\sources.inc ===
#
# Copyright (c) 2001	Microsoft Corporation
#
# Module Name:	URLLogging
#
# Abstract:		A class performs URL logging
#
MAJORCOMP=windows.com
MINORCOMP=lib.URLLogging

TARGETNAME=URLLogging
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\URLLogging.cpp \
	..\internet.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\urlagent\urlagent.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	UrlAgent.cpp
//
//  Description:
//
//		This class encapsulates the logic about where to get the right logic
//		for various purposes, including the case of running WU in corporate 
//		environments.
//
//		An object based on this class should be created first, then call
//		GetOriginalIdentServer() function to get where to download ident,
//		then download ident, then call PopulateData() function to read
//		all URL related data.
// 
//  Created by: 
//		Charles Ma
//
//	Date Creatd:
//		Oct 19, 2001
//
//***********************************************************************************

#include <windows.h>
#include <iucommon.h>
#include <osdet.h>
#include <logging.h>
#include <fileUtil.h>
#include <memutil.h>
#include <shlwapi.h>
#include <UrlAgent.h>

#include <MISTSAFE.h>
#include <wusafefn.h>



#ifndef INTERNET_MAX_URL_LENGTH
#define INTERNET_MAX_URL_LENGTH  2200
#endif

//
// starting size of url array
//
const int C_INIT_URL_ARRAY_SIZE = 4;	// for time being,we only have this many clients

//
// define the default original ident url
//
const TCHAR C_DEFAULT_IDENT_URL[] = _T("http://windowsupdate.microsoft.com/v4/");

//
// define reg keys to get ident server override for debugging
//
const TCHAR REGKEY_IDENT_SERV[] = _T("IdentServer");
const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");

const TCHAR REGVAL_ISBETA[] = _T("IsBeta");

//
// define reg keys used by related policies 
//

//
// define policy location
//
const TCHAR REGKEY_CORPWU_POLICY[] = _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate");

//
// define ident and selfupdate server, and ping server
//
const TCHAR REGKEY_CORPWU_WUSERVER[] = _T("WUServer");
const TCHAR REGKEY_CORPWU_PINGSERVER[] = _T("WUStatusServer");

//
// define the boolean (DWORD) value under each client
//
const TCHAR REGKEY_USEWUSERVER[] = _T("UseWUServer");


//
// define ident data
//
const TCHAR IDENT_SECTION_PINGSERVER[] = _T("IUPingServer");	// section name in ident
const TCHAR IDENT_ENTRY_SERVERURL[] = _T("ServerUrl");			// ping server entry name
const TCHAR IDENT_SECITON_IUSERVERCACHE[] = _T("IUServerCache");	// query server section
const TCHAR IDENT_ENTRY_QUERYSEVERINDEX[] = _T("QueryServerIndex");	// suffix of client entry
const TCHAR IDENT_ENTRY_BETAQUERYSERVERINDEX[] = _T("BetaQueryServerIndex"); // for beta server
const TCHAR IDENT_ENTRY_SERVER[] = _T("Server");				// prefix of server entry

// main IU selfupdate keys
const TCHAR IDENT_IUSELFUPDATE[] = _T("IUSelfUpdate");
const TCHAR IDENT_IUBETASELFUPDATE[] = _T("IUBetaSelfUpdate");
const TCHAR IDENT_STRUCTUREKEY[] = _T("StructureKey");
// IU selfupdate architecture flags
const TCHAR IDENT_ARCH[] = _T("ARCH");
const TCHAR IDENT_OS[] = _T("OS");
const TCHAR IDENT_LOCALE[] = _T("LOCALE");
const TCHAR IDENT_CHARTYPE[] = _T("CHARTYPE");
// IU selfupdate sections
const TCHAR IDENT_IUARCH[] = _T("IUArch");
const TCHAR IDENT_IUOS[] = _T("IUOS");
const TCHAR IDENT_IULOCALE[] = _T("IULocale");
const TCHAR IDENT_IUCHARTYPE[] = _T("IUCharType");
// IU selfupdate arch keys
const TCHAR IDENT_X86[] = _T("x86");
const TCHAR IDENT_IA64[] = _T("ia64");
// IU selfupdate chartypes
const TCHAR IDENT_ANSI[] = _T("ansi");
const TCHAR IDENT_UNICODE[] = _T("unicode");

const TCHAR SLASHENGINECAB[] = _T("/iuengine.cab");

// AU specific:
const TCHAR CLIENT_AU[] = _T("AU");
const TCHAR CLIENT_AU_DRIVER[] = _T("AUDriver");

// *********************************************************************
// 
// begin of class implementation
//
// *********************************************************************


CUrlAgent::CUrlAgent(void)
: 	m_fPopulated(FALSE),
	m_pszOrigIdentUrl(NULL),
	m_pszInternetPingUrl(NULL),
	m_pszIntranetPingUrl(NULL),
	m_pszWUServer(NULL),
	m_ArrayUrls(NULL),
	m_nArrayUrlCount(0),
	m_nArraySize(0),
	m_nOrigIdentUrlBufSize(0),
	m_fIdentFromPolicy(FALSE)
{

	HKEY hKey = NULL;
	DWORD dwRegCheckResult = 0;
	DWORD dwSize = 0, dwType, dwValue;

	LOG_Block("CUrlAgent::CUrlAgent()");

	//
	// always try to get original ident server url
	//
	m_hProcHeap = GetProcessHeap();

	if (NULL != m_hProcHeap)
	{
		m_nOrigIdentUrlBufSize = __max(
									MAX_PATH, // reg based?
									sizeof(C_DEFAULT_IDENT_URL)/sizeof(TCHAR)); // default

		m_pszOrigIdentUrl = (LPTSTR) 
					HeapAlloc(
							m_hProcHeap,	// allocate from process heap
							HEAP_ZERO_MEMORY, 
							sizeof(TCHAR) * m_nOrigIdentUrlBufSize);

		if (NULL != m_pszOrigIdentUrl)
		{
			//
			// first, check to see if there is debug override
			//
		    dwRegCheckResult= RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ, &hKey);
		    if (ERROR_SUCCESS == dwRegCheckResult)
		    {
				dwSize = sizeof(TCHAR) * m_nOrigIdentUrlBufSize;
			    dwRegCheckResult = RegQueryValueEx(hKey, REGKEY_IDENT_SERV, NULL, &dwType, (LPBYTE)m_pszOrigIdentUrl, &dwSize);
			    if (ERROR_SUCCESS == dwRegCheckResult)
			    {
				    if (REG_SZ == dwType)
					{
						LOG_Internet(_T("Found debugging Ident-URL %s"), m_pszOrigIdentUrl);
					}
					else
				    {
					    dwRegCheckResult = ERROR_SUCCESS + 1;	// any error number will do
				    }
			    }
			    RegCloseKey(hKey);
		    }

		    if (ERROR_SUCCESS != dwRegCheckResult)
		    {
				//
				// if there is no debug override, check to see if there is policy define
				// ident server for corporate case
				//
				dwRegCheckResult= RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_CORPWU_POLICY, 0, KEY_READ, &hKey);
				if (ERROR_SUCCESS == dwRegCheckResult)
				{
					dwSize = sizeof(TCHAR) * m_nOrigIdentUrlBufSize;
					dwRegCheckResult = RegQueryValueEx(hKey, REGKEY_CORPWU_WUSERVER, NULL, &dwType, (LPBYTE)m_pszOrigIdentUrl, &dwSize);
					if (ERROR_SUCCESS == dwRegCheckResult && REG_SZ == dwType)
					{
						m_fIdentFromPolicy = TRUE;
						
						//
						// for any client that its name appear here as a subkey, and
						// has a value "UseWUServer" set to 1 under the subkey, then
						// this will also be the base url used to construct the query url
						// for that client
						//
						m_pszWUServer = m_pszOrigIdentUrl;

					    LOG_Internet(_T("Found corp Ident-URL %s"), m_pszOrigIdentUrl);

						//
						// since we found wu server, for any client uses this url,
						// we can also have an optional ping server
						//
						m_pszIntranetPingUrl = (LPTSTR) HeapAlloc(
											m_hProcHeap,
											HEAP_ZERO_MEMORY, 
											sizeof(TCHAR) * m_nOrigIdentUrlBufSize);
						dwSize = sizeof(TCHAR) * m_nOrigIdentUrlBufSize;
						if (NULL != m_pszIntranetPingUrl)
						{
							if (ERROR_SUCCESS != (dwRegCheckResult = RegQueryValueEx(hKey, REGKEY_CORPWU_PINGSERVER, NULL, &dwType, (LPBYTE)m_pszIntranetPingUrl, &dwSize)) || REG_SZ != dwType)
							{
								StringCchCopyEx(m_pszIntranetPingUrl,m_nOrigIdentUrlBufSize,m_pszOrigIdentUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
								dwRegCheckResult = ERROR_SUCCESS;
							}
						}
					}
					else
					{
						dwRegCheckResult = ERROR_SUCCESS + 1;	// any error number will do
					}
					RegCloseKey(hKey);
				}
		    }

		    if (ERROR_SUCCESS != dwRegCheckResult)
		    {
				//
				// not debugging , neither corporate policy found
				//
				
				StringCchCopyEx(m_pszOrigIdentUrl,m_nOrigIdentUrlBufSize,C_DEFAULT_IDENT_URL,NULL,NULL,MISTSAFE_STRING_FLAGS);
				LOG_Internet(_T("Use default ident URL %s"), m_pszOrigIdentUrl);
			}
		}
	}
	else
	{
		LOG_ErrorMsg(GetLastError());
	}

	//
    // Check IUControl Reg Key for Beta Mode
	//
	m_fIsBetaMode = FALSE;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hKey))
    {
		dwValue = 0;
		dwSize = sizeof(dwValue);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGVAL_ISBETA, NULL, NULL, (LPBYTE)&dwValue, &dwSize))
        {
            m_fIsBetaMode = (1 == dwValue);
        }
        RegCloseKey(hKey);
    }
}	


CUrlAgent::~CUrlAgent(void)
{
	DesertData();

	SafeHeapFree(m_pszOrigIdentUrl);
	SafeHeapFree(m_pszIntranetPingUrl);
}



//------------------------------------------------------------------------
//
// this function should be called after you downloaded ident, and get
// a fresh copy of ident text file from the cab, after verifying cab was
// signed properly.
//
// this function reads data from ident and registry
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::PopulateData(void)
{
	LOG_Block("CUrlAgent::PopuldateData");

	if (m_fPopulated)
		return S_OK;

	HRESULT	hr = S_OK;
	LPTSTR	pszBuffer = NULL;
	LPTSTR	pszCurrentKey = NULL;	// ptr only, no memory alloc
	LPTSTR	pszUrlBuffer = NULL;
	LPCTSTR	pcszSuffix = (m_fIsBetaMode ? IDENT_ENTRY_BETAQUERYSERVERINDEX : IDENT_ENTRY_QUERYSEVERINDEX);
	HKEY	hKey = NULL;
	DWORD	dwRegCheckResult = 0;
	DWORD	dwSize = 0, 
			dwType,
			dwValue = 0;

	int		iLen = 0, iLenSuffix = 0;
	TCHAR	szIdentBuffer[MAX_PATH + 1];
	TCHAR	szIdentFile[MAX_PATH + 1];

	if (NULL == m_hProcHeap)
	{
		return E_FAIL;
	}

	pszUrlBuffer = (LPTSTR) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, sizeof(TCHAR)*INTERNET_MAX_URL_LENGTH);
	CleanUpFailedAllocSetHrMsg(pszUrlBuffer);


	GetIndustryUpdateDirectory(szIdentBuffer);
	
	
	hr=PathCchCombine(szIdentFile,ARRAYSIZE(szIdentFile), szIdentBuffer, IDENTTXT);

	if(FAILED(hr))
	{
		SafeHeapFree(pszUrlBuffer);
		LOG_ErrorMsg(hr);
		return hr;
	}

	//
	// make sure we release all data, if any
	//
	DesertData();
	
	//
	// before populate per-client array, we want to find out inter net ping server
	//
	m_pszInternetPingUrl = RetrieveIdentStrAlloc(
								IDENT_SECTION_PINGSERVER, 
								IDENT_ENTRY_SERVERURL, 
								NULL, 
								szIdentFile);

	//
	// allocate array of pointers for storing each server node
	//
	m_ArrayUrls = (PServerPerClient) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, C_INIT_URL_ARRAY_SIZE * sizeof(ServerPerClient));
	CleanUpFailedAllocSetHrMsg(m_ArrayUrls);

	m_nArraySize = C_INIT_URL_ARRAY_SIZE;	// now array is this big

	//
	// try to read data from policy first, if WU server exists
	//
	if (NULL != m_pszWUServer && 
		ERROR_SUCCESS == (dwRegCheckResult= RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_CORPWU_POLICY, 0, KEY_READ, &hKey)))
	{
		//
		// the way we find a client name under WU policy is, to open this key, see if it has a value
		// called "UseWUServer"
		//
		DWORD dwSubKeyIndex = 0;
		TCHAR szKeyName[32];
	
		while (TRUE)
		{
		DWORD dwKeyBufLen = ARRAYSIZE(szKeyName);
		dwRegCheckResult = RegEnumKeyEx(
									  hKey,             // handle to key to enumerate
									  dwSubKeyIndex,    // subkey index
									  szKeyName,        // subkey name
									  &dwKeyBufLen,     // size of subkey buffer
									  NULL,				// reserved
									  NULL,             // class string buffer
									  NULL,				// size of class string buffer
									  NULL				// last write time
									);
			if (ERROR_SUCCESS == dwRegCheckResult)
			{
				//
				// try to open this key
				//
				HKEY hKeyClient = NULL;
				dwRegCheckResult= RegOpenKeyEx(hKey, szKeyName, 0, KEY_READ, &hKeyClient);
				if (ERROR_SUCCESS == dwRegCheckResult)
				{
					//
					// try to see if it has a value called UseWUServer
					//
					dwValue = 0;
					dwType = REG_DWORD;
					dwSize = sizeof(dwValue);
					dwRegCheckResult = RegQueryValueEx(hKeyClient, REGKEY_USEWUSERVER, NULL, &dwType, (LPBYTE) &dwValue, &dwSize);
					if (ERROR_SUCCESS == dwRegCheckResult && REG_DWORD == dwType && 0x1 == dwValue)
					{
						LOG_Internet(_T("Found client %s\\UseWUServer=1"), szKeyName);

						//
						// we want to add this client to our url array
						//
						CleanUpIfFailedAndSetHrMsg(ExpandArrayIfNeeded());

						m_ArrayUrls[m_nArrayUrlCount].pszClientName = (LPTSTR)HeapAllocCopy(szKeyName, sizeof(TCHAR) * (lstrlen(szKeyName) + 1));
						CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszClientName);
						m_ArrayUrls[m_nArrayUrlCount].pszQueryServer = (LPTSTR) HeapAllocCopy(m_pszOrigIdentUrl, sizeof(TCHAR) * (lstrlen(m_pszOrigIdentUrl) + 1));
						CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszQueryServer);
						m_ArrayUrls[m_nArrayUrlCount].fInternalServer = TRUE;
						m_nArrayUrlCount++; // increase counter by 1

						//
						// BUG 507500 AUDriver Policy - 
						// map calls with the "AUDriver client to "AU" when checking the policy for usewuserver
						//
						if (CSTR_EQUAL == WUCompareStringI(szKeyName, CLIENT_AU))
						{
							//
							// we want to add client "AUDriver" to our url array
							//
							CleanUpIfFailedAndSetHrMsg(ExpandArrayIfNeeded());

							m_ArrayUrls[m_nArrayUrlCount].pszClientName = (LPTSTR)HeapAllocCopy((LPTSTR)CLIENT_AU_DRIVER, sizeof(TCHAR) * (lstrlen(CLIENT_AU_DRIVER) + 1));
							CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszClientName);
							m_ArrayUrls[m_nArrayUrlCount].pszQueryServer = (LPTSTR) HeapAllocCopy(m_pszOrigIdentUrl, sizeof(TCHAR) * (lstrlen(m_pszOrigIdentUrl) + 1));
							CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszQueryServer);
							m_ArrayUrls[m_nArrayUrlCount].fInternalServer = TRUE;
							m_nArrayUrlCount++; // increase counter by 1
						}
					}
				}
				RegCloseKey(hKeyClient);
			}
			else
			{
				if (ERROR_NO_MORE_ITEMS == dwRegCheckResult)
				{
					//
					// there is no more sub key to loop through. get out here
					//
					break;
				}
				//
				// otherwise, we try next sub key
				//
			}

			dwSubKeyIndex++; // try next sub key
		}

		RegCloseKey(hKey); // done with policy reg
	}

	//
	// now we should continue to work on internet case
	// that is, to retrieve query server(s) from ident
	//
	dwSize = MAX_PATH;
	pszBuffer = (LPTSTR) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
	while (NULL != pszBuffer &&
		   GetPrivateProfileString(
						IDENT_SECITON_IUSERVERCACHE, 
						NULL, 
						_T(""), 
						pszBuffer, 
						dwSize, 
						szIdentFile) == dwSize-2)
	{
		//
		// buffer too small? 
		//
		dwSize *= 2;

		LPTSTR pszTemp = (LPTSTR) HeapReAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, pszBuffer, dwSize * sizeof(TCHAR));
		if (NULL != pszTemp)
		{
			pszBuffer = pszTemp;
		}
		else
		{
			//
			// HeapReAlloc failed, bail from while with origional allocation freed
			//
			SafeHeapFree(pszBuffer);
		}
	}
	
	CleanUpFailedAllocSetHrMsg(pszBuffer);

	//
	// loop through each key
	//
	pszCurrentKey = pszBuffer;
	while ('\0' != *pszCurrentKey)
	{
		//
		// for the current key, we first try to see if its index key or server key
		// if it's not index key, skip it
		//
		iLen = lstrlen(pszCurrentKey);
		iLenSuffix = lstrlen(pcszSuffix);
		if ((iLen > iLenSuffix) && (0 == StrCmpI((pszCurrentKey + (iLen - iLenSuffix)), pcszSuffix)))
		{
			TCHAR szClient[MAX_PATH];	// isn't MAX_PATH big enough?
			int nIndex = 0;
			BOOL fExist = FALSE;

			//
			// retrieve server index from this key
			//
			nIndex = GetPrivateProfileInt(IDENT_SECITON_IUSERVERCACHE, pszCurrentKey, 0, szIdentFile); 

			//
			// no use of szIdentBuffer, so utilize it here
			//
			
			CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szIdentBuffer,ARRAYSIZE(szIdentBuffer),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("%s%d"), IDENT_ENTRY_SERVER, nIndex));
			
			GetPrivateProfileString(
								IDENT_SECITON_IUSERVERCACHE, 
								szIdentBuffer,		// use current str as key
								_T(""), 
								pszUrlBuffer, 
								INTERNET_MAX_URL_LENGTH, 
								szIdentFile);
			if ('0' != *pszUrlBuffer)
			{
				//
				// this is an index key!
				// try to extract client name from this key
				//
				
				CleanUpIfFailedAndSetHrMsg(StringCchCopyNEx(szClient,ARRAYSIZE(szClient),pszCurrentKey,iLen - iLenSuffix,NULL,NULL,MISTSAFE_STRING_FLAGS));
				
			
				//
				// find out if this client is already defined in policy and therefore
				// arleady got data in the url array
				//
				for (int i = 0; i < m_nArrayUrlCount && !fExist; i++)
				{
					fExist= (StrCmpI(m_ArrayUrls[i].pszClientName, szClient) == 0);
				}

				if (!fExist)
				{					
					CleanUpIfFailedAndSetHrMsg(ExpandArrayIfNeeded());
					m_ArrayUrls[m_nArrayUrlCount].pszClientName = (LPTSTR)HeapAllocCopy(szClient, sizeof(TCHAR) * (lstrlen(szClient) + 1));
					CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszClientName);
					m_ArrayUrls[m_nArrayUrlCount].pszQueryServer = (LPTSTR) HeapAllocCopy(pszUrlBuffer, sizeof(TCHAR) * (lstrlen(pszUrlBuffer) + 1));
					CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszQueryServer);
					m_ArrayUrls[m_nArrayUrlCount].fInternalServer = FALSE;
					m_nArrayUrlCount++; // increase counter by 1
				}
				else
				{	
					//
					// this client is already defined in policy, we just need to append the QueryServer with the
					// rest of the url path defined in iuident
					//
					LPTSTR pszPath = NULL;
					//
					// find "//" in URL retrieved from iuident          
					//
					if (NULL == (pszPath = StrStrI(pszUrlBuffer, _T("//"))))
					{
						// unexpected error
						hr = E_FAIL;
						LOG_ErrorMsg(hr);
						goto CleanUp;
					}
					else
					{
						//
						// find next "/" in URL retrieved from iuident
						//
						if (NULL != (pszPath = StrStrI(pszPath+2, _T("/"))))
						{
							DWORD dwLen = 0;
							LPTSTR pszTemp = NULL;
							//
							// remove trailing "/" in URL retrieved from policy
							//
							if (_T('/') == *(m_ArrayUrls[i-1].pszQueryServer + lstrlen(m_ArrayUrls[i-1].pszQueryServer) - 1))
							{
								dwLen = lstrlen(m_ArrayUrls[i-1].pszQueryServer) + lstrlen(pszPath);
								pszTemp = (LPTSTR)HeapReAlloc(GetProcessHeap(),
																	HEAP_ZERO_MEMORY,
																	m_ArrayUrls[i-1].pszQueryServer,
																	sizeof(TCHAR) * dwLen);
								CleanUpFailedAllocSetHrMsg(pszTemp);
								m_ArrayUrls[i-1].pszQueryServer = pszTemp;

								hr=StringCchCatEx(m_ArrayUrls[i-1].pszQueryServer,dwLen,pszPath + 1,NULL,NULL,MISTSAFE_STRING_FLAGS);
								if(FAILED(hr))
								{
									LOG_ErrorMsg(hr);
									SafeHeapFree(pszTemp);
									m_ArrayUrls[i-1].pszQueryServer=NULL;
									
								}
								
							}
							else
							{
								dwLen = lstrlen(m_ArrayUrls[i-1].pszQueryServer) + lstrlen(pszPath) + 1;
								pszTemp = (LPTSTR)HeapReAlloc(GetProcessHeap(),
																	HEAP_ZERO_MEMORY,
																	m_ArrayUrls[i-1].pszQueryServer,
																	sizeof(TCHAR) * dwLen);
								CleanUpFailedAllocSetHrMsg(pszTemp);
								m_ArrayUrls[i-1].pszQueryServer = pszTemp;
								
								hr=StringCchCatEx(m_ArrayUrls[i-1].pszQueryServer,dwLen,pszPath,NULL,NULL,MISTSAFE_STRING_FLAGS);
								if(FAILED(hr))
								{
									LOG_ErrorMsg(hr);
									SafeHeapFree(pszTemp);
									m_ArrayUrls[i-1].pszQueryServer=NULL;
								
								}

								
							}
						}
					}					
				}
			}
		}

		//
		// move to next string
		//
		pszCurrentKey += lstrlen(pszCurrentKey) + 1;
	}

	
CleanUp:

	if (FAILED(hr))
	{
		//
		// clean up half-way populated data
		//
		DesertData();
	}
	else
	{
		m_fPopulated = TRUE;
	}

	SafeHeapFree(pszBuffer);
	SafeHeapFree(pszUrlBuffer);

	return hr;
}

	
	
//------------------------------------------------------------------------
//
// get the original ident server. 
// *** this API should be called before PopulateData() is called ***
// *** this API should be called to retrieve the base URL where you download ident ***
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::GetOriginalIdentServer(
			LPTSTR lpsBuffer, 
			int nBufferSize,
			BOOL* pfInternalServer /*= NULL*/)
{
	
	HRESULT hr=S_OK;

	if (NULL == lpsBuffer)
	{
		return E_INVALIDARG;
	}

	nBufferSize/=sizeof(TCHAR);

	if (nBufferSize <= lstrlen(m_pszOrigIdentUrl))
	{
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}

	

	hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_pszOrigIdentUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
	if( FAILED(hr) )
	{ 
		return  hr;
	}


	if (NULL != pfInternalServer)
	{
		*pfInternalServer = m_fIdentFromPolicy;
	}

	return S_OK;
}



//------------------------------------------------------------------------
//
// get the ping/status server
// *** this API should be called after PopulateData() is called ***
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::GetLivePingServer(
			LPTSTR lpsBuffer, 
			int nBufferSize)
{

	HRESULT hr=S_OK;

	if (!m_fPopulated)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	if (NULL == lpsBuffer || 0 >= nBufferSize)
	{
		return E_INVALIDARG;
	}

	nBufferSize/=sizeof(TCHAR);

	if (NULL != m_pszInternetPingUrl &&
		_T('\0') != *m_pszInternetPingUrl)
	{
		if (nBufferSize <= lstrlen(m_pszInternetPingUrl))
		{
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
		else
		{
			
			hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_pszInternetPingUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
			if(FAILED(hr))
				return hr;
		}
	}
	else
	{
		*lpsBuffer = _T('\0');
	}
	return S_OK;
}


// *** this API can be called before PopulateData() is called ***
HRESULT CUrlAgent::GetCorpPingServer(
			LPTSTR lpsBuffer, 
			int nBufferSize)
{
	HRESULT hr=S_OK;

	if (NULL == m_pszIntranetPingUrl)
	{
		return (E_OUTOFMEMORY);
	}

	if (NULL == lpsBuffer || 0 >= nBufferSize)
	{
		return E_INVALIDARG;
	}
	nBufferSize/=sizeof(TCHAR);

	if (NULL != m_pszIntranetPingUrl &&
		_T('\0') != *m_pszIntranetPingUrl)
	{
		if (nBufferSize <= lstrlen(m_pszIntranetPingUrl))
		{
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
		else
		{
			

			hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_pszIntranetPingUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
			if(FAILED(hr))
				return hr;
			
		}
	}
	else
	{
		*lpsBuffer = _T('\0');
	}
	return hr;
}



//------------------------------------------------------------------------
//
// get the query server. this is per client based
// *** this API should be called after PopulateData() is called ***
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::GetQueryServer(
			LPCTSTR lpsClientName, 
			LPTSTR lpsBuffer, 
			int nBufferSize,
			BOOL* pfInternalServer /*= NULL*/)
{
	
	HRESULT hr=S_OK;

	if (!m_fPopulated)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	if (NULL == lpsClientName || NULL == lpsBuffer)
	{
		return E_INVALIDARG;
	}

	nBufferSize/=sizeof(TCHAR);

	for (int i = 0; i < m_nArrayUrlCount; i++)
	{
		if (StrCmpI(m_ArrayUrls[i].pszClientName, lpsClientName) == 0)
		{
			if (nBufferSize <= lstrlen(m_ArrayUrls[i].pszQueryServer))
			{
				return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			}
			else
			{				
				hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_ArrayUrls[i].pszQueryServer,NULL,NULL,MISTSAFE_STRING_FLAGS);
				if(FAILED(hr)) return hr;

				if (NULL != pfInternalServer)
				{
					*pfInternalServer = m_ArrayUrls[i].fInternalServer;
				}
			}
			return S_OK;
		}
	}

	return ERROR_IU_QUERYSERVER_NOT_FOUND;
}



//------------------------------------------------------------------------
//
// tell if a particular client is controlled by policy in corporate
// returns: 
//			S_OK = TRUE
//			S_FALSE = FALSE
//			other = error, so don't know
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::IsClientSpecifiedByPolicy(
			LPCTSTR lpsClientName
			)
{

	HRESULT hr=S_OK;

	if (!m_fPopulated)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	if (NULL == lpsClientName)
	{
		return E_INVALIDARG;
	}

	for (int i = 0; i < m_nArrayUrlCount; i++)
	{
		if (StrCmpI(m_ArrayUrls[i].pszClientName, lpsClientName) == 0)
		{
			return (m_ArrayUrls[i].fInternalServer) ? S_OK : S_FALSE;
		}
	}

	return S_FALSE;
}


HRESULT CUrlAgent::IsIdentFromPolicy()
{
	return TRUE == m_fIdentFromPolicy ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------
//
// private function, to clean up. called by destructor
//
//------------------------------------------------------------------------
void CUrlAgent::DesertData(void)
{
	LOG_Block("CUrlAgent::DesertData");

	if (NULL != m_ArrayUrls && m_nArrayUrlCount > 0)
	{
		for (int i = 0; i < m_nArrayUrlCount; i++)
		{
			SafeHeapFree(m_ArrayUrls[i].pszClientName);
			SafeHeapFree(m_ArrayUrls[i].pszQueryServer);
		}
		SafeHeapFree(m_ArrayUrls);
		m_nArrayUrlCount = 0;
		m_nArraySize = 0;
	}

	SafeHeapFree(m_pszInternetPingUrl);

	m_fPopulated = FALSE;
}




//------------------------------------------------------------------------
//
// private function, retrieve string from ident
// allocated memory will be multiple of MAX_PATH long.
//
//------------------------------------------------------------------------
LPTSTR CUrlAgent::RetrieveIdentStrAlloc(
					LPCTSTR pSection,
					LPCTSTR pEntry,
					LPDWORD lpdwSizeAllocated, 
					LPCTSTR lpszIdentFile)
{
	LPTSTR pBuffer = NULL;
	DWORD dwSize = MAX_PATH;
	DWORD dwRet = 0;
	TCHAR szIdentFile[MAX_PATH + 1];

	if (NULL == pSection || NULL == pEntry || NULL == lpszIdentFile)
	{
		return NULL;
	}
	
	//
	// try to allocate buffer first
	//
	while (TRUE)
	{
		pBuffer = (LPTSTR) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, sizeof(TCHAR) * dwSize);
		if (NULL == pBuffer)
		{
			break;
		}

		dwRet = GetPrivateProfileString(
							pSection,
							pEntry,
							_T(""),
							pBuffer,
							dwSize,
							lpszIdentFile);
		if (dwSize - 1 != dwRet)
		{
			if ('\0' == pBuffer)
			{
				//
				// no such data found from ident!
				//
				SafeHeapFree(pBuffer);
			}
			//
			// we are done!
			//
			break;
		}
		
		//
		// assume it's buffer too small
		//
		SafeHeapFree(pBuffer);
		dwSize += MAX_PATH;		// increase by 255
	}

	if (NULL != lpdwSizeAllocated)
	{
		*lpdwSizeAllocated = dwSize;
	}

	return pBuffer;
}




//------------------------------------------------------------------------
//
// helper function
// if there is no empty slot, double the size of url array
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::ExpandArrayIfNeeded(void)
{
	HRESULT hr = S_OK;
	LOG_Block("CUrlAgent::ExpandArrayIfNeeded()");

	if (m_nArrayUrlCount >= m_nArraySize)
	{
		//
		// we have used up all data slots. need to expand array
		//
		m_nArraySize *= 2;
		PServerPerClient pNewArray = (PServerPerClient) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, m_nArraySize * sizeof(ServerPerClient));
		if (NULL == pNewArray)
		{
			m_nArraySize /= 2;	// shrink it back
			SetHrMsgAndGotoCleanUp(E_OUTOFMEMORY);
		}
		//
		// copy old data to this new array
		//
		for (int i = 0; i < m_nArrayUrlCount; i++)
		{
			pNewArray[i] = m_ArrayUrls[i];
		}

		HeapFree(m_hProcHeap, 0, m_ArrayUrls);
		m_ArrayUrls = pNewArray;
	}
CleanUp:
	return hr;
}



// *********************************************************************
// 
// begin of derived class implementation
//
// *********************************************************************
CIUUrlAgent::CIUUrlAgent()
: 	m_fIUPopulated(FALSE),
	m_pszSelfUpdateUrl(NULL)
{
	if (m_fIdentFromPolicy)
	{
		//
		// since we found wu server, set selfupdate url to it
		//
		m_pszSelfUpdateUrl = (LPTSTR) HeapAlloc(
						m_hProcHeap,
						HEAP_ZERO_MEMORY, 
						sizeof(TCHAR) * m_nOrigIdentUrlBufSize);
		if (NULL != m_pszSelfUpdateUrl)
		{
			
			//No check is made  for the return value since this is a constructor and failure codes cannot be returned
			StringCchCopyEx(m_pszSelfUpdateUrl,m_nOrigIdentUrlBufSize,m_pszOrigIdentUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);

		}
	}
}



CIUUrlAgent::~CIUUrlAgent()
{
	m_fIUPopulated = FALSE;
	SafeHeapFree(m_pszSelfUpdateUrl);
}



//------------------------------------------------------------------------
//
// PopulateData():
// Do base class PopulateData() and then populate self-update url
//
//------------------------------------------------------------------------
HRESULT CIUUrlAgent::PopulateData(void)
{
	LOG_Block("CIUUrlAgent::PopulateData");

	if (m_fIUPopulated)
		return S_OK;

	HRESULT hr = ((CUrlAgent*)this)->PopulateData();
	if (FAILED(hr))
		return hr;

	//
	// we need to populate the self-update url from iuident if wu server is not present
	//
	if (!m_fIdentFromPolicy)
	{
		if (NULL == m_hProcHeap)
		{
			return E_FAIL;
		}

		TCHAR	szBaseServerUrl[INTERNET_MAX_URL_LENGTH];
		TCHAR	szSelfUpdateStructure[MAX_PATH];
		TCHAR	szServerDirectory[MAX_PATH] = { '\0' };
		TCHAR	szLocalPath[MAX_PATH];
		TCHAR	szValue[MAX_PATH];
		LPTSTR	pszWalk = NULL, pszDelim = NULL;		
		TCHAR	szIdentBuffer[MAX_PATH + 1];
		TCHAR	szIdentFile[MAX_PATH + 1];

		GetIndustryUpdateDirectory(szIdentBuffer);

		hr=PathCchCombine(szIdentFile,ARRAYSIZE(szIdentFile),szIdentBuffer, IDENTTXT);
		if(FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			return hr;
		}
			
		m_pszSelfUpdateUrl = (LPTSTR) HeapAlloc(
							m_hProcHeap,
							HEAP_ZERO_MEMORY, 
							sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH);
		CleanUpFailedAllocSetHrMsg(m_pszSelfUpdateUrl);

		// Get SelfUpdate Server URL
		GetPrivateProfileString(m_fIsBetaMode ? IDENT_IUBETASELFUPDATE : IDENT_IUSELFUPDATE, 
								IDENT_ENTRY_SERVERURL, 
								_T(""), 
								szBaseServerUrl, 
								ARRAYSIZE(szBaseServerUrl), 
								szIdentFile);

		if ('\0' == szBaseServerUrl[0])
		{
			// no URL specified in iuident.. 
			LOG_ErrorMsg(ERROR_IU_SELFUPDSERVER_NOT_FOUND);
			hr = ERROR_IU_SELFUPDSERVER_NOT_FOUND;
			goto CleanUp;
		}

		// Get SelfUpdate Structure Key
		// ARCH|LOCALE
		GetPrivateProfileString(m_fIsBetaMode ? IDENT_IUBETASELFUPDATE : IDENT_IUSELFUPDATE, 
								IDENT_STRUCTUREKEY, 
								_T(""), 
								szSelfUpdateStructure, 
								ARRAYSIZE(szSelfUpdateStructure), 
								szIdentFile);

		if ('\0' == szSelfUpdateStructure[0])
		{
			// no SelfUpdate Structure in iudent
			LOG_ErrorMsg(ERROR_IU_SELFUPDSERVER_NOT_FOUND);
			hr = ERROR_IU_SELFUPDSERVER_NOT_FOUND;
			goto CleanUp;
		}

		// Parse the SelfUpdate Structure Key for Value Names to Read
		// Initially we will only have an ARCH key.. 

		pszWalk = szSelfUpdateStructure;
		while (NULL != (pszDelim = StrChr(pszWalk, '|')))
		{
			*pszDelim = '\0';

			if (0 == StrCmpI(pszWalk, IDENT_ARCH))
			{
	#ifdef _IA64_
				GetPrivateProfileString(IDENT_IUARCH, IDENT_IA64, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
	#else
				GetPrivateProfileString(IDENT_IUARCH, IDENT_X86, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
	#endif
			}
			else if (0 == StrCmpI(pszWalk, IDENT_OS))
			{
				// Get the Current OS String
				GetIdentPlatformString(szLocalPath, ARRAYSIZE(szLocalPath));
				if ('\0' == szLocalPath[0])
				{
					LOG_ErrorMsg(ERROR_IU_SELFUPDSERVER_NOT_FOUND);
					hr = ERROR_IU_SELFUPDSERVER_NOT_FOUND;
					goto CleanUp;
				}
				GetPrivateProfileString(IDENT_IUOS, szLocalPath, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
			}
			else if (0 == StrCmpI(pszWalk, IDENT_LOCALE))
			{
				// Get the Current Locale String
				GetIdentLocaleString(szLocalPath, ARRAYSIZE(szLocalPath));
				if ('\0' == szLocalPath[0])
				{
					LOG_ErrorMsg(ERROR_IU_SELFUPDSERVER_NOT_FOUND);
					hr = ERROR_IU_SELFUPDSERVER_NOT_FOUND;
					goto CleanUp;
				}
				GetPrivateProfileString(IDENT_IULOCALE, szLocalPath, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
			}
			else if (0 == StrCmpI(pszWalk, IDENT_CHARTYPE))
			{
	#ifdef UNICODE
				GetPrivateProfileString(IDENT_IUCHARTYPE, IDENT_UNICODE, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
	#else
				GetPrivateProfileString(IDENT_IUCHARTYPE, IDENT_ANSI, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
	#endif
			}
			else
			{
				LOG_Internet(_T("Found Unrecognized Token in SelfUpdate Structure String: Token was: %s"), pszWalk);
				pszWalk += lstrlen(pszWalk) + 1; // skip the previous token, and go to the next one in the string.
				*pszDelim = '|';
				continue;
			}

			if ('\0' != szValue[0])
			{

				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szServerDirectory,ARRAYSIZE(szServerDirectory),szValue,NULL,NULL,MISTSAFE_STRING_FLAGS));
				
			}
			pszWalk += lstrlen(pszWalk) + 1; // skip the previous token, and go to the next one in the string.
			*pszDelim = '|';
		}


		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szServerDirectory,ARRAYSIZE(szServerDirectory),SLASHENGINECAB,NULL,NULL,MISTSAFE_STRING_FLAGS));
		


		if ('/' == szServerDirectory[0])
		{
			pszWalk = CharNext(szServerDirectory);
		}
		else
		{
			pszWalk = szServerDirectory;
		}

		DWORD dwSize = INTERNET_MAX_URL_LENGTH;
		UrlCombine(szBaseServerUrl, pszWalk, m_pszSelfUpdateUrl, &dwSize, 0);
	}

CleanUp:

	if (SUCCEEDED(hr))
	{
		m_fIUPopulated = TRUE;
	}

	return hr;
}



//------------------------------------------------------------------------
//
// get the self-update server. 
// *** this API should be called after PopulateData() is called ***
//
//------------------------------------------------------------------------
HRESULT CIUUrlAgent::GetSelfUpdateServer(
			LPTSTR lpsBuffer, 
			int nBufferSize,
			BOOL* pfInternalServer /*= NULL*/)
{

	HRESULT hr=S_OK;

	if (!m_fIUPopulated)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	if (NULL == m_pszSelfUpdateUrl)
	{
		return (E_OUTOFMEMORY);
	}

	if (NULL == lpsBuffer)
	{
		return E_INVALIDARG;
	}

	nBufferSize/=sizeof(TCHAR);
	if (nBufferSize <= lstrlen(m_pszSelfUpdateUrl))
	{
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}


	hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_pszSelfUpdateUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);

	if(FAILED(hr))
		return hr;


	if (NULL != pfInternalServer)
	{
		*pfInternalServer = m_fIdentFromPolicy;
	}	
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\urllogging\test\sources.inc ===
#
# Copyright (c) 2002	Microsoft Corporation
#
# Module Name:	testIsConnected
#
# Abstract:		Test the IsConnected() function in the URLLogging library
#

TARGETNAME=testIsConnected
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM
UMTYPE=console

SOURCES= \
	testIsConnected.cpp	\
#	testSens.cpp \
	testIsConnected.rc

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\..\inc

TARGETLIBS = \
	$(WINDOWS_COM)\lib\URLLogging\$(WUBLDTYPE)\$(O)\URLLogging.lib	\
	$(WINDOWS_COM)\lib\logging\$(WUBLDTYPE)\$(O)\logging.lib	\
	$(WINDOWS_COM)\lib\util\$(WUBLDTYPE)\$(O)\util.lib	\
	$(WINDOWS_COM)\lib\wusafefn\$(WUBLDTYPE)\$(O)\wusafefn.lib	\
	$(SDK_LIB_PATH)\shlwapi.lib	\
	$(SDK_LIB_PATH)\User32.lib	\
	$(SDK_LIB_PATH)\ole32.lib	\
	$(SDK_LIB_PATH)\oleaut32.lib	\
	$(SDK_LIB_PATH)\version.lib	\
    $(SDK_LIB_PATH)\uuid.lib	\
    $(SDK_LIB_PATH)\Rpcrt4.lib	\
    $(SDK_LIB_PATH)\comctl32.lib	\
	$(SDK_LIB_PATH)\shell32.lib	\
    $(SDK_LIB_PATH)\advpack.lib	\
	$(SDK_LIB_PATH)\wininet.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\bincompatible.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:	BinarySubSystem.cpp
//  Module: util.lib
//
//***********************************************************************************
#pragma once
#include <windows.h>
#include <tchar.h>
#include <iucommon.h>
#include <fileutil.h>

HRESULT IsBinaryCompatible(LPCTSTR lpszFile)
{
    DWORD               cbRead;
    IMAGE_DOS_HEADER    img_dos_hdr;
    PIMAGE_OS2_HEADER   pimg_os2_hdr;
    IMAGE_NT_HEADERS    img_nt_hdrs;
    HRESULT             hr = BIN_E_MACHINE_MISMATCH;
    HANDLE              hFile = INVALID_HANDLE_VALUE;

    if((hFile = CreateFile(lpszFile, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE)
    {
        goto done;
    }

    //Read the MS-DOS header (all windows executables start with an MS-DOS stub)
    if(!ReadFile(hFile, &img_dos_hdr, sizeof(img_dos_hdr), &cbRead, NULL) ||
        cbRead != sizeof(img_dos_hdr))
    {
        goto done;
    }

    //Verify that the executable has the MS-DOS header
    if(img_dos_hdr.e_magic != IMAGE_DOS_SIGNATURE)
    {
        hr = BIN_E_BAD_FORMAT;
        goto done;
    }
    //Move file pointer to the actual PE header (NT header)
    if(SetFilePointer(hFile, img_dos_hdr.e_lfanew, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        goto done;
    }

    //Read the NT header
    if(!ReadFile(hFile, &img_nt_hdrs, sizeof(img_nt_hdrs), &cbRead, NULL) ||
        cbRead != sizeof(img_nt_hdrs))
    {
        goto done;
    }

    //Check for NT signature in the header (we dont support OS2)
    if(img_nt_hdrs.Signature != IMAGE_NT_SIGNATURE)
    {
        goto done;
    }

    //Check to see if the executable belongs to the correct subsystem
    switch(img_nt_hdrs.OptionalHeader.Subsystem)
    {
    case IMAGE_SUBSYSTEM_NATIVE:
    case IMAGE_SUBSYSTEM_WINDOWS_GUI:
    case IMAGE_SUBSYSTEM_WINDOWS_CUI:
 
    //If it is a supported subsystem, check CPU architecture
    if ( img_nt_hdrs.FileHeader.Machine == 
#ifdef _IA64_
    IMAGE_FILE_MACHINE_IA64)
#elif defined _X86_
    IMAGE_FILE_MACHINE_I386)
#elif defined _AMD64_
    IMAGE_FILE_MACHINE_AMD64)
#else
#pragma message( "Windows Update : Automatic Updates does not support this processor." )
    IMAGE_FILE_MACHINE_I386)
#endif
        {
            hr = S_OK;
        }
        break;
    default:
        break;
    }

done:
    SafeCloseFileHandle(hFile);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\ensureacls.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:	EnsureACLs.cpp
//  Module: util.lib
//
//***********************************************************************************
#pragma once

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500  // Win2000 and later
#endif

#include <windows.h>
#include <tchar.h>
#include <safefunc.h>
#include <shlobj.h>
#include <sddl.h>
#include <Aclapi.h>
#include <fileutil.h>
#include <logging.h>
#include <wusafefn.h>
#include <mistsafe.h>


#if defined(UNICODE) || defined (_UNICODE)

typedef DWORD (*TREERESETSECURITY)(
                        LPTSTR               pObjectName,
                        SE_OBJECT_TYPE       ObjectType,
                        SECURITY_INFORMATION SecurityInfo,
                        PSID                 pOwner OPTIONAL,
                        PSID                 pGroup OPTIONAL,
                        PACL                 pDacl OPTIONAL,
                        PACL                 pSacl OPTIONAL,
                        BOOL                 KeepExplicit,
                        FN_PROGRESS          fnProgress OPTIONAL,
                        PROG_INVOKE_SETTING  ProgressInvokeSetting,
                        PVOID                Args OPTIONAL);



//Function to enable or disable a particular privelege for the current process
//Last parameter is optional, will return the previous state of the privelege
DWORD EnablePrivilege(LPCTSTR pszPrivName, BOOL fEnable, BOOL *pfWasEnabled);

/******************************************************************************
//Function to recursively set ACLS on the specified folder.
//Currently we set the following ACL's
// * Allow SYSTEM full control 
// * Allow Admins full control 
// * Allow Owners full control 
// * Allow Power Users R/W/X control 
******************************************************************************/
HRESULT SetDirPermissions(LPCTSTR lpszDir);

#endif 

//Rename the 'WindowsUpdate' file to 'WindowsUpdate.TickCount'; if rename fails we try to delete it
//Note that we wont revert the ownerhip of the file
BOOL RenameWUFile(LPCTSTR lpszFilePath);


/*****************************************************************************
//Function to set ACL's on Windows Update directories, optionally creates the 
//directory if it doesnt already exists
//This function will:
// * Take ownership of the directory and it's children
// * Set all the children to inherit ACL's from parent
// * Set the specified directory to NOT inherit properties from it's parent
// * Set the required ACL's on the specified directory
// * Replace the ACL's on the children (i.e. propogate own ACL's and remove 
//   those ACL's which were explicitly set
//
//	Input: 
//		lpszDirectory: Path to the directory to ACL, If it is NULL we use the
                       path to the WindowsUpdate directory
        fCreateAlways: Flag to indicate creation of new directory if it doesnt
                       already exist
******************************************************************************/
HRESULT CreateDirectoryAndSetACLs(LPCTSTR lpszDirectory, BOOL fCreateAlways)
{
    LOG_Block("CreateDirectoryAndSetACLs");
    BOOL fIsDirectory = FALSE;
    LPTSTR lpszWUDirPath = NULL;
    LPTSTR lpszDirPath = NULL;

#if defined(UNICODE) || defined (_UNICODE)
    BOOL fChangedPriv = FALSE;
    BOOL fPrevPrivEnabled = FALSE;
#endif
    
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
    
    if(NULL == lpszDirectory && !fCreateAlways)     
    {
        hr = E_INVALIDARG;
        goto done;
    }

    //Use WU directory if input parameter is NULL
    if(NULL == lpszDirectory) 
    {
        lpszWUDirPath = (LPTSTR)malloc(sizeof(TCHAR)*(MAX_PATH+1));
        if(NULL == lpszWUDirPath)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        //Get the path to the Windows Update directory
        if(!GetWUDirectory(lpszWUDirPath, MAX_PATH+1))
        {
            goto done;
        }
        lpszDirPath = lpszWUDirPath;
    }
    // else use the passed in parameter
    else    
    {
        lpszDirPath = (LPTSTR)lpszDirectory;
    }

    //if dir (or file) does not exist
    if (!fFileExists(lpszDirPath, &fIsDirectory))
    {
        if(!fCreateAlways)      //no need to create a new one
        {
            goto done;
        }
        if(!(fIsDirectory = CreateNestedDirectory(lpszDirPath)))
        {
            goto done;
        }
    }

    //Since these apis are only available for win2k and above, dont compile for ansii (we dont care about NT4)
#if defined(UNICODE) || defined (_UNICODE)
    //Enable privelege to 'take ownership' , we will continue even if we failed for some reason
    fChangedPriv = (ERROR_SUCCESS == EnablePrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE, &fPrevPrivEnabled));
    
    //Take ownership and apply correct ACL's, we dont care if we fail
    SetDirPermissions(lpszDirPath);
#endif
    
    //Check for a file name-squatting on the specified directory
    if (!fIsDirectory)     
    {
        if( !RenameWUFile(lpszDirPath) ||           //Rename or delete the existing file
            !CreateNestedDirectory(lpszDirPath))    //Create a new directory
        {
            goto done;
        }
#if defined(UNICODE) || defined (_UNICODE)
        //Take ownership and apply correct ACL's, we dont care if we fail
        SetDirPermissions(lpszDirPath);
#endif
    }
    hr = S_OK;

done:
#if defined(UNICODE) || defined (_UNICODE)
    //Restore previous privelege
    if(fChangedPriv)
    {
         EnablePrivilege(SE_TAKE_OWNERSHIP_NAME, fPrevPrivEnabled, NULL);
    }
#endif
    SafeFreeNULL(lpszWUDirPath);
    return hr;
}

/********************************************************************************
//Get the path to the WindowsUpdate Directory (without the backslash at the end)
*********************************************************************************/
BOOL GetWUDirectory(LPTSTR lpszDirPath, DWORD chCount, BOOL fGetV4Path)
{
    LOG_Block("GetWUDirectory");
    const TCHAR szWUDir[]   = _T("\\WindowsUpdate");
    const TCHAR szV4[]      = _T("\\V4");
    BOOL fRet = FALSE;

    if(NULL == lpszDirPath)
    {
        return FALSE;
    }

    //Get the path to the Program Files directory
    if (S_OK != SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, lpszDirPath))
    {
        goto done;
    }
    //Append the WU Directory
    if (FAILED(StringCchCatEx(lpszDirPath, chCount, szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
        goto done;
	}
    if(fGetV4Path && FAILED(StringCchCatEx(lpszDirPath, chCount, szV4, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        goto done;
    }
    fRet = TRUE;
    
done:
    return fRet;
}


#if defined(UNICODE) || defined (_UNICODE)
/********************************************************************************
//Function to enable or disable a particular privelege
//Last parameter is optional, will return the previous state of the privelege
********************************************************************************/
DWORD EnablePrivilege(LPCTSTR pszPrivName, BOOL fEnable, BOOL *pfWasEnabled)
{
    LOG_Block("EnablePrivilege");
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hToken = 0;
    DWORD dwSize = 0;
    TOKEN_PRIVILEGES privNew;
    TOKEN_PRIVILEGES privOld;

    if(!OpenProcessToken(
                   GetCurrentProcess(),
                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                   &hToken))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    if(!LookupPrivilegeValue(
                   0,
                   pszPrivName,
                   &privNew.Privileges[0].Luid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    privNew.PrivilegeCount = 1;
    privNew.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;

    AdjustTokenPrivileges(
                   hToken,
                   FALSE,
                   &privNew,
                   sizeof(privOld),
                   &privOld,
                   &dwSize);
    //Always call GetLastError, even when we succeed (as per msdn)
    dwError = GetLastError();
    if(dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    if (pfWasEnabled)
    {
        *pfWasEnabled = (privOld.Privileges[0].Attributes & SE_PRIVILEGE_ENABLED) ? TRUE : FALSE;
    }
    
Cleanup:
    SafeCloseHandle(hToken);
    return dwError;
}

/********************************************************************************
//Apply appropriate ACL's to the specified directory
********************************************************************************/
HRESULT SetDirPermissions(LPCTSTR lpszDir)
{
    LOG_Block("SetDirPermissions");
    DWORD dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pAdminSD = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl = NULL;
    PSID pOwner = NULL;
    BOOL fIsDefault = FALSE;
    HMODULE hModule = NULL;
    TREERESETSECURITY pfnTreeResetSec = NULL;

    //Admin Security Descriptor String
    LPCTSTR pszAdminSD = _T("O:BAG:BAD:(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)");      
    
    //Security Descriptor String with correct ACLs for the WindowsUpdate Directory
    LPCTSTR pszSD = _T("D:")                    // DACL
                    _T("(A;OICI;GA;;;SY)")      // Allow SYSTEM full control
                    _T("(A;OICI;GA;;;BA)")      // Allow Admins full control
                    _T("(A;OICI;GA;;;CO)")      // Allow Owners full control
                    _T("(A;OICI;GRGWGX;;;PU)"); // Allow Power Users R/W/X control

    if(NULL == lpszDir)
    {
        return E_INVALIDARG;
    }
    
    //Create an admin SD from admin SD string
    if(!ConvertStringSecurityDescriptorToSecurityDescriptor(pszAdminSD, SDDL_REVISION_1, &pAdminSD, NULL))
    {
        dwErr = GetLastError();
        goto done;
    }

    //Get the owner SID from the Admin SD
    if(!GetSecurityDescriptorOwner(pAdminSD, &pOwner, &fIsDefault))
    {
        dwErr = GetLastError();
        goto done;
    }

    //Generate the Security Descriptor from the SD String with custom ACL's
    if(!ConvertStringSecurityDescriptorToSecurityDescriptor(pszSD, SDDL_REVISION_1, &pSD, NULL))
    {
        dwErr = GetLastError();
        goto done;
    }
    
    //Exctract the DACL from the Security Descriptor
    BOOL fIsDaclPresent = FALSE;
    if(!GetSecurityDescriptorDacl(
                                pSD,                // SD
                                &fIsDaclPresent,    // DACL presence
                                &pDacl,             // ACL
                                &fIsDefault))       // default DACL
    {

        dwErr = GetLastError();
        goto done;
    }
    //If for some reason no DACL was present, we have an invalid SD
    if(!fIsDaclPresent)
    {
        dwErr = ERROR_INVALID_SECURITY_DESCR;
        goto done;
    }

    //Load Advapi32.dll
    if ((NULL == (hModule = LoadLibraryFromSystemDir(_T("advapi32.dll")))) ||
        (NULL == (pfnTreeResetSec = (TREERESETSECURITY)::GetProcAddress(hModule, "TreeResetNamedSecurityInfo"))))
    {
        if(ERROR_SUCCESS != (dwErr = SetNamedSecurityInfo(
                                            (LPTSTR)lpszDir,
                                            SE_FILE_OBJECT,
                                            DACL_SECURITY_INFORMATION | 
                                            PROTECTED_DACL_SECURITY_INFORMATION |
                                            OWNER_SECURITY_INFORMATION,
                                            pOwner,
                                            NULL,
                                            pDacl,
                                            NULL)))
        {
            goto done;
        }
    }
    else
    {
        //Recursively apply the ownership and the ACL's on the tree
        if(ERROR_SUCCESS != (dwErr = pfnTreeResetSec(
                                                (LPTSTR)lpszDir,                            //Directory
                                                SE_FILE_OBJECT,                             //object type
                                                DACL_SECURITY_INFORMATION |                 //Set DACL
                                                PROTECTED_DACL_SECURITY_INFORMATION |       //Do not inherit
                                                OWNER_SECURITY_INFORMATION,                 //Set owner
                                                pOwner,                                     //Owner SID
                                                NULL,                                       //pGroup - null
                                                pDacl,                                      //Dacl to set
                                                NULL,                                       //pSacl - null
                                                FALSE,                                      //Retain explicitly added ACL's to children
                                                NULL,                                       //Callback function --- we dont need one
                                                ProgressInvokeNever,                        //Since we dont have a callback
                                                NULL)))                                     //Other args
        {
            goto done;
        }
    }

done:
    if ( NULL != hModule )
	{
		FreeLibrary(hModule);
	}
    SafeLocalFree(pSD);
    SafeLocalFree(pAdminSD);
    return HRESULT_FROM_WIN32(dwErr);
}

#endif

/*************************************************************************************************
//Rename the 'WindowsUpdate' file to 'WindowsUpdate.TickCount'; if rename fails we try to delete it
//Note that we wont revert the ownerhip of the file
**************************************************************************************************/
BOOL RenameWUFile(LPCTSTR lpszFilePath)
{
    LOG_Block("RenameWUFile");
    TCHAR szNewFilePath[MAX_PATH+1];
    DWORD dwTickCount = GetTickCount();
    LPTSTR szFormat = _T("%s.%lu");

    //Generate path to new file, should never fail
    if(SUCCEEDED(StringCchPrintfEx(szNewFilePath, ARRAYSIZE(szNewFilePath), NULL, NULL, MISTSAFE_STRING_FLAGS, szFormat, lpszFilePath, dwTickCount)) &&
        MoveFile(lpszFilePath, szNewFilePath) || 
        DeleteFile(lpszFilePath))
    {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\memutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   MemUtil.CPP
//	Author:	Charles Ma, 10/13/2000
//
//	Revision History:
//
//
//
//
//  Description:
//
//      Implement IU memory utility library
//
//=======================================================================

#include <windows.h>
#include <MemUtil.h>




// *******************************************************************************
//
//	Implementation of class CSmartHeapMem
//
// *******************************************************************************


const size_t ArrayGrowChunk = 4;

//
// constructor
//
CSmartHeapMem::CSmartHeapMem()
{
	m_ArraySize		= 0;
	m_lppMems		= NULL;
	m_Heap			= GetProcessHeap();
}



//
// desctructor
//
CSmartHeapMem::~CSmartHeapMem()
{
	if (NULL != m_Heap)
	{
		for (size_t i = 0; i < m_ArraySize; i++)
		{
			if (NULL != m_lppMems[i])
				HeapFree(m_Heap, 0, m_lppMems[i]);
		}
		HeapFree(m_Heap, 0, m_lppMems);
	}
}


//
// allocate mem
//
LPVOID CSmartHeapMem::Alloc(size_t nBytes, DWORD dwFlags /*= HEAP_ZERO_MEMORY*/)
{
	int		iNdx;
	LPVOID	pMem			= NULL;
	DWORD	dwBytes			= (DWORD) nBytes;
	DWORD	dwCurrentFlag	= dwFlags & (~HEAP_GENERATE_EXCEPTIONS | 
										 ~HEAP_NO_SERIALIZE);
	
	if (NULL == m_Heap || 0x0 == dwBytes)
	{
		return NULL;
	}

	iNdx = GetUnusedArraySlot();

	if (iNdx < 0 || NULL == m_Heap)
	{
		//
		// out of mem
		//
		return NULL;
	}

	
	pMem = m_lppMems[iNdx] = HeapAlloc(m_Heap, dwCurrentFlag, dwBytes);

	return pMem;
}



//
// reallocate mem
//
LPVOID CSmartHeapMem::ReAlloc(LPVOID lpMem, size_t nBytes, DWORD dwFlags)
{
	LPVOID	pMem			= NULL;
	DWORD	dwBytes			= (DWORD) nBytes;
	DWORD	dwCurrentFlag	= dwFlags & (~HEAP_GENERATE_EXCEPTIONS | 
										 ~HEAP_NO_SERIALIZE);
	int n;

	if (0x0 == dwBytes || NULL == m_Heap)
	{
		return NULL;
	}

	n = FindIndex(lpMem);
	if (n < 0)
	{
		return NULL;
	}

	pMem = HeapReAlloc(m_Heap, dwCurrentFlag, lpMem, dwBytes);
	if (NULL != pMem)
	{
		m_lppMems[n] = pMem;
	}

	return pMem;
}


//
// return the size allocated
//
size_t CSmartHeapMem::Size(LPVOID lpMem)
{
	if (NULL == m_Heap) return 0;
	return HeapSize(m_Heap, 0, lpMem);
}



void CSmartHeapMem::FreeAllocatedMem(LPVOID lpMem)
{
	int n = FindIndex(lpMem);
	if (n < 0 || NULL == m_Heap)
	{
		return;
	}
	HeapFree(m_Heap, 0, lpMem);
	m_lppMems[n] = NULL;
}



//
// get first empty slot from mem pointer array
// expand array if needed
//
int CSmartHeapMem::GetUnusedArraySlot()
{
	int iNdx = -1;
	UINT i;
	LPVOID lpCurrent;
	LPVOID lpTemp;

	if (0 == m_ArraySize)
	{
		if (NULL == (m_lppMems = (LPVOID*)HeapAlloc(
										m_Heap, 
										HEAP_ZERO_MEMORY, 
										ArrayGrowChunk * sizeof(LPVOID))))
		{
			return -1;
		}
		m_ArraySize = ArrayGrowChunk;
	}
	
		
	while (true)
	{
		for (i = 0; i < m_ArraySize; i++)
		{
			if (NULL == m_lppMems[i])
			{
				return i;
			}
		}
		
		//
		// if come to here, we didn't find an empty slot
		//
		if (NULL == (lpTemp = HeapReAlloc(
										m_Heap, 
										HEAP_ZERO_MEMORY, 
										m_lppMems, 
										(m_ArraySize + ArrayGrowChunk) * sizeof(LPVOID))))
		{
			//
			// when fail, original mem buffer pointed by m_lppMems untouched, 
			// we we simply return -1 to signal caller that no more free slots.
			//
			return -1;
		}

		//
		// when success, the mem pointers previously stored in m_lppMems already
		// been copied to lpTemp, and lppMems was freed.
		//

		//
		// assign the newly allocated mems to m_lppMems in success case
		//
		m_lppMems = (LPVOID *) lpTemp;

		m_ArraySize += ArrayGrowChunk;

		//
		// go back to loop again
		//
	}
}



//
// based on mem pointer, find index
//
int CSmartHeapMem::FindIndex(LPVOID pMem)
{
	if (NULL == pMem) return -1;
	for (size_t i = 0; i < m_ArraySize; i++)
	{
		if (pMem == m_lppMems[i]) return (int)i;
	}
	return -1;
}






// *******************************************************************************
//
//	Other memory related functions
//
// *******************************************************************************



//
// implemenation of CRT memcpy() function
//
LPVOID MyMemCpy(LPVOID dest, const LPVOID src, size_t nBytes)
{
	LPBYTE lpDest = (LPBYTE)dest;
	LPBYTE lpSrc = (LPBYTE)src;

	if (NULL == src || NULL == dest || src == dest)
	{
		return dest;
	}

	while (nBytes-- > 0)
	{
		*lpDest++ = *lpSrc++;
	}
	
	return dest;
}


//
// allocate heap mem and copy
//
LPVOID HeapAllocCopy(LPVOID src, size_t nBytes)
{
	LPVOID pBuffer;

	if (0 == nBytes)
	{
		return NULL;
	}
	
	pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nBytes);
	if (NULL != pBuffer)
	{
		MyMemCpy(pBuffer, src, nBytes);
	}
	return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\fileutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   fileutil.cpp
//
//  Description:
//
//      IU file utility library
//
//=======================================================================

#include <windows.h>
#include <tchar.h>
#include <stringutil.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <memutil.h>
#include <fileutil.h>
#include <platform.h>
#include <logging.h>
#include <iucommon.h>
#include <advpub.h>
#include <wincrypt.h>
#include <mscat.h>


#include "mistsafe.h"
#include "wusafefn.h"


const TCHAR REGKEY_WINDOWSUPDATE[]		= _T("\\WindowsUpdate\\");
const TCHAR REGKEY_INDUSTRYUPDATE[]		= _T("\\WindowsUpdate\\V4\\");
const TCHAR REGKEY_WINCURDIR[]			= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
const TCHAR REGKEY_PROGFILES[]			= _T(":\\Program Files");
const TCHAR REGKEY_PROGFILESDIR[]		= _T("ProgramFilesDir");

const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR REGVAL_ISBETA[] = _T("IsBeta");

const TCHAR IDENT_IUSERVERCACHE[] = _T("IUServerCache");
const TCHAR IDENT_DEFAULTQUERYSERVERINDEX[] = _T("DefaultQueryServerIndex");
const TCHAR IDENT_BETAQUERYSERVERINDEX[] = _T("BetaQueryServerIndex");
const TCHAR IDENT_QUERYSERVERINDEX[] = _T("QueryServerIndex");

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))


#define	IfNullReturnNull(ptr)		if (NULL == ptr) return NULL;
#define InitString(lpStr)			if (NULL != lpStr) lpStr[0] = TCHAR_EOS


typedef BOOL (WINAPI * PFN_GetDiskFreeSpaceEx) (
												LPCTSTR lpDirectoryName,                 // directory name
												PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
												PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
												PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
												);



//---------------------------------------------------------------------
//  CreateNestedDirectory
//      Creates the full path of the directory (nested directories)
//---------------------------------------------------------------------
#pragma warning( disable : 4706 )	// Ignore warning C4706: assignment within conditional expression
BOOL CreateNestedDirectory(LPCTSTR pszDir)
{
	BOOL bRc;
	TCHAR szPath[MAX_PATH];
	HRESULT hr=S_OK;

	if (NULL == pszDir || MAX_PATH < (lstrlen(pszDir) + 1))
	{
		return FALSE;
	}

	//
	// make a local copy and remove final slash
	//
	
	hr=StringCchCopyEx(szPath,ARRAYSIZE(szPath),pszDir,NULL,NULL,MISTSAFE_STRING_FLAGS);
	if(FAILED(hr))
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

	int iLast = lstrlen(szPath) - 1;
	if (0 > iLast)		// Prefix
		iLast = 0;
	if (szPath[iLast] == '\\')
		szPath[iLast] = 0;

	//
	// check to see if directory already exists
	//
	DWORD dwAttr = GetFileAttributes(szPath);

	if (dwAttr != 0xFFFFFFFF)   
	{
		if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) != 0)
			return TRUE;
	}

	//
	// create it
	//
    TCHAR* p = szPath;
	if (p[1] == ':')
		p += 2;
	else 
	{
        // Check if the path is a UNC, need to skip past the UNC Server\Share specification to get to
        // real path
		if (p[0] == '\\' && p[1] == '\\')
        {
			p += 2;
            // skip to the beginning of the share declaration
            p = _tcschr(p, '\\');
            if (NULL == p)
            {
                return FALSE; // invalid UNC
            }
            p++;
            // look for a trailing '\', if it exists then we want to further check for any nested levels,
            // otherwise the path as is should be valid.
            p = _tcschr(p, '\\');
            if (NULL == p)
            {
                // UNC is valid base share name, assume its valid
                return TRUE;
            }
            else
            {
                // look for any further levels, if they exist then pass through to the rest of the directory
                // creator
                p++;
                if (NULL == p)
                {
                    // UNC is valid base share name, but had a trailing slash, not a problem, assume its valid
                    return TRUE;
                }
                // if we haven't exited then there are remaining levels, don't reset our current pointer in the string
                // and let the rest of the nested directory creation work.
            }
        }
	}
	
	if (*p == '\\')
		p++;
    while (p = _tcschr(p, '\\'))	// Ignore warning C4706: assignment within conditional expression
    {
        *p = 0;
		bRc = CreateDirectory(szPath, NULL);
		*p = '\\';
		p++;
		if (!bRc)
		{
			if (GetLastError() != ERROR_ALREADY_EXISTS)
			{
				return FALSE;
			}
		}
	}

	bRc = CreateDirectory(szPath, NULL);
	if ( !bRc )
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			return FALSE;
		}
	}

    return TRUE;
}
#pragma warning( default : 4706 )

//-----------------------------------------------------------------------------------
//  GetIndustryUpdateDirectory
//		This function returns the location of the IndustryUpdate directory. All local
//		files are stored in this directory. The pszPath parameter needs to be at least
//		MAX_PATH.  
//-----------------------------------------------------------------------------------
void GetIndustryUpdateDirectory(LPTSTR pszPath)
{
/*	
	HRESULT hr=S_OK;

	LOG_Block("GetIndustryUpdateDirectory");

	if (NULL == pszPath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return;
	}

	static TCHAR szCachePath[MAX_PATH] = {'\0'};

	if (szCachePath[0] == '\0')
	{
		HKEY hkey;

		pszPath[0] = '\0';
		if (RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_WINCURDIR, &hkey) == ERROR_SUCCESS)
		{
			DWORD cbPath = MAX_PATH * sizeof(TCHAR);
			RegQueryValueEx(hkey, REGKEY_PROGFILESDIR, NULL, NULL, (LPBYTE)pszPath, &cbPath);
			RegCloseKey(hkey);
		}
		if (pszPath[0] == '\0')
		{
			TCHAR szWinDir[MAX_PATH];
			if (! GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir)))
			{
				//if GetWinDir fails, assume C:
				CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(szWinDir,ARRAYSIZE(szWinDir),_T("C"),NULL,NULL,MISTSAFE_STRING_FLAGS));
		
			}
			pszPath[0] = szWinDir[0];
			pszPath[1] = '\0';
			
			//It is assumed that the pszPath will be of the size MAX_PATH
			CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszPath,MAX_PATH,REGKEY_PROGFILES,NULL,NULL,MISTSAFE_STRING_FLAGS));


		}	

		
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszPath,MAX_PATH,REGKEY_INDUSTRYUPDATE,NULL,NULL,MISTSAFE_STRING_FLAGS));
		CreateNestedDirectory(pszPath);

		//
		// save it in the cache (lstrcpy -> lstrcpyn to shut Prefix up, although this
		// would always be safe given the constants used).
		//
		lstrcpyn(szCachePath, pszPath, MAX_PATH);
	}
	else
	{
		//It is assumed that the pszPath will be of the size MAX_PATH
		CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(pszPath,MAX_PATH,szCachePath,NULL,NULL,MISTSAFE_STRING_FLAGS));
	}

CleanUp:
	return;
	*/
	(void) GetWUDirectory(pszPath, MAX_PATH, TRUE);

}

//-----------------------------------------------------------------------------------
//  GetWindowsUpdateV3Directory - used for V3 history migration
//		This function returns the location of the WindowsUpdate(V3) directory. All V3 
//      local files are stored in this directory. The pszPath parameter needs to be 
//      at least MAX_PATH.  The directory is created if not found
//-----------------------------------------------------------------------------------
void GetWindowsUpdateV3Directory(LPTSTR pszPath)
{
	LOG_Block("GetWindowsUpdateV3Directory");

	HRESULT hr=S_OK;
	if (NULL == pszPath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return;
	}

	static TCHAR szWUCachePath[MAX_PATH] = {'\0'};

	if (szWUCachePath[0] == '\0')
	{
		HKEY hkey;

		pszPath[0] = '\0';
		if (RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_WINCURDIR, &hkey) == ERROR_SUCCESS)
		{
			DWORD cbPath = MAX_PATH * sizeof(TCHAR);
			RegQueryValueEx(hkey, REGKEY_PROGFILESDIR, NULL, NULL, (LPBYTE)pszPath, &cbPath);
			RegCloseKey(hkey);
		}
		if (pszPath[0] == '\0')
		{
			TCHAR szWinDir[MAX_PATH];
			if (! GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir)))
			{
				//if GetWinDir fails, assume C:
				CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(szWinDir,ARRAYSIZE(szWinDir),_T("C"),NULL,NULL,MISTSAFE_STRING_FLAGS));
				
			}
			pszPath[0] = szWinDir[0];
			pszPath[1] = '\0';
		
			CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszPath,MAX_PATH,REGKEY_PROGFILES,NULL,NULL,MISTSAFE_STRING_FLAGS));
		}	

		
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszPath,MAX_PATH,REGKEY_WINDOWSUPDATE,NULL,NULL,MISTSAFE_STRING_FLAGS));
		CreateNestedDirectory(pszPath);

		//
		// save it in the cache (lstrcpy -> lstrcpyn to shut Prefix up, although this
		// would always be safe given the constants used).
		//
		lstrcpyn(szWUCachePath, pszPath, MAX_PATH);
	}
	else
	{
	
		CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(pszPath,MAX_PATH,szWUCachePath,NULL,NULL,MISTSAFE_STRING_FLAGS));

	}

CleanUp:
	return;

}

// ----------------------------------------------------------------------
//
// Public function MySplitPath() - same as CRT _tsplitpath()
//		to break a path into pieces
//
//	Input: 
//		see below
//
//	Return:
//		Returns the address of the last occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
//	Algorithm:
//				C:\mydir\...\mysubdir\myfile.ext
//       _________|          _________|     |____
//      |                   |                    |
//   start of dir   start of filename     start of extension
//
// ----------------------------------------------------------------------
void MySplitPath(
	LPCTSTR lpcszPath,	// original path
	LPTSTR lpszDrive,	// point to buffer to receive drive letter
	LPTSTR lpszDir,		// point to buffer to receive directory
	LPTSTR lpszFName,	// point to buffer to receive file name
	LPTSTR lpszExt		// point to buffer to receive extension
)
{
	LPCTSTR lpFirstSlash, lpLastSlash, lpPeriod;
	LPCTSTR lpStart = lpcszPath;

	int nPathLen = lstrlen(lpcszPath);
	int nExtLen;

	//
	// initialize pass in vars
	//
	InitString(lpszDrive);
	InitString(lpszDir);
	InitString(lpszFName);
	InitString(lpszExt);
	
	if (0 == nPathLen || TCHAR_DOT == lpcszPath[0])
	{
		//
		// not a valid path
		//
		return;
	}

	lpFirstSlash	= MyStrChr(lpcszPath, TCHAR_BACKSLASH);
	lpLastSlash		= MyStrRChr(lpcszPath, NULL, TCHAR_BACKSLASH);
	lpPeriod		= MyStrRChr(lpcszPath, NULL, TCHAR_DOT);

	nExtLen = lstrlen(lpPeriod);
	if (NULL != lpPeriod && NULL != lpszExt)
	{
		//
		// found a period from right, and
		// we have buffer to output extension
		//
		if(FAILED(StringCchCopyEx(lpszExt,nExtLen+1,lpPeriod,NULL,NULL,MISTSAFE_STRING_FLAGS)))
			return;

	}

	//
	// process drive
	//
	if (nPathLen > 2 && TCHAR_COLON == lpcszPath[1])
	{
		lpStart = lpcszPath + 2;
		if (NULL != lpszDir)
		{
			lstrcpyn(lpszDrive, lpcszPath, 3);
		}
	}


	if (NULL == lpFirstSlash)
	{
		//
		// no backslash, assume this is file name only
		//
		if (NULL != lpszFName)
		{
			lstrcpyn(lpszFName, lpStart, lstrlen(lpStart) - nExtLen + 1);
		}
	}
	else
	{
		//
		// find directory if not empty
		//
		//if (lpLastSlash != lpFirstSlash && NULL != lpszDir)
		if (NULL != lpszDir)
		{
			lstrcpyn(lpszDir, lpFirstSlash, (int)(lpLastSlash - lpFirstSlash + 2));
		}

		//
		// find file name
		//
		if (NULL != lpszFName)
		{
			lstrcpyn(lpszFName, lpLastSlash + 1, lstrlen(lpLastSlash) - nExtLen );
		}
	}
}







// **********************************************************************************
// 
// File version related declarations
//
// **********************************************************************************

// ----------------------------------------------------------------------------------
//
// public function to retrieve file version
//
// ----------------------------------------------------------------------------------
BOOL GetFileVersion(LPCTSTR lpsFile, LPFILE_VERSION lpstVersion)
{
	LOG_Block("GetFileVersion()");

	DWORD	dwVerInfoSize;
	DWORD	dwHandle;
	DWORD	dwVerNumber;
	LPVOID	lpBuffer = NULL;
	UINT	uiSize = 0;
	VS_FIXEDFILEINFO* lpVSFixedFileInfo;

	USES_MY_MEMORY;

	if (NULL != lpstVersion)
	{
		//
		// if this pointer not null, we always try to initialize
		// this structure to 0, in order to reduce the change of 
		// programming error, no matter the file exists or not.
		//
		ZeroMemory(lpstVersion, sizeof(FILE_VERSION));
	}
	if (NULL == lpsFile || NULL == lpstVersion)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	//
	// 506212 IU - FRE log reports incorrect version data for iuengine.dll
	//
	if (FALSE == FileExists(lpsFile))
	{
		//
		// GetFileVersionInfoSize() returns 0 but sets last error to 0 (or
		// doesn't set) if file doesn't exist on Win2K.
		//
		LOG_Out(_T("File \"%s\" doesn't exist, returning FALSE"), lpsFile);
		return FALSE;
	}
	
	dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)lpsFile, &dwHandle);
	
	if (0 == dwVerInfoSize)
	{
		DWORD dwErr = GetLastError();
		if (0 == dwErr)
		{
			LOG_Error(_T("File %s does not have version data. Use 0.0.0.0"), lpsFile);
			lpstVersion->Major	= 0x0;
			lpstVersion->Minor	= 0x0;
			lpstVersion->Build	= 0x0;
			lpstVersion->Ext	= 0x0;
			return TRUE;
		}
		else
		{
			LOG_ErrorMsg(dwErr);
			return FALSE;
		}
	}


	if (NULL == (lpBuffer = (LPVOID) MemAlloc(dwVerInfoSize)))
	{
		LOG_Error(_T("Failed to allocate memory to get version info"));
		return FALSE;
	}

	if (!GetFileVersionInfo((LPTSTR)lpsFile, dwHandle, dwVerInfoSize, lpBuffer))
	{
		LOG_ErrorMsg(GetLastError());
		return FALSE;
	}

	//
	// Get the value for Translation
	//
	if (!VerQueryValue(lpBuffer, _T("\\"), (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize) && NULL != lpVSFixedFileInfo)
	{
		LOG_ErrorMsg(GetLastError());
		return FALSE;
	}

	dwVerNumber = lpVSFixedFileInfo->dwFileVersionMS;
	lpstVersion->Major	= HIWORD(dwVerNumber);
	lpstVersion->Minor	= LOWORD(dwVerNumber);

	dwVerNumber = lpVSFixedFileInfo->dwFileVersionLS;
	lpstVersion->Build	= HIWORD(dwVerNumber);
	lpstVersion->Ext	= LOWORD(dwVerNumber);

	LOG_Out(_T("File %s found version %d.%d.%d.%d"), 
				lpsFile, 
				lpstVersion->Major, 
				lpstVersion->Minor, 
				lpstVersion->Build, 
				lpstVersion->Ext);

	return TRUE;
}



// ----------------------------------------------------------------------------------
//
// public functions to compare file versions
//	
// return:
//		-1: if file ver of 1st parameter < file ver of 2nd parameter
//		 0: if file ver of 1st parameter = file ver of 2nd parameter
//		+1: if file ver of 1st parameter > file ver of 2nd parameter
//
// ----------------------------------------------------------------------------------
int CompareFileVersion(const FILE_VERSION stVersion1, const FILE_VERSION stVersion2)
{

	if ((short)stVersion1.Major < 0 || (short)stVersion2.Major < 0)
	{
		//
		// two empty version structure to compare, we call it equal
		//
		return 0;
	}

	if (stVersion1.Major != stVersion2.Major)
	{
		//
		// major diff, then we know the answer 
		//
		return (stVersion1.Major < stVersion2.Major) ? -1 : 1;
	}
	else
	{
		if ((short)stVersion1.Minor < 0 || (short)stVersion2.Minor < 0)
		{
			//
			// if any minor missing, they equal
			//
			return 0;
		}

		if (stVersion1.Minor != stVersion2.Minor)
		{
			//
			// minor diff, then we know the answer
			//
			return (stVersion1.Minor < stVersion2.Minor) ? -1 : 1;
		}
		else
		{
			if ((short)stVersion1.Build < 0 || (short)stVersion2.Build < 0)
			{
				//
				// if any build is missing, they equal
				//
				return 0;
			}

			if (stVersion1.Build != stVersion2.Build)
			{
				//
				// if build diff then we are done
				//
				return (stVersion1.Build < stVersion2.Build) ? -1 : 1;
			}
			else
			{
				if ((short)stVersion1.Ext < 0 || (short)stVersion2.Ext < 0 || stVersion1.Ext == stVersion2.Ext)
				{
					//
					// if any ext is missing, or they equal, we are done
					//
					return 0;
				}
				else
				{
					return (stVersion1.Ext < stVersion2.Ext) ? -1 : 1;
				}
			}
		}
	}
}


HRESULT CompareFileVersion(LPCTSTR lpsFile1, LPCTSTR lpsFile2, int *pCompareResult)
{

	LOG_Block("CompareFileVersion(File, File)");

	FILE_VERSION stVer1 = {-1,-1,-1,-1}, stVer2 = {-1,-1,-1,-1};
	if (NULL == lpsFile1 || NULL == lpsFile2)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	if (!GetFileVersion(lpsFile1, &stVer1))
	{
		return E_INVALIDARG;
	}
	if (!GetFileVersion(lpsFile2, &stVer2))
	{
		return E_INVALIDARG;
	}

	*pCompareResult = CompareFileVersion(stVer1, stVer2);
	return S_OK;
}


HRESULT CompareFileVersion(LPCTSTR lpsFile, FILE_VERSION stVersion, int *pCompareResult)
{
	LOG_Block("CompareFileVersion(FILE, VER)");
	
	FILE_VERSION stVer = {0};

	if (NULL == lpsFile)
	{
		LOG_Error(_T("NULL file pointer passed in. Function returns 0"));
		return E_INVALIDARG;
	}

	if (!GetFileVersion(lpsFile, &stVer))
	{
		return E_INVALIDARG;
	}

	*pCompareResult = CompareFileVersion(stVer, stVersion);
	return S_OK;
}




// ----------------------------------------------------------------------------------
//
// publif function to convert a string type functoin to FILE_VERSION type
//
// ----------------------------------------------------------------------------------
BOOL ConvertStringVerToFileVer(LPCSTR lpsVer, LPFILE_VERSION lpstVer)
{
	LOG_Block("ConvertStringVerToFileVer()");

	WORD n = -1;
	char c;
	BOOL fHasNumber = FALSE;

#if defined(DBG)	// full logging for checked builds
	USES_IU_CONVERSION;
#endif

	if (NULL == lpsVer || NULL == lpstVer)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

#if defined(DBG)	// full logging for checked builds
	LOG_Out(_T("String version = %s"), A2T(const_cast<LPSTR>(lpsVer)));
#endif

	lpstVer->Major = lpstVer->Minor = lpstVer->Build = lpstVer->Ext = -1;

	c = *lpsVer;

	//
	// get first number
	//
	n = 0;
	while (c != '\0' && '0' <= c && c <= '9')
	{
		n = n * 10 + (int)(c - '0');
		c = *++lpsVer;
		fHasNumber = TRUE;
	}
	if (fHasNumber) 
	{
		lpstVer->Major = n;
	}
	else
	{
		return TRUE;
	}

	//
	// skip delimiter
	//
	while (c != '\0'  && ('0' > c || c > '9'))
	{
		c = *++lpsVer;
	}


	//
	// get 2nd number
	//
	n = 0;
	fHasNumber = FALSE;
	while (c != '\0' && '0' <= c && c <= '9')
	{
		n = n * 10 + (int)(c - '0');
		c = *++lpsVer;
		fHasNumber = TRUE;
	}
	if (fHasNumber) 
	{
		lpstVer->Minor = n;
	}
	else
	{
		return TRUE;
	}

	//
	// skip delimiter
	//
	while (c != '\0'  && ('0' > c || c > '9'))
	{
		c = *++lpsVer;
	}

	//
	// get 3rd number
	//
	n = 0;
	fHasNumber = FALSE;
	while (c != '\0' && '0' <= c && c <= '9')
	{
		n = n * 10 + (int)(c - '0');
		c = *++lpsVer;
		fHasNumber = TRUE;
	}
	if (fHasNumber) 
	{
		lpstVer->Build = n;
	}
	else
	{
		return TRUE;
	}

	//
	// skip delimiter
	//
	while (c != '\0'  && ('0' > c || c > '9'))
	{
		c = *++lpsVer;
	}

	//
	// get 4th number
	//
	n = 0;
	fHasNumber = FALSE;
	while (c != '\0' && '0' <= c && c <= '9')
	{
		n = n * 10 + (int)(c - '0');
		c = *++lpsVer;
		fHasNumber = TRUE;
	}
	if (fHasNumber) 
	{
		lpstVer->Ext = n;
	}

	return TRUE;
}



// ----------------------------------------------------------------------------------
//
// publif function to convert a FILE_VERSION to a string
//
// ----------------------------------------------------------------------------------
BOOL ConvertFileVerToStringVer(
	FILE_VERSION stVer,				// version to convert
	char chDel,						// delimiter to use
	LPSTR lpsBuffer,				// buffer of string
	int ccBufSize					// size of buffer
)
{
	//
	// declare max buffer that wsprintf can use
	//
	char szBuf[1024];

	HRESULT hr=S_OK;



	hr=StringCchPrintfExA(	szBuf,ARRAYSIZE(szBuf),
						NULL,NULL,MISTSAFE_STRING_FLAGS,
						"%d%c%d%c%d%c",
						 stVer.Major,
						 chDel,
						 stVer.Minor,
						 chDel,
						 stVer.Build,
						 chDel,
						 stVer.Ext,
						 chDel
						 );	
					
	if(FAILED(hr))
	{
		goto ErrorExit;
	}

	
	hr=StringCchCopyExA(lpsBuffer,ccBufSize,szBuf,NULL,NULL,MISTSAFE_STRING_FLAGS);
	
	if(FAILED(hr))
	{	
		goto ErrorExit;
	}

	return TRUE;

ErrorExit:
		lpsBuffer[0] = '\0';
		return FALSE;


}





// ----------------------------------------------------------------------------------
//
// public function to check if a file exists
//
// ----------------------------------------------------------------------------------
BOOL FileExists(
	LPCTSTR lpsFile		// file with path to check
)
{
	LOG_Block("FileExists");
	
	DWORD dwAttr;
	BOOL rc;

	if (NULL == lpsFile || _T('\0') == *lpsFile)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	dwAttr = GetFileAttributes(lpsFile);

	if (-1 == dwAttr)
	{
		LOG_InfoMsg(GetLastError());
		rc = FALSE;
	}

	else
	{
		rc = (0x0 == (FILE_ATTRIBUTE_DIRECTORY & dwAttr));
	}

	return rc;
}





// ----------------------------------------------------------------------------------
//
// publif function to retrieve the creation time of a file in ISO 8601 format
//	without zone info
//
//	if buffer too small, call GetLastError();
//
// ----------------------------------------------------------------------------------
BOOL GetFileTimeStamp(LPCTSTR lpsFile, LPTSTR lpsTimeStamp, int iBufSize)
{
	BOOL fRet = FALSE;
	HANDLE hFile;
	SYSTEMTIME tm;
	WIN32_FILE_ATTRIBUTE_DATA fileData;
	HRESULT hr=S_OK;

	if (0 != GetFileAttributesEx(lpsFile, GetFileExInfoStandard, &fileData) &&
		0 != FileTimeToSystemTime((const FILETIME*)&(fileData.ftCreationTime), &tm))
	{
		//
		// the output of this systemtime, according to ISA 8601 format, will be
		// like yyyy-mm-ddThh:mm:ss format, so it is 20 chars incl terminator
		//
		if (iBufSize < 20)
		{
			SetLastError(ERROR_BUFFER_OVERFLOW);
			return fRet;
		}
		
		
		hr=StringCchPrintfEx(lpsTimeStamp,iBufSize,NULL,NULL,MISTSAFE_STRING_FLAGS,
						_T("%4d-%02d-%02dT%02d:%02d:%02d"),
						tm.wYear, tm.wMonth, tm.wDay, tm.wHour, tm.wMinute, tm.wSecond);

		if(FAILED(hr))
		{
			fRet=FALSE;
			SetLastError(HRESULT_CODE(hr));
		}
		else
			fRet = TRUE;

	}
	
	return fRet;
}



// ----------------------------------------------------------------------------------
//
// publif function to find the free disk space in KB
//
//
// ----------------------------------------------------------------------------------
HRESULT GetFreeDiskSpace(TCHAR tcDriveLetter, int *piKBytes)
{
	HRESULT hr = E_INVALIDARG;
	BOOL fResult;
	TCHAR szDrive[4];

	if (!(_T('A') <= tcDriveLetter && tcDriveLetter <= _T('Z') ||
		  _T('a') <= tcDriveLetter && tcDriveLetter <= _T('z')))
	{
		return hr;
	}

	
	hr=StringCchPrintfEx(szDrive,ARRAYSIZE(szDrive),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("%c:\\"), tcDriveLetter);

	if(FAILED(hr))
		return hr;

	PFN_GetDiskFreeSpaceEx pGetDiskFreeSpaceEx = 
								(PFN_GetDiskFreeSpaceEx) 
								GetProcAddress( GetModuleHandle(_T("kernel32.dll")),
#ifdef UNICODE
                                                "GetDiskFreeSpaceExW");
#else
                                                "GetDiskFreeSpaceExA");
#endif

	if (pGetDiskFreeSpaceEx)
	{
		LARGE_INTEGER i64FreeBytesToCaller, i64TotalBytes;

		fResult = pGetDiskFreeSpaceEx (szDrive,
					(PULARGE_INTEGER)&i64FreeBytesToCaller,
					(PULARGE_INTEGER)&i64TotalBytes,
					(PULARGE_INTEGER)NULL);
		*piKBytes = (int) (i64FreeBytesToCaller.QuadPart / 1024);
	}

	else 
	{
		DWORD	dwSectPerClust = 0x0,
				dwBytesPerSect = 0x0,
				dwFreeClusters = 0x0,
				dwTotalClusters = 0x0;

		fResult = GetDiskFreeSpace (szDrive, 
					&dwSectPerClust, 
					&dwBytesPerSect,
					&dwFreeClusters, 
					&dwTotalClusters);
		
		*piKBytes = (int) ((float)(((int)dwFreeClusters) * ((int)dwSectPerClust)) / 1024.0 * (int)dwBytesPerSect);
	}

	return (fResult) ? S_OK : HRESULT_FROM_WIN32(GetLastError());

}

HRESULT GetFreeDiskSpace(LPCTSTR pszUNC, int *piKBytes)
{
	HRESULT hr = E_INVALIDARG;
	BOOL fResult;

	PFN_GetDiskFreeSpaceEx pGetDiskFreeSpaceEx = 
								(PFN_GetDiskFreeSpaceEx) 
								GetProcAddress( GetModuleHandle(_T("kernel32.dll")),
#ifdef UNICODE
                                                "GetDiskFreeSpaceExW");
#else
                                                "GetDiskFreeSpaceExA");
#endif

	if (pGetDiskFreeSpaceEx)
	{
		LARGE_INTEGER i64FreeBytesToCaller, i64TotalBytes;

		fResult = pGetDiskFreeSpaceEx (pszUNC,
					(PULARGE_INTEGER)&i64FreeBytesToCaller,
					(PULARGE_INTEGER)&i64TotalBytes,
					(PULARGE_INTEGER)NULL);
		*piKBytes = (int) (i64FreeBytesToCaller.QuadPart / 1024);
	}

	else 
	{
		DWORD	dwSectPerClust = 0x0,
				dwBytesPerSect = 0x0,
				dwFreeClusters = 0x0,
				dwTotalClusters = 0x0;

		fResult = GetDiskFreeSpace (pszUNC, 
					&dwSectPerClust, 
					&dwBytesPerSect,
					&dwFreeClusters, 
					&dwTotalClusters);
		
		*piKBytes = (int) ((float)(((int)dwFreeClusters) * ((int)dwSectPerClust)) / 1024.0 * (int)dwBytesPerSect);
	}

	return (fResult) ? S_OK : HRESULT_FROM_WIN32(GetLastError());

}

// ----------------------------------------------------------------------------------
//
// publif function to expand the file path
//
//	Assumption: lpszFilePath points to allocated buffer of MAX_PATH.
//	if the expanded path is longer than MAX_PATH, error returned.
//
// ----------------------------------------------------------------------------------
HRESULT ExpandFilePath(LPCTSTR lpszFilePath, LPTSTR lpszDestination, UINT cChars)
{
	HRESULT hr = S_OK;
	LPTSTR lpEnvExpanded;
	LPTSTR lp2ndPercentChar = NULL;
	LPTSTR lpSearchStart;

	USES_MY_MEMORY;

	if (NULL == (lpEnvExpanded = (LPTSTR) MemAlloc((cChars + 1) * sizeof(TCHAR))))
	{
		return E_OUTOFMEMORY;
	}

	//
	// first, let's substitute the system defined variables 
	//
	if (0 == ExpandEnvironmentStrings(lpszFilePath, lpEnvExpanded, cChars))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	//
	// then handle pre-defined variables that we need to recognize
	// these include all CSIDL definitions inside shlobj.h for SHGetFolderPath() API
	//
	const int C_NAME_LEN = 32;

	struct _CSIDL_NAME {
		long CSIDL_Id;
		TCHAR CSIDL_Str[C_NAME_LEN];
	};
	const _CSIDL_NAME C_CSIDL_NAMES[] = {
		{CSIDL_ADMINTOOLS 				,  _T("CSIDL_ADMINTOOLS")},
		{CSIDL_ALTSTARTUP 				,  _T("CSIDL_ALTSTARTUP")},
		{CSIDL_APPDATA 					,  _T("CSIDL_APPDATA")},
		{CSIDL_BITBUCKET 				,  _T("CSIDL_BITBUCKET")},
		{CSIDL_COMMON_ADMINTOOLS 		,  _T("CSIDL_COMMON_ADMINTOOLS")},
		{CSIDL_COMMON_ALTSTARTUP 		,  _T("CSIDL_COMMON_ALTSTARTUP")},
		{CSIDL_COMMON_APPDATA 			,  _T("CSIDL_COMMON_APPDATA")},
		{CSIDL_COMMON_DESKTOPDIRECTORY 	,  _T("CSIDL_COMMON_DESKTOPDIRECTORY")},
		{CSIDL_COMMON_DOCUMENTS 		,  _T("CSIDL_COMMON_DOCUMENTS")},
		{CSIDL_COMMON_FAVORITES 		,  _T("CSIDL_COMMON_FAVORITES")},
		{CSIDL_COMMON_PROGRAMS 			,  _T("CSIDL_COMMON_PROGRAMS")},
		{CSIDL_COMMON_STARTMENU 		,  _T("CSIDL_COMMON_STARTMENU")},
		{CSIDL_COMMON_STARTUP 			,  _T("CSIDL_COMMON_STARTUP")},
		{CSIDL_COMMON_TEMPLATES 		,  _T("CSIDL_COMMON_TEMPLATES")},
		{CSIDL_CONTROLS 				,  _T("CSIDL_CONTROLS")},
		{CSIDL_COOKIES 					,  _T("CSIDL_COOKIES")},
		{CSIDL_DESKTOP 					,  _T("CSIDL_DESKTOP")},
		{CSIDL_DESKTOPDIRECTORY 		,  _T("CSIDL_DESKTOPDIRECTORY")},
		{CSIDL_DRIVES 					,  _T("CSIDL_DRIVES")},
		{CSIDL_FAVORITES 				,  _T("CSIDL_FAVORITES")},
		{CSIDL_FONTS 					,  _T("CSIDL_FONTS")},
		{CSIDL_HISTORY 					,  _T("CSIDL_HISTORY")},
		{CSIDL_INTERNET 				,  _T("CSIDL_INTERNET")},
		{CSIDL_INTERNET_CACHE 			,  _T("CSIDL_INTERNET_CACHE")},
		{CSIDL_LOCAL_APPDATA 			,  _T("CSIDL_LOCAL_APPDATA")},
		{CSIDL_MYPICTURES 				,  _T("CSIDL_MYPICTURES")},
		{CSIDL_NETHOOD 					,  _T("CSIDL_NETHOOD")},
		{CSIDL_NETWORK 					,  _T("CSIDL_NETWORK")},
		{CSIDL_PERSONAL 				,  _T("CSIDL_PERSONAL")},
		{CSIDL_PRINTERS 				,  _T("CSIDL_PRINTERS")},
		{CSIDL_PRINTHOOD 				,  _T("CSIDL_PRINTHOOD")},
		{CSIDL_PROFILE 					,  _T("CSIDL_PROFILE")},
		{CSIDL_PROGRAM_FILES 			,  _T("CSIDL_PROGRAM_FILES")},
		{CSIDL_PROGRAM_FILES_COMMON 	,  _T("CSIDL_PROGRAM_FILES_COMMON")},
		{CSIDL_PROGRAMS 				,  _T("CSIDL_PROGRAMS")},
		{CSIDL_RECENT 					,  _T("CSIDL_RECENT")},
		{CSIDL_SENDTO 					,  _T("CSIDL_SENDTO")},
		{CSIDL_STARTMENU 				,  _T("CSIDL_STARTMENU")},
		{CSIDL_STARTUP 					,  _T("CSIDL_STARTUP")},
		{CSIDL_SYSTEM 					,  _T("CSIDL_SYSTEM")},
		{CSIDL_TEMPLATES 				,  _T("CSIDL_TEMPLATES")},
		{CSIDL_WINDOWS 					,  _T("CSIDL_WINDOWS")}
	};

	//
	// see if this path has any of these variables
	//
	lpSearchStart = lpEnvExpanded + 1;

	if (SUCCEEDED(hr) && _T('%') == *lpEnvExpanded && 
		NULL != (lp2ndPercentChar = StrChr(lpSearchStart, _T('%'))))
	{
		//
		// copy the variable name to passed in buffer
		//
		lstrcpyn(lpszDestination, lpSearchStart, (int)(lp2ndPercentChar - lpSearchStart + 1));	// skip the 1st % char
		
		lp2ndPercentChar++;	// move to begining of rest of path

		//
		// find out what this variable is
		//
		for (int i = 0; i < sizeof(C_CSIDL_NAMES)/sizeof(C_CSIDL_NAMES[0]); i++)
		{
			if (lstrcmpi(lpszDestination, C_CSIDL_NAMES[i].CSIDL_Str) == 0)
			{
				//
				// found the matching variable!
				//
				if (S_OK == (hr = SHGetFolderPath(NULL, C_CSIDL_NAMES[i].CSIDL_Id, NULL, SHGFP_TYPE_CURRENT, lpszDestination)))
				{
					//
					// ensure buffer big enough
					//
					if (lstrlen(lp2ndPercentChar) + lstrlen(lpszDestination) + sizeof(TCHAR) >= cChars) 
					{
						hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
					}

					//
					// append the rest of them - shouldn't be any of
					// these variables in the rest of string, since this
					// kind variable alaways starts at the beginning of
					// a path
					//

					if(SUCCEEDED(hr))
						hr=PathCchAppend(lpszDestination,MAX_PATH,lp2ndPercentChar);

					if (SUCCEEDED(hr))
					{
						return hr;
					}

				}

				//
				// we found the matching variable, but couldn't get the
				// string replaced.
				//
				break;
			}
		}

		//
		// didn't find it.
		//
	}

	//
	// didn't find it, or failed.
	//
	if (FAILED(hr))
	{
		*lpszDestination = _T('\0');
	}
	else
	{
		lstrcpyn(lpszDestination, lpEnvExpanded, cChars);
	}

	return hr;
}






//----------------------------------------------------------------------
//
// function to validate the folder to make sure
// user has required priviledge
//
// folder will be verified exist. then required priviledge will be checked.
//
// ASSUMPTION: lpszFolder not exceeding MAX_PATH long!!!
//
//----------------------------------------------------------------------
DWORD ValidateFolder(LPTSTR lpszFolder, BOOL fCheckForWrite)
{
	LOG_Block("ValidateFolder");

	DWORD dwErr = ERROR_SUCCESS;
	HRESULT hr=S_OK;
	//
	// first, check if the folder exist
	//
	dwErr = GetFileAttributes(lpszFolder);

	if (-1 == dwErr)
	{
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		return dwErr;
	}

	//
	// make sure it's a directory
	//
	if ((FILE_ATTRIBUTE_DIRECTORY & dwErr) == 0)
	{
		dwErr = ERROR_PATH_NOT_FOUND;
		LOG_ErrorMsg(dwErr);
		return dwErr;
	}

	
	if (fCheckForWrite)
	{
		TCHAR szFile[MAX_PATH], szFileName[40];
		SYSTEMTIME tm;
		HANDLE hFile;

		//
		// create a random file name
		//
		
		hr=StringCchCopyEx(szFile,ARRAYSIZE(szFile),lpszFolder,NULL,NULL,MISTSAFE_STRING_FLAGS);

		if(FAILED(hr))
		{
			dwErr = HRESULT_CODE(hr);;
			LOG_ErrorMsg(dwErr);
			return dwErr;
		}

		GetLocalTime(&tm);


		hr=StringCchPrintfEx(	szFileName, 
							ARRAYSIZE(szFileName),
							NULL,NULL,MISTSAFE_STRING_FLAGS,
							 _T("%08x%08x%02hd%02hd%02hd%02hd%02hd%03hd%08x"),
							 GetCurrentProcessId(),
							 GetCurrentThreadId(),
							 tm.wMonth,
							 tm.wDay,
							 tm.wHour,
							 tm.wMinute,
							 tm.wSecond,
							 tm.wMilliseconds,
							 GetTickCount());
		if(FAILED(hr))
		{
			dwErr = HRESULT_CODE(hr);;
			LOG_ErrorMsg(dwErr);
			return dwErr;
		}


		
		hr=PathCchAppend(szFile,ARRAYSIZE(szFile),szFileName);
		if(FAILED(hr))
		{
			dwErr = HRESULT_CODE(hr);;
			LOG_ErrorMsg(dwErr);
			return dwErr;
		}

			//
		// try to write file
		//
		hFile = CreateFile(szFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_FLAG_DELETE_ON_CLOSE, NULL);

		if (INVALID_HANDLE_VALUE == hFile)
		{
			dwErr = GetLastError();
			LOG_ErrorMsg(dwErr);
			return dwErr;
		}

		CloseHandle(hFile);
	}

	return ERROR_SUCCESS;
}

//----------------------------------------------------------------------
//
// function to get a QueryServer from the Ident File for a Given ClientName
// This also looks in the registry for the IsBeta regkey indicating Beta
// functionlality
//
// Returns:
// S_OK : we successfully got QueryServer for this Client
// S_FALSE : we did NOT find a QueryServer for this Client (pszQueryServer will be a null string)
// E_INVALIDARG : parameters were incorrect
//----------------------------------------------------------------------
HRESULT GetClientQueryServer(LPCTSTR pszClientName, LPTSTR pszQueryServer, UINT cChars)
{
    HKEY hkey;
    BOOL fBeta = FALSE;
    int iIndex;
    TCHAR szQueryServerKeyName[128];
    TCHAR szIUDir[MAX_PATH];
    TCHAR szIdentFile[MAX_PATH];
    DWORD dwValue = 0;
    DWORD dwLength = sizeof(dwValue);
	HRESULT hr=S_OK;

    LOG_Block("GetClientQueryServer");

    if ((NULL == pszClientName) || (NULL == pszQueryServer) || (0 == cChars))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }

    // Check IUControl Reg Key for Beta Mode
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, REGVAL_ISBETA, NULL, NULL, (LPBYTE)&dwValue, &dwLength))
        {
            if (1 == dwValue)
            {
                fBeta = TRUE;
            }
        }
        RegCloseKey(hkey);
    }

    GetIndustryUpdateDirectory(szIUDir);
    
	
	hr=PathCchCombine (szIdentFile,ARRAYSIZE(szIdentFile),szIUDir,IDENTTXT);
	if(FAILED(hr))
	{
		 LOG_ErrorMsg(hr);
         return hr;
	}

    // Form the KeyName for the QueryServer Index
    
	hr=StringCchPrintfEx(szQueryServerKeyName,ARRAYSIZE(szQueryServerKeyName),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("%s%s"), pszClientName, fBeta ? IDENT_BETAQUERYSERVERINDEX : IDENT_QUERYSERVERINDEX);

	if(FAILED(hr))
	{
		 LOG_ErrorMsg(hr);
         return hr;
	}

    iIndex = GetPrivateProfileInt(IDENT_IUSERVERCACHE, szQueryServerKeyName, 0, szIdentFile);
    if (0 == iIndex)
    {
        iIndex = GetPrivateProfileInt(IDENT_IUSERVERCACHE, IDENT_DEFAULTQUERYSERVERINDEX, 0, szIdentFile);
        if (0 == iIndex)
        {
            return S_FALSE;
        }
    }

    // Form the KeyName for the Specified QueryServer based on the Index
    

	hr=StringCchPrintfEx(szQueryServerKeyName,ARRAYSIZE(szQueryServerKeyName),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("Server%d"), iIndex);
	if(FAILED(hr))
	{
		 LOG_ErrorMsg(hr);
         return hr;
	}

    GetPrivateProfileString(IDENT_IUSERVERCACHE, szQueryServerKeyName, _T(""), pszQueryServer, cChars, szIdentFile);
    if ('\0' == *pszQueryServer)
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

HRESULT DecompressFolderCabs(LPCTSTR pszDecompressPath)
{
    HRESULT hr = S_FALSE; // default is not an Error, but if there are no cabs we return S_FALSE
    TCHAR szSearchInfo[MAX_PATH];
    TCHAR szCabPath[MAX_PATH];
    LPTSTR pszCabList = NULL;
    LPTSTR pszWritePosition = NULL;
    LONG lCabCount = 0;

    WIN32_FIND_DATA fd;
    HANDLE hFind;
    BOOL fMore = TRUE;
    BOOL fRet = TRUE;

	USES_IU_CONVERSION;

    
	hr=PathCchCombine (szSearchInfo,ARRAYSIZE(szSearchInfo),pszDecompressPath, _T("*.cab"));

	if(FAILED(hr))
	{
		return hr;
	}
	

    hFind = FindFirstFile(szSearchInfo, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        while (fMore)
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                lCabCount++;
            }
            fMore = FindNextFile(hFind, &fd);
        }
        FindClose(hFind);

        pszCabList = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (MAX_PATH * sizeof(TCHAR) * lCabCount));
        if (NULL == pszCabList)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }

        pszWritePosition = pszCabList;

        hFind = FindFirstFile(szSearchInfo, &fd);
        fMore = (INVALID_HANDLE_VALUE != hFind);

		DWORD dwRemLength=lCabCount*MAX_PATH;

        while (fMore)
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
               
				hr=PathCchCombine(szCabPath,ARRAYSIZE(szCabPath),pszDecompressPath, fd.cFileName);
				if(FAILED(hr))
				{
					 SafeHeapFree(pszCabList);
					 return hr;
				}
                
				hr=StringCchCatEx(pszWritePosition,dwRemLength,szCabPath,NULL,NULL,MISTSAFE_STRING_FLAGS);
				if(FAILED(hr))
				{
					 SafeHeapFree(pszCabList);
					return hr;

				}
                
				dwRemLength=dwRemLength-  ( lstrlen(pszWritePosition)+ 2 * (sizeof(TCHAR)) );
				pszWritePosition += lstrlen(pszWritePosition) + 2 * (sizeof(TCHAR));
				

            }
            fMore = FindNextFile(hFind, &fd);
        }
        FindClose(hFind);

        pszWritePosition = pszCabList;
        for (LONG lCnt = 0; lCnt < lCabCount; lCnt++)
        {
            fRet = IUExtractFiles(pszWritePosition, pszDecompressPath);
            if (!fRet)
            {
                break;
            }
            pszWritePosition += lstrlen(pszWritePosition) + 2 * (sizeof(TCHAR));
        }

        SafeHeapFree(pszCabList);
        if (!fRet)
        {
            hr = E_FAIL; // one of the cabs had an error decompressing
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

//Extracts a cab file to the specified destination. Optionally we can pass in a colon seperated list of files to extract
BOOL IUExtractFiles(LPCTSTR pszCabFile, LPCTSTR pszDecompressFolder, LPCTSTR pszFileNames)
{
    HRESULT hr = S_OK;
#ifdef UNICODE
    char szCabFile[MAX_PATH];
    char szDecompressFolder[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, pszCabFile, -1, szCabFile, sizeof(szCabFile), NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, pszDecompressFolder, -1, szDecompressFolder, sizeof(szDecompressFolder), NULL, NULL);
    char *pszFiles = NULL;
    if(pszFileNames != NULL)
    {
        pszFiles = (char*)malloc(lstrlen(pszFileNames)+1);
        if (pszFiles == NULL)
        {
            return  FALSE;
        }
        WideCharToMultiByte(CP_ACP, 0, pszFileNames, -1, pszFiles, lstrlen(pszFileNames)+1, NULL, NULL);
    }
    hr = ExtractFiles(szCabFile, szDecompressFolder, 0, pszFiles, 0, 0);
    free(pszFiles);
#else
    hr = ExtractFiles(pszCabFile, pszDecompressFolder, 0, pszFileNames, 0, 0);
#endif
    return SUCCEEDED(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// ReplaceFileExtension
//
/////////////////////////////////////////////////////////////////////////////

BOOL ReplaceFileExtension(  LPCTSTR pszPath,
                          LPCTSTR pszNewExt,
                          LPTSTR pszNewPathBuf, 
                          DWORD cchNewPathBuf)
{
    LPCTSTR psz;
    HRESULT hr;
    DWORD   cchPath, cchExt, cch;

    if (pszPath == NULL || *pszPath == _T('\0'))
        return FALSE;

    cchPath = lstrlen(pszPath);

    // note that only a '>' comparison is needed since the file extension
    //  should never start at the 1st char in the path.
    for (psz = pszPath + cchPath;
         psz > pszPath && *psz != _T('\\') && *psz != _T('.');
         psz--);
    if (*psz == _T('\\'))
        psz = pszPath + cchPath;
    else if (psz == pszPath)
        return FALSE;

    // ok, so now psz points to the place where the new extension is going to 
    //  go.  Make sure our buffer is big enough.
    cchPath = (DWORD)(psz - pszPath);
    cchExt  = lstrlen(pszNewExt);
    if (cchPath + cchExt >= cchNewPathBuf)
        return FALSE;

    // yay.  we got a big enuf buffer.
    hr = StringCchCopyEx(pszNewPathBuf, cchNewPathBuf, pszPath, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        return FALSE;
    
    hr = StringCchCopyEx(pszNewPathBuf + cchPath, cchNewPathBuf - cchPath, pszNewExt,
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        return FALSE;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// ReplaceFileInPath
//
/////////////////////////////////////////////////////////////////////////////

BOOL ReplaceFileInPath(LPCTSTR pszPath, 
                       LPCTSTR pszNewFile,
                       LPTSTR pszNewPathBuf,
                       DWORD cchNewPathBuf)
{
    LPCTSTR psz;
    HRESULT hr;
    DWORD   cchPath, cchFile, cch;

    if (pszPath == NULL || *pszPath == _T('\0'))
        return FALSE;

    cchPath = lstrlen(pszPath);

    // note that only the '>=' comparison is safe cuz we check if pszPath is 
    //  NULL above, so there should always be at least one value < pszPath
    for (psz = pszPath + cchPath;
         psz >= pszPath && *psz != _T('\\');
         psz--);

    // either way we break out of the loop, gotta increment the pointer to
    //  be either the first char in the string or the first char after the
    //  last backslash
    psz++;

    // ok, so now psz points to the place where the new filename is going to 
    //  go.  Make sure our buffer is big enough.
    cchPath = (DWORD)(psz - pszPath);
    cchFile = lstrlen(pszNewFile);
    if (cchPath + cchFile >= cchNewPathBuf)
        return FALSE;
    
    // yay.  we got a big enuf buffer.
    if (cchPath > 0)
    {
        hr = StringCchCopyEx(pszNewPathBuf, cchNewPathBuf, pszPath, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            return FALSE;
    }
    
    hr = StringCchCopyEx(pszNewPathBuf + cchPath, cchNewPathBuf - cchPath, pszNewFile,
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        return FALSE;

    return TRUE;
}

// ----------------------------------------------------------------------------------
// 
// VerifyFileCRC : This function takes a File Path, calculates the hash on this file
// and compares it to the passed in Hash (pCRC).
// Returns:
// S_OK: CRC's Match
// ERROR_CRC (HRESULT_FROM_WIN32(ERROR_CRC): if the CRC's do not match
// Otherwise an HRESULT Error Code
//
// ----------------------------------------------------------------------------------
HRESULT VerifyFileCRC(LPCTSTR pszFileToVerify, LPCTSTR pszHash)
{
    HRESULT hr = S_OK;
    TCHAR szCompareCRC[CRC_HASH_STRING_LENGTH];
       
    // Validate Parameters
    if ((NULL == pszFileToVerify) || (NULL == pszHash))
        return E_INVALIDARG;

    hr = CalculateFileCRC(pszFileToVerify, szCompareCRC, ARRAYSIZE(szCompareCRC));
    if (FAILED(hr))
        return hr;

    // Now we need to Compare the Calculated CRC with the Passed in CRC
    if (0 == lstrcmpi(szCompareCRC, pszHash))
        return S_OK; // CRC's Match
    else
        return HRESULT_FROM_WIN32(ERROR_CRC); // CRC's do not match
}

// ----------------------------------------------------------------------------------
// 
// CalculateFileCRC : This function takes a File Path, calculates a CRC from the file
// converts it to a string and returns it in the supplied TCHAR buffer
//
// ----------------------------------------------------------------------------------

typedef BOOL (WINAPI * PFN_CryptCATAdminCalcHashFromFileHandle)(HANDLE hFile,
                                                                                                          DWORD *pcbHash,
                                                                                                          BYTE *pbHash,
                                                                                                          DWORD dwFlags);

HRESULT CalculateFileCRC(LPCTSTR pszFileToHash, LPTSTR pszHash, int cchBuf)
{
    HANDLE hFile;
    HRESULT hr = S_OK;
    DWORD cbHash = CRC_HASH_SIZE;
    BYTE bHashBytes[CRC_HASH_SIZE];
    BYTE b;

    // Validate Parameters
    if ((NULL == pszFileToHash) || (NULL == pszHash) || (cchBuf < CRC_HASH_STRING_LENGTH))
        return E_INVALIDARG;

    hFile = CreateFile(pszFileToHash, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        HMODULE hWinTrust = LoadLibraryFromSystemDir(_T("wintrust.dll"));
        if (NULL == hWinTrust)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            PFN_CryptCATAdminCalcHashFromFileHandle fpnCryptCATAdminCalcHashFromFileHandle = NULL;
            
            fpnCryptCATAdminCalcHashFromFileHandle  = (PFN_CryptCATAdminCalcHashFromFileHandle) GetProcAddress(hWinTrust, "CryptCATAdminCalcHashFromFileHandle");
            if (NULL == fpnCryptCATAdminCalcHashFromFileHandle)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                if (!fpnCryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, bHashBytes, 0))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
                fpnCryptCATAdminCalcHashFromFileHandle = NULL;
            }
            FreeLibrary(hWinTrust);
        }
        CloseHandle(hFile);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (FAILED(hr))
        return hr;

    LPTSTR p = pszHash;

    // Now we have the Calculated CRC of the File, we need to convert it to a String and Return it. The following 
    // loop will go through each byte in the array and convert it to a Hex Character in the supplied TCHAR buffer
    for (int i = 0; i < CRC_HASH_SIZE; i++)
    {
        b = bHashBytes[i] >> 4;
        if (b <= 9)
            *p = '0' + (TCHAR)b;
        else
            *p = 'A' + (TCHAR)(b - 10);
        p++;

        b = bHashBytes[i] & 0x0F;
        if (b <= 9)
            *p = '0' + (TCHAR)b;
        else
            *p = 'A' + (TCHAR)(b - 10);
        p++;
    }
    *p = _T('\0');
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\urllogging\test\testisconnected.cpp ===
// testIsConnected.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include <wininet.h>
#include <iphlpapi.h>
#include <winsock2.h>
#include <malloc.h>
#include <MemUtil.h>
#include <shlwapi.h>
#include <sensapi.h>

#include <URLLogging.h>
//#include "testSens.h"

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))

#define INTERNET_RAS_INSTALLED              0x10
#define INTERNET_CONNECTION_OFFLINE         0x20
#define INTERNET_CONNECTION_CONFIGURED      0x40

//
// from winsock.dll (version 1.1 and up)
//
//typedef BOOL	(WINAPI * INETCONNECTSTATE)(LPDWORD, DWORD);
//typedef BOOL	(WINAPI * INETQUERYOPTION)(HINTERNET, DWORD, LPVOID, LPDWORD);
typedef int FAR	(WINAPI * WSASTARTUP)(WORD, LPWSADATA);
typedef int FAR	(WINAPI * WSACLEANUP)(void);
typedef int FAR	(WINAPI * WSAGETLASTERROR)(void);
typedef struct hostent FAR * (WINAPI * GETHOSTBYNAME)(const char FAR *);
typedef ULONG	(WINAPI * INET_ADDR)(const CHAR FAR *);
typedef char FAR *	(WINAPI * INET_NTOA)(struct in_addr);

//
// from iphlpapi.dll
//
typedef DWORD FAR	(WINAPI * GETBESTINTERFACE)(IPAddr, DWORD *);
typedef DWORD FAR	(WINAPI * GETINTERFACEINFO)(PIP_INTERFACE_INFO, PULONG);
typedef DWORD FAR	(WINAPI * GETIPFORWARDTABLE)(PMIB_IPFORWARDTABLE, PULONG, BOOL);
typedef DWORD FAR	(WINAPI * GETBESTROUTE)(IPAddr, IPAddr, PMIB_IPFORWARDROW);

//
// from sensapi.dll
//
typedef BOOL	(WINAPI * ISNETWORKALIVE)(LPDWORD);
typedef BOOL	(WINAPI * ISDESTINATIONREACHABLEA)(LPCSTR, LPQOCINFO);

CHAR szWU_PING_URL[] = "207.46.130.150"; // ip addr for windowsupdate.microsoft.com
//const TCHAR szWU_BASE_URL[] = _T("http://windowsupdate.microsoft.com");

BOOL g_fVerbose = FALSE;

HMODULE g_hIphlp = NULL;
HMODULE g_hSock = NULL;
HMODULE g_hSens = NULL;

// from winsock.dll (version 1.0 and up)
WSASTARTUP g_pfnWSAStartup = NULL;
WSACLEANUP g_pfnWSACleanup = NULL;
WSAGETLASTERROR g_pfnWSAGetLastError = NULL;
GETHOSTBYNAME g_pfn_gethostbyname = NULL;
INET_NTOA g_pfn_inet_ntoa = NULL;
INET_ADDR g_pfn_inet_addr = NULL;

// from iphlpapi.dll
GETINTERFACEINFO g_pfnGetInterfaceInfo = NULL;
GETIPFORWARDTABLE g_pfnGetIpForwardTable = NULL;
GETBESTINTERFACE g_pfnGetBestInterface = NULL;
GETBESTROUTE g_pfnGetBestRoute = NULL;

// from sensapi.dll
ISNETWORKALIVE g_pfnIsNetworkAlive = NULL;
ISDESTINATIONREACHABLEA g_pfnIsDestinationReachableA = NULL;

void printBestRoute(MIB_IPFORWARDROW & bestRoute)
{
	CHAR szForwardDest[15 + 1];
	CHAR szForwardMask[15 + 1];
	CHAR szForwardNextHop[15 + 1];
	struct in_addr in;

	in.s_addr = bestRoute.dwForwardDest;
	lstrcpyA(szForwardDest, g_pfn_inet_ntoa(in));
	in.s_addr = bestRoute.dwForwardMask;
	lstrcpyA(szForwardMask, g_pfn_inet_ntoa(in));
	in.s_addr = bestRoute.dwForwardNextHop;
	lstrcpyA(szForwardNextHop, g_pfn_inet_ntoa(in));
	printf("\tdest\t= %s\n\tmask\t= %s\n\tgateway\t= %s\n\tifindex\t= %d\n\ttype\t= %d\n\tproto\t= %d\n\tage\t= %d\n",
		szForwardDest,
		szForwardMask,
		szForwardNextHop,
		bestRoute.dwForwardIfIndex,
		bestRoute.dwForwardType,
		bestRoute.dwForwardProto,
		bestRoute.dwForwardAge);
}


BOOL MyIsConnected(WORD wVersion, LPCTSTR ptszUrl, BOOL fLive)
{
    BOOL bRet = FALSE;
    DWORD dwErr;

	LPTSTR ptszHostName = NULL;
/*
	if (0x3 == wVersion)
	{
		printf("Sleeping 20 seconds...\n");
		Sleep(20000);
		return g_fConnected;
	}
*/
	if (0x1 == wVersion)
	{
		// Test latest behavior
		return IsConnected(ptszUrl, fLive);
	}

	DWORD dwConnMethod = 0;

	if (0x200 == wVersion || 0x202 == wVersion)
	{
		if (bRet = InternetGetConnectedState(&dwConnMethod, 0))
		{
			// modem is dialing
			if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY)
			{
				bRet = FALSE;
				goto lFinish;
			}

			// check if there is a proxy but currently user is offline
			if (dwConnMethod & INTERNET_CONNECTION_PROXY)
			{
				DWORD dwState = 0;
				DWORD dwSize = sizeof(DWORD);

				if (!InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
				{
					printf("IsConnected(): InternetQueryOptionA failed with error %d\n", GetLastError());
				}

				if (dwState & (INTERNET_STATE_DISCONNECTED_BY_USER | INTERNET_STATE_DISCONNECTED))
				{
					bRet = FALSE;
					goto lFinish;
				}
			}
		}
		else
		{
			//
			// further test the case that user didn't run icw but is using a modem connection
			//
			const DWORD dwModemConn = (INTERNET_CONNECTION_MODEM | INTERNET_CONNECTION_MODEM_BUSY);
			if ((dwConnMethod & dwModemConn) == dwModemConn)
			{
				bRet = TRUE;
			}
		}
	}
	else
	{
		DWORD dwFlags;

		bRet = g_pfnIsNetworkAlive(&dwFlags);
	}

    //one final check for connectivity by pinging microsoft.com
    //if (bRet)
    //{
    //  bRet = CheckByPing(szURL);
    //}
    //bugfix for InternetGetConnectedState API - if LAN card is disabled it still returns LAN connection
    //use GetBestInterface and see if there is any error trying to reach an outside IP address
    //this may fix scenarios in homelan case where there is no actual connection to internet??
    if (((0x0200 == wVersion || 0x0202 == wVersion) &&
		 (!bRet || (dwConnMethod & INTERNET_CONNECTION_LAN))) ||  //LAN card present
		//bug 299338
		(0x0 == wVersion && bRet))
    {
		IPAddr dest = INADDR_NONE;

		if (0x0200 == wVersion)
		{
			if (INADDR_NONE == (dest = g_pfn_inet_addr(szWU_PING_URL)))
			{
				printf("inet_addr(\"%s\") failed\n", szWU_PING_URL);
			}
		}
		else
		{
			if (NULL != ptszUrl && _T('\0') != ptszUrl[0])
			{
				const TCHAR c_tszHttpScheme[] = _T("http://");

				if (0 == _tcsncmp(ptszUrl, c_tszHttpScheme, ARRAYSIZE(c_tszHttpScheme) - 1))
				{
					ptszUrl += ARRAYSIZE(c_tszHttpScheme) - 1;	// skip http://
				}
				LPCTSTR ptszDelim = _tcschr(ptszUrl, _T('/'));
				if (NULL == ptszDelim)
				{
					ptszDelim = ptszUrl + lstrlen(ptszUrl);
				}

				if (NULL != (ptszHostName = (LPTSTR) malloc(sizeof(TCHAR) * (ptszDelim - ptszUrl + 1))))
				{
					lstrcpyn(ptszHostName, ptszUrl, ((int) (ptszDelim - ptszUrl)) + 1);

					USES_IU_CONVERSION;

					LPSTR pszHostName = T2A(ptszHostName);

					if (0x0 != wVersion || INADDR_NONE == (dest = g_pfn_inet_addr(pszHostName)))
					{
						if (g_fVerbose)
						{
							printf("Resolving domain name for %s...\n", pszHostName);
						}

						int iErr = 0;

						if (0x0 == wVersion)
						{
							WSADATA wsaData;

							if (0 == (iErr = g_pfnWSAStartup(MAKEWORD(1, 1), &wsaData)))
							{
								if (g_fVerbose)
								{
									printf("WSAStartup() succeeded, wVersion = %d.%d, wHighVersion = %d.%d\n",
											LOBYTE(wsaData.wVersion),
											HIBYTE(wsaData.wVersion),
											LOBYTE(wsaData.wHighVersion),
											HIBYTE(wsaData.wHighVersion));
								}
							}
							else
							{
								/* Tell the user that we could not find a usable */
								/* WinSock DLL.                                  */
								printf("IsConnected(): WSAStartup() failed with error %d\n", iErr);
							}
						}

						if (0 == iErr)
						{
							DWORD dwTimeEllapsed = GetTickCount();

							struct hostent *ptHost = g_pfn_gethostbyname(pszHostName);

							dwTimeEllapsed = GetTickCount() - dwTimeEllapsed;

							if (NULL == ptHost)
							{
								dwErr = g_pfnWSAGetLastError();
								printf("IsConnected(): gethostbyname(\"%s\") failed with error WSABASEERR+%d (%d), took %d msecs\n", pszHostName, dwErr - WSABASEERR, dwErr, dwTimeEllapsed);

								if (0x0 == wVersion)
								{
									bRet = FALSE;
								}
							}
							else if (AF_INET == ptHost->h_addrtype &&
									 sizeof(IPAddr) == ptHost->h_length &&
									 NULL != ptHost->h_addr_list &&
									 NULL != *ptHost->h_addr_list)
							{
								dest = *((IPAddr FAR *) ptHost->h_addr);

								if (g_fVerbose)
								{
									printf("Host name %s resolved to be ", pszHostName);

									for (IPAddr FAR * FAR * ppAddresses = (IPAddr FAR * FAR *) ptHost->h_addr_list;
										 *ppAddresses != NULL;
										ppAddresses++)
									{
										struct in_addr in;

										in.s_addr = **ppAddresses;
										printf("%s, ", g_pfn_inet_ntoa(in));
									}
									printf("took %d msecs\n", dwTimeEllapsed);
								}
							}
							else
							{
								printf("IsConnected(): gethostbyname(\"%s\") returns invalid host entry\n", pszHostName);
							}

							if (0x0 == wVersion)
							{
								if (iErr = g_pfnWSACleanup())
								{
									printf("IsConnected(): WSACleanup() failed with error %d\n", iErr);
								}
								else if (g_fVerbose)
								{
									printf("WSACleanup() succeeded\n");
								}
							}
						}
					}
				}
				else
				{
					printf("IsConnected(): call to malloc() failed\n");
				}
			}
		}

		if (INADDR_NONE != dest)
		{
			DWORD dwIndex;
			struct in_addr in;

			in.s_addr = dest;

			if (bRet = (NO_ERROR == (dwErr = g_pfnGetBestInterface(dest, &dwIndex))))
			{
				if (g_fVerbose)
				{
					printf("GetBestInterface(%s) succeeded, dwIndex = %d\n", g_pfn_inet_ntoa(in), dwIndex);
				}
			}
			else
			{
				printf("IsConnected(): GetBestInterface(%s) failed w/ error %d\n", g_pfn_inet_ntoa(in), dwErr);
			}
		}
    }

lFinish:
	if (NULL != ptszHostName)
	{
		free(ptszHostName);
	}

    printf(bRet ? "Connected\n" : "Not connected\n");
    return (bRet);
}


void runApiTests(LPSTR pszURL)
{
	if (!g_fVerbose)
	{
		return;
	}

	DWORD dwFlags;

	if (g_pfnIsNetworkAlive(&dwFlags))
	{
		printf("IsNetworkAlive(&dwFlags) returns TRUE, dwFlags = %#lx\n", dwFlags);
		if (dwFlags & NETWORK_ALIVE_LAN)
		{
			printf("\t%s\n", "NETWORK_ALIVE_LAN");
		}
		if (dwFlags & NETWORK_ALIVE_WAN)
		{
			printf("\t%s\n", "NETWORK_ALIVE_WAN");
		}
		if (dwFlags & NETWORK_ALIVE_AOL)
		{
			printf("\t%s\n", "NETWORK_ALIVE_AOL");
		}
	}
	else
	{
		printf("runApiTests(): IsNetworkAlive(&dwFlags) failed with error %d\n", GetLastError());
	}

	printf("Checking destination reachability for %s...\n", pszURL);
	if (g_pfnIsDestinationReachableA(pszURL, NULL))
	{
		printf("IsDestinationReachableA(\"%s\", NULL) returns TRUE\n", pszURL);
	}
	else
	{
		printf("runApiTests(): IsDestinationReachableA(\"%s\", NULL) failed with error %d\n", pszURL, GetLastError());
	}
	printf("\n");

	PMIB_IPFORWARDTABLE pIpForwardTable = NULL;
	PIP_INTERFACE_INFO pIfTable = NULL;
	DWORD dwOutBufLen = 0;
	DWORD dwErr;

	switch(dwErr = g_pfnGetInterfaceInfo(pIfTable, &dwOutBufLen))
	{
	case NO_ERROR:
		printf("runApiTests(): GetInterfaceInfo() returns NO_ERROR with no buffer?\n");
		break;

	case ERROR_INSUFFICIENT_BUFFER:
		if (NULL == (pIfTable = (PIP_INTERFACE_INFO) malloc(dwOutBufLen)))
		{
			printf("IsConnected(): call to malloc() failed\n");
		}
		else
		{
			if (NO_ERROR != (dwErr = g_pfnGetInterfaceInfo(pIfTable, &dwOutBufLen)))
			{
				printf("runApiTests(): GetInterfaceInfo() failed with error %d\n", dwErr);
			}
			else
			{
				if (0 != pIfTable->NumAdapters)
				{
					for (int i=0; i<pIfTable->NumAdapters; i++)
					{
						printf("Network interface #%d = %ls\n", pIfTable->Adapter[i].Index, pIfTable->Adapter[i].Name);
					}
				}
				else
				{
					printf("There is no network interface on this machine.\n");
				}
				printf("\n");
			}

			free(pIfTable);
		}
		break;

	default:
		printf("runApiTests(): GetInterfaceInfo() failed with error %d\n", dwErr);
		break;
	}

	// Find out how big our buffer needs to be
	DWORD dwSize = 0;

	if (ERROR_INSUFFICIENT_BUFFER == (dwErr = g_pfnGetIpForwardTable(pIpForwardTable, &dwSize, TRUE)))
	{
		// Allocate the memory for the table
		if (NULL != (pIpForwardTable = (PMIB_IPFORWARDTABLE) malloc(dwSize)))
		{
			// Now get the table
			dwErr = g_pfnGetIpForwardTable(pIpForwardTable, &dwSize, TRUE);
		}
		else
		{
			printf("runApiTests(): call to malloc() failed\n");
		}
	}

	if (NO_ERROR == dwErr)
	{
		if (0 != pIpForwardTable->dwNumEntries)
		{
			printf("%-15.15s\t%-15.15s\t%-15.15s\t%s\t%s\t%s\t%s\n",
				"Destination",
				"Network Mask",
				"Gateway",
				"IfIndex",
				"Type",
				"Proto",
				"Age");
			printf("===============================================================================\n");
			for (DWORD i=0; i < pIpForwardTable->dwNumEntries; i++)
			{
				PMIB_IPFORWARDROW pRow = &(pIpForwardTable->table[i]);

				CHAR szForwardDest[15 + 1];
				CHAR szForwardMask[15 + 1];
				CHAR szForwardNextHop[15 + 1];
				struct in_addr in;

				in.s_addr = pRow->dwForwardDest;
				lstrcpyA(szForwardDest, g_pfn_inet_ntoa(in));
				in.s_addr = pRow->dwForwardMask;
				lstrcpyA(szForwardMask, g_pfn_inet_ntoa(in));
				in.s_addr = pRow->dwForwardNextHop;
				lstrcpyA(szForwardNextHop, g_pfn_inet_ntoa(in));
				printf("%15.15s\t%15.15s\t%15.15s\t%d\t%d\t%d\t%d\n",
					szForwardDest,
					szForwardMask,
					szForwardNextHop,
					pRow->dwForwardIfIndex,
					pRow->dwForwardType,
					pRow->dwForwardProto,
					pRow->dwForwardAge);
			}
		}
		else
		{
			printf("There is no entry in the routing table.\n");
		}
		printf("\n");
	}
	else
	{
		printf("runApiTests(): GetIpForwardTable() failed w/ error %d\n", dwErr);
	}

	DWORD dwConnMethod = 0;

	if (InternetGetConnectedState(&dwConnMethod, 0))
	{
		printf("InternetGetConnectedState(&dwConnMethod) returns TRUE, dwConnMethod = %#lx\n", dwConnMethod);
	}
	else
	{
		printf("InternetGetConnectedState(&dwConnMethod) returns FALSE\n");
	}
	if (dwConnMethod & INTERNET_CONNECTION_MODEM)
	{
		printf("\t%s\n", "INTERNET_CONNECTION_MODEM");
	}
	if (dwConnMethod & INTERNET_CONNECTION_LAN )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_LAN");
	}
	if (dwConnMethod & INTERNET_CONNECTION_PROXY )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_PROXY");
	}
	if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_MODEM_BUSY");
	}
	if (dwConnMethod & INTERNET_RAS_INSTALLED )
	{
		printf("\t%s\n", "INTERNET_RAS_INSTALLED");
	}
	if (dwConnMethod & INTERNET_CONNECTION_OFFLINE )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_OFFLINE");
	}
	if (dwConnMethod & INTERNET_CONNECTION_CONFIGURED )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_CONFIGURED");
	}
	printf("\n");

	DWORD dwState = 0;

	dwSize = sizeof(DWORD);
    if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
		printf("InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize) returns TRUE, dwState = %#lx\n", dwState);
		if (dwState & INTERNET_STATE_CONNECTED)
		{
			printf("\t%s\n", "INTERNET_STATE_CONNECTED - connected state (mutually exclusive with disconnected)");
		}
		if (dwState & INTERNET_STATE_DISCONNECTED)
		{
			printf("\t%s\n", "INTERNET_STATE_DISCONNECTED - disconnected from network");
		}
		if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
		{
			printf("\t%s\n", "INTERNET_STATE_DISCONNECTED_BY_USER - disconnected by user request");
		}
		if (dwState & INTERNET_STATE_IDLE)
		{
			printf("\t%s\n", "INTERNET_STATE_IDLE - no network requests being made (by Wininet)");
		}
		if (dwState & INTERNET_STATE_BUSY)
		{
			printf("\t%s\n", "INTERNET_STATE_BUSY - network requests being made (by Wininet)");
		}
    }
    else
    {
        printf("IsConnected(): InternetQueryOptionA failed with error %d\n", GetLastError());
    }
	printf("\n");

	if (NULL != pIpForwardTable)
	{
		free(pIpForwardTable);
	}
}


void runTest(WORD wVersion, LPSTR pszURL, BOOL fLive)
{
	CHAR szVersion[50];
	HRESULT hr;
	BOOL fCoInit = FALSE;

	switch (wVersion)
	{
	case 0x0200:
	case 0x0202:
		sprintf(szVersion, "from AU %d.%d", HIBYTE(wVersion), LOBYTE(wVersion));
		break;
	case 0x0:
		sprintf(szVersion, "(bug fix candidate)");
		break;
	case 0x1:
		sprintf(szVersion, "(latest code)");
		break;
/*
	case 0x3:
		sprintf(szVersion, "(SENS test)");
		if (fCoInit = FAILED(hr = CoInitialize(NULL)))
		{
			printf("runTest(): CoInitialize(NULL) failed w/ error %#lx\n", hr);
			goto CleanUp;
		}
		if (g_fVerbose)
		{
			printf("runTest(): CoInitialize(NULL) succeeded\n");
		}
		if (FAILED(hr = ActivateSensNetworkNotification()))
		{
			printf("runTest(): ActivateSensNetworkNotification() failed w/ error %#lx\n", hr);
			goto CleanUp;
		}
		if (g_fVerbose)
		{
			printf("runTest(): ActivateSensNetworkNotification() succeeded\n");
		}
		break;
*/
	default:
		printf("runTest(): unknown wVersion\n");
		goto CleanUp;
	}

	printf("Testing connection detection/server reachability algorithm %s...\n", szVersion);

	{
		USES_IU_CONVERSION;

		LPTSTR ptszURL = A2T(0x0200 == wVersion ? szWU_PING_URL : pszURL);

		_tprintf(_T("IsConnected(\"%s\") returns %s\n"), ptszURL, MyIsConnected(wVersion, ptszURL, fLive) ? _T("TRUE") : _T("FALSE"));
	}

/*
	if (0x3 == wVersion)
	{
		if (FAILED(hr = DeactivateSensNetworkNotification()))
		{
			printf("runTest(): DeactivateSensNetworkNotification() failed w/ error %#lx\n", hr);
		}
		else if (g_fVerbose)
		{
			printf("runTest(): DeactivateSensNetworkNotification() succeeded\n");
		}
	}
*/

CleanUp:
	if (fCoInit)
	{
		CoUninitialize();
	}
}

int __cdecl main(int argc, char* argv[])
{
	char c_szMethodToken[] = "/method:";
	char c_szMToken[] = "/m:";
	char c_szVerboseToken[] = "/verbose";
	char c_szVToken[] = "/v";
	char c_szCorpToken[] = "/corpwu";
	char c_szLiveToken[] = "/live";
	int fLive = -1;

	WORD wVersion = 0xffff;	// default == unknown;
	LPSTR pszURL = NULL;

	int index = 0;

	while (index < argc - 1)
	{
		LPSTR psz = NULL;

		index++;

		if (0 == StrCmpNIA(argv[index], c_szMethodToken, ARRAYSIZE(c_szMethodToken) - 1))
		{
			psz = argv[index] + ARRAYSIZE(c_szMethodToken) - 1;
		}
		else if (0 == StrCmpNIA(argv[index], c_szMToken, ARRAYSIZE(c_szMToken) - 1))
		{
			psz = argv[index] + ARRAYSIZE(c_szMToken) - 1;
		}

		if (NULL != psz)
		{
			if (0xffff != wVersion)
			{
				// param specified twice
				goto Usage;
			}

			char c_szOptionCode[] = "code";
			char c_szOptionFix[] = "fix";
			char c_szOptionAll[] = "all";
			char c_szOptionSens[] = "sens";
			int iMajorVersion = 0, iMinorVersion = 0;

			if (2 != sscanf(psz, "%d.%d", &iMajorVersion, &iMinorVersion))
			{
				if (0 == StrCmpNIA(psz, c_szOptionCode, ARRAYSIZE(c_szOptionCode)))
				{
					iMajorVersion = 0;
					iMinorVersion = 1;
				}
				else if (0 == StrCmpNIA(psz, c_szOptionFix, ARRAYSIZE(c_szOptionFix)))
				{
					iMajorVersion = iMinorVersion = 0;
				}
				else if (0 == StrCmpNIA(psz, c_szOptionAll, ARRAYSIZE(c_szOptionAll)))
				{
					iMajorVersion = 0xff;
					iMinorVersion = 0xfe;
				}
/*
				else if (0 == StrCmpNIA(psz, c_szOptionSens, ARRAYSIZE(c_szOptionSens)))
				{
					iMajorVersion = 0;
					iMinorVersion = 3;
				}
*/
				else
				{
					goto Usage;
				}
			}
			wVersion = MAKEWORD(iMinorVersion, iMajorVersion);
			continue;
		}

		if (0 == StrCmpNIA(argv[index], c_szVerboseToken, ARRAYSIZE(c_szVerboseToken)) ||
			0 == StrCmpNIA(argv[index], c_szVToken, ARRAYSIZE(c_szVToken)))
		{
			if (g_fVerbose)
			{
				// param specified twice
				goto Usage;
			}

			g_fVerbose = TRUE;
			continue;
		}

		if (0 == StrCmpNIA(argv[index], c_szLiveToken, ARRAYSIZE(c_szLiveToken)))
		{
			if (-1 != fLive)
			{
				// param specified twice or conflicting param
				goto Usage;
			}

			fLive = 1;
			continue;
		}

		if (0 == StrCmpNIA(argv[index], c_szCorpToken, ARRAYSIZE(c_szCorpToken)))
		{
			if (-1 != fLive)
			{
				// param specified twice or conflicting param
				goto Usage;
			}

			fLive = 0;
			continue;
		}

		if ('/' != *argv[index])
		{
			if (NULL != pszURL)
			{
				// param specified twice
				goto Usage;
			}

			pszURL = argv[index];
			continue;
		}

		// unknown param
		goto Usage;
	}

	switch (wVersion)
	{
	case 0x0200:
		if (NULL != pszURL)
		{
			goto Usage;
		}
		break;
	case 0x0202:
	case 0x0:
	case 0x1:
//	case 0x3:
	case 0xfffe:
		if (NULL == pszURL)
		{
			goto Usage;
		}
		break;
	default:
		goto Usage;
	}

	if (-1 == fLive)
	{
		fLive = 1;
	}

	if ((NULL == g_hIphlp && NULL == (g_hIphlp = LoadLibrary(TEXT("iphlpapi.dll")))) ||
		NULL == (g_pfnGetBestInterface = (GETBESTINTERFACE)::GetProcAddress(g_hIphlp, "GetBestInterface")) ||
		NULL == (g_pfnGetBestRoute = (GETBESTROUTE)::GetProcAddress(g_hIphlp, "GetBestRoute")) ||
		NULL == (g_pfnGetInterfaceInfo = (GETINTERFACEINFO)::GetProcAddress(g_hIphlp, "GetInterfaceInfo")) ||
		NULL == (g_pfnGetIpForwardTable = (GETIPFORWARDTABLE)::GetProcAddress(g_hIphlp, "GetIpForwardTable")))
	{
		printf("Failed to load proc from iphlpapi.dll\n");
		goto Done;
	}

	if ((NULL == g_hSock && NULL == (g_hSock = LoadLibrary(TEXT("ws2_32.dll")))) ||
		NULL == (g_pfnWSAStartup = (WSASTARTUP)::GetProcAddress(g_hSock, "WSAStartup")) ||
		NULL == (g_pfnWSACleanup = (WSACLEANUP)::GetProcAddress(g_hSock, "WSACleanup")) ||
		NULL == (g_pfn_gethostbyname = (GETHOSTBYNAME)::GetProcAddress(g_hSock, "gethostbyname")) ||
		NULL == (g_pfnWSAGetLastError = (WSAGETLASTERROR)::GetProcAddress(g_hSock, "WSAGetLastError")) ||
		NULL == (g_pfn_inet_addr = (INET_ADDR)::GetProcAddress(g_hSock, "inet_addr")) ||
		NULL == (g_pfn_inet_ntoa = (INET_NTOA)::GetProcAddress(g_hSock, "inet_ntoa")))
	{
		printf("Failed to load proc from ws2_32.dll\n");
		goto Done;
	}

	if (NULL == (g_hSens = LoadLibrary(TEXT("sensapi.dll"))) ||
		NULL == (g_pfnIsNetworkAlive = (ISNETWORKALIVE)::GetProcAddress(g_hSens, "IsNetworkAlive")) ||
		NULL == (g_pfnIsDestinationReachableA = (ISDESTINATIONREACHABLEA)::GetProcAddress(g_hSens, "IsDestinationReachableA")))
	{
		printf("Failed to load proc from sensapi.dll\n");
		goto Done;
	}

	if (0xfffe == wVersion)
	{
		WORD awVersions[] = {0x0200, 0x0202, 0x0, 0x1};

		printf("*******************************************************************************\nRunning API tests...\n\n");
		runApiTests(0x0200 == wVersion ? szWU_PING_URL : pszURL);

		printf("*******************************************************************************\nRunning various connectivity tests...\n\n");
		for (int i=0; i < ARRAYSIZE(awVersions); i++)
		{
			runTest(awVersions[i], pszURL, fLive);
			printf("\n");
		}
	}
	else
	{
		runTest(wVersion, pszURL, fLive);
	}
	goto Done;

Usage:
	printf("Windows Update V4 Network Connectivity/Server Reachability (IsConnected) Test\nCopyright (c) 2002. Microsoft Corporation. All rights reserved.\n\n");
	printf("usage:\n\ttestIsConnected /m[ethod]:<method> [/v[erbose]] [/live | /corpwu] [<destination>]\n");
	printf("where\n\t<method>\ttest method i.e. \"2.0\" for AU 2.0,\n");
	printf("\t\t\t\t\t \"2.2\" for older AU 2.2,\n");
	printf("\t\t\t\t\t \"fix\" for AU 2.2 w/ fix (mirrored),\n");
	printf("\t\t\t\t\t \"code\" for actual AU 2.2 code w/ fix,\n");
	printf("\t\t\t\t\t \"all\" to test all methods\n");
	printf("\t/live\t\tspecifies destination points to the live WU server\n");
	printf("\t\t\t(default; cannot be used together with /corpwu)\n");
	printf("\t/corpwu\t\tspecifies destination points to a WUCE server\n");
	printf("\t\t\t(cannot be used together with /live)\n");
	printf("\t<destination>\thost name or full URL to check for server reachability\n\t\t\te.g. \"windowsupdate.microsoft.com\",\n\t\t\t     \"v4autest\" or \"http://www.any.place/any.thing\"\n\t\t\t(not used in 2.0 mode)\n");

Done:
    if (g_hIphlp != NULL)
    {
        FreeLibrary(g_hIphlp);
    }
	if (g_hSock != NULL)
	{
		FreeLibrary(g_hSock);
	}
	if (g_hSens != NULL)
	{
		FreeLibrary(g_hSens);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	util
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.util

TARGETNAME=util
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\fileutil.cpp \
    ..\StringUtil.cpp \
	..\MemUtil.cpp  \
    ..\RegUtil.cpp  \
    ..\WaitUtil.cpp \
    ..\timeutil.cpp \
    ..\BinCompatible.cpp \
    ..\RedirectUtil.cpp \
    ..\EnsureACLs.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\regutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   RegUtil.CPP
//	Author:	Charles Ma, 10/20/2000
//
//	Revision History:
//
//
//
//
//  Description:
//
//      Implement IU registry accessing utility library
//
//=======================================================================

#include <windows.h>
#include <tchar.h>
#include <logging.h>
#include <memutil.h>
#include <fileutil.h>
#include <stringutil.h>
#include <shlwapi.h>
#include "wusafefn.h"
#include <regutil.h>
#include<iucommon.h>
#include <MISTSAFE.h>

const int REG_BUF_SIZE = 1024;


const LPCTSTR REG_ROOTKEY_STR[7] = { 
	_T("HKEY_LOCAL_MACHINE"),
	_T("HKEY_CLASSES_ROOT"),
	_T("HKEY_CURRENT_USER"),
	_T("HKEY_CURRENT_CONFIG"),
	_T("HKEY_USERS"),
	_T("HKEY_PERFORMANCE_DATA"),	// NT only
	_T("HKEY_DYN_DATA")				// W9x only
};

const HKEY REG_ROOTKEY[7] = {
	HKEY_LOCAL_MACHINE,
	HKEY_CLASSES_ROOT,
	HKEY_CURRENT_USER,
	HKEY_CURRENT_CONFIG,
	HKEY_USERS,
	HKEY_PERFORMANCE_DATA,
	HKEY_DYN_DATA
};


typedef BOOL (WINAPI * PFN_StrToInt64Ex)(LPCTSTR pszString,
										 DWORD dwFlags,
										 LONGLONG * pllRet);



// ----------------------------------------------------------------------
//
// private function to split a full reg path into
// two parts: root key and subkey
//
// ----------------------------------------------------------------------
LPCTSTR SplitRegPath(LPCTSTR lpsRegPath, HKEY* phRootKey)
{
	LPTSTR lpSubKey = NULL;
	for (int i = 0; i < sizeof(REG_ROOTKEY)/sizeof(HKEY); i++)
	{
		if ((lpSubKey = StrStrI(lpsRegPath, REG_ROOTKEY_STR[i])) == lpsRegPath)
		{
			*phRootKey = REG_ROOTKEY[i];
			lpSubKey += lstrlen(REG_ROOTKEY_STR[i]);
			lpSubKey = CharNext(lpSubKey); // skip past "\", if any (or remain on NULL)
			return lpSubKey;
		}
	}
	//
	// if come to here, must be no right root key
	//
	*phRootKey = 0;
	return lpsRegPath;
}


// ----------------------------------------------------------------------
//
// public function to tell if a reg key exists
//
// ----------------------------------------------------------------------
BOOL RegKeyExists(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName		// optional value name
)
{
	LOG_Block("RegKeyExists()");

	HKEY hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL rc = FALSE;
	DWORD dwType = 0x0;

	if (NULL == lpsKeyPath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	LOG_Out(_T("Parameters: (%s, %s)"), lpsKeyPath, lpsValName);

	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (hRootKey && ERROR_SUCCESS == RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey))
	{
		rc = (NULL == lpsValName) ||
			 (ERROR_SUCCESS == RegQueryValueEx(hKey, lpsValName, NULL, &dwType, NULL, NULL));
	}

	if (hKey)
	{
		RegCloseKey(hKey);
	}

	LOG_Out(_T("Result: %s"), rc ? _T("TRUE") : _T("FALSE"));

	return rc;

}






// ----------------------------------------------------------------------
//
// public function to tell is a reg value in reg matches given value
//
// ----------------------------------------------------------------------
BOOL RegKeyValueMatch(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsValue		// value value
)
{
	LOG_Block("RegKeyValueMatch()");

	HKEY	hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL	rc = FALSE;
	BYTE	btBuffer[REG_BUF_SIZE];
	LPBYTE	pBuffer = btBuffer;	
	LPCTSTR lpCurStr;
	DWORD	dwType = 0x0;
	DWORD	dwSize = sizeof(btBuffer);
	DWORD	dwCode = 0x0;
	HRESULT hr=S_OK;

	USES_MY_MEMORY;

	if (NULL == lpsKeyPath || NULL == lpsValue)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		goto CleanUp;
	}

	LOG_Out(_T("Parameters: (%s, %s, %s)"), lpsKeyPath, lpsValName, lpsValue);


	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (0 == hRootKey || (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey)))
	{
		goto CleanUp;
	}

	//
	// try to query the value with existing buffer.
	//
	dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, btBuffer, &dwSize);
	if (ERROR_MORE_DATA == dwCode)
	{
		//
		// if found the existing buffer not large enough, 
		// then allocate memory large enough to store the data now
		//
		if (NULL == (pBuffer = (LPBYTE) MemAlloc(dwSize)))
		{
			goto CleanUp;
		}
		dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, pBuffer, &dwSize);
	}

	if (ERROR_SUCCESS != dwCode)
	{
		goto CleanUp;
	}

	//
	// since the value to compare was read from XML doc, obviously only
	// the following 4 types possible to compare with
	//

	switch (dwType)
	{
	case REG_DWORD:
		{
			int x, y = *((int *) pBuffer);
			DWORD dwFlag = STIF_DEFAULT;
			//
			// check if the value from manifest is a hex value:
			// starts with x, or starts with 0x
			//
			LPCTSTR lpSecondChar  = lpsValue + 1;
			if (_T('0') == *lpsValue && (_T('x') == *lpSecondChar || _T('X') == *lpSecondChar))
			{
				dwFlag = STIF_SUPPORT_HEX;
			}

			if (StrToIntEx(lpsValue, dwFlag, &x))
			{
				rc = ( x == y);
			}
		}
		break;
	case REG_SZ:
	case REG_EXPAND_SZ:	// for mult-string, we only compair its first substring
		rc = (lstrcmpi((LPCTSTR)lpsValue, (LPCTSTR) pBuffer) == 0);
		if (!rc)
		{
			//
			// if the ressult is not equal, it's possibly caused by
			// path variables
			//
			// ASSUMPTION: these reg strings are for file path only, so we only
			// handle cases not longer than MAX_PATH.
			//
			TCHAR szRegStr[MAX_PATH], szValStr[MAX_PATH];

			if (dwSize >= MAX_PATH || lstrlen(lpsValue) >= MAX_PATH)
			{
				break;
			}

			if (SUCCEEDED(ExpandFilePath(lpsValue, szValStr, sizeof(szValStr)/sizeof(szValStr[0]))))
			{
				//
				// if we can expand the given sub-string,
				// then try to expand the reg string if QueryRegValue says
				// this string is expandable. Otherwise, use the
				// string retrieved only.
				//
				if (REG_EXPAND_SZ == dwType)
				{
					ExpandFilePath((LPCTSTR)pBuffer, szRegStr, sizeof(szRegStr)/sizeof(szRegStr[0]));
				}
				else
				{
					
					
					hr=StringCchCopyEx(szRegStr,ARRAYSIZE(szRegStr),(LPTSTR) pBuffer,NULL,NULL,MISTSAFE_STRING_FLAGS);
					if(FAILED(hr)) break;

				}

				//
				// compare in expanded mode
				//
				rc = (lstrcmpi((LPCTSTR)szRegStr, szValStr) == 0);
			}
		}
		break;

	case REG_MULTI_SZ:
		{
			TCHAR szRegStr[MAX_PATH], szValStr[MAX_PATH];

			szValStr[0] = '\0';
			lpCurStr = (LPCTSTR)pBuffer;
			//
			// try to match each SZ in this multi sz.
			//
			do
			{
				//
				// see if the value contains the substring passed in
				//
				rc = (lstrcmpi((LPCTSTR)lpsValue, (LPCTSTR)pBuffer) == 0);

				//
				// if not found, it's possibly caused by
				// path variable or environment variable embedded
				//
				if (!rc && _T('\0') == szValStr[0])
				{
					if (FAILED(ExpandFilePath(lpsValue, szValStr, sizeof(szValStr)/sizeof(szValStr[0]))))
					{
						szValStr[0] = '\0';
					}
				}

				//
				// compare expanded XML str with current reg str expanded
				// since this is REG_MULTI_SZ type, we have no way to tell
				// if this SZ inside MULTI_SZ is expandable or not, we
				// we will always try to expand it.
				//
				if (!rc && _T('\0') != szValStr[0])
				{
					rc = (SUCCEEDED(ExpandFilePath((LPCTSTR)lpCurStr, szRegStr, sizeof(szRegStr)/sizeof(szRegStr[0])))) &&
							 (lstrcmpi((LPCTSTR)szRegStr, szValStr) == 0);
				}

				if (!rc)
				{
					//
					// move to next string
					//
					lpCurStr += (lstrlen(lpCurStr) + 1);
					if (_T('\0') == *lpCurStr)
					{
						break;	// no more string to read
					}
				}
			} while (!rc); // repeat to next string

		}
		break;
	case REG_QWORD:
		{
			HMODULE hLib = LoadLibraryFromSystemDir(_T("Shlwapi.dll"));
			if (hLib)
			{
#if defined(UNICODE) || defined(_UNICODE)
				PFN_StrToInt64Ex pfnStrToInt64Ex = (PFN_StrToInt64Ex) GetProcAddress(hLib, "StrToInt64ExW");
#else
				PFN_StrToInt64Ex pfnStrToInt64Ex = (PFN_StrToInt64Ex) GetProcAddress(hLib, "StrToInt64ExA");
#endif
				if (pfnStrToInt64Ex)
				{
					LONGLONG llNum;
					rc = (pfnStrToInt64Ex((LPCTSTR)lpsValue, STIF_DEFAULT, &llNum) &&
						  (llNum == (LONGLONG)pBuffer));
				}
				FreeLibrary(hLib);
			} 
		}
		break;
		
	case REG_BINARY:
		rc = (CmpBinaryToString(pBuffer, dwSize, lpsValue) == 0);
		break;
	default:
		rc = FALSE;
	}

CleanUp:
	
	if (hKey)
	{
		RegCloseKey(hKey);
	}

	LOG_Out(_T("Result: %s"), rc ? _T("TRUE") : _T("FALSE"));

	return rc;
}



// ----------------------------------------------------------------------
//
// public function to tell is a reg key has a string type value
// that contains given string
//
// ----------------------------------------------------------------------
BOOL RegKeySubstring(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsSubString	// substring to see if contained in value
)
{
	LOG_Block("RegKeySubstring()");

	HKEY	hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL	rc = FALSE;
	BYTE	btBuffer[REG_BUF_SIZE];
	LPBYTE	pBuffer = btBuffer;	
	LPTSTR	lpCurStr = (LPTSTR) pBuffer;
	DWORD	dwType = 0x0;
	DWORD	dwSize = sizeof(btBuffer);
	DWORD	dwCode = 0x0;
	TCHAR	szRegStr[MAX_PATH];
	TCHAR	szValStr[MAX_PATH];		// buffer for expanding

	USES_MY_MEMORY;

	if (NULL == lpsKeyPath || NULL == lpsSubString)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	LOG_Out(_T("Parameters: (%s, %s, %s)"), lpsKeyPath, lpsValName, lpsSubString);


	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (0 == hRootKey || (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey)))
	{
		goto CleanUp;
	}

	//
	// try to query the value with existing buffer.
	//
	dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, btBuffer, &dwSize);
	if (ERROR_MORE_DATA == dwCode)
	{
		//
		// if found the existing buffer not large enough, 
		// then allocate memory large enough to store the data now
		//
		if (NULL == (pBuffer = (LPBYTE) MemAlloc(dwSize)))
		{
			goto CleanUp;
		}
		lpCurStr = (LPTSTR) pBuffer;
		dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, pBuffer, &dwSize);
	}

	if (ERROR_SUCCESS != dwCode || REG_SZ != dwType && REG_EXPAND_SZ != dwType && REG_MULTI_SZ != dwType)
	{
		goto CleanUp;
	}

	szValStr[0] = _T('\0');

	do
	{
		//
		// see if the value contains the substring passed in
		//
		rc = (StrStrI((LPCTSTR)lpCurStr, lpsSubString) != NULL);

		//
		// if not found, it's possibly caused by
		// path variable or environment variable embedded
		//
		if (!rc && _T('\0') == szValStr[0])
		{
			if (FAILED(ExpandFilePath(lpsSubString, szValStr, sizeof(szValStr)/sizeof(szValStr[0]))))
			{
				break;
			}
			rc = StrStrI((LPCTSTR)szRegStr, szValStr) != NULL;
		}

		if (!rc && _T('\0') != szValStr[0] && (REG_EXPAND_SZ == dwType ))
		{
			//
			// try to expand string from reg if this string is expandable
			//
			rc = (SUCCEEDED(ExpandFilePath((LPCTSTR)lpCurStr, szRegStr, sizeof(szRegStr)/sizeof(szRegStr[0])))) &&
					 (StrStrI((LPCTSTR)szRegStr, szValStr) != NULL);
		
		} // if not found

		if (!rc && REG_MULTI_SZ == dwType)
		{
			//
			// move to next string
			//
			lpCurStr += (lstrlen(lpCurStr) + 1);
			if (_T('\0') == *lpCurStr)
			{
				break;	// no more string to read
			}
		}
	} while (!rc && REG_MULTI_SZ == dwType); // repeat to next string if REG_MULTI_SZ

CleanUp:

	if (hKey)
	{
		RegCloseKey(hKey);
	}
	LOG_Out(_T("Result: %s"), rc ? _T("TRUE") : _T("FALSE"));
	return rc;
}



// ----------------------------------------------------------------------
//
// public function to tell is a reg key has a string type value
// that contains given string
//
// since this is a comparision function, rather than to check existance,
// anything wrong to get the reg version will make the reg having default
// version: 0.0.0.0
//
// ----------------------------------------------------------------------
BOOL RegKeyVersion(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsVersion,		// version in string to compare
	_VER_STATUS CompareVerb	// how to compair
)
{
	LOG_Block("RegKeyVersion()");

	HKEY	hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL	rc = FALSE;
	BYTE	btBuffer[REG_BUF_SIZE];
	LPBYTE	pBuffer = btBuffer;	
	DWORD	dwType = 0x0;
	DWORD	dwSize = sizeof(btBuffer);
	DWORD	dwCode = 0x0;
	FILE_VERSION verReg, verXml;
	int		verCompare;
	HRESULT hr=S_OK;

	USES_IU_CONVERSION;


	if (NULL == lpsKeyPath || NULL == lpsVersion)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	LOG_Out(_T("Parameters: (%s, %s, %s, %d)"), lpsKeyPath, lpsValName, lpsVersion, (int)CompareVerb);

	//
	// initialize the reg version string buffer
	//
	

	//The buffer size of btBuffer is sufficient to hold the source string
	if(FAILED(hr=StringCchCopyEx((LPTSTR)btBuffer,ARRAYSIZE(btBuffer)/sizeof(TCHAR),_T("0.0.0.0"),NULL,NULL,MISTSAFE_STRING_FLAGS)))
	{
		LOG_ErrorMsg(hr);
		return FALSE;

	}
	

	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (0 == hRootKey || (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey)))
	{
		// LOG_ErrorMsg(ERROR_BADKEY); don't log error since we don't know if this key HAS to be there or not
		goto GotVersion;
	}

	//
	// try to query the value with existing buffer.
	//
	dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, btBuffer, &dwSize);
	if (ERROR_MORE_DATA == dwCode)
	{
		//
		// if found the existing buffer not large enough, 
		// then allocate memory large enough to store the data now
		//
		pBuffer = (LPBYTE) MemAlloc(dwSize);
		if (NULL == pBuffer)
		{
			goto GotVersion;
		}
		dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, pBuffer, &dwSize);
	}

	if (ERROR_SUCCESS != dwCode || REG_SZ != dwType)
	{

			
			hr=StringCchCopyEx((LPTSTR)pBuffer,dwSize/sizeof(TCHAR),_T("0.0.0.0"),NULL,NULL,MISTSAFE_STRING_FLAGS);
			if(FAILED(hr))
			{
				LOG_ErrorMsg(hr);
				goto CleanUp;
			}

	}

GotVersion:

	//
	// convert the retrieved reg value to version
	//
	if (!ConvertStringVerToFileVer(T2CA((LPCTSTR) pBuffer), &verReg) ||
		!ConvertStringVerToFileVer(T2CA((LPCTSTR) lpsVersion), &verXml))
	{
		goto CleanUp;
	}

	//
	// maybe we successfully read data from reg, but that data can't be converted
	// into version at all. In this case, we still want to use the default version
	// for comparision
	//
	if (0 > verReg.Major)
	{
		verReg.Major = verReg.Minor = verReg.Build = verReg.Ext = 0;
	}

	//
	// compare version number. if a < b, -1; a > b, +1
	//
	verCompare = CompareFileVersion(verReg, verXml);
	switch (CompareVerb)
	{
	case DETX_LOWER:
        //
        // if reg key version less than XML version
        //
		rc = (verCompare < 0);
		break;
	case DETX_LOWER_OR_EQUAL:
        //
        // if reg key version less than  or equal to XML version
        //
		rc = (verCompare <= 0);
		break;
	case DETX_SAME:
        //
        // if reg key version same as XML version
        //
		rc = (0 == verCompare);
		break;
	case DETX_HIGHER_OR_EQUAL:
        //
        // if reg key version higher than  or equal to XML version
        //
		rc = (verCompare >= 0);
		break;
	case DETX_HIGHER:
        //
        // if reg key versiong higher than  XML version
        //
		rc = (verCompare > 0);
		break;
	default:
		//
		// should never happen
		//
		rc = FALSE;
		break;
	}

CleanUp:

	if (hKey)
	{
		RegCloseKey(hKey);
	}
	LOG_Out(_T("Result: %s"), rc ? _T("TRUE") : _T("FALSE"));
	return rc;
}




// ----------------------------------------------------------------------------------
//
// public function to find out the file path based on reg
//	assumption: 
//		lpsFilePath points to a buffer at least MAX_PATH long.
//
// ----------------------------------------------------------------------------------
BOOL GetFilePathFromReg(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR	lpsValName,		// optional value name
	LPCTSTR	lpsRelativePath,// optional additonal relative path to add to path in reg
	LPCTSTR	lpsFileName,	// optional file name to append to path
	LPTSTR	lpsFilePath
)
{
	LOG_Block("GetFilePathFromReg()");

	HKEY	hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL	rc = FALSE;
	BYTE	btBuffer[REG_BUF_SIZE];
	LPBYTE	pBuffer = btBuffer;	
	DWORD	dwType = 0x0;
	DWORD	dwSize = sizeof(btBuffer);
	DWORD	dwCode = 0x0;
	FILE_VERSION verReg, verXml;
	int		verCompare;
	HRESULT hr=S_OK;

	USES_IU_CONVERSION;

	if (NULL == lpsKeyPath || NULL == lpsFilePath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	//
	// initialize file path
	//
	*lpsFilePath = '\0';

	LOG_Out(_T("Parameters: (%s, %s, %s, %s)"), lpsKeyPath, lpsValName, lpsRelativePath, lpsFileName);

	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (0 == hRootKey || (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey)))
	{
		// LOG_ErrorMsg(ERROR_BADKEY); --- key probably not required to exist!
		goto CleanUp;
	}

	//
	// try to query the value with existing buffer.
	//
	dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, btBuffer, &dwSize);
	if (ERROR_MORE_DATA == dwCode)
	{
		//
		// if found the existing buffer not large enough, 
		// then allocate memory large enough to store the data now
		//
		if (NULL == (pBuffer = (LPBYTE) MemAlloc(dwSize + sizeof(TCHAR))))
		{
			goto CleanUp;
		}
		dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, pBuffer, &dwSize);
	}

	if (ERROR_SUCCESS != dwCode || REG_SZ != dwType)
	{
		LOG_ErrorMsg(ERROR_BADKEY);
		goto CleanUp;
	}

	//
	// validate the to-be-combined path can fit into the buffer
	//
	if (lstrlen(lpsRelativePath) + lstrlen(lpsFileName) + dwSize/sizeof(TCHAR) >= MAX_PATH)
	{
		LOG_ErrorMsg(ERROR_BUFFER_OVERFLOW);
		goto CleanUp;
	}

	//
	// combile the path with optional relative path and file name
	//

	//The size of lpsFilePath is not available for using Safe String Functions

	
	hr=StringCchCopyEx(lpsFilePath,MAX_PATH,(LPCTSTR) pBuffer,NULL,NULL,MISTSAFE_STRING_FLAGS);
	if ( SUCCEEDED(hr) && (NULL == lpsRelativePath || SUCCEEDED(PathCchAppend(lpsFilePath,MAX_PATH,lpsRelativePath)) ) && (NULL == lpsFileName || SUCCEEDED(PathCchAppend(lpsFilePath,MAX_PATH,lpsFileName)) ))
	{
		rc = TRUE;
	}

CleanUp:

	if (hKey)
	{
		RegCloseKey(hKey);
	}
	if (!rc)
	{
		//
		// make sure the buffer is set to empty string if error
		//
		*lpsFilePath = _T('\0');
	}
	else
	{
		LOG_Out(_T("Found path: %s"), lpsFilePath);
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\redirectutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   RedirectUtil.cpp
//	Author:	Charles Ma, 9/19/2001
//
//	Revision History:
//
//
//
//  Description:
//
//      Helper function(s) for handling server redirect
//		Can be shared by IU control and other Windows Update components
//
//=======================================================================

#include <iucommon.h>
#include <logging.h>
#include <stringutil.h>
#include <fileutil.h>	// for using function GetIndustryUpdateDirectory()
#include <download.h>
#include <trust.h>
#include <memutil.h>

#include <wininet.h>	// for define of INTERNET_MAX_URL_LENGTH

#include <RedirectUtil.h>
#include <MISTSAFE.h>
#include <wusafefn.h>


const TCHAR IDENTNEWCABDIR[] = _T("temp");	// temp name for newly downloaded cab
													// we need to validate time before we take it as a good iuident.cab
const TCHAR IDENTCAB[] = _T("iuident.cab");
const TCHAR REDIRECT_SECTION[] = _T("redirect");


//
// private structure, which defines data used to 
// determine server redirect key
//
typedef struct OS_VER_FOR_REDIRECT 
{
	DWORD dwMajor;
	DWORD dwMinor;
	DWORD dwBuildNumber;
	DWORD dwSPMajor;
	DWORD dwSPMinor;
} OSVerForRedirect, *pOSVerForRedirect;

const OSVerForRedirect MAX_VERSION = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};



//-----------------------------------------------------------------------
//
// private helper function:
//	read data in string, convert it to structure
//	string ends with \0 or "-"
//
//-----------------------------------------------------------------------
HRESULT ConvertStrToOSVer(LPCTSTR pszVer, pOSVerForRedirect pOSVer)
{
	int Numbers[5] = {0, 0, 0, 0, 0}; // default version component val is 0
	int n = 0;

	if (NULL == pOSVer || NULL == pszVer)
	{
		return E_INVALIDARG;
	}

	//
	// recognizing numbers from string can be done in two ways:
	// 1. more acceptive: stop if known ending char, otherwise continue
	// 2. more rejective: stop if anything not known.
	// we use the first way
	//
	while ('\0' != *pszVer && 
		   _T('-') != *pszVer &&
		   _T('=') != *pszVer &&
		   n < sizeof(Numbers)/sizeof(int))
	{
		if (_T('.') == *pszVer)
		{
			n++;
		}
		else if (_T('0') <= *pszVer && *pszVer <= _T('9'))
		{
			//
			// if this is a digit, add to the current ver component
			//
			Numbers[n] = Numbers[n]*10 + (*pszVer - _T('0'));
		}
		// 
		// else - for any other chars, skip it and continue,
		// therefore we are using a very acceptive algorithm
		//

		pszVer++;
	}

	pOSVer->dwMajor = Numbers[0];
	pOSVer->dwMinor = Numbers[1];
	pOSVer->dwBuildNumber = Numbers[2];
	pOSVer->dwSPMajor = Numbers[3];
	pOSVer->dwSPMinor = Numbers[4];

	return S_OK;
}



//-----------------------------------------------------------------------
//
// Private helper function: retrieve version info from current OS
//
//-----------------------------------------------------------------------
HRESULT GetCurrentOSVerInfo(pOSVerForRedirect pOSVer)
{
	OSVERSIONINFO osVer;
	OSVERSIONINFOEX osVerEx;

	osVer.dwOSVersionInfoSize = sizeof(osVer);
	osVerEx.dwOSVersionInfoSize = sizeof(osVerEx);

	if (NULL == pOSVer)
	{
		return E_INVALIDARG;
	}

	//
	// first, get basic version info
	//
	if (0 == GetVersionEx(&osVer))
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	//
	// check what kinf of platform is this?
	//
	if (VER_PLATFORM_WIN32_WINDOWS == osVer.dwPlatformId || 
		(VER_PLATFORM_WIN32_NT == osVer.dwPlatformId && osVer.dwMajorVersion < 5) )
	{
		//
		// if this is Win9X or NT4 and below, then OSVERSIONINFO is the only thing we can get
		// unless we hard code all those SP strings here.
		// Since Windows Update team has no intention to set different site
		// for different releases and SPs of these down level OS, we simply put 0.0 for 
		// SP components.
		//
		osVerEx.dwMajorVersion = osVer.dwMajorVersion;
		osVerEx.dwMinorVersion = osVer.dwMinorVersion;
		osVerEx.dwBuildNumber = osVer.dwBuildNumber;
		osVerEx.wServicePackMajor = osVerEx.wServicePackMinor = 0x0;
	}
	else
	{
		//
		// for later OS, we can get OSVERSIONINFOEX data, which contains SP data
		//
		if (0 == GetVersionEx((LPOSVERSIONINFO)&osVerEx))
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}

	pOSVer->dwMajor = osVerEx.dwMajorVersion;
	pOSVer->dwMinor = osVerEx.dwMinorVersion;
	pOSVer->dwBuildNumber = osVerEx.dwBuildNumber;
	pOSVer->dwSPMajor = osVerEx.wServicePackMajor;
	pOSVer->dwSPMinor = osVerEx.wServicePackMinor;

	return S_OK;

}


//-----------------------------------------------------------------------
//
// Private helper function: to tell one given ver structure is between
// two known ver structures or not.
//
// when compare, pass all 3 structures in ptr. Any NULL ptr will return FALSE
//
//-----------------------------------------------------------------------
BOOL IsVerInRange(pOSVerForRedirect pVerToBeTested, 
				 const pOSVerForRedirect pVerRangeStart,
				 const pOSVerForRedirect pVerRangeEnd)
{
	if (NULL == pVerToBeTested || 
		NULL == pVerRangeStart ||
		NULL == pVerRangeEnd)
	{
		return FALSE;
	}

	return ((pVerRangeStart->dwMajor < pVerToBeTested->dwMajor &&		// if major in the range
			 pVerToBeTested->dwMajor < pVerRangeEnd->dwMajor) ||
			((pVerRangeStart->dwMajor == pVerToBeTested->dwMajor ||		// or major equal
			  pVerRangeEnd->dwMajor == pVerToBeTested->dwMajor) &&	
			  ((pVerRangeStart->dwMinor < pVerToBeTested->dwMinor &&	// and minor in the range 
			    pVerToBeTested->dwMinor < pVerRangeEnd->dwMinor) ||
			    ((pVerRangeStart->dwMinor == pVerToBeTested->dwMinor ||		// or minor equal too
			      pVerToBeTested->dwMinor == pVerRangeEnd->dwMinor) &&
			      ((pVerRangeStart->dwBuildNumber < pVerToBeTested->dwBuildNumber && // and build number in the range
			        pVerToBeTested->dwBuildNumber < pVerRangeEnd->dwBuildNumber) ||
			        ((pVerRangeStart->dwBuildNumber == pVerToBeTested->dwBuildNumber || // or build number equal too
			          pVerToBeTested->dwBuildNumber == pVerRangeEnd->dwBuildNumber) &&
			          ((pVerRangeStart->dwSPMajor < pVerToBeTested->dwSPMajor &&		// and service pack major within
			            pVerToBeTested->dwSPMajor < pVerRangeEnd->dwSPMajor) ||
			            ((pVerRangeStart->dwSPMajor == pVerToBeTested->dwSPMajor ||		// or spmajor equal too
			              pVerToBeTested->dwSPMajor == pVerRangeEnd->dwSPMajor) &&
			              ((pVerRangeStart->dwSPMinor <= pVerToBeTested->dwSPMinor &&	// and sp minor within
			                pVerToBeTested->dwSPMinor <= pVerRangeEnd->dwSPMinor) 
						  )
						)
					  )
					)
				  )
				)
			  )
			));

}


//-----------------------------------------------------------------------
// 
// GetRedirectServerUrl() 
//	Search the [redirect] section of the given init file for the base
//  server URL corresponding to the OS version.
//
// Parameters:
//		pcszInitFile - file name (including path) of the ini file.
//						if this paramater is NULL or empty string,
//						then it's assumed IUident.txt file.
//		lpszNewUrl - point to a buffer to receive redirect server url, if found
//		nBufSize - size of pointed buffer, in number of chars
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - the redirect server url is found and been put into pszBuffer
//		S_FALSE - no redirect server url defined for this OS. 
//		other - error code
//
// Comments:
//		Expected section in IUIDENT has the following format;
//		Section name: [redirect]
//		Its entries should be defined according to GetINIValueByOSVer().
// 
//-----------------------------------------------------------------------

HRESULT GetRedirectServerUrl(
			LPCTSTR pcszInitFile, // path of file name.
			LPTSTR lpszNewUrl,	// points to a buffer to receive new server url 
			int nBufSize		// size of buffer, in chars
)
{
	LOG_Block("GetRedirectServerUrl()");
	
	return GetINIValueByOSVer(
				pcszInitFile,
				REDIRECT_SECTION,
				lpszNewUrl,
				nBufSize);
}


//-----------------------------------------------------------------------
// 
// GetINIValueByOSVer() 
//	Search the specified section of the given init file for
//  the value corresponding to the version of the OS.
//
// Parameters:
//		pcszInitFile - file name (including path) of the ini file.
//						if this paramater is NULL or empty string,
//						then it's assumed IUident.txt file.
//		pcszSection - section name which the key is under
//		lpszValue - point to a buffer to receive the entry value, if found
//		nBufSize - size of pointed buffer, in number of chars
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - the redirect server url is found and been put into pszBuffer
//		S_FALSE - no value defined for this OS. 
//		other - error code
//
// Comments:
//		Expected section in IUIDENT has the following format;
//		this section contains zero or more entries, each entry has format:
//		<beginVersionRange>-<endVersionRange>=<redirect server url>
//		where:
//			<beginVersionRange> ::= <VersionRangeBound>
//			<endVersionRange> ::= <VersionRangeBound>
//			<VersionRangeBound> ::= EMPTY | Major[.Minor[.Build[.ServicePackMajor[.ServicePackMinor]]]]
//			<redirect server url>=http://blahblah....
//		an empty version range bound means boundless.
//		a missing version component at end of a version data string means default value 0.
//		(e.g., 5.2 = 5.2.0.0.0)
// 
//-----------------------------------------------------------------------

HRESULT GetINIValueByOSVer(
			LPCTSTR pcszInitFile, // path of file name.
			LPCTSTR pcszSection, // section name
			LPTSTR lpszValue,	// points to a buffer to receive new server url 
			int nBufSize)		// size of buffer, in chars
{
	LOG_Block("GetINIValueByOSVer");

	HRESULT hr = S_OK;
	TCHAR szInitFile[MAX_PATH];
	LPTSTR pszBuffer = NULL;
	LPTSTR pszCurrentChar = NULL;
	LPCTSTR pszDash = NULL;
	DWORD dwRet;
	DWORD dwSize = INTERNET_MAX_URL_LENGTH;
	
	if (NULL == pcszSection || NULL == lpszValue || nBufSize < 1)
	{
		return E_INVALIDARG;
	}


	OSVerForRedirect osCurrent, osBegin, osEnd;

	CleanUpIfFailedAndSetHrMsg(GetCurrentOSVerInfo(&osCurrent));

	pszBuffer = (LPTSTR) malloc(dwSize * sizeof(TCHAR));
	CleanUpFailedAllocSetHrMsg(pszBuffer);

	//
	// find out what's the right init file to search
	//
	if (NULL == pcszInitFile ||
		_T('\0') == *pcszInitFile)
	{
		//
		// if not specified, use iuident.txt
		//
		GetIndustryUpdateDirectory(pszBuffer);
        if (FAILED(hr=PathCchCombine(szInitFile,ARRAYSIZE(szInitFile), pszBuffer, IDENTTXT)) )
		{
			goto CleanUp;
		}
	}
	else
	{
		lstrcpyn(szInitFile, pcszInitFile, ARRAYSIZE(szInitFile));
	}

	LOG_Out(_T("Init file to retrieve redirect data: %s"), szInitFile);

	//
	// read in all key names
	//
	if (GetPrivateProfileString(
			pcszSection, 
			NULL, 
			_T(""), 
			pszBuffer, 
			dwSize, 
			szInitFile) == dwSize-2)
	{
		//
		// buffer too small? assume bad ident. stop here
		//
		hr = S_FALSE;
		goto CleanUp;
	}

	//
	// loop through each key
	//
	pszCurrentChar = pszBuffer;
	while (_T('\0') != *pszCurrentChar)
	{
		//
		// for the current key, we first try to make sure it's in the right format:
		// there should be a dash "-". If no, then assume this key is bad and we try to 
		// skip it.
		//
		pszDash = MyStrChr(pszCurrentChar, _T('-'));

		if (NULL != pszDash)
		{
			//
			// get lower bound of ver range. If string starts with "-",
			// then the returned ver would be 0.0.0.0.0
			//
			ConvertStrToOSVer(pszCurrentChar, &osBegin);

			//
			// get upper bound of ver range
			//
			pszDash++;
			ConvertStrToOSVer(pszDash, &osEnd);
			if (0x0 == osEnd.dwMajor &&
				0x0 == osEnd.dwMinor &&
				0x0 == osEnd.dwBuildNumber &&
				0x0 == osEnd.dwSPMajor && 
				0x0 == osEnd.dwSPMinor)
			{
				//
				// if 0.0.0.0.0. it means nothing after "-".
				// assume the upper bound is unlimited
				//
				osEnd = MAX_VERSION;
			}

			if (IsVerInRange(&osCurrent, &osBegin, &osEnd))
			{
				//
				// the current OS falls in this range.
				// we read the redirect URL
				//
				if (GetPrivateProfileString(
									pcszSection, 
									pszCurrentChar,		// use current str as key
									_T(""), 
									lpszValue, 
									nBufSize, 
									szInitFile) == nBufSize - 1)
				{
					Win32MsgSetHrGotoCleanup(ERROR_INSUFFICIENT_BUFFER);
				}

				hr = S_OK;
				goto CleanUp;
			}
		}

		//
		// move to next string
		//
		pszCurrentChar += lstrlen(pszCurrentChar) + 1;
	}

	//
	// if come to here, it means no suitable version range found.
	//
	*lpszValue = _T('\0');
	hr = S_FALSE;
	
CleanUp:
	SafeFree(pszBuffer);
	return hr;
}


//-----------------------------------------------------------------------
// 
// DownloadCab() 
//	download a cab file of specific name from a base web address.  The
//  file will be saved locally, with file trust verified and extracted to
//  a specific folder.
//
// Parameters:
//		hQuitEvent - the event handle to cancel this operation
//		ptszCabName - the file name of the cab file (eg. iuident.cab)
//		ptszBaseUrl - the base web address to download the cab file
//		ptszExtractDir - the local dir to save the cab file and those extracted from it
//		dwFlags - the set of flags to be passed to DownloadFileLite()
//		fExtractFiles (default as TRUE) - extract files
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - iuident.cab was successfully downloaded into the specified location
//		other - error code
//
//-----------------------------------------------------------------------

HRESULT DownloadCab(
			HANDLE hQuitEvent,
			LPCTSTR ptszCabName,
			LPCTSTR ptszBaseUrl,
			LPCTSTR ptszExtractDir,
			DWORD dwFlags,
			BOOL fExtractFiles)
{
	LOG_Block("DownloadCab");

    LPTSTR ptszFullCabUrl;

	if (NULL == ptszCabName ||
		NULL == ptszBaseUrl ||
		_T('\0') == *ptszBaseUrl ||
		NULL == ptszExtractDir ||
		_T('\0') == *ptszExtractDir)
	{
		return E_INVALIDARG;
	}

	if (NULL == (ptszFullCabUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)))
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_OK;
    TCHAR tszTarget[MAX_PATH+1];
	int nBaseUrlLen = lstrlen(ptszBaseUrl);

	if (SUCCEEDED(PathCchCombine(tszTarget,ARRAYSIZE(tszTarget),ptszExtractDir, ptszCabName)) &&
		INTERNET_MAX_URL_LENGTH > nBaseUrlLen)
	{
		
		hr=StringCchCopyEx(ptszFullCabUrl,INTERNET_MAX_URL_LENGTH,ptszBaseUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
		CleanUpIfFailedAndMsg(hr);


		if (_T('/') != ptszFullCabUrl[nBaseUrlLen-1])
		{
			ptszFullCabUrl[nBaseUrlLen++] = _T('/');
		}

		if (INTERNET_MAX_URL_LENGTH > nBaseUrlLen + lstrlen(ptszCabName))
		{
	
			//
			// changes made by charlma 4/24/2002: add a safegard:
			//
			// first, make sure that if the local file exist, then it must be trusted. Otherwise,
			// it will block the download if the size/timestamp match the server file.
			//
			if (FileExists(tszTarget))
			{
				hr = VerifyFileTrust(tszTarget, NULL, ReadWUPolicyShowTrustUI());
				if (FAILED(hr))
				{
					(void)DeleteFile(tszTarget);
				}
			}

			hr=StringCchCopyEx(ptszFullCabUrl+ nBaseUrlLen,INTERNET_MAX_URL_LENGTH-nBaseUrlLen,ptszCabName,NULL,NULL,MISTSAFE_STRING_FLAGS);
			CleanUpIfFailedAndMsg(hr);
	

//			if (SUCCEEDED(hr = DownloadFile(
//								ptszFullCabUrl,			// full http url
//								ptszBaseUrl,
//								tszTarget,		// optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
//								NULL,
//								&hQuitEvent,		// quit event
//								1,
//								NULL,
//								NULL,
//								dwFlags))) //dwFlags | WUDF_ALLOWWINHTTPONLY)))
			if (SUCCEEDED(hr = DownloadFileLite(
								ptszFullCabUrl,			// full http url
								tszTarget,		// optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
								hQuitEvent,		// quit event
								dwFlags))) //dwFlags | WUDF_ALLOWWINHTTPONLY)))
			{
				// need to use the VerifyFile function, not CheckWinTrust (WU bug # 12251)
				if (SUCCEEDED(hr = VerifyFileTrust(tszTarget, NULL, ReadWUPolicyShowTrustUI())))
				{
					if (WAIT_TIMEOUT != WaitForSingleObject(hQuitEvent, 0))
					{
						hr = E_ABORT;
						LOG_ErrorMsg(hr);
					}
					else 
					{
						//
						// changed by charlma for bug 602435:
						// added new flag to tell if we should extract files. default as TRUE
						//
						if (fExtractFiles)
						{
							if (IUExtractFiles(tszTarget, ptszExtractDir))
							{
								hr = S_OK;
								if (WAIT_TIMEOUT != WaitForSingleObject(hQuitEvent, 0))
								{
									hr = E_ABORT;
									LOG_ErrorMsg(hr);
								}
							}
							else
							{
								hr = E_FAIL;
								LOG_Error(_T("failed to extract %s"), tszTarget);
							}
						}
					}
				}
				else
				{
					LOG_Error(_T("VerifyFileTrust(\"%s\", NULL, ReadWUPolicyShowTrustUI()) failed (%#lx)"), tszTarget, hr);
					DeleteFile(tszTarget);
				}
			}
#ifdef DBG
			else
			{
				LOG_Error(_T("DownloadFileLite(\"%s\", \"%s\", xxx, %#lx) failed (%#lx)."), ptszFullCabUrl, tszTarget, dwFlags, hr);
			}
#endif
		}
		else
		{
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}


CleanUp:

	free(ptszFullCabUrl);
    return hr;
}


//-----------------------------------------------------------------------
//
// ValidateNewlyDownloadedCab()
//
// This is a new helper function to validate the newly downloaded iuident.cab
// 
// Description:
//	The newly downloaded iuident.cab will be saved as IUIDENTNEWCAB
//	then this function will do the following validation:
//	(1) if local iuident.cab not exist, then the new one is valid
//	(2) otherwise, extract iuident.txt from both cabs, make sure
//		the one from new cab has later date then the one from existing cab.
//	(3) If not valid, then delete the new cab.
//
//	Return: 
//		S_OK: validated, existing cab been replaced with the new one
//		S_FALSE: not valid, new cab deleted. 
//		error: any error encountered during validation
//
//-----------------------------------------------------------------------
HRESULT ValidateNewlyDownloadedCab(LPCTSTR lpszNewIdentCab)
{
	HRESULT	hr = S_OK;
	BOOL	fRet;
	DWORD	dwErr;
	TCHAR	szExistingIdent[MAX_PATH + 1];
	TCHAR	szIUDir[MAX_PATH + 1];

	HANDLE	hFile = INVALID_HANDLE_VALUE;
	FILETIME ft1, ft2;


	LOG_Block("ValidateNewlyDownloadedCab()");

	if (NULL == lpszNewIdentCab)
	{
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		return hr;
	}

	if (!FileExists(lpszNewIdentCab))
	{
		LOG_ErrorMsg(ERROR_PATH_NOT_FOUND);
		hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
		return hr;
	}

	//
	// create existing cab path
	//
	fRet = GetWUDirectory(szIUDir, ARRAYSIZE(szIUDir), TRUE);
	CleanUpIfFalseAndSetHrMsg(!fRet, HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));

	hr = PathCchCombine(szExistingIdent, ARRAYSIZE(szExistingIdent), szIUDir, IDENTCAB);
	CleanUpIfFailedAndMsg(hr);

	//
	// if original ident not exist, we will assume the new one is valid, 
	// since we don't have anything else to validate against!
	//
	if (!FileExists(szExistingIdent))
	{
		LOG_Internet(_T("%s not exist. Will use new cab"), szExistingIdent);
		hr = S_OK;
		goto CleanUp;
	}

	if (!IUExtractFiles(szExistingIdent, szIUDir, IDENTTXT))
	{
		LOG_Internet(_T("Error 0x%x when extracting ident.txt from %s. Use new one"), GetLastError(), szExistingIdent);
		hr = S_OK;
		goto CleanUp;
	}

	//
	// get the time stamp from the extacted files: we borrow szExistingIdent buffer
	// to contstruct the file name of iuident.txt
	//
	hr = PathCchCombine(szExistingIdent, ARRAYSIZE(szExistingIdent), szIUDir, IDENTTXT);
	CleanUpIfFailedAndMsg(hr);
	
	//
	// open file for retrieving modified time
	//
	hFile = CreateFile(szExistingIdent, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		LOG_ErrorMsg(GetLastError());
		hr = S_OK;	// use new cab
		goto CleanUp;
	}

	if (!GetFileTime(hFile, NULL, NULL, &ft1))
	{
		LOG_ErrorMsg(GetLastError());
		hr = S_OK;	// use new cab
		goto CleanUp;
	}

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	DeleteFile(szExistingIdent);

	//
	// extract files from new cab
	//
	if (!IUExtractFiles(lpszNewIdentCab, szIUDir, IDENTTXT))
	{
		dwErr = GetLastError();
		LOG_Internet(_T("Error 0x%x when extracting ident.txt from %s"), dwErr, lpszNewIdentCab);
		hr = HRESULT_FROM_WIN32(dwErr);
		goto CleanUp;
	}

	//
	// open file for retrieving modified time
	//
	hFile = CreateFile(szExistingIdent, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
	{
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		hr = HRESULT_FROM_WIN32(dwErr);
		goto CleanUp;
	}

	if (!GetFileTime(hFile, NULL, NULL, &ft2))
	{
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		hr = HRESULT_FROM_WIN32(dwErr);
		goto CleanUp;
	}

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	DeleteFile(szExistingIdent);

	//
	// compare the two values: if ft2 (from new cab) is later than ft1 (from old cab)
	// then S_OK, otherwise, S_FALSE
	//
	hr = ((ft2.dwHighDateTime  > ft1.dwHighDateTime) ||
		  ((ft2.dwHighDateTime == ft1.dwHighDateTime) && 
		  (ft2.dwLowDateTime > ft1.dwLowDateTime))) 
		  ? S_OK : S_FALSE;


CleanUp:

	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
	}

	if (S_OK == hr)
	{
		//
		// validated. copy the new cab to existing cab name
		//
		(void)PathCchCombine(szExistingIdent, ARRAYSIZE(szExistingIdent), szIUDir, IDENTCAB);
		if (CopyFile(lpszNewIdentCab, szExistingIdent, FALSE))
		{
			LOG_Internet(_T("New cab is better, copy to existing one, if any"));
		}
		else
		{
			dwErr = GetLastError();
			LOG_ErrorMsg(dwErr);
			hr = HRESULT_FROM_WIN32(dwErr);
		}
	}
	else
	{
		//
		// if not to use the new cab, we delete it.
		//
		LOG_Internet(_T("Error (0x%x) or new iuident.cab not better than old one."), hr);
		if ((ft2.dwHighDateTime != ft1.dwHighDateTime) || (ft2.dwLowDateTime != ft1.dwLowDateTime))
		{
			LOG_Internet(_T("Found bad iuident.cab downloaded! Try to delete it."));
			if (!DeleteFile(lpszNewIdentCab))
			{
				LOG_ErrorMsg(GetLastError());
			}
		}
	}

	//
	// clean up the extracted ident
	//
	if (SUCCEEDED(PathCchCombine(szExistingIdent, ARRAYSIZE(szExistingIdent), szIUDir, IDENTTXT)))
	{
		DeleteFile(szExistingIdent);
	}
	return hr;

}


//-----------------------------------------------------------------------
// 
// DownloadIUIdent() 
//	download iuident.cab from a specific location, if provided.
//	Otherwise get it from where the WUServer registry value points to.
//  Either case, it will handle ident redirection.
//
// Parameters:
//		hQuitEvent - the event handle to cancel this operation
//		ptszBaseUrl - the initial base URL for iuident.cab, must be no bigger than
//					  (INTERNET_MAX_URL_LENGTH) TCHARs.  Otherwise use
//					  WUServer entry from policy.  If entry not found,
//					  use "http://windowsupdate.microsoft.com/v4"
//		ptszFileCacheDir - the local base path to store the iuident.cab and
//						   the files extracted from it
//		dwFlags - the set of flags used by DownloadCab()
//		fIdentFromPolicy - tell if this is corpwu use. It has these impacts:
//					TRUE:	(1) no iuident.txt timestamp validation will be done by
//							comparing the newly downloaded cab and existing one.
//							(2) if download fail and ident cab exist and valid,
//							we will verify trust and extract iuident to use.
//					FALSE:	will validate newly downloaded cab against existing one
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - iuident.cab was successfully downloaded into the specified location
//		other - error code
//
//-----------------------------------------------------------------------

HRESULT DownloadIUIdent(
			HANDLE hQuitEvent,
			LPCTSTR ptszBaseUrl,
			LPTSTR ptszFileCacheDir,
			DWORD dwFlags,
			BOOL fIdentFromPolicy
			)
{
	LOG_Block("DownloadIUIdent");

	HRESULT hr = S_OK;
	TCHAR	tszTargetPath[MAX_PATH + 1];
	LPTSTR	ptszIdentBaseUrl = NULL;
	BOOL	fVerifyTempDir = TRUE;
	DWORD	dwErr = 0;

	USES_MY_MEMORY;

	if (NULL == ptszBaseUrl ||
		NULL == ptszFileCacheDir)
	{
		return E_INVALIDARG;
	}

	ptszIdentBaseUrl = (LPTSTR) MemAlloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH);
	CleanUpFailedAllocSetHrMsg(ptszIdentBaseUrl);

	hr = StringCchCopyEx(ptszIdentBaseUrl, INTERNET_MAX_URL_LENGTH, ptszBaseUrl, NULL,NULL,MISTSAFE_STRING_FLAGS);
	CleanUpIfFailedAndMsg(hr);

	int iRedirectCounter = 3;	// any non-negative value; to catch circular reference

	while (0 <= iRedirectCounter)
	{
		if (fIdentFromPolicy)
		{
			//
			// for corpwu case, always download it to overwrite the original
			// no iuident.txt timestamp validation needed.
			//
			hr = StringCchCopyEx(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, NULL,NULL,MISTSAFE_STRING_FLAGS);
			CleanUpIfFailedAndMsg(hr);
		}
		else
		{
			//
			// constrcut the temp local path for consumer case: download it to v4\temp
			//
			hr = PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTNEWCABDIR);
			CleanUpIfFailedAndMsg(hr);
			if (fVerifyTempDir)
			{
				if (!CreateNestedDirectory(tszTargetPath))
				{
					dwErr = GetLastError();
					LOG_ErrorMsg(dwErr);
					hr = HRESULT_FROM_WIN32(dwErr);
					goto CleanUp;
				}
				fVerifyTempDir = FALSE;
			}
		}
			
		
		hr = DownloadCab(
						hQuitEvent,
						IDENTCAB,
						ptszIdentBaseUrl,
						tszTargetPath,
						dwFlags,
						FALSE);	// download cab without extracting it.

		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);

            // Bad Case, couldn't download the iuident.. iuident is needed for security..
#if defined(UNICODE) || defined(_UNICODE)
			LogError(hr, "Failed to download %ls from %ls to %ls", IDENTCAB, ptszIdentBaseUrl, tszTargetPath);
#else
			LogError(hr, "Failed to download %s from %s to %s", IDENTCAB, ptszIdentBaseUrl, tszTargetPath);
#endif
			//
			// construct original path. 
			//
			HRESULT hr1 = PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTCAB);
			if (FAILED(hr1))
			{
				LOG_ErrorMsg(hr1);
				goto CleanUp;
			}

			if (fIdentFromPolicy && FileExists(tszTargetPath))
			{
				//
				// charlma: moved the fix from selfupd.cpp to here:
				//

				// bug 580808 CorpWU: IU: If corpwu server is not available when user navigates to web site, 
				// website displays x80072ee7 error and cannot be used.
				// Fix:
				// if corpwu policy is set but the corpwu server is unavailable,
				// we fail over to the local iuident.
				// This is true for both corpwu client and site client.
				hr = S_OK;
#if defined(DBG)
				LOG_Out(_T("Ignore above error, use local copy of %s from %s"), IDENTCAB, ptszFileCacheDir);
#endif
#if defined(UNICODE) || defined(_UNICODE)
				LogMessage("Ignore above error, use local copy of %ls from %ls", IDENTCAB, ptszFileCacheDir);
#else
				LogMessage("Ignore above error, use local copy of %s from %s", IDENTCAB, ptszFileCacheDir);
#endif
			}
			else
			{
				//
				// if this is the consumer case, or iuident.cab not exist, can't continue
				//
				break;
			}
		}
		else
		{
#if defined(UNICODE) || defined(_UNICODE)
			LogMessage("Downloaded %ls from %ls to %ls", IDENTCAB, ptszIdentBaseUrl, ptszFileCacheDir);
#else
			LogMessage("Downloaded %s from %s to %s", IDENTCAB, ptszIdentBaseUrl, ptszFileCacheDir);
#endif
			//
			// added by charlma for bug 602435 fix: verify the signed time stamp of
			// the downloaded cab is newer than the local one.
			//
			if (!fIdentFromPolicy)
			{
				//
				// if the newly downloaded cab is newer, and nothing bad happen (SUCCEEDED(hr)), we
				// we'll have an iuident.cab there, new or old.
				//
				(void) PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTNEWCABDIR);
				hr = PathCchAppend(tszTargetPath, ARRAYSIZE(tszTargetPath), IDENTCAB);
				CleanUpIfFailedAndMsg(hr);

				hr = ValidateNewlyDownloadedCab(tszTargetPath);

				if (FAILED(hr))
				{
					break;
				}

				//
				// if we need to use old one, it's fine. so we correct S_FALSE to S_OK;
				//
				hr = S_OK;

			}

			//
			// construct original path. we won't fail since we already tried IDENTNEWCAB on this buffer
			//
			(void)PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTCAB);

		}

		//
		// validat the iuidentcab trust
		//
		if (FAILED(hr = VerifyFileTrust(tszTargetPath, NULL, ReadWUPolicyShowTrustUI())))
		{
			//
			// alreaady logged by VerifyFileTrust(), so just bail out.
			//
			DeleteFile(tszTargetPath);
			goto CleanUp;
		}

		//
		// now, we have iuident.cab ready to use. extract the files
		//
		if (!IUExtractFiles(tszTargetPath, ptszFileCacheDir, IDENTTXT))
		{
			dwErr = GetLastError();
			LOG_Internet(_T("Error 0x%x when extracting ident.txt from %s"), dwErr, tszTargetPath);
			hr = HRESULT_FROM_WIN32(dwErr);
			goto CleanUp;
		}

		//
		// now we use tszTargetPath buffer to construct the iuident.txt file
		//
		hr = PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTTXT);
		CleanUpIfFailedAndMsg(hr);
	
		
		//
		// check to see if this OS needs redirect ident
		//
		if (FAILED(hr = GetRedirectServerUrl(tszTargetPath, ptszIdentBaseUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Error(_T("GetRedirectServerUrl(%s, %s, ...) failed (%#lx)"), tszTargetPath, ptszIdentBaseUrl, hr);
			break;
		}

		if (S_FALSE == hr || _T('\0') == ptszIdentBaseUrl[0])
		{
			LOG_Out(_T("no more redirection"));
			hr = S_OK;
			break;
		}

		if (WAIT_TIMEOUT != WaitForSingleObject(hQuitEvent, 0))
		{
			hr = E_ABORT;
			LOG_ErrorMsg(hr);
			break;
		}

		//
		// this OS should be redirect to get new ident.
		//
		iRedirectCounter--;
	}
	if (0 > iRedirectCounter)
	{
		// possible circular reference
		hr = E_FAIL;
	}

CleanUp:

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\stringutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   StringUtil.CPP
//
//  Description:
//
//      IU string utility library
//
//=======================================================================

#include <windows.h>
#include <tchar.h>
#include <stringutil.h>
#include <memutil.h>
#include <shlwapi.h>
#include<iucommon.h>
#include<MISTSAFE.h>


#define	IfNullReturnNull(ptr)		if (NULL == ptr) return NULL;

// ----------------------------------------------------------------------
//
// Public function StrChr() - same as shlwapi StrChr()
//		Searches a string for the first occurrence of a character that
//		matches the specified character. The comparison is case sensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the first occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrChr(LPCTSTR lpStart, const TCHAR wMatch)
{
	LPCTSTR lpPtr = lpStart;

	IfNullReturnNull(lpStart);
	
	while (_T('\0') != *lpPtr && wMatch != *lpPtr)
	{
		lpPtr = CharNext(lpPtr);
	}

	return (_T('\0') != *lpPtr) ? lpPtr : NULL;
}

// ----------------------------------------------------------------------
//
// Public function StrRChr() - same as shlwapi StrRChr()
//		Searches a string for the last occurrence of a character that
//		matches the specified character. The comparison is case sensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//      lpEnd - Address of the end of the string (NOT included in the search)
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the last occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrRChr(LPCTSTR lpStart, LPCTSTR lpEnd, const TCHAR wMatch)
{
    LPCTSTR lpFound = NULL;

    IfNullReturnNull(lpStart);

    if (NULL == lpEnd)
        lpEnd = lpStart + lstrlen(lpStart);

    LPCTSTR lpPtr = lpEnd;
    while (lpPtr > lpStart)
    {
        if (*lpPtr == wMatch)
            break;

        lpPtr = CharPrev(lpStart, lpPtr);
    }
	if (lpStart == lpPtr)
	{
		return (*lpStart == wMatch) ? lpStart : NULL;
	}
	else
	{
		return (lpPtr > lpStart) ? lpPtr : NULL;
	}
}


// ----------------------------------------------------------------------
//
// Public function StrChrI() - same as shlwapi StrChrI()
//		Searches a string for the first occurrence of a character that
//		matches the specified character. The comparison is case INsensitive.
//
//	Input: 
//		lpStart - Address of the string to be searched
//		wMatch - Character to be used for comparison
//
//	Return:
//		Returns the address of the first occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
// ----------------------------------------------------------------------
LPCTSTR MyStrChrI(LPCTSTR lpStart, const TCHAR wMatch)
{
	LPCTSTR	lpPtr;
	LPTSTR	lpBuffer;
	DWORD	dwLength;
	HANDLE	hHeap;

	IfNullReturnNull(lpStart);

	//
	// get buffer to store search string
	//
	hHeap = GetProcessHeap();
	dwLength = lstrlen(lpStart);
	lpBuffer = (LPTSTR) HeapAlloc(
								  GetProcessHeap(), 
								  0, 
								  (dwLength + 1) * sizeof(TCHAR)
								 );

	IfNullReturnNull(lpBuffer);

	//
	// copy the search string to buffer
	//
	

	//The buffer allocated is sufficient to hold the lpStart string. 
	StringCchCopyEx(lpBuffer,dwLength + 1,lpStart,NULL,NULL,MISTSAFE_STRING_FLAGS);



	//
	// based on the case of wMatch, determine how to convert
	// the search string
	//
	if (IsCharUpper(wMatch))
	{
		CharUpperBuff(lpBuffer, dwLength);
	}
	else
	{
		CharLowerBuff(lpBuffer, dwLength);
	}

	//
	// search the char in in new string
	//
	lpPtr = lpBuffer;
	while (_T('\0') != *lpPtr && wMatch != *lpPtr)
	{
		lpPtr = CharNext(lpPtr);
	}

	//
	// map the position to original string, if found.
	//
	lpPtr = (_T('\0') != *lpPtr) ? lpStart + (lpPtr - lpBuffer) : NULL;

	HeapFree(hHeap, 0, lpBuffer); 

	return lpPtr;
}



// ----------------------------------------------------------------------
//
//	Convert a long number content in bstr into long
//	if error, 0 returned.
//
// ----------------------------------------------------------------------
LONG MyBSTR2L(BSTR bstrLongNumber)
{
	USES_IU_CONVERSION;

	LPTSTR lpszNumber = OLE2T(bstrLongNumber);
	
	return StrToInt(lpszNumber);
}



// ----------------------------------------------------------------------
//
//	Convert a a long number into bstr
//
// ----------------------------------------------------------------------
BSTR MyL2BSTR(LONG lNumber)
{
	USES_IU_CONVERSION;
	WCHAR sNumber[32];
	
	
	StringCchPrintfExW(sNumber,ARRAYSIZE(sNumber),NULL,NULL,MISTSAFE_STRING_FLAGS,L"%ld", lNumber);

	return SysAllocString(sNumber);
}


BSTR MyUL2BSTR(ULONG ulNumber)
{
	USES_IU_CONVERSION;
	WCHAR sNumber[32];

	
	StringCchPrintfExW(sNumber,ARRAYSIZE(sNumber),NULL,NULL,MISTSAFE_STRING_FLAGS,L"%lu", ulNumber);
	return SysAllocString(sNumber);
}






// ----------------------------------------------------------------------
//
// Compare a binary buffer with a string, where data in the string
// has format:
//
//		<String>	::= <Number> [<Space><String>]
//		<Space>		::= TCHAR(' ')
//		<Number>	::= 0x<HexValue>|x<HexValue>|<Decimal>
//		<Decimal>	::= +<DecimalValue>|-<DecimalValue>
//		<DecimalValue> ::= <DecimalDigit>|<DecimalDigit><DecimalValue>
//		<DecimalDegit> ::= 0|1|2|3|4|5|6|7|8|9
//		<HexValue>	::= <HexDigit>|<HexDigit><HexDigit>
//		<HexDigit>	::= <DecimalDigit>|A|B|C|D|E|F
//
//	example of strings that this function recognize:
//		"12 0 45 0x1F"
//
//	Return: similar to lstrcmp() API, each byte is compared
//			as unsigned short
//			if binary > string, +1
//			if binary = string, 0
//			if binary < string, -1
//
//  Note:
//		If the string is shorter than binary buffer, i.e., string contains
//		less byte data than the binary buffer contain, we only compare till
//		the number of bytes provided by the string offered. 
//		This request is based on the fact that many v3 data has reg value
//		as DWORD but the update created the value with type binary. so for 
//		string data, e.g., it's "1", for binary data, it's "01 00 00 00" for
//		4 bytes, this function will return 0 meaning equality, per request
//		from aavon for bug 364085 in Whistler RAID.
//
// ----------------------------------------------------------------------
int CmpBinaryToString(
		LPBYTE pBinaryBuffer,		// buffer to contain binary data
		UINT nBinarySize,			// number of bytes this binary has data
		LPCTSTR pstrValue			// string contains data to compare
)
{
	int rc = 0;
	int iNumber;
	UINT nCharCount = nBinarySize;
	LPCTSTR lpNumber = pstrValue;

	if (NULL == pBinaryBuffer)
	{
		if (NULL == pstrValue)
		{
			return 0;	// both NULL
		}
		nBinarySize = 0; // make sure
	}

	if (NULL == pstrValue || _T('\0') == *pstrValue)
	{
		//
		// this is the case that binary not null,
		// but string null.
		// as of lstrcmp(), string 1 > string 2
		//
		return +1;		
	}

	while (nBinarySize > 0)
	{
		if (NULL == lpNumber || _T('\0') == *lpNumber)
		{
			//
			// when binary not done, string done, we don't care the left binary
			// 
			return 0;
		}


		if (!StrToIntEx(lpNumber, STIF_SUPPORT_HEX, &iNumber) ||
			iNumber < 0 || 
			iNumber > 255)
		{
			//
			// found un-convertable number in the 
			// string. or the number if out of range
			// of a byte, treat it invalid, so the
			// binary win
			//
			iNumber = 0x0;
		}

		if ((unsigned short)pBinaryBuffer[nCharCount - nBinarySize]  > (unsigned short) iNumber)
		{
			return +1;

		}
		else if ((unsigned short)pBinaryBuffer[nCharCount - nBinarySize]  < (unsigned short) iNumber)
		{
			//
			// binary is smaller
			//
			return -1;
		}

		//
		// if equal, continue to compare next byte
		//
		nBinarySize--;

		//
		// skip the white spaces before this number
		//
		while (_T('\0') != *lpNumber && 
			   (_T(' ') == *lpNumber ||
			   _T('\t') == *lpNumber ||
			   _T('\r') == *lpNumber ||
			   _T('\n') == *lpNumber)) lpNumber++;
		//
		// try to find the beginning of the next number
		//
		lpNumber = StrChr(lpNumber, _T(' '));
	}

	//
	// these two parameters point to data having same meaning
	//
	return 0;
}


/*
 * FUNCTION:		int atoh(char *ptr)
 * 
 * PURPOSE:			This function converts an hexadecimal string into it's decimal value.
 * 
 * PARAMETERS:
 *
 *		char *ptr:	pointer to string to be converted
 * 
 * RETURNS:			The converted value.
 * 
 * COMMENTS:		Like atoi this function ends the conversion on the first innvalid
 *					hex digit.
 * 
 */
int atoh(LPCSTR ptr)
{
	int		i = 0;
	char	ch;

	//skip 0x if present
	if (NULL == ptr) return 0;
	if ( ptr[0] == '0') ptr++;
	if ( ptr[0] == 'x' || ptr[0] == 'X') ptr++;

	while( 1 )
	{
		ch = (char)toupper(*ptr);
		if ( (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') )
		{
			ch -= '0';
			if ( ch > 10 )
				ch -= 7;
			i *= 16;
			i += (int)ch;
			ptr++;
			continue;
		}
		break;
	}
	return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\waitutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   WaitUtil.h
//
//  Description:
//
//      IU wait message utility library
//
//=======================================================================

#include "WaitUtil.h"

DWORD WaitAndPumpMessages(DWORD nCount, LPHANDLE pHandles, DWORD dwWakeMask)
{
    DWORD dwWaitResult;
    MSG msg;

    while (TRUE)
    {
        dwWaitResult = MsgWaitForMultipleObjects(nCount, pHandles, FALSE, 1000, dwWakeMask);
        if (dwWaitResult <= WAIT_OBJECT_0 + nCount - 1)
        {
            return dwWaitResult;
        }

        if (WAIT_OBJECT_0 + nCount == dwWaitResult)
        {
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    return dwWaitResult;
}

DWORD MyMsgWaitForMultipleObjects(DWORD nCount, LPHANDLE pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
{
    DWORD dwTickStart;
    DWORD dwWaitResult;
	DWORD dwLoopMS = 250;	// default 250 ms timeout for MsgWaitForMultipleObjects
    MSG msg;

    dwTickStart = GetTickCount();

	if (dwLoopMS > dwMilliseconds)
	{
		//
		// Never wait more than dwMilliseconds
		//
		dwLoopMS = dwMilliseconds;
	}

    while (TRUE)
    {
		//
		// Empty message queue before calling MsgWaitForMultipleObjects or any
		// existing messages will not be processed until a new message arrives
		// in the queue.
		//
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			switch (msg.message)
			{
			case WM_QUIT:
			case WM_CLOSE:
			case WM_DESTROY:
				{
					// if the message is one that indicates we're trying to close down, we'll signal the abort
					// and leave.
					dwWaitResult = ERROR_REQUEST_ABORTED;
					return dwWaitResult;
				}
			default:
				break;
			}

			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		dwWaitResult = MsgWaitForMultipleObjects(nCount, pHandles, fWaitAll, dwLoopMS, dwWakeMask);

        if (dwWaitResult <= WAIT_OBJECT_0 + nCount - 1)
        {
			//
			// One (or all depending on fWaitAll) of the objects is signaled, return dwWaitResult
			//
            break;
        }

		//
		// NOTE: we ignore WAIT_ABANDONED_0 + n cases and just time out since our callers
		// don't handle this special case.
		//

		//
		// Stop pumping messages after dwMilliseconds
		//
		// Timer wraparound handled by unsigned subtract
		//
        if (GetTickCount() - dwTickStart >= dwMilliseconds)
        {
			//
			// No need to continue, even if caused by new message (WAIT_OBJECT_0 + nCount == dwWaitResult),
			// we have reached our dwMilliseconds timeout
			//
            dwWaitResult = WAIT_TIMEOUT;
            break;
        }

        //
		// Otherwise continue, WAIT_TIMEOUT from MsgWaitForMultipleObjects is only case left
		//
		continue;
    }

    return dwWaitResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\util\timeutil.cpp ===
#include <timeutil.h>

////////////////////////////////////////////////////////////////////////////
//
// Helper Function  TimeDiff(tm1, tm2)
//          helper function to find the difference (in seconds) of 2 system times
//
// Input:   2 SYSTEMTIME structures
// Output:  None
// Return:  seconds of difference
//              > 0 if tm2 is later than tm1
//              = 0 if tm2 and tm1 are the same
//              < 0 if tm2 is earlier than tm1
//
// On error the function returns 0 even if the two times are not equal
//
// Comment: If the number of seconds goes beyond INT_MAX (that is 
//          more than 24,855 days, INT_MAX is returned.
//          If the number of seconds goes beyond INT_MIN (a negative value,
//          means 24,855 days ago), INT_MIN is returned.
//
////////////////////////////////////////////////////////////////////////////
int TimeDiff(SYSTEMTIME tm1, SYSTEMTIME tm2)
{
    LONGLONG i64Sec;
    int iSec;
    //
    // convert the two times from SYSTEMTIME format into FILETIME format
    //
    FILETIME ftm1, ftm2;

    if ((SystemTimeToFileTime(&tm1, &ftm1) == 0) ||
        (SystemTimeToFileTime(&tm2, &ftm2) == 0))
    {
        return 0;
    }

    if ((ftm1.dwHighDateTime == ftm2.dwHighDateTime) &&
        (ftm1.dwLowDateTime == ftm2.dwLowDateTime))
    {
        return 0;
    }

    //
    // convert the two times from FILETIME to LARGE_INTEGER type,
    //
    LARGE_INTEGER i64Sec1, i64Sec2;
    i64Sec2.LowPart = ftm2.dwLowDateTime;
    i64Sec2.HighPart = ftm2.dwHighDateTime;
    i64Sec1.LowPart = ftm1.dwLowDateTime;
    i64Sec1.HighPart = ftm1.dwHighDateTime;
    
    
    //
    // since Windows support LONGLONG, we directly use the quad portion of LARGE_INTEGER
    // to get the difference, which is 100 nanoseconds. Then convert the number to seconds.
    //
    i64Sec = (i64Sec2.QuadPart - i64Sec1.QuadPart) / NanoSec100PerSec;

    //
    // convert the LONGLONG seconds value into integer, since it shouldn't exceed 
    // integer limit
    //
    if (i64Sec > INT_MAX)
    {
        //
        // just in case user is playing with the system time.
        // Otherwise, this difference should not go beyond 68 years.
        //
        iSec = INT_MAX;
    }
    else
    {
        if (i64Sec < INT_MIN)
        {
            iSec = INT_MIN;
        }
        else
        {
            iSec = (int)i64Sec;
        }
    }
    
    return iSec;
}
    

////////////////////////////////////////////////////////////////////////////
//
// Helper Function  TimeAddSeconds(SYSTEMTIME, int, SYSTEMTIME* )
//          helper function to calculate time by adding n seconds to 
//          the given time.
//
// Input:   a SYSTEMTIME as base time, an int as seconds to add to the base time
// Output:  new time
// Return:  HRESULT
//
////////////////////////////////////////////////////////////////////////////
HRESULT TimeAddSeconds(SYSTEMTIME tmBase, int iSeconds, SYSTEMTIME* pTimeNew)
{
	// fixcode use i64 calcs
    FILETIME ftm;

    if (SystemTimeToFileTime(&tmBase, &ftm) == 0)
    {
        return E_FAIL;
    }

    LARGE_INTEGER i64Sec;
    i64Sec.LowPart  = ftm.dwLowDateTime;
    i64Sec.HighPart = ftm.dwHighDateTime;

    __int64 i64Delay = NanoSec100PerSec;
    i64Delay *= iSeconds;
    i64Sec.QuadPart += i64Delay;    
    ftm.dwLowDateTime = i64Sec.LowPart;
    ftm.dwHighDateTime = i64Sec.HighPart;
    if (FileTimeToSystemTime(&ftm, pTimeNew) == 0)
    {
        return E_FAIL;
    }
    return S_OK;
}



//=======================================================================
// String2SystemTime
//=======================================================================
HRESULT String2SystemTime(LPCTSTR pszDateTime, SYSTEMTIME *ptm)
{
    // we expect the date/time format as 4-digit year ISO:
    //      01234567890123456789
    //      YYYY.MM.DD HH:MM:SS
    //
    const TCHAR C_DATE_DEL      = _T('.');
    const TCHAR C_DATE_TIME_DEL = _T(' ');
    const TCHAR C_TIME_DEL      = _T(':');
    TCHAR szBuf[20];
	LPTSTR pszDestEnd;

    if (FAILED(StringCchCopyEx(szBuf, ARRAYSIZE(szBuf), pszDateTime, &pszDestEnd, NULL, MISTSAFE_STRING_FLAGS)) ||
		19 != pszDestEnd - szBuf)
    {
        return E_INVALIDARG;
    }

    for (int i = 0; i < 19; i++)
    {
        switch (i)
        {
        case 4:
        case 7:
            if (szBuf[i] != C_DATE_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        case 10:
            if (szBuf[i] != C_DATE_TIME_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        case 13:
        case 16:
            if (szBuf[i] != C_TIME_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        default:
            if (szBuf[i] < _T('0') || pszDateTime[i] > _T('9'))
            {
                return E_INVALIDARG;
            }
            break;
        }
    }

    //
    // get values
    //
    szBuf[4]            = EOS;
    ptm->wYear          = (short)_ttoi(szBuf);
    szBuf[7]            = EOS;
    ptm->wMonth         = (short)_ttoi(szBuf + 5);
    szBuf[10]           = EOS;
    ptm->wDay           = (short)_ttoi(szBuf + 8);
    szBuf[13]           = EOS;
    ptm->wHour          = (short)_ttoi(szBuf + 11);
    szBuf[16]           = EOS;
    ptm->wMinute        = (short)_ttoi(szBuf + 14);
    ptm->wSecond        = (short)_ttoi(szBuf + 17); 
    ptm->wMilliseconds  = 0;

    //
    // validate if this constructed SYSTEMTIME data is good
    //
    // fixcode should this just be SystemTimeToFileTime() ?
    if (GetDateFormat(LOCALE_SYSTEM_DEFAULT,DATE_SHORTDATE, ptm, NULL, NULL, 0) == 0)
    {
        return E_INVALIDARG;
    }
    if (GetTimeFormat(LOCALE_SYSTEM_DEFAULT,LOCALE_NOUSEROVERRIDE, ptm, NULL, NULL, 0) == 0)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}


//=======================================================================
// SystemTime2String
//=======================================================================
HRESULT SystemTime2String(SYSTEMTIME & tm, LPTSTR pszDateTime, size_t cchSize)
{
    if ( pszDateTime == NULL )
    {
        return E_INVALIDARG;
    }

    // bug fixed: changed from wsprintf to _snwprintf because an invalid
    // date on tm was causing buffer overflow
    LPTSTR pszDestEnd;
	if (FAILED(StringCchPrintfEx(
					pszDateTime,
					cchSize,
					&pszDestEnd,
					NULL,
					MISTSAFE_STRING_FLAGS,
					TEXT("%4i.%02i.%02i %02i:%02i:%02i"),
					tm.wYear,
					tm.wMonth,
					tm.wDay,
					tm.wHour,
					tm.wMinute,
					tm.wSecond)) ||
		pszDestEnd - pszDateTime != 19)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\wusafefn\safefile.cpp ===
//
// SafeFile.cpp
//
//		Functions to help prevent opening unsafe files.
//
// History:
//
//		2002-03-18  KenSh     Created
//
// Copyright (c) 2002 Microsoft Corporation
//

#include "stdafx.h"
#include "SafeFile.h"
#include <strsafe.h>

//
// Hopefully most projects already define these; if not, ensure we still compile
//
#ifndef ASSERT
#define ASSERT(x)
#endif
#ifndef ARRAYSIZE
#define ARRAYSIZE(ar) (sizeof(ar)/sizeof((ar)[0]))
#endif

//
// Eliminate an unnecessary function call on Unicode builds
//
#ifndef CHARNEXT
#ifdef UNICODE
#define CHARNEXT(psz) (psz+1)
#else
#define CHARNEXT CharNextA
#endif
#endif

//
// Local function declarations
//
static inline BOOL IsSlashOrBackslash(IN TCHAR ch);
static inline BOOL IsSlashOrBackslash(IN TCHAR ch);
static BOOL SkipLangNeutralPrefix(IN LPCTSTR pszString, IN LPCTSTR pszPrefix, OUT LPCTSTR* ppszResult);
static BOOL MyPathFindNextComponent(IN LPCTSTR pszFileName, IN BOOL fAllowForwardSlash, OUT LPCTSTR* ppszResult);
static BOOL SkipPathDrivePart(IN LPCTSTR pszFileName, OUT OPTIONAL int* pcchDrivePart, OUT OPTIONAL BOOL* pfUNC, OUT OPTIONAL BOOL* pfExtendedSyntax);
static HRESULT CheckValidDriveType(IN LPCTSTR pszFileName, IN BOOL fAllowNetworkDrive, IN BOOL fAllowRemovableDrive);
static BOOL WINAPI DoesPathContainDotDot(IN LPCTSTR pszFileName);
static BOOL DoesPathContainStreamSyntax(IN LPCTSTR pszFileName);
static HRESULT CheckReparsePointPermissions(IN DWORD dwReparseType);


//============================================================================

static inline HRESULT GetLastErrorAsHresult()
{
	DWORD dwErr = GetLastError();
	return HRESULT_FROM_WIN32(dwErr);
}

// IsSlashOrBackslash [private]
//
//		Helper function to simplify code that checks for path separators.
//		Most places where backslash is valid, forward slash is also valid.
//
static inline BOOL IsSlashOrBackslash(IN TCHAR ch)
{
	return (ch == _T('\\') || ch == _T('/'));
}


// StrLenWithMax [private]
//
//		Returns the equivalent of min(lstrlen(pszString), cchMax)
//		but avoids most of the lstrlen when cchMax is small.
//
static int StrLenWithMax(IN LPCTSTR pszString, IN int cchMax)
{
	int cch = 0;
	while (*pszString && cch < cchMax)
		cch++;
	return cch;
}


// SkipLangNeutralPrefix [private]
//
//		Sets the out param to the new string pointer after skipping the prefix,
//		if the string starts with the prefix (case-insensitive). Otherwise sets
//		the out param to the start of the input string.
//
//		Returns TRUE if the prefix was found & skipped, otherwise FALSE.
//
static BOOL SkipLangNeutralPrefix(IN LPCTSTR pszString, IN LPCTSTR pszPrefix, OUT LPCTSTR* ppszResult)
{
	int cchPrefix = lstrlen(pszPrefix);
	int cchString = StrLenWithMax(pszString, cchPrefix);
	BOOL fResult = FALSE;

	if (CSTR_EQUAL == CompareString(MAKELCID(LANG_ENGLISH, SORT_DEFAULT), NORM_IGNORECASE,
							pszString, cchString, pszPrefix, cchPrefix))
	{
		fResult = TRUE;
		pszString += cchPrefix;
	}

	*ppszResult = pszString;
	return fResult;
}


// MyPathFindNextComponent [private]
//
//		Skips past the next component of the given path, including the slash or
//		backslash that follows it.
//
//		Sets the out param to the beginning of the next path component, or to
//		the end of string if there is no next path component.
//
//		Returns TRUE if a slash or backslash was found and skipped. Note that
//		the out param can be "" even if function returns TRUE.
//
static BOOL MyPathFindNextComponent
	(
		IN  LPCTSTR pszFileName,
		IN  BOOL    fAllowForwardSlash,
		OUT LPCTSTR* ppszResult
	)
{
	// This is a string-parsing helper function; params should never be NULL
	ASSERT(pszFileName != NULL);
	ASSERT(ppszResult != NULL);

	LPCTSTR pszStart = pszFileName;
	TCHAR chSlash2 = (fAllowForwardSlash ? _T('/') : _T('\\'));
	BOOL fResult = FALSE;

	for (;;)
	{
		TCHAR ch = *pszFileName;
		if (ch == _T('\0'))
			break; // didn't find a path separator; we'll return FALSE

		// Advance to next char, even if current char is path separator (\ or /)
		pszFileName = CHARNEXT(pszFileName);

		if (ch == _T('\\') || ch == chSlash2)
		{
			fResult = TRUE;
			break;
		}
	}

	*ppszResult = pszFileName;
	return fResult;
}


// SkipPathDrivePart [private]
//
//		Parses the filename to determine the length of the base drive portion of
//		the filename, and to determine what syntax the name is in.
//
//		This function does not actually examine the drive or file to ensure existence,
//		or to recognize that a drive letter like X:\ might be a network drive.
//
//		Returns:
//			TRUE  - if the input is a full path
//			FALSE - if input param is not a full path, or is bogus. The pcchDrivePart
//			        out param is set to 0 in this case.
//
static BOOL SkipPathDrivePart
	(
		IN LPCTSTR pszFileName,             // input path name (full or relative path)
		OUT OPTIONAL int* pcchDrivePart,    // # of TCHARs used by drive part
		OUT OPTIONAL BOOL* pfUNC,           // TRUE if path is UNC (not incl mapped drive)
		OUT OPTIONAL BOOL* pfExtendedSyntax // TRUE if path is \\?\ syntax
	)
{
	BOOL fFullPath = FALSE;
	LPCTSTR pszOriginalFileName = pszFileName;
	int fUNC = FALSE;
	int fExtendedSyntax = FALSE;

	if (!pszFileName)
		goto done;

	// BLOCK
	{
		//
		// Skip \\?\ if present. (This part must use backslashes, not forward slashes)
		//
#ifdef UNICODE
		if (SkipLangNeutralPrefix(pszFileName, _T("\\\\?\\"), &pszFileName))
		{
			fExtendedSyntax = TRUE;

			if (SkipLangNeutralPrefix(pszFileName, _T("UNC\\"), &pszFileName))
			{
				fUNC = TRUE; // Found "\\?\UNC\..."
			}
			else if (SkipLangNeutralPrefix(pszFileName, _T("Volume{"), &pszFileName))
			{
				// Found "\\?\Volume{1f3b3813-ddbf-11d5-ab2e-806d6172696f}\".
				// Skip the rest of the volume name.
				fFullPath = MyPathFindNextComponent(pszFileName, FALSE, &pszFileName);
				goto done;
			}
			// else continue normal parsing starting at updated pszFileName pointer
		}
#endif // UNICODE

		//
		// Check for path of the form C:\ 
		//
		TCHAR chFirstUpper = (TCHAR)CharUpper((LPTSTR)(pszFileName[0]));
		if (chFirstUpper >= _T('A') && chFirstUpper <= _T('Z') &&
			pszFileName[1] == _T(':') && pszFileName[2] == _T('\\'))
		{
			pszFileName += 3;
			fFullPath = TRUE;
			goto done;
		}

		//
		// Check for UNC of the form \\server\share\ 
		//
		if (!fExtendedSyntax &&
			pszFileName[0] == _T('\\') &&
			pszFileName[1] == _T('\\'))
		{
			fUNC = TRUE;
			pszFileName += 2; // skip the "\\"
		}
		if (fUNC) // may be \\server\share\ or \\?\UNC\server\share\ 
		{
			// Skip past server and share names. Trailing backslash is NOT optional.
			if (!MyPathFindNextComponent(pszFileName, TRUE, &pszFileName) ||
				!MyPathFindNextComponent(pszFileName, TRUE, &pszFileName))
			{
				goto done; // incomplete UNC path -> return failure
			}

			fFullPath = TRUE;
		}
	}

done:
	if (pcchDrivePart)
		*pcchDrivePart = fFullPath ? (int)(pszFileName - pszOriginalFileName) : 0;
	if (pfUNC)
		*pfUNC = fUNC;
	if (pfExtendedSyntax)
		*pfExtendedSyntax = fExtendedSyntax;

	return fFullPath;
}


// GetReparsePointType [public]
//
//		Given the full path of a file or directory, determines what type of 
//		reparse point the path represents.
//
//		Returns S_OK if the type of reparse point could be determined, or
//		an appropriate error code if not.
//
//		The out param is set to the reparse point type, or 0 if none.
//		The value for both volume mount points and junction points is
//		IO_REPARSE_TAG_MOUNT_POINT. (Use GetVolumeNameForVolumeMountPoint
//		to distinguish, if necessary.)
//
HRESULT WINAPI GetReparsePointType
	(
		IN LPCTSTR pszFileName,           // full path to folder to check
		OUT DWORD* pdwReparsePointType    // set to reparse point type, or 0 if none
	)
{
	HRESULT hr = S_OK;
	DWORD dwReparseType = 0;

	ASSERT(pdwReparsePointType);

	// BLOCK
	{
		if (!pszFileName)
		{
			hr = E_INVALIDARG;
			goto done;
		}

		DWORD dwAttrib = GetFileAttributes(pszFileName);
		if (dwAttrib == INVALID_FILE_ATTRIBUTES)
			goto win32_error;

		if (dwAttrib & FILE_ATTRIBUTE_REPARSE_POINT)
		{
			WIN32_FIND_DATA Find;
			HANDLE hFind = FindFirstFile(pszFileName, &Find);
			if (hFind == INVALID_HANDLE_VALUE)
				goto win32_error;

			dwReparseType = Find.dwReserved0;
			FindClose(hFind);
		}
		goto done;
	}

win32_error:
	hr = GetLastErrorAsHresult();

done:
	*pdwReparsePointType = dwReparseType;
	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// CheckReparsePointPermissions [private]
//
//		Determines whether or not it's ok to trust the given reparse type.
//		Returns S_OK if it's safe, or an appropriate error message if not.
//
static HRESULT CheckReparsePointPermissions(IN DWORD dwReparseType)
{
	HRESULT hr = S_OK;

	// REVIEW: Any reason to worry about these other types of reparse points?
	//   IO_REPARSE_TAG_HSM, IO_REPARSE_TAG_SIS, IO_REPARSE_TAG_DFS, etc.
	if (dwReparseType == IO_REPARSE_TAG_MOUNT_POINT)
	{
		hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
	}

	return hr;
}


// CheckValidDriveType [private]
//
//		Gets the volume name associated with the given file, and checks the
//		return value from GetDriveType() to see whether or not operations
//		are allowed on the file.
//
static HRESULT CheckValidDriveType
	(
		IN LPCTSTR pszFileName,       // full path of a file whose drive we want to check
		IN BOOL fAllowNetworkDrive,   // determines whether or not net drives are allowed
		IN BOOL fAllowRemovableDrive  // determines whether or not removable drives are allowed
	)
{
	HRESULT hr = E_INVALIDARG;
	LPTSTR pszVolumePath = NULL;

	// BLOCK
	{
		if (!pszFileName)
		{
			goto done;  // hr is already E_INVALIDARG
		}

		int cchFileName = lstrlen(pszFileName);
		pszVolumePath = (LPTSTR)SafeFileMalloc(sizeof(TCHAR) * (cchFileName+1));
		if (!pszVolumePath)
		{
			hr = E_OUTOFMEMORY;
			goto done;
		}

#ifdef UNICODE
		if (!GetVolumePathName(pszFileName, pszVolumePath, cchFileName+1))
		{
			hr = GetLastErrorAsHresult();
			goto done;
		}
#else
		int cchDrivePart;
		if (!SkipPathDrivePart(pszFileName, &cchDrivePart, NULL, NULL))
		{
			hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
			goto done;
		}
		StringCchCopy(pszVolumePath, cchDrivePart+1, pszFileName);
#endif

		UINT uDriveType = GetDriveType(pszVolumePath);
		switch (uDriveType)
		{
		case DRIVE_FIXED:
			hr = S_OK;
			break;

		case DRIVE_REMOVABLE:
		case DRIVE_CDROM:
		case DRIVE_UNKNOWN:
		case DRIVE_RAMDISK:
			hr = fAllowRemovableDrive ? S_OK : E_ACCESSDENIED;
			break;

		case DRIVE_REMOTE:
			hr = fAllowNetworkDrive ? S_OK : E_ACCESSDENIED;
			break;

		default:
			hr = E_INVALIDARG;
			break;
		}
	}

done:
	SafeFileFree(pszVolumePath);

	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// IsFullPathName [public]
//
//		Determines whether the given filename is a full path including a drive
//		or UNC. Filenames such as \\?\ are supported, and can be considered
//		valid or not depending on the dwSafeFlags parameter.
//
//		Returns:
//			TRUE  - if the filename is a full path
//			FALSE - if filename is NULL, isn't a full path, or fails to meet
//			        the criteria given in the dwSafeFlags parameter.
//
BOOL WINAPI IsFullPathName
	(
		IN LPCTSTR pszFileName,              // full or relative path to a file
		OUT OPTIONAL BOOL* pfUNC,            // TRUE path is UNC (int incl mapped drive)
		OUT OPTIONAL BOOL* pfExtendedSyntax  // TRUE if path is \\?\ syntax
	)
{
	return SkipPathDrivePart(pszFileName, NULL, pfUNC, pfExtendedSyntax);
}


// DoesPathContainDotDot [private]
//
//		Returns TRUE if the path contains any ".." references, else FALSE.
//
static BOOL WINAPI DoesPathContainDotDot(IN LPCTSTR pszFileName)
{
	if (!pszFileName)
		return FALSE;

	while (*pszFileName)
	{
		// Flag path components that consist exactly of ".." (nothing following)
		if (pszFileName[0] == _T('.') && pszFileName[1] == _T('.') &&
			(pszFileName[2] == _T('/') || pszFileName[2] == _T('\\') || pszFileName[2] == _T('\0')))
		{
			return TRUE;
		}

		MyPathFindNextComponent(pszFileName, TRUE, &pszFileName);
	}

	return FALSE;
}


// DoesPathContainStreamSyntax [private]
//
//		Returns TRUE if the path contains any characters that could cause it
//		to refer to an alternate NTFS stream (namely any ":" characters beyond
//		the drive specification).
//
static BOOL DoesPathContainStreamSyntax(IN LPCTSTR pszFileName)
{
	if (!pszFileName)
		return FALSE;

	int cchSkip;
	SkipPathDrivePart(pszFileName, &cchSkip, NULL, NULL);

	for (LPCTSTR pch = pszFileName + cchSkip; *pch; pch = CHARNEXT(pch))
	{
		if (*pch == _T(':'))
			return TRUE;
	}

	return FALSE;
}


// SafeCreateFile [public]
//
//		Opens the given file, ensuring that it meets certain path standards (e.g.
//		doesn't contain "..") and that it is a file, not a device or named pipe.
//
HRESULT WINAPI SafeCreateFile
	(
		OUT HANDLE* phFileResult,       // receives handle to opened file, or INVALID_HANDLE_VALUE
		IN DWORD dwSafeFlags,           // zero or more SCF_* flags
		IN LPCTSTR pszFileName,         // same as CreateFile
		IN DWORD dwDesiredAccess,       // same as CreateFile
		IN DWORD dwShareMode,           // same as CreateFile
		IN LPSECURITY_ATTRIBUTES lpSecurityAttributes, // same as CreateFile
		IN DWORD dwCreationDisposition, // same as CreateFile
		IN DWORD dwFlagsAndAttributes,  // same as CreateFile + (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)
		IN HANDLE hTemplateFile         // same as CreateFile
	)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HRESULT hr = S_OK;

	// BLOCK
	{
		if (!pszFileName || !phFileResult ||
			(dwSafeFlags & ~(SCF_ALLOW_NETWORK_DRIVE | SCF_ALLOW_REMOVABLE_DRIVE | SCF_ALLOW_ALTERNATE_STREAM)))
		{
			hr = E_INVALIDARG;
			goto done;
		}

		// We require a full pathname.
		if (!IsFullPathName(pszFileName))
		{
			hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
			goto done;
		}

		// Ensure path doesn't contain ".." references
		if (DoesPathContainDotDot(pszFileName))
		{
			hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
			goto done;
		}

		// Ensure filename doesn't refer to alternate stream unless allowed
		if (!(dwSafeFlags & SCF_ALLOW_ALTERNATE_STREAM) &&
			DoesPathContainStreamSyntax(pszFileName))
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
			goto done;
		}

		// Check drive type to ensure it's allowed by dwSafeFlags
		if (FAILED(hr = CheckValidDriveType(pszFileName, (dwSafeFlags & SCF_ALLOW_NETWORK_DRIVE),
							(dwSafeFlags & SCF_ALLOW_REMOVABLE_DRIVE))))
		{
			goto done;
		}

		// Open the file w/ extra security attributes
		dwFlagsAndAttributes |= (SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS);
		hFile = CreateFile(pszFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
							dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			goto win32_error;
		}

		// Ensure it's really a file
		if (FILE_TYPE_DISK != GetFileType(hFile))
		{
			CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;
			hr = HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
		}
		goto done;

	} // end BLOCK

win32_error:
	hr = GetLastErrorAsHresult();

done:
	if (phFileResult)
		*phFileResult = hFile;
	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafeRemoveFileAttributes [public]
//
//		Given a filename and that file's current attributes, checks whether
//		any of the bits in dwRemoveAttrib need to be removed from the file,
//		and if necessary calls SetFileAttributes() to remove them.
//
//		Designed to check for invalid dwCurAttrib and call GetLastError()
//		for you, so you can pass GetFileAttributes() directly as a parameter.
//
HRESULT WINAPI SafeRemoveFileAttributes
	(
		IN LPCTSTR pszFileName,    // full path to file whose attributes we will change
		IN DWORD   dwCurAttrib,    // current attributes of the file
		IN DWORD   dwRemoveAttrib  // attribute bits to remove
	)
{
	HRESULT hr = S_OK; // this is default if attrib doesn't need to be removed

	if (!pszFileName || !dwRemoveAttrib)
	{
		hr = E_INVALIDARG;
		goto done;
	}

	if (dwCurAttrib & dwRemoveAttrib) // note: always true if dwCurAttrib==INVALID_FILE_ATTRIBUTES
	{
		if (dwCurAttrib == INVALID_FILE_ATTRIBUTES ||
			!SetFileAttributes(pszFileName, dwCurAttrib & ~dwRemoveAttrib))
		{
			hr = GetLastErrorAsHresult();
		}
	}

done:
	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafeDeleteFolderAndContentsHelper [private]
//
//		Does all work except the parameter validation for for
//		SafeDeleteFolderAndContents.
//
static HRESULT SafeDeleteFolderAndContentsHelper
	(
		IN  LPCTSTR pszFolderToDelete,  // folder in current level of recursion
		IN  DWORD dwSafeFlags,          // zero or more SDF_* flags
		OUT WIN32_FIND_DATA* pFind      // struct to use for FindFirst/FindNext (to avoid malloc)
	)
{
	HRESULT hr = S_OK;
	LPTSTR pszCurFile = NULL;
	HANDLE hFind = INVALID_HANDLE_VALUE;

	// Allocate room for folder + backslash + MAX_PATH (includes trailing null)
	int cchFolderName = lstrlen(pszFolderToDelete);
	int cchAllocCurFile = cchFolderName + 1 + MAX_PATH;
	pszCurFile = (LPTSTR)SafeFileMalloc(sizeof(TCHAR) * cchAllocCurFile);
	if (!pszCurFile)
	{
		hr = E_OUTOFMEMORY;
		goto done;
	}

	// Check for read-only base folder
	if (dwSafeFlags & SDF_DELETE_READONLY_FILES)
	{
		hr = SafeRemoveFileAttributes(pszFolderToDelete, GetFileAttributes(pszFolderToDelete), FILE_ATTRIBUTE_READONLY);
		if (FAILED(hr) && !(dwSafeFlags & SDF_CONTINUE_IF_ERROR))
			goto done;
	}

	// Build search path by appending "\*.*"
	StringCchCopy(pszCurFile, cchAllocCurFile, pszFolderToDelete);
	if (!IsSlashOrBackslash(pszCurFile[cchFolderName-1]))
		pszCurFile[cchFolderName++] = _T('\\');
	StringCchCopy(pszCurFile + cchFolderName, cchAllocCurFile - cchFolderName, _T("*.*"));

	// Iterate through all files in this folder
	hFind = FindFirstFile(pszCurFile, pFind);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastErrorAsHresult();  // probably doesn't exist, or not a folder
		goto done;
	}
	else
	{
		do
		{
			if (0 == lstrcmp(pFind->cFileName, _T(".")) ||
				0 == lstrcmp(pFind->cFileName, _T("..")))
			{
				continue;
			}

			StringCchCopy(pszCurFile + cchFolderName, cchAllocCurFile - cchFolderName, pFind->cFileName);
			HRESULT hrCur = S_OK;

			if (!(pFind->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ||
				SUCCEEDED(hrCur = CheckReparsePointPermissions(pFind->dwReserved0)))
			{
				// Remove read-only attribute if allowed
				if (dwSafeFlags & SDF_DELETE_READONLY_FILES)
				{
					hrCur = SafeRemoveFileAttributes(pszCurFile, pFind->dwFileAttributes, FILE_ATTRIBUTE_READONLY);
				}

				if (SUCCEEDED(hrCur) || (dwSafeFlags & SDF_CONTINUE_IF_ERROR))
				{
					HRESULT hrCur2 = S_OK;

					if (pFind->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
					{
						// Recursively delete folder and contents
						// Note that pFind's contents are clobbered by this call
						hrCur2 = SafeDeleteFolderAndContentsHelper(pszCurFile, dwSafeFlags, pFind);
					}
					else
					{
						// Delete the file
						if (!DeleteFile(pszCurFile))
						{
							hrCur2 = GetLastErrorAsHresult();
						}
					}

					if (FAILED(hrCur2))
						hrCur = hrCur2;
				}
			}

			if (FAILED(hrCur))
				hr = hrCur;

			if (FAILED(hr) && !(dwSafeFlags & SDF_CONTINUE_IF_ERROR))
				goto done;

		} while (FindNextFile(hFind, pFind));
		FindClose(hFind);
		hFind = INVALID_HANDLE_VALUE;
	}

	// Delete the folder
	if (!RemoveDirectory(pszFolderToDelete))
	{
		if (SUCCEEDED(hr))
			hr = GetLastErrorAsHresult();
	}

done:
	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);
	SafeFileFree(pszCurFile);
	return hr;
}


// SafeDeleteFolderAndContents [public]
//
//		Deletes the given folder and all of its contents, but refuses to walk
//		across reparse points.
//
HRESULT WINAPI SafeDeleteFolderAndContents
	(
		IN LPCTSTR pszFolderToDelete,  // full path of folder to delete
		IN DWORD   dwSafeFlags         // zero or more SDF_* flags
	)
{
	HRESULT hr = E_INVALIDARG;

	if (!pszFolderToDelete || !(*pszFolderToDelete) ||
		(dwSafeFlags & ~(SDF_ALLOW_NETWORK_DRIVE | SDF_DELETE_READONLY_FILES | SDF_CONTINUE_IF_ERROR)))
	{
		goto done;  // hr already set to E_INVALIDARG
	}

	//
	// Ensure it's a full path, but not the root of a drive
	//
	int cchDrivePart;
	if (!SkipPathDrivePart(pszFolderToDelete, &cchDrivePart, NULL, NULL) ||
		pszFolderToDelete[cchDrivePart] == _T('\0'))
	{
		hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
		goto done;
	}

	//
	// Ensure we're not deleting from a network drive unless allowed
	//
	if (FAILED(hr = CheckValidDriveType(pszFolderToDelete, (dwSafeFlags & SDF_ALLOW_NETWORK_DRIVE), TRUE)))
	{
		goto done;
	}

	//
	// Ensure starting point is not a reparse point
	//
	DWORD dwReparseType;
	if (FAILED(hr = GetReparsePointType(pszFolderToDelete, &dwReparseType)) ||
		FAILED(hr = CheckReparsePointPermissions(dwReparseType)))
	{
		goto done;
	}

	WIN32_FIND_DATA Find;
	hr = SafeDeleteFolderAndContentsHelper(pszFolderToDelete, dwSafeFlags, &Find);

done:
	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafeFileCheckForReparsePoint [public]
//
//		Checks a subset of the given filename's component parts to ensure that
//		they are not reparse points (specifically, volume mount points or
//		junction points: see linkd.exe and mountvol.exe).
//
//		Normal return values are S_OK or HRESULT_FROM_WIN32(ERROR_REPARSE_TAG_MISMATCH).
//		Other values may be returned in exceptional cases such as out-of-memory.
//
HRESULT WINAPI SafeFileCheckForReparsePoint
	(
		IN LPCTSTR pszFileName,           // full path of a file
		IN int     nFirstUntrustedOffset, // char offset of first path component to check
		IN DWORD   dwSafeFlags            // zero or more SRP_* flags
	)
{
	HRESULT hr = E_INVALIDARG;
	LPTSTR pszMutableFileName = NULL;

	// BLOCK
	{
		if (!pszFileName || (dwSafeFlags & ~SRP_FILE_MUST_EXIST))
		{
			goto done;  // hr is already E_INVALIDARG
		}

		int cchFileName = lstrlen(pszFileName);
		if ((UINT)nFirstUntrustedOffset >= (UINT)cchFileName) // bad offset, or zero-length filename
		{
			goto done;  // hr is already E_INVALIDARG
		}

		pszMutableFileName = (LPTSTR)SafeFileMalloc(sizeof(TCHAR) * (cchFileName+1));
		if (!pszMutableFileName)
		{
			hr = E_OUTOFMEMORY;
			goto done;
		}
		StringCchCopy(pszMutableFileName, cchFileName+1, pszFileName);

		//
		// Always consider the drive part of the path to be trusted
		//
		int cchDrivePart;
		if (!SkipPathDrivePart(pszMutableFileName, &cchDrivePart, NULL, NULL))
		{
			hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
			goto done;
		}
		if (nFirstUntrustedOffset < cchDrivePart)
			nFirstUntrustedOffset = cchDrivePart;

		//
		// Validate left-to-right, starting after trusted base path
		//
		LPTSTR pszNextComponent = pszMutableFileName + nFirstUntrustedOffset;
		BOOL fMoreComponents = TRUE;
		do
		{
			//
			// Advance pszNextComponent; truncate after current path component
			//
			fMoreComponents = MyPathFindNextComponent(pszNextComponent, TRUE, (LPCTSTR*)&pszNextComponent);
			TCHAR chSave = *(pszNextComponent-1);
			if (fMoreComponents)
			{
				*(pszNextComponent-1) = _T('\0');
			}

			// Get reparse point type of truncated string, and undo the truncation
			DWORD dwReparseType;
			if (FAILED(hr = GetReparsePointType(pszMutableFileName, &dwReparseType)))
				goto done;
			*(pszNextComponent-1) = chSave;

			// Check for forbidden reparse point type, e.g. mounted drive
			if (FAILED(hr = CheckReparsePointPermissions(dwReparseType)))
				goto done;
		}
		while (fMoreComponents);

	} // end BLOCK

done:
	SafeFileFree(pszMutableFileName);

	// Ignore file-not-found errors, if requested in dwSafeFlags
	if (!(dwSafeFlags & SRP_FILE_MUST_EXIST) &&
	    (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
	     hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)))
	{
		hr = S_OK;
	}

	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafePathCombine [public]
//
//		Combines a path and filename, ensuring exactly one backslash between them.
//		The second "untrusted" half of the path is checked to ensure that it is
//		safe (doesn't contain ".." or ":", or point to existing reparse points).
//
//		File-not-found errors are ignored unless SPC_FILE_MUST_EXIST flag is specified.
//
//		It's ok for the base path and the output buffer to point to the same buffer.
//
//		Returns S_OK if successful, or an appropriate error code if not.
//
HRESULT WINAPI SafePathCombine
	(
		OUT LPTSTR  pszBuf,               // buffer where combined path will be stored
		IN  int     cchBuf,               // size of output buffer, in TCHARs
		IN  LPCTSTR pszTrustedBasePath,   // first half of path, all trusted
		IN  LPCTSTR pszUntrustedFileName, // second half of path, not trusted
		IN  DWORD   dwSafeFlags           // zero or more SPC_* flags
	)
{
	HRESULT hr = E_INVALIDARG;

	if (!pszBuf || cchBuf <= 0 || !pszTrustedBasePath || !pszUntrustedFileName ||
		(dwSafeFlags & ~(SPC_FILE_MUST_EXIST | SPC_ALLOW_ALTERNATE_STREAM)))
	{
		goto done;  // hr is already E_INVALIDARG
	}

	// BLOCK
	{
		int cchBasePath = lstrlen(pszTrustedBasePath);
		int cchFileName = lstrlen(pszUntrustedFileName);
		if (cchBasePath == 0 || cchFileName == 0)
		{
			goto done;  // hr is already E_INVALIDARG
		}

		// Ensure nothing bogus in the untrusted part of the filename
		if (DoesPathContainDotDot(pszUntrustedFileName))
		{
			hr = ERROR_BAD_PATHNAME;
			goto done;
		}

		if (!(dwSafeFlags & SPC_ALLOW_ALTERNATE_STREAM) &&
			DoesPathContainStreamSyntax(pszUntrustedFileName))
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
			goto done;
		}

		//
		// Ensure room for the "\" that will be inserted.
		//
		int cchInsertSlash = 0;
		if (!IsSlashOrBackslash(pszTrustedBasePath[cchBasePath-1]))
		{
			cchInsertSlash = 1;
		}
		if (cchBasePath + cchInsertSlash + cchFileName >= cchBuf)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			goto done;
		}

		//
		// Build full path with a backslash between
		//
		if (pszBuf != pszTrustedBasePath)
			StringCchCopy(pszBuf, cchBuf, pszTrustedBasePath);
		int cchUsed = cchBasePath;
		if (cchInsertSlash > 0)
		{
			pszBuf[cchUsed++] = _T('\\');
		}
		StringCchCopy(pszBuf + cchUsed, cchBuf - cchUsed, pszUntrustedFileName);

		//
		// Ensure no junctions or volume mount points in untrusted portion
		//
		DWORD dwReparseFlags = (dwSafeFlags & SPC_FILE_MUST_EXIST) ? SRP_FILE_MUST_EXIST : 0;
		hr = SafeFileCheckForReparsePoint(pszBuf, cchUsed, dwReparseFlags);
	}

done:
	if (FAILED(hr) && pszBuf && cchBuf > 0)
		pszBuf[0] = _T('\0');

	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafePathCombineAlloc [public]
//
//		See comments for SafePathCombine. The only difference is that this
//		function allocates a buffer of sufficient size and stores it in the
//		output parameter ppszResult. Caller is responsible for freeing the
//		buffer via SafeFileFree.
//
HRESULT WINAPI SafePathCombineAlloc
	(
		OUT LPTSTR* ppszResult,           // ptr to newly alloc'd buffer stored here
		IN  LPCTSTR pszTrustedBasePath,   // first half of path, all trusted
		IN  LPCTSTR pszUntrustedFileName, // second half of path, not trusted
		IN  DWORD   dwSafeFlags           // zero or more SPC_* flags
	)
{
	HRESULT hr = E_INVALIDARG;

	ASSERT(ppszResult);
	*ppszResult = NULL;

	if (!pszTrustedBasePath || !pszUntrustedFileName)
	{
		goto done; // hr already set to E_INVALIDARG
	}

	// Allocate room for the max possible length (includes room for "\" between parts)
	int cchMaxNeeded = lstrlen(pszTrustedBasePath) + lstrlen(pszUntrustedFileName) + 2;
	LPTSTR pszResult = (LPTSTR)SafeFileMalloc(sizeof(TCHAR) * cchMaxNeeded);
	if (!pszResult)
	{
		hr = E_OUTOFMEMORY;
		goto done;
	}

	hr = SafePathCombine(pszResult, cchMaxNeeded, pszTrustedBasePath, pszUntrustedFileName, dwSafeFlags);
	if (FAILED(hr))
	{
		SafeFileFree(pszResult);
	}
	else
	{
		*ppszResult = pszResult;
	}

done:
	ASSERT(hr != E_INVALIDARG);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\wusafefn\safecs.cpp ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    safecs.cpp

Abstract:
    Implements a safe InitializeCriticalSection (usable on all supported platforms)

******************************************************************************/

#include "stdafx.h"

BOOL WINAPI WUInitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpcs, DWORD dwSpinCount)
{
	OSVERSIONINFO osvinfo;
	ZeroMemory(&osvinfo, sizeof(osvinfo));
	osvinfo.dwOSVersionInfoSize = sizeof(osvinfo);

	if (!GetVersionEx(&osvinfo))
	{
		return FALSE;
	}

	typedef BOOL (WINAPI* PROC_InitializeCriticalSectionAndSpinCount)(LPCRITICAL_SECTION, DWORD);
	PROC_InitializeCriticalSectionAndSpinCount pfnInitCS = 
		(PROC_InitializeCriticalSectionAndSpinCount)GetProcAddress(
			GetModuleHandle(_T("kernel32.dll")), "InitializeCriticalSectionAndSpinCount");
	//
	// Don't use InitializeCriticalSectionAndSpinCount on Win9x.
	// It exists but returns VOID (it's a thunk to InitializeCriticalSection).
	//
	if (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT && pfnInitCS != NULL)
	{
		return (*pfnInitCS)(lpcs, dwSpinCount);
	}
	else
	{
		BOOL fSuccess = TRUE;
		__try
		{
			InitializeCriticalSection(lpcs);
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			fSuccess = FALSE;
		}

		return fSuccess;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\wusafefn\stdafx.h ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    StdAfx.h
	
Abstract:
    precompiled header

******************************************************************************/

#pragma once

#define _WIN32_WINNT 0x0500  // some functionality is Win2000+ only

#include <windows.h>
#include <tchar.h>
#include <wusafefn.h>
#include <iucommon.h>
#include <mistsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\wusafefn\sources.inc ===
MAJORCOMP=windows.com
MINORCOMP=lib.wusafefn

TARGETNAME=wusafefn
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

PRECOMPILED_INCLUDE=..\StdAfx.h
PRECOMPILED_CXX=1

CHICAGO_PRODUCT=1

!IF "$(NTDEBUG)" != "ntsdnodbg"
DEBUG_CRTS=1
C_DEFINES = $(C_DEFINES) -D_DEBUG
MSC_OPTIMIZATION=/Od
!ENDIF

INCLUDES= \
        $(INCLUDES); \
        ..; \
        ..\..\..\inc; \

SOURCES= \
        ..\safecs.cpp \
        ..\safefile.cpp \
        ..\safelib.cpp \
        ..\safepath.cpp \
        ..\safereg.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\wusafefn\safelib.cpp ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    safelib.cpp

Abstract:
    Implements LoadLibraryFromSystemDir function

******************************************************************************/

#include "stdafx.h"


// **************************************************************************
static 
BOOL UseFullPath(void)
{
    static BOOL s_fUseFullPath = TRUE;
    static BOOL s_fInit        = FALSE;

    OSVERSIONINFO   osvi;

    if (s_fInit)
        return s_fUseFullPath;

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (GetVersionEx(&osvi))
    {
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
            (osvi.dwMajorVersion > 5 ||
             (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion >= 1)))
        {
            s_fUseFullPath = FALSE;
        }

        s_fInit = TRUE;
    }

    return s_fUseFullPath;
}

// **************************************************************************
HMODULE WINAPI LoadLibraryFromSystemDir(LPCTSTR szModule)
{
    HRESULT hr = NOERROR;
    HMODULE hmod = NULL;
    TCHAR   szModulePath[MAX_PATH + 1];

    if (szModule == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    if (UseFullPath())
    {
        DWORD cch;

        // if the function call fails, make the buffer an empty string, so 
        //  we will just use the dll name in the append below.
        cch = GetSystemDirectory(szModulePath, ARRAYSIZE(szModulePath));
        if (cch == 0 || cch >= ARRAYSIZE(szModulePath))
            szModulePath[0] = _T('\0');
    }
    else
    {
        szModulePath[0] = _T('\0');
    }

    hr = PathCchAppend(szModulePath, ARRAYSIZE(szModulePath), szModule);
    if (FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        goto done;
    }

    hmod = LoadLibraryEx(szModulePath, NULL, 0);
    if (hmod == NULL)
        goto done;

done:
    return hmod;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\wusafefn\safereg.cpp ===
//
// SafeReg.cpp
//
//		Functions to ensure strings read from the registry are null-terminated.
//
// History:
//
//		2002-03-20  KenSh     Created
//
// Copyright (c) 2002 Microsoft Corporation
//

#include "stdafx.h"
#include "SafeReg.h"


// SafeRegQueryValueCchHelper [private]
//
//		Implementation of both "safe" kinds of string registry reads.
//
static HRESULT SafeRegQueryValueCchHelper
	(
		IN DWORD dwExpectedType,
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize,
		OUT OPTIONAL BOOL* pfExpandSz
	)
{
	HRESULT hr = S_OK;
	int cchValueSize = 0;
	BOOL fExpandSz = FALSE;

	// BLOCK
	{
		if ((!pszBuf && cchBuf != 0) || cchBuf < 0) // note: pszValueName can be null
		{
			hr = E_INVALIDARG;
			goto done;
		}

		DWORD dwType;
		DWORD cbData = cchBuf * sizeof(TCHAR);
		DWORD dwResult = RegQueryValueEx(
							hkey, pszValueName, NULL, &dwType, (LPBYTE)pszBuf, &cbData);
		if (dwResult != ERROR_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(dwResult);
		}
		else if (!pszBuf && cbData > 0)
		{
			hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
		}

		if (SUCCEEDED(hr))
		{
			fExpandSz = (dwType == REG_EXPAND_SZ);

			if ((dwType != dwExpectedType) &&
			    !(dwExpectedType == REG_SZ && dwType == REG_EXPAND_SZ))
			{
				hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
			}
		}

		if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA))
		{
			// Add 1-2 extra chars in case the registry data is not big enough.
			cchValueSize = cbData / sizeof(TCHAR);
			cchValueSize += (dwExpectedType == REG_MULTI_SZ) ? 2 : 1;
		}
		else if (SUCCEEDED(hr))
		{
			cchValueSize = cbData / sizeof(TCHAR);

			// check for lack of null-termination
			if (cchValueSize == 0 || pszBuf[cchValueSize-1] != _T('\0'))
				cchValueSize++;

			// check for lack of double null-termination (multi-sz only)
			if (dwExpectedType == REG_MULTI_SZ && (cchValueSize < 2 || pszBuf[cchValueSize-2] != _T('\0')))
				cchValueSize++;

			// check for overflow
			if (cchValueSize > cchBuf)
			{
				hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
			}
			else
			{
				cchValueSize--;  // when successful, count doesn't include trailing null
				pszBuf[cchValueSize] = _T('\0');

				if (dwExpectedType == REG_MULTI_SZ)
					pszBuf[cchValueSize-1] = _T('\0');
			}
		}
	} // end BLOCK

done:
	if (FAILED(hr) && pszBuf && cchBuf > 0)
		pszBuf[0] = _T('\0');
	if (pcchValueSize)
		*pcchValueSize = cchValueSize;
	if (pfExpandSz)
		*pfExpandSz = fExpandSz;

	return hr;
}


// SafeRegQueryValueCchAllocHelper [private]
//
//		Implementation of the 2 "alloc" versions of the safe reg string functions.
//
HRESULT WINAPI SafeRegQueryValueCchAllocHelper
	(
		IN DWORD dwExpectedType,
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize,
		OUT OPTIONAL BOOL* pfExpandSz
	)
{
	LPTSTR pszResult = NULL;
	int cchValueSize = 0;
	BOOL fExpandSz = FALSE;
	HRESULT hr = E_INVALIDARG;

	// BLOCK
	{
		if (!ppszBuf)
		{
			goto done;  // hr is already E_INVALIDARG
		}

		DWORD cbNeeded = 0;
		DWORD dwErr = RegQueryValueEx(hkey, pszValueName, NULL, NULL, NULL, &cbNeeded);
		if (dwErr != 0 && dwErr != ERROR_MORE_DATA)
		{
			hr = HRESULT_FROM_WIN32(dwErr);
			goto done;
		}

		int cchBuf = (cbNeeded / sizeof(TCHAR)) + 2;
		pszResult = (LPTSTR)SafeRegMalloc(sizeof(TCHAR) * cchBuf);
		if (!pszResult)
		{
			hr = E_OUTOFMEMORY;
			goto done;
		}

		hr = SafeRegQueryValueCchHelper(dwExpectedType, hkey, pszValueName, pszResult, cchBuf, &cchValueSize, &fExpandSz);
	}

done:
	if (FAILED(hr))
	{
		SafeRegFree(pszResult);
		pszResult = NULL;
	}

	if (ppszBuf)
		*ppszBuf = pszResult;
	if (pcchValueSize)
		*pcchValueSize = cchValueSize;
	if (pfExpandSz)
		*pfExpandSz = fExpandSz;

	return hr;
}


// SafeRegQueryStringValueCch [public]
//
//		Reads a string out of the registry and ensures the result is null-
//		terminated. Optionally returns the number of characters retrieved,
//		excluding the trailing null.
//
//		If the buffer is not big enough, the function returns REG_E_MORE_DATA
//		and stores the required size, in characters, in the pcchValueSize
//		parameter (including room for the trailing null). Note that the size
//		returned may be bigger than the actual size of the data in the registry.
//
HRESULT WINAPI SafeRegQueryStringValueCch
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize, // S_OK: chars written, excluding trailing null
		                                 // REG_E_MORE_DATA: required size, including null
		OUT OPTIONAL BOOL* pfExpandSz    // TRUE if reg string is actually REG_EXPAND_SZ
	)
{
	return SafeRegQueryValueCchHelper(REG_SZ, hkey, pszValueName, pszBuf, cchBuf, pcchValueSize, pfExpandSz);
}

HRESULT WINAPI SafeRegQueryStringValueCb
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cbBuf,
		OUT OPTIONAL int* pcbValueSize, // S_OK: bytes written, excluding trailing null
		                                // REG_E_MORE_DATA: required size, including null
		OUT OPTIONAL BOOL* pfExpandSz   // TRUE if reg string is actually REG_EXPAND_SZ
	)
{
	int cchBuf = cbBuf / sizeof(TCHAR); // note: odd #'s for cbBuf are rounded down
	HRESULT hr = SafeRegQueryValueCchHelper(REG_SZ, hkey, pszValueName, pszBuf, cchBuf, pcbValueSize, pfExpandSz);
	if (pcbValueSize)
		*pcbValueSize *= sizeof(TCHAR);
	return hr;
}


// SafeRegQueryMultiStringValueCch [public]
//
//		Reads a multi-string out of the registry and ensures the result is double
//		null-terminated. Optionally returns the number of characters retrieved,
//		excluding the second trailing NULL.
//
//		If the buffer is not big enough, the function returns REG_E_MORE_DATA
//		and stores the required size, in characters, in the pcchValueSize
//		parameter (including room for the trailing nulls). Note that the size
//		returned may be bigger than the actual size of the data in the registry.
//
HRESULT WINAPI SafeRegQueryMultiStringValueCch
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cchBuf,
		OUT OPTIONAL int* pcchValueSize // S_OK: chars written, excluding final trailing null
		                                // REG_E_MORE_DATA: required size, including nulls
	)
{
	return SafeRegQueryValueCchHelper(REG_MULTI_SZ, hkey, pszValueName, pszBuf, cchBuf, pcchValueSize, NULL);
}

HRESULT WINAPI SafeRegQueryMultiStringValueCb
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR pszBuf,
		IN int cbBuf,
		OUT OPTIONAL int* pcbValueSize // S_OK: bytes written, excluding final trailing null
		                               // REG_E_MORE_DATA: required size, including nulls
	)
{
	int cchBuf = cbBuf / sizeof(TCHAR); // note: odd #'s for cbBuf are rounded down
	HRESULT hr = SafeRegQueryValueCchHelper(REG_MULTI_SZ, hkey, pszValueName, pszBuf, cchBuf, pcbValueSize, NULL);
	if (pcbValueSize)
		*pcbValueSize *= sizeof(TCHAR);
	return hr;
}

// SafeRegQueryStringValueCchAlloc [public]
//
//		Allocates room for the registry string via SafeRegMalloc, and returns
//		the resulting string. Caller should free via SafeRegFree.
//
HRESULT WINAPI SafeRegQueryStringValueCchAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize, // chars written, excluding trailing null
		OUT OPTIONAL BOOL* pfExpandSz    // TRUE if reg string is actually REG_EXPAND_SZ
	)
{
	return SafeRegQueryValueCchAllocHelper(REG_SZ, hkey, pszValueName, ppszBuf, pcchValueSize, pfExpandSz);
}

HRESULT WINAPI SafeRegQueryStringValueCbAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcbValueSize, // bytes written, excluding trailing null
		OUT OPTIONAL BOOL* pfExpandSz   // TRUE if reg string is actually REG_EXPAND_SZ
	)
{
	HRESULT hr = SafeRegQueryValueCchAllocHelper(REG_SZ, hkey, pszValueName, ppszBuf, pcbValueSize, pfExpandSz);
	if (pcbValueSize)
		*pcbValueSize *= sizeof(TCHAR);
	return hr;
}

// SafeRegQueryMultiStringValueCchAlloc [public]
//
//		Allocates room for the registry string via SafeRegMalloc, and returns
//		the resulting string. Caller should free via SafeRegFree.
//
HRESULT WINAPI SafeRegQueryMultiStringValueCchAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcchValueSize // chars written, excluding final trailing null
	)
{
	return SafeRegQueryValueCchAllocHelper(REG_MULTI_SZ, hkey, pszValueName, ppszBuf, pcchValueSize, NULL);
}

HRESULT WINAPI SafeRegQueryMultiStringValueCbAlloc
	(
		IN HKEY hkey,
		IN LPCTSTR pszValueName,
		OUT LPTSTR* ppszBuf,
		OUT OPTIONAL int* pcbValueSize // bytes written, excluding final trailing null
	)
{
	HRESULT hr = SafeRegQueryValueCchAllocHelper(REG_MULTI_SZ, hkey, pszValueName, ppszBuf, pcbValueSize, NULL);
	if (pcbValueSize)
		*pcbValueSize *= sizeof(TCHAR);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\lib\wusafefn\safepath.cpp ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    safepath.cpp

Abstract:
    Implements safe path function

******************************************************************************/

#include "stdafx.h"
#include <shlwapi.h>

// We use a little C++ precompiler trick to be able to code both ANSI & Unicode
//  versions of the below functions in the same file with only one copy of the 
//  source code.  This is what all the 'X' suffixes below are doing.  
// During the first pass through the source file, we build ANSI source code. 
//  When we reach the bottom, we define a symbol & #include this source file,
//  causing it to be compiled again.  However, in this second pass, the symbol
//  we defined causes it to be compiled as Unicode.

#undef XCHAR
#undef _X
#undef LPXSTR
#undef LPCXSTR
#undef StringCchCatExX
#undef StringCchCopyExX
#undef StringCchCopyNExX
#undef PathCchAppendX
#undef PathCchCombineX
#undef PathCchAddBackslashX
#undef PathCchAddExtensionX
#undef PathCchRenameExtensionX
#undef PathCchCanonicalizeX
#undef lstrlenX
#undef PathIsRelativeX
#undef PathIsRootX
#undef PathIsUNCX
#undef PathStripToRootX
#undef PathFindExtensionX
#undef StrChrX
#undef StrRChrX
#undef c_szDotExeX
#undef WUGetPCEndX
#undef WUGetPCStartX
#undef WUNearRootFixupsX

#if defined(SAFEPATH_UNICODEPASS)

static const WCHAR c_szDotExeW[] = L".exe";

// define Unicode versions
#define XCHAR                   WCHAR
#define _X(ch)                  L ## ch
#define LPXSTR                  LPWSTR
#define LPCXSTR                 LPCWSTR
#define StringCchCatExX         StringCchCatExW
#define StringCchCopyExX        StringCchCopyExW
#define StringCchCopyNExX       StringCchCopyNExW
#define PathCchAppendX          PathCchAppendW
#define PathCchCombineX         PathCchCombineW
#define PathCchAddBackslashX    PathCchAddBackslashW
#define PathCchAddExtensionX    PathCchAddExtensionW
#define PathCchRenameExtensionX PathCchRenameExtensionW
#define PathCchCanonicalizeX    PathCchCanonicalizeW
#define PathIsRelativeX         PathIsRelativeW
#define PathIsRootX             PathIsRootW
#define PathIsUNCX              PathIsUNCW
#define PathStripToRootX        PathStripToRootW
#define PathFindExtensionX      PathFindExtensionW
#define StrChrX                 StrChrW
#define StrRChrX                StrRChrW
#define lstrlenX                lstrlenW
#define c_szDotExeX             c_szDotExeW
#define WUGetPCEndX             WUGetPCEndW
#define WUGetPCStartX           WUGetPCStartW
#define WUNearRootFixupsX       WUNearRootFixupsW

#else

static const CHAR  c_szDotExeA[] = ".exe";

// define ANSI versions
#define XCHAR                   char
#define _X(ch)                  ch
#define LPXSTR                  LPSTR
#define LPCXSTR                 LPCSTR
#define StringCchCatExX         StringCchCatExA
#define StringCchCopyExX        StringCchCopyExA
#define StringCchCopyNExX       StringCchCopyNExA
#define PathCchAppendX          PathCchAppendA
#define PathCchCombineX         PathCchCombineA
#define PathCchAddBackslashX    PathCchAddBackslashA
#define PathCchAddExtensionX    PathCchAddExtensionA
#define PathCchRenameExtensionX PathCchRenameExtensionA
#define PathCchCanonicalizeX    PathCchCanonicalizeA
#define PathIsRelativeX         PathIsRelativeA
#define PathIsRootX             PathIsRootA
#define PathIsUNCX              PathIsUNCA
#define PathStripToRootX        PathStripToRootA
#define PathFindExtensionX      PathFindExtensionA
#define StrChrX                 StrChrA
#define StrRChrX                StrRChrA
#define lstrlenX                lstrlenA
#define c_szDotExeX             c_szDotExeA
#define WUGetPCEndX             WUGetPCEndA
#define WUGetPCStartX           WUGetPCStartA
#define WUNearRootFixupsX       WUNearRootFixupsA

#endif


#define SAFEPATH_STRING_FLAGS (MISTSAFE_STRING_FLAGS | STRSAFE_NO_TRUNCATION)
#define CH_WHACK _X('\\')

//////////////////////////////////////////////////////////////////////////////
// Utility functions

// **************************************************************************
// Return a pointer to the end of the next path componenent in the string.
//  ie return a pointer to the next backslash or terminating NULL.
static inline
LPCXSTR WUGetPCEndX(LPCXSTR pszStart)
{
    LPCXSTR pszEnd;
    pszEnd = StrChrX(pszStart, CH_WHACK);
    if (pszEnd == NULL)
        pszEnd = pszStart + lstrlenX(pszStart);
    return pszEnd;
}

// **************************************************************************
// Given a pointer to the end of a path component, return a pointer to
//  its begining.
//  ie return a pointer to the previous backslash (or start of the string).
static inline
LPXSTR WUGetPCStartX(LPXSTR pszStart, LPCXSTR pszCurrent)
{
    LPXSTR pszBegin;
    pszBegin = StrRChrX(pszStart, pszCurrent, CH_WHACK);
    if (pszBegin == NULL)
        pszBegin = pszStart;
    return pszBegin;
}

// **************************************************************************
// Fix up a few special cases so that things roughly make sense.
static inline
void WUNearRootFixupsX(LPXSTR pszPath, DWORD cchPath, BOOL fUNC)
{
    // Empty path?
    if (cchPath > 1 && pszPath[0] == _X('\0'))
    {
        pszPath[0] = CH_WHACK;
        pszPath[1] = _X('\0');
    }
    
    // Missing slash?  (In the case of ANSI, be sure to check if the first 
    //  character is a lead byte
    else if (cchPath > 3 && 
#if !defined(SAFEPATH_UNICODEPASS)
             IsDBCSLeadByte(pszPath[0]) == FALSE && 
#endif
             pszPath[1] == _X(':') && pszPath[2] == _X('\0'))
    {
        pszPath[2] = _X('\\');
        pszPath[3] = _X('\0');
    }
    
    // UNC root?
    else if (cchPath > 2 && 
             fUNC && 
             pszPath[0] == _X('\\') && pszPath[1] == _X('\0'))
    {
        pszPath[1] = _X('\\');
        pszPath[2] = _X('\0');
    }
}

// **************************************************************************
static inline
LPXSTR AllocNewDest(LPXSTR pszDest, DWORD cchDest, LPXSTR *ppchDest, LPXSTR *ppszMax)
{
    HRESULT hr;
    LPXSTR  pszNewDest = NULL;
    DWORD   cchToCopy;

    pszNewDest = (LPXSTR)HeapAlloc(GetProcessHeap(), 0, cchDest * sizeof(XCHAR));
    if (pszNewDest == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    cchToCopy = (DWORD)(DWORD_PTR)(*ppchDest - pszDest);

    hr = StringCchCopyNExX(pszNewDest, cchDest, pszDest, cchToCopy,
                           NULL, NULL, SAFEPATH_STRING_FLAGS);
    if (FAILED(hr))
    {
        HeapFree(GetProcessHeap(), 0, pszNewDest);
        SetLastError(HRESULT_CODE(hr));
        pszNewDest = NULL;
        goto done;
    }

    *ppchDest = pszNewDest + cchToCopy;
    *ppszMax  = pszNewDest + cchDest - 1;

done:
    return pszNewDest;
}

//////////////////////////////////////////////////////////////////////////////
// Exported functions

// **************************************************************************
HRESULT PathCchCanonicalizeX(LPXSTR pszDest, DWORD cchDest, LPCXSTR pszSrc)
{
    HRESULT hr = NOERROR;
    LPCXSTR pchSrc, pchPCEnd;
    LPXSTR  pszMax = pszDest + cchDest - 1;
    LPXSTR  pchDest;
    LPXSTR  pszDestReal = pszDest;
    DWORD   cchPC;
    BOOL    fUNC, fRoot;

    if (pszDest == NULL || cchDest == 0 || pszSrc == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    pchSrc  = pszSrc;
    pchDest = pszDestReal;
    
    // Need to keep track of whether we have a UNC path so we can potentially
    //  fix it up below
    fUNC = PathIsUNCX(pszSrc);

    while (*pchSrc != _T('\0'))
    {
        pchPCEnd = WUGetPCEndX(pchSrc);
        cchPC    = (DWORD)(DWORD_PTR)(pchPCEnd - pchSrc) + 1;

        // is it a backslash?
        if (cchPC == 1 && *pchSrc == CH_WHACK)
        {
            if (pchDest + 1 > pszMax)            
            {
                // source string too big for the buffer.  Put a NULL at the end
                //  to ensure that it is NULL terminated.
                pszDestReal[cchDest - 1] = 0;
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                goto done;
            }

            // Just copy it.
            *pchDest++ = CH_WHACK;
            pchSrc++;
        }

        // ok, how about a dot?
        else if (cchPC == 2 && *pchSrc == _X('.'))
        {
            if (pszDest == pszSrc && pszDestReal == pszDest)
            {
                pszDestReal = AllocNewDest(pszDest, cchDest, &pchDest, &pszMax);
                if (pszDestReal == NULL)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto done;
                }
            }
            
            // Are we at the end?
            if (*(pchSrc + 1) == 0)
            {
                pchSrc++;

                // remove the last slash we copied (if we've copied one), but 
                //  don't make a malformed root
                if (pchDest > pszDestReal && PathIsRootX(pszDestReal) == FALSE)
                    pchDest--;
            }
            else
            {
                pchSrc += 2;
            }
        }

        // any double dots? 
        else if (cchPC == 3 && *pchSrc == _X('.') && *(pchSrc + 1) == _X('.'))
        {
            if (pszDest == pszSrc && pszDestReal == pszDest)
            {
                pszDestReal = AllocNewDest(pszDest, cchDest, &pchDest, &pszMax);
                if (pszDestReal == NULL)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto done;
                }
            }
            
            // make sure we aren't already at the root.  If not, just remove 
            //  the previous path component
            if (PathIsRootX(pszDestReal) == FALSE)
            {
                pchDest = WUGetPCStartX(pszDestReal, pchDest - 1);
            }

            // we are at the root- however, we must make sure to skip the 
            //  backslash at the end of the ..\ so we don't copy another
            //  one (otherwise, C:\..\FOO would become C:\\FOO)
            else
            {
                if (*(pchSrc + 2) == CH_WHACK)
                    pchSrc++;
            }

            // skip ".."
            pchSrc += 2;       
        }

        // just choose 'none of the above'...
        else
        {
            if (pchDest != pchSrc)
            {
                DWORD cchAvail;
                
                cchAvail = cchDest - (DWORD)(DWORD_PTR)(pchDest - pszDestReal);

                hr = StringCchCopyNExX(pchDest, cchAvail, pchSrc, cchPC,
                                       NULL, NULL, SAFEPATH_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;
            }
            
            pchDest += (cchPC - 1);
            pchSrc  += (cchPC - 1);
        }

        // make sure we always have a NULL terminated string
        if (pszDestReal != pszSrc) 
            *pchDest = _X('\0');
    }

    // Check for weirdo root directory stuff.
    WUNearRootFixupsX(pszDestReal, cchDest, fUNC);

    if (pszDest != pszDestReal)
    {
        hr = StringCchCopyExX(pszDest, cchDest, pszDestReal, 
                              NULL, NULL, SAFEPATH_STRING_FLAGS);
    }

done:
    if (pszDest != pszDestReal && pszDestReal != NULL)
        HeapFree(GetProcessHeap(), 0, pszDestReal);
    
    return hr;
}

// **************************************************************************
HRESULT PathCchRenameExtensionX(LPXSTR pszPath, DWORD cchPath, LPCXSTR pszExt)
{
    HRESULT hr = NOERROR;
    LPXSTR  pszOldExt;
    DWORD   cchPathWithoutExt;

    if (pszPath == NULL || pszExt == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    // This function returns a pointer to the end of the string if there 
    //  is no extension.  This is exactly what we want cuz we will want
    //  to add an extension to the end of the string if none exists.
    pszOldExt = PathFindExtensionX(pszPath);
    cchPathWithoutExt = (DWORD)(DWORD_PTR)(pszOldExt - pszPath);

    hr = StringCchCopyExX(pszOldExt, cchPath - cchPathWithoutExt, pszExt,
                          NULL, NULL, SAFEPATH_STRING_FLAGS);
done:
    return hr;
}


// **************************************************************************
HRESULT PathCchAddExtensionX(LPXSTR pszPath, DWORD cchPath, LPCXSTR pszExt)
{
    HRESULT hr = NOERROR;
    LPXSTR  pszOldExt;
    
    if (pszPath == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    // since we're *adding* an extension here, don't want to do anything if
    //  one already exists
    pszOldExt  = PathFindExtensionX(pszPath);
    if (*pszOldExt == _T('\0'))
    {
        if (pszExt == NULL)
            pszExt = c_szDotExeX;

        hr = StringCchCatExX(pszPath, cchPath, pszExt, 
                             NULL, NULL, SAFEPATH_STRING_FLAGS);
    }

done:
    return hr;
}

// **************************************************************************
HRESULT PathCchAddBackslashX(LPXSTR pszPath, DWORD cchPathBuff)
{
    HRESULT hr = NOERROR;
    LPCXSTR psz;
    DWORD   cch;

    if (pszPath == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    cch = lstrlenX(pszPath);

    if (cch == 0)
        goto done;

#if defined(SAFEPATH_UNICODEPASS)
    psz = &pszPath[cch - 1];
#else
    psz = CharPrevA(pszPath, &pszPath[cch]);
#endif

    // if the end of the base string does not have a backslash, then add one
    if (*psz != CH_WHACK)
    {
        // make sure we have enough space for the backslash in the buffer
        if (cch + 1 >= cchPathBuff)
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            goto done;
        }
        
        pszPath[cch++] = CH_WHACK;
        pszPath[cch]   = _X('\0');
    }

done:
    return hr;
}




// **************************************************************************
HRESULT PathCchCombineX(LPXSTR pszPath, DWORD cchPathBuff, LPCXSTR pszPrefix, 
                       LPCXSTR pszSuffix)
{
    HRESULT hr = NOERROR;

    if (pszPath == NULL || cchPathBuff == 0)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }


    // if both fields are NULL, just bail now.
    if (pszPrefix == NULL && pszSuffix == NULL)
    {
        pszPath[0] = L'\0';
        goto done;
    }

    if ((pszPrefix == NULL || *pszPrefix == _X('\0')) &&
        (pszSuffix == NULL || *pszSuffix == _X('\0')))
    {
        if (cchPathBuff > 1)
        {
            pszPath[0] = _X('\\');
            pszPath[1] = _X('\0');
        }
        else
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        goto done;
    }

    // if all we have is the suffix, just copy it
    if (pszPrefix == NULL || *pszPrefix == _X('\0'))
    {
        hr = StringCchCopyExX(pszPath, cchPathBuff, pszSuffix, 
                              NULL, NULL, SAFEPATH_STRING_FLAGS);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        // if all we have is the prefix, just copy it
        if (pszSuffix == NULL || *pszSuffix == _X('\0'))
        {
            hr = StringCchCopyExX(pszPath, cchPathBuff, pszPrefix,
                                  NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
        }

        // if we have a relative path for the suffix, then we just combine 
        //  the two and insert a backslash between them if necessary
        else if (PathIsRelativeX(pszSuffix))
        {
            hr = StringCchCopyExX(pszPath, cchPathBuff, pszPrefix,
                                  NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;

            hr = PathCchAddBackslashX(pszPath, cchPathBuff);
            if (FAILED(hr))
                goto done;

            hr = StringCchCatExX(pszPath, cchPathBuff, pszSuffix,
                                 NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
        }

        // if the suffix starts with a backslash then just strip off
        //  everything except for the root of the prefix and append the
        //  suffix
        else if (*pszSuffix == CH_WHACK && PathIsUNCX(pszSuffix) == FALSE)
        {
            hr = StringCchCopyExX(pszPath, cchPathBuff, pszPrefix,
                                  NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;

            // this is safe to call as it will only reduce the size of the
            //  string
            PathStripToRootX(pszPath);

            hr = PathCchAddBackslashX(pszPath, cchPathBuff);
            if (FAILED(hr))
                goto done;

            // make sure to skip the backslash while appending
            hr = StringCchCatExX(pszPath, cchPathBuff, pszSuffix + 1,
                                 NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
        }

        // we'll, likely the suffix is a full path (local or UNC), so
        //  ignore the prefix
        else
        {
            hr = StringCchCopyExX(pszPath, cchPathBuff, pszSuffix, 
                                  NULL, NULL, SAFEPATH_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
        }
    }

    hr = PathCchCanonicalizeX(pszPath, cchPathBuff, pszPath);

done:
    return hr;
}



// **************************************************************************
HRESULT PathCchAppendX(LPXSTR pszPath, DWORD cchPathBuff, LPCXSTR pszNew)
{
    HRESULT hr = NOERROR;
    DWORD   dwOffset = 0;
    DWORD   cch, cchNew;

    if (pszPath == NULL)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
        goto done;
    }

    if (pszNew != NULL)
    {
        // skip all initial backslashes in pszNew
        while (*pszNew == CH_WHACK)
        {
            pszNew++;
        }

        hr = PathCchCombineX(pszPath, cchPathBuff, pszPath, pszNew);

    }
    else
    {
        hr = E_FAIL;
    }
    
done:
    return hr;
}




// make the unicode pass through the file
#if !defined(SAFEPATH_UNICODEPASS)
#define SAFEPATH_UNICODEPASS
#include "safepath.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\include\sysinfo.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   SysInfo.h 
//
//	Description:
//			Gathers system information necessary to do redirect to windows update site.
//
//=======================================================================

const TCHAR NT5_REGPATH_MACHTYPE[]   = _T("HARDWARE\\DESCRIPTION\\System");
const TCHAR NT5_REGKEY_MACHTYPE[]    = _T("Identifier");

const TCHAR REGPATH_WINUPD[]     = _T("Software\\Policies\\Microsoft\\Windows Update");
const TCHAR REGPATH_EXPLORER[]   = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
const TCHAR REGKEY_WINUPD_DISABLED[] = _T("NoWindowsUpdate");

// Internet Connection Wizard settings
const TCHAR REGPATH_CONNECTION_WIZARD[] = 
				_T("SOFTWARE\\Microsoft\\INTERNET CONNECTION WIZARD");
const TCHAR REGKEY_CONNECTION_WIZARD[] = _T("Completed");
#define LANGID_LEN 20

const TCHAR MTS_REDIR_URL[] = _T("http://www.microsoft.com/isapi/redir.dll");
const TCHAR WINDOWS_UPDATE_URL[] = _T("http://windowsupdate.microsoft.com");

bool FWinUpdDisabled(void);

void
vAppendRedirArguments(LPTSTR tszURLPrefix, LPTSTR tszURL);

HRESULT HrGetConnectionStatus(bool *pfConnected);

void vGetWindowsDirectory(LPTSTR tszWinDirectory);

const TCHAR WEB_DIR[] = _T("web\\");

/////////////////////////////////////////////////////////////////////////////
// vGetWebDirectory
//   Get the path to %windir%\web.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

inline void vGetWebDirectory(LPTSTR tszWebDirectory)
{
	vGetWindowsDirectory(tszWebDirectory);

	lstrcat(tszWebDirectory, WEB_DIR);
}

/////////////////////////////////////////////////////////////////////////////
// vLaunchIE
//   Launch IE on the given URL.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

HRESULT vLaunchIE(LPTSTR tszURL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\cathelp.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999  All Rights Reserved.
//
//  File:   CatHelp.cpp 
//
//		contains the Component Category helper functions.
//
//=======================================================================

#include "stdafx.h"

#include "comcat.h"

EXTERN_C const CATID CATID_SafeForScripting;
EXTERN_C const CATID CATID_SafeForInitializing;

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\lib\sysinfo.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   SysInfo.cpp 
//
// Description:
//   Gathers system information necessary to do redirect to windows update site.
//
//=======================================================================

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <windows.h>
#include <shellapi.h>
#include <wininet.h>
#include <ras.h>
#include <ole2.h>
#include <atlbase.h>
#include <exdisp.h>
#include <sysinfo.h>
// 
// Definitions
//
// internationalize
const TCHAR REGKEY_REMOTE_URL[]  = _T("Remote URL");

const TCHAR REGVAL_MACHTYPE_AT[]  = _T("AT/AT COMPATIBLE");
const TCHAR REGVAL_MACHTYPE_NEC[] = _T("NEC PC-98");

// NEC detection based on existence of NEC keyboard
#define	LOOKUP_OEMID(keybdid)     HIBYTE(LOWORD((keybdid)))
#define	PC98_KEYBOARD_ID          0x0D

const TCHAR MACHTYPE_AT[] = _T("at");
const TCHAR MACHTYPE_NEC[] = _T("nec");

#define LANGID_LEN 20
#define SafeFree(x){if(NULL != x){free(x); x = NULL;}}

typedef enum
{
	enAT,
	enNEC,
	enOther
} enumMachineType;

// Minimum OS versions supported by Windows Update
// For NT, it is 5.0 (NT 5)
// for Win9x, it is 4.1	(Win 98)
const DWORD dwNT5MinMajorVer = 5;
const DWORD dwNT5MinMinorVer = 0;
const DWORD dwWin98MinMajorVer = 4;
const DWORD dwWin98MinMinorVer = 1;

/////////////////////////////////////////////////////////////////////////////
// vGetWindowsDirectory
//   Get the path to %windir%\web.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

void vGetWindowsDirectory(LPTSTR tszWinDirectory)
{
	UINT nGetWindowsDirectory = ::GetWindowsDirectory(tszWinDirectory, MAX_PATH);

	if ( nGetWindowsDirectory != 0 )
	{
		if ( tszWinDirectory[lstrlen(tszWinDirectory) - 1] != _T('\\') )
		{
			lstrcat(tszWinDirectory, _T("\\"));
		}
	}
	else
	{
			lstrcpy(tszWinDirectory, _T("C:\\WINNT\\"));
	}
}


/////////////////////////////////////////////////////////////////////////////
// HrGetMachineType
//   Determine whether the machine is of AT or NEC type.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT HrGetMachineType(WORD langid, enumMachineType *penMachineType)
{
	*penMachineType = enAT;


	if ( langid == LANG_JAPANESE )
	{
		HKEY hKey;
		DWORD type;
		TCHAR tszMachineType[50];
		DWORD size = sizeof(tszMachineType);

		// determine if we should log transmissions
		if ( RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
							 NT5_REGPATH_MACHTYPE,
							 0,
							 KEY_QUERY_VALUE,
							 &hKey) == ERROR_SUCCESS )
		{
			if ( RegQueryValueEx(hKey, 
									NT5_REGKEY_MACHTYPE, 
									0, 
									&type,
									(BYTE *)tszMachineType, 
									&size) == ERROR_SUCCESS )
			{
				if ( type == REG_SZ )
				{
					if ( lstrcmpi(tszMachineType, REGVAL_MACHTYPE_NEC) == 0 )
					{
						*penMachineType = enNEC;
					}
				}
			}

			RegCloseKey(hKey);
		}
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// vAppendRedirArguments
//   Append redir arguments to the redir.dll URL.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

void
vAppendRedirArguments(LPTSTR tszURLPrefix, LPTSTR tszURL)
{
	LANGID langidUser = GetUserDefaultLangID();
	LANGID langidMachine = GetSystemDefaultLangID(); 

	enumMachineType enMachineType;

	HrGetMachineType(PRIMARYLANGID(langidMachine), &enMachineType);
	
	wsprintf(tszURL, L"%ws?OLCID=0x%04x&CLCID=0x%04x&OS=%ws", 
							tszURLPrefix,
							langidMachine,
							langidUser,
							(enMachineType == enAT) ? MACHTYPE_AT : MACHTYPE_NEC);
}


/////////////////////////////////////////////////////////////////////////////
// FWinUpdDisabled
//   Determine if corporate administrator has turned off Windows Update via
//	 policy settings.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

bool FWinUpdDisabled(void)
{
	bool fDisabled = false;
	HKEY hKey;
	DWORD dwDisabled;
	DWORD dwSize = sizeof(dwDisabled);
	DWORD dwType;


	if ( RegOpenKeyEx(	HKEY_CURRENT_USER,
						REGPATH_EXPLORER,
						NULL,
						KEY_QUERY_VALUE,
						&hKey) == ERROR_SUCCESS )
	{
		if ( RegQueryValueEx(hKey,
							REGKEY_WINUPD_DISABLED,
							NULL,
							&dwType,
							(LPBYTE)&dwDisabled,
							&dwSize) == ERROR_SUCCESS )
		{
			if ( (dwType == REG_DWORD) && (dwDisabled != 0) )
			{
				fDisabled = true;
			}
		}
	
		RegCloseKey(hKey);
	}

	return fDisabled;
}

//
// FRASConnectoidExists
// Checks to see whether there is a default RAS connectoid.  
// If so, we know we're configured to connect to the Internet
//
bool FRASConnectoidExists()
{
	DWORD cb = 0;
   	DWORD cEntries = 0;
   	DWORD dwRet = 0;
	bool  fRet = false;

	// We have to have a valid structure with the dwSize initialized, but we pass 0 as the size
	// This will return us the correct count of entries (which is all we care about)
	LPRASENTRYNAME lpRasEntryName = (LPRASENTRYNAME) malloc( sizeof(RASENTRYNAME) );
	
    lpRasEntryName->dwSize = sizeof(RASENTRYNAME);

    dwRet = RasEnumEntries( NULL, NULL, lpRasEntryName, &cb, &cEntries );

	 // Check to make sure there's at least one RAS entry
	if(cEntries > 0)
	{
		fRet = true;
	}

	SafeFree(lpRasEntryName );
	return fRet;
}

//
// FICWConnection Exists
// Checks to see whether the "Completed" flag has been set for the ICW.
// as of XP build 2472, this also applies to the Network Connection Wizard
//
bool FICWConnectionExists()
{
	HKEY	hKey = NULL;
	DWORD	dwCompleted = 0;
	DWORD	dwSize = sizeof(dwCompleted);
	DWORD	dwType = 0;
	bool	fRet = false;

	if ( RegOpenKeyEx(	HKEY_CURRENT_USER,
						REGPATH_CONNECTION_WIZARD,
						NULL,
						KEY_QUERY_VALUE,
						&hKey) == ERROR_SUCCESS )
	{
		if ( RegQueryValueEx(hKey,
							REGKEY_CONNECTION_WIZARD,
							NULL,
							&dwType,
							(BYTE *)&dwCompleted,
							&dwSize) == ERROR_SUCCESS )
		{
			if ( ((dwType != REG_DWORD) && (dwType != REG_BINARY)) || 
				 dwCompleted )
			{
				fRet = true;
			}
		}
	
		RegCloseKey(hKey);
	}

	return fRet;
}

bool FIsLanConnection()
{
	DWORD dwConnTypes = 0;

	// We don't care about the return value - we just care whether we get the LAN flag
	(void)InternetGetConnectedState( &dwConnTypes, 0 );

	return (dwConnTypes & INTERNET_CONNECTION_LAN) ? true : false;
}

/////////////////////////////////////////////////////////////////////////////
// HrGetConnectionStatus
//   Determine whether the Internet Connection Wizard has run.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////


HRESULT HrGetConnectionStatus(bool *pfConnected)
{
	// Check to see if there is a default entry in the RAS phone book.  
	// If so, we know this computer has configured a connection to the Internet.
	// We can't tell whether the connection is live, but we can let IE handle prompting to connect.
	*pfConnected = FRASConnectoidExists() ||

    // If there's no default RAS entry, check to see if the user has run the ICW
	// As of build 2472, the Network Connection Wizard sets this same key for both RAS and persistent network connections
	FICWConnectionExists() ||

	// if the user has a LAN connection, we will trust IE's ability to get through
	FIsLanConnection();

	// if *pfConnected is still false at this point, there is no preconfigured Internet connection

	return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
// vLaunchIE
//   Launch IE on URL.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

HRESULT vLaunchIE(LPTSTR tszURL)
{
    IWebBrowser2 *pwb2;

    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( SUCCEEDED(hr) )
    {
    
        hr = CoCreateInstance(CLSID_InternetExplorer, NULL,
                              CLSCTX_LOCAL_SERVER, IID_IWebBrowser2, (LPVOID*)&pwb2);

		if ( SUCCEEDED(hr) )
		{
			USES_CONVERSION;
			BSTR bstrURL = SysAllocString(T2W(tszURL));

			VARIANT varURL;
			varURL.vt = VT_BSTR;
			varURL.bstrVal = bstrURL;

			VARIANT varFlags;
			varFlags.vt = VT_I4;
			varFlags.lVal = 0;

			VARIANT varEmpty;
			VariantInit(&varEmpty);

			hr = pwb2->Navigate2(&varURL, &varFlags, &varEmpty, &varEmpty, &varEmpty);
        
			if ( SUCCEEDED(hr) )
			{
				// check to see if lhwnd should be type of LONG_PTR instead of long in win_64
				LONG_PTR lhwnd = NULL;
				if ( SUCCEEDED(pwb2->get_HWND((LONG_PTR*)&lhwnd)) )
				{
					SetForegroundWindow((HWND)lhwnd);
				}
				hr = pwb2->put_Visible(TRUE);
			}
			pwb2->Release();
		}

		CoUninitialize();
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\cruntime.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   curntime.h
//
//=======================================================================

int atoh(const TCHAR *string);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\cwupd.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   CWUpd.h : Declaration of the CCWUpdInfo
//
//=======================================================================

#ifndef __CWUPDINFO_H_
#define __CWUPDINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCWUpdInfo
class ATL_NO_VTABLE CCWUpdInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCWUpdInfo, &CLSID_CWUpdInfo>,
	public IDispatchImpl<ICWUpdInfo, &IID_ICWUpdInfo, &LIBID_WUPDINFOLib>
{
public:
	CCWUpdInfo()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CWUPDINFO)

BEGIN_COM_MAP(CCWUpdInfo)
	COM_INTERFACE_ENTRY(ICWUpdInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ICWUpdInfo
public:
	STDMETHOD(IsRegistered)(/*[out, retval]*/ VARIANT_BOOL * pfRegistered);
	STDMETHOD(IsConnected)(/*[out, retval]*/ VARIANT_BOOL * pfConnected);
	STDMETHOD(GetPlatform)(/*[out, retval]*/ BSTR * pbstrPlatform);
	STDMETHOD(GetLanguage)(/*[out, retval]*/ BSTR * pbstrLanguage);
	STDMETHOD(GetUserLanguage)(/*[out, retval]*/ BSTR * pbstrUserLanguage);
	STDMETHOD(GetMachineLanguage)(/*[out, retval]*/ BSTR * pbstrMachineLanguage);
	STDMETHOD(GetMTSOEMURL)(/*[out, retval]*/ BSTR *pbstrURL);
	STDMETHOD(GetMTSURL)(BSTR bstrURLArgs, 
						 /*[out, retval]*/ BSTR *pbstrURL);
	STDMETHOD(GotoMTSOEMURL)(/*[out, retval]*/ int *pnRetval);
	STDMETHOD(GotoMTSURL)(/*[in]*/ BSTR bstrURLArgs);
	STDMETHOD(IsDisabled)(/*[out, retval]*/ BOOL *pfDisabled);
	STDMETHOD(GetWinUpdURL)(/*[out, retval]*/ BSTR *pbstrURL);
};

#endif //__CWUPDINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\cruntime.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   cruntime.cpp 
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//=======================================================================

#include "stdafx.h"
#include "cruntime.h"

#define ISHEXDIGIT(c) ((c >= '0' && c <= '9') || ((c&0xDF) >= 'A' && ((c&0xDF) <= 'F')))
#define GETHEXDIGIT(c) ((c<'A') ? (c-0x30) : ((c&0xDF)-0x37))

int atoh(const TCHAR *string)
{
	int iValue = 0;

	while( ISHEXDIGIT(*string) )
	{
		iValue = (iValue << 4) + GETHEXDIGIT(*string);
		string++;
	}

	return iValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\cwupd.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   CWUpd.cpp : Implementation of CCWUpdInfo
//
//=======================================================================

#include "stdafx.h"
#include "WUpdInfo.h"
#include "CWUpd.h"
#include "cruntime.h"
#include "sysinfo.h"
#include "shellapi.h"

/////////////////////////////////////////////////////////////////////////////
// CCWUpdInfo


/////////////////////////////////////////////////////////////////////////////
// CCWUpdInfo::GetWinUpdURL
//   Get the URL to Windows Update. This could be the local or remote URL.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCWUpdInfo::GetWinUpdURL(/*[out, retval]*/ BSTR *pbstrURL)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CCWUpdInfo::IsDisabled
//   Indicates whether the administrator has disabled Windows Update.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCWUpdInfo::IsDisabled(BOOL * pfDisabled)
{

	*pfDisabled = FWinUpdDisabled() ? TRUE : FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// FGetOEMURL
//   Get the OEM ULR from oeminfo.ini.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

bool FGetOEMURL(LPTSTR tszKey, LPTSTR tszURL)
{
	bool fFound = false;
	TCHAR tszLocalFile[MAX_PATH];
	TCHAR tszOEMINFOPath[MAX_PATH];
	

	if ( GetSystemDirectory(tszOEMINFOPath, 
							MAX_PATH) != 0 )
	{
		lstrcat(tszOEMINFOPath, _T("\\oeminfo.ini"));

		DWORD dwGetPrivateProfileString = ::GetPrivateProfileString(
													_T("General"), 
													tszKey, 
													_T(""), 
													tszLocalFile, 
													MAX_PATH, 
													tszOEMINFOPath);

		if ( lstrcmp(tszLocalFile, _T("")) != 0 )
		{
			lstrcpy(tszURL, tszLocalFile);
			fFound = true;
		}
	}

	return fFound;
}


/////////////////////////////////////////////////////////////////////////////
// CCWUpdInfo::GotoMTSURL
//   Launch the default browser to display the MTS URL.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCWUpdInfo::GotoMTSURL(BSTR bstrURLArgs) // prd= arg for redir.dll
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCWUpdInfo::GotoMTSOEMURL
//   Launch the default browser to display the MTS URL.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCWUpdInfo::GotoMTSOEMURL(int * pnRetval)
{
	return E_NOTIMPL;
}


STDMETHODIMP CCWUpdInfo::GetMTSURL(BSTR bstrURLArgs, 
								   /*[out, retval]*/ BSTR *pbstrURL)
{
	return E_NOTIMPL;
}


STDMETHODIMP CCWUpdInfo::GetMTSOEMURL(/*[out, retval]*/ BSTR *pbstrURL)
{
	USES_CONVERSION;
	TCHAR tszURL[MAX_PATH];

	if ( !FGetOEMURL(_T("SupportURL"), tszURL) )
	{
		tszURL[0] = _T('\0');
	}

	*pbstrURL = SysAllocString(T2W(tszURL));

	return S_OK;
}

STDMETHODIMP CCWUpdInfo::GetMachineLanguage(BSTR * pbstrMachineLanguage)
{
	return E_NOTIMPL;
}

STDMETHODIMP CCWUpdInfo::GetUserLanguage(BSTR * pbstrUserLanguage)
{
	return E_NOTIMPL;
}

STDMETHODIMP CCWUpdInfo::GetLanguage(BSTR * pbstrLanguage)
{
    return E_NOTIMPL;
}

STDMETHODIMP CCWUpdInfo::GetPlatform(BSTR * pbstrPlatform)
{
	return E_NOTIMPL;
}

STDMETHODIMP CCWUpdInfo::IsRegistered(VARIANT_BOOL * pfRegistered)
{
	return E_NOTIMPL;
}

STDMETHODIMP CCWUpdInfo::IsConnected(VARIANT_BOOL * pfConnected)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\dlldatax.c ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   dlldatax.c
//			wrapper for dlldata.c
//
//=======================================================================

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "WUpdInfo_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\cathelpp.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999  All Rights Reserved.
//
//  File:   CatHelp.h 
//
//=======================================================================

/////////////////////////////////////////////////////////////////////////////
//
// contains the prototypes for the component category helper functions
//
#include "comcat.h"
#include "cathelp.h"

EXTERN_C const CATID CATID_SafeForScripting;
EXTERN_C const CATID CATID_SafeForInitializing;


#define REGISTER_SERVER_AND_CATID(clsid) \
{                                                                                   \
    HRESULT hr;                                                                     \
                                                                                    \
    /* registers object, typelib and all interfaces in typelib */                   \
    if ( SUCCEEDED(hr =_Module.RegisterServer(TRUE)) &&                             \
         SUCCEEDED(hr = CreateComponentCategory(CATID_SafeForScripting,             \
                        L"Controls that are safely scriptable")) &&                 \
         SUCCEEDED(hr = CreateComponentCategory(CATID_SafeForInitializing,          \
                        L"Controls safely initializable from persistent data")) &&  \
         SUCCEEDED(hr = RegisterCLSIDInCategory(clsid,                              \
                                                CATID_SafeForScripting)) )          \
    {                                                                               \
        hr = RegisterCLSIDInCategory(clsid, CATID_SafeForInitializing);             \
    }                                                                               \
    return hr;                                                                      \
}

#define UNREGISTER_SERVER_AND_CATID(clsid) \
{                                                                                   \
    _Module.UnregisterServer();                                                     \
                                                                                    \
    /* Remove CATID information. */                                                 \
    UnRegisterCLSIDInCategory(clsid, CATID_SafeForScripting);                       \
    UnRegisterCLSIDInCategory(clsid, CATID_SafeForInitializing);                    \
                                                                                    \
    return S_OK;                                                                    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\resource.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   resource.h
//
//=======================================================================
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WUpdInfo.rc
//
#define IDS_PROJNAME                    100
#define IDR_CWUPDINFO                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\dlldatax.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   dlldatax.h
//
//=======================================================================

#if !defined(AFX_DLLDATAX_H__A3863C28_86EB_11D1_A9DB_00C04FB16F9E__INCLUDED_)
#define AFX_DLLDATAX_H__A3863C28_86EB_11D1_A9DB_00C04FB16F9E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__A3863C28_86EB_11D1_A9DB_00C04FB16F9E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\stdafx.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//
//=======================================================================

#if !defined(AFX_STDAFX_H__A3863C20_86EB_11D1_A9DB_00C04FB16F9E__INCLUDED_)
#define AFX_STDAFX_H__A3863C20_86EB_11D1_A9DB_00C04FB16F9E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#include "cathelpp.h"

#endif // !defined(AFX_STDAFX_H__A3863C20_86EB_11D1_A9DB_00C04FB16F9E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\stdafx.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   stdafx.cpp : source file that includes just the standard includes
//			stdafx.pch will be the pre-compiled header
//			stdafx.obj will contain the pre-compiled type information
//
//=======================================================================

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdmgr\resource.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   resource.h
//
//=======================================================================
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by InfoStub.rc
//
#define IDS_FILENOTFOUND                1
#define IDS_CANTACCESS                  2
#define IDS_UNKNOWN                     3
#define IDS_NOEXECUTABLE                4
#define IDS_DESCRIPTION                 5
#define IDS_MEMORY                      6
#define IDS_UNEXPECTED                  7
#define IDS_NOMSCFILE                   8

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdmgr\stubexe.h ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   	StubExe.h
//
//=======================================================================

#include <afxwin.h>

class CMSInfoApp : public CWinApp {
	BOOL	InitInstance();
};

CMSInfoApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdinfo\wupdinfo.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   	WUpdInfo.cpp : Implementation of DLL Exports.
//
// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for WUpdInfo.idl by adding the following 
//		files to the Outputs.
//			WUpdInfo_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f WUpdInfops.mk in the project directory.
//
//=======================================================================

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "WUpdInfo.h"
#include "dlldatax.h"

#include "WUpdInfo_i.c"
#include "CWUpd.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CWUpdInfo, CCWUpdInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    REGISTER_SERVER_AND_CATID(CLSID_CWUpdInfo)
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    UNREGISTER_SERVER_AND_CATID(CLSID_CWUpdInfo)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\aucomres.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    comres.h
//
//  Creator: Weiw
//
//  Purpose: common utility header for auto update
//
//=======================================================================
#pragma once
#include <windows.h>
#include <TCHAR.h>

#define IDC_OPTION1       1000
#define IDC_OPTION2       1001
#define IDC_OPTION3       1002
#define IDC_RESTOREHIDDEN		     1003
#define IDC_CHK_KEEPUPTODATE		1008
#define IDC_CMB_DAYS			1009
#define IDC_CMB_HOURS			1010

#ifdef DBG
const TCHAR DOWNLOAD_FILE[] = _T("downloadresult.xml");
const TCHAR INSTALLRESULTS_FILE[] = _T("InstallResults.xml");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\audirectory.h ===
#pragma once
extern const TCHAR C_DOWNLD_DIR[];
extern TCHAR g_szWUDir[MAX_PATH+1];        //Path to windows update directory

/////////////////////////////////////////////////////////////////////
// audirectory.cpp
/////////////////////////////////////////////////////////////////////
int DelDir(LPCTSTR lpszDir);
int RegExpDelFile(LPCTSTR tszFilePath, LPCTSTR tszFilePattern);

BOOL AUDelFileOrDir(LPCTSTR szFileOrDir);
BOOL CreateWUDirectory(BOOL fGetPathOnly = FALSE);
HRESULT GetDownloadPath(LPTSTR lpszDir, DWORD dwCchSize);
HRESULT MakeTempDownloadDir(LPTSTR  pstrTarget, DWORD dwCchSize);
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, DWORD dwCchSize);
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, DWORD dwCchSize, LANGID langid);
HRESULT GetRTFLocalFileName(BSTR bstrRTFUrl, LPTSTR lpszFileName, DWORD dwCchSize, LANGID langid);
HRESULT GetCabsDownloadPath(LPTSTR lpszDir, DWORD dwCchSize );
BOOL 	EnsureDirExists(LPCTSTR lpDir);
HRESULT	LOGXMLFILE(LPCTSTR szFileName, BSTR bstrMessage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\auregkeys.h ===
#pragma once

#define AUTOUPDATEKEY       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update")
#define TIMEOUTVALUE        TEXT("Timeout")
//#define TIMESTAMPVALUE      TEXT("Timestamp")
#define TIMEOUTSTATE        TEXT("TimeoutState")
//#define INDEXVALUE          TEXT("TimeoutIndex")
//#define DOWNLOADSTOPPED     TEXT("DownloadStopped")
#define LASTWAITTIMEOUT		TEXT("LastWaitTimeout")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\winupd\wupdmgr\wupdmgr.cpp ===
//=======================================================================
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999  All Rights Reserved.
//
//  File:   	WUpdMgr.cpp
//
//  Description:
//		Executable launched from the Windows Update shortcut.
//
//=======================================================================

#include <stdio.h>
#include <tchar.h>

#include <windows.h>
#include <wininet.h> //INTERNET_MAX_URL_LENGTH
#include <shellapi.h>
#include <objbase.h>
#include <shlobj.h>

#include "sysinfo.h"
#include "msg.h"
#include <atlbase.h>
#include <atlconv.cpp>

// Definitions
const TCHAR DEFAULT_WINUPD_LOCAL_FILE[] = _T("wum.htm");
const TCHAR HELPCENTER_WINUPD_URL[] = _T("hcp://system/updatectr/updatecenter.htm");

 
/////////////////////////////////////////////////////////////////////////////
// vShowMessageBox
//   Display an error in a message box.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

void vShowMessageBox(DWORD dwMessageId)
{
	LPTSTR tszMsg;
	
	DWORD dwResult = 
		FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
						FORMAT_MESSAGE_FROM_HMODULE,
						NULL,
						dwMessageId,
						0,
						(LPTSTR)&tszMsg,
						0,
						NULL);

	// if we can't get the message, we don't do anything.
	if ( dwResult != 0 )
	{
		MessageBox(NULL,
				   tszMsg,
				   NULL,
				   MB_OK | MB_ICONEXCLAMATION);

		LocalFree(tszMsg);
	}
}


/////////////////////////////////////////////////////////////////////////////
// main
//   Entry point.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char **argv)
{
	int nReturn = 0;

	if ( FWinUpdDisabled() )
	{
		vShowMessageBox(WU_E_DISABLED);

		nReturn = 1;
	}
	else
	{
		bool fConnected;
		TCHAR tszURL[INTERNET_MAX_URL_LENGTH];

		// Determine if the internet connection wizard has run and we are
		// connected to the Internet
		HrGetConnectionStatus(&fConnected);

		if ( fConnected )
		{	// The user has an internet connection.
			
			lstrcpy(tszURL, WINDOWS_UPDATE_URL); 
			// no we need to check registry override
			HKEY hkey;
			if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate"), 0, KEY_READ, &hkey)) 
			{
				DWORD dwSize = sizeof(tszURL);
				RegQueryValueEx(hkey, _T("URL"), 0, 0, (LPBYTE)&tszURL, &dwSize);
				RegCloseKey(hkey);
			}

			// Launch IE to go to the site
			vLaunchIE(tszURL);

		}
		else
		{
			//launch helpcenter version of WU
			ShellExecute(NULL, NULL, HELPCENTER_WINUPD_URL, NULL, NULL, SW_SHOWNORMAL);
		}
	}
	return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\aucatitem.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCatItem.h
//
//  Creator: PeterWi
//
//  Purpose: AU Catalog Item
//
//=======================================================================

#pragma once

#include "AUBaseCatalog.h"

//const DWORD AUCATITEM_UNSELECTED = 0;
//const DWORD AUCATITEM_SELECTED	 = 1;
//const DWORD AUCATITEM_HIDDEN	 = 2;

struct CatalogItem
{	
	void init(PUID puid, DWORD index, DWORD dwStatus = AUCATITEM_SELECTED)
	{
	    m_puid = puid;
	    m_dwStatus = dwStatus;
	    m_index = index;
    }
	void SetStatus(DWORD dwStatus) { m_dwStatus = dwStatus; }
    void SetStatusHidden(void) { m_dwStatus = AUCATITEM_HIDDEN; }

	DWORD GetStatus(void) { return m_dwStatus; }
	BOOL Selected(void)	{ return (AUCATITEM_SELECTED == m_dwStatus); }
	BOOL Unselected(void) { return (AUCATITEM_UNSELECTED == m_dwStatus); }
	BOOL Hidden(void) { return (AUCATITEM_HIDDEN == m_dwStatus); }

	PUID m_puid;
	BOOL m_dwStatus;
	DWORD m_index;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\aucompat.h ===
/****************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:
    aucompat.h

Revision History:
    DerekM      created     10/28/01

****************************************************************************/

#ifndef AUTSUTIL_H
#define AUTSUTIL_H

BOOL    AUIsTSRunning(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\aumsgs.h ===
#pragma once

// fixcode separate and rename
// engine messages
const UINT AUMSG_INIT				= WM_APP;
const UINT AUMSG_DETECT                 = WM_APP+1;
const UINT AUMSG_DOWNLOAD               = WM_APP +  2;
const UINT AUMSG_DOWNLOAD_COMPLETE      = WM_APP +  3;
const UINT AUMSG_PRE_INSTALL            = WM_APP +  4;
const UINT AUMSG_POST_INSTALL           = WM_APP +  5;
const UINT AUMSG_VALIDATE_CATALOG       = WM_APP + 17;
const UINT AUMSG_EULA_ACCEPTED          = WM_APP + 23;
const UINT AUMSG_LOG_EVENT				= WM_APP + 24;


// client messages
const UINT AUMSG_INSTALL_COMPLETE       = WM_APP +  6;
const UINT AUMSG_REBOOT_REQUIRED        = WM_APP +  7;
const UINT AUMSG_SHOW_WELCOME           = WM_APP +  8;
const UINT AUMSG_SHOW_DOWNLOAD          = WM_APP +  9;
const UINT AUMSG_SHOW_INSTALL           = WM_APP + 10;
const UINT AUMSG_TRAYCALLBACK           = WM_APP + 11;
const UINT AUMSG_INSTALL_PROGRESS       = WM_APP + 12;
const UINT AUMSG_SELECTION_CHANGED      = WM_APP + 13;
const UINT AUMSG_SET_INSTALL_ITEMSNUM = WM_APP+14;
const UINT AUMSG_SHOW_RTF               = WM_APP + 15;
const UINT AUMSG_SHOW_INSTALLWARNING = WM_APP + 18;


const UINT AUMSG_ENG_END				= AUMSG_LOG_EVENT;
const UINT AUMSG_ENG_START              = AUMSG_INIT;

inline BOOL IsValidAUMsg(UINT uMsg) 
{
	return uMsg >= AUMSG_ENG_START && uMsg <= AUMSG_ENG_END;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\aubasecatalog.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCatalog.h
//
//  Creator: PeterWi
//
//  Purpose: AU Catalog Definitions
//
//=======================================================================

#pragma once
#include <stdio.h>
#include <msxml.h>
#include <windows.h>
#include <safefunc.h>
#include "Loadengine.h"
#include "iu.h" //for IU engine exported functions' prototype
#include "iuctl.h" //for definition of UPDATE_COMMAND_CANCEL
#include "mistsafe.h"

class AUCatalogItem;

const WCHAR AUCLIENTINFO[] = L"<clientInfo xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/clientInfo.xml\" clientName=\"au\" />";
const WCHAR AUDRIVERCLIENTINFO[] = L"<clientInfo xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/clientInfo.xml\" clientName=\"audriver\" />";

const DWORD AUCATITEM_UNSELECTED = 0;
const DWORD AUCATITEM_SELECTED	 = 1;
const DWORD AUCATITEM_HIDDEN	 = 2;

//global object should not use CAU_BSTR because its constructor and destructor will
//make API calls which might cause dll loader deadlock
class CAU_BSTR
{
public:
    CAU_BSTR() : m_bstr(NULL){};
    ~CAU_BSTR() {SafeFreeBSTR(m_bstr); } 
	
    operator BSTR()	{ return m_bstr; }
	
    BOOL append(LPCWSTR wszToAppend)
		{
		if (NULL == wszToAppend)
			{
			return FALSE;
			}
		if (NULL == m_bstr)
			{
			m_bstr = SysAllocString(wszToAppend);
			return m_bstr != NULL;
			}
		int ilen = SysStringLen(m_bstr) + lstrlenW(wszToAppend) + 1;
		LPWSTR wszTmp = (LPWSTR) malloc(ilen * sizeof(WCHAR));
		if (NULL == wszTmp)
			{
			return FALSE;
			}
		BOOL fRet =
			SUCCEEDED(StringCchCopyExW(wszTmp, ilen, m_bstr, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatExW(wszTmp, ilen, wszToAppend, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SysReAllocString(&m_bstr, wszTmp);
		free(wszTmp);
		return fRet;
		}

private:
    BSTR m_bstr;
};

class AU_VARIANT : public ::tagVARIANT
{
public:
    AU_VARIANT()
    {
        vt = VT_EMPTY;
    }

    AU_VARIANT(LPCWSTR wsz)
    {
        vt = VT_BSTR;
        if ( NULL == (bstrVal = SysAllocString(wsz)) )
        {
            vt = VT_EMPTY;
        }
    }

    AU_VARIANT(long newlVal)
    {
        vt = VT_I4;
        lVal = newlVal;
    }

    AU_VARIANT(GUID & guid)
    {
        WCHAR wszGUID[40]; // 725e35a2-ee11-4b34-834f-6eaf4bade994

        vt = VT_BSTR;
        if ( (0 == StringFromGUID2(guid, wszGUID, ARRAYSIZE(wszGUID))) ||
             (NULL == (bstrVal = SysAllocString(wszGUID))) )
        {
            DEBUGMSG("variant with guid failed");
            vt = VT_EMPTY;
        }
    }

    ~AU_VARIANT() { VariantClear(this); }

    BOOL IsEmpty(void) { return VT_EMPTY == vt; }
};


class AUCatalogItemList
{
public:
	AUCatalogItemList()
		:pList(NULL), uNum(0) {}
	~AUCatalogItemList() { Clear();	}
	UINT Count(void) { return uNum; }

	AUCatalogItem & operator[] (UINT uIndex) const
	{
	    return *pList[uIndex];
	}
	void Clear(void);
	HRESULT Allocate(DWORD cItems);
	HRESULT Allocate(VARIANT & var);
	BOOL Add(AUCatalogItem *pitem);
	void Remove(BSTR bstrItemID);
	INT Contains(BSTR bstrItemID);
	HRESULT Copy( AUCatalogItemList &itemlist2);
	HRESULT BuildIndirectDependency();

       UINT GetNum(DWORD dwSelectionStatus);
       UINT GetNumSelected(void) { return GetNum(AUCATITEM_SELECTED); }
       UINT GetNumUnselected(void) { return GetNum(AUCATITEM_UNSELECTED); }
       UINT GetNumHidden(void) { return GetNum(AUCATITEM_HIDDEN);}

       BOOL ItemIsRelevant(UINT index) ;
   
       void DbgDump(void);
    
private:
	UINT uNum;
	AUCatalogItem **pList;
};

class AUCatalogItem
{
public:
    AUCatalogItem()
        : m_dwStatus(AUCATITEM_SELECTED),
          m_bstrID(NULL),
          m_bstrProviderName(NULL),
          m_bstrTitle(NULL),
          m_bstrDescription(NULL),
          m_bstrRTFPath(NULL),
          m_bstrEULAPath(NULL)
    {}

    AUCatalogItem(AUCatalogItem & item2)
    {
    	m_bstrID = SysAllocString(item2.bstrID());
		m_bstrProviderName = SysAllocString(item2.bstrProviderName());
		m_bstrTitle = SysAllocString(item2.bstrTitle());
		m_bstrDescription = SysAllocString(item2.bstrDescription());
		m_bstrRTFPath = SysAllocString(item2.bstrRTFPath());
		m_bstrEULAPath = SysAllocString(item2.bstrEULAPath());
		m_dwStatus = item2.dwStatus();
    }

	void Clear()
	{
		SafeFreeBSTRNULL(m_bstrID);
        SafeFreeBSTRNULL(m_bstrTitle);
        SafeFreeBSTRNULL(m_bstrProviderName);
        SafeFreeBSTRNULL(m_bstrDescription);
        SafeFreeBSTRNULL(m_bstrRTFPath);
        SafeFreeBSTRNULL(m_bstrEULAPath);
	}
	
    ~AUCatalogItem()
    {
    	Clear();
    }

    BOOL fEqual(AUCatalogItem & item2)
		{
			BOOL fRet = FALSE;
			BSTR  myValues[] = {m_bstrID,
								m_bstrProviderName, 
								m_bstrTitle, 
								m_bstrDescription, 
								m_bstrRTFPath, 
								m_bstrEULAPath }; 
			BSTR theirValues[] = {item2.bstrID(),
								item2.bstrProviderName(),
								item2.bstrTitle(),
								item2.bstrDescription(),
								item2.bstrRTFPath(),
								item2.bstrEULAPath()};
			if (item2.dwStatus() != m_dwStatus)
			{
				goto done;
			}
			for ( UINT i= 0; i < ARRAYSIZE(myValues); i++ )
			{
				if (NULL != myValues[i] && NULL == theirValues[i]
					|| NULL == myValues[i] && NULL != theirValues[i])
				{
					goto done;
				}
				else if (NULL != myValues[i] && NULL != theirValues[i])
				{
					if (0 != lstrcmpW(myValues[i], theirValues[i]))
					{
						goto done;
					}
				}
			}
			fRet = TRUE;
done:
			return fRet;
    }
  	

    void SetField(LPCSTR szFieldName, BSTR bstrVal)
	{
		BSTR * grValues[] = {	&m_bstrID,
								&m_bstrProviderName, 
								&m_bstrTitle, 
								&m_bstrDescription, 
								&m_bstrRTFPath, 
								&m_bstrEULAPath }; 

		for ( int index = 0; index < ARRAYSIZE(grValues); index++ )
		{
			if ( 0 == _stricmp(szFieldName, m_pFieldNames[index]))
			{
				*grValues[index] = bstrVal;
				return;
			}
		}
	}

    void dump() //for debug
	{
		DEBUGMSG("dumping item content");
		DEBUGMSG("Item ID= %S", m_bstrID);
		DEBUGMSG("Provider Name= %S", m_bstrProviderName);
		DEBUGMSG("Title= %S", m_bstrTitle);
		DEBUGMSG("Desc= %S", m_bstrDescription);
		DEBUGMSG("RTF Path= %S", m_bstrRTFPath);
		DEBUGMSG("Eula Path= %S", m_bstrEULAPath);
		DEBUGMSG("status = %d", m_dwStatus);
		if (m_DependingItems.Count() == 0)
			{
			DEBUGMSG("		has no depending items");
			}
		else
			{
			DEBUGMSG("		has total %d depending items", m_DependingItems.Count());
			for (UINT i = 0; i < m_DependingItems.Count();  i++)
				{
				DEBUGMSG("		: %S", m_DependingItems[i].bstrID()); //only cares about itemID
				}
			}	
		DEBUGMSG("dumping item done");
	}

    static char * m_pFieldNames[] ;

    DWORD dwStatus(void) { return m_dwStatus; }
    BSTR bstrID(void) { return (m_bstrID); }
    BSTR bstrProviderName(void) { return (m_bstrProviderName); }
    BSTR bstrTitle(void) { return (m_bstrTitle); }
    BSTR bstrDescription(void) { return (m_bstrDescription); }
    BSTR bstrRTFPath(void) { return (m_bstrRTFPath); }
    BSTR bstrEULAPath(void) { return (m_bstrEULAPath); }

    void SetStatus(DWORD dwStatus) { m_dwStatus = dwStatus; }
    void SetStatusHidden(void) { m_dwStatus = AUCATITEM_HIDDEN; }
    void SetStatusSelected(void)	{m_dwStatus = AUCATITEM_SELECTED;}

    BOOL fSelected(void) { return (AUCATITEM_SELECTED == m_dwStatus); }
    BOOL fUnselected(void) { return (AUCATITEM_UNSELECTED == m_dwStatus); }
    BOOL fHidden(void) { return (AUCATITEM_HIDDEN == m_dwStatus); }
	
   AUCatalogItemList	m_DependingItems; //all items that depends on this item, directly and indirectly
private:
    DWORD m_dwStatus;

    BSTR m_bstrID; 
    BSTR m_bstrProviderName;
    BSTR m_bstrTitle;
    BSTR m_bstrDescription;
    BSTR m_bstrRTFPath;
    BSTR m_bstrEULAPath;


    friend HRESULT TransformSafeArrayToItemList(VARIANT & var, AUCatalogItemList & ItemList);
    friend class AUCatalog;
};



//wrapper class for AU to do detection using IU
class AUBaseCatalog
{
public: 
    AUBaseCatalog()
    	{
			Reset();
		}
    ~AUBaseCatalog();
    HRESULT PrepareIU(BOOL fOnline = TRUE);
    void FreeIU();
    HRESULT CancelNQuit(void);
protected:
    HMODULE				m_hIUCtl;
    HMODULE				m_hIUEng;					
    PFN_LoadIUEngine		m_pfnCtlLoadIUEngine;
    PFN_UnLoadIUEngine		m_pfnCtlUnLoadIUEngine;
    PFN_GetSystemSpec		m_pfnGetSystemSpec;
    PFN_GetManifest			m_pfnGetManifest;
    PFN_Detect				m_pfnDetect;
    PFN_Install		        m_pfnInstall;
    PFN_SetOperationMode	m_pfnSetOperationMode;
    PFN_CtlCancelEngineLoad m_pfnCtlCancelEngineLoad;
	PFN_CreateEngUpdateInstance		m_pfnCreateEngUpdateInstance;
	PFN_DeleteEngUpdateInstance		m_pfnDeleteEngUpdateInstance;
    BOOL 					m_fEngineLoaded;
	HIUENGINE				m_hIUEngineInst;
private:
	void Reset()
	{
		m_hIUCtl = NULL;
	    m_hIUEng = NULL;
	    m_pfnCtlLoadIUEngine = NULL;
	    m_pfnCtlUnLoadIUEngine = NULL;
	    m_pfnGetSystemSpec = NULL;
	    m_pfnGetManifest = NULL;
	    m_pfnDetect = NULL;
	    m_pfnInstall = NULL;
	    m_pfnSetOperationMode = NULL;
	    m_pfnCtlCancelEngineLoad = NULL;
		m_pfnCreateEngUpdateInstance = NULL;
		m_pfnDeleteEngUpdateInstance = NULL;
		m_hIUEngineInst = NULL;
		m_fEngineLoaded = FALSE;
	}
};


extern HANDLE ghMutex; //mutex used to prevent catalog from being destructed while canceling it
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\ausvc.h ===
#pragma once

typedef DWORD (WINAPI *AUSERVICEHANDLER)(DWORD fdwControl,
                                                DWORD dwEventType,
                                                LPVOID pEventData,
                                                LPVOID lpContext);


const DWORD AUSRV_VERSION = 1;
typedef struct _AUENGINEINFO_VER_1
{
    SERVICE_STATUS          serviceStatus;
    SERVICE_STATUS_HANDLE   hServiceStatus;
} AUENGINEINFO_VER_1;

typedef BOOL (WINAPI *AUREGSERVICEVER) (DWORD dwServiceVersion, DWORD *pdwEngineVersion);
typedef BOOL (WINAPI *AUGETENGSTATUS)(void *pEngineInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\auinternals.cpp ===
#include "pch.h"
#pragma hdrstop

#include "wuauengi_i.c"

CAUInternals::~CAUInternals()
{
	if (m_pUpdates != NULL)
	{
		m_pUpdates->Release();
	}
}

HRESULT CAUInternals::m_setReminderState(DWORD dwState)
{
	HRESULT hr = S_OK;

	// save selections so we have them after the reminder
	if ( AUSTATE_NOT_CONFIGURED == dwState || (SUCCEEDED(hr = m_saveSelectionsToServer(m_pUpdates))))
	{
		hr = SetRegDWordValue(TIMEOUTSTATE, dwState);
	}
	return hr;
}

/*****
 Takes the number of seconds we want to wait before reminding the user
 and records it in the current user's registry along with a timestamp.
*****/
HRESULT CAUInternals::m_setReminderTimeout(UINT iTimeout)
{
	//const int NanoSec100PerSec = 10000000;
	DEBUGMSG("WUAUCLT Setting timeout = %lu", ReminderTimes[iTimeout].timeout);

	DWORD timeout;

	if ( TIMEOUT_INX_TOMORROW == iTimeout )
	{
		// time to wait is midnight - current time.
		SYSTEMTIME tmCurrent;
		SYSTEMTIME tmMidnight;
		FILETIME ftCurrent;
		FILETIME ftMidnight;

		GetLocalTime(&tmCurrent);
		tmMidnight = tmCurrent;
		tmMidnight.wHour = 23;
		tmMidnight.wMinute = 59;
		tmMidnight.wSecond = 59;
		tmMidnight.wMilliseconds  = 999;

		SystemTimeToFileTime(&tmCurrent,  &ftCurrent);
		SystemTimeToFileTime(&tmMidnight, &ftMidnight);
		ULONGLONG diff = *((ULONGLONG *)&ftMidnight) - *((ULONGLONG *)&ftCurrent);
		timeout = DWORD(diff / NanoSec100PerSec);
		DEBUGMSG("WUAUCLT: tomorrow is %lu secs away", timeout);
	}
	else
	{
		timeout = ReminderTimes[iTimeout].timeout;
	}

	return setAddedTimeout(timeout, TIMEOUTVALUE);
}

HRESULT CAUInternals::m_getServiceState(AUSTATE *pAuState)
{
#ifdef TESTUI
		return S_OK;
#else
	if (NULL == m_pUpdates)
	{
		return E_FAIL;
	}
	HRESULT hr = m_pUpdates->get_State(pAuState);
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_getServiceState failed, hr=%#lx", hr);		
	}
	return hr;
#endif
}


HRESULT TransformSafeArrayToItemList(VARIANT & var, AUCatalogItemList & ItemList)
{
	HRESULT hr; //= S_OK;


	// determine how many elements there are.
	if (FAILED(hr = ItemList.Allocate(var)))
	{
	    DEBUGMSG("WUAUCLT fail to allocate item list with error %#lx", hr);
	    goto done;
	}
    DEBUGMSG("ItemList had %d elements", ItemList.Count());
#if 0
	if ( !m_bValid )
	{
		DEBUGMSG("Catalog::getUpdateList fails because catalog is not valid");
		goto done;
	}
#endif
	for ( UINT index = 0; index < ItemList.Count(); index++ )
	{
		VARIANT varg;
		VariantInit(&varg);

		struct
		{
			VARTYPE vt;
			void * pv;
		} grMembers[] = { { VT_I4,		&ItemList[index].m_dwStatus }, 
						  { VT_BSTR,	&ItemList[index].m_bstrID },
						  { VT_BSTR,	&ItemList[index].m_bstrProviderName },
						  { VT_BSTR,	&ItemList[index].m_bstrTitle },
						  { VT_BSTR,	&ItemList[index].m_bstrDescription },
						  { VT_BSTR,	&ItemList[index].m_bstrRTFPath },
						  { VT_BSTR,	&ItemList[index].m_bstrEULAPath } };

		for ( int index2 = 0; index2 < ARRAYSIZE(grMembers); index2++ )
		{
    		long dex = (index * 7) + index2;

			if ( FAILED(hr = SafeArrayGetElement(var.parray, &dex, &varg)) )
			{
                DEBUGMSG("Failed to get element %ld", dex);
				goto done;
			}

			switch (grMembers[index2].vt)
			{
			case VT_I4:
				*((long *)grMembers[index2].pv) = varg.lVal;
				break;
			
			case VT_BSTR:
				*((BSTR *)grMembers[index2].pv) = varg.bstrVal;
				break;
			}
		}
	}

done:
	return hr; 
}


HRESULT CAUInternals::m_getServiceUpdatesList(void)
{
#ifdef TESTUI
    return S_OK;
#else
    VARIANT var;
    HRESULT hr;
    
    if ( SUCCEEDED(hr = m_pUpdates->GetUpdatesList(&var)) &&
         SUCCEEDED(hr = TransformSafeArrayToItemList(var, m_ItemList)) )
    {
//        gItemList.DbgDump();
    }
    else
    {	
        DEBUGMSG("WUAUCLT m_getUpdatesList failed, hr=%#lx", hr);
    }

    VariantClear(&var);

    return hr;
#endif
}


HRESULT CAUInternals::m_saveSelectionsToServer(IUpdates *pUpdates)
{
    HRESULT hr = E_FAIL;
	SAFEARRAYBOUND bound[1] = { m_ItemList.Count() * 2, 0};

	if ( 0 == m_ItemList.Count() )
	{
		DEBUGMSG("Catalog::m_saveSelectionsToServer fails because getNumItems is 0");
		hr = E_UNEXPECTED;
		goto Done;
	}

	VARIANT varSelections;
    varSelections.vt = VT_ARRAY | VT_VARIANT;

	if (NULL == (varSelections.parray = SafeArrayCreate(VT_VARIANT, 1, bound)))
    {
		hr = E_OUTOFMEMORY;
		goto Done;
    }

	VARIANT *grVariant = NULL;
	if (FAILED(hr = SafeArrayAccessData(varSelections.parray, (void **)&grVariant)))
	{
		goto CleanUp;
	}

	for ( UINT n = 0; n < m_ItemList.Count(); n++ )
	{
		if (NULL == (grVariant[n*2+0].bstrVal = SysAllocString(m_ItemList[n].bstrID())))
		{
			hr = E_OUTOFMEMORY;
			break;
		}
		grVariant[n*2+0].vt = VT_BSTR;
		grVariant[n*2+1].vt = VT_I4;
		grVariant[n*2+1].lVal = m_ItemList[n].dwStatus();
	}
	HRESULT hr2 = SafeArrayUnaccessData(varSelections.parray);
	if (SUCCEEDED(hr) && FAILED(hr2))
	{
		hr = hr2;
		goto CleanUp;
	}

	if (SUCCEEDED(hr))
	{
		hr = pUpdates->SaveSelections(varSelections);
	}

CleanUp:
    VariantClear(&varSelections);

Done:
	return hr; 
}

HRESULT CAUInternals::m_startDownload(void)
{
	//fixcode this call is probably unneccesary
	HRESULT hr = m_saveSelectionsToServer(m_pUpdates);
       DEBUGMSG("WUAUCLT %s download", FAILED(hr) ? "skip" : "start");
	if ( SUCCEEDED(hr) )
	{
		hr = m_pUpdates->StartDownload();

		if (FAILED(hr))
		{
			DEBUGMSG("WUAUCLT m_startDownload failed, hr=%#lx", hr);
		}
	}

	return hr;
}

HRESULT CAUInternals::m_getDownloadStatus(UINT *percent, DWORD *status)
{
	HRESULT hr = m_pUpdates->GetDownloadStatus(percent, status);
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_getDownloadStatus failed, hr=%#lx", hr);
	}
	return hr;
}

HRESULT CAUInternals::m_setDownloadPaused(BOOL bPaused)
{
	HRESULT hr = m_pUpdates->SetDownloadPaused(bPaused);
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_setDownloadPaused failed, hr=%#lx", hr);
	}
	return hr;
}

//fAutoInstall  TRUE if client doing install via local system
// FALSE if installing via local admin
HRESULT CAUInternals::m_startInstall(BOOL fAutoInstall)
{
	HRESULT hr = m_pUpdates->ClientMessage(AUMSG_PRE_INSTALL);

	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_startInstall failed, hr=%#lx", hr);
	}
	else
	{
	    gpClientCatalog->m_WrkThread.m_DoDirective(fAutoInstall ? enWrkThreadAutoInstall :  enWrkThreadInstall);
	}
	return hr;
}

//fixcode: should change name to complete wizard
HRESULT CAUInternals::m_configureAU()
{
	HRESULT hr = m_pUpdates->ConfigureAU();
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT m_ConfigureAU failed, hr=%#lx", hr);
	}
	return hr;
}

#if 0
long CAUInternals::m_getNum(DWORD dwSelectionStatus)
{
	long total = 0;
	
    
    for (UINT index = 0; index < gItemList.Count(); index++ )
	{
		if ( dwSelectionStatus == gItemList[index].dwStatus() )
		{
			total++;
		}
	}

    return total;
}
#endif

HRESULT CAUInternals::m_AvailableSessions(LPUINT pcSess)
{
	if (NULL == pcSess)
	{
		return E_INVALIDARG;
	}
	return m_pUpdates->AvailableSessions(pcSess);
}

HRESULT CAUInternals::m_getEvtHandles(DWORD dwProcId, AUEVTHANDLES *pAuEvtHandles)
{
	HRESULT	hr = m_pUpdates->get_EvtHandles(dwProcId, pAuEvtHandles);
	if (FAILED(hr))
	{
		DEBUGMSG("WUAUCLT get_EvtHandles failed hr=%#lx", hr);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\auinternals.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUInternals.h
//
//  Creator: PeterWi
//
//  Purpose: Client AU Internal Definitions
//
//=======================================================================

#pragma once
#include "aubasecatalog.h"

extern AUClientCatalog *gpClientCatalog;

struct AUDownloadStatus
{
	DWORD m_percentageComplete;
	BOOL  m_bSuspended;
};

class CAUInternals
{
public:
	CAUInternals():m_pUpdates(NULL)
		{}
	~CAUInternals();

	HRESULT	m_Init()
	{
		return CoCreateInstance(__uuidof(Updates),
					NULL,
					 CLSCTX_LOCAL_SERVER,
					 IID_IUpdates,
					 (LPVOID*)&m_pUpdates);
	}
	HRESULT	m_setReminderTimeout(UINT iTimeout);
	HRESULT	m_setReminderState(DWORD);	
	HRESULT	m_getServiceState(AUSTATE *pAuState);
	HRESULT	m_getServiceOption(AUOPTION *pauopt)
	{
#ifdef TESTUI
		return S_OK;
#else
		HRESULT hr = m_pUpdates->get_Option(pauopt);
		return hr;
#endif
	}

	HRESULT	m_setServiceOption(AUOPTION auopt)
	{
#ifdef TESTUI
		return S_OK;
#else
		return m_pUpdates->put_Option(auopt);
#endif
	}

	HRESULT m_getServiceUpdatesList(void);
	HRESULT m_saveSelectionsToServer(IUpdates *pUpdates);
	HRESULT m_startDownload(void);
	HRESULT m_getDownloadStatus(UINT *, DWORD *);
	HRESULT m_setDownloadPaused(BOOL);
	HRESULT m_startInstall(BOOL fAutoInstall = FALSE);
	HRESULT m_configureAU();
	HRESULT m_AvailableSessions(LPUINT pcSess);
	HRESULT m_getEvtHandles(DWORD dwProcId, AUEVTHANDLES *pAuEvtHandles);

	IUpdates* m_pUpdates;
	AUCatalogItemList m_ItemList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\auwait.h ===
#pragma once

#define AU_TEN_SECONDS (10)
#define AU_ONE_MIN     (60)
#define AU_THREE_MINS (3 * AU_ONE_MIN)
#define AU_FIVE_MINS   (5  * AU_ONE_MIN)
#define AU_TEN_MINS	   (10 * AU_ONE_MIN)
#define AU_ONE_HOUR    (60 * AU_ONE_MIN)
#define AU_FOUR_HOURS  (4  * AU_ONE_HOUR)
#define AU_FIVE_HOURS  (5  * AU_ONE_HOUR)
#define AU_TWELVE_HOURS (12* AU_ONE_HOUR)
#define AU_TWENTY_TWO_HOURS (22 * AU_ONE_HOUR)
#define AU_ONE_DAY     (24 * AU_ONE_HOUR)
#define AU_TWO_DAYS    ( 2 * AU_ONE_DAY)
#define AU_ONE_WEEK    ( 7 * AU_ONE_DAY)

#define AU_MIN_SECS    (1)
#define AU_MIN_MS      (AU_MIN_SECS * 1000)

#define AUFT_INVALID_VALUE ((ULONGLONG) 0)

#define AU_RANDOMIZATION_WINDOW	20 //percent

// easy to do calculations with without casting.
typedef union
{
    FILETIME ft;
    ULONGLONG ull;
} AUFILETIME;

DWORD dwTimeToWait(DWORD dwTimeInSecs, DWORD dwMinSecs = AU_MIN_SECS);

inline DWORD dwSecsToWait(DWORD dwTime)
{
    return (dwTimeToWait(dwTime) / 1000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\aucltcatalog.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUClientCatalog.cpp
//
//  Creator: PeterWi
//
//  Purpose: Client AU Catalog Functions
//
//=======================================================================

#include "pch.h"

//=======================================================================
//
//  AUClientCatalog::Init
//
//  Initialize client catalog data.
//
//=======================================================================
HRESULT AUClientCatalog::Init(void)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = m_WrkThread.m_Init()))
        {
        DEBUGMSG("AUCatalog::Init() Work Thread fail to init with error %#lx", hr);
        goto end;
        }
        
    m_fReboot = FALSE;

	if (NULL == m_pInstallCallback)
	{
		m_pInstallCallback = new CInstallCallback();
		if (NULL == m_pInstallCallback)
		{
			DEBUGMSG("AUCatalog::Init() fail to create install progress listener");
			hr = E_OUTOFMEMORY;
			goto end;
		}
	}

	if (NULL == m_bstrClientInfo)
	{
		m_bstrClientInfo = SysAllocString(AUCLIENTINFO);
		if (NULL == m_bstrClientInfo)
		{
			DEBUGMSG("AUCatalog::Init() fail to alloc string for client info");
			hr = E_OUTOFMEMORY;
			goto end;
		}
	}

end:
	return hr;
}


AUClientCatalog::~AUClientCatalog(void)
{
//	m_WrkThread.m_Terminate();
       SafeFreeBSTR(m_bstrClientInfo);
	SafeDelete(m_pInstallCallback);
}


DWORD GetItemNum(BSTR bstrCatalog) 
{
	IXMLDOMDocument *pxml = NULL;
	CAU_BSTR aubsItemIdsPattern;
	IXMLDOMNodeList *pItemIdsNodeList = NULL;
	HRESULT hr;
	long lRet = 0;

	if (FAILED(hr =LoadXMLDoc(bstrCatalog, &pxml)))
	{
		DEBUGMSG("GetItemNum fails to load xml with error %#lx", hr);
		goto done;
	}
	
	if (!aubsItemIdsPattern.append(L"catalog/provider/item/identity/@itemID")) //case sensitive
	{
	    DEBUGMSG("WUAUCLT OUT OF MEMORY. Fail to create item id pattern");
            goto done;
	}
 	
	if (FAILED(hr = pxml->selectNodes(aubsItemIdsPattern, &pItemIdsNodeList)))
	{
		DEBUGMSG(" fail to find item id with error %#lx", hr);
		goto done;
	}

	pItemIdsNodeList->get_length(&lRet);

done:
	SafeRelease(pItemIdsNodeList);
	SafeRelease(pxml);
//	DEBUGMSG("GetItemNum return %ld", lRet);
	return lRet;
}
	
//=======================================================================
//
//  AUClientCatalog::InstallItems
//
//  Install selected items.
//
//=======================================================================
HRESULT AUClientCatalog::InstallItems(BOOL fAutoInstall)
{
    DEBUGMSG("AUClientCatalog::InstallItems");
    HRESULT hr;
    IUpdates * pUpdates = NULL;
    BSTR bstrCatalogXML = NULL;
    BSTR bstrDownloadXML = NULL;
    BSTR bstrUuidOperation = NULL;

    if ( FAILED(hr = PrepareIU(FALSE)) )
    {
        DEBUGMSG("AUCatalog::InstallItems() fail to prepare IU %#lx", hr);
        goto end;
    }

    if ( FAILED(hr = CoCreateInstance(__uuidof(Updates),
    	    NULL,
    		CLSCTX_LOCAL_SERVER,
    		IID_IUpdates,
    		(LPVOID*)&pUpdates)) )
    {
        DEBUGMSG("AUClientCatalog::InstallItems() fail to create Updates object");
        goto end;
    }		

    if (!fAutoInstall)
    {
            if ( FAILED(hr = gInternals->m_saveSelectionsToServer(pUpdates)) )
            {
        		DEBUGMSG("AUClientCatalog::InstallItems() call to m_saveSelectionsToServer failed, hr = %#lx", hr);
                goto end;
            }
    }

    if ( FAILED(hr = pUpdates->GetInstallXML(&bstrCatalogXML, &bstrDownloadXML)) )
    {
		DEBUGMSG("AUClientCatalog::InstallItems() call to GetInstallXML failed, hr = %#lx", hr);
        goto end;
    }

    if (S_FALSE == hr)
    {
        DEBUGMSG("Nothing to install");
        goto end;
    }

	SendMessage(ghCurrentDialog, AUMSG_SET_INSTALL_ITEMSNUM, 0, GetItemNum(bstrCatalogXML));


#if DBG
	LOGXMLFILE(DOWNLOAD_FILE, bstrDownloadXML);
#endif

    //fixcode: when install fail, should NOT show the installation complete UI
    DEBUGMSG("WUAUCLT calling IU to do install........");
     m_pfnInstall(m_hIUEngineInst, m_bstrClientInfo,
                      bstrCatalogXML, 
					  bstrDownloadXML,
					  UPDATE_NOTIFICATION_ANYPROGRESS |UPDATE_OFFLINE_MODE , 
					  m_pInstallCallback, 
					  0, // hWnd
					  &bstrUuidOperation);
    DEBUGMSG("WUAUCLT IU done installation");
    
    Sleep(750);

    if ( gpClientCatalog->m_fReboot )
    {
        DEBUGMSG("Reboot required, setting regkey");
        fSetRebootFlag();
        if (NULL != ghCurrentDialog)
            {
            SendMessage(ghCurrentDialog, AUMSG_REBOOT_REQUIRED, 0, 0);
            }
    }
    else
    {
        if (NULL != ghCurrentDialog)
            {
            SendMessage(ghCurrentDialog, AUMSG_INSTALL_COMPLETE, 0, 0);
            }
    }

end:
    SafeFreeBSTR(bstrUuidOperation);	
    SafeFreeBSTR(bstrCatalogXML);	
    SafeFreeBSTR(bstrDownloadXML);	

    FreeIU();
    SafeRelease(pUpdates);
    DEBUGMSG("AUCatalog done items installation");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\wuaustate.h ===
#pragma once

//States
#define AUSTATE_OUTOFBOX			0
#define AUSTATE_NOT_CONFIGURED	1
#define AUSTATE_DETECT_PENDING		2
#define AUSTATE_DETECT_COMPLETE		3
#define AUSTATE_DOWNLOAD_PENDING	4
#define AUSTATE_DOWNLOAD_COMPLETE	5
#define AUSTATE_INSTALL_PENDING		6
#define AUSTATE_DISABLED			7
#define AUSTATE_WAITING_FOR_REBOOT	8
#define AUSTATE_MIN	AUSTATE_OUTOFBOX
#define AUSTATE_MAX	AUSTATE_WAITING_FOR_REBOOT
//AUSTATE 

//Directives
const DWORD AUCLT_ACTION_NONE = 0;
//const DWORD AUCLT_ACTION_SHOWINSTALLWARNINGONLY = 1;
const DWORD AUCLT_ACTION_AUTOINSTALL = 1;
const DWORD AUCLT_ACTION_SHOWREBOOTWARNING = 2;

typedef struct _AUSTATE
{
	DWORD dwState;
	BOOL  fDisconnected;
	DWORD dwCltAction;
} AUSTATE;

typedef struct _AUOPTION
{
	DWORD dwOption;
	DWORD dwSchedInstallDay;
	DWORD dwSchedInstallTime;
	BOOL    fDomainPolicy; //option comes from domain
} AUOPTION;


typedef struct _AUEVTHANDLES
{
#ifdef _WIN64
	//LONG64	ulEngineState;
	LONG64	ulNotifyClient;
#else	
	//LONG	ulEngineState;
	LONG	ulNotifyClient;
#endif

} AUEVTHANDLES;


typedef enum tagClientNotifyCode {
	NOTIFY_STOP_CLIENT = 1,
	NOTIFY_ADD_TRAYICON,
	NOTIFY_REMOVE_TRAYICON,
	NOTIFY_STATE_CHANGE,
	NOTIFY_SHOW_INSTALLWARNING,
	NOTIFY_RESET,
	NOTIFY_RELAUNCH_CLIENT
} CLIENT_NOTIFY_CODE;

typedef struct tagCLIENT_NOTIFY_DATA{
	CLIENT_NOTIFY_CODE actionCode;
} CLIENT_NOTIFY_DATA;

///////////////////////////////////////////////
//
//  Status Pinging Related Definition
//
///////////////////////////////////////////////
typedef long PUID;

const UINT	PING_STATUS_ERRMSG_MAX_LENGTH = 200;

typedef enum tagPingStatusCode
{
	PING_STATUS_CODE_SELFUPDATE_PENDING = 0,
	PING_STATUS_CODE_SELFUPDATE_COMPLETE ,
	PING_STATUS_CODE_SELFUPDATE_FAIL,
	PING_STATUS_CODE_DETECT_FAIL,
	PING_STATUS_CODE_DOWNLOAD_SUCCESS,
	PING_STATUS_CODE_DOWNLOAD_FAIL,
	PING_STATUS_CODE_INSTALL_SUCCESS,
	PING_STATUS_CODE_INSTALL_REBOOT,
	PING_STATUS_CODE_INSTALL_FAIL
} PingStatusCode;

#define  PING_STATUS_CODE_MIN  PING_STATUS_CODE_SELFUPDATE_PENDING
#define  PING_STATUS_CODE_MAX PING_STATUS_CODE_INSTALL_FAIL

#if 0
// Ping status information entry
// fUsePuid		: switch to decide if to use puid or not
//					if TURE, puid is used 
//					if FALSE, puid is not applicable 
// puid			: if applicable, puid of the item we send information about
// enStatusCode	: status code for type of information AU sends.
// guid			: unique identifier for each AU cycle
// tszErr		: addtional message about general errors. Maximum length is PING_STATUS_ERRMSG_MAX_LENGTH. 
//				: Messages longer than PING_STATUS_ERRMSG_MAX_LENGTH will be truncated.
//			:	 if NULL, "none" will be the default error message
typedef struct tagStatusEntry  
{
	BOOL fUsePuid;   //if TRUE, puid is used. otherwise puid is not used
	PUID puid;
	GUID guid;
	PingStatusCode enStatusCode;
	TCHAR tszErr[PING_STATUS_ERRMSG_MAX_LENGTH];
} StatusEntry;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\aucltcatalog.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCltCatalog.h
//
//  Creator: PeterWi
//
//  Purpose: Client AU Catalog Definitions
//
//=======================================================================

#pragma once
#include "AUBaseCatalog.h"
#include "WrkThread.h"
//#include <iuprogress.h>

class CInstallCallback : public IProgressListener
{
public: 
		// IUnknown
	   STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
       STDMETHOD_(ULONG, AddRef)(void);
       STDMETHOD_(ULONG, Release)(void);
	
	   // IProgressListener
	   HRESULT STDMETHODCALLTYPE OnItemStart( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItem,
            /* [out] */ LONG *plCommandRequest);

        HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ VARIANT_BOOL fItemCompleted,
            /* [in] */ BSTR bstrProgress,
            /* [out] */ LONG *plCommandRequest);

        HRESULT STDMETHODCALLTYPE OnOperationComplete( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItems);

private:
    long m_refs;
};

//wrapper class for AU to do detection using IU
class AUClientCatalog : public AUBaseCatalog
{
public:
	AUClientCatalog(): m_bstrClientInfo(NULL), m_pInstallCallback(NULL) {}
    ~AUClientCatalog();
    HRESULT InstallItems(BOOL fAutoInstall);
    HRESULT Init();
//    void Uninit();

	IProgressListener * m_pInstallCallback;
	BSTR	m_bstrClientInfo;
	BOOL m_fReboot;
    	CClientWrkThread m_WrkThread;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\inc\link.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Link.h
//
//  Owner:  a-josem
//
//  Description:
//
//      Static control subclassing Class used to display links.
//
//
//=======================================================================


#pragma once
#include <stdlib.h>
#include <malloc.h>

#include "windowsx.h"
#include "tchar.h"
#include "htmlhelp.h"
#include <shellapi.h>
#include <safefunc.h>
#include "mistsafe.h"

const TCHAR strObjPtr[]  = TEXT("strSysLinkObjPtr");

const struct
{
	enum { cxWidth = 32, cyHeight = 32 };
	int xHotSpot;
	int yHotSpot;
	unsigned char arrANDPlane[cxWidth * cyHeight / 8];
	unsigned char arrXORPlane[cxWidth * cyHeight / 8];
} _Link_CursorData = 
{
	5, 0, 
	{
		0xF9, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 
		0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xF0, 0x07, 0xFF, 0xFF, 0xF0, 0x01, 0xFF, 0xFF, 
		0xF0, 0x00, 0xFF, 0xFF, 0x10, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 
		0x80, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x7F, 0xFF, 
		0xE0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 
		0xF8, 0x01, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
		0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0xC0, 0x00, 0x00, 0x06, 0xD8, 0x00, 0x00, 
		0x06, 0xDA, 0x00, 0x00, 0x06, 0xDB, 0x00, 0x00, 0x67, 0xFB, 0x00, 0x00, 0x77, 0xFF, 0x00, 0x00, 
		0x37, 0xFF, 0x00, 0x00, 0x17, 0xFF, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 
		0x0F, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 
		0x03, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	}
};

class CSysLink
{
public:
	CSysLink(BOOL fIsHtmlHelp= TRUE):/*bInit(FALSE),*/m_OrigWndProc(NULL),m_lpstrLabel(NULL), m_lpstrHyperLink(NULL),m_hWnd(NULL),
			m_hCursor(NULL), m_hFont(NULL), /* m_bPaintLabel(true),*/ m_clrLink(RGB(0, 0, 255)), m_PaintedFocusRect(false), m_IsHtmlHelp(fIsHtmlHelp)
	{
		SetRectEmpty(&m_rcLink);
	}

	~CSysLink()
	{
#if 0		
		free(m_lpstrLabel);
		free(m_lpstrHyperLink);
		if(m_hFont != NULL)
			::DeleteObject(m_hFont);
		if(m_hCursor != NULL)
			::DestroyCursor(m_hCursor);
#endif		
	}

	void Uninit()
	{
		SafeFreeNULL(m_lpstrLabel);
		SafeFreeNULL(m_lpstrHyperLink);
		if(m_hFont != NULL)
		{
			::DeleteObject(m_hFont);
			m_hFont = NULL;
		}
		if(m_hCursor != NULL)
		{
			::DestroyCursor(m_hCursor);
			m_hCursor = NULL;
		}
	}

	void Init()
	{	
		LONG ctrlstyle = GetWindowLong(m_hWnd,GWL_STYLE);
		ctrlstyle |= SS_NOTIFY;
		SetWindowLongPtr(m_hWnd,GWL_STYLE,ctrlstyle);

		HWND wnd = GetParent(m_hWnd);
		HFONT hFont = (HFONT)SendMessage(wnd,WM_GETFONT,0,0);
/*		if(m_bPaintLabel) */
		{
			if(hFont != NULL)
			{
				LOGFONT lf;
				GetObject(hFont, sizeof(LOGFONT), &lf);
				lf.lfUnderline = TRUE;
				m_hFont = CreateFontIndirect(&lf);
			}
		}

		// set label (defaults to window text)
		if(m_lpstrLabel == NULL)
		{
			int nLen = GetWindowTextLength(m_hWnd);
			if(nLen > 0)
			{
				LPTSTR lpszText = (LPTSTR)malloc((nLen+1)*sizeof(TCHAR));
				if(NULL != lpszText && GetWindowText(m_hWnd,lpszText, nLen+1))
					SetLabel(lpszText);
				SafeFree(lpszText);
			}
		}

		// set hyperlink (defaults to label)
		if(m_lpstrHyperLink == NULL && m_lpstrLabel != NULL)
			SetHyperLink(m_lpstrLabel);

		CalcLabelRect();
	}

	void SubClassWindow(HWND hWnd)
	{
		if (SetProp(hWnd, strObjPtr, (HANDLE)this))
		{
//			bInit = TRUE;
			m_hWnd = hWnd;
			m_OrigWndProc = (WNDPROC) SetWindowLongPtr(hWnd,GWLP_WNDPROC,(LONG_PTR)CSysLink::_SysLinkWndProc);
		}
		Init();
	}

	static INT_PTR CALLBACK _SysLinkWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CSysLink *pThis = (CSysLink *)GetProp(hwnd, strObjPtr);

//		if (NULL != pThis)
//		{
			switch(uMsg)
			{
				HANDLE_MSG(hwnd, WM_ERASEBKGND,	pThis->_OnEraseBkgnd);
				HANDLE_MSG(hwnd, WM_PAINT, pThis->_OnPaint);
				HANDLE_MSG(hwnd, WM_SETFOCUS, pThis->_OnFocus);
				HANDLE_MSG(hwnd, WM_KILLFOCUS, pThis->_OnFocus);
				HANDLE_MSG(hwnd, WM_MOUSEMOVE, pThis->_OnMouseMove);
				HANDLE_MSG(hwnd, WM_LBUTTONDOWN, pThis->_OnLButtonDown);
				HANDLE_MSG(hwnd, WM_LBUTTONUP, pThis->_OnLButtonUp);
				HANDLE_MSG(hwnd, WM_CHAR, pThis->_OnChar);
				HANDLE_MSG(hwnd, WM_GETDLGCODE,  pThis->_OnGetDlgCode);
				HANDLE_MSG(hwnd, WM_SETCURSOR,  pThis->_OnSetCursor);
			}
//		}
		return CallWindowProc(pThis->m_OrigWndProc, hwnd,uMsg,wParam,lParam);
	}

	BOOL Invalidate(BOOL bErase = TRUE)
	{
		return InvalidateRect(m_hWnd, NULL, bErase);
	}

	BOOL Navigate()
	{
		if (m_IsHtmlHelp == TRUE)
			HtmlHelp(NULL,m_lpstrHyperLink,HH_DISPLAY_TOPIC,NULL);
		else
		{
			ShellExecute(0, _T("open"), m_lpstrHyperLink, 0, 0, SW_SHOWNORMAL);
		}
		return TRUE;
	}

	void SetSysLinkInstanceHandle(HINSTANCE hInstance)
	{
		m_hInstance = hInstance;
		m_hCursor = ::CreateCursor(hInstance, _Link_CursorData.xHotSpot, _Link_CursorData.yHotSpot, _Link_CursorData.cxWidth, _Link_CursorData.cyHeight, _Link_CursorData.arrANDPlane, _Link_CursorData.arrXORPlane);
	}

public: //Message Handlers
	BOOL _OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
	{
		POINT pt;
		GetCursorPos(&pt);
		ScreenToClient(m_hWnd,&pt);
		if(m_lpstrHyperLink != NULL && ::PtInRect(&m_rcLink, pt))
		{
			return TRUE;
		}
		return (BOOL)CallWindowProc(m_OrigWndProc, hwnd,WM_SETCURSOR,(WPARAM)hwndCursor,MAKELPARAM(codeHitTest,msg));
	}

	UINT _OnGetDlgCode(HWND hwnd, LPMSG lpmsg)
	{
		return DLGC_WANTCHARS;
	}

	void _OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
	{
		POINT pt = { x, y};
		if(m_lpstrHyperLink != NULL && PtInRect(&m_rcLink, pt))
			SetCursor(m_hCursor);
	}

	void _OnFocus(HWND hwnd, HWND hwndOldFocus)
	{
		Invalidate();
	}

	void _OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
	{
		POINT pt = { x, y };
		if(PtInRect(&m_rcLink, pt))
		{
			SetFocus(m_hWnd);
			SetCapture(m_hWnd);
		}
	}

	void _OnPaint(HWND hwnd)
	{
		PAINTSTRUCT ps;
		HDC hDC = BeginPaint(hwnd, &ps);
		m_hWnd = hwnd;
		DoPaint(hDC);
		EndPaint(hwnd, &ps);
	}

	void _OnChar(HWND hwnd, TCHAR ch, int cRepeat)
	{
		if(ch == VK_RETURN || ch == VK_SPACE)
			Navigate();
	}

	BOOL _OnEraseBkgnd(HWND hwnd, HDC hdc)
	{
/*		if(m_bPaintLabel)*/
		{
			HBRUSH hBrush = (HBRUSH)::SendMessage(GetParent(hwnd), WM_CTLCOLORSTATIC, (WPARAM)hdc, (LPARAM)m_hWnd);
			if(hBrush != NULL)
			{
				RECT rect;
				GetClientRect(m_hWnd, &rect);
				FillRect(hdc, &rect, hBrush);
			}
		}
		return 1;
	}

	void _OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
	{
		if(GetCapture() == m_hWnd)
		{
			ReleaseCapture();
			POINT pt = { x, y };
			if(PtInRect(&m_rcLink, pt))
				Navigate();
		}
	}

	void DoPaint(HDC hDC)
	{
		if (m_PaintedFocusRect)
		{
			m_PaintedFocusRect = false;
			DrawFocusRect(hDC, &m_rcLink);
		}

		SetBkMode(hDC, TRANSPARENT);
		SetTextColor(hDC, m_clrLink);
		if(m_hFont != NULL)
			SelectFont(hDC, m_hFont);

		LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;

		LONG_PTR dwStyle = GetWindowLongPtr(m_hWnd,GWL_STYLE);

		int nDrawStyle = DT_LEFT;
		if (dwStyle & SS_CENTER)
			nDrawStyle = DT_CENTER;
		else if (dwStyle & SS_RIGHT)
			nDrawStyle = DT_RIGHT;

		DrawText(hDC, lpstrText, -1, &m_rcLink, nDrawStyle | DT_WORDBREAK);

		if((GetFocus() == m_hWnd)&&(!m_PaintedFocusRect))
		{
			m_PaintedFocusRect = true;
			DrawFocusRect(hDC, &m_rcLink);
		}
	}

	bool CalcLabelRect()
	{
		if(m_lpstrLabel == NULL && m_lpstrHyperLink == NULL)
			return false;

		HDC hDC = GetDC(m_hWnd);

		RECT rect;
		GetClientRect(m_hWnd, &rect);
		m_rcLink = rect;

		HFONT hOldFont = NULL;
		if(m_hFont != NULL)
			hOldFont = SelectFont(hDC, m_hFont);
		LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;

		DWORD dwStyle = (DWORD)GetWindowLongPtr(m_hWnd,GWL_STYLE);
		int nDrawStyle = DT_LEFT;
		if (dwStyle & SS_CENTER)
			nDrawStyle = DT_CENTER;
		else if (dwStyle & SS_RIGHT)
			nDrawStyle = DT_RIGHT;
		DrawText(hDC, lpstrText, -1, &m_rcLink, nDrawStyle | DT_WORDBREAK | DT_CALCRECT);
		if(m_hFont != NULL)
			SelectFont(hDC, hOldFont);
		return true;
	}

	bool SetLabel(LPCTSTR lpstrLabel)
	{
		free(m_lpstrLabel);
		m_lpstrLabel = NULL;
		int ilen = lstrlen(lpstrLabel) + 1;
		m_lpstrLabel = (LPTSTR)malloc(ilen * sizeof(TCHAR));
		if(m_lpstrLabel == NULL)
			return false;
		//lstrcpy(m_lpstrLabel, lpstrLabel);
		if (FAILED(StringCchCopyEx(m_lpstrLabel, ilen, lpstrLabel, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			free(m_lpstrLabel);
			m_lpstrLabel = NULL;
			return false;
		}
		CalcLabelRect();
		return true;
	}

#if 0
	bool GetLabel(LPTSTR lpstrBuffer, int nLength)
	{
		if (NULL != m_lpstrLabel &&
			nLength > lstrlen(m_lpstrLabel) &&
			SUCCEEDED(StringCchCopyEx(lpstrBuffer, nLength, m_lpstrLabel, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			return true;
		}
		return false;
	}
#endif

	bool SetHyperLink(LPCTSTR lpstrLink)
	{
		free(m_lpstrHyperLink);
		m_lpstrHyperLink = NULL;
		int ilen = lstrlen(lpstrLink) + 1;
		m_lpstrHyperLink = (LPTSTR)malloc(ilen * sizeof(TCHAR));
		if(m_lpstrHyperLink == NULL)
			return false;
		if (FAILED(StringCchCopyEx(m_lpstrHyperLink, ilen, lpstrLink, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			free(m_lpstrHyperLink);
			m_lpstrHyperLink = NULL;
			return false;
		}
		if(m_lpstrLabel == NULL)
			CalcLabelRect();
		return true;
	}

#if 0
	bool GetHyperLink(LPTSTR lpstrBuffer, int nLength)
	{
		if (NULL != m_lpstrHyperLink &&
			nLength > lstrlen(m_lpstrHyperLink) &&
			SUCCEEDED(StringCchCopyEx(lpstrBuffer, nLength, m_lpstrHyperLink, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			return true;
		}
		return false;
	}
#endif

private:
//	BOOL bInit;
	BOOL m_IsHtmlHelp;
	HWND m_hWnd;
	WNDPROC m_OrigWndProc;

	LPTSTR m_lpstrLabel;
	LPTSTR m_lpstrHyperLink;
	HCURSOR m_hCursor;
//	bool m_bPaintLabel;
	HFONT m_hFont;
	RECT m_rcLink;

	bool m_PaintedFocusRect;
	COLORREF m_clrLink; //set once

	HINSTANCE m_hInstance;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\cltdebug.h ===
#pragma once

#ifdef DBG

void DebugCheckForAutoPilot(HWND hwnd);
void DebugUninstallDemoPackages(void);

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\customlb.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    customlb.h
//
//  Creator: weiw
//
//  Purpose: custom list box header file
//
//=======================================================================

#pragma once

#define XBITMAP 20

// ATTENTION_COLOR: color for link when mouse is over 
// NOATTENTION_COLOR: otherwise
//#define NOATTENTION_COLOR	COLOR_GRAYTEXT
#define ATTENTION_COLOR		COLOR_HOTLIGHT

// Foward declarations of functions included in this code module:

#define MAX_RTF_LENGTH			80 //in charaters
#define MAX_TITLE_LENGTH		300
#define MAX_DESC_LENGTH			3000 // 750 in the spec, leave room to adapt 
#define DEF_CHECK_HEIGHT		13
#define SECTION_SPACING			6 //spacing between title, description and RTF
#define TITLE_MARGIN			6 //margin at the left and right for title
#define RTF_MARGIN				20 //margin at the right of rtf
#define MAX_RTFSHORTCUTDESC_LENGTH	140


class LBITEM
{
public:
    TCHAR szTitle[MAX_TITLE_LENGTH]; 
    LPTSTR pszDescription;
	TCHAR szRTF[MAX_RTF_LENGTH];
	UINT	  m_index; // index of item in gvList
    BOOL  bSelect;
    BOOL  bRTF;
    RECT rcTitle;
    RECT rcText;
    RECT rcBitmap; // weiwfixcode: missleading name. the same as rcTitle
    RECT rcRTF;
    RECT rcItem;
    //int  xTitle; // extra len for the title hit point
public:
	LBITEM()
	{
		ZeroMemory(szTitle, sizeof(szTitle));
		ZeroMemory(szRTF, sizeof(szRTF));
		ZeroMemory(&rcTitle, sizeof(rcTitle));
		ZeroMemory(&rcText, sizeof(rcText));
		ZeroMemory(&rcBitmap, sizeof(rcBitmap));
		ZeroMemory(&rcRTF, sizeof(rcRTF));
		ZeroMemory(&rcItem, sizeof(rcItem));
		bSelect = FALSE;
		bRTF = FALSE;
		pszDescription = NULL;
	}

	~LBITEM()
	{
		if (NULL != pszDescription)
		{
			free(pszDescription);
		}
	}
};

typedef enum tagMYLBFOCUS {
	MYLB_FOCUS_TITLE =1,
	MYLB_FOCUS_RTF
} MYLBFOCUS;


const TCHAR MYLBALIVEPROP[] = TEXT("MYLBAlive");

extern HWND ghWndList;
extern INT  gFocusItemId;
extern TCHAR gtszRTFShortcut[MAX_RTFSHORTCUTDESC_LENGTH];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\cltdebug.cpp ===
#include "pch.h"
#pragma hdrstop

#ifdef DBG
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    cltdebug.cpp
//
//  Creator: PeterWi
//
//  Purpose: wuauclt debug functions.
//
//=======================================================================
const UINT_PTR AU_AUTOPILOT_TIMER_ID = 555;
const DWORD AU_AUTOPILOT_TIMEOUT = 2000;

//=======================================================================
//
//  DebugAutoPilotTimerProc
//
//  Called after timeout to dismiss dialog.
//
//=======================================================================

VOID CALLBACK DebugAutoPilotTimerProc( HWND hWnd,         // handle to window
								  UINT /*uMsg*/,         // WM_TIMER message
								  UINT_PTR /*idEvent*/,  // timer identifier
								  DWORD /*dwTime*/)      // current system time
{
	if ( hWnd == ghMainWindow )
	{
		PostMessage(hWnd, AUMSG_TRAYCALLBACK, 0, WM_LBUTTONDOWN);
	}
	else
	{
		PostMessage(hWnd, WM_COMMAND, IDC_OK, 0);
	}

	KillTimer(hWnd, AU_AUTOPILOT_TIMER_ID);
}

//=======================================================================
//
//  DebugCheckForAutoPilot
//
//  Check to see if we want AU to run by itself.
//
//=======================================================================
void DebugCheckForAutoPilot(HWND hWnd)
{
	DWORD dwAutoPilot;

	if ( SUCCEEDED(GetRegDWordValue(TEXT("AutoPilot"), &dwAutoPilot)) &&
		 (0 != dwAutoPilot) )
	{
		SetTimer(hWnd, AU_AUTOPILOT_TIMER_ID, AU_AUTOPILOT_TIMEOUT, DebugAutoPilotTimerProc);
	}
}

//=======================================================================
//
//  DebugUninstallDemoPackages
//
//  Uninstall demo packages and increase iteration count.
//
//=======================================================================
void DebugUninstallDemoPackages(void)
{
	DWORD dwAutoPilot;

	if ( SUCCEEDED(GetRegDWordValue(TEXT("AutoPilot"), &dwAutoPilot)) &&
		 (0 != dwAutoPilot) )
	{
		if ( FAILED(GetRegDWordValue(TEXT("AutoPilotIteration"), &dwAutoPilot)) )
		{
			dwAutoPilot = 0;
		}

		DEBUGMSG("AUTOPILOT: Finished iteration %d", ++dwAutoPilot);
		SetRegDWordValue(TEXT("AutoPilotIteration"), dwAutoPilot);

		fRegKeyDelete(TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{0A1F2CEC-8688-4d1b-A266-051415FBEE91}"));
		fRegKeyDelete(TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{09AC50A5-0354-479b-8961-EDA2CE7AC002}"));
		fRegKeyDelete(TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{0101E65E-8C15-4551-8455-D2CC10FBEA01}"));
	}
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\customlbacc.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    customlbacc.cpp
//
//  Creator: weiw
//
//  Purpose: custom list box accessibility file
//
//=======================================================================
#include <pch.h>
#pragma hdrstop

BSTR GetMYLBItemTitle(DWORD idChild)
{
	//DEBUGMSG("GetMYLBItemTitle() called");
	static LPCTSTR tszDefItemTitle = _T("");
	LRESULT lr =  SendMessage(ghWndList, LB_GETITEMDATA, idChild, 0);
	if (LB_ERR == lr)
	{
		return SysAllocString(tszDefItemTitle);
	}
	LBITEM *pItem = (LBITEM*) lr;
	return SysAllocString(pItem->szTitle);
}

BSTR GetMYLBItemDesc(DWORD idChild)
{
	//DEBUGMSG("GetMYLBItemDesc() called");
	static LPCTSTR tszDefItemDesc = _T("");
	_bstr_t bstrItemDesc;
	BSTR   bsRet = NULL;
	LRESULT lr = SendMessage(ghWndList, LB_GETITEMDATA, idChild, 0);
	try 
	{
		if (LB_ERR == lr)
		{
			bstrItemDesc = _bstr_t(tszDefItemDesc);
		}
		else
		{
			LBITEM *pItem = (LBITEM*) lr;
			bstrItemDesc = _bstr_t(pItem->pszDescription);
			if (pItem->bRTF)
			{
				DEBUGMSG("GetMYLBItemDesc() Item got RTF, adding %S", gtszRTFShortcut);
				bstrItemDesc += _bstr_t(gtszRTFShortcut);
			}
		}
		bsRet = bstrItemDesc.copy();
	}
	catch (...)
	{
		DEBUGMSG("GetMYLBItemDesc() got _bstr_t exception");
	}
	return bsRet;
}

DWORD GetMYLBItemState(DWORD idChild)
{
	//DEBUGMSG("GetMYLBItemState() called");
	DWORD dwState = STATE_SYSTEM_FOCUSABLE|STATE_SYSTEM_SELECTABLE;
	LRESULT lr = SendMessage(ghWndList, LB_GETITEMDATA, idChild, 0);
	if (LB_ERR == lr)
	{
		goto done;
	}
	LBITEM *pItem = (LBITEM*) lr;
	if (pItem->bSelect)
	{
		dwState |= STATE_SYSTEM_CHECKED;
	}
	if (idChild == gFocusItemId)
	{
		dwState |= STATE_SYSTEM_FOCUSED|STATE_SYSTEM_SELECTED;
	}
done:
	return dwState;
}

HRESULT STDMETHODCALLTYPE MYLBAccPropServer::GetPropValue ( 
        const BYTE *    pIDString,
        DWORD           dwIDStringLen,
        MSAAPROPID      idProp,
        VARIANT *       pvarValue,
        BOOL *          pfGotProp )
{
	HRESULT hr = S_OK;
	BOOL fHoldMYLB = FALSE;

	//DEBUGMSG("MYLBAccPropServer::GetPropValue() starts");
	if (NULL == pvarValue || NULL == pfGotProp)
	{
		hr = E_INVALIDARG;
		goto done;
	}

	pvarValue->vt = VT_EMPTY;
	*pfGotProp = FALSE;

	if (!(fHoldMYLB = TryEnterCriticalSection(&gcsClient))|| 
		! IsWindow( ghWndList ) ||
		GetProp( ghWndList, MYLBALIVEPROP) != (HANDLE)TRUE )
	{
		DEBUGMSG("GetPropValue() MYLB is not alive any more");
		hr = RPC_E_DISCONNECTED;
		goto done;
	}

    HWND  hwnd;
    DWORD idObject;
    DWORD idChild;

    if( S_OK != m_pAccPropSvc->DecomposeHwndIdentityString( pIDString, dwIDStringLen,
                & hwnd, & idObject, & idChild ) )
    {
        // problem decomposing identity string - return early...
        goto done;
    }

    if( idChild != CHILDID_SELF )
    {
        DEBUGMSG("MYLBAccPropServer::GetPropValue() for child Id %lu", idChild);
        if  (PROPID_ACC_NAME == idProp)
        {
            pvarValue->bstrVal = GetMYLBItemTitle(idChild-1);
			if (NULL == pvarValue->bstrVal)
			{
				goto done;
			}
			pvarValue->vt = VT_BSTR;
            *pfGotProp = TRUE;
		}
		else if (PROPID_ACC_STATE == idProp)
		{
			pvarValue->vt = VT_I4;
			pvarValue->lVal = GetMYLBItemState(idChild-1);
			*pfGotProp = TRUE;
		}
		else if (PROPID_ACC_ROLE == idProp)
		{
			pvarValue->vt = VT_I4;
            pvarValue->lVal = ROLE_SYSTEM_CHECKBUTTON;
            *pfGotProp = TRUE;
		}
		else if (PROPID_ACC_DESCRIPTION == idProp)
		{
			pvarValue->bstrVal = GetMYLBItemDesc(idChild-1);
			if (NULL == pvarValue->bstrVal)
			{
				goto done;
			}
			pvarValue->vt = VT_BSTR;
			*pfGotProp = TRUE;
		}
    }

done:
	if (fHoldMYLB)
	{
		LeaveCriticalSection(&gcsClient);
	}

	//DEBUGMSG("MYLBAccPropServer::GetPropValue() ends");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\customlbacc.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    customlbacc.h
//
//  Creator: weiw
//
//  Purpose: custom list box accessibility header file
//
//=======================================================================

#pragma once
#include <pch.h>


class MYLBAccPropServer : public IAccPropServer {

    LONG               m_Ref;
    IAccPropServices *  m_pAccPropSvc;

public:

    MYLBAccPropServer(IAccPropServices * pAccPropSvc )
        : m_Ref( 1 ),
          m_pAccPropSvc( pAccPropSvc )
    {
        m_pAccPropSvc->AddRef();
    }

    ~MYLBAccPropServer()
    {
        m_pAccPropSvc->Release();
    }
	
// IUnknown
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject)
	{
		HRESULT hr = S_OK;
		*ppvObject = NULL;

		if (__uuidof(IUnknown)  == riid ||
			__uuidof(IAccPropServer) == riid)
        {
			*ppvObject = (void *)this;
			AddRef();
        }
		else
        {
			DEBUGMSG("MYLBAccPropServer QueryInterface(): interface not supported");
			hr = E_NOINTERFACE;
        }

		return hr;
	}

	STDMETHOD_(ULONG, AddRef)(void)
	{
		 long cRef = InterlockedIncrement(&m_Ref);
		 //DEBUGMSG("MYLBAccPropServer AddRef = %d", cRef);
		 return cRef;
	}
	
	STDMETHOD_(ULONG, Release)(void)
	{
		long cRef = InterlockedDecrement(&m_Ref);
		//DEBUGMSG("MYLBAccPropServer Release = %d", cRef);
		if (0 == cRef)
		{
			delete this;
		}
		return cRef;
	}

// IAccPropServer
	HRESULT STDMETHODCALLTYPE GetPropValue ( 
            const BYTE *    pIDString,
            DWORD           dwIDStringLen,
            MSAAPROPID      idProp,
            VARIANT *       pvarValue,
            BOOL *          pfGotProp );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\installcallback.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCltCatalog.cpp
//
//  Creator: PeterWi
//
//  Purpose: Client AU Catalog Functions
//
//=======================================================================

#include "pch.h"
#include "iuprogress.h"

#include "AUEventMsgs.h"

//=======================================================================
//
// CInstallCallback::QueryInterface
//
//=======================================================================
STDMETHODIMP CInstallCallback::QueryInterface(REFIID riid, void **ppvObject)
{
   if ( (riid == __uuidof(IUnknown)) || (riid == IID_IProgressListener) )
	{
		*ppvObject = this;
		AddRef();
	}
	else
	{
		*ppvObject = NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

//=======================================================================
//
// CInstallCallback::AddRef
//
//=======================================================================
STDMETHODIMP_(ULONG) CInstallCallback::AddRef(void)
{
    return InterlockedIncrement(&m_refs);;
}

//=======================================================================
//
// CInstallCallback::Release
//
//=======================================================================
STDMETHODIMP_(ULONG) CInstallCallback::Release(void)
{
   return InterlockedDecrement(&m_refs);
}
	
//=======================================================================
//
// CInstallCallback::OnItemStart
//
//=======================================================================
STDMETHODIMP CInstallCallback::OnItemStart( 
            IN BSTR /*bstrUuidOperation*/,
            IN BSTR bstrXmlItem,
            OUT LONG *plCommandRequest)
{
    DEBUGMSG("InstallProgressListener::OnItemStart(%S)", bstrXmlItem);
	*plCommandRequest = 0;			
    return S_OK;
}

//=======================================================================
//
// CInstallCallback::OnProgress
//
//=======================================================================
STDMETHODIMP CInstallCallback::OnProgress( 
            IN  BSTR /*bstrUuidOperation*/,
            IN  VARIANT_BOOL fItemCompleted,
            IN  BSTR bstrProgress,
            OUT LONG *plCommandRequest)
{
	DEBUGMSG("InstallProgressListener::OnProgress(%S), %s", 
             bstrProgress, (VARIANT_TRUE == fItemCompleted) ? "completed" : "ongoing");
	
    *plCommandRequest = 0;			

    if ( fItemCompleted )
    {
    	SendMessage(ghCurrentDialog, AUMSG_INSTALL_PROGRESS, 0, 0);
    }

	return S_OK;
}

//=======================================================================
//
// CInstallCallback::OnOperationComplete
//
//=======================================================================

HRESULT LogEventToServer(
			IUpdates *pUpdates,
			WORD wType,
			WORD wCategory,
			DWORD dwEventID,
			DWORD dwItemCount,
			BSTR *pbstrItems);

STDMETHODIMP CInstallCallback::OnOperationComplete( 
            /* [in] */ BSTR bstrUuidOperation,
            /* [in] */ BSTR bstrXmlItems)
{
	DEBUGMSG("InstallProgressListener::OnOperationComplete() for %S", bstrUuidOperation);
    HRESULT hr;

#ifdef DBG
    LOGXMLFILE(INSTALLRESULTS_FILE, bstrXmlItems);
#endif

    // determine if reboot needed
    IXMLDOMDocument *pxmlInstallResult = NULL;
    IXMLDOMNodeList *pItemStatuses = NULL;
	BSTR *pbstrItemsSucceeded = NULL;
	BSTR *pbstrItemsFailed = NULL;
	BSTR *pbstrItemsNeedReboot = NULL;
	IXMLDOMNode *pItemStatus = NULL;
	IXMLDOMNode *pChild = NULL;
	BSTR bstrTitle = NULL;
	BSTR bstrStatus = NULL;
	DWORD dwNumOfItemsSucceeded = 0;
	DWORD dwNumOfItemsFailed = 0;
	DWORD dwNumOfItemsNeedReboot = 0;
	IUpdates *pUpdates = NULL;
	BOOL fCoInit = FALSE;
	BSTR bstrItemStatusXPath 		= SysAllocString(L"items/itemStatus");
	BSTR bstrTitleXPath 			= SysAllocString(L"description/descriptionText/title");
	BSTR bstrItemStatusNode 		= SysAllocString(L"installStatus");
	BSTR bstrValueAttribute 		= SysAllocString(L"value");
	BSTR bstrNeedsRebootAttribute 	= SysAllocString(L"needsReboot");

	if (NULL == bstrItemStatusXPath || NULL == bstrTitleXPath || NULL == bstrItemStatusNode || NULL == bstrValueAttribute || NULL == bstrNeedsRebootAttribute)
	{
		hr = E_OUTOFMEMORY;
		goto CleanUp;	
	}

	if (FAILED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() CoInitialize failed (%#lx)", hr);
		goto CleanUp;
	}
	fCoInit = TRUE;

    if ( FAILED(hr = LoadXMLDoc(bstrXmlItems, &pxmlInstallResult)) )
    {
		DEBUGMSG("InstallProgressListener::OnOperationComplete() call to LoadXMLDoc() failed (%#lx)", hr);
		pxmlInstallResult = NULL;
        goto CleanUp;
    }

	if (FAILED(hr = pxmlInstallResult->selectNodes(bstrItemStatusXPath, &pItemStatuses)) )
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() fail to select node");
		pItemStatuses = NULL;
		goto CleanUp;
	}

    long lLen;
	if (FAILED(hr = pItemStatuses->get_length(&lLen)))
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() fail to get count of item statuses");
		goto CleanUp;
	}

	if (0 >= lLen)
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() no item statuses found");
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	if (NULL == (pbstrItemsSucceeded = (BSTR *) malloc(sizeof(BSTR) * lLen)) ||
		NULL == (pbstrItemsFailed = (BSTR *) malloc(sizeof(BSTR) * lLen)) ||
		NULL == (pbstrItemsNeedReboot = (BSTR *) malloc(sizeof(BSTR) * lLen)))
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() failed to alloc memory for BSTR *'s");
		hr = E_OUTOFMEMORY;
		goto CleanUp;
	}

	for (long index = 0; index < lLen; index++)
    {
		if (S_OK != (hr = pItemStatuses->get_item(index, &pItemStatus)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to get_item() failed (%#lx)", hr);
			pItemStatus = NULL;
			if (S_FALSE == hr)
			{
				hr = E_FAIL;
			}
			goto CleanUp;
		}

		if (S_OK != (hr = pItemStatus->selectSingleNode(bstrTitleXPath, &pChild)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to selectSingleNode() failed (%#lx)", hr);
			pChild = NULL;
			if (S_FALSE == hr)
			{
				hr = E_INVALIDARG;
			}
			goto CleanUp;
		}

		if (S_OK != (hr = GetText(pChild, &bstrTitle)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to GetText() failed (%#lx)", hr);
			bstrTitle = NULL;
			if (S_FALSE == hr)
			{
				hr = E_INVALIDARG;
			}
			goto CleanUp;
		}

		pChild->Release();
		pChild = NULL;

		if (S_OK != (hr = pItemStatus->selectSingleNode(bstrItemStatusNode, &pChild)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to selectSingleNode() failed (%#lx)", hr);
			pChild = NULL;
			if (S_FALSE == hr)
			{
				hr = E_INVALIDARG;
			}
			goto CleanUp;
		}

		if (S_OK != (hr = GetAttribute(pChild, bstrValueAttribute, &bstrStatus)))
		{
			DEBUGMSG("InstallProgressListener::OnOperationComplete() call to GetAttribute(..., \"value\", ...) failed (%#lx)", hr);
			bstrStatus = NULL;
			if (S_FALSE == hr)
			{
				hr = E_INVALIDARG;
			}
			goto CleanUp;
		}

		if (CSTR_EQUAL == WUCompareStringI(bstrStatus, L"COMPLETE"))
		{
			BOOL fReboot;

			if (S_OK != (hr = GetAttribute(pChild, bstrNeedsRebootAttribute, &fReboot)))
			{
				DEBUGMSG("InstallProgressListener::OnOperationComplete() call to GetAttribute(..., \"needsReboot\", ...) failed (%#lx)", hr);
				if (S_FALSE == hr)
				{
					hr = E_INVALIDARG;
				}
				goto CleanUp;
			}
			if (fReboot)
			{
				pbstrItemsNeedReboot[dwNumOfItemsNeedReboot++] = bstrTitle;
				gpClientCatalog->m_fReboot = TRUE;
			}
			pbstrItemsSucceeded[dwNumOfItemsSucceeded++] = bstrTitle;
			// Now pbstrItemsSucceeded is responsible to free the BSTR.
		}
		else if (CSTR_EQUAL == WUCompareStringI(bstrStatus, L"FAILED"))
		{
			pbstrItemsFailed[dwNumOfItemsFailed++] = bstrTitle;
			// Now pbstrItemsFailed is responsible to free the BSTR.
		}
		SysFreeString(bstrStatus);
		bstrStatus = NULL;

		pChild->Release();
		pChild = NULL;

		bstrTitle = NULL;
    }

	if (FAILED(hr = CoCreateInstance(__uuidof(Updates),
						 NULL,
						 CLSCTX_LOCAL_SERVER,
						 IID_IUpdates,
						 (LPVOID*)&pUpdates)))
	{
		DEBUGMSG("LogEventToServer failed to get Updates object (%#lx)", hr);
		goto CleanUp;
	}

	if (0 < dwNumOfItemsSucceeded)
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() %lu items was successfully installed", dwNumOfItemsSucceeded);
		LogEventToServer(
			pUpdates,
			EVENTLOG_INFORMATION_TYPE,
			IDS_MSG_Installation,
			IDS_MSG_InstallationSuccessful,
			dwNumOfItemsSucceeded,
			pbstrItemsSucceeded);
	}
	if (0 < dwNumOfItemsFailed)
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() %lu items failed to install", dwNumOfItemsFailed);
		LogEventToServer(
			pUpdates,
			EVENTLOG_ERROR_TYPE,
			IDS_MSG_Installation,
			IDS_MSG_InstallationFailure,
			dwNumOfItemsFailed,
			pbstrItemsFailed);
	}
	if (0 < dwNumOfItemsNeedReboot)
	{
		DEBUGMSG("InstallProgressListener::OnOperationComplete() %lu items was installed and require reboot", dwNumOfItemsNeedReboot);

		AUOPTION auopt;
		if (SUCCEEDED(hr = pUpdates->get_Option(&auopt)) &&
			AUOPTION_SCHEDULED == auopt.dwOption)
		{
			LogEventToServer(
				pUpdates,
				EVENTLOG_INFORMATION_TYPE,
				IDS_MSG_Installation,
				IDS_MSG_RestartNeeded_Scheduled,
				dwNumOfItemsNeedReboot,
				pbstrItemsNeedReboot);
		}
		else
		{
			LogEventToServer(
				pUpdates,
				EVENTLOG_INFORMATION_TYPE,
				IDS_MSG_Installation,
				IDS_MSG_RestartNeeded_Unscheduled,
				dwNumOfItemsNeedReboot,
				pbstrItemsNeedReboot);
		}
	}

CleanUp:
	SafeFreeBSTR(bstrItemStatusXPath);
	SafeFreeBSTR(bstrTitleXPath);
	SafeFreeBSTR(bstrItemStatusNode);
	SafeFreeBSTR(bstrValueAttribute);
	SafeFreeBSTR(bstrNeedsRebootAttribute);
	SafeRelease(pUpdates);
	SysFreeString(bstrStatus);
	SysFreeString(bstrTitle);
	SafeRelease(pChild);
	SafeRelease(pItemStatus);
	SafeFree(pbstrItemsNeedReboot);
	if (NULL != pbstrItemsFailed)
	{
		while(dwNumOfItemsFailed > 0)
		{
			SysFreeString(pbstrItemsFailed[--dwNumOfItemsFailed]);
		}
		free(pbstrItemsFailed);
	}
	if (NULL != pbstrItemsSucceeded)
	{
		while(dwNumOfItemsSucceeded > 0)
		{
			SysFreeString(pbstrItemsSucceeded[--dwNumOfItemsSucceeded]);
		}
		free(pbstrItemsSucceeded);
	}
    SafeRelease(pItemStatuses);
    SafeRelease(pxmlInstallResult);
	if (fCoInit)
	{
		CoUninitialize();
	}

	DEBUGMSG("InstallProgressListener::OnOperationComplete() ends");
	return hr;
}

HRESULT LogEventToServer(
			IUpdates *pUpdates,
			WORD wType,
			WORD wCategory,
			DWORD dwEventID,
			DWORD dwItemCount,
			BSTR *pbstrItems)
{
	DEBUGMSG("LogEventToServer");

    HRESULT hr;
	SAFEARRAY *psa;

	SAFEARRAYBOUND bound[1] = { dwItemCount, 0};

	if (NULL == (psa = SafeArrayCreate(VT_BSTR, 1, bound)))
	{
		DEBUGMSG("LogEventToServer failed to create safearray");
		hr = E_OUTOFMEMORY;
		goto CleanUp;
	}

	BSTR *pbstrElements;

	if (S_OK != (hr = SafeArrayAccessData(psa, (void **)&pbstrElements)))
    {
		DEBUGMSG("LogEventToServer failed to access savearray date (%#lx)", hr);
		goto CleanUp;
    }

	for ( DWORD i = 0; i < dwItemCount; i++ )
	{
		if (NULL == (pbstrElements[i] = SysAllocString(pbstrItems[i])))
		{
			DEBUGMSG("LogEventToServer failed to allocate BSTR memory");
			hr = E_OUTOFMEMORY;
			break;
		}
	}

	if (S_OK != (hr = SafeArrayUnaccessData(psa)))
	{
		DEBUGMSG("LogEventToServer failed to unaccess safearray data (%#lx)", hr);
	}

	if (FAILED(hr))
	{
		goto CleanUp;
	}

	VARIANT varItems;
    varItems.vt = VT_ARRAY | VT_BSTR;
	varItems.parray = psa;

    hr = pUpdates->LogEvent(wType, wCategory, dwEventID, varItems);
	if (FAILED(hr))
	{
		DEBUGMSG("LogEventToServer failed to call pUpdates->LogEvent (%#lx)", hr);
	}

CleanUp:
	if (NULL != psa)
	{
		(void) SafeArrayDestroy(psa);
	}
	return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\customlb.cpp ===
#include "pch.h"
#pragma hdrstop


void SetMYLBAcc(HWND hListWin);
void DrawMYLBFocus(HWND hListWin, LPDRAWITEMSTRUCT lpdis, MYLBFOCUS enCurFocus, INT nCurFocusId);
void DrawItem(LPDRAWITEMSTRUCT lpdis, BOOL fSelectionDisabled);
void DrawTitle(HDC hDC, LBITEM * plbi, RECT rc);
void DrawRTF(HDC hDC, LBITEM * plbi, const RECT & rc /*, BOOL bHit*/);
void DrawDescription(HDC hDC, LBITEM * plbi, RECT & rc);
void DrawBitmap(HDC hDC, LBITEM * plbi, const RECT & rc, BOOL fSel, BOOL fSelectionDisabled);
void CalcTitleFocusRect(const RECT &rcIn, RECT & rcOut);
void CalcRTFFocusRect(const RECT &rcIn, RECT & rcOut);
int  CalcDescHeight(HDC hDC, LBITEM * plbi, int cx);
int  CalcRTFHeight(HDC hDC, LBITEM * plbi);
int  CalcRTFWidth(HDC hDC, LBITEM * plbi);
int  CalcTitleHeight(HDC hDC, LBITEM * plbi, int cx);
void CalcItemLocation(HDC hDC, LBITEM * plbi, const RECT & rc);
void ToggleSelection(HWND hDlg, HWND hListWin, LBITEM *pItem);
void AddItem(LPTSTR tszTitle, LPTSTR tszDesc, LPTSTR tszRTF, int index, BOOL fSelected, BOOL fRTF);
BOOL CurItemHasRTF(HWND hListWin);
void RedrawMYLB(HWND hwndLB);
void LaunchRTF(HWND hListWin);


HBITMAP ghBmpGrayOut; //=NULL;
HBITMAP ghBmpCheck; // = NULL;
HBITMAP ghBmpClear; // = NULL;
HFONT   ghFontUnderline; // = NULL;
HFONT   ghFontBold; // = NULL;
HFONT   ghFontNormal; // = NULL;
HWND   ghWndList; //=NULL;

MYLBFOCUS gFocus;
INT	  gFocusItemId;
TCHAR gtszRTFShortcut[MAX_RTFSHORTCUTDESC_LENGTH];


void LaunchRTF(HWND hListWin)
{
	HWND hDlg = GetParent(hListWin);
	int i = (LONG)SendMessage(ghWndList, LB_GETCURSEL, 0, 0);
	if(i != LB_ERR)
	{
		LBITEM* pItem = (LBITEM*)SendMessage(hListWin, LB_GETITEMDATA, i, 0);
		if (pItem && pItem->bRTF)
		{
			DEBUGMSG("MYLB show RTF for item %S", pItem->szTitle);
			PostMessage(GetParent(hDlg), AUMSG_SHOW_RTF, LOWORD(pItem->m_index), 0);
		}
	}  
}

////////////////////////////////////////////////////////////////////////////////
// Overwrite hListWin's accessibility behavior using dynamic annotation server
////////////////////////////////////////////////////////////////////////////////
void SetMYLBAcc(HWND hListWin)
{
    IAccPropServices * pAccPropSvc = NULL;
    HRESULT hr = CoCreateInstance(CLSID_AccPropServices, 
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IAccPropServices,
				(void **) &pAccPropSvc);
    if( hr == S_OK && pAccPropSvc )
    {
        MYLBAccPropServer* pMYLBPropSrv = new MYLBAccPropServer( pAccPropSvc );
        if( pMYLBPropSrv )
        {
            
            MSAAPROPID propids[4];
            propids[0] = PROPID_ACC_NAME;
			propids[1] = PROPID_ACC_STATE;
			propids[2] = PROPID_ACC_ROLE;
			propids[3] = PROPID_ACC_DESCRIPTION;

			pAccPropSvc->SetHwndPropServer( hListWin, OBJID_CLIENT, 0, propids, 4, pMYLBPropSrv, ANNO_CONTAINER);
		
            pMYLBPropSrv->Release();
        }
		pAccPropSvc->Release();
    }
    else
    {
    	DEBUGMSG("WANRING: WUAUCLT   Fail to create object AccPropServices with error %#lx", hr);
    }
	// Mark the listbox so that the server can tell if it alive
	SetProp(hListWin, MYLBALIVEPROP, (HANDLE)TRUE);

}

/*void DumpRect(LPCTSTR tszName, RECT rc)
{
	DEBUGMSG("DumpRect %S at (%d, %d, %d, %d)", tszName, rc.left, rc.top, rc.right, rc.bottom);
}
*/

void DrawItem(LPDRAWITEMSTRUCT lpdis, BOOL fSelectionDisabled)
{
	LRESULT lResult = SendMessage(lpdis->hwndItem, LB_GETITEMDATA, lpdis->itemID, 0); 
	
	if (LB_ERR == lResult)
	{
		return;
	}
	LBITEM * plbi = (LBITEM*) lResult;
	CalcItemLocation(lpdis->hDC, plbi, lpdis->rcItem);
	// Draw the title of the item
	DrawTitle(lpdis->hDC, plbi, plbi->rcTitle);
	// Draw the text of the item
	DrawDescription(lpdis->hDC, plbi, plbi->rcText);
	// Draw the bitmap
	DrawBitmap(lpdis->hDC, plbi, plbi->rcBitmap, plbi->bSelect, fSelectionDisabled);
	// draw the Read this First 
	DrawRTF(lpdis->hDC, plbi, plbi->rcRTF);
}

BOOL CurItemHasRTF(HWND hListWin)
{
	int i = (LONG)SendMessage(hListWin, LB_GETCURSEL, 0, 0);
	if (LB_ERR == i)
	{
		return FALSE;
	}
	LBITEM *pItem = (LBITEM*)SendMessage(hListWin, LB_GETITEMDATA, (WPARAM)i, 0);
	return pItem->bRTF;
}

BOOL fDisableSelection(void)
{
     AUOPTION auopt;
    if (SUCCEEDED(gInternals->m_getServiceOption(&auopt))
         && auopt.fDomainPolicy && AUOPTION_SCHEDULED == auopt.dwOption)
        {
            return TRUE;
        }
    return FALSE;
}

void ToggleSelection(HWND hDlg, HWND hListWin, LBITEM *pItem)
{
	//DEBUGMSG("ToggleSelection()");
	if (NULL == hDlg || NULL == hListWin || NULL == pItem || pItem->m_index >= gInternals->m_ItemList.Count())
	{
		AUASSERT(FALSE); //should never reach here.
		return;
	}
    HDC hDC = GetDC(hListWin);

	if (NULL == hDC)
	{
		return;
	}
	pItem->bSelect = !pItem->bSelect;
    DrawBitmap(hDC, pItem, pItem->rcBitmap, pItem->bSelect, FALSE); //obviously selection is allowed

#ifndef TESTUI
    gInternals->m_ItemList[pItem->m_index].SetStatus(pItem->bSelect ? AUCATITEM_SELECTED : AUCATITEM_UNSELECTED);
#endif
    PostMessage(GetParent(hDlg), AUMSG_SELECTION_CHANGED, 0, 0);
    ReleaseDC(hListWin, hDC);
}


void RedrawMYLB(HWND hwndLB)
{
	//DEBUGMSG("REDRAW MYLB ");
	InvalidateRect(ghWndList, NULL, TRUE);
	UpdateWindow(ghWndList);
}

void CalcTitleFocusRect(const RECT &rcIn, RECT & rcOut)
{
	rcOut = rcIn;
	rcOut.right -= TITLE_MARGIN * 2/3;
	rcOut.top += SECTION_SPACING * 2/3;
	rcOut.bottom -= SECTION_SPACING*2/3 ;
}

void CalcRTFFocusRect(const RECT &rcIn, RECT & rcOut)
{
	rcOut = rcIn;
	rcOut.left -=3;
	rcOut.right +=3;
	rcOut.top -= 2;
	rcOut.bottom += 2;
}

void DrawMYLBFocus(HWND hListWin, LPDRAWITEMSTRUCT lpdis, MYLBFOCUS enCurFocus, INT nCurFocusId)
{
	LBITEM * pItem;
	LRESULT lResult;
	
	//DEBUGMSG("DrawMYLBFocus for current focus %d with Item %d", enCurFocus, nCurFocusId);

	RECT rcNew;

	if (nCurFocusId != lpdis->itemID)
	{
		return;
	}

	if (GetFocus() != ghWndList )
	{
//		DEBUGMSG("CustomLB doesn't have focus");
		return;
	}

	lResult = SendMessage(hListWin, LB_GETITEMDATA, lpdis->itemID, 0);
	if (LB_ERR == lResult)
	{
		DEBUGMSG("DrawMYLBFocus() fail to get item data");
		goto done;
	}
	pItem = (LBITEM*) lResult;
	if (!EqualRect(&lpdis->rcItem, &pItem->rcItem))
    {
        CalcItemLocation(lpdis->hDC, pItem, lpdis->rcItem);
    }
                   
	if (enCurFocus == MYLB_FOCUS_RTF)
	{
		CalcRTFFocusRect(pItem->rcRTF, rcNew);
	}
	if (enCurFocus == MYLB_FOCUS_TITLE)
	{
		CalcTitleFocusRect(pItem->rcTitle, rcNew);
	}
	DrawFocusRect(lpdis->hDC, &rcNew); //set new focus rect
done:
	return;
}
	
LRESULT CallDefLBWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	static WNDPROC s_defLBWndProc = NULL;

	if (NULL == s_defLBWndProc)
	{
		s_defLBWndProc = (WNDPROC) GetWindowLongPtr(hWnd, GWLP_USERDATA);
	}
	
	return CallWindowProc(s_defLBWndProc, hWnd, message, wParam, lParam);
}


LRESULT CALLBACK newLBWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_GETDLGCODE:
			return DLGC_WANTALLKEYS;
		case WM_KEYDOWN:
			switch(wParam)
			{
			case VK_RIGHT:
			case VK_LEFT:
				if (MYLB_FOCUS_RTF == gFocus)
				{
					DEBUGMSG("LB change focus to Title");
					gFocus = MYLB_FOCUS_TITLE;
					RedrawMYLB(ghWndList);
				}
				else if (MYLB_FOCUS_TITLE == gFocus && CurItemHasRTF(hWnd))
				{
					DEBUGMSG("LB change focus to RTF");
					gFocus = MYLB_FOCUS_RTF;
					RedrawMYLB(ghWndList);
				}
				break;
			case VK_F1:
				if (GetKeyState(VK_SHIFT)<0) 
				{//SHIFT down
					LaunchRTF(hWnd);
					return 0;
				}
				break;
			case VK_RETURN:
				if (MYLB_FOCUS_RTF == gFocus)
				{
					DEBUGMSG("MYLB show RTF ");
					LaunchRTF(hWnd);
				}
				break;
			case VK_TAB:
				PostMessage(GetParent(hWnd), WM_NEXTDLGCTL, 0, 0L);
				break;
			default:
				return CallDefLBWndProc(hWnd, message, wParam, lParam);
			}
			return 0;
		case WM_KEYUP:

			switch(wParam)
			{
			case VK_RIGHT:
			case VK_LEFT:
				break;
			case VK_RETURN:
				break;
			default:
				return CallDefLBWndProc(hWnd, message, wParam, lParam);
			}
			return 0;
		default:
			break;
	}
	return CallDefLBWndProc(hWnd, message, wParam, lParam);
}


// Message handler for Custom List box.
LRESULT CALLBACK CustomLBWndProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static int lenx;
    int clb;
    LBITEM *item;
    static BOOL s_fSelectionDisabled;
    
    switch (message)
    {
        case WM_CREATE:
            {
                RECT rcLst, rcDlg;
                LOGFONT lf;
				HFONT parentFont;
				TCHAR tszRTF[MAX_RTF_LENGTH] = _T("");

                GetClientRect(hDlg, &rcDlg);
                rcDlg.top += 2;
                rcDlg.bottom -= 3;
                rcDlg.left += 2;
                rcDlg.right -= 2;

                s_fSelectionDisabled = fDisableSelection();
                
                ghWndList = CreateWindow(_T("listbox"), NULL, 
                    WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_OWNERDRAWVARIABLE |
                    LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS | LBS_WANTKEYBOARDINPUT | 
					WS_VSCROLL | WS_HSCROLL | WS_TABSTOP,
                    rcDlg.left, rcDlg.top, rcDlg.right - rcDlg.left, rcDlg.bottom - rcDlg.top,
                    hDlg, NULL, ghInstance, NULL);

                if (NULL == ghWndList)
                {
                    return -1;
                }
				WNDPROC defLBWndProc = (WNDPROC) GetWindowLongPtr(ghWndList, GWLP_WNDPROC);
				SetWindowLongPtr(ghWndList, GWLP_USERDATA, (LONG_PTR) defLBWndProc);
				SetWindowLongPtr(ghWndList, GWLP_WNDPROC, (LONG_PTR) newLBWndProc);
                    
                HDC hDC = GetDC(ghWndList);

                GetWindowRect(hDlg, &rcDlg);        
                GetWindowRect(ghWndList, &rcLst);
                
                lenx = rcLst.right - rcLst.left;

                // Load read this first text from resource file
                LoadString(ghInstance, IDS_READTHISFIRST, tszRTF, MAX_RTF_LENGTH);
     
				// load keyboard shortcut description for Read this First
				LoadString(ghInstance, IDS_RTFSHORTCUT, gtszRTFShortcut, MAX_RTFSHORTCUTDESC_LENGTH);

                // Load the bitmaps
                ghBmpClear = (HBITMAP)LoadImage(ghInstance, MAKEINTRESOURCE(IDB_CLEAR), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);
                ghBmpCheck = (HBITMAP)LoadImage(ghInstance, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);
                ghBmpGrayOut = (HBITMAP)LoadImage(ghInstance, MAKEINTRESOURCE(IDB_GRAYOUT), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION); 


                // Create BOLD and Italic fonts
                ZeroMemory(&lf, sizeof(lf));

				//fixcode: check return value of GetCurrentObject()
                GetObject(GetCurrentObject(hDC, OBJ_FONT), sizeof(lf), &lf);

				//fixcode: check return value of GetParent()
				parentFont = (HFONT)SendMessage(GetParent(hDlg), WM_GETFONT, 0, 0);
				SendMessage(hDlg, WM_SETFONT, (WPARAM)parentFont, FALSE);
				SelectObject(hDC, parentFont);

				//fixcode: check return value of GetCurrentObject()
                GetObject(GetCurrentObject(hDC, OBJ_FONT), sizeof(lf), &lf);

                lf.lfUnderline = TRUE;
                lf.lfWeight = FW_NORMAL;
				//fixcode: check return value of CreateFontIndirect()
                ghFontUnderline = CreateFontIndirect(&lf); 

                lf.lfUnderline = FALSE;
                lf.lfWeight = FW_NORMAL;
				//fixcode: check return value of CreateFontIndirect()
                ghFontNormal = CreateFontIndirect(&lf); 

                lf.lfUnderline = FALSE; 
                lf.lfWeight = FW_HEAVY; 
				//fixcode: check return value of CreateFontIndirect()
                ghFontBold = CreateFontIndirect(&lf); 
                ReleaseDC(ghWndList, hDC);

#ifdef TESTUI
                {
                    AddItem(_T("Test 1 Very long title Test 1 Very long title Test 1 Very long title Test 1 Very long title "),
							_T("Description"), tszRTF, 0, TRUE, TRUE);
                    AddItem(_T("Test 2"), _T("Another description. No RTF"), tszRTF,0, TRUE, FALSE);
                }
#else
                {
                    for (UINT i = 0; i < gInternals->m_ItemList.Count(); i++)
                    {
						DEBUGMSG("selected[%d] = %lu", i, gInternals->m_ItemList[i].dwStatus());
						if ( !gInternals->m_ItemList[i].fHidden() )
						{
							AddItem(gInternals->m_ItemList[i].bstrTitle(),
									gInternals->m_ItemList[i].bstrDescription(),
									tszRTF,
									i,
									gInternals->m_ItemList[i].fSelected(),
									IsRTFDownloaded(gInternals->m_ItemList[i].bstrRTFPath(), GetSystemDefaultLangID()));
						}
                    }
                }
#endif
                SendMessage(ghWndList, LB_SETCURSEL, 0, 0); 
                gFocus = MYLB_FOCUS_TITLE;
                gFocusItemId = 0;

                SetMYLBAcc(ghWndList);

			
                return 0;
            }

		case WM_MOVE:
            {
                RECT rcList;
                
                GetWindowRect(ghWndList, &rcList);   // need this to force LB to realize it got moved
                return(TRUE);
            }
            
        case WM_SETCURSOR:
			{
				if (ghWndList == (HWND)wParam && LOWORD(lParam) == HTCLIENT && HIWORD(lParam) == WM_MOUSEMOVE)
				{
					POINT pt;
					RECT rc;
					GetCursorPos(&pt);
					if (0 == MapWindowPoints(NULL, ghWndList, &pt, 1))
					{
						DEBUGMSG("MYLBWndProc MapWindowPoints failed");
						return FALSE;
					}
                
					DWORD dwPos;
					dwPos = MAKELONG( pt.x, pt.y);
                
					DWORD dwItem = (LONG)SendMessage(ghWndList, LB_ITEMFROMPOINT, 0, dwPos);
                
					if (LOWORD(dwItem) == -1)
						return(FALSE);
                
					item = (LBITEM*)SendMessage(ghWndList, LB_GETITEMDATA, LOWORD(dwItem), 0);
					SendMessage(ghWndList, LB_GETITEMRECT, LOWORD(dwItem), (LPARAM)&rc);
                
					if (!EqualRect(&rc, &item->rcItem))
					{
						HDC hDC = GetDC(ghWndList);
						CalcItemLocation(hDC, item, rc);
						ReleaseDC(ghWndList, hDC);
					}
                                
					if (item->bRTF && PtInRect(&item->rcRTF, pt))
					{
					//	DEBUGMSG("Change Cursor to hand in MOUSEMOVE");
						SetCursor(ghCursorHand);
						return TRUE;
					}
                
					return FALSE;
				}
				else
				if (ghWndList == (HWND)wParam && LOWORD(lParam) == HTCLIENT && HIWORD(lParam) == WM_LBUTTONDOWN)
				{
					POINT pt;
					RECT rc;
					GetCursorPos(&pt);
					if (0 == MapWindowPoints(NULL, ghWndList, &pt, 1))
					{
						DEBUGMSG("MYLBWndProc MapWindowPoints failed");
						return FALSE;
					}

					DWORD dwPos;
					dwPos = MAKELONG( pt.x, pt.y);
					DWORD dwItem = (LONG)SendMessage(ghWndList, LB_ITEMFROMPOINT, 0, dwPos);
                
					if (LOWORD(dwItem) == -1)
						return(FALSE);
                
					item = (LBITEM*)SendMessage(ghWndList, LB_GETITEMDATA, LOWORD(dwItem), 0);
					SendMessage(ghWndList, LB_GETITEMRECT, LOWORD(dwItem), (LPARAM)&rc);

					if (!EqualRect(&rc, &item->rcItem))
					{
						HDC hDC = GetDC(ghWndList);
						CalcItemLocation(hDC, item, rc);
						ReleaseDC(ghWndList, hDC);
					}
                
					// Are we clicking on the Title?
					if (PtInRect(&item->rcBitmap, pt))
					{
						if (!s_fSelectionDisabled)
						    {
						        ToggleSelection(hDlg, ghWndList, item);
						    }
					//	DEBUGMSG("WM_SETCURSOR change gFocus to TITLE");
						gFocus = MYLB_FOCUS_TITLE;
						gFocusItemId = dwItem;
						RedrawMYLB(ghWndList);

						return TRUE;
					}
                
					// or are we clicking on the RTF?
					if (item->bRTF && PtInRect(&item->rcRTF, pt))
					{
						PostMessage(GetParent(hDlg), AUMSG_SHOW_RTF, LOWORD(item->m_index), 0);
						SetCursor(ghCursorHand);
						//DEBUGMSG("WM_SETCURSOR change gFocus to RTF");
						gFocus = MYLB_FOCUS_RTF;
						gFocusItemId = dwItem;
						RedrawMYLB(ghWndList);
						return TRUE;
					}
                
					return FALSE;
				}

				return FALSE;
			}
            
        case WM_MEASUREITEM: 
            {
                LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam ; 
                HDC hdc = GetDC(ghWndList);
                LBITEM * plbi = (LBITEM*)lpmis->itemData;
                
		lpmis->itemHeight = CalcTitleHeight(hdc, plbi, lenx -  XBITMAP - 2* TITLE_MARGIN) 
								+ CalcDescHeight(hdc, plbi, lenx - XBITMAP )
								+ CalcRTFHeight(hdc, plbi) + 4 * SECTION_SPACING;
				
                ReleaseDC(ghWndList, hdc);
                return TRUE; 

            }
        case WM_PAINT:
            PAINTSTRUCT ps;
			RECT borderRect;
            BeginPaint(hDlg, &ps);
			GetClientRect(hDlg, &borderRect);
			DrawEdge(ps.hdc, &borderRect, EDGE_ETCHED, BF_RECT);
            EndPaint(hDlg, &ps);
            break;
            
		case WM_NEXTDLGCTL:
			PostMessage(GetParent(hDlg), WM_NEXTDLGCTL, 0, 0L);
			return 0;
		case WM_KEYUP:
			//DEBUGMSG("MYLB got KEYUP key %d", wParam);
			switch(wParam)
            {
				case VK_TAB:
				case VK_DOWN:
				case VK_UP:
						SetFocus(ghWndList);
						return 0;
				default: 
					break;
			}
			break;
				
		case WM_VKEYTOITEM:
			{
				//DEBUGMSG("WM_VKEYTOITEM got char %d", LOWORD(wParam));
				if (LOWORD(wParam) != VK_SPACE)
				{
					return -1;
				}
				if (MYLB_FOCUS_TITLE == gFocus)
				{
					int i = (LONG)SendMessage(ghWndList, LB_GETCURSEL, 0, 0);
					if (LB_ERR == i)
					{
						return -2;
					}
					item = (LBITEM*)SendMessage(ghWndList, LB_GETITEMDATA, i, 0);

        				if (!s_fSelectionDisabled)
        				    {
	        				ToggleSelection(hDlg, ghWndList, item);
        				    }
					return -2;
				}
				if (MYLB_FOCUS_RTF == gFocus)
				{
					LaunchRTF(ghWndList);
				}
				return -2;
			}
			
	     case WM_DRAWITEM: 
	     		{
		            LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam; 

		            // If there are no list box items, skip this message. 
		 
		            if (lpdis->itemID == -1) 
		            { 
		                break; 
		            } 
		 
		            // Draw the bitmap and text for the list box item. Draw a 
		            // rectangle around the bitmap if it is selected. 
		 
		            switch (lpdis->itemAction) 
		            { 
		                case ODA_SELECT: 
		                case ODA_DRAWENTIRE: 
							//DEBUGMSG("MYLB WM_DRAWITEM ODA_DRAWENTIRE for %d", lpdis->itemID);
							DrawItem(lpdis, s_fSelectionDisabled);
							DrawMYLBFocus(ghWndList, lpdis, gFocus, gFocusItemId);
		                    break; 
		                case ODA_FOCUS: 
							if (lpdis->itemID != gFocusItemId)
							{
								gFocusItemId = lpdis->itemID;
								gFocus = MYLB_FOCUS_TITLE;
							}
							//DEBUGMSG("MYLB ODA_FOCUS change focus to %d", gFocusItemId);
							DrawItem(lpdis, s_fSelectionDisabled);
							DrawMYLBFocus(ghWndList, lpdis, gFocus, gFocusItemId);
		                    break; 
		            } 
		            return TRUE; 
	     		}

        case WM_DESTROY:
            // need to cleanup the fonts
            if (ghFontBold)         
                DeleteObject(ghFontBold);
            if (ghFontUnderline)
                DeleteObject(ghFontUnderline);
            if (ghFontNormal)
                DeleteObject(ghFontNormal);
		if (ghBmpCheck)
                DeleteObject(ghBmpCheck);
		if (ghBmpGrayOut)
		   DeleteObject(ghBmpGrayOut);
            if (ghBmpClear)
                DeleteObject(ghBmpClear);

                
            ghFontNormal = NULL;
            ghFontBold = NULL;
            ghFontUnderline = NULL;
		ghBmpCheck = NULL;
		ghBmpGrayOut = NULL;
		ghBmpClear = NULL;

		EnterCriticalSection(&gcsClient);
		RemoveProp( ghWndList, MYLBALIVEPROP );
            clb = (LONG)SendMessage(ghWndList, LB_GETCOUNT, 0, 0);
            for(int i = 0; i < clb; i++)
            {
                item = (LBITEM*)SendMessage(ghWndList, LB_GETITEMDATA, i, 0);
                delete(item);
            }
		LeaveCriticalSection(&gcsClient);
			
            return 0;
    }
    return DefWindowProc(hDlg, message, wParam, lParam);
}

void DrawTitle(HDC hDC, LBITEM * plbi, RECT rc)
{
    // we want the bitmap to be on the same background as the title, let's do this here since we 
    // already have all the measures.
    RECT rcTop = rc;
    rcTop.left = 0;

    // draw menu background rectangle for the title and bitmap
    HBRUSH hBrush;
    if (! (hBrush = CreateSolidBrush(GetSysColor(COLOR_MENU))))
	{
		DEBUGMSG("WUAUCLT CreateSolidBrush failure in DrawTitle, GetLastError=%lu", GetLastError());
		return;
	}
    FillRect(hDC, (LPRECT)&rcTop, hBrush);
    if (NULL != hBrush)
	{
		DeleteObject(hBrush);
	}

    // draw 3d look
    DrawEdge(hDC, &rcTop, EDGE_ETCHED, BF_RECT);

    // change text and back ground color of list box's selection
    DWORD dwOldTextColor = SetTextColor(hDC, GetSysColor(COLOR_MENUTEXT)); // black text color
    DWORD dwOldBkColor = SetBkColor(hDC, GetSysColor(COLOR_MENU)); // text cell light gray background
    HFONT hFontPrev = (HFONT)SelectObject(hDC, ghFontBold);

	rc.left += TITLE_MARGIN;
    rc.top += SECTION_SPACING;
    rc.right -= TITLE_MARGIN;
    rc.bottom -= SECTION_SPACING;
	DrawText(hDC, (LPTSTR)plbi->szTitle, -1,
            &rc, DT_WORDBREAK);
    
    // restore text and back ground color of list box's selection
    SetTextColor(hDC, dwOldTextColor);
    SetBkColor(hDC, dwOldBkColor);
    SelectObject(hDC, hFontPrev);

    return;
}

void DrawRTF(HDC hDC, LBITEM * plbi, const RECT & rc /*,BOOL fHit*/)
{
  if (!plbi->bRTF)
		return;

	//draw RTF background 
   RECT rcBackGround;
   CalcRTFFocusRect(rc, rcBackGround);
   HBRUSH hBrush;
    if (!(hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW))))
	{
		DEBUGMSG("WUAUCLT CreateSolidBrush failure in DrawRTF, GetLastError=%lu", GetLastError());
		return;
	}
    if (!FillRect(hDC, (LPRECT)&rcBackGround, hBrush))
	{
		DEBUGMSG("Fail to erase RTF background");
	}
    if (NULL != hBrush)
	{
		DeleteObject(hBrush);
	}

	
    HFONT hFontPrev = (HFONT) SelectObject(hDC, ghFontUnderline);

    DWORD dwOldTextColor = SetTextColor(hDC, GetSysColor(ATTENTION_COLOR));

	SetBkMode(hDC, TRANSPARENT);
	// add the read this first 
    TextOut(hDC, (int)(rc.left), (int)(rc.top),
          (LPTSTR)plbi->szRTF, lstrlen(plbi->szRTF));
    
    // restore text and back ground color of list box's selection
    SetTextColor(hDC, dwOldTextColor);
	SelectObject(hDC, hFontPrev);

    return;
}

void DrawDescription(HDC hDC, LBITEM * plbi, RECT & rc)
{
	HFONT hFontPrev = (HFONT)SelectObject(hDC, ghFontNormal);
    DrawText(hDC, (LPTSTR)plbi->pszDescription, -1,
            &rc, DT_BOTTOM | DT_EXPANDTABS | DT_WORDBREAK | DT_EDITCONTROL);
            
    SelectObject(hDC, hFontPrev);

    return;
}

void DrawBitmap(HDC hDC, LBITEM * plbi, const RECT & rc, BOOL fSel, BOOL fSelectionDisabled)
{
    HDC hdcMem;

    plbi->bSelect = fSel;

    if (hdcMem = CreateCompatibleDC(hDC))
	{
	    HGDIOBJ hBmp;
	    if (fSelectionDisabled)
	        {
	            hBmp = ghBmpGrayOut;
//	            DEBUGMSG("Set bitmap to grayout");
	        }
	    else
	        {
//	            DEBUGMSG("Set bitmap to selectable");
	            hBmp = (plbi->bSelect ? ghBmpCheck : ghBmpClear);
	        }
		HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, hBmp); 

		BitBlt(hDC, 
			rc.left + 3, rc.top + SECTION_SPACING, 
			rc.right - rc.left, 
			rc.bottom - rc.top, 
			hdcMem, 0, 0, SRCCOPY);

		SelectObject(hdcMem, hbmpOld); 
		DeleteDC(hdcMem);
	}
}

BOOL GetBmpSize(HANDLE hBmp, SIZE *psz)
{
	if (NULL == hBmp || NULL == psz)
	{
		DEBUGMSG("Error: GetBmpSize() invalid parameter");
		return FALSE;
	}
	BITMAP bm;
	ZeroMemory(&bm, sizeof(bm));
	if (0 == GetObject(hBmp, sizeof(bm), &bm))
	{
		return FALSE;
	}
	psz->cx = bm.bmWidth;
	psz->cy = bm.bmHeight;
	return TRUE;
}

//fixcode: should return error code
void AddItem(LPTSTR tszTitle, LPTSTR tszDesc, LPTSTR tszRTF, int index, BOOL fSelected, BOOL fRTF)
{
    LBITEM *newItem = new(LBITEM);
	if (! newItem)
	{
		DEBUGMSG("WUAUCLT new() failed in AddItem, GetLastError=%lu", GetLastError());
		goto Failed;
	}
	DWORD dwDescLen = max(lstrlen(tszDesc), MAX_DESC_LENGTH);
	newItem->pszDescription = (LPTSTR) malloc((dwDescLen+1) * sizeof(TCHAR));
	if (NULL == newItem->pszDescription)
	{
		DEBUGMSG("AddItem() fail to alloc memory for description");
		goto Failed;
	}
    (void)StringCchCopyEx(newItem->szTitle, ARRAYSIZE(newItem->szTitle), tszTitle, NULL, NULL, MISTSAFE_STRING_FLAGS);
	(void)StringCchCopyEx(newItem->pszDescription, dwDescLen+1, tszDesc, NULL, NULL, MISTSAFE_STRING_FLAGS);
	(void)StringCchCopyEx(newItem->szRTF, ARRAYSIZE(newItem->szRTF), tszRTF, NULL, NULL, MISTSAFE_STRING_FLAGS);
    newItem->m_index = index;
	newItem->bSelect = fSelected;
    newItem->bRTF = fRTF;

    LRESULT i = SendMessage(ghWndList, LB_GETCOUNT, 0, 0);
	if (LB_ERR == i ||
		LB_ERR == (i = SendMessage(ghWndList, LB_INSERTSTRING, (WPARAM) i, (LPARAM) newItem->szTitle)) ||
		LB_ERRSPACE == i ||
		LB_ERR == SendMessage(ghWndList, LB_SETITEMDATA, (WPARAM) i, (LPARAM) newItem))
	{
		DEBUGMSG("WUAUCLT AddItem() fail to add item to listbox");
		goto Failed;
	}

	return;

Failed:
	SafeDelete(newItem);
	QuitNRemind(TIMEOUT_INX_TOMORROW);
}

////////////////////////////////////////////////////
// utility function
// calculate the height of a paragraph in current 
// device context
////////////////////////////////////////////////////
UINT GetParagraphHeight(HDC hDC, LPTSTR tszPara, UINT uLineWidth)
{
	UINT y = 0;
	TCHAR* pEOL;
	SIZE sz; 

	if (0 == uLineWidth)
	{
		return 0;
	}

	TCHAR* pLast = tszPara;
    while(pEOL = _tcschr(pLast, _T('\n')))
    {
        *pEOL = _T('\0');
		//fixcode: check return value of GetTextExtentPoint32()
        GetTextExtentPoint32(hDC, pLast, lstrlen(pLast), &sz);
		*pEOL = _T('\n');
        pLast = _tcsinc(pEOL);
        y += sz.cy * ((sz.cx  / (uLineWidth)) + 1);
    }

	//fixcode: check return value of GetTextExtentPoint32()
    GetTextExtentPoint32(hDC, pLast, lstrlen(pLast), &sz);
	y += sz.cy * ((sz.cx  / (uLineWidth)) + 1);
	return y;
}

int CalcDescHeight(HDC hDC, LBITEM * plbi, int cx)
{
    TCHAR* pEOL = NULL;
    TCHAR* pLast = NULL;
    int y = 0;
	HFONT hPrevFont = NULL;
    
	if (NULL == plbi) 
	{
		DEBUGMSG("CalcDescHeight() invalid parameter");
		return 0;
	}

	hPrevFont = (HFONT) SelectObject(hDC, ghFontNormal);
	y = GetParagraphHeight(hDC, plbi->pszDescription, cx);
	SelectObject(hDC, hPrevFont);

    return y;
}    


int CalcRTFHeight(HDC hDC, LBITEM * plbi)
{
    SIZE sz ;

	if (NULL == plbi) 
	{
		DEBUGMSG("CalcRTFHeight() invalid parameter");
		return 0;
	}
	ZeroMemory(&sz, sizeof(sz));
	HFONT hPrevFont = (HFONT) SelectObject(hDC, ghFontUnderline);
	//fixcode: check return value of GetTextExtentPoint32()
	GetTextExtentPoint32(hDC, plbi->szRTF, lstrlen(plbi->szRTF), &sz);
	SelectObject(hDC, hPrevFont);

	return sz.cy;
}

int CalcRTFWidth(HDC hDC, LBITEM * plbi)
{
	if (NULL == plbi) 
	{
		DEBUGMSG("CalcRTFWidth() invalid parameter");
		return 0;
	}
	SIZE sz;
	HFONT hPrevFont = (HFONT) SelectObject(hDC, ghFontUnderline);
	//fixcode: check return value of GetTextExtentPoint32()
	GetTextExtentPoint32(hDC, plbi->szRTF, lstrlen(plbi->szRTF), &sz);
	SelectObject(hDC, hPrevFont);

	return sz.cx;
}

int CalcTitleHeight(HDC hDC, LBITEM *plbi, int cx)
{    
	INT y = 0;
	INT iBmpHeight = 0;

	if (NULL == plbi) 
	{
		DEBUGMSG("CalcTitleHeight() invalid parameter");
		goto done;
	}
	
	HFONT hPrevFont = (HFONT) SelectObject(hDC, ghFontBold);
	y = GetParagraphHeight(hDC, plbi->szTitle, cx);
	SelectObject(hDC, hPrevFont);

	// get checkbox size
	if (NULL != ghBmpCheck && NULL != ghBmpClear && NULL != ghBmpGrayOut)
	{
		SIZE sz1 ;
		SIZE sz2 ;
		SIZE sz3 ;
		sz1.cy = sz2.cy = sz3.cy = DEF_CHECK_HEIGHT;
		GetBmpSize(ghBmpCheck, &sz1);
		GetBmpSize(ghBmpClear, &sz2);
		GetBmpSize(ghBmpGrayOut, &sz3);
		iBmpHeight = max(sz1.cy, sz2.cy);
		iBmpHeight = max(iBmpHeight, sz3.cy);
	}
done:
	return max(y, iBmpHeight); //make title height a little bigger for clearer focus rect
}


////////////////////////////////////////////////////////////
/// Layout of listbox item:
///		spacing
///		bitmap margin TITLE margin
///		spacing
///			   DESCRIPTION 
///		spacing
///						RTF rtf_margin
///		spacing
///////////////////////////////////////////////////////////
void CalcItemLocation(HDC hDC, LBITEM * plbi, const RECT & rc)
{
    // Calculate the positon of each element
    plbi->rcItem = rc;
    
    plbi->rcTitle = rc;
	plbi->rcTitle.left += XBITMAP ;
    plbi->rcTitle.bottom = plbi->rcTitle.top + CalcTitleHeight(hDC, plbi, plbi->rcTitle.right -  plbi->rcTitle.left - 2* TITLE_MARGIN) 
							+ 2 * SECTION_SPACING; 

    plbi->rcText = rc;
    plbi->rcText.left = plbi->rcTitle.left;
	plbi->rcText.right = plbi->rcTitle.right;
    plbi->rcText.top = plbi->rcTitle.bottom;
    plbi->rcText.bottom -= CalcRTFHeight(hDC, plbi) + SECTION_SPACING;  //

	
	plbi->rcRTF = plbi->rcText;
    plbi->rcRTF.top = plbi->rcText.bottom;
    plbi->rcRTF.bottom = plbi->rcRTF.top + CalcRTFHeight(hDC, plbi);
	plbi->rcRTF.right = plbi->rcText.right - RTF_MARGIN;
	plbi->rcRTF.left = plbi->rcRTF.right - CalcRTFWidth(hDC, plbi);

    plbi->rcBitmap = rc;
    plbi->rcBitmap.bottom = plbi->rcTitle.bottom;
       
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\dialogs.cpp ===
#include "pch.h"
#include "htmlhelp.h"
#include "link.h"
#pragma hdrstop
	
HINSTANCE mshtml = NULL;
HACCEL ghCurrentAccel = NULL;
HHOOK ghHook = NULL;
AUOPTION gWelcomeOption;

extern UINT		gNextDialogMsg;

#ifdef TESTUI
DWORD gdwScheduledInstallDay = -1;
DWORD gdwScheduledInstallTime = -1;
#endif

CSysLink g_AutoUpdatelink;
CSysLink g_ScheduledInstalllink;
CSysLink g_PrivacyStatementLink;
CSysLink g_EULA_Link(FALSE); //non html help

SHOWHTMLDIALOGFN  *pfnShowHTMLDialog;

const UINT CTRLIDSTRIDMAP[][2] = {
	{IDC_WELCOME_NOTE, IDS_NOTE},
	{IDC_WELCOME_CONTINUE, IDS_WELCOME_CONTINUE},
	{IDC_SUMMARY_NOTE, IDS_NOTE},
	{IDC_WELCOME_EULA, IDS_EULA},
	{IDC_LEARNMORE,IDS_LEARNMORE},
	{IDC_STAT_LEARNAUTOUPDATE,IDS_LEARNMOREAUTO}
};

// A Wrapper function to first check the item handle returned from GetDlgItem for the item iIDDlgItem and then to enable or disable it depending on the flag passed
inline void GetItemAndEnableIt(HWND hWnd, int iIDDlgItem, BOOL bEnable)
{
	HWND hItem = GetDlgItem(hWnd, iIDDlgItem);
	if (NULL != hItem)
	{
		EnableWindow(hItem, bEnable);
	}	
}

void SetButtonText(HWND button, UINT resId)
{
    TCHAR text[50];
    LoadString(ghInstance, resId, text, 50);
    SendMessage(button, WM_SETTEXT, 0, (LPARAM)text);
}

void ShowRTF(HWND hWnd, WPARAM wParam)
{
    UINT uIndex = (UINT)wParam;
	IMoniker *pIMon = NULL;
       WCHAR wszArg[200];
	RECT rc;

   	if (NULL == pfnShowHTMLDialog || uIndex >= gInternals->m_ItemList.Count()) 
   		{
   		return;
   		}
	HRESULT hr;
	if (FAILED(hr = CreateURLMoniker(NULL, L"res://wuauclt.exe/RTFWRAPPER.HTM", &pIMon)))
	{
		DEBUGMSG("WUAUCLT: ShowRTF failed to CreateURLMoniker() with error %#lx", hr);
		goto done;
	}

	//fixcode: check return value of GetWindowRect()
	GetWindowRect(hWnd, &rc);
	if (FAILED(StringCchPrintfExW(wszArg, ARRAYSIZE(wszArg), NULL, NULL, MISTSAFE_STRING_FLAGS,
					L"dialogHeight:%dpx;dialogWidth:%dpx;dialogTop:%d;dialogLeft:%d;help:no;resizable:yes",
					rc.bottom-rc.top, rc.right-rc.left, rc.top + 25, rc.left + 25)))
	{
		DEBUGMSG("WUAUCLT: ShowRTF insufficient buffer for HTML dialog argument");
		goto done;
	}

	TCHAR tszRTFLocalFile[MAX_PATH];
	if (FAILED(GetRTFLocalFileName(gInternals->m_ItemList[uIndex].bstrRTFPath(), tszRTFLocalFile, ARRAYSIZE(tszRTFLocalFile), GetSystemDefaultLangID())))
	{
		goto done;
	}
	DEBUGMSG("Launching RTF page from %S", T2W(tszRTFLocalFile));
	VARIANT varg;
	varg.vt = VT_BSTR;
	if (NULL == (varg.bstrVal = SysAllocString(T2W(tszRTFLocalFile))))
	{
		DEBUGMSG("WUAUCLT: ShowRTF failed to allocate memory for HTML dialog argument");
		goto done;
	}
       pfnShowHTMLDialog(hWnd, pIMon, &varg, wszArg, NULL);
       VariantClear(&varg);
done:
	SafeRelease(pIMon);
	return;
}


UINT ControlId2StringId(UINT uCtrlId)
{
	for (int i = 0 ; i< ARRAYSIZE(CTRLIDSTRIDMAP); i++)
	{
		if (CTRLIDSTRIDMAP[i][0] == uCtrlId)
		{
			return CTRLIDSTRIDMAP[i][1];
		}
	}
	return -1;
}

//////////////////////////////////////////////////////////////////
// Adjust (Stretch or squeeze) the bitmap IDB_SIDEBAR to
//  make it fit into the control IDC_SIDEBAR
// to fit in the dialog
// hDlg		: handle to the dialog
///////////////////////////////////////////////////////////////////
void AdjustSideBar(HWND hDlg)
{
	HBITMAP hBmp;
	BITMAP  bmp;
	HDC		hDC;
	HDC		hMemDC;
	RECT	rc ;
	RECT	rcWhiteRect, rcBottomLine;

	GetWindowRect(GetDlgItem(hDlg, IDC_BOTTOMLINE), &rcBottomLine);
	GetWindowRect(GetDlgItem(hDlg, IDC_WHITERECT), &rcWhiteRect);
	MapWindowPoints(NULL, hDlg, (LPPOINT)&rcBottomLine, 2);
	MapWindowPoints(NULL, hDlg, (LPPOINT)&rcWhiteRect, 2);
	rc.right = rcWhiteRect.left;
	rc.bottom = rcBottomLine.top -1;
	hDC = GetDC(hDlg);
	hMemDC = CreateCompatibleDC(hDC);
	hBmp = (HBITMAP) LoadImage(ghInstance, MAKEINTRESOURCE(IDB_SIDEBAR), IMAGE_BITMAP,
		0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
	GetObject(hBmp, sizeof(bmp), &bmp);	
	SelectObject(hMemDC, hBmp);
	SetStretchBltMode( hDC, COLORONCOLOR );
	StretchBlt(hDC, 0, 0, rc.right, rc.bottom, hMemDC, 0, 0, bmp.bmWidth, bmp.bmHeight, MERGECOPY);
	DeleteObject(hBmp);
	DeleteDC(hMemDC);
	ReleaseDC(hDlg, hDC);
}


void SetAUDialogIcon(HWND hDlg, HANDLE hIcon, HANDLE hSmIcon)
{
	SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
	SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hSmIcon);
}

int DisplayWizardCancelWarning(HWND hWnd)
{
	TCHAR title[80], text[300];
	
	LoadString(ghInstance, IDS_CLOSEWARNINGTITLE, title, ARRAYSIZE(title));
	LoadString(ghInstance, IDS_CLOSEWARNINGTEXT, text, ARRAYSIZE(text));

	return MessageBox(hWnd, text, title, MB_YESNO | MB_ICONQUESTION);
}

void LaunchHelp(
	HWND hwnd,
	LPCTSTR szURL
)
{
	HtmlHelp(NULL,szURL,HH_DISPLAY_TOPIC,NULL);
}

LONG SetColors(HDC hdc, HWND control)
{
	int id = GetDlgCtrlID(control);

	switch (id)
	{
		case IDC_WHITERECT:
			{
				SetBkMode(hdc, OPAQUE);
				SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
				return PtrToLong(GetSysColorBrush(COLOR_WINDOW));
			}
			
		case IDC_CHK_KEEPUPTODATE:
			{
				//DEBUGMSG("IDC_LEARNMORE Setcolors");
/*				
				SetBkMode(hdc, TRANSPARENT);
				return PtrToLong(GetSysColorBrush(COLOR_BTNFACE));
*/	
				return FALSE;
			}

		case IDC_OPTION1:
		case IDC_OPTION2:
		case IDC_OPTION3:
			{ 
				return FALSE;
			}

		case IDC_GRPBOX:
			return FALSE;

		default:
			{ 
				SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
				SetBkMode(hdc, TRANSPARENT);
				return PtrToLong(GetStockObject(HOLLOW_BRUSH));
			}
	}
}


LRESULT CALLBACK AUTranslatorProc(int code, WPARAM wParam, LPARAM lParam)
{
	if(code != MSGF_DIALOGBOX
	   || ghCurrentAccel == NULL 
	   || !TranslateAccelerator(ghCurrentDialog, ghCurrentAccel, (MSG*)lParam))
	{
		return CallNextHookEx(ghHook, code, wParam, lParam);
	}
	else
	{
		return 1;
	}
}


BOOL CALLBACK WizardFrameProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
    switch(message)
    {
        case WM_INITDIALOG:
            ghCurrentMainDlg = hWnd;
            CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_WELCOME), 
                hWnd, (DLGPROC)WelcomeDlgProc);
            SetActiveWindow(ghCurrentMainDlg);
            SetForegroundWindow(ghCurrentMainDlg);
            SetAUDialogIcon(hWnd, ghAppIcon, ghAppSmIcon); //set icon for all AU dialogs
			gWelcomeOption.dwOption = -1;
            gWelcomeOption.dwSchedInstallDay = -1;
            gWelcomeOption.dwSchedInstallTime = -1;
            return TRUE;

		case WM_COMMAND:
			if(ghCurrentDialog != NULL)
			{
				PostMessage(ghCurrentDialog, WM_COMMAND, wParam, lParam);
			}
			return 0;

        case WM_DESTROY:
            ghCurrentMainDlg = NULL;
			return 0;

        case WM_HELP:
        	LaunchHelp(hWnd, gtszAUOverviewUrl);
        	return TRUE;
	    default:
            return FALSE;
    }
}


void LaunchEula()
{
	TCHAR szCmd[MAX_PATH+1];																
	STARTUPINFO StartupInfo;								
	PROCESS_INFORMATION ProcessInfo;
	TCHAR szEULA_TXT[] = _T(" eula.txt"); // command line string
	UINT ulen =GetSystemDirectory(szCmd, ARRAYSIZE(szCmd)); 
    if ( 0 == ulen ||
    	ulen >= ARRAYSIZE(szCmd) ||
		FAILED(StringCchCatEx(szCmd, ARRAYSIZE(szCmd), _T("\\notepad.exe"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
		return;
    }

	ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
	ZeroMemory(&StartupInfo, sizeof(StartupInfo));
	
	StartupInfo.cb = sizeof(StartupInfo);
	StartupInfo.wShowWindow = SW_SHOW;
	
	CreateProcess(
			szCmd,					// name of executable module
			szEULA_TXT,			    // command line string
			NULL,					// SD
			NULL,					// SD
			FALSE,					// handle inheritance option
			DETACHED_PROCESS,		// creation flags
			NULL,					// new environment block
			NULL,					// current directory name
			&StartupInfo,			// startup information
			&ProcessInfo			// process information
			);	
	SafeCloseHandleNULL(ProcessInfo.hThread);
	SafeCloseHandleNULL(ProcessInfo.hProcess);
}


void LaunchLinkAction(HWND hwnd, UINT uCtrlId)
{

//#ifdef _CWU
#if 0
	OSVERSIONINFO OsVer;
	OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx( &OsVer );
#endif	
//#endif

	switch (uCtrlId)
	{
		case IDC_WELCOME_EULA:
			LaunchEula();
			break;
//		case IDC_WELCOME_PRIVACY:
/*#ifndef _CWU
			ShellExecute(NULL, NULL, gtszPrivacyUrl, NULL, NULL, SW_SHOWNORMAL);
#else
*/
//			{
//				LaunchHelp(hwnd, (LPTSTR)gtszW2KPrivacyUrl);

/*				if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 0))
				{
					// NT5
					LaunchHelp(hwnd, (LPTSTR)gtszW2KPrivacyUrl);
				}
				else if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 1))
				{
					// Whistler
					ShellExecute(NULL, NULL, gtszPrivacyUrl, NULL, NULL, SW_SHOWNORMAL);
				}
*/
//			}
//#endif
			break;
		case IDC_LEARNMORE:
/*#ifndef _CWU
			ShellExecute(NULL, NULL, gtszLearnMoreUrl, NULL, NULL, SW_SHOWNORMAL);
#else
*/
			{
				LaunchHelp(hwnd, gtszAUSchedInstallUrl);

/*				if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 0))
				{
					// NT5
					LaunchHelp(hwnd, (LPTSTR)gtszAUW2kSchedInstallUrl);
				}
				else if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 1))
				{
					// Whistler
        				LaunchHelp(hwnd, (LPTSTR)gtszAUXPSchedInstallUrl);
				}
*/				
			}
			break;
//#endif

//#ifdef _CWU
		case IDC_STAT_LEARNAUTOUPDATE:
			{
				LaunchHelp(hwnd, gtszAUOverviewUrl);
/*
				if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 0))
				{
					// NT5
					LaunchHelp(hwnd, (LPTSTR)gtszAUOverviewUrl);
				}
				else if( (OsVer.dwMajorVersion == 5) && (OsVer.dwMinorVersion == 1))
				{
					// Whistler
					ShellExecute(NULL, NULL, gtszLearnMoreUrl, NULL, NULL, SW_SHOWNORMAL);
				}
*/
			}
			break;
//#endif
	}
	return;
}


void SetDefaultCF(HWND hWndMYRE, CHARFORMAT2 *pcfDefault)
{
	pcfDefault->cbSize  = sizeof(*pcfDefault);
	SendMessage(hWndMYRE, EM_GETCHARFORMAT, 0, (LPARAM)pcfDefault);
	pcfDefault->dwMask |= CFM_BOLD | CFM_HIDDEN | CFM_ITALIC | CFM_LINK 
							| CFM_UNDERLINE | CFM_SIZE | CFM_WEIGHT | CFM_COLOR;
	pcfDefault->dwEffects &= ~(CFE_BOLD | CFE_ITALIC |CFE_LINK | CFE_UNDERLINE | CFE_HIDDEN);

	SendMessage(hWndMYRE, EM_SETCHARFORMAT, 0, (LPARAM)pcfDefault);
}

/*
void DbgDumpEffects(CHARFORMAT2 cf)
{
	UINT   effects[] = {
			CFE_BOLD,
			CFE_ITALIC,
			CFE_LINK, 
			CFE_UNDERLINE
	};
	LPTSTR msgs[]= {
		_T("BOLD"),
		_T("ITALIC"),
		_T("LINK"),
		_T("UNDERLINE")
	};
	const UINT NUM_EFFECTS = 4;
	for (int i = 0; i < NUM_EFFECTS; i++)
	{
		if (cf.dwEffects & effects[i] )
		{
			DEBUGMSG("cf is %S", msgs[i]);
		}
		else
		{
			DEBUGMSG("cf is NOT %S", msgs[i]);
		}
	}
}
*/

/////////////////////////////////////////////////////////////
// Format specified text in a rich edit control
// e.g. make it bold, italic, link etc
// hWndMYRE		: Rich edit window handle
// uStrId		: string id for the text to format
// puEffects	: points to the flag specifying designed effects. e.g.
//				: CFE_BOLD
//				: CFE_ITALIC
//				: CFE_UNDERLINE
//				: if NULL, effects not changed
void FormatMYREText(HWND hWndMYRE, UINT uStrId, UINT* puEffects)
{
	FINDTEXTEXW ft;
	CHARRANGE cr;
	CHARFORMAT2 cf;
	INT nFTflags ;
	ZeroMemory(&ft, sizeof(ft));
	ZeroMemory(&cr, sizeof(cr));
	ZeroMemory(&cf, sizeof(cf));
	
//	DEBUGMSG("FormatMYREText() effects = 0x%x color = 0x%x", puEffects, ptxtColor);

	cf.cbSize = sizeof(cf);
	ft.chrg.cpMin = 0;
	ft.chrg.cpMax = -1;
	ft.lpstrText = ResStrFromId(uStrId);

	nFTflags = FR_MATCHCASE|FR_WHOLEWORD|FR_DOWN;
	cr.cpMin = (LONG)SendMessage(hWndMYRE, EM_FINDTEXTEXW, nFTflags, (LPARAM) &ft);
	if (-1 == cr.cpMin )
	{
		DEBUGMSG("Format Text %S not found %lu", ft.lpstrText, GetLastError()); 
		return;
	}
	cr = ft.chrgText;
	SendMessage(hWndMYRE, EM_EXSETSEL, 0, (LPARAM)&cr);
	SendMessage(hWndMYRE, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
	if (0 != puEffects)
	{
		cf.dwEffects |= *puEffects;
	}
	SendMessage(hWndMYRE, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
}

/////////////////////////////////////////////////////////////////
// Subclass rich edit control and format its text
// hDlg : the dialog the rich edit control is in
// uId  : id of the rich edit control
// hFont: font to set richedit control 
/////////////////////////////////////////////////////////////////
void MYREInit(HWND hDlg, UINT uId, HFONT hFont)
{
	CHARFORMAT2 cfDefault;
	HWND	hWndMYRE = GetDlgItem(hDlg, uId);
	UINT uStrId  = 0;
       UINT uEffects = 0;

      	SetDefaultCF(hWndMYRE, &cfDefault);
      //DEBUGMSG("MYREInit() retrieving and removing text");
       UINT uTextLen =  (LONG)SendMessage(hWndMYRE, WM_GETTEXTLENGTH, 0, 0);
       TCHAR *pText = (TCHAR*)malloc((uTextLen + 1)* sizeof(TCHAR));
       if (NULL != pText)
       {
               /* need to blank out text and reset text for new font to go into effect*/
               SendMessage(hWndMYRE, WM_GETTEXT, (WPARAM)(uTextLen+1), (LPARAM)pText);
               //DEBUGMSG("MYREInit() get text %S", pText);
               SendMessage(hWndMYRE, WM_SETTEXT, 0, (LPARAM)L"");
               //DEBUGMSG("MYREInit() removed text");
               LRESULT lres = SendMessage(hWndMYRE, EM_GETLANGOPTIONS, 0, 0);
               lres &= ~IMF_AUTOFONT;        // turn off autofont
               SendMessage(hWndMYRE, EM_SETLANGOPTIONS, 0, (LPARAM)lres);
               //DEBUGMSG("MYREInit() turn off auto font");
               SendMessage(hWndMYRE, WM_SETFONT, (WPARAM)hFont, TRUE);
               //DEBUGMSG("MYREInit() setting font to %#lx", hFont);
               SendMessage(hWndMYRE, WM_SETTEXT, 0, (LPARAM)pText);
               //DEBUGMSG("MYREInit() reset text");
               free(pText);
        }
	switch (uId)
	{
		case IDC_WELCOME_NOTE:
		case IDC_SUMMARY_NOTE:
		case IDC_WELCOME_CONTINUE:
			{
				uStrId = ControlId2StringId(uId);
				uEffects = CFE_BOLD;
				break;
			}
//#ifdef _CWU
		case IDC_WELCOME_EULA:
	    case IDC_WELCOME_PRIVACY:
		case IDC_LEARNMORE:
		case IDC_STAT_LEARNAUTOUPDATE:
			uStrId = ControlId2StringId(uId);
			uEffects = CFE_LINK;

			SendMessage(hWndMYRE, EM_SETEVENTMASK, 0, ENM_LINK);
			break;

	
//#endif
				
	}
	if (0 != uStrId)
	{
		FormatMYREText(hWndMYRE, uStrId, &uEffects);
	}

	return;
}					

void CancelWizard(HWND hWnd)
{
	static BOOL s_fCancelWarningShown = FALSE;

	if (!s_fCancelWarningShown)
	{
		s_fCancelWarningShown = TRUE;
		if (IDYES == DisplayWizardCancelWarning(hWnd))				
		{
#if 0
#ifndef TESTUI
			SetTomorrowReminder(AUSTATE_NOT_CONFIGURED);
#endif
#endif
			CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_SETUPCANCEL), 
				GetParent(hWnd), (DLGPROC)SetupCancelDlgProc);     
			DestroyWindow(hWnd);
		}
		s_fCancelWarningShown = FALSE;
	}
}

BOOL CALLBACK WelcomeDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
	static BOOL s_fHasFocusLastTime ; 

    switch(message)
    {   
        case WM_INITDIALOG:
            {
				HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);

                ghCurrentDialog = hWnd;				
   				s_fHasFocusLastTime = FALSE; 
			
                SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);

				GetItemAndEnableIt(hWnd, IDC_BACK, FALSE);

				SetFocus(GetDlgItem(hWnd, IDC_NEXT));	

                HFONT hFont = (HFONT) SendMessage(hWnd , WM_GETFONT, 0, 0);
				MYREInit(hWnd, IDC_WELCOME_NOTE, hFont);
				MYREInit(hWnd, IDC_WELCOME_CONTINUE, hFont);
//#ifdef _CWU
//				MYREInit(hWnd, IDC_WELCOME_EULA, hFont);
//				MYREInit(hWnd, IDC_WELCOME_PRIVACY, hFont);
//#endif
				g_PrivacyStatementLink.SetSysLinkInstanceHandle(ghInstance);
				g_PrivacyStatementLink.SubClassWindow(GetDlgItem(hWnd,IDC_WELCOME_PRIVACY));
				g_PrivacyStatementLink.SetHyperLink(gtszAUPrivacyUrl);
				g_PrivacyStatementLink.Invalidate();

				g_EULA_Link.SetSysLinkInstanceHandle(ghInstance);
				g_EULA_Link.SubClassWindow(GetDlgItem(hWnd,IDC_WELCOME_EULA));
				g_EULA_Link.SetHyperLink(_T("eula.txt"));
				g_EULA_Link.Invalidate();

				return TRUE;
            }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
				case IDOK:
                case IDC_NEXT:
                    CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_NOTOPTIONS), 
                        GetParent(hWnd), (DLGPROC)NotificationOptionsDlgProc);
                    DestroyWindow(hWnd);
                    return 0;

				case IDCANCEL:														
				case IDC_CANCEL:					
						CancelWizard(hWnd);
						return 0;

				default:
						return 0;
            }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

		case WM_SETCURSOR:
			{	
				if (LOWORD(lParam) == HTCLIENT && HIWORD(lParam) == WM_MOUSEMOVE)
				{
					SetCursor(ghCursorNormal);
				}
				return TRUE;
			}

		case WM_DRAWITEM:
			{
				AdjustSideBar(hWnd);
				return TRUE;	
			}
		case WM_NOTIFY:
			{
				UINT  uId = (UINT) LOWORD(wParam);
/*#ifndef _CWU
				LPNMHDR pNMHdr = (LPNMHDR) lParam;
				switch (uId)
				{
					case IDC_WELCOME_PRIVACY:
					case IDC_WELCOME_EULA:
							switch (pNMHdr->code)
							{
							 case NM_RETURN:
							 case NM_CLICK:
								{
									LaunchLinkAction(uId);							
								}
								break;
							 default:
								 break;
							}			

					default:
							  break;
				}
#else
*/
				switch (uId)
				{
//					case IDC_WELCOME_PRIVACY:
					case IDC_WELCOME_EULA:
						if (((NMHDR FAR *) lParam)->code == EN_LINK) 
						{
							if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN)  
							{
								LaunchLinkAction(hWnd, uId);
							}
						}
						break;
					default:
							  break;
				}
//#endif
				return 0;
			}
		case WM_DESTROY:
		    g_EULA_Link.Uninit();
		    g_PrivacyStatementLink.Uninit();
		    return 0;
		default:
			{
				return FALSE;
			}
				
    }
}

WNDPROC editProc;

#ifdef TESTUI
const TCHAR REG_AUOPTIONS[] = _T("AUOptions"); //REG_DWORD
const TCHAR REG_AUSCHEDINSTALLDAY[] = _T("ScheduledInstallDay"); // REG_DWORD
const TCHAR REG_AUSCHEDINSTALLTIME[] = _T("ScheduledInstallTime"); // REG_DWORD

void GetServiceOption(
	LPDWORD lpdwOption,
	LPDWORD lpdwDay,
	LPDWORD lpdwTime
)
{
	DWORD dwResult = AUOPTION_INSTALLONLY_NOTIFY;
	GetRegDWordValue(REG_AUOPTIONS, &dwResult);
	if ((dwResult < AUOPTION_ADMIN_MIN) || (dwResult > AUOPTION_MAX))
	{
		DEBUGMSG("WUAUENG Invalid option in registry, returning installonly");
		dwResult = AUOPTION_INSTALLONLY_NOTIFY;
	}
	*lpdwOption = dwResult;

	dwResult = 0;
	GetRegDWordValue(REG_AUSCHEDINSTALLDAY, &dwResult);
	if( (dwResult <= 0) || (dwResult > 7))
	{
		dwResult = 0;
	}
	*lpdwDay = dwResult;
	gdwScheduledInstallDay = dwResult;

	dwResult = 0;
	GetRegDWordValue(REG_AUSCHEDINSTALLTIME, &dwResult);
	if( (dwResult <= 0) || (dwResult > 23))
	{
		dwResult = 3;
	}
	*lpdwTime = dwResult;
	gdwScheduledInstallTime = dwResult;
}


void SetServiceOption(
	DWORD dwOption,
	DWORD dwDay,
	DWORD dwTime
)
{
	SetRegDWordValue( REG_AUOPTIONS, dwOption);
	SetRegDWordValue( REG_AUSCHEDINSTALLDAY, dwDay);
	SetRegDWordValue( REG_AUSCHEDINSTALLTIME, dwTime);
}
#endif 

BOOL EnableCombo(HWND hwnd, BOOL bState)
{
	GetItemAndEnableIt(hwnd,IDC_CMB_DAYS,bState);
	GetItemAndEnableIt(hwnd,IDC_CMB_HOURS,bState);
//	GetItemAndEnableIt(hwnd,IDC_LEARNMORE,bState); //Enable/disable the learn about schedule install 
														//link along with the combo boxes.	
	return TRUE;
}

BOOL EnableOptions(HWND hwnd, BOOL bState)
{
	GetItemAndEnableIt(hwnd,IDC_OPTION1,bState);
	GetItemAndEnableIt(hwnd,IDC_OPTION2,bState);
	GetItemAndEnableIt(hwnd,IDC_OPTION3,bState);

	if (BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_OPTION3),BM_GETCHECK,0,0))
	{
		EnableCombo(hwnd, bState);
	}
	return TRUE;
}


void OnKeepUptoDate(HWND hwnd)
{
	LRESULT lResult = SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_GETCHECK,0,0);
	
	if (lResult == BST_CHECKED)
	{
		EnableOptions(hwnd, TRUE);
	}
	else if (lResult == BST_UNCHECKED)
	{
		EnableOptions(hwnd, FALSE);
		EnableCombo(hwnd, FALSE);
	}
}


void GetDayAndTimeFromUI( 
	HWND hWnd,
	LPDWORD lpdwDay,
	LPDWORD lpdwTime
)
{
	HWND hComboDays = GetDlgItem(hWnd,IDC_CMB_DAYS);
	HWND hComboHrs = GetDlgItem(hWnd,IDC_CMB_HOURS);
	LRESULT nDayIndex = SendMessage(hComboDays,CB_GETCURSEL,0,(LPARAM)0);
	LRESULT nTimeIndex = SendMessage(hComboHrs,CB_GETCURSEL,0,(LPARAM)0);

	*lpdwDay = (DWORD)SendMessage(hComboDays,CB_GETITEMDATA, nDayIndex, (LPARAM)0);
	*lpdwTime = (DWORD)SendMessage(hComboHrs,CB_GETITEMDATA, nTimeIndex, (LPARAM)0);
}

BOOL CALLBACK NotificationOptionsDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  

    switch(message)
    {   
        case WM_INITDIALOG:
            {
                ghCurrentDialog = hWnd;
  				EnableCombo(hWnd, FALSE); //Initially disabled
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
				SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
				
				if(-1 == gWelcomeOption.dwOption)
				{
#ifndef TESTUI
					gInternals->m_getServiceOption(&gWelcomeOption);
#else
					GetServiceOption(&(gWelcomeOption.dwOption), &(gWelcomeOption.dwSchedInstallDay), &(gWelcomeOption.dwSchedInstallTime));
#endif
				}

				g_AutoUpdatelink.SetSysLinkInstanceHandle(ghInstance);
				g_AutoUpdatelink.SubClassWindow(GetDlgItem(hWnd,IDC_STAT_LEARNAUTOUPDATE));
				g_AutoUpdatelink.SetHyperLink(gtszAUOverviewUrl);
				g_AutoUpdatelink.Invalidate();

				g_ScheduledInstalllink.SetSysLinkInstanceHandle(ghInstance);
				g_ScheduledInstalllink.SubClassWindow(GetDlgItem(hWnd,IDC_LEARNMORE));
				g_ScheduledInstalllink.SetHyperLink(gtszAUSchedInstallUrl);
				g_ScheduledInstalllink.Invalidate();

				switch(gWelcomeOption.dwOption)
				{
					case AUOPTION_AUTOUPDATE_DISABLE:
						CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_UNCHECKED);
						CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
						EnableOptions( hWnd, FALSE );
						break;

					case AUOPTION_PREDOWNLOAD_NOTIFY:
						CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
						CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
						EnableOptions( hWnd, TRUE );
						break;

					case AUOPTION_INSTALLONLY_NOTIFY:
						CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
						CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
						EnableOptions( hWnd, TRUE );
						break;

					case AUOPTION_SCHEDULED:
						CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
						CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
						EnableOptions( hWnd, TRUE );
						break;
				}

				SetFocus(GetDlgItem(hWnd, IDC_NEXT));
                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);

				HFONT hFont = (HFONT) SendMessage(hWnd , WM_GETFONT, 0, 0);
				MYREInit(hWnd, IDC_STAT_LEARNAUTOUPDATE, hFont);
				MYREInit(hWnd, IDC_LEARNMORE, hFont);
				FillDaysCombo(ghInstance, hWnd, gWelcomeOption.dwSchedInstallDay, IDS_STR_EVERYDAY, IDS_STR_SATURDAY );
				FillHrsCombo( hWnd, gWelcomeOption.dwSchedInstallTime );

                if (gWelcomeOption.fDomainPolicy)
                {
                    DisableUserInput(hWnd); 
                }
                return TRUE;
            }

		case WM_COMMAND:
			switch(LOWORD(wParam))
			{
				case IDOK:
				case IDC_NEXT:
//#ifndef _CWU
#if 0
					if(IsDlgButtonChecked(hWnd, IDC_OPTION1) == BST_CHECKED)
					{
						gdwWelcomeOption = AUOPTION_INSTALLONLY_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION2) == BST_CHECKED)
					{
						gdwWelcomeOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION3) == BST_CHECKED)
					{
						gdwWelcomeOption = AUOPTION_AUTOUPDATE_DISABLE;
					}
#endif					
//#else
					if(IsDlgButtonChecked(hWnd, IDC_CHK_KEEPUPTODATE) == BST_UNCHECKED)
					{
						gWelcomeOption.dwOption = AUOPTION_AUTOUPDATE_DISABLE;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION1) == BST_CHECKED)
					{
						gWelcomeOption.dwOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION2) == BST_CHECKED)
					{
						gWelcomeOption.dwOption = AUOPTION_INSTALLONLY_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION3) == BST_CHECKED)
					{
						gWelcomeOption.dwOption = AUOPTION_SCHEDULED;
						EnableCombo( hWnd, TRUE );
						GetDayAndTimeFromUI( hWnd, &(gWelcomeOption.dwSchedInstallDay), &(gWelcomeOption.dwSchedInstallTime));
					}					
//#endif
					CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_SETUPCOMPLETE), 
					        GetParent(hWnd), (DLGPROC)SetupCompleteDlgProc);
					DestroyWindow(hWnd);
					return 0;

                case IDC_BACK:
                    CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_WELCOME), 
                    GetParent(hWnd), (DLGPROC)WelcomeDlgProc);
                    DestroyWindow(hWnd);
                    return 0;

		case IDCANCEL:
		case IDC_CANCEL:
			CancelWizard(hWnd);	
			return 0;
//#ifndef _CWU
#if 0
				case IDC_OPTION1:
					gdwWelcomeOption = AUOPTION_INSTALLONLY_NOTIFY;
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
					return 0;
				case IDC_OPTION2:
					gdwWelcomeOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					return 0;
				case IDC_OPTION3:
					gdwWelcomeOption = AUOPTION_AUTOUPDATE_DISABLE;
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
					return 0;
#endif					
//#else
				case IDC_OPTION1:
					gWelcomeOption.dwOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					EnableCombo( hWnd, FALSE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
					return 0;
				case IDC_OPTION2:
					gWelcomeOption.dwOption = AUOPTION_INSTALLONLY_NOTIFY;
					EnableCombo( hWnd, FALSE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					return 0;
				case IDC_OPTION3:
					gWelcomeOption.dwOption = AUOPTION_SCHEDULED;
					EnableCombo( hWnd, TRUE );
					//GetDayAndTimeFromUI( hWnd, &(gWelcomeOption.dwSchedInstallDay), &(gWelcomeOption.dwSchedInstallTime));
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
					return 0;
				case IDC_CHK_KEEPUPTODATE:
					if( BN_CLICKED == HIWORD(wParam) )
					{
						OnKeepUptoDate( hWnd );
					}
					return 0;
//#endif
				default:
					return 0;
			}
		case WM_NOTIFY:
//#ifndef _CWU
#if 0
			{
				UINT  uId = (UINT) wParam;
				LPNMHDR pNMHdr = (LPNMHDR) lParam;
				if (IDC_LEARNMORE == uId && (NM_RETURN == pNMHdr->code || NM_CLICK == pNMHdr->code))
				{
					LaunchLinkAction(hWnd, uId);							
				}
				return 0;
			}
#endif
//#else
			{
					UINT  uId = (UINT) LOWORD(wParam);
					switch (uId)
					{
						case IDC_LEARNMORE:
						case IDC_STAT_LEARNAUTOUPDATE:
							if (((NMHDR FAR *) lParam)->code == EN_LINK) 
							{
								if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN)  
								{
									LaunchLinkAction(hWnd, uId);							
								}
							}
							break;
						default:
								  break;
					}
			}
			return 0;
//#endif
		case WM_SETCURSOR:
			{			
				if (LOWORD(lParam) == HTCLIENT && HIWORD(lParam) == WM_MOUSEMOVE)
				{
					SetCursor(ghCursorNormal);
				}
				return TRUE;
			}

	    case WM_CTLCOLORSTATIC:
		{
			return SetColors((HDC)wParam, (HWND)lParam);
		}	
	    case WM_DESTROY:
	        g_ScheduledInstalllink.Uninit();
	        g_AutoUpdatelink.Uninit();
	        return 0;
        default:
            return FALSE;
    }
}

BOOL CALLBACK SetupCompleteDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
    switch(message)
    {   
        case WM_INITDIALOG:
            {
                ghCurrentDialog = hWnd;
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
                SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
								
				GetItemAndEnableIt(hWnd, IDC_BACK, TRUE);								
				GetItemAndEnableIt(hWnd, IDC_CANCEL, TRUE);

                SetFocus(GetDlgItem(hWnd, IDC_FINISH));

                return TRUE;
            }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
				case IDC_BACK:
              		      CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_NOTOPTIONS), 
						GetParent(hWnd), (DLGPROC)NotificationOptionsDlgProc);
		                    DestroyWindow(hWnd);
					return 0;
				case IDCANCEL:
				case IDC_CANCEL:
					CancelWizard(hWnd);
					return 0;
				case IDOK:
				case IDC_FINISH:									
					EndDialog(GetParent(hWnd), S_OK);
					DestroyWindow(hWnd);
#ifdef TESTUI
					SetServiceOption(gWelcomeOption.dwOption, gWelcomeOption.dwSchedInstallDay, gWelcomeOption.dwSchedInstallTime);
					PostMessage(ghMainWindow, AUMSG_SHOW_DOWNLOAD, 0, 0);
#else
					gInternals->m_setServiceOption(gWelcomeOption);
					gInternals->m_configureAU();
					QUITAUClient();
#endif
					return 0;
	       	         default:
       	       	      return 0;
            }

			case WM_CTLCOLORSTATIC:
				return SetColors((HDC)wParam, (HWND)lParam);

			case WM_DRAWITEM:
				AdjustSideBar(hWnd);
				return TRUE;

        default:
            return FALSE;
    }
}

void SetRemindMeLaterState(HWND hWnd)
{
#ifndef TESTUI
    AUOPTION auopt;
    if (SUCCEEDED(gInternals->m_getServiceOption(&auopt)))
    {
        GetItemAndEnableIt(hWnd, IDC_REMINDLATER,AUOPTION_SCHEDULED != auopt.dwOption); 
    }
#endif    
}

BOOL CALLBACK DownloadDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{ 
    switch(message)
    {
        case WM_INITDIALOG:
            {
                ghCurrentMainDlg = hWnd;
  	 	  ghCurrentDialog = hWnd;

		  SetAUDialogIcon(hWnd, ghAppIcon, ghAppSmIcon);
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
		  SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
#ifndef TESTUI
                if ( gInternals->m_ItemList.GetNumSelected() == 0)
                {
                    SetButtonText(GetDlgItem(hWnd, IDC_OK), IDS_CLOSEBUTTONTXT);
                }
#endif
                SetRemindMeLaterState(hWnd);

                SetActiveWindow(ghCurrentMainDlg);
                SetForegroundWindow(ghCurrentMainDlg);
                
                if(mshtml == NULL) 
                {
			// fixcode: we already have a static ref to mshtml.
                    mshtml = LoadLibraryFromSystemDir(_T("MSHTML.DLL"));
                    pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)GetProcAddress(mshtml, "ShowHTMLDialog");
                }
                
                SetFocus(GetDlgItem(hWnd, IDC_UPDATELIST));
#ifdef DBG
				DebugCheckForAutoPilot(hWnd);
#endif // DBG
                return TRUE;
            }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_OK:
                        {
#ifdef TESTUI
					PostMessage(ghMainWindow, AUMSG_SHOW_INSTALL, 0, 0);
#else
                                   long lSelected = gInternals->m_ItemList.GetNumSelected();
					if (FAILED(gInternals->m_startDownload()) || 0 == lSelected)
						{
						QUITAUClient();
						}
					else
					{
					    RemoveTrayIcon();
					}
#endif
			
			EndDialog(hWnd, S_OK);
                    return 0;
                    }

                case IDC_REMINDLATER:
                    if(DialogBox(ghInstance, MAKEINTRESOURCE(IDD_REMIND),
                        hWnd, (DLGPROC)ReminderDlgProc) == S_OK)
                    {
#ifndef TESTUI
				gInternals->m_setReminderState(AUSTATE_DETECT_COMPLETE);
       	              EndDialog(hWnd, S_FALSE);
#endif
                    }
                    return 0;

                case IDC_SETTINGS:
                    {
                        ShowSettingsDlg(hWnd);
                        SetRemindMeLaterState(hWnd);
                        return 0;
                    }

                case IDCANCEL:					
                	//CancelDialog(hWnd, AUSTATE_DETECT_COMPLETE, TRUE);
                	EndDialog(hWnd, S_OK);
                	gNextDialogMsg = AUMSG_SHOW_DOWNLOAD;
                	return 0;

                default:
                    return 0;
            }
            
        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case AUMSG_SELECTION_CHANGED:
#ifndef TESTUI
            if ( gInternals->m_ItemList.GetNumSelected() == 0)
            {
                SetButtonText(GetDlgItem(hWnd, IDC_OK), IDS_CLOSEBUTTONTXT);
            }
            else
            {
                SetButtonText(GetDlgItem(hWnd, IDC_OK), IDS_DOWNLOADBUTTONTXT);
            }
#endif
            return TRUE;

        case AUMSG_SHOW_RTF:
            {
#ifdef TESTUI
				TCHAR tszMsg[100];
				(void)StringCchPrintfEx(tszMsg, ARRAYSIZE(tszMsg), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("SHOW RTF for item %d"), (UINT)wParam);
				MessageBox(0, tszMsg, _T("Show RTF"), 0);
#else
                
				ShowRTF(hWnd, wParam);
				
#endif
                return TRUE;
            }            
            break;
            
        case WM_DESTROY:
            ghCurrentMainDlg = NULL;
            return FALSE;
            
        case WM_MOVE:
            return (LONG)SendMessage(GetDlgItem(hWnd, IDC_UPDATELIST), message, wParam, lParam);

        case WM_HELP:
    		LaunchHelp(hWnd, gtszAUOverviewUrl);
    		return TRUE;

            
        default:
            return FALSE;

    }
}

BOOL CALLBACK InstallDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
    switch(message)
    {
        case WM_INITDIALOG:
			SetAUDialogIcon(hWnd, ghAppIcon, ghAppSmIcon);
            ghCurrentMainDlg = hWnd;
#ifdef TESTUI
           ghCurrentDialog = CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_SUMMARY), 
                    hWnd, (DLGPROC)SummaryDlgProc);
#else
            if ( 0 == gInternals->m_ItemList.GetNumUnselected())
			{
				ghCurrentDialog = CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_SUMMARY), 
                    hWnd, (DLGPROC)SummaryDlgProc);
			}
			else
			{
				ghCurrentDialog = CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_DETAILS), 
                    hWnd, (DLGPROC)DetailsDlgProc);
			}
#endif
            ShowWindow(hWnd, SW_HIDE);
            SetActiveWindow(ghCurrentMainDlg);
            SetForegroundWindow(ghCurrentMainDlg);
			SetFocus(ghCurrentDialog);
            return FALSE;

        case WM_MOVE:
            return (LONG)SendMessage(ghCurrentDialog, message, wParam, lParam);
            break;

		case WM_COMMAND:
			if(ghCurrentDialog != NULL)
			{
				PostMessage(ghCurrentDialog, WM_COMMAND, wParam, lParam);
			}
			return 0;
			break;

        case WM_HELP:
        		LaunchHelp(hWnd, gtszAUOverviewUrl);
        		return TRUE;

        case WM_DESTROY:
            	ghCurrentMainDlg = NULL;
            	ghCurrentDialog = NULL;
//		QUITAUClient(); // if we are getting destroyed, install is over //QUITAUClient() where we know we need to quit
	     	break;
        default:
            break;
    }
    return FALSE;
}

BOOL CALLBACK SummaryDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HANDLE hIcon = NULL;
    switch(message)
    {
        case WM_INITDIALOG:
            {
		//DEBUGMSG("SummaryDlg Get Initialized");
                ghCurrentDialog = hWnd;
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
                SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
                if (NULL == hIcon)
                {
                	hIcon = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_INFOICON), IMAGE_ICON, 16, 16, LR_LOADTRANSPARENT | LR_CREATEDIBSECTION);
                }
                HWND hInfoIcon = GetDlgItem(hWnd, IDC_INFOICON);
                SendMessage( hInfoIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
                HFONT hFont = (HFONT) SendMessage(hWnd , WM_GETFONT, 0, 0);
                MYREInit(hWnd, IDC_SUMMARY_NOTE, hFont);
                SetRemindMeLaterState(hWnd);
                SetFocus(GetDlgItem(hWnd, IDC_OK));
		
#ifdef DBG
				DebugCheckForAutoPilot(hWnd);
#endif // DBG
                return TRUE;
            }

		case WM_COMMAND:
            switch(LOWORD(wParam))
            {
		  case IDOK:
                case IDC_OK:
					{
					RemoveTrayIcon();
#ifdef TESTUI
					CreateDialogParam(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS), 
							GetParent(hWnd), (DLGPROC)ProgressDlgProc, 2);
					DestroyWindow(hWnd);
#else
					int num;
					if ( 0 != (num = gInternals->m_ItemList.GetNumSelected() ))
					{
//						CreateDialogParam(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS), 
//							GetParent(hWnd), (DLGPROC)ProgressDlgProc, gInternals->m_ItemList.GetNumSelected());
						CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS),GetParent(hWnd), (DLGPROC)ProgressDlgProc);
					}
                                   HRESULT hr;
					if (FAILED(hr = gInternals->m_startInstall()) || 0 == num)
					{
						EndDialog(GetParent(hWnd), S_OK);
					}
					else
					    {
                                          DestroyWindow(hWnd);
					    }
					if (FAILED(hr))
					    {
    						QUITAUClient();
					    }
#endif
                    return 0;
					}

               
				case IDC_DETAILS:
                    CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_DETAILS), 
                    GetParent(hWnd), (DLGPROC)DetailsDlgProc);
                    DestroyWindow(hWnd);
                    return 0;
				

                case IDC_REMINDLATER:
                    if(DialogBox(ghInstance, MAKEINTRESOURCE(IDD_REMIND),
                        hWnd, (DLGPROC)ReminderDlgProc) == S_OK)
                    {
#ifdef TESTUI
#else
						gInternals->m_setReminderState(AUSTATE_DOWNLOAD_COMPLETE);
                        EndDialog(GetParent(hWnd), S_FALSE);
//                        QUITAUClient();
#endif
                    }
                    return 0;

		case IDCANCEL:					
					//CancelDialog(hWnd, AUSTATE_DOWNLOAD_COMPLETE);
					EndDialog(GetParent(hWnd), S_OK);
					gNextDialogMsg = AUMSG_SHOW_INSTALL;
					return 0;

                default:
                    return 0;
            }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);
            
	case WM_DRAWITEM:
				AdjustSideBar(hWnd);
				return TRUE;

        default:
            return FALSE;
    }
}

// peterwi can this and Summary dialog proc essentially be combined?
BOOL CALLBACK DetailsDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_INITDIALOG:
            {
                ghCurrentDialog = hWnd;
            
                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
				SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

#ifndef TESTUI
                if ( gInternals->m_ItemList.GetNumSelected() == 0 )
                {
                    SetButtonText(GetDlgItem(hWnd, IDC_OK), IDS_CLOSEBUTTONTXT);
                }
#endif
                SetRemindMeLaterState(hWnd);
                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
                
                if(mshtml == NULL) 
                {
                    mshtml = LoadLibraryFromSystemDir(_T("MSHTML.DLL"));
                    pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)GetProcAddress(mshtml, "ShowHTMLDialog");
                }
                
                SetFocus(GetDlgItem(hWnd, IDC_OK));
                                
                return TRUE;
            }
	
		
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_OK:
					{

#ifdef TESTUI
					CreateDialogParam(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS), 
                                    GetParent(hWnd), (DLGPROC)ProgressDlgProc, 2);
					DestroyWindow(hWnd);
#else
					RemoveTrayIcon();
					//(void)gpClientCatalog->PruneInstallListAccordingToSelections();
					int num;
					if ( 0 != (num = gInternals->m_ItemList.GetNumSelected()) )
					{
						DEBUGMSG("WUAUCLT details dialog had %d items selected", num);
//						CreateDialogParam(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS), 
//							              GetParent(hWnd), (DLGPROC)ProgressDlgProc, gInternals->m_ItemList.GetNumSelected());
						CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_PROGRESS),GetParent(hWnd), (DLGPROC)ProgressDlgProc);
					}

					HRESULT hr ;
					if (FAILED(hr = gInternals->m_startInstall()) || 0 == num)
					{
						EndDialog(GetParent(hWnd), S_OK);
					}
					else
					{
						DestroyWindow(hWnd);
					}
					if (FAILED(hr))
					{
						QUITAUClient();
					}
#endif
                    return 0;
					}

                case IDC_REMINDLATER:
                    if(DialogBox(ghInstance, MAKEINTRESOURCE(IDD_REMIND),
                        hWnd, (DLGPROC)ReminderDlgProc) == S_OK)
                    {
#ifndef TESTUI
                        gInternals->m_setReminderState(AUSTATE_DOWNLOAD_COMPLETE);
                        EndDialog(GetParent(hWnd), S_FALSE);
                        //QUITAUClient();
#endif
                    }
                    return 0;

                case IDC_SETTINGS:
                    ShowSettingsDlg(hWnd);
                    SetRemindMeLaterState(hWnd);
                    return 0;

                case IDCANCEL:					
					//CancelDialog(hWnd, AUSTATE_DETECT_COMPLETE);
					EndDialog(GetParent(hWnd), S_OK);
					gNextDialogMsg = AUMSG_SHOW_INSTALL;
					return 0;

                default:
                    return 0;
            }

        case AUMSG_SELECTION_CHANGED:
        	UINT uBtnTxt;
            if ( gInternals->m_ItemList.GetNumSelected() == 0 )
            {
                uBtnTxt = IDS_CLOSEBUTTONTXT;
            }
            else
            {
                uBtnTxt = IDS_INSTALLBUTTONTXT;
            }
            SetButtonText(GetDlgItem(hWnd, IDC_OK), uBtnTxt);
            return TRUE;
            
        case AUMSG_SHOW_RTF:
            {
#ifdef TESTUI
				TCHAR tszMsg[100];
				(void)StringCchPrintfEx(tszMsg, ARRAYSIZE(tszMsg), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("SHOW RTF for item %d"), (UINT)wParam);
				MessageBox(0, tszMsg, _T("Show RTF"), 0);
#else
                ShowRTF(hWnd, wParam);
#endif
                return TRUE;
            }            
            break;
            
        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case WM_MOVE:
            return (LONG)SendMessage(GetDlgItem(hWnd, IDC_UPDATELIST), message, wParam, lParam);

        default:
            return FALSE;
    }
}

BOOL CALLBACK ProgressDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
#ifdef TESTUI
	static DWORD dwProgress = 0;
#endif
    switch(message)
    {
        case WM_INITDIALOG:
        {
            ghCurrentDialog = hWnd;
            HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
			SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

#ifdef TESTUI
			HWND hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
			dwProgress = 0;
			SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,  3));
			SendMessage(hProgress, PBM_SETSTEP, (WPARAM) 1, 0); 
			SetTimer(hWnd, 1, 1000, NULL);
#else
//		    HWND hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
//			DEBUGMSG("WUAUCLT ProgressDlg total %d items to be installed ", lParam);
//            SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,  lParam));
//			SendMessage(hProgress, PBM_SETSTEP, (WPARAM) 1, 0); 
#endif
		
            SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
            EnableMenuItem (GetSystemMenu(GetParent(hWnd), FALSE), SC_CLOSE, MF_GRAYED);
            return TRUE;
        }
		case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case AUMSG_INSTALL_COMPLETE:
			DEBUGMSG("WUAUCLT ProgDlg gets AUMSG_INSTALL_COMPLETE");
            CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_COMPLETE), 
                GetParent(hWnd), (DLGPROC)InstallCompleteDlgProc);
            DestroyWindow(hWnd);
            return TRUE;

        case AUMSG_REBOOT_REQUIRED:
			DEBUGMSG("WUAUCLT ProgDlg gets AUMSG_REBOOT_REQUIRED");
            CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_RESTART),
                GetParent(hWnd), (DLGPROC)RestartDlgProc);
		DestroyWindow(hWnd);
		return TRUE;

        case AUMSG_INSTALL_PROGRESS:
			{
				HWND hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
				SendMessage(hProgress, PBM_STEPIT, 0, 0);
		            return TRUE;
			}

	case AUMSG_SET_INSTALL_ITEMSNUM:
		{
			HWND hProgress = GetDlgItem(hWnd, IDC_PROGRESS);
			DEBUGMSG("WUAUCLT ProgressDlg total %d items to be installed ", lParam);
			SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,  lParam));
			SendMessage(hProgress, PBM_SETSTEP, (WPARAM) 1, 0); 
	}
#ifdef TESTUI
		case WM_TIMER:
		{
			dwProgress ++;
			PostMessage(hWnd, AUMSG_INSTALL_PROGRESS, 0, 0);
			if (dwProgress  >= 3) 
			{
				KillTimer(hWnd, 1);
				if(fCheckRebootFlag())
				{
					PostMessage(hWnd, AUMSG_REBOOT_REQUIRED, 0, 0);
				}
				else
				{
					PostMessage(hWnd, AUMSG_INSTALL_COMPLETE, 0, 0);
				}
			}
			return 0;
		}
#endif  
        default:
            return FALSE;
    }
}

BOOL CALLBACK InstallCompleteDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_INITDIALOG:
        {
			ghCurrentDialog = hWnd;
            HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
            SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
            SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
#ifdef DBG
			DebugCheckForAutoPilot(hWnd);
			DebugUninstallDemoPackages();
#endif // DBG
            EnableMenuItem (GetSystemMenu(GetParent(hWnd), FALSE), SC_CLOSE, MF_ENABLED); //reset system menu
            return TRUE;
        }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
				case IDOK:
                case IDC_OK:
				case IDCANCEL:
                    EndDialog(GetParent(hWnd), S_OK);
					QUITAUClient();
                    return 0;				

                default:
                    return 0;
            }

		case WM_DESTROY:
//            ghCurrentMainDlg = NULL;
			return FALSE;

		case WM_DRAWITEM:
			AdjustSideBar(hWnd);
			return TRUE;

        default:
            return FALSE;
    }
}

BOOL CALLBACK RestartDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_INITDIALOG:
        {
            ghCurrentDialog = hWnd;
            HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
            SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);
            SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
            SetFocus(GetDlgItem(hWnd, IDC_RESTARTNOW));
            EnableMenuItem (GetSystemMenu(GetParent(hWnd), FALSE), SC_CLOSE, MF_ENABLED); //reset system menu
            return TRUE;
        }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
		case IDOK:
        case IDC_RESTARTNOW:
			SetClientExitCode(CDWWUAUCLT_REBOOTNOW);
                    EndDialog(GetParent(hWnd),S_OK);
                    QUITAUClient();
                    return 0;
		case IDCANCEL:
		case IDC_RESTARTLATER:
				//DestroyWindow(hWnd);
				EndDialog(GetParent(hWnd), S_OK);
				SetClientExitCode(CDWWUAUCLT_REBOOTLATER);
				QUITAUClient();
			return 0;
              default:
                    return 0;
            }

		case WM_DRAWITEM:
			AdjustSideBar(hWnd);
			return TRUE;

        default:
            return FALSE;
    }
}


BOOL CALLBACK SetupCancelDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{  
    switch(message)
    {   
        case WM_INITDIALOG:
            {
                ghCurrentDialog = hWnd;

                HWND hHeader = GetDlgItem(hWnd, IDC_HEADER);
                SendMessage(hHeader, WM_SETFONT, (WPARAM)ghHeaderFont, 0);

                SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
				
				GetItemAndEnableIt(hWnd, IDC_BACK, FALSE);
				GetItemAndEnableIt(hWnd, IDC_CANCEL, FALSE);

				SetFocus(GetDlgItem(hWnd, IDC_FINISH));		

                return TRUE;
            }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
				case IDOK:				
				case IDCANCEL:					
				case IDC_FINISH:	
					{
						// bug 493734
						// Remove the dialog (frame) but keep the icon.
                		EndDialog(GetParent(hWnd), S_OK);
                		gNextDialogMsg = AUMSG_SHOW_WELCOME;
//						QUITAUClient();		
//						RemoveTrayIcon();
						return 0;
					}				
                default:
                    return 0;
            }

        case WM_CTLCOLORSTATIC:
			return SetColors((HDC)wParam, (HWND)lParam);

	case WM_DRAWITEM:
			AdjustSideBar(hWnd);
			return TRUE;

        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\reminder.cpp ===
#include "pch.h"
#pragma hdrstop

#define STRING_BUFFER_SIZE 80

void InitReminderComboBox(HWND hDlg, HWND combo)
{
	for(int i = 0; i < TIMEOUT_INX_COUNT; i++)
	{
		TCHAR buffer[STRING_BUFFER_SIZE];
		if (0 == LoadString(ghInstance, ReminderTimes[i].stringResId, buffer, STRING_BUFFER_SIZE))
		{
			DEBUGMSG("WUAUCLT String resource %d not found", ReminderTimes[i].stringResId);
			QUITAUClient();
			return;
		}
		LRESULT lr = SendMessage(combo, CB_INSERTSTRING, i, (LPARAM)buffer);
		if (CB_ERR == lr)
		{
			DEBUGMSG("REMINDER: fail to insert string to combobox %S", buffer);
		}
	}
	SendMessage(combo, CB_SETCURSEL, 0, 0); 
}



BOOL CALLBACK ReminderDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM /*lParam*/)
{
	//fixcode: no need static
	static HWND combo;
	static HWND oldCurrentDlg;

	switch(message)
	{
		case WM_INITDIALOG:
			oldCurrentDlg = ghCurrentDialog;
			ghCurrentDialog = hWnd;
			gTopWins.Add(hWnd);
			combo = GetDlgItem(hWnd, IDC_REMINDTIME);
			InitReminderComboBox(hWnd, combo);
			SetFocus(combo);
			return TRUE;

		case WM_COMMAND:
			switch(LOWORD(wParam))
			{
				case IDC_OK:
					{
#ifdef TESTUI
						EndDialog(hWnd, S_OK);
						return 0;
#else
						UINT index = (LONG)SendMessage(combo, CB_GETCURSEL, 0, 0);
						gInternals->m_setReminderTimeout(index);
						EndDialog(hWnd, S_OK);						
						QUITAUClient();	//Stop the client's execution when user sets remind me later
						return 0;
#endif
					}
				case IDCANCEL:
				case IDC_CANCEL:
					{
						EndDialog(hWnd, S_FALSE);
						return 0;
					}

				default:
					break;
			}
			break;
/*
		case WM_CLOSE:
			{
				UINT index = SendMessage(combo, CB_GETCURSEL, 0, 0);

				setReminderTime(index);
				EndDialog(hWnd, S_FALSE);
				return TRUE;
			}
			*/

		case WM_DESTROY:
			ghCurrentDialog = oldCurrentDlg;
			gTopWins.Remove(hWnd);
			return 0;

		default:
			break;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\promptuserdlg.h ===
// PromptUserDlg.h: interface for the CPromptUserDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROMPTUSERDLG_H__BFA609BD_8021_4CE2_AEF8_1D0D96F87402__INCLUDED_)
#define AFX_PROMPTUSERDLG_H__BFA609BD_8021_4CE2_AEF8_1D0D96F87402__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define AU_IDTIMEOUT 	1000
class CPromptUserDlg  
{
public:
	CPromptUserDlg(WORD wDlgResourceId, BOOL fEnableYes= TRUE, BOOL fEnableNo = TRUE);
	virtual int DoModal(HWND hWndParent);
	virtual ~CPromptUserDlg();

	//Message Handlers
	BOOL _OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
	void _OnTimer(HWND hwnd, UINT id);
	void _OnDestroy(HWND hwnd);
	void _OnEndSession(HWND hwnd, BOOL fEnding);

	static void SetInstanceHandle(HINSTANCE hInstance);
	static INT_PTR CALLBACK _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	//Helper function
	void UpdateStatus(HWND hwnd);
private:
	static HINSTANCE m_hInstance;

private:
	WORD m_wDlgResourceId;
	HWND m_ProgressBar;

	UINT_PTR m_nIDTimer;
	UINT m_ElapsedTime;
	
	BOOL m_fEnableYes;
	BOOL m_fEnableNo;
};

#endif // !defined(AFX_PROMPTUSERDLG_H__BFA609BD_8021_4CE2_AEF8_1D0D96F87402__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\promptuserdlg.cpp ===
// PromptUserDlg.cpp: implementation of the CPromptUserDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "PromptUserDlg.h"
#include "Resource.h"
#include "windowsx.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
HINSTANCE CPromptUserDlg::m_hInstance = NULL;

#define TIMER_INTERVAL 5000  //5 sec interval
#define TOTAL_TIME_ELAPSE 300000 //Lesser number for testing purposes
								// For 5 mins 300000
								// Waiting time : 5 mins interval

const TCHAR g_szDialogPtr[]       = TEXT("PromptUser_DialogPtr");

void CPromptUserDlg::SetInstanceHandle(HINSTANCE hInstance)
{
	m_hInstance = hInstance;
}

CPromptUserDlg::CPromptUserDlg(WORD wDlgResourceId, BOOL fEnableYes, BOOL fEnableNo )
{
	m_nIDTimer = 0;
	m_wDlgResourceId = wDlgResourceId;
	m_ElapsedTime = 0;
	m_fEnableYes = fEnableYes;
	m_fEnableNo = fEnableNo;
}

CPromptUserDlg::~CPromptUserDlg()
{

}

INT CPromptUserDlg::DoModal(HWND hWndParent = NULL)
{
	return (INT)DialogBoxParam(m_hInstance, 
                                 MAKEINTRESOURCE(m_wDlgResourceId), 
                                 hWndParent, 
                                 (DLGPROC)CPromptUserDlg::_DlgProc, 
                                 (LPARAM)this);
}

INT_PTR CALLBACK 
CPromptUserDlg::_DlgProc(   // [static]
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
	CPromptUserDlg *pThis = NULL;
    if (WM_INITDIALOG == uMsg)
    {
        pThis = (CPromptUserDlg *)lParam;
        if (!SetProp(hwnd, g_szDialogPtr, (HANDLE)pThis))
        {
            pThis = NULL;
        }
    }
    else
    {
        pThis = (CPromptUserDlg *)GetProp(hwnd, g_szDialogPtr);
    }

    if (NULL != pThis)
    {
        switch(uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG,  pThis->_OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND,     pThis->_OnCommand);
            HANDLE_MSG(hwnd, WM_DESTROY, pThis->_OnDestroy);
	     HANDLE_MSG(hwnd, WM_TIMER,     pThis->_OnTimer);
		 HANDLE_MSG(hwnd, WM_ENDSESSION, pThis->_OnEndSession);
            default:
                break;
        }
    }
    return (FALSE);
}

extern HWND ghCurrentMainDlg;
extern HWND ghCurrentDialog;

BOOL CPromptUserDlg::_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
// set icons
	HICON hIcon = (HICON)::LoadImage(m_hInstance, MAKEINTRESOURCE(IDI_AUICON), 
	IMAGE_ICON, ::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR);
	::SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);

	HICON hIconSmall = (HICON)::LoadImage(m_hInstance, MAKEINTRESOURCE(IDI_AUICON), 
		IMAGE_ICON, ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR);
	::SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIconSmall);

	EnableWindow(GetDlgItem(hwnd, IDYES), m_fEnableYes);
	EnableWindow(GetDlgItem(hwnd, IDNO), m_fEnableNo);
	ghCurrentMainDlg = hwnd;
  	ghCurrentDialog = hwnd;
	m_nIDTimer = SetTimer(hwnd,m_nIDTimer,TIMER_INTERVAL,(TIMERPROC)NULL);
	m_ProgressBar = GetDlgItem(hwnd,IDC_PROG_TIME);

	SendMessage(m_ProgressBar,PBM_SETRANGE, 0, MAKELPARAM(0,TOTAL_TIME_ELAPSE / TIMER_INTERVAL));
	SendMessage(m_ProgressBar,PBM_SETSTEP,(WPARAM)1,(LPARAM)0);

	EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_CLOSE, MF_GRAYED);

	UpdateStatus(hwnd);
//       SetActiveWindow(ghCurrentMainDlg); 
       SetForegroundWindow(ghCurrentMainDlg);

	return TRUE;
}

void CPromptUserDlg::_OnDestroy (HWND hwnd) {
        ghCurrentMainDlg = NULL;
}



BOOL CPromptUserDlg::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
        case IDNO:
        case IDYES:
            if(BN_CLICKED == codeNotify)
            {
				KillTimer(hwnd,m_nIDTimer);
                EndDialog(hwnd,id);
            }
	        break;
	}
	return TRUE;
}

void CPromptUserDlg::_OnTimer(HWND hwnd, UINT id)
{
	m_ElapsedTime += TIMER_INTERVAL;

	if (m_ElapsedTime <= TOTAL_TIME_ELAPSE)
	{
		//Update Progress bar
		SendMessage(m_ProgressBar,PBM_STEPIT,0,0);
		UpdateStatus(hwnd);
	}
	if (m_ElapsedTime == TOTAL_TIME_ELAPSE)
	{
		KillTimer(hwnd,m_nIDTimer);
		//On end of TOTAL_TIME_ELAPSE send message idyes to the dialog.
		EndDialog(hwnd,AU_IDTIMEOUT);
	}
}

void CPromptUserDlg::UpdateStatus(HWND hwnd)
{
	TCHAR tszCountdownFormat[81];//see 
	TCHAR tszCountdown[160];
	TCHAR strFormat[200];
	TCHAR strUpdate[200];
	DWORD dwResId = 0;
	SYSTEMTIME st;

	ZeroMemory(&st, sizeof(st));
	st.wMinute = ((TOTAL_TIME_ELAPSE - m_ElapsedTime) / 1000) / 60;
	st.wSecond = ((TOTAL_TIME_ELAPSE - m_ElapsedTime) / 1000) % 60;

	switch(m_wDlgResourceId) {
	case IDD_START_INSTALL:
		dwResId = IDS_START_INSTALL;
		break;

	case IDD_PROMPT_RESTART:
		dwResId = IDS_PROMPT_RESTART;
		break;
	}

	if (LoadString(m_hInstance, IDS_COUNTDOWN_FORMAT, tszCountdownFormat, ARRAYSIZE(tszCountdownFormat)) &&
		LoadString(m_hInstance, dwResId, strFormat, ARRAYSIZE(strFormat)) &&
		GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, tszCountdownFormat, tszCountdown, ARRAYSIZE(tszCountdown)))
	{
		(void)StringCchPrintfEx(strUpdate, ARRAYSIZE(strUpdate), NULL, NULL, MISTSAFE_STRING_FLAGS, strFormat, tszCountdown);
		//fixcode: check return value of GetDlgItem()
		SetWindowText(GetDlgItem(hwnd,IDC_STAT_COUNTER),strUpdate);
	}
}


void CPromptUserDlg::_OnEndSession(HWND hwnd, BOOL fEnding)
{
	DEBUGMSG("OnEndSession: ending = %s", fEnding ? "TRUE" : "FALSE");
	KillTimer(hwnd,m_nIDTimer);
	//On end of TOTAL_TIME_ELAPSE send message idyes to the dialog.
	EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_CLOSE, MF_ENABLED);
	EndDialog(hwnd,AU_IDTIMEOUT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\pch.h ===
//#pragma warning( push, 3 )
#include <windows.h>
#include <tchar.h>
#include "criticalfixreg.h"
#include "aumsgs.h"
#include "wuauengi.h"
#include "wuaustate.h"
#include "wuaulib.h"
#include "aucltcatalog.h"
#include "auinternals.h"
#include "wuauclt.h"
#include "resource.h"
#include <Mshtmhst.h>
#include <Wtsapi32.h>
#include "auregkeys.h"
#include "auwait.h"
#include <richedit.h>
#include <commdlg.h>
#include "safefunc.h"
#include "CltDebug.h"
#include <shellapi.h>
#include <comdef.h>
#include <initguid.h> 
#include <oleacc.h>
#include <advpub.h>
#include "customlb.h"
#include "customlbacc.h"
#include "schemamisc.h"
#include "aucomres.h"
#include "audirectory.h"
#include "PromptUserDlg.h"
#include "aucompat.h"
#include "memutil.h"
#include "WUTestKeys.h"
#include "wusafefn.h"
#include "MISTSafe.h"
//#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by contents.rc
//
#include "aucomres.h"

#define IDS_WELCOMECAPTION              100
#define IDS_DOWNLOADTITLE               101
#define IDS_DOWNLOADCAPTION             102
#define IDS_INSTALLTITLE                103
#define IDS_INSTALLCAPTION              104
#define IDS_DOWNLOADBUTTONTXT	        107
#define IDS_INSTALLBUTTONTXT	        108
#define IDS_CLOSEBUTTONTXT	            109
#define IDS_PAUSEMENUITEM	            111
#define IDS_RESUMEMENUITEM	            112
#define IDS_DOWNLOADINGFORMAT	        113
#define IDS_SUSPENDEDFORMAT	            114
#define IDS_HEADERFONT		            117
#define IDS_INSTALLTEXT                 118
#define IDS_THIRTY_MINUTES              125
#define IDS_ONE_HOUR                    126
#define IDS_TWO_HOURS                   127
#define IDS_FOUR_HOURS                  128
#define IDS_TOMORROW                    129
#define IDS_READTHISFIRST               130
#define IDS_WELCOMETITLE                131
#define IDS_CLOSEWARNINGTITLE       	132
#define IDS_CLOSEWARNINGTEXT	        133
#define IDS_RESTORE_POINT_DESC          136
#define IDS_THREE_DAYS					154
#define IDS_NOTE				157
#define IDS_WELCOME_CONTINUE			158
#define IDS_RTFSHORTCUT					159
//#ifdef _CWU
#define IDS_EULA						160
#define IDS_PRIVACY						161
#define IDS_LEARNMORE					162
#define IDS_LEARNMOREAUTO				163
#define IDS_STR_EVERYDAY				164
#define IDS_STR_SUNDAY					165
#define IDS_STR_MONDAY					166
#define IDS_STR_TUESDAY					167
#define IDS_STR_WEDNESDAY				168
#define IDS_STR_THURSDAY				169
#define IDS_STR_FRIDAY					170
#define IDS_STR_SATURDAY				171
#define IDS_START_INSTALL				174
#define IDS_PROMPT_RESTART				175
#define IDS_COUNTDOWN_FORMAT			176
//#endif



//////////////////////////////////////////////////
// ICON identifiers
//////////////////////////////////////////////////
#define IDI_AUICON 		301
#define IDI_INFOICON					304


//////////////////////////////////////////////////
// BITMAP identifiers
//////////////////////////////////////////////////
#define IDB_SIDEBAR                     401
#define IDB_HEADERICON                  402
#define IDB_CHECK                       403
#define IDB_CLEAR                       404
#define IDB_GRAYOUT			    405


/////////////////////////////////////////////////
// DIALOG identifiers
/////////////////////////////////////////////////
#define IDD_WELCOME                     501
#define IDD_DETAILS                     502
#define IDD_DOWNLOAD                    503
#define IDD_SUMMARY                     504
#define IDD_PROGRESS                    505
#define IDD_COMPLETE                    506
#define IDD_RESTART                     507
#define IDD_REMIND			            509
#define IDD_UPDATEFRAME                 510
#define IDD_INSTALLFRAME                511
#define IDD_SETTINGS                    512
#define IDD_DISABLE                     513
#define IDD_SETUPCOMPLETE				514
#define IDD_NOTOPTIONS					515
#define IDD_SETUPCANCEL					516
//#ifdef _CWU
#define IDD_RESTOREUPDATE				517
#define IDD_START_INSTALL               518
#define IDD_PROMPT_RESTART              519
//#endif

/////////////////////////////////////////////////
// ACCELARATOR identifiers
/////////////////////////////////////////////////
#define IDA_BASE						610

/////////////////////////////////////////////////
// CONTROL identifiers
/////////////////////////////////////////////////
#define IDC_SETTINGS                    701
#define IDC_OK                          702
#define IDC_REMINDLATER                 703
#define IDC_UPDATELIST                  704
#define IDC_DETAILS                     705
#define IDC_PROGRESS                    706
#define IDC_HEADER                      707
#define IDC_CANCEL                      708
#define IDC_REMINDTIME                  709
#define IDC_TEXT                        710
//#define IDC_OPTION1                     711
//#define IDC_OPTION2                     712
//#define IDC_OPTION3                     713
//#define IDC_RESTOREHIDDEN               714
#define IDC_NEXT						715
#define IDC_BACK						716
#define IDC_FINISH						717
#define IDC_ACCEPT						718
#define IDC_PAUSE                       720
#define IDC_RESUME                      721
#define IDC_INFOICON					723
#define IDC_WHITERECT                   725
#define IDC_TEXT_HIDDEN1				726
#define IDC_TEXT_HIDDEN2				727
#define IDC_LEARNMORE					729
#define IDC_RESTARTNOW					730
#define IDC_RESTARTLATER				731
#define IDC_WELCOME_CONTINUE			732
#define IDC_WELCOME_NOTE				733
#define IDC_WELCOME_EULA				734
#define IDC_WELCOME_PRIVACY				735
#define IDC_SUMMARY_NOTE				736
#define IDC_SIDEBAR						737
#define IDC_BOTTOMLINE					738
#define IDC_GRPBOX						739

#define IDI_AUSYSTRAYICON				740	

//#ifdef _CWU
//#define IDC_CMB_DAYS                    1000
//#define IDC_CMB_HOURS                   1001
//#define IDC_CHK_KEEPUPTODATE			1002
#define IDC_STAT_LEARNAUTOUPDATE		2003
#define IDC_AT							2004
#define IDC_STAT_COUNTER                2005
#define IDC_PROG_TIME                   2006
//#endif
/////////////////////////////////////////////////
// Other Resource identifiers
/////////////////////////////////////////////////

/*
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           126
#endif
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\wrkthread.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	 wrkthread.cpp
//
//  Creator: PeterWi
//
//  Purpose: Worker thread.
//
//=======================================================================

#include "pch.h"
#pragma hdrstop

const CLSID CLSID_CV3 = {0xCEBC955E,0x58AF,0x11D2,{0xA3,0x0A,0x00,0xA0,0xC9,0x03,0x49,0x2B}};

HANDLE CClientWrkThread::m_hEvtInstallDone = NULL;

//=======================================================================
//
// CClientWrkThread::~CClientWrkThread
//
// Destructor
//
//=======================================================================

CClientWrkThread::~CClientWrkThread()
{
	SafeCloseHandleNULL(m_hEvtDirectiveStart);
	SafeCloseHandleNULL(m_hEvtDirectiveDone);
	SafeCloseHandleNULL(m_hEvtInstallDone);
	SafeCloseHandleNULL(m_hWrkThread);
}

void CClientWrkThread::m_Terminate()
{
	if (NULL != m_hWrkThread)
	{
		m_DoDirective(enWrkThreadTerminate);
		WaitForSingleObject(m_hWrkThread, INFINITE);
	}
}

//=======================================================================
//
// CClientWrkThread::m_WorkerThread
//
// Client worker thread that does long duration activities.
//
//=======================================================================

DWORD WINAPI CClientWrkThread::m_WorkerThread(void * lpParameter)
{
//	HRESULT hr;
	CClientWrkThread * pWrkThread = (CClientWrkThread *)lpParameter;
	DWORD dwRet = 0;

	DEBUGMSG("WUAUCLT: Installation worker thread starting");

	if ( FAILED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)) )
	{
	       DEBUGMSG("m_WorkerThread() fails to initialize COM");
		return 1;
	}

	SetEvent(pWrkThread->m_hEvtDirectiveDone);

	DEBUGMSG("WUAUCLT: Installation worker thread waiting for directive");

	// wait for directive or termination of client.
	do
	{
		if ( SUCCEEDED(pWrkThread->m_WaitForDirective()) )
		{
			switch ( pWrkThread->m_enDirective )
			{
			case enWrkThreadInstall:
			case enWrkThreadAutoInstall:
			        {
        			      DEBUGMSG("m_WorkerThread() doing install");
			            HRESULT hr = gpClientCatalog->InstallItems(enWrkThreadAutoInstall == pWrkThread->m_enDirective);
			            SetEvent(m_hEvtInstallDone);
			            if (S_OK != hr)
			                {
			                    //install failed or nothing to install
			                    QUITAUClient();
			                    goto done;
			                }
        				break;
        			    }

			case enWrkThreadTerminate:
			       DEBUGMSG("m_WorkerThread() terminating");
				goto done;
				break;

			default:
				DEBUGMSG("ClientWrkThread: bad directive %d", pWrkThread->m_enDirective);
				break;
			}
		}
		else
		{
			dwRet = 1; // FAIL //fixcode: nobody look at this
			QUITAUClient();
			goto done;
		}
	} while (1);

done:
	DEBUGMSG("WUAUCLT CClientWrkThread::m_WorkerThread releasing");

	CoUninitialize();

	DEBUGMSG("WUAUCLT: Worker thread ended, ret = %lu", dwRet);

	return dwRet;
}

//=======================================================================
//
// CClientWrkThread::m_Init
//
// Init routine to do things that can fail.
//
//=======================================================================

HRESULT CClientWrkThread::m_Init(void)
{
	DWORD dwID;

	if ( (NULL == (m_hEvtDirectiveStart = CreateEvent(NULL,	FALSE, FALSE, NULL)))
	  || (NULL == (m_hEvtDirectiveDone = CreateEvent(NULL,	FALSE, FALSE, NULL)))
	  || (NULL == (m_hEvtInstallDone = CreateEvent(NULL,  FALSE, FALSE, NULL)))
	  || (NULL == (m_hWrkThread = CreateThread(NULL,
												 0,
												 (LPTHREAD_START_ROUTINE)CClientWrkThread::m_WorkerThread,
												 (LPVOID)this /*m_pCatalog*/,
												 0,
												 &dwID))))
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	CONST HANDLE grHandles[] = { m_hEvtDirectiveDone, m_hWrkThread };
	DWORD dwRet = WaitForMultipleObjects(ARRAYSIZE(grHandles), grHandles, FALSE, INFINITE);

	// thread only returns on failure
	if ( (WAIT_OBJECT_0 + 1) == dwRet )
	{
		return E_FAIL;
	}
	else if (WAIT_FAILED == dwRet)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

//=======================================================================
//
// ClientWrkThread::m_WaitForDirective
//
// Routine that worker thread waits with for a new directive.
//
//=======================================================================

HRESULT CClientWrkThread::m_WaitForDirective(void)
{
	DWORD dwRet = WaitForSingleObject(m_hEvtDirectiveStart, INFINITE);

	return (WAIT_OBJECT_0 == dwRet) ? S_OK : E_FAIL;
}

//=======================================================================
//
// ClientWrkThread::m_DoDirective
//
// Method to tell thread to start doing directive.
//
//=======================================================================

void CClientWrkThread::m_DoDirective(enumWrkThreadDirective enDirective)
{
	m_enDirective = enDirective;
	SetEvent(m_hEvtDirectiveStart);
}


/////////////////////////////////////////////////////////////////////////////////////////////
// wait until installation is done
////////////////////////////////////////////////////////////////////////////////////////////
void CClientWrkThread::WaitUntilDone()
{
    WaitForSingleObject(m_hEvtInstallDone, INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\trayicon.cpp ===
#include "pch.h"
#pragma hdrstop


BOOL fTrayIconShowing;
TCHAR downloadFormatString[64];
TCHAR pauseString[64];


BOOL MyShell_NotifyIcon(DWORD dwMessage, PNOTIFYICONDATA pnid)
{

//       DEBUGMSG("MyShell_NotifyIcon() called with msg %d", dwMessage);
	BOOL fRet;

	if (NIM_SETVERSION == dwMessage)
		{
		return Shell_NotifyIcon(dwMessage, pnid);
		}
	UINT uRetry = 0;
	//retry 3 times due to the way Shell_NotifyIcon is implemented
	while ( !(fRet = Shell_NotifyIcon(dwMessage, pnid)) && uRetry++ < 3)
		{
		   if (WAIT_TIMEOUT != MsgWaitForMultipleObjectsEx(0,NULL, 2000, QS_POSTMESSAGE, MWMO_INPUTAVAILABLE))
		   	{
		   	break;
		   	}
		   	
		}
	return fRet;
}
   
void InitTrayIcon()
{
	fTrayIconShowing = FALSE;

	TCHAR PauseMenuString[30];
	TCHAR ResumeMenuString[30];

	LoadString(ghInstance, IDS_PAUSEMENUITEM, PauseMenuString, ARRAYSIZE(PauseMenuString));
	LoadString(ghInstance, IDS_RESUMEMENUITEM, ResumeMenuString, ARRAYSIZE(ResumeMenuString));
	
	ghPauseMenu = CreatePopupMenu();
	AppendMenu(ghPauseMenu, MF_STRING, IDC_PAUSE, PauseMenuString);	
	ghResumeMenu = CreatePopupMenu();
	AppendMenu(ghResumeMenu, MF_STRING, IDC_RESUME, ResumeMenuString);	

	LoadString(ghInstance, IDS_DOWNLOADINGFORMAT, downloadFormatString, ARRAYSIZE(downloadFormatString));
	LoadString(ghInstance, IDS_SUSPENDEDFORMAT, pauseString, ARRAYSIZE(pauseString));
}

void UninitPopupMenus()
{
	if (NULL != ghPauseMenu)
	{
		DestroyMenu(ghPauseMenu);
	}
	if (NULL != ghResumeMenu)
	{
		DestroyMenu(ghResumeMenu);
	}
}

BOOL ShowTrayIcon()
{
    DEBUGMSG("ShowTrayIcon() called");

	if ( fTrayIconShowing) 
	{
		return TRUE;
	}

	NOTIFYICONDATA nid;
	memset(&nid, 0, sizeof(nid));
	nid.cbSize = sizeof(nid);
	nid.hWnd = ghMainWindow;
	nid.uID = (UINT) IDI_AUICON;
	nid.uFlags = NIF_ICON | NIF_MESSAGE;
	nid.uCallbackMessage = AUMSG_TRAYCALLBACK;
	nid.hIcon = ghTrayIcon;
	BOOL fRet = MyShell_NotifyIcon(NIM_ADD, &nid);

	if(!fRet)
	{
		// If for any reason, we are not able to use the tray icon, something is wrong
		// ask WUAUSERV wait for sometime before relaunch WUAUCLT. 
		DEBUGMSG("WUAUCLT quit because fail to add tray icon");
		SetClientExitCode(CDWWUAUCLT_RELAUNCHLATER);
		QUITAUClient();
	}
	else
	{
		fTrayIconShowing = TRUE;
	}
	return fRet;
}

void ShowTrayBalloon(WORD title, WORD caption, WORD tip )
{
       DEBUGMSG("ShowTrayBalloon() called");

	static NOTIFYICONDATA nid;
    
	memset(&nid, 0, sizeof(nid));
	nid.uTimeout = 15000;

    LoadString(ghInstance, title, nid.szInfoTitle, ARRAYSIZE(nid.szInfoTitle));
	LoadString(ghInstance, caption, nid.szInfo, ARRAYSIZE(nid.szInfo));
	LoadString(ghInstance, tip, nid.szTip, ARRAYSIZE(nid.szTip));
	nid.uFlags = NIF_INFO | NIF_TIP;
	nid.cbSize = sizeof(nid);
	nid.hWnd = ghMainWindow;
	nid.uID = (UINT) IDI_AUICON;
    nid.dwInfoFlags = NIIF_INFO;

	BOOL fRet = MyShell_NotifyIcon(NIM_MODIFY, &nid);
    if (!fRet)
    {
        DEBUGMSG("WUAUCLT Creation of tray balloon failed");
    }

#ifdef DBG
	DebugCheckForAutoPilot(ghMainWindow);
#endif
}


/*
void AddTrayToolTip(WORD tip)
{
	static NOTIFYICONDATA nid;
    
	memset(&nid, 0, sizeof(nid));
	LoadString(ghInstance, tip, nid.szTip, ARRAYSIZE(nid.szTip));
	nid.uFlags = NIF_TIP;
	nid.cbSize = sizeof(nid);
	nid.hWnd = ghMainWindow;
	nid.uID = (UINT) IDI_AUICON;
	MyShell_NotifyIcon(NIM_MODIFY, &nid);
}
*/

void RemoveTrayIcon()
{
	DEBUGMSG("RemoveTrayIcon() called");
	if (fTrayIconShowing)
	{
		NOTIFYICONDATA nid;
		memset(&nid, 0, sizeof(nid));
		nid.cbSize = sizeof(nid);
		nid.hWnd = ghMainWindow;
		nid.uID = (UINT) IDI_AUICON;
		MyShell_NotifyIcon(NIM_DELETE, &nid);

		// Don't leave any popup menu around when removing tray icon.
		if (SendMessage(ghMainWindow, WM_CANCELMODE, 0, 0))
		{
			DEBUGMSG("WUAUCLT WM_CANCELMODE was not handled");
		}

		fTrayIconShowing = FALSE;
	}
}

//fixcode: when download complete, should call ShowProgress() to update trayicon info
void ShowProgress()
{
	NOTIFYICONDATA nid;
	UINT percentComplete;
	DWORD status;

    //DEBUGMSG("ShowProgress() called");
    memset(&nid, 0, sizeof(nid));

	if (FAILED(gInternals->m_getDownloadStatus(&percentComplete, &status)))
	{
		QUITAUClient();
		return;
	}
	nid.cbSize = sizeof(nid);
	nid.hWnd = ghMainWindow;
	nid.uID = (UINT) IDI_AUICON;
	nid.uFlags = NIF_TIP;
	
	if(status == DWNLDSTATUS_DOWNLOADING) 
	{
		(void)StringCchPrintfEx(nid.szTip, ARRAYSIZE(nid.szTip), NULL, NULL, MISTSAFE_STRING_FLAGS, downloadFormatString, percentComplete);
	}
	else if(status == DWNLDSTATUS_PAUSED)
	{
		(void)StringCchCopyEx(nid.szTip, ARRAYSIZE(nid.szTip), pauseString, NULL, NULL, MISTSAFE_STRING_FLAGS);
	}
	else
	{
	    (void)StringCchCopyEx(nid.szTip, ARRAYSIZE(nid.szTip), _T(""), NULL, NULL, MISTSAFE_STRING_FLAGS);
	}
	MyShell_NotifyIcon(NIM_MODIFY, &nid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\settingsdlg.cpp ===
#include "pch.h"
#include "link.h"

#pragma hdrstop

#define	AU_ITEMS			TEXT("AutoUpdateItems")

void EnableRestoreControls(HWND hWnd, BOOL fEnable)
{
	EnableWindow(GetDlgItem(hWnd, IDC_RESTOREHIDDEN), fEnable);
	EnableWindow(GetDlgItem(hWnd, IDC_TEXT_HIDDEN1), fEnable);				
	EnableWindow(GetDlgItem(hWnd, IDC_TEXT_HIDDEN2), fEnable);				
}
					
CSysLink g_SettingsAutoUpdatelink;
CSysLink g_SettingsScheduledInstalllink;

BOOL EnableCombo(HWND hwnd, BOOL bState);
BOOL EnableOptions(HWND hwnd, BOOL bState);
//BOOL FillDaysCombo(HWND hwnd, DWORD dwSchedInstallDay);
//BOOL FillHrsCombo(HWND hwnd, DWORD dwSchedInstallTime);
void OnKeepUptoDate(HWND hwnd);
void MYREInit(HWND hDlg, UINT uId, HFONT hFont);
void LaunchLinkAction(HWND hwnd, UINT uCtrlId);
#ifdef TESTUI
#if 0
void SetServiceOption(
	DWORD dwOption,
	DWORD dwDay,
	DWORD dwTime
);
void GetServiceOption(
	LPDWORD lpdwOption,
	LPDWORD lpdwDay,
	LPDWORD lpdwTime
);
#endif
#endif

void GetDayAndTimeFromUI( 
	HWND hWnd,
	LPDWORD lpdwDay,
	LPDWORD lpdwTime
);

BOOL CALLBACK _DlgRestoreProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
		case WM_INITDIALOG:
			{
				HWND hwndOwner; 
				RECT rc, rcDlg, rcOwner; 
				// Get the owner window and dialog box rectangles. 
 
				if ((hwndOwner = GetParent(hwnd)) == NULL) 
				{
					hwndOwner = GetDesktopWindow(); 
				}

				GetWindowRect(hwndOwner, &rcOwner); 
				GetWindowRect(hwnd, &rcDlg); 
				CopyRect(&rc, &rcOwner); 

				 // Offset the owner and dialog box rectangles so that 
				 // right and bottom values represent the width and 
				 // height, and then offset the owner again to discard 
				 // space taken up by the dialog box. 
				OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top); 
				OffsetRect(&rc, -rc.left, -rc.top); 
				OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom); 

				 // The new position is the sum of half the remaining 
				 // space and the owner's original position. 
				SetWindowPos(hwnd, 
					HWND_TOP, 
					rcOwner.left + (rc.right / 2), 
					rcOwner.top + (rc.bottom / 2), 
					0, 0,          // ignores size arguments 
					SWP_NOSIZE); 
			}
			return TRUE;

		case WM_COMMAND:	
			switch(LOWORD(wParam))
			{
			case IDOK:
				EndDialog(hwnd, TRUE);
				return TRUE;

			case IDCANCEL:
				EndDialog(hwnd, FALSE);
				return TRUE;
			}
	}
	return FALSE;
}

LONG SetSettingsColors(HDC hdc, HWND control)
{
	SetBkMode(hdc, TRANSPARENT);
	return PtrToLong(GetStockObject( HOLLOW_BRUSH ));
}

BOOL CALLBACK SettingsDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	static HWND oldCurrentDialog;
//	DWORD dwOption = AUOPTION_INSTALLONLY_NOTIFY;
//	DWORD dwScheduledInstallDay = -1;
//	DWORD dwScheduledInstallTime = -1;
	AUOPTION auopt;
	auopt.dwOption = AUOPTION_INSTALLONLY_NOTIFY;
	auopt.dwSchedInstallDay = -1;
	auopt.dwSchedInstallTime = -1;

	switch(message)
	{
		case WM_INITDIALOG:
			{
			oldCurrentDialog = ghCurrentDialog;
			ghCurrentDialog = hWnd;
			gTopWins.Add(hWnd);
  			EnableCombo(hWnd, FALSE); //Initially disabled
#ifndef TESTUI
			if (FAILED(gInternals->m_getServiceOption(&auopt)))
				{
				QUITAUClient();
				return TRUE;
				}
#else
#endif

			g_SettingsAutoUpdatelink.SetSysLinkInstanceHandle(ghInstance);
			g_SettingsAutoUpdatelink.SubClassWindow(GetDlgItem(hWnd,IDC_STAT_LEARNAUTOUPDATE));
			g_SettingsAutoUpdatelink.SetHyperLink(gtszAUOverviewUrl);
			g_SettingsAutoUpdatelink.Invalidate();

			g_SettingsScheduledInstalllink.SetSysLinkInstanceHandle(ghInstance);
			g_SettingsScheduledInstalllink.SubClassWindow(GetDlgItem(hWnd,IDC_LEARNMORE));
			g_SettingsScheduledInstalllink.SetHyperLink(gtszAUSchedInstallUrl);
			g_SettingsScheduledInstalllink.Invalidate();

			switch(auopt.dwOption)
			{
				case AUOPTION_AUTOUPDATE_DISABLE:
					CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_UNCHECKED);
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					EnableOptions( hWnd, FALSE );
					break;

				case AUOPTION_PREDOWNLOAD_NOTIFY:
					CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
					EnableOptions( hWnd, TRUE );
					break;

				case AUOPTION_INSTALLONLY_NOTIFY:
					CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					EnableOptions( hWnd, TRUE );
					break;

				case AUOPTION_SCHEDULED:
					CheckDlgButton( hWnd, IDC_CHK_KEEPUPTODATE, BST_CHECKED);
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
					EnableOptions( hWnd, TRUE );
					break;
			}

//			HFONT hFont = (HFONT) SendMessage(hWnd , WM_GETFONT, 0, 0);
//			MYREInit(hWnd, IDC_STAT_LEARNAUTOUPDATE, hFont);
//			MYREInit(hWnd, IDC_LEARNMORE, hFont);
			FillDaysCombo(ghInstance, hWnd, auopt.dwSchedInstallDay, IDS_STR_EVERYDAY, IDS_STR_SATURDAY );
			FillHrsCombo( hWnd, auopt.dwSchedInstallTime );
				
#ifndef TESTUI
			EnableRestoreControls(hWnd, FHiddenItemsExist());
			if (auopt.fDomainPolicy)
			{
				DisableUserInput(hWnd);
			}
#else
			EnableRestoreControls(hWnd, TRUE);
#endif
			SetFocus(GetDlgItem(hWnd,IDC_OK));
			return TRUE;
			}

		case WM_COMMAND:	
			switch(LOWORD(wParam))
			{
				case IDC_OK:
					if(IsDlgButtonChecked(hWnd, IDC_CHK_KEEPUPTODATE) == BST_UNCHECKED)
					{
                                          auopt.dwOption = AUOPTION_AUTOUPDATE_DISABLE;
						QUITAUClient();
						EndDialog(GetParent(hWnd), S_OK);
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION1) == BST_CHECKED)
					{
                                          auopt.dwOption = AUOPTION_PREDOWNLOAD_NOTIFY;
					}
					else if(IsDlgButtonChecked(hWnd, IDC_OPTION2) == BST_CHECKED)
					{
                                          auopt.dwOption = AUOPTION_INSTALLONLY_NOTIFY;
					}
					else //if(IsDlgButtonChecked(hWnd, IDC_OPTION3) == BST_CHECKED)
					{
						GetDayAndTimeFromUI( hWnd, &(auopt.dwSchedInstallDay), &(auopt.dwSchedInstallTime));
						auopt.dwOption = AUOPTION_SCHEDULED;
						EnableCombo( hWnd, TRUE );
					}
#ifndef TESTUI					
        				gInternals->m_setServiceOption(auopt);
#else
//					SetServiceOption(auopt.dwOption, auopt.dwScheduledInstallDay, auopt.dwScheduledInstallTime);
#endif
					EndDialog(hWnd, S_OK);
					return 0;

				case IDC_OPTION1:
					EnableCombo( hWnd, FALSE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
					return 0;
				case IDC_OPTION2:
					EnableCombo( hWnd, FALSE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
					return 0;
				case IDC_OPTION3:
					EnableCombo( hWnd, TRUE );
					CheckRadioButton(hWnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
					return 0;
				case IDC_CHK_KEEPUPTODATE:
					if( BN_CLICKED == HIWORD(wParam) )
					{
						OnKeepUptoDate( hWnd );
					}
					return 0;

				case IDC_RESTOREHIDDEN:
					{
						extern HINSTANCE ghInstance;
						INT Result = (INT)DialogBoxParam(ghInstance, 
								MAKEINTRESOURCE(IDD_RESTOREUPDATE), 
								hWnd, 
								(DLGPROC)_DlgRestoreProc, 
							(LPARAM)NULL);
						if (Result == TRUE)
						{
#ifndef TESTUI
							if (RemoveHiddenItems())
							{
								EnableRestoreControls(hWnd, FALSE);
							}	
#else
							MessageBoxW(NULL,L"Said Yes",NULL,MB_OK);
							EnableRestoreControls(hWnd, FALSE);
#endif
						}
					}
					return 0;
				case IDCANCEL:
				case IDC_CANCEL:
					EndDialog(hWnd, S_OK);
					return 0;

				default:
					return FALSE;
			}
		case WM_CLOSE:
			EndDialog(hWnd, S_OK);
			return FALSE;

		case WM_DESTROY:
		       g_SettingsAutoUpdatelink.Uninit();
		       g_SettingsScheduledInstalllink.Uninit();
			ghCurrentDialog = oldCurrentDialog;
			gTopWins.Remove(hWnd);
			return 0;
		
		case WM_CTLCOLORSTATIC:
			{
				if (((HWND)lParam == GetDlgItem(hWnd, IDC_STAT_LEARNAUTOUPDATE)) || ((HWND)lParam == GetDlgItem(hWnd, IDC_LEARNMORE)))
					return SetSettingsColors((HDC)wParam, (HWND)lParam);
			}
/*
		case WM_NOTIFY:
			{
					UINT  uId = (UINT) LOWORD(wParam);
					switch (uId)
					{
						case IDC_LEARNMORE:
						case IDC_STAT_LEARNAUTOUPDATE:
							if (((NMHDR FAR *) lParam)->code == EN_LINK) 
							{
								if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN)  
								{
									LaunchLinkAction(hWnd, uId);							
								}
							}
							break;
						default:
								  break;
					}
			}
			return 0;*/
		default:
			return FALSE;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\wrkthread.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    WrkThread.h
//
//  Creator: PeterWi
//
//  Purpose: Worker thread declarations.
//
//=======================================================================
#pragma once

#include "wuauengi.h"

typedef enum
{
	enWrkThreadInstall,
	enWrkThreadAutoInstall,	
	enWrkThreadTerminate
} enumWrkThreadDirective;

//start another thread in client to install
class CClientWrkThread
{
public:
	CClientWrkThread()
		: m_hEvtDirectiveStart(NULL),
		  m_hEvtDirectiveDone(NULL),
		  m_hWrkThread(NULL)
	{ 
	}
	
	~CClientWrkThread();
	HRESULT m_Init(void);
	void  m_Terminate(void);
	static DWORD WINAPI m_WorkerThread(void * lpParameter);
	static void PingStatus(PUID puid, PingStatusCode enStatusCode, HRESULT hrErr = 0);
	void m_DoDirective(enumWrkThreadDirective enDirective);
	void WaitUntilDone();

private:
	HRESULT m_WaitForDirective(void);
	HANDLE m_hEvtDirectiveStart;
	HANDLE m_hEvtDirectiveDone;
	HANDLE m_hWrkThread;	
	static HANDLE m_hEvtInstallDone;
	enumWrkThreadDirective m_enDirective;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\wuauclt.h ===
#pragma once

#include "auinternals.h"
#include "resource.h"

class AUCLTTopWindows 
{
 public:
        AUCLTTopWindows(): m_uNum(0)
            {
                ZeroMemory(m_hwnds, sizeof(m_hwnds));
             }
        void Add(HWND hwnd) { 
                if (NULL != hwnd)
                    {
                       m_hwnds[m_uNum++] = hwnd;
                    }
            }
        BOOL Remove(HWND hwnd){
            if (NULL == hwnd)
                {
                    return FALSE;
                }
            for (UINT u = 0 ; u < m_uNum; u++)
                {
                    if (hwnd == m_hwnds[u]) 
                        {
                            m_hwnds[u] = m_hwnds[m_uNum-1];
                            m_hwnds[m_uNum-1] = NULL;
                            m_uNum--;
                            return TRUE;
                        }
                }
            return FALSE;
            }
        void Dismiss(void)
            {
	         DEBUGMSG("WUAUCLT dismiss %d dialogs", m_uNum);     
	         UINT uNum = m_uNum; //extra variable needed because m_uNum will change once a dialog is dismissed
	         HWND hwnds[ARRAYSIZE(m_hwnds)];
	         
                for (UINT u = 0; u < uNum; u++)
                    {
                    		hwnds[u] = m_hwnds[u];
                	}
                for (UINT u = 0; u < uNum; u++)
                	{
#ifdef DBG
//			   TCHAR buf[100];
//			   GetWindowText(hwnds[u], buf, 100);
//                    	   DEBUGMSG("Dismiss dialog %S", buf);
#endif                    	   
                        EndDialog(hwnds[u], S_OK);
                    }
                m_uNum = 0;
                ZeroMemory(m_hwnds, sizeof(m_hwnds));
            }
private:
        UINT m_uNum; //number of top wuauclt windows
        HWND m_hwnds[2]; //maximum 2 top windows at the same time
};



#define QUITAUClient() { PostMessage(ghMainWindow, WM_CLOSE, 0, 0); }

// Global Data Items
extern CAUInternals*	gInternals;	
extern UINT guExitProcess;
extern CRITICAL_SECTION gcsClient; 
extern LPCTSTR gtszAUSchedInstallUrl;
extern LPCTSTR gtszAUPrivacyUrl;


// Global UI Items
extern HINSTANCE	ghInstance;
extern HFONT		ghHeaderFont;
extern HWND			ghMainWindow;
extern HWND			ghCurrentDialog;
extern HWND			ghCurrentMainDlg;
extern AUCLTTopWindows	gTopWins;
extern HMENU		ghCurrentMenu;
extern HMENU		ghPauseMenu;
extern HMENU		ghResumeMenu;
extern HICON		ghAppIcon;
extern HICON		ghAppSmIcon;
extern HICON		ghTrayIcon;
extern HHOOK		ghHook;
extern HACCEL		ghCurrentAccel;
extern HCURSOR ghCursorHand;
extern HCURSOR ghCursorNormal;
//extern AUCatalogItemList gItemList;



struct ReminderItem
{
	DWORD timeout;
	WORD stringResId;
};

//IMPORTANT: Change constants below if you change ReminderItems constant
extern const ReminderItem ReminderTimes[];

typedef enum tagTIMEOUTINDEX
{
	TIMEOUT_INX_MIN			= 0,
	TIMEOUT_INX_THIRTY_MINS = 0,
	TIMEOUT_INX_ONE_HOUR	= 1,
	TIMEOUT_INX_TWO_HOURS	= 2,
	TIMEOUT_INX_FOUR_HOURS	= 3,
	TIMEOUT_INX_TOMORROW	= 4,
	TIMEOUT_INX_THREE_DAYS	= 5,
	TIMEOUT_INX_COUNT		= 6
} TIMEOUTINDEX;

extern LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);	
extern void InitTrayIcon();
extern void UninitPopupMenus();
extern BOOL ShowTrayIcon();
extern void ShowTrayBalloon(WORD, WORD, WORD );
//extern void AddTrayToolTip(WORD tip);
extern void RemoveTrayIcon();
extern void ShowProgress();
extern void QuitNRemind(TIMEOUTINDEX enTimeoutIndex);
extern LPTSTR ResStrFromId(UINT uStrId);
extern UINT ControlId2StringId(UINT uCtrlId);

extern LRESULT CALLBACK AUTranslatorProc(int code, WPARAM wParam, LPARAM lParam);
extern BOOL CALLBACK InstallDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK SummaryDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK DetailsDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK ProgressDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK SettingsDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK InstallCompleteDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK RestartDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK WizardFrameProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK WelcomeDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK NotificationOptionsDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK SetupCompleteDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK DownloadDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK ReminderDlgProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL CALLBACK SetupCancelDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
inline void ShowSettingsDlg(HWND hWndOwner)
{
	DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_SETTINGS), hWndOwner, (DLGPROC)SettingsDlgProc, (LPARAM)ghInstance);
}

void	SetClientExitCode(UINT uExitCode);
inline UINT   GetClientExitCode()
{
	return guExitProcess;
}

extern LRESULT CALLBACK CustomLBWndProc(HWND, UINT, WPARAM, LPARAM);
extern BOOL fDisableSelection(void);
//extern void SaveSelection();

//Index for the events in main loop
const ISTATE_CHANGE		= 0;
const IMESSAGE			= 1;
const CNUM_EVENTS		= 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauclt\wuauclt.cpp ===
#include "pch.h"
#pragma hdrstop

#define MAINWINDOW_CURSOR   IDC_ARROW
#define RESOURCE_STRING_MAX_LENGTH      100

TCHAR AU_WINDOW_CLASS_NAME[] =  _T("Auto Update Client Window");
const TCHAR gtszAUW2KPrivacyUrl[]= _T("..\\help\\wuauhelp.chm::/w2k_autoupdate_privacy.htm");
const TCHAR gtszAUXPPrivacyUrl[]= _T("..\\help\\wuauhelp.chm::/autoupdate_privacy.htm");

const ReminderItem ReminderTimes[TIMEOUT_INX_COUNT] = 
{ 
    { 1800, IDS_THIRTY_MINUTES },
    { 3600, IDS_ONE_HOUR },
    { 7200, IDS_TWO_HOURS },
    { 14400, IDS_FOUR_HOURS },
    { 86400, IDS_TOMORROW },
    { 259200, IDS_THREE_DAYS }
};

const UINT RESOURCESTRINGINDEX[] = {
    IDS_NOTE,
    IDS_WELCOME_CONTINUE,
    IDS_EULA,
    IDS_PRIVACY,
    IDS_LEARNMORE,
    IDS_LEARNMOREAUTO
};


// Global Data Items
CAUInternals*   gInternals; 
AUClientCatalog *gpClientCatalog ; //= NULL
TCHAR gResStrings[ARRAYSIZE(RESOURCESTRINGINDEX)][RESOURCE_STRING_MAX_LENGTH]; 
// Global UI Items
CRITICAL_SECTION gcsClient; // guard guard user's tray interaction (showing, not showing) and guard customlb data
HINSTANCE   ghInstance;
HFONT       ghHeaderFont;
HCURSOR     ghCursorHand;
HCURSOR     ghCursorNormal; // cursor of main window

HMODULE     ghRichEd20;
HANDLE      ghEngineState;
HWND        ghMainWindow;
HWND        ghCurrentDialog;
HWND        ghCurrentMainDlg;
AUCLTTopWindows gTopWins;
UINT        gNextDialogMsg;
BOOL        gbOnlySession; // = FALSE;
BOOL             gfShowingInstallWarning; // = FALSE;

HMENU       ghPauseMenu;
HMENU       ghResumeMenu;
HMENU       ghCurrentMenu;
HICON       ghAppIcon;
HICON       ghAppSmIcon;
HICON       ghTrayIcon;
UINT        guExitProcess=CDWWUAUCLT_UNSPECIFY;

LPCTSTR      gtszAUSchedInstallUrl;
LPCTSTR      gtszAUPrivacyUrl;

AU_ENV_VARS gAUEnvVars;

HANDLE g_hClientNotifyEvt = NULL; //the event Engine use to notify client
HANDLE g_hRegisterWait = NULL;
BOOL g_fCoInit = FALSE;
BOOL g_fcsInit = FALSE;

/****
Helper function to simplify window class registration.
*****/
ATOM AURegisterWindowClass(WNDPROC lpWndProc, LPTSTR lpClassName)
{
    WNDCLASSEX wcex;

    ZeroMemory(&wcex, sizeof(wcex));
    
    wcex.cbSize = sizeof(WNDCLASSEX); 
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = (WNDPROC)lpWndProc;
//    wcex.cbClsExtra     = 0;
//    wcex.cbWndExtra     = 0;
//    wcex.lpszMenuName   = NULL;
//    wcex.hIcon          = NULL; 
//    wcex.hIconSm        = NULL; 
    wcex.hInstance      = ghInstance;
    wcex.hCursor        = LoadCursor(NULL, MAINWINDOW_CURSOR);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszClassName  = lpClassName;

    return RegisterClassEx(&wcex);
}


///////////////////////////////////////////////////////////////////
// map string id to its storage in the gResStrings
///////////////////////////////////////////////////////////////////
LPTSTR ResStrFromId(UINT uStrId)
{
    for (int i = 0; i < ARRAYSIZE(RESOURCESTRINGINDEX); i++)
    {
        if (RESOURCESTRINGINDEX[i] == uStrId)
        {
            return gResStrings[i];
        }
    }
    return NULL;
}

////////////////////////////////////////////////////////
//  Set reminder timeout and state and quit
////////////////////////////////////////////////////////
void QuitNRemind(TIMEOUTINDEX enTimeoutIndex)
{
    AUSTATE     auState;
    if (FAILED(gInternals->m_getServiceState(&auState)))
    {
        goto done;
    }
    if (FAILED(gInternals->m_setReminderTimeout(enTimeoutIndex)))
    {
        goto done;
    }
    gInternals->m_setReminderState(auState.dwState);
done:
    QUITAUClient();
}



////////////////////////////////////////////////////////////////////////////
//
// Helper Function  HrQuerySessionConnectState(int iAdminSession, int *piConState)
//          helper function to get the Session Connection State
//
// Input:   int iAdminSession   Session Admin ID
// Output:  int *piConState     Conection state
// Return:  HRESULT value. If Failed, *piConState is unspecified
////////////////////////////////////////////////////////////////////////////
HRESULT HrQuerySessionConnectState(int iAdminSession, int *piConState)
{
    LPTSTR  pBuffer = NULL;             
    HRESULT hr = NO_ERROR;
    DWORD dwBytes;

    if (AUIsTSRunning())
    {
        
        if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, iAdminSession, WTSConnectState, 
            &pBuffer, &dwBytes))
        {
            *piConState = (int) *pBuffer;   //Because we are asking for WTSConnectState, pBuffer points to an int
            WTSFreeMemory(pBuffer);
            hr = NO_ERROR;
        }
        else
        {
            DEBUGMSG("WUAUCLT: WTSQuerySessionInformation failed: %lu", GetLastError());
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else 
    {
        DWORD dwSession = iAdminSession;
        
        if (dwSession == WTS_CURRENT_SESSION)
            ProcessIdToSessionId(GetCurrentProcessId(), &dwSession);
        
        // if we're launched & TS is not up, we've gotta be an active session.
        if (dwSession == 0)
        {
            DEBUGMSG("WUAUCLT: TS is not running or not installed.  Assuming session 0 is active.");
            gbOnlySession = TRUE;
            *piConState = WTSActive;
        }
        else
        {
            DEBUGMSG("WUAUCLT: TS is not running or not installed, but a non 0 session was asked for (session %d).  Failing call.", iAdminSession);
            hr = E_FAIL;
        }
    }
    
    return hr;
}
BOOL FCurrentSessionInActive()
{
    BOOL fRet = FALSE;
    HRESULT hr;
    int iConState;

    if (gbOnlySession)
    {
           DEBUGMSG("FCurrentSessionInActive() Only one session");
        goto Done;
    }
        
    //Check if the Current Session is Inactive
    hr = HrQuerySessionConnectState(WTS_CURRENT_SESSION, &iConState);

    if (SUCCEEDED(hr))
    {
        fRet = (WTSDisconnected == iConState);
    }
    else
    {
        if (RPC_S_INVALID_BINDING == GetLastError()) //Terminal Services are disabled, this is session 0
        {
            DEBUGMSG("FCurrentSessionInActive() TS disabled");
            gbOnlySession = TRUE;
        }
        else
        {       
            DEBUGMSG("FCurrentSessionInActive() HrQuerySessionConnectState failed %#lx =",hr);
        }
    }
Done:
//       DEBUGMSG("FCurrentSessionInActive() return %s", fRet ? "TRUE" : "FALSE");
    return fRet;
}


//////////////////////////////////////////////////////////////////////////////
// BuildClientCatalog
//
// Do online detection of the catalog and build up the wuv3is.dll detection state
// inside this process.  Validation is done during this process with the catalog file
// previously written by the engine.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT BuildClientCatalog(void)
{
    HRESULT hr = S_OK;

    DEBUGMSG("BuildClientCatalog() starts");
    if ( NULL == gpClientCatalog )
    {
        gpClientCatalog = new AUClientCatalog();
        if ( NULL != gpClientCatalog )
        {
            if ( FAILED(hr = gpClientCatalog->Init()) )
            {
                goto done;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    // change to: hr = gpClientCatalog->LoadInstallXML();

done:
       DEBUGMSG("BuildClientCatalog() ends");
    return hr;
}

void DismissUIIfAny()
{
    gTopWins.Add(ghCurrentMainDlg);
    gTopWins.Dismiss();

	// Don't leave any popup menu around when dismissing dialogs.
	if (SendMessage(ghMainWindow, WM_CANCELMODE, 0, 0))
	{
		DEBUGMSG("WUAUCLT WM_CANCELMODE was not handled");
	}
}


void ResetAUClient(void)
{
    DismissUIIfAny();
    RemoveTrayIcon();
    gfShowingInstallWarning = FALSE;
    gNextDialogMsg = NULL;
    ghCurrentMenu = NULL;
}


void ShowInstallWarning()
{ //dismiss current dialog if any
    DEBUGMSG("ShowInstallWarning() starts");
    gfShowingInstallWarning = TRUE;
    gNextDialogMsg = NULL;
    ghCurrentMenu = NULL;
    CPromptUserDlg PromptUserDlg(IDD_START_INSTALL);
	PromptUserDlg.SetInstanceHandle(ghInstance);
    INT iRet = PromptUserDlg.DoModal(NULL);
    DEBUGMSG("WUAUCLT ShowInstallWarning dlg return code is %d", iRet);
    if (IDYES == iRet || AU_IDTIMEOUT == iRet)
    {
        SetClientExitCode(CDWWUAUCLT_INSTALLNOW);
        QUITAUClient();
    }
    else //if (retVal == IDNO)
    {
            gNextDialogMsg = AUMSG_SHOW_INSTALL;
    }
    gfShowingInstallWarning = FALSE;
    DEBUGMSG("ShowInstallWarning() ends");
}

void ShowRebootWarning(BOOL fEnableYes, BOOL fEnableNo)
{
    DEBUGMSG("ShowRebootWarning() starts");
	INT iRet;
    CPromptUserDlg PromptUserDlg(IDD_PROMPT_RESTART, fEnableYes, fEnableNo);

	PromptUserDlg.SetInstanceHandle(ghInstance);
	iRet = PromptUserDlg.DoModal(NULL);
    if (IDYES == iRet)
    {
        SetClientExitCode(CDWWUAUCLT_REBOOTNOW);
    }
	else if (IDNO == iRet)
	{
        SetClientExitCode(CDWWUAUCLT_REBOOTLATER);
    }
	else  //if (IDTIMEOUT == iRet)
	{
		SetClientExitCode(CDWWUAUCLT_REBOOTTIMEOUT);
	}
	
    QUITAUClient();
    DEBUGMSG("ShowRebootWarning() ends with return code %d", iRet);
    DEBUGMSG("ShowRebootWarning() set client exit code to be %d", GetClientExitCode());
}

VOID CALLBACK WaitCallback(PVOID lpParameter,  BOOLEAN /*fTimerOrWaitFired*/ )
{
    // fTimerOrWaitFired is always false - We can't time out with INFINATE wait

	BOOL fRebootWarningMode = (BOOL) PtrToInt(lpParameter);
	if (fRebootWarningMode)
	{
		DEBUGMSG("WUAUCLT got exit signal from engine");
		QUITAUClient();
		return ;
	}
    
    // ClientNotify event was fired
    CLIENT_NOTIFY_DATA notifyData;
    BOOL fCoInit = SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
    
    if ( !fCoInit )
    {
        DEBUGMSG("WUAUCLT WaitCallback CoInitialize failed");
        goto Done;
    }

    IUpdates * pUpdates = NULL;
    HRESULT hr = CoCreateInstance(__uuidof(Updates),
                     NULL,
                     CLSCTX_LOCAL_SERVER,
                     IID_IUpdates,
                     (LPVOID*)&pUpdates);
    if (FAILED(hr))
    {
        DEBUGMSG("WaitCallback failed to get Updates object");
        goto Done;
    }
    if (FAILED(hr = pUpdates->GetNotifyData(&notifyData)))
    {
        DEBUGMSG("WaitCallback fail to get NotifyData %#lx", hr);
        goto Done;
    }
    switch (notifyData.actionCode)
    {
    case NOTIFY_STOP_CLIENT:
    case NOTIFY_RELAUNCH_CLIENT:
        if (NOTIFY_RELAUNCH_CLIENT == notifyData.actionCode)
        {
            DEBUGMSG("WaitCallback() notify client to relaunch");
            SetClientExitCode(CDWWUAUCLT_RELAUNCHNOW);
        }
        else
        {
            DEBUGMSG("WaitCallback() notify client to stop");
            SetClientExitCode(CDWWUAUCLT_OK);
        }
        if (NULL != ghMutex)
        {
            WaitForSingleObject(ghMutex, INFINITE);
            if (NULL != gpClientCatalog)
            {
                gpClientCatalog->CancelNQuit();
            }
            else
            {
                DEBUGMSG("No need to cancel catalag");
            }
            ReleaseMutex(ghMutex);
        }
        QUITAUClient(); 
        break;
    case NOTIFY_RESET: //reprocess state and option and show UI accordingly
        ResetAUClient();
        SetEvent(ghEngineState);
        break;
    case NOTIFY_ADD_TRAYICON:
        DEBUGMSG("WaitCallback()  notify client to show tray icon");
        ShowTrayIcon();
        ghCurrentMenu = ghPauseMenu; //the job is now downloading
        break;
    case NOTIFY_REMOVE_TRAYICON:
        DEBUGMSG("WaitCallback() notify client to remove tray icon");
        RemoveTrayIcon();
        break;
    case NOTIFY_STATE_CHANGE:
        DEBUGMSG("WaitCallback() notify client of state change");
        SetEvent(ghEngineState);
        break;
    case NOTIFY_SHOW_INSTALLWARNING:
        DEBUGMSG("WaitCallback() notify client to show install warning");
        if (!gfShowingInstallWarning)
        { //install warning dialog is not up, prevent install warning dialog torn down before it expires when secsinaday low
            DismissUIIfAny();
            PostMessage(ghMainWindow, AUMSG_SHOW_INSTALLWARNING, 0, 0);
        }
        break;
    }
Done:
    SafeRelease(pUpdates);
    if (fCoInit)
    {
        CoUninitialize();
    }
}

BOOL ProcessEngineState()
{
    AUSTATE AuState;
    BOOL fResult = TRUE;

    DEBUGMSG("WUAUCLT starts ProcessEngineState()");
    ghCurrentMenu = NULL;

    if (FAILED(gInternals->m_getServiceState(&AuState)))
    {
        DEBUGMSG("WUAUCLT : quit because m_getServiceState failed");       
        SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
        fResult = FALSE;
        goto Done;
    }
    
    DEBUGMSG("WUAUCLT process Engine state %lu",AuState.dwState);
    switch(AuState.dwState)
    {
        case AUSTATE_NOT_CONFIGURED:
            if(gNextDialogMsg != AUMSG_SHOW_WELCOME && ghCurrentMainDlg == NULL )
            {
                if (ShowTrayIcon())
                {
                    ShowTrayBalloon(IDS_WELCOMETITLE, IDS_WELCOMECAPTION, IDS_WELCOMETITLE);
                    gNextDialogMsg = AUMSG_SHOW_WELCOME;
                }
            }
            break;
        case AUSTATE_DETECT_COMPLETE:
            if ( FAILED(gInternals->m_getServiceUpdatesList()) )
            {
                DEBUGMSG("WUAUCLT : quit because m_getServiceUpdatesList failed");
                SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
                fResult = FALSE;
                break;
            }

           {
                AUOPTION auopt;

                if (SUCCEEDED(gInternals->m_getServiceOption(&auopt)) && 
                    (AUOPTION_INSTALLONLY_NOTIFY == auopt.dwOption || AUOPTION_SCHEDULED == auopt.dwOption))
                {
                    // user option is auto download, start download
                    //ShowTrayIcon();    
                    
                    // do download right away without dialogs if user options set to notify for just install
                    if (FAILED(gInternals->m_startDownload()))
                    {
                        QUITAUClient();
                    }
                    else
                    {
//                            ghCurrentMenu = ghPauseMenu;
                    }
                    break;
                }
                
                if(gNextDialogMsg != AUMSG_SHOW_DOWNLOAD && ghCurrentMainDlg == NULL)
                {
                    if (ShowTrayIcon())
                    {
                        ShowTrayBalloon(IDS_DOWNLOADTITLE, IDS_DOWNLOADCAPTION, IDS_DOWNLOADTITLE);
                                        gNextDialogMsg = AUMSG_SHOW_DOWNLOAD;
                    }
                }   
                break;                  
            }
            
        case AUSTATE_DOWNLOAD_COMPLETE:
            if (AUCLT_ACTION_AUTOINSTALL == AuState.dwCltAction)
            { // engine initiated install: auto install
                HRESULT hr;
                DEBUGMSG("Auto install ...");
                if ( S_OK !=(hr = BuildClientCatalog()))
                {
                    DEBUGMSG("WUAUCLT fail to build client catalog with error %#lx, exiting, hr");
                    SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
                    fResult = FALSE;
                    break;
                }
                if (FAILED(hr = gInternals->m_startInstall(TRUE)))
                {
                    DEBUGMSG("Fail to post install message with error %#lx", hr);
                    fResult = FALSE;
                    break;
                }
                gpClientCatalog->m_WrkThread.WaitUntilDone();
                if (gpClientCatalog->m_fReboot)
                {
                    SetClientExitCode(CDWWUAUCLT_REBOOTNEEDED);
                }
                else
                {
                    SetClientExitCode(CDWWUAUCLT_OK);
                }
                QUITAUClient();
                break;
            }
            else
            { //show preinstall dialog and let user initiate install
                HRESULT hr;
                DEBUGMSG("Prompt for manual install");
                if ( FAILED(gInternals->m_getServiceUpdatesList()))
                {
                    DEBUGMSG("WUAUCLT : quit because m_getServiceUpdatesList failed");
                    SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
                    fResult = FALSE;
                    break;
                }

           
                if ( S_OK !=(hr = BuildClientCatalog()) )
                {
                    DEBUGMSG("WUAUCLT fail to build client catalog with error %#lx, exiting", hr);
                    SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
                    fResult = FALSE;
                }
                else if(gNextDialogMsg != AUMSG_SHOW_INSTALL && ghCurrentMainDlg == NULL)
                {
                    if (ShowTrayIcon())
                    {
                        ShowTrayBalloon(IDS_INSTALLTITLE, IDS_INSTALLCAPTION, IDS_INSTALLTITLE);
                        gNextDialogMsg = AUMSG_SHOW_INSTALL;
                    }
                }
                break;
            }   
            
        case AUSTATE_DOWNLOAD_PENDING:                  
            {                                       
                UINT nPercentComplete = 0;
                DWORD dwStatus;
                
                //if drizzle got transient error, quit client
                //fixcode: why quit if transient error?
                if (AuState.fDisconnected)
                {
                    DEBUGMSG("WUAUCLT : quit because of lost of connection, fDisconnected = %d",AuState.fDisconnected);
                    fResult = FALSE;        
                    break;
                }
                if (FAILED(gInternals->m_getDownloadStatus(&nPercentComplete, &dwStatus)))
                {
                    DEBUGMSG("WUAUCLT : quit because m_getDownloadStatus failed");
                    fResult = FALSE;
                    break;
                }

                if (DWNLDSTATUS_CHECKING_CONNECTION == dwStatus) 
                {
                    //hide tray icon 
                    DEBUGMSG("WUAUCLT Waiting for engine to find connection first");
//                    RemoveTrayIcon();
//                    ghCurrentMenu = NULL;
                }
                else if(dwStatus == DWNLDSTATUS_DOWNLOADING) 
                {
					ghCurrentMenu = ghPauseMenu;
                    DEBUGMSG("WUAUCLT in active downloading state");
                    ShowTrayIcon();                         
                }
                else if(dwStatus == DWNLDSTATUS_PAUSED)
                {
                    ghCurrentMenu = ghResumeMenu;
                    DEBUGMSG("WUAUCLT in download paused state");
                    if (fDisableSelection() &&
						FAILED(gInternals->m_setDownloadPaused(FALSE)))
                    {
//                        QUITAUClient(); //let wuaueng to figure out problem and recover
                    }
                    ShowTrayIcon();
                }
                else //not downloading
                {
                    DEBUGMSG("WUAUCLT WARNING: not downloading while in download pending state");
                }              
            }
            break;                  
            
        case AUSTATE_DETECT_PENDING:
            //Quit only if the Install UI has been accepted or there is no InstallUI
            if (NULL == ghCurrentMainDlg)
            {                       
                QUITAUClient();
            }
            break;
            
        case AUSTATE_DISABLED:
            QUITAUClient();
            break;

        case AUSTATE_INSTALL_PENDING:
        default:
            // outofbox and waiting_for_reboot are here. WUAUCLT should not be launched in these states
            DEBUGMSG("WUAUCLT AUSTATE = %lu", AuState.dwState);
            break;
    }
Done:
    DEBUGMSG("WUAUCLT exits ProcessEngineState()");
    return fResult; 
}

BOOL InitUIComponents(HINSTANCE hInstance)
{
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = 0;     //We dont need to register any control classes
	if (!InitCommonControlsEx(&icex))  //needed for theming
    {
        DEBUGMSG("InitUIComponents :InitCommonControlsEx failed");
        return FALSE;
    }

	//we need to load riched20.dll to register the class
	ghRichEd20  = LoadLibraryFromSystemDir(_T("RICHED20.dll"));
	if (NULL == ghRichEd20)
	{
	    return FALSE;
	}

	ghCursorHand = LoadCursor(NULL, IDC_HAND);
	ghCursorNormal = LoadCursor(NULL, MAINWINDOW_CURSOR); //change if main window's cursor does
	if (NULL == ghCursorHand)
	{
	  DEBUGMSG("WUAUCLT fail to load hand cursor");
	  ghCursorHand = ghCursorNormal;
	}

	ghAppIcon = (HICON) LoadImage(hInstance, MAKEINTRESOURCE(IDI_AUICON), IMAGE_ICON, NULL, NULL, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
	ghAppSmIcon = (HICON) LoadImage(hInstance, MAKEINTRESOURCE(IDI_AUICON), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_CREATEDIBSECTION);

	if (IsWin2K())
	{
		//Win2k
		ghTrayIcon = (HICON) LoadImage(hInstance, MAKEINTRESOURCE(IDI_AUSYSTRAYICON), IMAGE_ICON, 16, 16, 0);
	}
	else
	{
		//WindowsXP
		ghTrayIcon = (HICON) LoadImage(hInstance, MAKEINTRESOURCE(IDI_AUICON), IMAGE_ICON, 16, 16, LR_CREATEDIBSECTION);
	}
		
	for (int i = 0; i < ARRAYSIZE(RESOURCESTRINGINDEX); i++)
	{
	    LoadString(hInstance, RESOURCESTRINGINDEX[i], ResStrFromId(RESOURCESTRINGINDEX[i]), RESOURCE_STRING_MAX_LENGTH);    
	}

	ghCurrentAccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(IDA_BASE));
	gtszAUSchedInstallUrl = IsWin2K() ? gtszAUW2kSchedInstallUrl : gtszAUXPSchedInstallUrl;
	gtszAUPrivacyUrl = IsWin2K() ? gtszAUW2KPrivacyUrl : gtszAUXPPrivacyUrl;

	return TRUE;
}


BOOL InitializeAUClientForRebootWarning(HINSTANCE hInstance, 
	OUT HANDLE *phRegisterWait, 
	OUT HANDLE *phClientNotifyEvt,
	OUT BOOL *pfCoInit)
{
	TCHAR buf[100];

    SetClientExitCode(CDWWUAUCLT_UNSPECIFY);
	*phRegisterWait = NULL;
	*pfCoInit = FALSE;
	*phClientNotifyEvt = OpenEvent(SYNCHRONIZE, FALSE, gAUEnvVars.m_szClientExitEvtName);
	if (NULL == *phClientNotifyEvt)
	{
		DEBUGMSG("WUAUCLT fail to open client exit event");
		return FALSE;
	}


	INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = 0;     //We dont need to register any control classes
	if (!InitCommonControlsEx(&icex))  //needed for theming
    {
        DEBUGMSG("InitCommonControlsEx failed");
        return FALSE;
    }

	if (!RegisterWaitForSingleObject(phRegisterWait,               // wait handle
        *phClientNotifyEvt, // handle to object
        WaitCallback,                   // timer callback function
        (PVOID)1,                           // callback function parameter
        INFINITE,                       // time-out interval
        WT_EXECUTEONLYONCE               // options
        ))
	{
	    DEBUGMSG("WUAUCLT RegisterWaitForSingleObject failed %lu",GetLastError());
	    *phRegisterWait = NULL;
	    return FALSE;
	}
    ghInstance = hInstance;

	return TRUE;
}

BOOL InitializeAUClient(HINSTANCE hInstance,
     OUT  HANDLE * phRegisterWait,
     OUT  HANDLE * phClientNotifyEvt,
     OUT  BOOL *pfCoInit,
     OUT  BOOL *pfcsInit)
{   
        HRESULT hr;
    *pfcsInit = FALSE;
    *phClientNotifyEvt = NULL;
    *phRegisterWait = NULL;
    SetClientExitCode(CDWWUAUCLT_UNSPECIFY);
    *pfCoInit = SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
    
    if ( !*pfCoInit )
    {
        DEBUGMSG("WUAUCLT WinMain CoInitialize failed");
        return FALSE;
    }

    if (!InitUIComponents(hInstance))
    {
    	DEBUGMSG("WUAUCLT fail to initialize UI components");
    	return FALSE;
    }

    if (NULL == (ghMutex = CreateMutex(NULL, FALSE, NULL)))
    {
        DEBUGMSG("WUAUCLT fail to create global mutex");
        return FALSE;
    }

    
    gInternals = NULL;
    
    if ( (NULL == (ghEngineState = CreateEvent(NULL, FALSE, FALSE, NULL))) )
    {
    	DEBUGMSG("WUAUCLT fails to create event");
        return FALSE;
    }

    ghInstance = hInstance;

    if (!(*pfcsInit = SafeInitializeCriticalSection(&gcsClient)))
    {
    	DEBUGMSG("WUAUCLT fails to initialize critical section");
        return FALSE;
    }

#ifndef TESTUI

    if (! (gInternals = new CAUInternals()))
    {
    	DEBUGMSG("WUAUCLT fails to create auinternals object");
        return FALSE;
    }

    if (FAILED(hr = gInternals->m_Init()))
    {
        DEBUGMSG("WUAUCLT failed in CoCreateInstance of service with error %#lx, exiting", hr);
        return FALSE;
    }           

    AUEVTHANDLES AuEvtHandles;
    ZeroMemory(&AuEvtHandles, sizeof(AuEvtHandles));
    if (FAILED(hr = gInternals->m_getEvtHandles(GetCurrentProcessId(), &AuEvtHandles)))
    {
        DEBUGMSG("WUAUCLT failed in m_getEvtHandles with error %#lx, exiting", hr);
        return FALSE;
    }
	*phClientNotifyEvt = (HANDLE)AuEvtHandles.ulNotifyClient;

    if (!RegisterWaitForSingleObject( phRegisterWait,               // wait handle
        *phClientNotifyEvt, // handle to object
        WaitCallback,                   // timer callback function
        0,                           // callback function parameter
        INFINITE,                       // time-out interval
        WT_EXECUTEDEFAULT               // options
        ))
    {
        DEBUGMSG("WUAUCLT RegisterWaitForSingleObject failed %lu",GetLastError());
        *phRegisterWait = NULL;
        return FALSE;
    }
        
#endif

    return TRUE;
}


void UninitializeAUClient(HANDLE hRegisterWait, HANDLE hClientNotifyEvt, BOOL fCoInit, BOOL fcsInit)
{
	static BOOL fAlreadyUninit = FALSE;

	if (fAlreadyUninit)
	{
		return;
	}
	fAlreadyUninit = TRUE;

    RemoveTrayIcon();
    if (NULL != hRegisterWait)
    {
        if ( !UnregisterWaitEx(hRegisterWait, INVALID_HANDLE_VALUE) )
        {
            DEBUGMSG("WUAUCLT: UnregisterWaitEx() failed, dw = %lu", GetLastError());
        }
    }
    if (NULL != ghRichEd20)
    {
        FreeLibrary(ghRichEd20);
		ghRichEd20 = NULL;
    }
	SafeCloseHandleNULL(hClientNotifyEvt);
	
	if (!gAUEnvVars.m_fRebootWarningMode)
	{
		//fixcode: is ghMainWindow a valid window here?
	    KillTimer(ghMainWindow, 1);
	    if (fcsInit)
	    {
	        DeleteCriticalSection(&gcsClient);
	    }
	    SafeDeleteNULL(gInternals);
	    SafeDeleteNULL(gpClientCatalog);   
	    SafeCloseHandleNULL(ghEngineState);
	    SafeCloseHandleNULL(ghMutex);
	}

    if ( fCoInit)
    {
        CoUninitialize();
    }
}
      	

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE /*hPrevInstance*/,
                     LPSTR     /*lpCmdLine*/,
                     int       /*nCmdShow*/)
{
    HANDLE rhEvents[CNUM_EVENTS];

    //Initialize the global pointing to WU Directory. (the directory should already exist)
    if(!CreateWUDirectory(TRUE))
    {
        //If we can not create WU directory, no point in continuing
        DEBUGMSG("WUAUCLT Fail to create WU directory");
        SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
        goto exit;
    }

	if (!gAUEnvVars.ReadIn())
	{
		DEBUGMSG("WUAUCLT fails to read in environment variables");
		SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
		goto exit;
	}
	
	if (gAUEnvVars.m_fRebootWarningMode)
	{
		DEBUGMSG("WUAUCLT starts in reboot warning mode");
		if (!InitializeAUClientForRebootWarning(hInstance, &g_hRegisterWait, &g_hClientNotifyEvt, &g_fCoInit))
		{
			SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
			goto exit;
		}
	}
	else
	{
		DEBUGMSG("WUAUCLT starts in regular mode");
	    if (!InitializeAUClient(hInstance, &g_hRegisterWait, &g_hClientNotifyEvt, &g_fCoInit, &g_fcsInit))
	    {
	        SetClientExitCode(CDWWUAUCLT_FATAL_ERROR);
	        goto exit;
	    }
	}

    DEBUGMSG("WUAUCLT initialization done");
    // Create the main window hidden
    if (!AURegisterWindowClass(MainWndProc, AU_WINDOW_CLASS_NAME))
    {
        goto exit;
    }
    if (!AURegisterWindowClass(CustomLBWndProc, _T("MYLB")))
    {
        goto exit;
    }
    if (!CreateWindow(AU_WINDOW_CLASS_NAME, AU_WINDOW_CLASS_NAME, WS_CAPTION,
        0, 0, 0, 0, NULL, NULL, hInstance, NULL))
    {
        goto exit;
    }

    ShowWindow(ghMainWindow, SW_HIDE);
    
#ifdef TESTUI
    {
        MSG msg;
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (WM_QUIT == msg.message )
            {
                // Set this event so the service does what every appropriate
                // If we don't do this, we might leave the service waiting for this event for 
                // some cases - for example, when the session in which the client leaves is deactivated or
                // when there is a log off
                //SetEvent(ghEngineState);                  
                goto exit;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);          
        }
    }
#else
    {
    	// Run the main message loop
	    MSG msg;

    	if (gAUEnvVars.m_fRebootWarningMode)
    	{
    		ShowRebootWarning(gAUEnvVars.m_fEnableYes, gAUEnvVars.m_fEnableNo);
    	}
    	else
    	{
	        SetTimer(ghMainWindow, 1, dwTimeToWait(ReminderTimes[TIMEOUT_INX_FOUR_HOURS].timeout), NULL); //every 4 hours

	        DEBUGMSG("WUAUCLT Processing messages and being alert for Engine state change event");

	        rhEvents[ISTATE_CHANGE] = ghEngineState;
	        
	        while (1)
	        {
	            DWORD dwRet = MsgWaitForMultipleObjectsEx(CNUM_EVENTS, rhEvents, INFINITE, QS_ALLINPUT, MWMO_INPUTAVAILABLE);
	            
	            if (WAIT_OBJECT_0 + ISTATE_CHANGE == dwRet)                 //ghEngineState (ISTATE_CHANGE)
	            {
	                DEBUGMSG("WUAUCLT Engine changed state");
	                if (!ProcessEngineState())
	                {
	                    QUITAUClient();
	                }           
	            }
	            else if (WAIT_OBJECT_0 + IMESSAGE == dwRet)     // There is a message to process
	            {
	                while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	                {
	                    if (WM_QUIT == msg.message )
	                    {         
	                        goto exit;
	                    }
	                    TranslateMessage(&msg);
	                    DispatchMessage(&msg);          
	                }
	            }   
	            else 
	            {
	                if (WAIT_ABANDONED_0 == dwRet)      //ghEngineState abandoned       
	                {
	                    DEBUGMSG("WUAUCLT quitting because engine state event was abandoned");          
	                }
	                else if (WAIT_FAILED == dwRet)               //MsgWaitForMultipleObjectsEx failed
	                {                   
	                    DEBUGMSG("WUAUCLT quitting because MsgWaitForMultipleObjectsEx() failed with last error = %lu", GetLastError());
	                }               
	                QUITAUClient();
	            }
	        }
    	}
    }
#endif

exit:
    DEBUGMSG("WUAUCLT Exiting");

    //if installation thread is live, wait until it finishes
    if (NULL != gpClientCatalog)
    {
    	gpClientCatalog->m_WrkThread.m_Terminate();
    }
    UninitializeAUClient(g_hRegisterWait, g_hClientNotifyEvt, g_fCoInit, g_fcsInit);

    if (CDWWUAUCLT_UNSPECIFY == GetClientExitCode())
    {
		SetClientExitCode(CDWWUAUCLT_OK);
    }
    DEBUGMSG("WUAUCLT exit code %d", GetClientExitCode());
    ExitProcess(GetClientExitCode());

    return 0;
}

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    AUSTATE AuState;

    switch(message)
    {
        case WM_CREATE:
        {
            LOGFONT     lFont;

            // initialize global ui variables
            ghMainWindow = hWnd;
            ghCurrentMainDlg = NULL;
            gNextDialogMsg = NULL;
            ghHeaderFont    = NULL;

            InitTrayIcon();

            HFONT hDefUIFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            //create header font
            ZeroMemory(&lFont, sizeof(lFont));
            lFont.lfWeight = FW_BOLD;
            lFont.lfCharSet = DEFAULT_CHARSET;
            lFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
            lFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
            lFont.lfQuality = DEFAULT_QUALITY;
            lFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
            LoadString(ghInstance, IDS_HEADERFONT, lFont.lfFaceName, ARRAYSIZE(lFont.lfFaceName));
            ghHeaderFont = CreateFontIndirect(&lFont);
            if(ghHeaderFont == NULL) {
                DEBUGMSG("WUAUCLT fail to create Header Font, use default GUI font instead");
                ghHeaderFont = hDefUIFont;
            }
            //create underline font
            ZeroMemory(&lFont, sizeof(lFont));              
            GetObject(hDefUIFont, sizeof(lFont), &lFont);
            lFont.lfUnderline = TRUE;

            ghHook = SetWindowsHookEx(WH_MSGFILTER, AUTranslatorProc, ghInstance, GetCurrentThreadId());            
#ifdef TESTUI
            PostMessage(ghMainWindow, AUMSG_SHOW_WELCOME, 0, 0);
#else
#endif
            return 0;                   
        }

        case AUMSG_SHOW_WELCOME:
            DEBUGMSG("WUAUCLT Displaying Welcome");
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_UPDATEFRAME), 
                    NULL, (DLGPROC)WizardFrameProc);                        
            return 0;

        case AUMSG_SHOW_DOWNLOAD:                   
#ifdef TESTUI
        {
            DEBUGMSG("WUAUCLT Displaying Predownload");
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_DOWNLOAD), 
                    NULL, (DLGPROC)DownloadDlgProc);    
            return 0;
        }
#else
        {               
            DEBUGMSG("WUAUCLT Displaying Predownload");
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_DOWNLOAD), 
                NULL, (DLGPROC)DownloadDlgProc);                
            return 0;
        }
#endif

        case AUMSG_SHOW_INSTALL:
            DEBUGMSG("WUAUCLT Displaying Install");
            DismissUIIfAny();
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_INSTALLFRAME), 
                NULL, (DLGPROC)InstallDlgProc);
            return 0;

        case AUMSG_SHOW_INSTALLWARNING: 
            DEBUGMSG("WUAUCLT Displaying install warning dialog");
            ShowInstallWarning();
            return 0;

        case WM_CLOSE:          
            DestroyWindow(ghMainWindow);            
            return 0;

		case WM_ENDSESSION:
			DEBUGMSG("WUAUCLT received WM_ENDSESSION (wParam = %#x)", wParam);
			if (wParam)
			{
				//if installation thread is live, wait until it finishes
				if (NULL != gpClientCatalog)
				{
    				gpClientCatalog->m_WrkThread.m_Terminate();
				}
				DismissUIIfAny();
				UninitPopupMenus();
				if (NULL != ghHeaderFont)
				{
					DeleteObject(ghHeaderFont);
				}
				UninitializeAUClient(g_hRegisterWait, g_hClientNotifyEvt, g_fCoInit, g_fcsInit);

				// Even we try to set the client exit code here, but there are cases
				// based on observation (e.g. logging off during reboot warning) that
				// we don't get back to WinMain for clean up after so the exit code gets
				// ignored.
				if (CDWWUAUCLT_UNSPECIFY == GetClientExitCode())
				{
					SetClientExitCode(CDWWUAUCLT_ENDSESSION);
				}
				DEBUGMSG("WUAUCLT exit code %d", GetClientExitCode());
			}
			return 0;

        case WM_DESTROY:            
            if (NULL != ghHeaderFont)
            {
                DeleteObject(ghHeaderFont);
            }
            if(ghCurrentMainDlg != NULL) 
            {
                DestroyWindow(ghCurrentMainDlg);
            }
			UninitPopupMenus();
            PostQuitMessage(0); 
            return 0;

        case WM_TIMER:
#ifdef TESTUI
            return 0;
#else
            {
                UINT nPercentComplete = 0;
                DWORD dwStatus;

                if (FAILED(gInternals->m_getServiceState(&AuState)))
                {
                    DEBUGMSG("WUAUCLT m_getServiceState failed when WM_TIMER or AuState.fDisconnected, quitting");
                    QUITAUClient();
                }
                else
                {
					if (AUSTATE_DETECT_COMPLETE != AuState.dwState 
						&& AUSTATE_DOWNLOAD_PENDING != AuState.dwState
						&& AUSTATE_DOWNLOAD_COMPLETE != AuState.dwState
						&& AUSTATE_NOT_CONFIGURED != AuState.dwState)
					{
						return 0;
					}
                    if (AUSTATE_DOWNLOAD_PENDING != AuState.dwState ||
                        SUCCEEDED(gInternals->m_getDownloadStatus(&nPercentComplete, &dwStatus)) && (DWNLDSTATUS_PAUSED == dwStatus))
                    {
						UINT cSess;

                        if ((SUCCEEDED(gInternals->m_AvailableSessions(&cSess)) && cSess > 1) || FCurrentSessionInActive())
                        {
                            DEBUGMSG("WUAUCLT : After 4 hours, exit client and relaunch it in next available admin session");
                            SetClientExitCode(CDWWUAUCLT_RELAUNCHNOW);
                            QUITAUClient();
                        }
                    }
                }
            return 0;
            }
#endif      
        case AUMSG_TRAYCALLBACK:
#ifdef TESTUI
            return 0;
#else
            switch(lParam)
            {
                case WM_LBUTTONDOWN:
                case WM_RBUTTONDOWN:
                case WM_LBUTTONDBLCLK:
                case WM_CONTEXTMENU:
                case NIN_BALLOONUSERCLICK:
                    DEBUGMSG("TrayIcon Message got %d", lParam);
                    if (ghCurrentMenu != NULL)
                    {
						// bug 499697
						// Don't show Pause/Resume menu for download if domain policy specifies schedule install
						if (//SUCCEEDED(gInternals->m_getServiceState(&AuState)) &&
							//AUSTATE_DOWNLOAD_PENDING == AuState.dwState &&
							fDisableSelection())
						{
							break;
						}

						POINT mousePos;
						GetCursorPos(&mousePos);
						SetForegroundWindow(ghMainWindow);
						/*BOOL result =*/ TrackPopupMenu(ghCurrentMenu, 0, mousePos.x, mousePos.y, 0, ghMainWindow, NULL);
						PostMessage(ghMainWindow, WM_NULL, 0, 0);
                    }
                    else
                    {
                        EnterCriticalSection(&gcsClient); 

                        if(gNextDialogMsg != 0)
                        {
                            PostMessage(hWnd, gNextDialogMsg, 0, 0);
                            gNextDialogMsg = 0;
                            // we need to make use of the permission to set foregroundwindow ASAP because 
                            // SetForegroundWindow() will fail if called later
                            if (!SetForegroundWindow(ghMainWindow))
                            {
                                DEBUGMSG("WUAUCLT: Set main window to foreground FAILED");
                            }
                        }
                        else
                        {
                            SetActiveWindow(ghCurrentMainDlg);
                            SetForegroundWindow(ghCurrentMainDlg);
                            if(ghCurrentDialog != NULL) SetFocus(ghCurrentDialog);
                        }
                        LeaveCriticalSection(&gcsClient);
                    }
                    break;

                case WM_MOUSEMOVE:
                    if (FAILED(gInternals->m_getServiceState(&AuState)))
                    {
                        //fixcode: shall we quit AU here?
                        RemoveTrayIcon();
                        break;
                    }
                    if (AUSTATE_DOWNLOAD_PENDING == AuState.dwState) 
                    {
                        ShowProgress();
                    }
                    break;

                default:
                    break;
            }
            return 0;
#endif

        case WM_COMMAND:
            
#ifdef TESTUI
            return 0;
#else
			// bug 499697
			// Don't process Pause/Resume menu commands
			// if domain policy specifies scheduled install
			// in case the message was generated before
			// current domain policy kicked in.
			if (fDisableSelection())
			{
				return 0;
			}
            switch(LOWORD(wParam))
            {
                case IDC_PAUSE:
                    DEBUGMSG("WUAUCLT User pausing download");
                    if (FAILED(gInternals->m_setDownloadPaused(TRUE)))
                    {
//                        QUITAUClient(); //let wuaueng to figure out problem and recover
                    }
                    else
                    {
                        ghCurrentMenu = ghResumeMenu;
                        DEBUGMSG("current menu = resume");
                    }
                    break;

                case IDC_RESUME:
                    DEBUGMSG("WUAUCLT User resuming download");
                    if (FAILED(gInternals->m_setDownloadPaused(FALSE)))
                    {
//                        QUITAUClient();
                    }
                    else
                    {
                        ghCurrentMenu = ghPauseMenu;
                        DEBUGMSG("current menu = pause");
                    }
                    break;

                default:
                    break;
            }
            return 0;
#endif  
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);

    }
    return 0;
}

//client exit code should only be set once with a meaningful value
void SetClientExitCode(UINT uExitCode)
{
    if (guExitProcess != CDWWUAUCLT_UNSPECIFY)
    {
        DEBUGMSG("ERROR: WUAUCLT Client exit code should only be set once");
    }
    else
    {
        guExitProcess = uExitCode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\aucatalog.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUCatalog.h
//
//  Creator: PeterWi
//
//  Purpose: AU Catalog Definitions
//
//=======================================================================

#pragma once
#include <windows.h>
#include "safefunc.h"
#include "audownload.h"
#include "auwait.h"
#include "AUBaseCatalog.h"

class AUCatalogItemList;

const DWORD CATALOG_XML_VERSION = 2;

typedef enum tagDETECTLEVEL
{
	MIN_LEVEL = 0,
	PROVIDER_LEVEL = MIN_LEVEL,
	PRODUCT_LEVEL ,
	ITEM_LEVEL,
	DETAILS_LEVEL,
	MAX_LEVEL = DETAILS_LEVEL,
	DRIVERS_LEVEL
} DETECTLEVEL;


//wrapper class for AU to do detection using IU
class AUCatalog : public AUBaseCatalog
{
public: 
   AUCatalog(): m_audownloader(DoDownloadStatus)
   	{
   	}
   ~AUCatalog();
	static BOOL InitStaticVars(void)
    {
    	AUPROVIDERQUERY = SysAllocString(L"<query><dObjQueryV1 procedure=\"providers\" /></query>"); //case SENSITIVE
		AUPRODUCTQUERY= SysAllocString(L"<query><dObjQueryV1 procedure=\"products\"><parentItems></parentItems></dObjQueryV1></query>");
		AUITEMQUERY = SysAllocString(L"<query><dObjQueryV1 procedure=\"items\"><parentItems></parentItems></dObjQueryV1></query>");
		AUDETAILSQUERY = SysAllocString(L"<query><dObjQueryV1 procedure=\"itemdetails\"><parentItems></parentItems></dObjQueryV1></query>");
		PRODUCT_PRUNE_PATTERN = SysAllocString(L"/items/itemStatus[detectResult/@installed=\"1\"]"); 
		DETAILS_PRUNE_PATTERN = SysAllocString(L"/items/itemStatus[(not (detectResult/@excluded) or (detectResult/@excluded=\"0\")) and (detectResult/@force=\"1\" or not (detectResult/@installed=\"1\") or detectResult/@upToDate = \"0\")]");
		AUDRIVERSQUERY = SysAllocString(L"<query><dObjQueryV1 procedure=\"driverupdates\"/></query>");
		AUDRIVERSYSCLASS = SysAllocString(L"<classes><computerSystem/><platform/><devices/><locale /></classes>");
		AUNONDRIVERSYSCLASS = SysAllocString(L"<classes><computerSystem/><platform/><locale /></classes>");
		bstrParentItems = SysAllocString(L"/query/dObjQueryV1/parentItems");
		bstrItemID = SysAllocString(L"./identity/@itemID");
	
		bstrTagAUCATALOG=SysAllocString(L"AUCATALOG");
		bstrAttrVERSION=SysAllocString(L"VERSION");
		bstrAttrDOWNLOADID=SysAllocString(L"DOWNLOADID");
		bstrAttrITEMCOUNT=SysAllocString(L"ITEMCOUNT");
		bstrAttrUpdateDriver = SysAllocString(L"UPDATEDRIVER");
		bstrAttrSTATUS=SysAllocString(L"STATUS");
		bstrHiddenItems=SysAllocString(L"hiddenitems");
		bstrTagITEM=SysAllocString(L"ITEM");
		bstrAttrID=SysAllocString(L"ID");
		bstrProviderNamePattern=SysAllocString(L"description/descriptionText/title"); 
        bstrItemIDPattern=SysAllocString(L"identity/@itemID"); 
        bstrTitlePattern=SysAllocString(L"description/descriptionText/title"); 
        bstrDescPattern=SysAllocString(L"description/descriptionText/text()");
        bstrRTFUrlPattern=SysAllocString(L"description/descriptionText/details/@href");
        bstrEulaUrlPattern=SysAllocString(L"description/descriptionText/eula/@href");
        bstrExclusiveItemPattern=SysAllocString(L"catalog/provider/item[installation/@exclusive=\"1\"]");
        bstrItemIdsPattern=SysAllocString(L"catalog/provider/item/identity/@itemID"); 
        bstrTemplate=SysAllocString(L"<hiddenitems version = \"1\"></hiddenitems>");
        bstrResultTemplate=SysAllocString(L"<?xml version=\"1.0\"?><items xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/resultschema.xml\"></items>");
       	bstrCatalog=SysAllocString(L"catalog");


		//make sure all query and prune pattern strings are not NULL
		if (NULL == AUPROVIDERQUERY 
			|| NULL == AUPRODUCTQUERY
			|| NULL == AUITEMQUERY 
			|| NULL == AUDETAILSQUERY
			|| NULL == PRODUCT_PRUNE_PATTERN 
			|| NULL == DETAILS_PRUNE_PATTERN
			|| NULL == AUDRIVERSQUERY
			|| NULL == AUDRIVERSYSCLASS
			|| NULL == AUNONDRIVERSYSCLASS
			|| NULL == bstrParentItems
			|| NULL == bstrItemID
			|| NULL == bstrTagAUCATALOG
			|| NULL == bstrAttrVERSION
			|| NULL == bstrAttrDOWNLOADID
			|| NULL == bstrAttrITEMCOUNT
			|| NULL == bstrAttrUpdateDriver
			|| NULL == bstrTagITEM 
			|| NULL == bstrAttrID
			|| NULL == bstrAttrSTATUS 
			|| NULL == bstrHiddenItems
			|| NULL == bstrProviderNamePattern
			|| NULL == bstrItemIDPattern
			|| NULL == bstrTitlePattern
			|| NULL == bstrDescPattern
			|| NULL == bstrRTFUrlPattern
			|| NULL == bstrEulaUrlPattern
			|| NULL == bstrExclusiveItemPattern
			|| NULL == bstrItemIdsPattern
			|| NULL == bstrTemplate
			|| NULL == bstrResultTemplate
			|| NULL == bstrCatalog)
		{
		    DEBUGMSG("AUCatalog::Init() fail to initialize some query strings");
			return FALSE;
		}
		return TRUE;
    }

	static void UninitStaticVars(void)
	{
		SafeFreeBSTR(AUPROVIDERQUERY);
		SafeFreeBSTR(AUPRODUCTQUERY);
		SafeFreeBSTR(AUITEMQUERY);
		SafeFreeBSTR(AUDETAILSQUERY);
		SafeFreeBSTR(PRODUCT_PRUNE_PATTERN);
		SafeFreeBSTR(DETAILS_PRUNE_PATTERN);
		SafeFreeBSTR(AUDRIVERSQUERY);
		SafeFreeBSTR(AUDRIVERSYSCLASS);
		SafeFreeBSTR(AUNONDRIVERSYSCLASS);
		SafeFreeBSTR(bstrParentItems);
		SafeFreeBSTR(bstrItemID);
		SafeFreeBSTR(bstrTagAUCATALOG);
		SafeFreeBSTR(bstrAttrVERSION);
		SafeFreeBSTR(bstrAttrDOWNLOADID);
		SafeFreeBSTR(bstrAttrITEMCOUNT);
		SafeFreeBSTR(bstrAttrUpdateDriver);
		SafeFreeBSTR(bstrTagITEM);
		SafeFreeBSTR(bstrAttrID);
		SafeFreeBSTR(bstrAttrSTATUS);
		SafeFreeBSTR(bstrHiddenItems);
		SafeFreeBSTR(bstrProviderNamePattern);
		SafeFreeBSTR(bstrItemIDPattern);
		SafeFreeBSTR(bstrTitlePattern);
		SafeFreeBSTR(bstrDescPattern);
		SafeFreeBSTR(bstrRTFUrlPattern);
		SafeFreeBSTR(bstrEulaUrlPattern);
		SafeFreeBSTR(bstrExclusiveItemPattern);
		SafeFreeBSTR(bstrItemIdsPattern);
		SafeFreeBSTR(bstrTemplate);
		SafeFreeBSTR(bstrResultTemplate);
		SafeFreeBSTR(bstrCatalog);
	}
	
    HRESULT Init(void);
    HRESULT DetectItems(BOOL fUpdate = FALSE);
    HRESULT ValidateItems(BOOL fOnline);
    HRESULT ValidateDownloadedCabs(BSTR *pbstrErrorItemId);
    HRESULT DownloadItems(void);
    HRESULT GetInstallXML(BSTR *pbstrCatalogXML, BSTR *pbstrDownloadXML);
    HRESULT Serialize(void);
    HRESULT Unserialize(void);
    void DelCatFiles(BOOL fUpdate = FALSE);
    HRESULT getUpdatesList(VARIANT *plist);
	BSTR FindItemIdByLocalFileName(LPCWSTR pwszLocalFileName);

#if DBG
	void DbgDump(void) { m_ItemList.DbgDump(); }
#endif

public: 
	AUCatalogItemList m_ItemList;
    CAUDownloader m_audownloader;
    BOOL  m_fUpdateDriver;
    static 	BSTR bstrTagAUCATALOG;
	static 	BSTR bstrAttrVERSION;
	static 	BSTR bstrAttrDOWNLOADID;
	static	BSTR bstrAttrITEMCOUNT;
	static 	BSTR bstrAttrUpdateDriver;
	static	BSTR bstrTagITEM;
	static 	BSTR bstrAttrID;
	static	BSTR bstrAttrSTATUS;
	static 	BSTR bstrHiddenItems;
	static  BSTR bstrProviderNamePattern; //context node is provider
 	static  BSTR bstrItemIDPattern; //from here below, context node is item
    static  BSTR bstrTitlePattern; 
    static  BSTR bstrDescPattern;
    static  BSTR bstrRTFUrlPattern;
    static  BSTR bstrEulaUrlPattern;
    static 	BSTR bstrExclusiveItemPattern;
    static  BSTR bstrItemIdsPattern;
    static	BSTR bstrTemplate;
    static 	BSTR bstrResultTemplate;
    static	BSTR bstrCatalog;    	
    DWORD m_dwCatLifeSpan;
    DWORD m_dwOfflineCatLifeSpan;
    
private:
    HRESULT GetManifest(DETECTLEVEL enLevel, BSTR bstrDetectResult, BSTR * pbstrManifest);
    HRESULT GetSystemSpec(DETECTLEVEL enLevel, BSTR *pbstrSysSpec);
    HRESULT DoDetection(DETECTLEVEL enLevel, BSTR bstrCatalog, BSTR * pbstrResult, BOOL fOnline = TRUE);
    HRESULT DetectNonDriverItems(OUT BSTR *pbsInstall, OUT AUCatalogItemList &pItemList,  BOOL *pfExclusiveItemFound);
    HRESULT DetectDriverItems(OUT BSTR *pbsInstall, OUT AUCatalogItemList &pItemList,  BOOL *pfExclusiveItemFound);
    HRESULT AUCatalog::MergeDetectionResult(BSTR bstrDriverInstall, AUCatalogItemList & driverlist, BOOL fExclusiveDriverFound, BSTR bstrNonDriverInstall,  AUCatalogItemList & nondriverlist, BOOL fExclusiveItemFound);
    HRESULT DownloadRTFsnEULAs(LANGID langid);
    void ValidateDownloadedRTF(BSTR bstrRTFUrl, BSTR bstrItemId);
    HRESULT ValidateOffline(BSTR bstrNonDrivers, BSTR bstrDrivers);
    HRESULT GetQuery(DETECTLEVEL enLevel, BSTR bstrDetectResult, BSTR *pbstrQuery);
    LPCTSTR GetLogFile(DETECTLEVEL enLevel);
    char * GetLevelStr(DETECTLEVEL enLevel);
    BOOL 	hasExpired(BOOL fOffline = FALSE);
    HRESULT setExpireTime(BOOL fOffline = FALSE);
    DWORD  GetNumSelected(void);		
    void Clear(void);
    
	BSTR	m_bstrClientInfo; //assigned once and never change
	BSTR 	m_bstrDriverClientInfo; //assigned once and never change
	BSTR m_bstrInstallation; //a.k.a item details
	SYSTEMTIME m_stExpireTime; //online
	SYSTEMTIME m_stOfflineExpireTime;
	BOOL m_fNeedToContinueJob; 

static	BSTR AUPROVIDERQUERY;
static	BSTR AUPRODUCTQUERY;
static	BSTR AUITEMQUERY;
static	BSTR AUDETAILSQUERY;
static	BSTR AUDRIVERSQUERY;
static	BSTR PRODUCT_PRUNE_PATTERN; 
static	BSTR DETAILS_PRUNE_PATTERN;
static 	BSTR AUDRIVERSYSCLASS;
static	BSTR AUNONDRIVERSYSCLASS;
static 	BSTR bstrParentItems;
static 	BSTR bstrItemID;

	
};

const DWORD CATALOG_LIFESPAN	=	AU_TWELVE_HOURS; //in secs
const DWORD CATALOG_OFFLINE_LIFESPAN = AU_ONE_HOUR; 

//following files persisted across cycles. Under %program files%\windowsupdate
extern const LPTSTR ITEM_FILE; 
extern const LPTSTR DRIVERS_FILE;
extern const LPTSTR CATALOG_FILE;
extern const LPTSTR DETAILS_FILE; 


//following files are write once and never be read. 
#ifdef DBG
extern const LPTSTR DRIVER_SYSSPEC_FILE; 
extern const LPTSTR NONDRIVER_SYSSPEC_FILE; 
extern const LPTSTR PROVIDER_FILE; 
extern const LPTSTR PRODUCT_FILE ; 
extern const LPTSTR DETECT1_FILE ; 
extern const LPTSTR DETECT2_FILE; 
extern const LPTSTR DETECT3_FILE; 
extern const LPTSTR INSTALL_FILE; 
#endif
extern AUCatalog * gpAUcatalog;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\aucatalog.cpp ===
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aucatalog.cpp
//
//  Purpose:	AU catalog file using IU 
//
//  Creator:	WeiW
//
//  History:	08-15-01 	first created
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop


const LPTSTR ITEM_FILE = _T("item.xml");
const LPTSTR DRIVERS_FILE = _T("drivers.xml");
const LPTSTR CATALOG_FILE = _T("catalog.xml");
const LPTSTR DETAILS_FILE = _T("details.xml");


//following files are write once and never be read. 
#ifdef DBG
const LPTSTR DRIVER_SYSSPEC_FILE = _T("driversys.xml");
const LPTSTR NONDRIVER_SYSSPEC_FILE = _T("nondriversys.xml");
const LPTSTR PROVIDER_FILE = _T("provider.xml");
const LPTSTR PRODUCT_FILE = _T("product.xml");
const LPTSTR DETECT1_FILE = _T("detect1.xml");
const LPTSTR DETECT2_FILE = _T("detect2.xml");
const LPTSTR DETECT3_FILE = _T("detect3.xml");
const LPTSTR INSTALL_FILE = _T("install.xml");
#endif

#ifdef DBG
const TCHAR REG_AUCATLIFESPAN[] = _T("CatLifeSpan"); //REG_DWORD
const TCHAR REG_AUCATOFFLINELIFESPAN[] = _T("CatOfflineLifeSpan"); //REG_DWORD
#endif


BSTR AUCatalog::AUPROVIDERQUERY;
BSTR AUCatalog::AUPRODUCTQUERY;
BSTR AUCatalog::AUITEMQUERY;
BSTR AUCatalog::AUDETAILSQUERY;
BSTR AUCatalog::AUDRIVERSQUERY;
BSTR AUCatalog::PRODUCT_PRUNE_PATTERN; 
BSTR AUCatalog::DETAILS_PRUNE_PATTERN;
BSTR AUCatalog::AUDRIVERSYSCLASS;
BSTR AUCatalog::AUNONDRIVERSYSCLASS;
BSTR AUCatalog::bstrParentItems;
BSTR AUCatalog::bstrItemID;
BSTR AUCatalog::bstrTagAUCATALOG;
BSTR AUCatalog::bstrAttrVERSION;
BSTR AUCatalog::bstrAttrDOWNLOADID;
BSTR AUCatalog::bstrAttrITEMCOUNT;
BSTR AUCatalog::bstrAttrUpdateDriver;
BSTR AUCatalog::bstrAttrSTATUS;
BSTR AUCatalog::bstrHiddenItems;
BSTR AUCatalog::bstrTagITEM;
BSTR AUCatalog::bstrAttrID;
BSTR AUCatalog::bstrProviderNamePattern;
BSTR AUCatalog::bstrItemIDPattern;
BSTR AUCatalog::bstrTitlePattern;
BSTR AUCatalog::bstrDescPattern;
BSTR AUCatalog::bstrRTFUrlPattern;
BSTR AUCatalog::bstrEulaUrlPattern;
BSTR AUCatalog::bstrExclusiveItemPattern;
BSTR AUCatalog::bstrItemIdsPattern;
BSTR AUCatalog::bstrTemplate;
BSTR AUCatalog::bstrResultTemplate;
BSTR AUCatalog::bstrCatalog;


inline BOOL FServiceShuttingDown()
{
    return WaitForSingleObject(ghServiceFinished, 0) == WAIT_OBJECT_0;
}

#ifdef DBG
inline BOOL fDBGUseLocalFile()
{
    DWORD dwLevel;
    if (FAILED(GetRegDWordValue(TEXT("UseLocalFile"), &dwLevel)) || 1 != dwLevel)
        {
            return FALSE;
        }
    
    return TRUE;
}
#endif

AUCatalog::~AUCatalog(void)
{
    Clear();
    SafeFreeBSTR(m_bstrClientInfo);
    SafeFreeBSTR(m_bstrDriverClientInfo);
}

//always called before any other method on AUCatalog is used.
HRESULT AUCatalog::Init()
{
    HRESULT hr = S_OK;
    m_fNeedToContinueJob = FALSE;
    m_bstrInstallation = NULL;
    m_fUpdateDriver = !gpState->fWin2K();
    m_dwCatLifeSpan = CATALOG_LIFESPAN;
    m_dwOfflineCatLifeSpan = CATALOG_OFFLINE_LIFESPAN;

    ZeroMemory(&m_stExpireTime, sizeof(m_stExpireTime)) ;
    ZeroMemory(&m_stOfflineExpireTime, sizeof(m_stOfflineExpireTime));

	m_bstrClientInfo = SysAllocString(AUCLIENTINFO);
	m_bstrDriverClientInfo = SysAllocString(AUDRIVERCLIENTINFO);
	if (NULL == m_bstrClientInfo || NULL == m_bstrDriverClientInfo)
	{
	    DEBUGMSG("AUCatalog::Init() fail to alloc string for client info");
		hr = E_FAIL;
		goto end;
	}

#ifdef DBG
	if (FAILED(GetRegDWordValue(REG_AUCATLIFESPAN, &m_dwCatLifeSpan)))
	{
		m_dwCatLifeSpan = CATALOG_LIFESPAN;
	}

	 if (FAILED(GetRegDWordValue(REG_AUCATOFFLINELIFESPAN, &m_dwOfflineCatLifeSpan)))
	{
		m_dwOfflineCatLifeSpan = CATALOG_OFFLINE_LIFESPAN;
	}
#endif

end:
	return hr;
}


//////////////////////////////////////////////////////////////////////
// clear out more dynamic internal data
/////////////////////////////////////////////////////////////////////
void AUCatalog::Clear()
{
       m_ItemList.Clear();
	SafeFreeBSTRNULL(m_bstrInstallation);
       ZeroMemory(&m_stExpireTime, sizeof(m_stExpireTime));
       ZeroMemory(&m_stOfflineExpireTime, sizeof(m_stOfflineExpireTime));
}


HRESULT AUCatalog::GetSystemSpec(DETECTLEVEL enLevel, BSTR * pbstrSysSpec)
{
	HRESULT hr = E_FAIL;
	if (FServiceShuttingDown())
        {
            DEBUGMSG("Skip AUCatalog::GetSystemSpec() because service is shutting down");
            hr = E_ABORT;
            goto done;
        }


	BSTR bstrSysClass = (DRIVERS_LEVEL == enLevel) ? AUDRIVERSYSCLASS : AUNONDRIVERSYSCLASS;
	hr = m_pfnGetSystemSpec(m_hIUEngineInst, bstrSysClass, 0, pbstrSysSpec); //online mode

#ifdef DBG	   
	if (SUCCEEDED(hr))
	{
		LOGXMLFILE((DRIVERS_LEVEL == enLevel) ? DRIVER_SYSSPEC_FILE : NONDRIVER_SYSSPEC_FILE, *pbstrSysSpec);
	}
#endif	
done:
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// compose query based on a format and items picked out from detection result
//
HRESULT AUCatalog::GetQuery(IN DETECTLEVEL enLevel, IN BSTR bstrDetectResult, OUT BSTR *pbstrQuery)
{
	BSTR bstrPrunePattern;
	BSTR bstrQuery = NULL;
    HRESULT hr = S_OK;
	IXMLDOMNodeList *pItems = NULL;
    IXMLDOMNode *pParentItems = NULL; 
  	IXMLDOMDocument *pQueryXML= NULL;
	IXMLDOMDocument *pResultXML= NULL;


	DEBUGMSG("GetQuery() starts");
	AUASSERT(NULL != pbstrQuery);
    *pbstrQuery = NULL;
	switch (enLevel)
	{
	case PROVIDER_LEVEL:
			bstrQuery = AUPROVIDERQUERY;
			break;
	case DRIVERS_LEVEL:
	              bstrQuery = AUDRIVERSQUERY;
	              break;
	case PRODUCT_LEVEL:
			bstrQuery = AUPRODUCTQUERY;
			bstrPrunePattern = PRODUCT_PRUNE_PATTERN;
			break;
	case ITEM_LEVEL:
			bstrQuery = AUITEMQUERY;
			bstrPrunePattern = PRODUCT_PRUNE_PATTERN; //the same as product pruning logic
			break;
	case DETAILS_LEVEL:
			bstrQuery = AUDETAILSQUERY;
			bstrPrunePattern = DETAILS_PRUNE_PATTERN;
			break;
	default:
			AUASSERT(FALSE); //should never be here
			return E_INVALIDARG;
	}


	if (FAILED(hr = LoadXMLDoc(bstrQuery, &pQueryXML, TRUE)))
        {
          DEBUGMSG("GetQuery() fail to load query XML with error %#lx", hr);
           goto done;
        }

	if (enLevel != PROVIDER_LEVEL && DRIVERS_LEVEL != enLevel)
	{
		if (FAILED(hr = LoadXMLDoc(bstrDetectResult, &pResultXML, TRUE)))
		    {
		    DEBUGMSG("GetQuery() fail to load XML for detect result with error %#lx", hr);
		    goto done;
		    }

		if (FAILED(hr = pResultXML->selectNodes(bstrPrunePattern, &pItems)))
		{
			DEBUGMSG("GetQuery() fail to select node or nothing to select with error %#lx", hr);
			goto done;
		}

		long lLen = 0;
		if (FAILED(hr = pItems->get_length(&lLen)))
		{
			DEBUGMSG("GetQuery() fail to get item number with error %#lx", hr);
			goto done;
		}
		DEBUGMSG("GetQuery(): pruning result %d items", lLen);
		if (0 == lLen)
		    {
		      DEBUGMSG("No updates applicable");
		      hr = S_FALSE;
                    goto done;
		    }
		if (S_OK != (hr = pQueryXML->selectSingleNode(bstrParentItems, &pParentItems)))
		{
			DEBUGMSG("GetQuery() fail to select single node %#lx or nothing to select", hr);
			hr = E_FAIL;
			goto done;
		}
		for (int i = 0; i < lLen; i++)
		{
                     IXMLDOMNode *pIdentity1 = NULL;
  		       IXMLDOMNode *pItemStatus;
			if (S_OK != (hr = pItems->get_item(i, &pItemStatus)))
			    {
                    hr = FAILED(hr) ? hr : E_FAIL;			    	
			        goto done;
			    }
			hr = pItemStatus->selectSingleNode(bstrItemID, &pIdentity1);
			pItemStatus->Release();
			if (FAILED(hr) || NULL == pIdentity1)
			{
				DEBUGMSG("GetQuery() fail to select itemID with error %#lx", hr);
				hr = FAILED(hr) ? hr : E_FAIL;
				goto done;
			}
			if (NULL == pIdentity1)
			{
				DEBUGMSG("GetQuery() fail to select itemID");
				hr = E_FAIL;
				goto done;
			}
       		    {
       			BSTR bstrItemId = NULL;
       			IXMLDOMElement *pItem= NULL;
         		       IXMLDOMText *pItemIdText = NULL;

         		       if (S_OK != (hr = pIdentity1->get_text(&bstrItemId)))
         		        {
         		            DEBUGMSG("Fail to get text for item");
                            hr = FAILED(hr) ? hr : E_FAIL;
         		        }
         		       else if (FAILED(hr = pQueryXML->createTextNode(bstrItemId, &pItemIdText)))
         		        {
         		            DEBUGMSG("Fail to create text node");
         		        }
         		       else if (FAILED (hr = pQueryXML->createElement(KEY_ITEM, &pItem)))
         		        {
         		            DEBUGMSG("GetQuery() fail to create element");
           			}
         		       else if (FAILED(hr = pItem->appendChild(pItemIdText, NULL)))
         		        {
         		            DEBUGMSG("Fail to append child");
         		        }
         		       else if (FAILED(hr = pParentItems->appendChild(pItem, NULL)))
         		        {
         		            DEBUGMSG("Fail to append child with error %#lx", hr);
         		        }

       			SafeRelease(pItem);
       			SafeRelease(pItemIdText);
       			SafeFreeBSTR(bstrItemId);
       			pIdentity1->Release();
       			if (FAILED(hr))
       			    {
       			    goto done;
       			    }
       		    }
		}
	}
	if (FAILED(hr = pQueryXML->get_xml(pbstrQuery)))
	{
		DEBUGMSG("Fail to get query xml with error %#lx", hr);
		goto done;
	}
done:
//	DEBUGMSG("GetQuery(): Query string is %S", *pbstrQuery);
	SafeRelease(pItems);
	SafeRelease(pParentItems);
	SafeRelease(pQueryXML);
	SafeRelease(pResultXML);
	if (FAILED(hr))
	{
		SafeFreeBSTRNULL(*pbstrQuery);
	}
	return hr;
}


HRESULT AUCatalog::DoDetection(IN  DETECTLEVEL enLevel, IN BSTR bstrCatalog, OUT BSTR *pbstrResult, IN BOOL fOnline)
{
       HRESULT hr = E_FAIL;
#ifdef DBG
       DWORD dwStart = GetTickCount();
#endif
	AUASSERT(m_pfnDetect != NULL);
	AUASSERT(bstrCatalog != NULL);
	AUASSERT(m_hIUEngineInst != NULL);
	AUASSERT(NULL != pbstrResult);
	*pbstrResult = NULL;
	if (FServiceShuttingDown())
        {
        DEBUGMSG("Skip AUCatalog::DoDetection() because service is shutting down");
        hr = E_ABORT;
        goto done;
        }
	hr = m_pfnDetect(m_hIUEngineInst, bstrCatalog, fOnline ? 0 : FLAG_OFFLINE_MODE, pbstrResult); 
#ifdef DBG
	if (SUCCEEDED(hr))
	{
		switch (enLevel)
		{
		case PROVIDER_LEVEL:
			LOGXMLFILE(DETECT1_FILE, *pbstrResult);
			break;
		case PRODUCT_LEVEL:
			LOGXMLFILE(DETECT2_FILE, *pbstrResult);
			break;
		case ITEM_LEVEL:
			LOGXMLFILE(DETECT3_FILE, *pbstrResult);
			break;
		default:
			AUASSERT(FALSE);
			hr = E_INVALIDARG;
			break;
		}
	}
#endif
done:
#ifdef DBG
    DEBUGMSG("DoDetection() take %d msecs", GetTickCount() - dwStart);
#endif
	if (FAILED(hr))
	{
		SafeFreeBSTRNULL(*pbstrResult);
	}
    return hr;
}

LPCTSTR AUCatalog::GetLogFile(IN DETECTLEVEL enLevel)
{
	switch (enLevel)
	{
#ifdef DBG	
	case PROVIDER_LEVEL:
		return PROVIDER_FILE;
	case PRODUCT_LEVEL:
		return PRODUCT_FILE;
#endif		
	case ITEM_LEVEL:
		return ITEM_FILE;
	case DETAILS_LEVEL:
		return DETAILS_FILE;
	case DRIVERS_LEVEL:
	        return DRIVERS_FILE;
	default:
		return NULL;
	}
}

HRESULT AUCatalog::GetManifest(IN DETECTLEVEL enLevel, IN BSTR bstrDetectResult, OUT BSTR *pbstrManifest)
{
       HRESULT hr = E_FAIL;
       BSTR bstrQuery = NULL;
       
#ifdef DBG
        DWORD dwStart= GetTickCount();
#endif
		AUASSERT(NULL != m_pfnGetManifest);
        *pbstrManifest = NULL;
	if (FServiceShuttingDown())
        {
        DEBUGMSG("Skip AUCatalog::GetManifest() because service is shutting down");
        hr = E_ABORT;
        goto done;
        }
       if (S_OK != (hr = GetQuery(enLevel, bstrDetectResult, &bstrQuery)))
        {
            goto done;
        }

       BSTR bstrSysSpec = NULL;            
       if (FAILED(hr = GetSystemSpec(enLevel, &bstrSysSpec)))
        {
           goto done;
        } 

	DEBUGMSG("WUAUENG: Calling IU getmanifest()....");
	hr = m_pfnGetManifest(m_hIUEngineInst, (DRIVERS_LEVEL == enLevel) ? m_bstrDriverClientInfo :m_bstrClientInfo,
	            bstrSysSpec, bstrQuery, FLAG_USE_COMPRESSION, pbstrManifest); //compression on
	DEBUGMSG("WUAUENG: IU getmanifest() done");	            
	SysFreeString(bstrSysSpec);
	if (FAILED(hr))
	{
		goto done;
	}

	LPCTSTR ptszLogFile = GetLogFile(enLevel);
	if (NULL != ptszLogFile)
	{
		if (FAILED(hr = LOGXMLFILE(ptszLogFile, *pbstrManifest)))
		{
			goto done;
		}
	}
	
done:
    SafeFreeBSTR(bstrQuery);
#ifdef DBG
        DEBUGMSG("GetManifest() take %d msecs", GetTickCount() - dwStart);
#endif
	if (FAILED(hr))
	{
		SafeFreeBSTRNULL(*pbstrManifest);
	}
    return hr;
}


HRESULT AUCatalog::DownloadItems()
{
//	USES_CONVERSION;
	HRESULT hr = S_OK;
	CItemDetails itemdetails;
	UINT uItemCount;
    
	DEBUGMSG("AUCatalog downloading items...");

	PersistHiddenItems(m_ItemList, URLLOGACTIVITY_Download);

       if (m_fNeedToContinueJob)
	{
        	m_fNeedToContinueJob = FALSE;
		if (SUCCEEDED(m_audownloader.ContinueLastDownloadJob()))
		{
			DEBUGMSG("found previous download job, reconnecting succeed");
			goto end;
		}
	}
#ifdef DBG
	else
	{
		DEBUGMSG("no previous download job found");
	}
#endif

	DWORD dwNumSelected = m_ItemList.GetNumSelected();
	if (0 == dwNumSelected)
	{
		hr = S_FALSE;
		DEBUGMSG("Nothing to download, bail out");
		goto end;
	}

	if (NULL == m_bstrInstallation)
	{
		DEBUGMSG("AUCatalog::DownloadItems() can't get installation xml");
		hr = E_FAIL;
		goto end;
	}

	if (!itemdetails.Init(m_bstrInstallation))
	{
		hr = E_FAIL;
		DEBUGMSG("fail to init itemdetails");
		goto end;
	}

	for (UINT i = 0; i < m_ItemList.Count(); i++)
	{
		AUCatalogItem &item = m_ItemList[i];
		if (item.fSelected() || m_ItemList.ItemIsRelevant(i))
		{
			BSTR * pCRCCabNames, *pRealCabNames, *pCabChecksums;
			UINT uCabsNum;
			BSTR bstrItemId = item.bstrID();
			BSTR bstrItemDownloadPath = itemdetails.GetItemDownloadPath(bstrItemId);
			if (NULL == bstrItemDownloadPath)
			{
				DEBUGMSG("fail to build item downloadPath");
				hr = E_FAIL;
				goto end;
			}

			if (SUCCEEDED(hr = itemdetails.GetCabNames(bstrItemId, &pCRCCabNames, &pRealCabNames, &pCabChecksums, &uCabsNum)))
			{
				DEBUGMSG("Need to download following files for %S", bstrItemId);
				for (UINT j  = 0; j < uCabsNum; j++)
				{
					TCHAR szFullFileName[MAX_PATH];
					if (SUCCEEDED(hr) &&
						SUCCEEDED(hr = StringCchCopyEx(szFullFileName, ARRAYSIZE(szFullFileName), W2T(bstrItemDownloadPath), NULL, NULL, MISTSAFE_STRING_FLAGS)))
					{
						if (SUCCEEDED(hr = PathCchAppend(szFullFileName, ARRAYSIZE(szFullFileName), W2T(pRealCabNames[j]))))
						{
							hr = m_audownloader.QueueDownloadFile(W2T(pCRCCabNames[j]), szFullFileName);
						}						
					}
					DEBUGMSG("       from %S  to %S", pCRCCabNames[j], szFullFileName);

					SafeFreeBSTR(pCRCCabNames[j]);
					SafeFreeBSTR(pRealCabNames[j]);
                    SafeFreeBSTR(pCabChecksums[j]);
                }
				free(pCRCCabNames);
				free(pRealCabNames);
                free(pCabChecksums);
			}
#ifdef DBG
			else
			{
				DEBUGMSG("fail to get cab names for %S", bstrItemId);
			}
#endif

			SysFreeString(bstrItemDownloadPath);
			if (FAILED(hr))
			{
				goto end;
			}
		}
	}
	if (SUCCEEDED(hr = m_audownloader.StartDownload()))
	{
		Serialize(); //serialize download id
	}
end: 
	itemdetails.Uninit();
	if (FAILED(hr))
	{
		m_audownloader.Reset();
	}
	DEBUGMSG("AUCatalog downloading items done");
	return hr;
}

char * AUCatalog::GetLevelStr(DETECTLEVEL enLevel)
{
	switch (enLevel)
	{
	case PROVIDER_LEVEL: return "Provider";
	case PRODUCT_LEVEL: return "Product";
	case ITEM_LEVEL: return "Item";
	case DETAILS_LEVEL: return "ItemDetails";
	default: return NULL;
	}
}

BOOL AUCatalog::hasExpired(BOOL fOffline)
{
	SYSTEMTIME	stTmp ;
	SYSTEMTIME stExpire;

	ZeroMemory(&stTmp, sizeof(stTmp));
    stExpire = fOffline ? m_stOfflineExpireTime : m_stExpireTime;
    GetSystemTime(&stTmp);
#ifdef DBG      	
	TCHAR szExpireTime[80], szCurrentTime[80];
       if (SUCCEEDED(SystemTime2String(stExpire, szExpireTime, ARRAYSIZE(szExpireTime))) 
       	  && SUCCEEDED(SystemTime2String(stTmp, szCurrentTime, ARRAYSIZE(szCurrentTime))))
       {
	     	DEBUGMSG("AUCatalog::hasExpired() expire time is %S current time is %S", szExpireTime, szCurrentTime);
       }
#endif     	
	return TimeDiff(stExpire, stTmp) >= 0;
}

HRESULT AUCatalog::setExpireTime(BOOL fOffline)
{
	SYSTEMTIME stCurrent;
	HRESULT hr = E_FAIL;
	GetSystemTime(&stCurrent);
	if (FAILED(hr = TimeAddSeconds(stCurrent, dwSecsToWait(m_dwOfflineCatLifeSpan), &m_stOfflineExpireTime)))
	{
		DEBUGMSG("Fail to calculate m_stOfflineExpireTime with error %#lx", hr);
		goto done;
	}
	if (!fOffline)
	{
	    if (FAILED(hr = TimeAddSeconds(stCurrent, dwSecsToWait(m_dwCatLifeSpan), &m_stExpireTime)))
	    {
	    	DEBUGMSG("Fail to calculate m_stExpireTime with error %#lx", hr);
	    	goto done;
	    }
	}
#ifdef DBG       
	TCHAR szCurrentTime[80], szExpireTime[80];
       if (SUCCEEDED(SystemTime2String(stCurrent, szCurrentTime, ARRAYSIZE(szCurrentTime)))
       	&& SUCCEEDED(SystemTime2String(m_stOfflineExpireTime, szExpireTime, ARRAYSIZE(szExpireTime))))
       {
	       DEBUGMSG("AUCatalog::setExpireTime with current time %S and expire time %S", szCurrentTime, szExpireTime);
       }
#endif       
	hr = S_OK;
done:
	if (FAILED(hr))
	{
		ZeroMemory(&m_stOfflineExpireTime, sizeof(m_stOfflineExpireTime));
		ZeroMemory(&m_stExpireTime, sizeof(m_stOfflineExpireTime));
	}
	return hr;
}

//when m_fUpdateDriver is FALSE, bstrDrivers are not looked at
HRESULT AUCatalog::ValidateOffline(BSTR bstrItems, BSTR bstrDrivers)
{
    HRESULT hr= E_FAIL;
    BSTR bstrResult = NULL;
    BSTR bstrQuery = NULL;
    IXMLDOMDocument *pQueryXml = NULL;
    IXMLDOMDocument *pDriversXml = NULL;

//	DEBUGMSG("ValidateOffline starts");
		if (0 == m_ItemList.Count())
		{
			hr = S_FALSE;
			goto done; //no need to validate
		}

         if (FAILED(hr = PrepareIU(FALSE)))
            {
                DEBUGMSG(" fail to prepare IU offline with error %#lx", hr);
                goto done;
            }

         if (FAILED(hr = DoDetection(ITEM_LEVEL, bstrItems, &bstrResult, FALSE)))
                {
                DEBUGMSG("Fail to detect items with error %#lx", hr);
                goto done;
                }
            if (S_OK != (hr = GetQuery(DETAILS_LEVEL, bstrResult, &bstrQuery)))
                {
                    goto done;
                }
//            DEBUGMSG("Query Result is %S", bstrQuery);
            if (FAILED(hr = LoadXMLDoc(bstrQuery, &pQueryXml, TRUE)) ||
                  (m_fUpdateDriver && FAILED(hr = LoadXMLDoc(bstrDrivers, &pDriversXml, TRUE)))) //offline
                {
                DEBUGMSG("Fail to load xml with error %#lx", hr);
                goto done;
                }

            for (UINT u = 0; u < m_ItemList.Count(); u++)
                {
                    IXMLDOMNode *pItemIdentityNode1 = NULL;
                    IXMLDOMNode *pItemNode2 = NULL;
                    CAU_BSTR aubsItemPattern;
                    CAU_BSTR aubsDriverItemIdentityPattern;
                    if (!aubsDriverItemIdentityPattern.append(L"/catalog/provider/item/identity[@itemID=\"") || !aubsDriverItemIdentityPattern.append(m_ItemList[u].bstrID()) || !aubsDriverItemIdentityPattern.append(L"\"]"))
                        {
                        DEBUGMSG("failed to create driver pattern string");
                        hr = E_OUTOFMEMORY;
                        goto done;
                        }

                    if (!aubsItemPattern.append(L"/query/dObjQueryV1/parentItems/item[.=\"") || !aubsItemPattern.append(m_ItemList[u].bstrID()) || !aubsItemPattern.append(L"\"]"))
                        {
                        DEBUGMSG("OUT OF MEMORY and failed to create pattern string");
                        hr = E_OUTOFMEMORY;
                        goto done;
                        }

                    if ((m_fUpdateDriver && HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == FindSingleDOMNode(pDriversXml, aubsDriverItemIdentityPattern, &pItemIdentityNode1)
                        && HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == FindSingleDOMNode(pQueryXml, aubsItemPattern, &pItemNode2)) ||
                          (!m_fUpdateDriver && HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == FindSingleDOMNode(pQueryXml, aubsItemPattern, &pItemNode2)))
                    {
                        DEBUGMSG("item %S installed off band, remove it from AU's list", m_ItemList[u].bstrID());
                        m_ItemList.Remove(m_ItemList[u].bstrID());
                    }
                    SafeRelease(pItemIdentityNode1);
                    SafeRelease(pItemNode2);
                }
done:
           		FreeIU();
                SafeFreeBSTR(bstrQuery);
                SafeFreeBSTR(bstrResult);
                SafeRelease(pQueryXml);
                SafeRelease(pDriversXml);
    //           	DEBUGMSG("ValidateOffline ends");
                return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
//update internal list to reflect latest applicable items
// return S_FALSE if nothing is appliable anymore
//////////////////////////////////////////////////////////////////////////////////////
HRESULT AUCatalog::ValidateItems(BOOL fOnline )
{
    HRESULT hr = S_OK;
    BSTR bstrNonDrivers = NULL, bstrDrivers = NULL;

    DEBUGMSG("AUCatalog validating items...");

    if (fOnline && !hasExpired())
	{
		DEBUGMSG("Catalog was valid and hasn't expired online. Do offline validation only");
		fOnline = FALSE;
	}
    if (!fOnline && !hasExpired(TRUE))
    {
        DEBUGMSG("Catalog was valid and hasn't expired offline. No validation needed");
        goto done;
    }

    if (fOnline)
        {
        //do online detection
         DEBUGMSG("Doing online validating");
        AUCatalogItemList olditemlist;
        if (FAILED(hr = olditemlist.Copy(m_ItemList)))
        {
        	goto done;
        }
        if (S_OK != (hr = DetectItems(TRUE))) //update instead of building from scratch
            {
                //fail to detect or no items applicable
                goto done;
            }

        BOOL fItemPulled;
        do
            {
                fItemPulled = FALSE;
                UINT uOldListLen = olditemlist.Count();
                for (UINT u=0; u < uOldListLen; u++)
                    {
                        if (m_ItemList.Contains(olditemlist[u].bstrID()) < 0)
                            {
                                DEBUGMSG("item %S is pulled from site", olditemlist[u].bstrID());
                                olditemlist.Remove(olditemlist[u].bstrID());
                                fItemPulled = TRUE;
                                break;
                            }
                    }
            }
        while (fItemPulled);
        if (FAILED(hr = m_ItemList.Copy(olditemlist))) //update item list
        {
        	goto done;
        }
      }

      if (NULL == (bstrNonDrivers =ReadXMLFromFile(ITEM_FILE))  ||
          (m_fUpdateDriver && (NULL == (bstrDrivers = ReadXMLFromFile(DRIVERS_FILE)))))
            {
              DEBUGMSG("Fail to read item or drivers xml file ");
              hr = E_FAIL;
              goto done;
            }

    if (!fOnline)
    {
        //do offline validation for non drivers
            DEBUGMSG("Doing offline validating");
            if (FAILED(hr = ValidateOffline(bstrNonDrivers, bstrDrivers)))
                {
                    DEBUGMSG("Fail to validate offline with error %#lx", hr);
                    goto done;
                }
    }
    if (m_ItemList.GetNumHidden() == m_ItemList.Count())
        {
            DEBUGMSG("No applicable items left");
            hr = S_FALSE;
            goto done;
        }


    if (FAILED(hr = BuildDependencyList(m_ItemList, bstrDrivers, bstrNonDrivers)))
        {
            DEBUGMSG("Fail to build dependency list with error %#lx", hr);
            goto done;
        }
    setExpireTime(fOnline);
    
     Serialize();
done:
    if (S_OK != hr)
        {
            Clear(); //need to redetect anyway
            DelCatFiles();
        }
    SafeFreeBSTR(bstrNonDrivers);
    SafeFreeBSTR(bstrDrivers);
    DEBUGMSG("AUCatalog done validating items");
    return hr;
}

HRESULT AUCatalog::getUpdatesList(VARIANT OUT *pvarList)
{
    SAFEARRAYBOUND bound[1] = { m_ItemList.Count() * 7, 0};
	SAFEARRAY * psa = SafeArrayCreate(VT_VARIANT, 1, bound);
	VARIANT * grVariant;
	BOOL fRet = FALSE;

	AUASSERT(NULL != pvarList);
    DEBUGMSG("AUCatalog::getUpdateList() starts");
	VariantInit(pvarList);
	if ( 0 == m_ItemList.Count() )
	{
		DEBUGMSG("AUCatalog::getUpdateList fails because getNumItems is 0");
		goto done;
	}

	if (NULL == psa || S_OK != SafeArrayAccessData(psa, (void **)&grVariant))
		goto done;	

	BOOL fError = FALSE;
	for ( UINT n = 0; n < m_ItemList.Count(); n++ )
	{
		grVariant[n*7+0].vt = VT_I4;
		grVariant[n*7+0].lVal = m_ItemList[n].dwStatus();
		grVariant[n*7+1].vt = VT_BSTR;
		grVariant[n*7+1].bstrVal = SysAllocString(m_ItemList[n].bstrID()); 
		grVariant[n*7+2].vt = VT_BSTR;
		grVariant[n*7+2].bstrVal = SysAllocString(m_ItemList[n].bstrProviderName()); 
		grVariant[n*7+3].vt = VT_BSTR;
		grVariant[n*7+3].bstrVal = SysAllocString(m_ItemList[n].bstrTitle()); 
		grVariant[n*7+4].vt = VT_BSTR;
		grVariant[n*7+4].bstrVal = SysAllocString(m_ItemList[n].bstrDescription()); 
		grVariant[n*7+5].vt = VT_BSTR;
		grVariant[n*7+5].bstrVal = SysAllocString(m_ItemList[n].bstrRTFPath()); 
		grVariant[n*7+6].vt = VT_BSTR;
		grVariant[n*7+6].bstrVal = SysAllocString(m_ItemList[n].bstrEULAPath()); 
		if ((NULL != m_ItemList[n].bstrID() && NULL == grVariant[n*7+1].bstrVal)
			|| (NULL != m_ItemList[n].bstrProviderName() && NULL == grVariant[n*7+2].bstrVal)
			|| (NULL != m_ItemList[n].bstrTitle() && NULL == grVariant[n*7+3].bstrVal)
			|| (NULL != m_ItemList[n].bstrDescription() && NULL == grVariant[n*7+4].bstrVal)
			|| (NULL != m_ItemList[n].bstrRTFPath() && NULL == grVariant[n*7+5].bstrVal)
			|| (NULL != m_ItemList[n].bstrEULAPath() && NULL == grVariant[n*7+6].bstrVal))
		{
			DEBUGMSG("OUT OF MEMORY, Fail to allocate string");
			fError = TRUE;
			break;
		}
	}
	if (FAILED(SafeArrayUnaccessData(psa)))
	{
		goto done;
		
	}
	if (!fError)
	{
		fRet = TRUE;
		pvarList->vt = VT_ARRAY | VT_VARIANT;
		pvarList->parray = psa;
	}
done:
    DEBUGMSG("AUCatalog::getUpdateList() ends");
	if (!fRet && NULL != psa)
	{
		SafeArrayDestroy(psa);
	}
	return (fRet ? S_OK : E_FAIL); 
}

//if udpate, meaning get updated information about existing items. Used in online validation. Treat exclusive and non exclusive the same
//if not update, meaning building a fresh new item list 
//return S_FALSE if nothing applicable
HRESULT AUCatalog::DetectItems(BOOL fUpdate )
{
    HRESULT hr;
    BSTR bstrNonDriverInstall = NULL, bstrDriverInstall = NULL;
    AUCatalogItemList  nonDriverList, driverList;
    BOOL fExclusiveItemFound = FALSE;
    BOOL fExclusiveDriverFound = FALSE;

    DEBUGMSG("CAUCatalog::DetectItems() starts");
    //clean up memory and local disk
    Clear();
    DelCatFiles(fUpdate);
    if (FAILED(hr = PrepareIU()))
        {
            DEBUGMSG("AUCatalog::DetectItems() fail to prepare IU %#lx", hr);
            goto done;
        }

    if (FAILED(hr = DetectNonDriverItems(&bstrNonDriverInstall, nonDriverList,  &fExclusiveItemFound)))
        {

        if (E_ABORT != hr)
            {
            DEBUGMSG(" fail to detect non driver updates %#lx", hr);
            }
        goto done;
        }
    DEBUGMSG("Non driver items got");

    if (m_fUpdateDriver)
     {
        if (FAILED(hr = DetectDriverItems(&bstrDriverInstall, driverList,  &fExclusiveDriverFound)))
            {
            if (E_ABORT != hr)
                {
                DEBUGMSG("fail to detect driver updates %#lx", hr);
                DEBUGMSG("consider driver update not essential, continue even if it fails");
                //consider driver update not essential, continue even if it fails
                m_fUpdateDriver = FALSE;  //from now on in this cycle do not care about driver any more
                }
            else
                {
                    goto done; //bail out if service shutdown
                }
            }
         DEBUGMSG("Driver items got");
        }
    else
        {
            DEBUGMSG("Driver updates not supported");
        }

    if (fExclusiveItemFound)
        {
        AUCatalogItemList dummydriverList;
        hr = MergeDetectionResult(NULL, dummydriverList, FALSE, bstrNonDriverInstall, nonDriverList, fExclusiveItemFound);
        DEBUGMSG("Exclusive item found");
        }
    else if (fExclusiveDriverFound)
        {
        AUCatalogItemList dummynonDriverList;
        hr = MergeDetectionResult(bstrDriverInstall, driverList, fExclusiveDriverFound, NULL, dummynonDriverList, FALSE);
        DEBUGMSG("Exclusive driver found");
        }
    else
        {
        hr = MergeDetectionResult(bstrDriverInstall, driverList, fExclusiveDriverFound, bstrNonDriverInstall, nonDriverList, fExclusiveItemFound);
        DEBUGMSG("Merge detection result for non driver and driver");
        }
            
    if (FAILED(hr))
    {
        DEBUGMSG("MergeDetectionResult fail with error %#lx", hr);
        goto done;
    }

    if (m_ItemList.Count() == m_ItemList.GetNumHidden())
        { //nothing to show to the user
            hr = S_FALSE;
            goto done;
        }
   
#ifdef DBG
//   m_ItemList.DbgDump();
#endif

    if (!fUpdate) 
        { 
            BSTR bstrNonDrivers;
            if (NULL == (bstrNonDrivers =ReadXMLFromFile(ITEM_FILE)))
            {
            DEBUGMSG("Fail to read item file ");
            goto done;
            }
            hr = BuildDependencyList(m_ItemList, bstrDriverInstall, bstrNonDrivers);
            SysFreeString(bstrNonDrivers);
            if (FAILED(hr))
            {
                DEBUGMSG("fail to build dependency list with error %#lx", hr);
                goto done;
            }
            hr = DownloadRTFsnEULAs(GetSystemDefaultLangID());
            DEBUGMSG("downloading RTF and EULAs %s", FAILED(hr)? "failed" : "succeeded");
            setExpireTime();
            Serialize();
        }
  done:
        FreeIU();
        SafeFreeBSTR(bstrNonDriverInstall);
        SafeFreeBSTR(bstrDriverInstall);
        if (FAILED(hr))
            {
                Clear();
            }
        DEBUGMSG("CAUCatalog::DetectItems() ends");
        return hr;
}

HRESULT AUCatalog::MergeDetectionResult(BSTR bstrDriverInstall, AUCatalogItemList & driverlist, BOOL fExclusiveDriverFound, BSTR bstrNonDriverInstall,  AUCatalogItemList & nondriverlist, BOOL fExclusiveItemFound)
{
    HRESULT hr= S_OK;
    UINT uDriverNum = driverlist.Count();
    UINT uNonDriverNum = nondriverlist.Count();

    UINT nums[2] = {uDriverNum, uNonDriverNum};
    AUCatalogItemList * pitemlists[2] = {&driverlist, &nondriverlist};

    if (fExclusiveDriverFound || fExclusiveItemFound)
        { //no merge needed
            DEBUGMSG("Exclusive driver or non driver found, no need to merge");
            AUCatalogItemList *pItemList = fExclusiveDriverFound ? &driverlist : & nondriverlist;
            BSTR bstrInstall = fExclusiveDriverFound? bstrDriverInstall : bstrNonDriverInstall;
            if (FAILED(hr = m_ItemList.Copy(*pItemList)))
                {
                goto done;
                }
            if (NULL == (m_bstrInstallation = SysAllocString(bstrInstall)))
                {
                    hr = E_OUTOFMEMORY;
                    DEBUGMSG("OUT of memory: fail to alloc string");
                    goto done;
                }
        }
    else
        {
            for (UINT j = 0; j < ARRAYSIZE(nums) ; j++)
                {
                for (UINT i = 0; i < nums[j]; i++)
                    {
                    AUCatalogItem * pItem = new AUCatalogItem((*pitemlists[j])[i]);
                    if (NULL == pItem)
                        {
                        DEBUGMSG("Fail to create item");
                        hr = E_FAIL;
                        goto done;
                        }
                    if (!pItem->fEqual((*pitemlists[j])[i]))
                    {
                    	DEBUGMSG("Fail to create item");
                    	hr = E_OUTOFMEMORY;
                    	delete pItem;
                    	goto done;
                    }
                    if (!m_ItemList.Add(pItem))
                    {
                    	hr = E_OUTOFMEMORY;
                    	delete pItem;
                    	goto done;
                    }
                    }
                }        
          hr = MergeCatalogs(bstrDriverInstall, bstrNonDriverInstall, &m_bstrInstallation);
        }

done:
    if (FAILED(hr))
        {
            Clear();
        }
    return hr;
}

// go through 1 cycle to detect driver items 
HRESULT AUCatalog::DetectDriverItems(OUT BSTR *pbstrInstall, OUT AUCatalogItemList &itemList,  BOOL *pfFoundExclusiveItem)
{
    HRESULT hr = S_OK;
    BSTR bstrManifest;

	if (NULL == pbstrInstall || NULL == pfFoundExclusiveItem)
	{
		return E_INVALIDARG;
	}
    DEBUGMSG("CAUCatalog detecting driver items...");
    *pbstrInstall = NULL;
    *pfFoundExclusiveItem = FALSE;
    itemList.Clear();
#ifdef DBG
     if (fDBGUseLocalFile())
        {
            DEBUGMSG("Use local file instead of going on line");
            if (NULL == (bstrManifest = ReadXMLFromFile(DRIVERS_FILE)))
                {
                DEBUGMSG("fail to get drivers from file %s", DRIVERS_FILE);
                hr = E_FAIL;
                goto end;
                }
        }
    else
#endif
		{
			if (FAILED(hr = GetManifest(DRIVERS_LEVEL, NULL, &bstrManifest)))
				{
			    DEBUGMSG(" Fail to get drivers manifest %#lx", hr);
			    goto end;
				}
			if (S_FALSE == hr)
			    { //no updates applicable

			    goto end;
			    }
		}

    *pbstrInstall = bstrManifest;
    if (!fExtractItemInfo(*pbstrInstall, itemList, pfFoundExclusiveItem))
        {
            DEBUGMSG("fail to extract information for driver items");
            hr = E_FAIL;
            goto end;
        }

#ifdef DBG
//        itemList.DbgDump();
#endif

end: 
    DEBUGMSG("CAUCatalog detecting driver items done");
    if (FAILED(hr))
    {
    	SafeFreeBSTRNULL(*pbstrInstall);
    	*pfFoundExclusiveItem = FALSE;
    	itemList.Clear();
    }
    return hr;
}


          

// go through 4 cycles to detect software items 
// get down manifest 
HRESULT AUCatalog::DetectNonDriverItems(OUT BSTR *pbstrInstall, OUT AUCatalogItemList &itemList, OUT BOOL *pfFoundExclusiveItem)
{
    HRESULT hr = S_OK;
    BSTR bstrManifest = NULL;
    BSTR bstrResult=NULL;

	if (NULL == pbstrInstall || NULL == pfFoundExclusiveItem)
	{
		return E_INVALIDARG;
	}
    DEBUGMSG("CAUCatalog detecting non driver items...");
    *pbstrInstall = NULL;
    *pfFoundExclusiveItem = FALSE;
    itemList.Clear();
#ifdef DBG
    if (fDBGUseLocalFile())
        {
            DEBUGMSG("Use local file instead of going on line");
            if (NULL == (bstrManifest = ReadXMLFromFile(DETAILS_FILE)))
                {
                hr = E_FAIL;
                DEBUGMSG("Fail to get item details from file %s", DETAILS_FILE);
                goto end;
                }
        }
    else
 #endif
        {
            for (int enLevel = MIN_LEVEL; enLevel <= MAX_LEVEL; enLevel++)
            {
            	DEBUGMSG("#%d pass", enLevel+1);
            	hr = GetManifest((DETECTLEVEL)enLevel, bstrResult, &bstrManifest);
            	SafeFreeBSTR(bstrResult);
            	if (FAILED(hr))
            	{
            		DEBUGMSG(" Fail to get %s %#lx", GetLevelStr((DETECTLEVEL)enLevel), hr);
            		goto end;
            	}
            	if (S_FALSE == hr)
            	    {
            	        goto end;
            	    }
            	DEBUGMSG("%s got", GetLevelStr((DETECTLEVEL)enLevel));
            	if (DETAILS_LEVEL != enLevel)
            	{
            	       DEBUGMSG("Doing detection........");
            		hr = DoDetection((DETECTLEVEL)enLevel, bstrManifest, &bstrResult);
            		SafeFreeBSTR(bstrManifest);
            		if (FAILED(hr))
            		{
            			DEBUGMSG("Fail to do detection %#lx", hr);
            			goto end;
            		}
            	}
            }
        }

     *pbstrInstall = bstrManifest;

    if (!fExtractItemInfo(bstrManifest, itemList, pfFoundExclusiveItem))
        {
            DEBUGMSG("Fail to extract item information for non drivers");
            hr = E_FAIL;
            goto end;
        }

#ifdef DBG
//            itemList.DbgDump();
#endif

   end: 
        DEBUGMSG("CAUCatalog detecting non driver items done");
        if (FAILED(hr))
        {
        	SafeFreeBSTRNULL(*pbstrInstall);
        	*pfFoundExclusiveItem = FALSE;
		    itemList.Clear();
		}
		if (gpState->fInCorpWU())
		{
			if (SUCCEEDED(hr))
			{
				gPingStatus.PingDetectionSuccess(TRUE, itemList.Count());
			}
			else
			{
				gPingStatus.PingDetectionFailure(TRUE, hr);
			}
		}
        return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////////
// delete all local cat log files we might use to do offline operation, including item.xml details.xml, 
// mergedcatalog.xml, drivers.xml and catalog.xml. If not fUpdate (i.e., will build everything from scratch), also clean up RTFs and Cabs
/////////////////////////////////////////////////////////////////////////////////////////////
void AUCatalog::DelCatFiles(BOOL fUpdate)
{
    TCHAR tszPath[MAX_PATH];
    TCHAR tszFullFileName[MAX_PATH];

    DEBUGMSG("DelCatFiles()");
#ifdef DBG
    if (fDBGUseLocalFile())
        {
            DEBUGMSG("When use local file in debugging mode, do not delete local catalog files");
            return;
        }
    else
#endif
    {
        AUASSERT(_T('\0') != g_szWUDir[0]);
   		if (FAILED(StringCchCopyEx(tszPath, ARRAYSIZE(tszPath) , g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
   		 {
  	      return;
  		 }

   		LPCTSTR FILES_TO_DELETE[] = {ITEM_FILE, DRIVERS_FILE, DETAILS_FILE, 
#ifdef DBG
        DETECT1_FILE, DETECT2_FILE, DETECT3_FILE, DRIVER_SYSSPEC_FILE, NONDRIVER_SYSSPEC_FILE,
		PROVIDER_FILE, PRODUCT_FILE, INSTALL_FILE,
#endif
            CATALOG_FILE };
    	for (int i = 0;  i< ARRAYSIZE(FILES_TO_DELETE); i++)
        {
            if (SUCCEEDED(StringCchCopyEx(tszFullFileName, ARRAYSIZE(tszFullFileName) , tszPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
				SUCCEEDED(StringCchCatEx(tszFullFileName, ARRAYSIZE(tszFullFileName), FILES_TO_DELETE[i], NULL, NULL, MISTSAFE_STRING_FLAGS)))
			{
				AUDelFileOrDir(tszFullFileName);
			}
        }
            
    	if (!fUpdate)
        {
             TCHAR tszDownloadTmpDir[MAX_PATH];

            if (SUCCEEDED(GetDownloadPath(tszDownloadTmpDir, ARRAYSIZE(tszDownloadTmpDir))))
            {
	            DelDir(tszDownloadTmpDir);
	            RemoveDirectory(tszDownloadTmpDir);
            }
        }
	}
}


////////////////////////////////////////////
// caller needs to free the returned BSTR
////////////////////////////////////////////
BSTR GetCatalogFile(void)
{
    TCHAR szFile[MAX_PATH];
    AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(StringCchCopyEx(szFile, ARRAYSIZE(szFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS))||
		FAILED(StringCchCatEx(szFile, ARRAYSIZE(szFile), CATALOG_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)))
        {
            return NULL;
        }
    return SysAllocString(T2W(szFile));
}

    
//=======================================================================
//
//  AUCatalog::Serialize
//
//=======================================================================
HRESULT AUCatalog::Serialize(void)
{
    HRESULT hr = S_OK;
	DEBUGMSG("WUAUENG: serializing");
	BSTR bstrCatFile = NULL ;
    IXMLDOMDocument *pxmlCatalog = NULL;
    IXMLDOMElement *pelemAUCATALOG = NULL;
  
    AU_VARIANT  varValueVERSION(CATALOG_XML_VERSION);
    AU_VARIANT  varValueDOWNLOADID(m_audownloader.getID());
    AU_VARIANT  varValueITEMCOUNT(m_ItemList.Count());
    AU_VARIANT  varValueUpdateDriver(m_fUpdateDriver);


    if (NULL == (bstrCatFile = GetCatalogFile()))
    {
    	DEBUGMSG("Fail to get catalog file with error %#lx", hr);
    	goto done;
    }

    AUDelFileOrDir(W2T(bstrCatFile)); //delete old catalog file


	if ( FAILED(hr = CoCreateInstance(__uuidof(DOMDocument), NULL, CLSCTX_INPROC_SERVER,
                                      __uuidof(IXMLDOMDocument), (void**)&pxmlCatalog)) ||
         FAILED(hr = pxmlCatalog->createElement(bstrTagAUCATALOG, &pelemAUCATALOG)) ||
         FAILED(hr = pelemAUCATALOG->setAttribute(bstrAttrVERSION, varValueVERSION)) ||
         FAILED(hr = pelemAUCATALOG->setAttribute(bstrAttrDOWNLOADID, varValueDOWNLOADID)) ||
         FAILED(hr = pelemAUCATALOG->setAttribute(bstrAttrITEMCOUNT, varValueITEMCOUNT)) ||
         FAILED(hr = pelemAUCATALOG->setAttribute(bstrAttrUpdateDriver, varValueUpdateDriver)) ||
         FAILED(hr = pxmlCatalog->appendChild(pelemAUCATALOG, NULL)) )
	{
		DEBUGMSG("Fail to create Catalog.xml");
		goto done;
	}

        VARIANT varValueID;
        VARIANT varValueSTATUS;
        varValueID.vt = VT_BSTR;
        varValueSTATUS.vt = VT_I4;

    // write out item information
	for ( DWORD index = 0; index < m_ItemList.Count(); index++ )
	{
        IXMLDOMElement *pelemITEM = NULL;
        varValueID.bstrVal = m_ItemList[index].bstrID();
        varValueSTATUS.lVal = m_ItemList[index].dwStatus();
//        DEBUGMSG("Status is %d for item %S", varValueSTATUS.lVal, m_ItemList[index].bstrID());

        if ( FAILED(hr = pxmlCatalog->createElement(bstrTagITEM, &pelemITEM)) ||
             FAILED(hr = pelemITEM->setAttribute(bstrAttrID, varValueID)) ||
             FAILED(hr = pelemITEM->setAttribute(bstrAttrSTATUS, varValueSTATUS)) ||
             FAILED(hr = pelemAUCATALOG->appendChild(pelemITEM, NULL)) )
        {
            SafeRelease(pelemITEM);
            goto done;
        }
        SafeRelease(pelemITEM);
	}

     if ( FAILED(hr = SaveDocument(pxmlCatalog, bstrCatFile)))
    {
        DEBUGMSG("saving of %S failed, hr = %#lx", bstrCatFile, hr);
        if ( SUCCEEDED(hr) )
        {
            hr = E_FAIL;
        }
        goto done;
    }

done:
	if (FAILED(hr) && NULL != bstrCatFile)
   	{
   		AUDelFileOrDir(bstrCatFile);
   	}	
    SafeFreeBSTR(bstrCatFile);
	SafeRelease(pelemAUCATALOG);
   	SafeRelease(pxmlCatalog);
	return hr;
}

//=======================================================================
//
// AUCatalog::Unserialize
//
//=======================================================================
HRESULT AUCatalog::Unserialize()
{
//    USES_CONVERSION;
    DEBUGMSG("WUAUENG: unserializing");

    HRESULT hr = S_OK;
    IXMLDOMDocument *pxmlCatalog = NULL;
    IXMLDOMNodeList *pitemnodes = NULL;
    IXMLDOMNode *pcatalog = NULL;
    BSTR bstrCatFile = NULL;
    long lVersion;
    long lItemCount;
    BSTR bstrDownloadId = NULL;
    GUID downloadId;

    if (NULL == (bstrCatFile = GetCatalogFile()))
    {
    	DEBUGMSG("Fail to get catalog file with error %#lx", hr);
    	goto done;
    }
    if ( FAILED(hr = LoadDocument(bstrCatFile, &pxmlCatalog, TRUE)))
    {
        DEBUGMSG("Could not Load catalog file with error %#lx",  hr);
        goto done;
    }

    //get catalog node (root)
    if (!FindNode(pxmlCatalog, bstrTagAUCATALOG, &pcatalog))
        {
        hr = E_FAIL;
        DEBUGMSG("fail to find catalog node ");
        goto done;
        }
    
    // get version
    if ( FAILED(hr = GetAttribute(pcatalog, bstrAttrVERSION, &lVersion)))
    {
        DEBUGMSG("Fail to get version with error %#lx", hr);
        goto done;
    }

    DEBUGMSG("Catalog Version Number is %d", lVersion);

    if ( CATALOG_XML_VERSION !=  lVersion )
    {
        DEBUGMSG("invalid XML version");
        hr = E_FAIL;
        goto done;
    }

    // get DOWNLOADID
    if ( FAILED(hr = GetAttribute(pcatalog, bstrAttrDOWNLOADID, &bstrDownloadId)) ||
         FAILED(hr = CLSIDFromString(bstrDownloadId, &downloadId)))
    {
        DEBUGMSG("failed to get download id with error %#lx", hr);
        goto done;
    }

    if (GUID_NULL != downloadId)
    {
        m_audownloader.setID(downloadId);
        m_fNeedToContinueJob = TRUE;
    }
    // get ITEMCOUNT
    if ( FAILED(hr = GetAttribute(pcatalog, bstrAttrITEMCOUNT, &lItemCount)))
    {
        DEBUGMSG("failed to get item count with error %#lx", hr);
        goto done;
    }

	if (m_fUpdateDriver)
	{
	    if (FAILED(hr = GetAttribute(pcatalog, bstrAttrUpdateDriver, &m_fUpdateDriver)))
	    {
	    	DEBUGMSG("failed to get fUpdateDriver with error %#lx", hr);
	    	goto done;
	    }
	}

    DEBUGMSG("Catalog item count is %d", lItemCount);

    if (FAILED(hr = m_ItemList.Allocate(lItemCount)))
        {
          DEBUGMSG("Out of memory, fail to allocate item list");
          goto done;
        }

    if ( NULL == (pitemnodes = FindDOMNodeList(pcatalog, bstrTagITEM)))
    {
        hr = E_FAIL;
        DEBUGMSG("Fail to find items in the catalog ");
        goto done;
    }

    // read in item list
    for ( DWORD index = 0; index < m_ItemList.Count(); index++ )
    {
        IXMLDOMNode *pitemnode = NULL;
        if ( S_OK != (hr = pitemnodes->get_item(index, &pitemnode)) )
        {
            DEBUGMSG("failed to get item node %d", index);
            hr = FAILED(hr) ? hr : E_FAIL;
            goto done;
        }

        // get ID
        if ( FAILED(hr = GetAttribute(pitemnode, bstrAttrID, &(m_ItemList[index].m_bstrID))))
        {
            DEBUGMSG("Fail to find ID for item %d", index);
            SafeRelease(pitemnode);
            goto done;
        }

       
        // get STATUS
        if ( FAILED(hr = GetAttribute(pitemnode, bstrAttrSTATUS, (long*)(&(m_ItemList[index].m_dwStatus)))))
        {
            DEBUGMSG("Fail to find status for item %d with error %#lx", index, hr);
            SafeRelease(pitemnode);
            goto done;
        }
//        DEBUGMSG("item %S status is %d", m_ItemList[index].m_bstrID, m_ItemList[index].m_dwStatus);

        pitemnode->Release();
    }

    //populate m_ItemList with other information than itemID and status
     hr = GetDetailedItemInfoFromDisk(m_ItemList, &m_bstrInstallation, m_fUpdateDriver);
done:
    SafeFreeBSTR(bstrDownloadId);
    SafeFreeBSTR(bstrCatFile);
    SafeRelease(pcatalog);
    SafeRelease(pitemnodes);
    SafeRelease(pxmlCatalog);
    if (FAILED(hr))
	{
	     DelCatFiles();
         Clear();
	}
    DEBUGMSG("WUAUENG unserializing done with result %#lx", hr);
    return hr;
}

//only download RTFs for now
HRESULT AUCatalog::DownloadRTFsnEULAs(LANGID langid)
{
    BSTR bstrRTFUrl, bstrEULAUrl;
    TCHAR tszLocalRTFDir[MAX_PATH];
    HRESULT hr;

    if (FAILED(hr = GetRTFDownloadPath(tszLocalRTFDir, ARRAYSIZE(tszLocalRTFDir), langid)))
        {
        DEBUGMSG("Fail to get RTF download path %#lx", hr);
        goto done;
        }
    DEBUGMSG("Got RTF path %S", tszLocalRTFDir);
    UINT uItemCount = m_ItemList.Count();
//    DEBUGMSG("Downloading %d RTFs", uItemCount);
    for (UINT i = 0; i<uItemCount; i++)
    {
        AUCatalogItem & item = (m_ItemList)[i];
        if (item.fSelected())
        {
            bstrRTFUrl = item.bstrRTFPath();
            if (NULL != bstrRTFUrl)
            {
                HRESULT hr1 =DownloadFile(bstrRTFUrl, tszLocalRTFDir,NULL, NULL, &ghServiceFinished, 1, NULL,NULL, WUDF_SKIPCABVALIDATION);                
                DEBUGMSG("download RTF file from %S to %S %s (with error %#lx)", bstrRTFUrl, tszLocalRTFDir, FAILED(hr1)? "failed" : "succeeded", hr1);
                if(SUCCEEDED(hr1))
                {
                    ValidateDownloadedRTF(bstrRTFUrl, m_ItemList[i].bstrID());
                }
            }
        }
    }
done:
        return hr;
}

DWORD AUCatalog::GetNumSelected(void)
{
    UINT uItemNum = m_ItemList.Count();
    DWORD dwSelectedNum = 0;
    for (UINT i = 0; i < uItemNum; i++)
        {
        AUCatalogItem &item = m_ItemList[i];
        if (item.fSelected())
            {
            dwSelectedNum++;
            }
        }
    return dwSelectedNum;
}

//=======================================================================
//
//  AUCatalog::GetInstallXML
//
//=======================================================================
HRESULT AUCatalog::GetInstallXML(BSTR *pbstrCatalogXML, BSTR *pbstrDownloadXML)
{
	DEBUGMSG("AUCatalog::GetInstallXML");
    HRESULT hr = S_OK;


    PersistHiddenItems(m_ItemList, URLLOGACTIVITY_Installation);
    if (m_ItemList.GetNumSelected() == 0)
        {
            DEBUGMSG("Nothing to install");
            hr = S_FALSE;
            goto end;
        }
                
    if (S_OK != (hr = ValidateItems(FALSE/*, TRUE*/)))
        {
            DEBUGMSG("Invalid catalog with error %#lx or no items", hr);
            hr = E_FAIL;
            goto end;
        }

    if (NULL == m_bstrInstallation )
	{
	    DEBUGMSG(" can't get installation xml or download result xml");
	    hr = E_FAIL;
	    goto end;
	}

    hr = PrepareInstallXML(m_bstrInstallation, m_ItemList, pbstrDownloadXML, pbstrCatalogXML);
#ifdef DBG
    if (SUCCEEDED(hr))
        {
        LOGXMLFILE(INSTALL_FILE, *pbstrCatalogXML); //download xml is logged by client
        }
#endif
end:
	return hr;
}

//=======================================================================
//
//  AUCatalog::FindItemIdByLocalFileName
//  return value should not be freed
//=======================================================================
BSTR AUCatalog::FindItemIdByLocalFileName(LPCWSTR pwszLocalFileName)
{
	CItemDetails itemdetails;

	if (NULL == pwszLocalFileName ||
		0 == m_ItemList.GetNumSelected() ||
		NULL == m_bstrInstallation ||
		!itemdetails.Init(m_bstrInstallation))
	{
		DEBUGMSG("AUCatalog::FindItemIdByLocalFileName bad params or failed to init CItemDetails");
		return NULL;
	}

	UINT uItemCount = m_ItemList.Count();
	BSTR bstrResult = NULL;
	BOOL fDone = FALSE;

	for (UINT i = 0; i < uItemCount && !fDone; i++)
	{
		AUCatalogItem &item = m_ItemList[i];

		if (item.fSelected() || m_ItemList.ItemIsRelevant(i))
		{
			BSTR bstrItemId = item.bstrID();
			BSTR bstrItemDownloadPath = itemdetails.GetItemDownloadPath(bstrItemId);

			if (NULL == bstrItemDownloadPath)
			{
				DEBUGMSG("AUCatalog::FindItemIdByLocalFileName fail to build item downloadPath for %S", bstrItemId);
				fDone = TRUE;
			}
			else
			{
				BSTR *pCRCCabNames  = NULL;
				BSTR *pRealCabNames = NULL;
                BSTR *pCabChecksums = NULL;
				UINT uCabsNum;

				if (FAILED(itemdetails.GetCabNames(bstrItemId, &pCRCCabNames, &pRealCabNames, &pCabChecksums, &uCabsNum)))
				{
					DEBUGMSG("AUCatalog::FindItemIdByLocalFileName fail to get cab names for %S", bstrItemId);
					fDone = TRUE;
				}
				else
				{
					for (UINT j = 0; j < uCabsNum; j++)
					{
						WCHAR wszFullFileName[MAX_PATH];

						if (!fDone &&
							SUCCEEDED(PathCchCombineW(
										wszFullFileName,
                                        ARRAYSIZE(wszFullFileName),
										bstrItemDownloadPath,
										pRealCabNames[j])) &&
							0 == StrCmpIW(wszFullFileName, pwszLocalFileName))
						{
							DEBUGMSG("AUCatalog::FindItemIdByLocalFileName found item");
							bstrResult = bstrItemId;
							fDone = TRUE;
						}

						SafeFreeBSTR(pCRCCabNames[j]);
						SafeFreeBSTR(pRealCabNames[j]);
                        SafeFreeBSTR(pCabChecksums[j]);
					}

					SafeFree(pCRCCabNames);
					SafeFree(pRealCabNames);
                    SafeFree(pCabChecksums);
				}

				SysFreeString(bstrItemDownloadPath);
			}
		}
    }

	itemdetails.Uninit();
	return bstrResult;
}


//=======================================================================
////  AUCatalog::ValidateDownloadedCabs
//    The OUT parameter (itemid) will be NULL if no error or if the error 
//    is other than ERROR_CRC
//=======================================================================
HRESULT AUCatalog::ValidateDownloadedCabs(BSTR *pbstrErrorItemId)
{
    HRESULT hr = E_FAIL;
	CItemDetails itemdetails;

    AUASSERT(NULL != m_bstrInstallation);
    if(NULL == pbstrErrorItemId)
    {
        return E_INVALIDARG;
    }
    *pbstrErrorItemId = NULL;

    //if no items selected or if failed to load install xml
    if (0 == m_ItemList.GetNumSelected() || 
        !itemdetails.Init(m_bstrInstallation))
	{
		return hr;
	}

	UINT uItemCount = m_ItemList.Count();
    BOOL fError = FALSE;

    BSTR *pCRCCabNames = NULL;
	BSTR *pRealCabNames = NULL;
    BSTR *pCabChecksums = NULL;
	UINT uCabsNum = 0;

	for (UINT i = 0; i < uItemCount && !fError; i++)
	{
        if (!m_ItemList[i].fSelected() && !m_ItemList.ItemIsRelevant(i))
		{
            continue;
        }
		BSTR bstrItemId = m_ItemList[i].bstrID();
		BSTR bstrItemDownloadPath = itemdetails.GetItemDownloadPath(bstrItemId);
        if( NULL == bstrItemDownloadPath)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

		if (FAILED(hr = itemdetails.GetCabNames(bstrItemId, &pCRCCabNames, &pRealCabNames, &pCabChecksums, &uCabsNum)))
		{
            SysFreeString(bstrItemDownloadPath);
            break;
		}

        //Iterate through all the cabs in an item
		for (UINT j = 0; j < uCabsNum; j++)
		{
            //If no error and CRC exists
            if(!fError && NULL != pCabChecksums[j])
            {
			    WCHAR wszFullFileName[MAX_PATH+1];
			    if (SUCCEEDED(hr = PathCchCombineW(wszFullFileName, ARRAYSIZE(wszFullFileName), bstrItemDownloadPath, pRealCabNames[j])))
                {
                    if(FAILED(hr = VerifyFileCRC(wszFullFileName, pCabChecksums[j])))
                    {
                        fError = TRUE;
                        if(hr == HRESULT_FROM_WIN32(ERROR_CRC))
                        {
                            *pbstrErrorItemId = bstrItemId;
                        }
                        DEBUGMSG("Checksum Failed for file %S", wszFullFileName);
                    }
                }
                else
                {
                    fError = TRUE;
                }
            }
            //Free up memory
            SafeFreeBSTR(pCRCCabNames[j]);
            SafeFreeBSTR(pRealCabNames[j]);
            SafeFreeBSTR(pCabChecksums[j]);
        }
        
        SafeFreeNULL(pCRCCabNames);
        SafeFreeNULL(pRealCabNames);
        SafeFreeNULL(pCabChecksums);

        SysFreeString(bstrItemDownloadPath);
    }
    itemdetails.Uninit();
	return hr;
}

void AUCatalog::ValidateDownloadedRTF(BSTR bstrRTFUrl, BSTR bstrItemId)
{
    CItemDetails itemdetails;
    BSTR bstrCRC = NULL;
    TCHAR szRTFName[MAX_PATH+1];

    AUASSERT(NULL != bstrItemId && NULL != bstrRTFUrl && NULL != m_bstrInstallation);

    //if failed to load install xml
    if (itemdetails.Init(m_bstrInstallation) &&
        SUCCEEDED(itemdetails.GetRTFCRC(bstrItemId, &bstrCRC)) &&
        SUCCEEDED(GetRTFLocalFileName(bstrRTFUrl, szRTFName, ARRAYSIZE(szRTFName), GetSystemDefaultLangID())) &&
        HRESULT_FROM_WIN32(ERROR_CRC) == VerifyFileCRC(szRTFName, bstrCRC))
    {
        DEBUGMSG("Checksum Failed for RTF %S, deleting it.", szRTFName);
        DeleteFile(szRTFName);
    }

    SafeFreeBSTR(bstrCRC);
    itemdetails.Uninit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\aucpl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aucpl.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

HINSTANCE  g_hInstance = NULL;
LONG       g_cRefDll    = 0;

// {5F327514-6C5E-4d60-8F16-D07FA08A78ED}
//DEFINE_GUID(CLSID_AutoUpdatePropSheet,
//0x5f327514, 0x6c5e, 0x4d60, 0x8f, 0x16, 0xd0, 0x7f, 0xa0, 0x8a, 0x78, 0xed);

class __declspec(uuid("5f327514-6c5e-4d60-8f16-d07fa08a78ed")) CAutoUpdatePropSheet;
                        
//-----------------------------------------------------------------------------
// COM server class factory.
//-----------------------------------------------------------------------------
class CAutoUpdateClassFactory : IClassFactory
{
    public:
        ~CAutoUpdateClassFactory(void);
        //
        // IUnknown methods
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IClassFactory methods
        //
        STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void **ppvOut);
        STDMETHOD(LockServer)(BOOL);
        //
        // Instance generator.
        //
        static HRESULT CreateInstance(REFIID riid, void **ppvOut);

    private:
        LONG m_cRef;
        //
        // Force use of instance generator.
        //
        CAutoUpdateClassFactory(void);
        //
        // Prevent copy.
        //
        CAutoUpdateClassFactory(const CAutoUpdateClassFactory& rhs);              // not implemented.
        CAutoUpdateClassFactory& operator = (const CAutoUpdateClassFactory& rhs); // not implemented.
};


//
// Instance generator.
//
HRESULT
CAutoUpdateClassFactory::CreateInstance(  // [static]
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CAutoUpdateClassFactory *pFactory = new CAutoUpdateClassFactory();
    if (NULL != pFactory)
    {
        hr = pFactory->QueryInterface(riid, ppvOut);
        pFactory->Release();
    }
    return hr;
}



CAutoUpdateClassFactory::CAutoUpdateClassFactory(void)
    : m_cRef(1)
{
    DllAddRef();
}



CAutoUpdateClassFactory::~CAutoUpdateClassFactory(void)
{
    DllRelease();
}



STDMETHODIMP
CAutoUpdateClassFactory::QueryInterface(
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IClassFactory == riid || IID_IUnknown == riid)
    {
        *ppvOut = static_cast<IClassFactory *>(this);
    }
    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }
    return hr;
}



STDMETHODIMP_(ULONG) CAutoUpdateClassFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG) CAutoUpdateClassFactory::Release(void)
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}



STDMETHODIMP
CAutoUpdateClassFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = CLASS_E_NOAGGREGATION;

	if (NULL == ppvOut)
	{
		return E_INVALIDARG;
	}
    *ppvOut = NULL;

    if (NULL == pUnkOuter)
    {
        if (IID_IShellExtInit == riid ||
            IID_IShellPropSheetExt == riid ||
            IID_IUnknown == riid)
        {
            hr = CAutoUpdatePropSheet_CreateInstance(g_hInstance, riid, ppvOut);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}



STDMETHODIMP
CAutoUpdateClassFactory::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Standard COM server exports.
//-----------------------------------------------------------------------------

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

	if (NULL == ppvOut)
	{
		return E_INVALIDARG;
	}
    *ppvOut = NULL;

    if (__uuidof(CAutoUpdatePropSheet) == rclsid)
    {
        hr = CAutoUpdateClassFactory::CreateInstance(riid, ppvOut);
    }
    return hr;
}



STDAPI DllCanUnloadNow(void)
{
    HRESULT hr = (0 == g_cRefDll ? S_OK : S_FALSE);
    return hr;
}



STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefDll);
}



STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cRefDll);
}



BOOL APIENTRY 
DllMain( 
    HANDLE hModule, 
    DWORD  dwReason, 
    LPVOID /*lpReserved*/
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = (HINSTANCE)hModule;
            DisableThreadLibraryCalls(g_hInstance);
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
	    break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\aucpl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aucpl.h
//
//--------------------------------------------------------------------------

#pragma once

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

extern HINSTANCE  g_hInstance;

class AUSetup {
public:
	HRESULT m_SetupNewAU(void);
private:
	static const LPCTSTR mc_WUFilesToDelete[] ;
	static const LPCTSTR mc_WUDirsToDelete[];
	void mi_CleanUpWUDir();
	HRESULT mi_CreateAUService(BOOL fStandalone);
//    BOOL m_IsWin2K(); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\audownload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       catalog.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


extern CLIENT_HANDLES  ghClientHandles;
extern ENGINE_EVENTS EngineEvents;

const WCHAR AUJOBNAME[] = L"Windows Update";


void DoDownloadStatus(
					DWORD dwDownloadMsg,
					IBackgroundCopyJob *pBGJob,
					IBackgroundCopyError *pBGErr)
{
	DEBUGMSG("WUAUENG DoDownloadStatus!");

    switch(dwDownloadMsg)
    {
		case CATMSG_TRANSIENT_ERROR:
			{
#ifdef DBG
				if (NULL == pBGErr &&
					S_OK != pBGJob->GetError(&pBGErr))
				{
//					break;
				}
				else
				{
        				HRESULT hrErr;
        				BG_ERROR_CONTEXT bgErrContext;

        				// Formulate error message
        				(void) pBGErr->GetError(&bgErrContext, &hrErr);
        				DEBUGMSG("WUAUENG DoDownloadStatus - TRANSIENT_ERROR %#lx (context=%d)", hrErr, bgErrContext);
        				pBGErr->Release();
				}
#endif
				EngineEvents.SetEvent(IDOWNLOAD_TRANSIENT_ERROR_EVT); 				
			}
			break;
		case CATMSG_DOWNLOAD_IN_PROGRESS:
			{
				DEBUGMSG("WUAUENG DoDownloadStatus - DOWNLOAD_IN_PROGRESS");
				EngineEvents.SetEvent(IDOWNLOAD_DOWNLOAD_IN_PROGRESS);
			}
			break;
        case CATMSG_DOWNLOAD_COMPLETE:            // Ping required
			{
				// Send ping for each successfully downloaded item.
				DEBUGMSG("WUAUENG DoDownloadStatus - file download done");
				EngineEvents.SetEvent(IDOWNLOAD_COMPLETE_EVT);
			}
			break;
		case CATMSG_DOWNLOAD_ERROR:
            {
				DEBUGMSG("WUAUENG DoDownloadStatus - DOWNLOAD_ERROR");
				//DEBUGMSG("WUAUENG DoDownloadStatus() ping error puid %d and error description %S", ptDownloadStatusData->m_errPuid, ptDownloadStatusData->m_tszErrDesc);

				IBackgroundCopyFile *pBGFile = NULL;

				// Found out which item caused the download error
				if (SUCCEEDED(pBGErr->GetFile(&pBGFile)))
				{
					BSTR bstrErrorItemId;	// only used if dwDownloadMsg == CATMSG_DOWNLOAD_ERROR
					LPWSTR pwszLocalFileName = NULL;

					(void) pBGFile->GetLocalName(&pwszLocalFileName);

					// Ping for download failure
					if (NULL != (bstrErrorItemId = gpAUcatalog->FindItemIdByLocalFileName(pwszLocalFileName)))
					{
						HRESULT hrErr;
						BG_ERROR_CONTEXT bgErrContext;
						TCHAR tszMessage[30];

						// Formulate error message
						(void) pBGErr->GetError(&bgErrContext, &hrErr);
                        (void)StringCchPrintfEx(tszMessage, ARRAYSIZE(tszMessage), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("ctx=%d"), bgErrContext);
						gPingStatus.PingDownload(
							FALSE,
							URLLOGSTATUS_Failed,
							hrErr,
							W2T(bstrErrorItemId),
							NULL,
							tszMessage);
					}
					CoTaskMemFree(pwszLocalFileName);

					pBGFile->Release();
				}
#ifdef DBG
				else
				{
					DEBUGMSG("WUAUENG DoDownloadStatus failed to get IBackgroundCopyFile object");
				}
#endif
			}
			break;
        default:
            DEBUGMSG("WUAUENG DoDownloadStatus - invalid message");
            break;
    }
}


CAUDownloader::~CAUDownloader()
{
       IBackgroundCopyJob  * pjob;
       HRESULT hr ;
	// fixcode optimization check if m_refs != 0
	DEBUGMSG("CAUDownloader::~CAUDownloader() starts");
	
	if ( SUCCEEDED(FindDownloadJob(&pjob)))
	{
		DEBUGMSG("Found bits notify interface to release");
		if (FAILED(hr = pjob->SetNotifyInterface(NULL)))
		{
			DEBUGMSG(" failed to delete job notification interface %#lx", hr);
		}
		pjob->Release();
	}

	if ( FAILED(hr = CoDisconnectObject((IUnknown *)this, 0)) )
	{
		DEBUGMSG("CoDisconnectObject() failed %#lx", hr);
	}

	DEBUGMSG("WUAUENG: CAUDownloader destructed with m_refs = %d", m_refs);
}	

///////////////////////////////////////////////////////////////////////////////////
// when service starts up, find last download job if there is one and reconnect AU to drizzle 
//////////////////////////////////////////////////////////////////////////////////
HRESULT CAUDownloader::ContinueLastDownloadJob(/*const GUID & downloadid*/)
{	
    HRESULT hr = E_FAIL;
    IBackgroundCopyJob * pjob = NULL;
    DEBUGMSG("CAUDownloader::ContinueLastDownloadJob() starts");
       if (GUID_NULL != m_DownloadId)
        {
            if (SUCCEEDED(hr = FindDownloadJob(&pjob)) && SUCCEEDED(hr = ReconnectDownloadJob()))
                {
                DEBUGMSG("found and connected to previous download job ");
                goto done;
                }
            else
                {
                DEBUGMSG("fail to find or connect to previous download job");
                m_DownloadId = GUID_NULL;
                }
       }
done:           
       SafeRelease(pjob);
       DEBUGMSG("CAUDownloader::ContinueLastDownloadJob() ends");
	return hr;
}


HRESULT CAUDownloader::CreateDownloadJob(IBackgroundCopyJob **ppjob)
{
    IBackgroundCopyManager * pmanager = NULL;
    HRESULT hr;

    *ppjob = NULL;
     m_DownloadId = GUID_NULL;
    if (FAILED(hr = CoCreateInstance(__uuidof(BackgroundCopyManager),
                                     NULL,
                                     CLSCTX_LOCAL_SERVER,
                                     __uuidof(IBackgroundCopyManager),
                                     (void **)&pmanager )))
     {
       DEBUGMSG("CreateDownloadJob : create manager failed %x ", hr);
       goto done;
     }

    if (FAILED(hr=pmanager->CreateJob( AUJOBNAME ,
                                      BG_JOB_TYPE_DOWNLOAD,
                                      &m_DownloadId,
                                      ppjob )))
      {
        DEBUGMSG("CreateDownloadJob : create job failed %x ", hr);
        goto done;
      }

    {
    DWORD fFullBandwidth = 0;;

    // change job priority to full bandwidth if appropriate reg key set.
	if ( SUCCEEDED(GetRegDWordValue(L"FullBandwidth", &fFullBandwidth)) && fFullBandwidth )
    {
        HRESULT hr1 = (*ppjob)->SetPriority(BG_JOB_PRIORITY_FOREGROUND);
        DEBUGMSG("CAUDownloader::CreateDownloadJob -- FULL BANDWIDTH, hr = %#lx", hr1);
    }
    }

#ifdef DBG
	WCHAR szGUID[50]; //really need 39 bytes
	int iret;
	
	iret = StringFromGUID2(m_DownloadId, //GUID to be converted  
						szGUID,  //Pointer to resulting string
						ARRAYSIZE(szGUID));//Size of array at lpsz
	if (0 != iret)
	{
		DEBUGMSG("WUAUENG m_DownloadId = %S", szGUID);
	}
#endif

	if (FAILED(hr = SetDrizzleNotifyInterface()))
        {
        DEBUGMSG("CreateDownloadJob : set notification interface failed %x", hr);
    	}
done:
       SafeRelease(pmanager);
	if (FAILED(hr))
	{
        Reset();
        SafeReleaseNULL(*ppjob);
        }
        return hr;
}


HRESULT CAUDownloader::FindDownloadJob(IBackgroundCopyJob ** ppjob)
{
    IBackgroundCopyManager * pmanager = NULL;
    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(__uuidof(BackgroundCopyManager),
                                     NULL,
                                     CLSCTX_LOCAL_SERVER,
                                     __uuidof(IBackgroundCopyManager),
                                     (void **)&pmanager )))
        {
        DEBUGMSG("FindDownloadJob : create manager failed %x ", hr);
        goto done;
        }

    if (FAILED(hr=pmanager->GetJob(m_DownloadId, ppjob )))
        {
        //            DEBUGMSG("FindDownloadJob : get job failed %x ", hr); //might be expected
        }
done:
    SafeRelease(pmanager);
    return hr;
}



STDMETHODIMP
CAUDownloader::JobTransferred(
    IBackgroundCopyJob * pjob
    )
{
    HRESULT hr;

#if DBG
    //
    // Make sure the right job is finished.
    //
    {
    GUID jobId;

    if (FAILED( hr= pjob->GetId( &jobId )))
        {
        return hr;
        }

    if ( jobId != m_DownloadId )
        {
        DEBUGMSG("notified of completion of a download job that I don't own");
        }
    }
#endif

    //
    // Transfer file ownership from downloader to catalogue.
    //
    if (FAILED(hr= pjob->Complete()))
        {
        return hr;
        }

    m_DoDownloadStatus(CATMSG_DOWNLOAD_COMPLETE, pjob);

    m_dwJobState = NO_BG_JOBSTATE;	
    m_DownloadId = GUID_NULL;
    return S_OK;
}

STDMETHODIMP
CAUDownloader::JobError(
    IBackgroundCopyJob * pjob,
    IBackgroundCopyError * perror
    )
{
    // download encounter error
	m_DoDownloadStatus(CATMSG_DOWNLOAD_ERROR, pjob, perror);

	HRESULT hr;
	BG_ERROR_CONTEXT bgEContext;
	if (SUCCEEDED(perror->GetError(&bgEContext, &hr)))
	{
		DEBUGMSG("WUAUNEG JobError callback Context = %d, hr = 0x%x",bgEContext, hr);
	}

       Reset();
       m_FinishReason = JOB_ERROR;
       return S_OK;
}

STDMETHODIMP
CAUDownloader::JobModification(
    IBackgroundCopyJob * pjob,
    DWORD  /*dwReserved*/
    )
{
    BG_JOB_STATE state;
	HRESULT hr;
    if (FAILED(hr= pjob->GetState(&state)))
        {
        return hr;
        }

	if (m_dwJobState == state)
	{
		goto Done;
	}
	DEBUGMSG("WUAUENG JobModification callback");
	switch (state)
	{
	case BG_JOB_STATE_QUEUED: 	
		DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_QUEUED");
		ghClientHandles.ClientRemoveTrayIcon();
		break;
	case BG_JOB_STATE_TRANSFERRING:
		DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_TRANSFERRING");
		m_DoDownloadStatus(CATMSG_DOWNLOAD_IN_PROGRESS, pjob);
		ghClientHandles.ClientAddTrayIcon();
		break;
	case BG_JOB_STATE_TRANSIENT_ERROR:
		{
			DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE_TRANSIENT_ERROR");
			m_DoDownloadStatus(CATMSG_TRANSIENT_ERROR, pjob);
			break;
		}		
	case BG_JOB_STATE_SUSPENDED:
	case BG_JOB_STATE_ERROR:			//What about BG_JOB_STATE_ERROR ?
	case BG_JOB_STATE_TRANSFERRED:
	case BG_JOB_STATE_ACKNOWLEDGED:	
    case BG_JOB_STATE_CONNECTING:
		{
			DEBUGMSG("WUAUENG JobModification: Drizzle notified BG_JOB_STATE = %d", state);
			break;
		}
	default:
		{
		DEBUGMSG("WUAUENG Drizzle notified unexpected BG_JOB_STATE %d",state);
		}
	}
	m_dwJobState = state;
Done:
	return S_OK;
}

HRESULT CAUDownloader::SetDrizzleNotifyInterface()
{
	HRESULT hr ;
       IBackgroundCopyJob * pjob = NULL;
       
       if (FAILED(hr = FindDownloadJob(&pjob)))
        {
            DEBUGMSG("CAUDownloader::SetDrizzleNotifyInterface() got no download job with error %#lx", hr);
            goto done;
        }
	if (FAILED(hr = pjob->SetNotifyFlags(DRIZZLE_NOTIFY_FLAGS)))
	{
		DEBUGMSG("WUAUENG SetDrizzleNotifyInterface: set notification flags failed %#lx", hr);
	}
	else if (FAILED(hr = pjob->SetNotifyInterface(this)))
	{
		DEBUGMSG("WUAUENG SetDrizzleNotifyInterface: set notification interface failed %#lx", hr);
	}
	
done:
       SafeRelease(pjob);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// helper function to connect AU to the job got using its GUID
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CAUDownloader::ReconnectDownloadJob()
{
	BG_JOB_STATE state;		
	HRESULT hr = E_FAIL;
       IBackgroundCopyJob * pjob = NULL;
       
	DEBUGMSG("ReconnectDownloadJob() starts");
	if ( (FAILED(hr = FindDownloadJob(&pjob)))
	   || FAILED(hr = pjob->GetState(&state)))
	{  
	    DEBUGMSG("get no download job or fail to get job state");
           goto Done;
	}	
	switch (state)
	{
	case BG_JOB_STATE_QUEUED: 
	case BG_JOB_STATE_TRANSFERRING:
	case BG_JOB_STATE_CONNECTING:
	case BG_JOB_STATE_TRANSIENT_ERROR:
	case BG_JOB_STATE_SUSPENDED:		
	case BG_JOB_STATE_ERROR:
		{
			DEBUGMSG("WUAUENG Trying to connect to drizzle again");
			if (FAILED(hr = SetDrizzleNotifyInterface()))
			{
				goto Done;				
			}			
			//fixcode: why need resume if error?
			if (BG_JOB_STATE_ERROR == state)
			{
				pjob->Resume();		//REVIEW, Is this really what we want to do?
			}
			break;
		}				
	case BG_JOB_STATE_TRANSFERRED:
		{
			DEBUGMSG("WUAUENG  Got BG_JOB_STATE_TRANSFERRED should work ok");
			if (FAILED(hr = pjob->Complete()))
			{
				goto Done;
			}
			m_DoDownloadStatus(CATMSG_DOWNLOAD_COMPLETE, pjob);

			break;
		}
	case BG_JOB_STATE_ACKNOWLEDGED:
		{
			//If the job was already acknowledged, we are assuming that the engine can continue
			DEBUGMSG("WUAUENG : Got BG_JOB_STATE_ACKNOWLEDGED should work ok");
			break;
		}
	case BG_JOB_STATE_CANCELLED:
		{
			DEBUGMSG("WUAUENG : Got BG_JOB_STATE_CANCELLED, should start again");
			goto Done;			
		}
	default:
		{
		DEBUGMSG("WUAUENG Drizzle notified unexpected BG_JOB_STATE");		
		}
	}
	hr = S_OK;
	m_dwJobState = state;	
Done:
       SafeRelease(pjob);
       if (FAILED(hr))
        {
           Reset();
        }
     	DEBUGMSG("ReconnectDownloadJob() ends with result %#lx", hr);
	return hr;
}



/*****
CAUDownloader::QueueDownloadFile() adds a file to download to drizzle's 

RETURNS:
    S_OK:    
*****/
HRESULT CAUDownloader::QueueDownloadFile(LPCTSTR pszServerUrl,				// full http url
			LPCTSTR pszLocalFile				// local file name
			)
{
    HRESULT hr = S_OK;

    DEBUGMSG("CAUDownloader::DownloadFile() starts");
    
    IBackgroundCopyJob * pjob = NULL;
    if (FAILED(hr = FindDownloadJob(&pjob)))
    {
         DEBUGMSG("no existing download job, create one ");
         if (FAILED(hr = CreateDownloadJob(&pjob)))
            {
            DEBUGMSG("fail to create a new download job");
            goto done;
            }
     }

    //fixcode: do we need to pause job first before adding files
    
    //
    // Add the file to the download job.
    //
   hr = pjob->AddFile( pszServerUrl, pszLocalFile);
    if (FAILED(hr))
    {
        DEBUGMSG(" adding file failed with %#lx", hr);
        goto done;
    }

done:
       SafeRelease(pjob);
	if ( FAILED(hr) )
	{
		Reset();
	}
      return hr;
}


HRESULT CAUDownloader::StartDownload()
{
    HRESULT hr = E_FAIL;
    IBackgroundCopyJob * pjob = NULL;

    if (FAILED(hr = FindDownloadJob(&pjob)))
        {
        DEBUGMSG(" fail to get download job with error %#lx", hr);
        goto done;
        }
    if (FAILED(hr = pjob->Resume()))
    {
        DEBUGMSG("  failed to start the download job");
    }
done:
    SafeRelease(pjob);
    if (FAILED(hr))
        {
           Reset();
        }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
// cancel the job and reset CAUDownloader's state 
/////////////////////////////////////////////////////////////////////////////////
void CAUDownloader::Reset()
{
    IBackgroundCopyJob * pjob = NULL;

    if (SUCCEEDED(FindDownloadJob(&pjob)))
        {
            pjob->Cancel();
            pjob->Release();
            EngineEvents.SetEvent(IDOWNLOAD_DOWNLOAD_CANCELED);				
            DEBUGMSG("Reset() job cancelled and released");
        }
    m_DownloadId = GUID_NULL;
}

HRESULT CAUDownloader::DrizzleOperation(DRIZZLEOPS dop)
{
    HRESULT hrRet;
    IBackgroundCopyJob * pjob = NULL;
    if (FAILED(hrRet = FindDownloadJob(&pjob)))
    {
        DEBUGMSG("CAUDownloader::DrizzleOperation() on an invalid job");
        goto done;
    }
    switch (dop)
    	{
	case  DRIZZLEOPS_CANCEL: 
		DEBUGMSG("Catalog: Canceling Drizzle Job");
		hrRet =pjob->Cancel();
		EngineEvents.SetEvent(IDOWNLOAD_DOWNLOAD_CANCELED);				
		break;
	case DRIZZLEOPS_PAUSE:
		DEBUGMSG("Catalog: Pausing Drizzle Job");
		hrRet = pjob->Suspend();		
		break;
	case DRIZZLEOPS_RESUME:
		DEBUGMSG("Catalog: Resuming Drizzle Job");
		hrRet = pjob->Resume();		
		break;
    	}
done:
    SafeRelease(pjob);
    return hrRet;
}

/// pdwstatus actually contains the jobstate
HRESULT CAUDownloader::getStatus(DWORD *pdwPercent, DWORD *pdwstatus)
{
    BG_JOB_PROGRESS progress;
    BG_JOB_STATE state;
    HRESULT hr = S_OK;
    IBackgroundCopyJob * pjob = NULL;

    if (FAILED(hr = FindDownloadJob(&pjob)))
        {
        DEBUGMSG(" getStatus : no download job with error %#lx", hr);
        goto done;
        }

    if (FAILED(hr = pjob->GetState( &state )))
        {
	    DEBUGMSG("WUAUENG: job->GetState failed");
           state = BG_JOB_STATE_QUEUED;
           goto done;
        }

    if (FAILED(hr = pjob->GetProgress( &progress )))
        {
	    DEBUGMSG("WUAUENG: job->GetProgress failed");
	    goto done;
        }
    
    if (progress.BytesTotal != BG_SIZE_UNKNOWN )
       {
           *pdwPercent = DWORD( 100 * float(progress.BytesTransferred) / float(progress.BytesTotal) );
           DEBUGMSG("getStatus is %d percent", *pdwPercent);
       }
     else
        {
            DEBUGMSG("getStatus, progress.BytesTotal= BG_SIZE_UNKNOWN, BytesTransfered = %d",progress.BytesTransferred);
           *pdwPercent = 0;       
        }

	*pdwstatus =  state;

done:
    SafeRelease(pjob);
    return hr;
}


HRESULT STDMETHODCALLTYPE
CAUDownloader::QueryInterface(
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject
    )
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    if (riid == __uuidof(IUnknown) ||
        riid == __uuidof(IBackgroundCopyCallback) )
        {
        *ppvObject = (IBackgroundCopyCallback *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    return hr;
}

ULONG STDMETHODCALLTYPE
CAUDownloader::AddRef()
{
    long cRef = InterlockedIncrement(&m_refs);
	DEBUGMSG("CAUDownloader AddRef = %d", cRef);
	return cRef;
}

ULONG STDMETHODCALLTYPE
CAUDownloader::Release()
{
    long cRef = InterlockedDecrement(&m_refs);
	DEBUGMSG("CAUDownloader Release = %d", cRef);
	return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\aueventlog.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUEventLog.h
//
//  Creator: DChow
//
//  Purpose: Event Logging class
//
//=======================================================================

#pragma once

#include <windows.h>

class CAUEventLog
{
public:
	CAUEventLog(HINSTANCE hInstance);
	~CAUEventLog();

	BOOL LogEvent(
			WORD wType,
			WORD wCatagory,
			DWORD dwEventID,
			UINT nNumOfItems = 0,
			BSTR *pbstrItems = NULL,
			WORD wNumOfMsgParams = 0,
			LPTSTR *pptszMsgParams = NULL) const;
	BOOL LogEvent(
			WORD wType,
			WORD wCatagory,
			DWORD dwEventID,
			SAFEARRAY *psa) const;
	LPTSTR CombineItems(
			UINT nNumOfItems,
			BSTR *pbstItems) const;

private:
	HANDLE m_hEventLog;
	LPTSTR m_ptszListItemFormat;

	BOOL EnsureValidSource();
};


void LogEvent_ItemList(
		WORD wType,
		WORD wCategory,
		DWORD dwEventID,
		WORD wNumOfMsgParams = 0,
		LPTSTR *pptszMsgParams = NULL);

void LogEvent_ScheduledInstall(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\audownload.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:     audownload.h
//
//--------------------------------------------------------------------------

#pragma once

#include "aucatitem.h"
#include "aucatalog.h"
#include <bits.h>
#include <initguid.h>

class Catalog;

#define NO_BG_JOBSTATE				-1
#define CATMSG_DOWNLOAD_COMPLETE	1
#define CATMSG_TRANSIENT_ERROR		2	//This comes from drizzle, for example if internet connection is lost
#define CATMSG_DOWNLOAD_IN_PROGRESS 3
#define CATMSG_DOWNLOAD_CANCELED	4
#define CATMSG_DOWNLOAD_ERROR		5

#define DRIZZLE_NOTIFY_FLAGS	BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR | BG_NOTIFY_JOB_MODIFICATION

typedef void (*DWNLDCALLBACK)(DWORD dwCallbackMsg, IBackgroundCopyJob *pBGJob, IBackgroundCopyError *pBGErr = NULL);


typedef enum tagDRIZZLEOPS {
	DRIZZLEOPS_CANCEL = 1,
	DRIZZLEOPS_PAUSE ,
	DRIZZLEOPS_RESUME
} DRIZZLEOPS;

typedef enum tagJOBFINISHREASON {
	JOB_UNSPECIFIED_REASON = -1,
	JOB_ERROR = 0
} JOBFINISHREASON;

	


///////////////////////////////////////////////////////////////////////////
// Wrapper class for drizzle download operation
// also implements drizzle notification callbacks
//////////////////////////////////////////////////////////////////////////
class CAUDownloader : public IBackgroundCopyCallback
{
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    ULONG STDMETHODCALLTYPE AddRef( void);

    ULONG STDMETHODCALLTYPE Release( void);

    // IBackgroundCopyCallback methods

    HRESULT STDMETHODCALLTYPE JobTransferred(
        /* [in] */ IBackgroundCopyJob *pJob);

    HRESULT STDMETHODCALLTYPE JobError(
        /* [in] */ IBackgroundCopyJob *pJob,
        /* [in] */ IBackgroundCopyError *pError);

    HRESULT STDMETHODCALLTYPE JobModification(
        /* [in] */ IBackgroundCopyJob*,
        /* [in] */ DWORD );


	CAUDownloader(DWNLDCALLBACK pfnCallback):
			m_DownloadId(GUID_NULL),
			m_dwJobState(NO_BG_JOBSTATE),
			m_DoDownloadStatus(pfnCallback),
			m_refs(0),
			m_FinishReason(JOB_UNSPECIFIED_REASON)
			{};
	~CAUDownloader();

	HRESULT ContinueLastDownloadJob();
	//the following two could be combined into DownloadFiles() in V4
	HRESULT QueueDownloadFile(LPCTSTR pszServerUrl,				// full http url
			LPCTSTR pszLocalFile				// local file name
			);
	HRESULT StartDownload();
	HRESULT DrizzleOperation(DRIZZLEOPS);
	HRESULT getStatus(DWORD *percent, DWORD *pdwstatus);
	GUID 	getID() 
		{
			return m_DownloadId;
		}
	void  setID(const GUID & guid )
		{
			m_DownloadId = guid;
		}
	void 	Reset();
	JOBFINISHREASON m_FinishReason;
private:
	HRESULT SetDrizzleNotifyInterface();
	HRESULT InitDownloadJob(const GUID & guidDownloadId);	
	HRESULT ReconnectDownloadJob();
	HRESULT CreateDownloadJob(IBackgroundCopyJob ** ppjob);
	HRESULT FindDownloadJob(IBackgroundCopyJob ** ppjob);

	long m_refs;
	GUID m_DownloadId;                  // id what m_pjob points to. 
	DWORD m_dwJobState;			//Job State from drizzle, used in JobModification callback
	DWNLDCALLBACK	m_DoDownloadStatus; //callback function to notify user of download state change

// Friend functions (callbacks)
	friend void QueryFilesExistCallback(void*, long, LPCTSTR, LPCTSTR);
	
};


void DoDownloadStatus(DWORD dwDownloadMsg, IBackgroundCopyJob *pBGJob, IBackgroundCopyError *pBGErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\aueventlog.cpp ===
//=======================================================================
//
//  Copyright (c) 2001-2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:    AUEventLog.cpp
//
//  Creator: DChow
//
//  Purpose: Event Logging class
//
//=======================================================================

#include "pch.h"

extern HINSTANCE g_hInstance;
extern AUCatalog *gpAUcatalog;

const TCHAR c_tszSourceKey[] = _T("SYSTEM\\CurrentControlSet\\Services\\Eventlog\\System\\Automatic Updates");

CAUEventLog::CAUEventLog(HINSTANCE hInstance)
: m_hEventLog(NULL), m_ptszListItemFormat(NULL)
{
	const DWORD c_dwLen = 64;
	LPTSTR ptszToken = NULL;

	if (NULL != (m_ptszListItemFormat = (LPTSTR) malloc(sizeof(TCHAR) * c_dwLen)) &&
		0 != LoadString(
					hInstance,
					IDS_EVT_LISTITEMFORMAT,
					m_ptszListItemFormat,
					c_dwLen) &&
		NULL != (ptszToken = StrStr(m_ptszListItemFormat, _T("%lS"))) &&
		EnsureValidSource() &&
		NULL != (m_hEventLog = RegisterEventSource(NULL, _T("Automatic Updates"))))
	{
		// bug 492897: WUAU: W2K: Event log error for installation failure
		// does not show the package that failed.  CombineItems() calls
		// StringCchPrintfEx() which in turn calls _sntprintf().  _sntprintf
		// calls wvsprintf().  Compiled with USE_VCRT=1, the %lS placeholder
		// in the format string will be replaced under Win2K by only the first
		// character of the intended string, contrary to MSDN.  It doesn't
		// happen if the placeholder is %ls, %ws or %wS, or if the running
		// platform is WinXP or .Net Server.  To get around the problem
		// without using an unsafe function, we choose to replace %lS in the
		// format string from resource with %ls.
		// We should move the fix to the resource string when we can.
		ptszToken[2] = _T('s');	// Convert %lS into %ls
	}
	else
	{
		AUASSERT(FALSE);

		SafeFreeNULL(m_ptszListItemFormat);
	}
}


CAUEventLog::~CAUEventLog()
{
	if (NULL != m_hEventLog)
	{
		DeregisterEventSource(m_hEventLog);
	}
	SafeFree(m_ptszListItemFormat);
}


// Assume no NULL in the pbstrItems and pptszMsgParams arrays.
BOOL CAUEventLog::LogEvent(
					WORD wType,
					WORD wCategory,
					DWORD dwEventID,
					UINT nNumOfItems,
					BSTR *pbstrItems,
					WORD wNumOfMsgParams,
					LPTSTR *pptszMsgParams) const
{
	if (NULL == m_hEventLog || NULL == m_ptszListItemFormat)
	{
		return FALSE;
	}

	BOOL fRet = FALSE;

	LPTSTR ptszItemList = NULL;
	LPTSTR *pptszAllMsgParams = pptszMsgParams;
	WORD wNumOfAllMsgParams = wNumOfMsgParams;

	if (0 < nNumOfItems)
	{
		wNumOfAllMsgParams++;

		if (NULL == (ptszItemList = CombineItems(nNumOfItems, pbstrItems)))
		{
			goto CleanUp;
		}

		if (0 < wNumOfMsgParams)
		{
			if (NULL == (pptszAllMsgParams = (LPTSTR *) malloc(sizeof(LPTSTR) * wNumOfAllMsgParams)))
			{
				goto CleanUp;
			}

			for (INT i=0; i<wNumOfMsgParams; i++)
			{
				pptszAllMsgParams[i] = pptszMsgParams[i];
			}
			pptszAllMsgParams[i] = ptszItemList;
		}
		else
		{
			pptszAllMsgParams = &ptszItemList;
		}
	}

	fRet = ReportEvent(
				m_hEventLog,
				wType,
				wCategory,
				dwEventID,
				NULL,
				wNumOfAllMsgParams,
				0,
				(LPCTSTR *) pptszAllMsgParams,
				NULL);

CleanUp:
	if (0 < nNumOfItems)
	{
		if (0 < wNumOfMsgParams)
		{
			SafeFree(pptszAllMsgParams);
		}
		SafeFree(ptszItemList);
	}
	return fRet;
}


BOOL CAUEventLog::LogEvent(
					WORD wType,
					WORD wCategory,
					DWORD dwEventID,
					SAFEARRAY *psa) const
{
    DEBUGMSG("CAUEvetLog::LogEvent(VARIANT version)");

	long lItemCount, i = 0;
	HRESULT hr;

// similar check should have been done in Update::LogEvent()
/*	if (NULL == psa)
	{
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	VARTYPE vt;

	if (FAILED(hr = SafeArrayGetVartype(psa, &vt)))
	{
		DEBUGMSG("CAUEvetLog::LogEvent(VARIANT version) failed to get safearray type (%#lx)", hr);
		goto CleanUp;
	}

	if (VT_BSTR != vt)
	{
		DEBUGMSG("CAUEvetLog::LogEvent(VARIANT version) invalid element type of safearray (%#lx)", vt);
		goto CleanUp;
	}
*/
	if (FAILED(hr = SafeArrayGetUBound(psa, 1, &lItemCount)))
	{
		DEBUGMSG("CAUEventLog::LogEvent(VARIANT version) failed to get upper bound (%#lx)", hr);
		goto CleanUp;
	}

	lItemCount++;

	BSTR *pbstrItems = NULL;
	if (NULL == (pbstrItems = (BSTR *) malloc(sizeof(BSTR) * lItemCount)))
	{
		DEBUGMSG("CAUEventLog::LogEvent(VARIANT version) out of memory");
		goto CleanUp;
	}

	BOOL fRet = FALSE;
    while (i < lItemCount)
	{
		long dex = i;

        if (FAILED(hr = SafeArrayGetElement(psa, &dex, &pbstrItems[i])))
        {
            DEBUGMSG("CAUEventLog::LogEvent(VARIANT version) SafeArrayGetElement failed (%#lx)", hr);
            goto CleanUp;
        }
		i++;
	}

	fRet = LogEvent(
				wType,
				wCategory,
				dwEventID,
				lItemCount,
				pbstrItems);

CleanUp:
	if (NULL != pbstrItems)
	{
		while(i > 0)
		{
			SysFreeString(pbstrItems[--i]);
		}
		free(pbstrItems);
	}

	DEBUGMSG("CAUEventLog::LogEvent(VARIANT version) ends");

	return fRet;
}

// The caller is responsible for freeing the return value if this function succeeds.
LPTSTR CAUEventLog::CombineItems(UINT nNumOfItems, BSTR *pbstrItems) const
{
	DEBUGMSG("CombineItems");

	if (NULL != m_ptszListItemFormat && NULL != pbstrItems && 0 < nNumOfItems)
	{
		// Estimate buffer size
		size_t cchBufferLen = 1;	// 1 for the terminating NULL
		size_t cchListItemFormatLen = lstrlen(m_ptszListItemFormat);

		for (UINT i=0; i<nNumOfItems; i++)
		{
			if (0 < i)
			{
				cchBufferLen += 2;	// for line feed and carriage return (i.e. _T('\n'))
			}
			cchBufferLen += cchListItemFormatLen + SysStringLen(pbstrItems[i]);
		}

		LPTSTR ptszBuffer;

		cchBufferLen = min(cchBufferLen, 0x8000);	// String limit for ReportEvent
		if (NULL != (ptszBuffer = (LPTSTR) malloc(sizeof(TCHAR) * cchBufferLen)))
		{
			LPTSTR ptszDest = ptszBuffer;

			for (i = 0;;)
			{
				if (FAILED(StringCchPrintfEx(
								ptszDest,
								cchBufferLen,
								&ptszDest,
								&cchBufferLen,
								MISTSAFE_STRING_FLAGS,
								m_ptszListItemFormat,	// uses %ls; so okay w/ BSTR (UNICODE)
								pbstrItems[i++])))
				{
					DEBUGMSG("CAUEventLog::CombineItems() call to StringCchPrintfEx() failed");
					return ptszBuffer;
				}
				if (i == nNumOfItems)
				{
					return ptszBuffer;
				}
				if (cchBufferLen <= 1)
				{
					DEBUGMSG("CAUEventLog::CombineItems() insufficient buffer for newline");
					return ptszBuffer;
				}
				*ptszDest++ = _T('\n');
				*ptszDest = _T('\0');
				cchBufferLen--;
			}
		}
	}
	return NULL;
}


BOOL CAUEventLog::EnsureValidSource()
{
	HKEY hKey;
	DWORD dwDisposition;

	if (ERROR_SUCCESS != RegCreateKeyEx(
							HKEY_LOCAL_MACHINE,					// root key
							c_tszSourceKey,						// subkey
							0,									// reserved
							NULL,								// class name
							REG_OPTION_NON_VOLATILE,			// option
							KEY_QUERY_VALUE | KEY_SET_VALUE,	// security 
							NULL,								// security attribute
							&hKey,
							&dwDisposition))
	{
		return FALSE;
	}

	BOOL fRet = TRUE;

	if (REG_OPENED_EXISTING_KEY == dwDisposition)
	{
		(void) RegCloseKey(hKey);
	}
	else
	{
		DWORD dwCategoryCount = 2;	//fixcode: should it be hardcoded?
//		DWORD dwDisplayNameID = IDS_SERVICENAME;
		DWORD dwTypesSupported =
					EVENTLOG_ERROR_TYPE |
					EVENTLOG_WARNING_TYPE |
					EVENTLOG_INFORMATION_TYPE;
		const TCHAR c_tszWUAUENG_DLL[] = _T("%SystemRoot%\\System32\\wuaueng.dll");

		if (ERROR_SUCCESS != RegSetValueEx(
								hKey,
								_T("CategoryCount"),		// value name
								0,							// reserved
								REG_DWORD,					// type
								(BYTE*) &dwCategoryCount,	// data
								sizeof(dwCategoryCount)) ||	// size
			ERROR_SUCCESS != RegSetValueEx(
								hKey,
								_T("CategoryMessageFile"),
								0,
								REG_EXPAND_SZ,
								(BYTE*) c_tszWUAUENG_DLL,
								sizeof(c_tszWUAUENG_DLL)) ||	// not ARRAYSIZE
//			ERROR_SUCCESS != RegSetValueEx(
//								hKey,
//								_T("DisplayNameFile"),
//								0,
//								REG_EXPAND_SZ,
//								(BYTE*) c_tszWUAUENG_DLL,
//								sizeof(c_tszWUAUENG_DLL)) ||	// not ARRAYSIZE
//			ERROR_SUCCESS != RegSetValueEx(
//								hKey,
//								_T("DisplayNameID"),
//								0,
//								REG_DWORD,
//								(BYTE*) &dwDisplayNameID,
//								sizeof(dwDisplayNameID)) ||
			ERROR_SUCCESS != RegSetValueEx(
								hKey,
								_T("EventMessageFile"),
								0,
								REG_EXPAND_SZ,
								(BYTE*) c_tszWUAUENG_DLL,
								sizeof(c_tszWUAUENG_DLL)) ||	// not ARRAYSIZE
			ERROR_SUCCESS != RegSetValueEx(
								hKey,
								_T("TypesSupported"),
								0,
								REG_DWORD,
								(BYTE*) &dwTypesSupported,
								sizeof(dwTypesSupported)))
		{
			fRet = FALSE;
		}

		if (ERROR_SUCCESS != RegCloseKey(hKey))
		{
			fRet = FALSE;
		}
	}

	return fRet;
}


void LogEvent_ItemList(
		WORD wType,
		WORD wCategory,
		DWORD dwEventID,
		WORD wNumOfMsgParams,
		LPTSTR *pptszMsgParams)
{
	AUCatalogItemList &itemList = gpAUcatalog->m_ItemList;
	UINT nNumOfItems = itemList.GetNumSelected();

	if (0 < nNumOfItems)
	{
		BSTR *pbstrItems = (BSTR *) malloc(sizeof(BSTR) * nNumOfItems);

		if (NULL != pbstrItems)
		{
			CAUEventLog aueventlog(g_hInstance);
			UINT j = 0;

			for (UINT i=0; i<itemList.Count(); i++)
			{
				AUCatalogItem &item = itemList[i];
				if (item.fSelected())
				{
					pbstrItems[j++] = item.bstrTitle();
				}
			}

			aueventlog.LogEvent(
				wType,
				wCategory,
				dwEventID,
				nNumOfItems,
				pbstrItems,
				wNumOfMsgParams,
				pptszMsgParams);

			free(pbstrItems);
		}
		else
		{
			DEBUGMSG("LogEvent_ItemList() failed to allocate memory for pbstrItems");
		}
	}
	else
	{
		DEBUGMSG("LogEvent_ItemList() no item in gpAUcatalog is selected!");
	}
}


void LogEvent_ScheduledInstall(void)
{
	TCHAR tszScheduledDate[64];
	TCHAR tszScheduledTime[40];
	AUFILETIME auftSchedInstallDate;
	SYSTEMTIME stScheduled;

	DEBUGMSG("LogEvent_ScheduledInstall");

	gpState->GetSchedInstallDate(auftSchedInstallDate);

	//fixcode: any need to use DATE_LTRREADING or DATE_RTLREADING?
	if (FileTimeToSystemTime(&auftSchedInstallDate.ft, &stScheduled))
	{
		if (0 != GetDateFormat(
					LOCALE_SYSTEM_DEFAULT,
					LOCALE_NOUSEROVERRIDE | DATE_LONGDATE,
					&stScheduled,
					NULL,
					tszScheduledDate,
					ARRAYSIZE(tszScheduledDate)))
		{
			if (Hours2LocalizedString(
					&stScheduled,
					tszScheduledTime,
					ARRAYSIZE(tszScheduledTime)))
			{
				LPTSTR pptszMsgParams[2];

				pptszMsgParams[0] = tszScheduledDate;
				pptszMsgParams[1] = tszScheduledTime;

				LogEvent_ItemList(
					EVENTLOG_INFORMATION_TYPE,
					IDS_MSG_Installation,
					IDS_MSG_InstallReady_Scheduled,
					2,
					pptszMsgParams);
			}
		#ifdef DBG
			else
			{
				DEBUGMSG("LogEvent_ScheduledInstall() call to Hours2LocalizedString() failed");
			}
		#endif
		}
	#ifdef DBG
		else
		{
			DEBUGMSG("LogEvent_ScheduledInstall() call to GetDateFormatW() failed (%#lx)", GetLastError());
		}
	#endif
	}
#ifdef DBG
	else
	{
		DEBUGMSG("LogEvent_ScheduledInstall() call to FileTimeToSystemTime() failed (%#lx)", GetLastError());
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\auservinternals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auservinternals.h
//
//--------------------------------------------------------------------------

#pragma once

HRESULT	removeTimeOutKeys(BOOL fLastWaitReminderKeys);
HRESULT	getReminderTimeout(DWORD *, UINT *);
HRESULT getReminderState(DWORD *);
HRESULT	removeReminderKeys(void);	
HRESULT getLastWaitTimeout(DWORD * pdwLastWaitTimeout);
HRESULT setLastWaitTimeout(DWORD pdwLastWaitTimeout);
HRESULT removeLastWaitKey(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\ausens.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  sens.cpp
//
//  Modele that implements a COM+ subscriber for use with SENS notifications. 
//
//  10/9/2001   annah   Created
//                      Ported code from BITS sources. Removed SEH code, 
//                      changed methods that threw exceptions to return
//                      error codes.
//
//----------------------------------------------------------------------------


#include "pch.h"
#include "ausens.h"
#include "tscompat.h"
#include "service.h"

static CLogonNotification  *g_SensLogonNotification = NULL;


HRESULT ActivateSensLogonNotification()
{
    HRESULT hr = S_OK;

    // only activate once
    if ( g_SensLogonNotification )
    {
        DEBUGMSG("AUSENS Logon object was already created; reusing object.");
        return S_OK;
    }

    g_SensLogonNotification = new CLogonNotification();
    if (!g_SensLogonNotification)
    {
        DEBUGMSG("AUSENS Failed to alocate memory for CLogonNotification object.");
        return E_OUTOFMEMORY;
    }

    hr = g_SensLogonNotification->Initialize();
    if (FAILED(hr))
    {
        DEBUGMSG( "AUSENS notification activation failed." );
    }
    else
    {
        DEBUGMSG( "AUSENS notification activated" );
    }

    return hr;
}

HRESULT DeactivateSensLogonNotification()
{
    if (!g_SensLogonNotification)
    {
        DEBUGMSG("AUSENS Logon object is not activated; ignoring call.");
        return S_OK;
    }

    delete g_SensLogonNotification;
    g_SensLogonNotification = NULL;

    DEBUGMSG( "AUSENS notification deactivated" );
    return S_OK;
}

//----------------------------------------------------------------------------
// BSTR manipulation
//----------------------------------------------------------------------------

 HRESULT AppendBSTR(BSTR *bstrDest, BSTR bstrAppend)
 {
     HRESULT hr      = S_OK;
     BSTR    bstrNew = NULL;

     if (bstrDest == NULL || *bstrDest == NULL)
         return E_INVALIDARG;

     if (bstrAppend == NULL)
         return S_OK;

     hr = VarBstrCat(*bstrDest, bstrAppend, &bstrNew);
     if (SUCCEEDED(hr))
     {
         SysFreeString(*bstrDest);
         *bstrDest = bstrNew;
     }

     return hr;
 }

 // Caller is responsible for freeing bstrOut
 HRESULT BSTRFromIID(IN REFIID riid, OUT BSTR *bstrOut)
 {
     HRESULT   hr       = S_OK;
     LPOLESTR  lpszGUID = NULL;

     if (bstrOut == NULL)
     {
         hr = E_INVALIDARG;
         goto done;
     }

     hr = StringFromIID(riid, &lpszGUID);
     if (FAILED(hr))
     {
         DEBUGMSG("AUSENS Failed to extract GUID from string");
         goto done;
     }

     *bstrOut = SysAllocString(lpszGUID);
     if (*bstrOut == NULL)
     {
         hr = E_OUTOFMEMORY;
         goto done;
     }

 done:
     if (lpszGUID)
     {
         CoTaskMemFree(lpszGUID);
     }

     return hr;
 }

 HRESULT CBstrTable::Initialize()
 {
     HRESULT hr = S_OK;

     hr = BSTRFromIID(g_oLogonSubscription.MethodGuid, &m_bstrLogonMethodGuid);
     if (FAILED(hr))
     {
         goto done;
     }

     m_bstrLogonMethodName = SysAllocString(g_oLogonSubscription.pszMethodName);
     if (m_bstrLogonMethodName == NULL)
     {
         hr = E_OUTOFMEMORY;
         goto done;
     }    

     m_bstrSubscriptionName = SysAllocString(SUBSCRIPTION_NAME_TEXT);
     if (m_bstrSubscriptionName == NULL)
     {
         hr = E_OUTOFMEMORY;
         goto done;
     }    

     m_bstrSubscriptionDescription = SysAllocString(SUBSCRIPTION_DESCRIPTION_TEXT);
     if (m_bstrSubscriptionDescription == NULL)
     {
         hr = E_OUTOFMEMORY;
         goto done;
     }    

     hr = BSTRFromIID(_uuidof(ISensLogon), &m_bstrSensLogonGuid);
     if (FAILED(hr))
     {
         goto done;
     }

     hr = BSTRFromIID(SENSGUID_EVENTCLASS_LOGON, &m_bstrSensEventClassGuid);
     if (FAILED(hr))
     {
         goto done;
     }

 done:
     return hr;
 }


//----------------------------------------------------------------------------
// Implementation for CLogonNotification methods
//----------------------------------------------------------------------------

HRESULT CLogonNotification::Initialize()
{
   HRESULT  hr = S_OK;
   SIZE_T   cSubscriptions = 0;

   // 
   // Create auxiliary object with BSTR names used for several actions
   //
   m_oBstrTable = new CBstrTable();
   if (!m_oBstrTable)
   {
       return E_OUTOFMEMORY;
   }

   hr = m_oBstrTable->Initialize();
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Could not create auxiliary structure BstrTable");
       return hr;
   }

   //
   // Load the type library from SENS
   //
   hr = LoadTypeLibEx(L"SENS.DLL", REGKIND_NONE, &m_TypeLib);
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Could not load type library from SENS DLL");
       goto done;
   }

   //
   // Get TypeInfo for ISensLogon from SENS typelib -- this will
   // simplify thing for us when implementing IDispatch methods
   //
   hr = m_TypeLib->GetTypeInfoOfGuid(__uuidof( ISensLogon ), &m_TypeInfo);
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Could not get type info for ISensLogon.");
       goto done;
   }

   //
   // Grab an interface pointer of the EventSystem object
   //
   hr = CoCreateInstance(CLSID_CEventSystem, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IEventSystem, (void**)&m_EventSystem );
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Failed to create EventSytem instance for Sens subscription. Error is %x.", hr);
       goto done;
   }

   //
   // Subscribe for the Logon notifications
   //
   DEBUGMSG("AUSENS Subscribing method '%S' with SENS (%S)", m_oBstrTable->m_bstrLogonMethodName, m_oBstrTable->m_bstrLogonMethodGuid);
   hr = SubscribeMethod(m_oBstrTable->m_bstrLogonMethodName, m_oBstrTable->m_bstrLogonMethodGuid);
   if (FAILED(hr))
   {
       DEBUGMSG("AUSENS Subscription for method failed.");
       goto done;
   }
   m_fSubscribed = TRUE;

done:

   return hr;
}

HRESULT CLogonNotification::UnsubscribeAllMethods()
{
    HRESULT   hr                      = S_OK;
    BSTR      bstrQuery               = NULL;
    BSTR      bstrAux                 = NULL;
    int       ErrorIndex;

    DEBUGMSG("AUSENS Unsubscribing all methods");
    //
    // The query should be a string in the following format:
    // EventClassID == {D5978630-5B9F-11D1-8DD2-00AA004ABD5E} and SubscriptioniD == {XXXXXXX-5B9F-11D1-8DD2-00AA004ABD5E}
    //

    bstrQuery = SysAllocString(L"EventClassID == ");
    if (bstrQuery == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    bstrAux = SysAllocString(L" and SubscriptionID == ");
    if (bstrAux == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = AppendBSTR(&bstrQuery, m_oBstrTable->m_bstrSensLogonGuid);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to append BSTR string");
        goto done;
    }

    hr = AppendBSTR(&bstrQuery, bstrAux);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to append BSTR string");
        goto done;
    }

    hr = AppendBSTR(&bstrQuery, m_oBstrTable->m_bstrLogonMethodGuid);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to append BSTR string");
        goto done;
    }

	if (bstrQuery != NULL)
    {    
	    // Remove subscription for all ISensLogon subscription that were added for this WU component
        DEBUGMSG("AUSENS remove subscription query: %S", bstrQuery);
	    hr = m_EventSystem->Remove( PROGID_EventSubscription, bstrQuery, &ErrorIndex );
	    if (FAILED(hr))
	    {
            DEBUGMSG("AUSENS Failed to remove AU Subscription from COM Event System");
            goto done;
	    }
        m_fSubscribed = FALSE;
	}
    else
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

done:

    SafeFreeBSTR(bstrQuery);
    SafeFreeBSTR(bstrAux);

    return hr;
}

HRESULT CLogonNotification::SubscribeMethod(const BSTR bstrMethodName, const BSTR bstrMethodGuid)
{
    HRESULT              hr = S_OK;
    IEventSubscription  *pEventSubscription  = NULL;

    //
    // Create an instance of EventSubscription
    //
    hr = CoCreateInstance(CLSID_CEventSubscription, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IEventSubscription, (void**)&pEventSubscription); 
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to instanciate EventSubscription object");
        goto done;
    }

    //
    // Subscribe the method
    //
    hr = pEventSubscription->put_EventClassID(m_oBstrTable->m_bstrSensEventClassGuid);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set EventClassID during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_SubscriberInterface(this);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set EventClassID during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_SubscriptionName(m_oBstrTable->m_bstrSubscriptionName);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set EventClassID during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_Description(m_oBstrTable->m_bstrSubscriptionDescription);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set subscription method during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_Enabled(TRUE);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set enabled flag during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_MethodName(bstrMethodName);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set MethodName during method subscription");
        goto done;
    }

    hr = pEventSubscription->put_SubscriptionID(bstrMethodGuid);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to set SubscriptionID during method subscription");
        goto done;
    }

    hr = m_EventSystem->Store(PROGID_EventSubscription, pEventSubscription);
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS Failed to store Event Subscription in the Event System");
        goto done;
    }

done:
    SafeRelease(pEventSubscription);

    return hr;
}

void CLogonNotification::Cleanup()
{
    __try
    {
        if (m_EventSystem)
        {
            if (m_fSubscribed)
            {
                UnsubscribeAllMethods();
            }
            SafeRelease(m_EventSystem);
        }

        SafeRelease(m_TypeInfo);
        SafeRelease(m_TypeLib);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUGMSG("AUSENS Cleanup raised and execution exception that was trapped.");
    }

    if (m_oBstrTable)
    {
        delete m_oBstrTable;
        m_oBstrTable = NULL;
    }
}

HRESULT CLogonNotification::CheckLocalSystem()
{
    HRESULT                     hr             = E_FAIL;
    PSID                        pLocalSid      = NULL;
    HANDLE                      hToken         = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT  = SECURITY_NT_AUTHORITY;
    BOOL                        fRet           = FALSE;
    BOOL                        fIsLocalSystem = FALSE;

    fRet = AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid );

    if (fRet == FALSE) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DEBUGMSG("AUSENS AllocateAndInitializeSid failed with error %x", hr);
        goto done;
    }

    if (FAILED(hr = CoImpersonateClient()))
	{
        DEBUGMSG("AUSENS Failed to impersonate client", hr);
        hr = E_ACCESSDENIED;
        goto done;
	}
    
    fRet = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
    if (fRet == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DEBUGMSG("AUSENS Failed to OpenProcessToken");
        goto done;
    }

    if (FAILED(CoRevertToSelf()))
    {
    	AUASSERT(FALSE); //should never be there
    	hr = E_ACCESSDENIED;
    	goto done;
    }

    fRet = CheckTokenMembership(hToken, pLocalSid, &fIsLocalSystem);
    if (fRet == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DEBUGMSG("AUSENS fail to Check token membership with error %x", hr);
        goto done;
    }

    if (fIsLocalSystem)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
        DEBUGMSG("AUSENS SECURITY CHECK Current thread is not running as LocalSystem!!");
    }

done:

    if (hToken != NULL)
        CloseHandle(hToken);
    if (pLocalSid != NULL)
        FreeSid(pLocalSid);

    return hr;
}

STDMETHODIMP CLogonNotification::Logon( BSTR UserName )
{
    DEBUGMSG("AUSENS logon notification for %S", (WCHAR*)UserName );
    DEBUGMSG("AUSENS Forcing the rebuilt of the cachesessions array");

    // 
    // fix for security bug 563054 -- annah
    //
    // The Logon() method is called by the COM+ Event System to notify us of a logon event
    // We expose the ISensLogon interface but don't want anybody calling us
    // that is not the COM+ Event System.
    //
    // The COM+ Event System service runs as Local System in the netsvcs svchost group.
    // We will check if the caller is really the Event System by checking for
    // the Local System account.
    //
    HRESULT hr = CheckLocalSystem();
    if (FAILED(hr))
    {
        DEBUGMSG("AUSENS CheckLocalSystem failed with error %x. Will not trigger logon notification", hr);
        goto done;
    }


    //
    // One big problem of the code below is that although we're validating that
    // there are admins on the machine who are valid users for AU, it could be the 
    // same that was already there, because we don't have a reliable way of receiving
    // logoff notifications. So we will raise the NEW_ADMIN event here, and
    // we will block the cretiion of a new client if we detect that there's a
    // a client still running.
    // 
    gAdminSessions.RebuildSessionCache();
	if (gAdminSessions.CSessions() > 0)
	{
        DEBUGMSG("AU SENS Logon: There are admins in the admin cache, raising NEW_ADMIN event (it could be a false alarm)");
        SetActiveAdminSessionEvent();
    }

#if DBG
    gAdminSessions.m_DumpSessions();
#endif

done:

    return S_OK;
}

STDMETHODIMP CLogonNotification::Logoff( BSTR UserName )
{
    DEBUGMSG( "AUSENS logoff notification for %S", (WCHAR*)UserName );

    // do nothing

#if DBG
    gAdminSessions.m_DumpSessions();
#endif

    return S_OK;
}

STDMETHODIMP CLogonNotification::QueryInterface(REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    if ((iid == IID_IUnknown) || (iid == _uuidof(IDispatch)) || (iid == _uuidof(ISensLogon)))
    {
        *ppvObject = static_cast<ISensLogon *> (this);
        (static_cast<IUnknown *>(*ppvObject))->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP CLogonNotification::GetIDsOfNames(REFIID, OLECHAR ** rgszNames, unsigned int cNames, LCID, DISPID *rgDispId )
{
    return m_TypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispId);
}

    
STDMETHODIMP CLogonNotification::GetTypeInfo(unsigned int iTInfo, LCID, ITypeInfo **ppTInfo )
{
    if ( iTInfo != 0 )
        return DISP_E_BADINDEX;

    *ppTInfo = m_TypeInfo;
    m_TypeInfo->AddRef();

    return S_OK;
}

STDMETHODIMP CLogonNotification::GetTypeInfoCount(unsigned int *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CLogonNotification::Invoke( 
    DISPID dispID, 
    REFIID riid, 
    LCID, 
    WORD wFlags, 
    DISPPARAMS *pDispParams, 
    VARIANT *pvarResult, 
    EXCEPINFO *pExcepInfo, 
    unsigned int *puArgErr )
{

    if (riid != IID_NULL)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    return m_TypeInfo->Invoke(
        (IDispatch*) this,
        dispID,
        wFlags,
        pDispParams,
        pvarResult,
        pExcepInfo,
        puArgErr
        );
}

STDMETHODIMP CLogonNotification::DisplayLock( BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP CLogonNotification::DisplayUnlock( BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP CLogonNotification::StartScreenSaver( BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP CLogonNotification::StopScreenSaver( BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP CLogonNotification::StartShell( BSTR UserName )
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\auservinternals.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auservinternals.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


/*****
 Looks for reminder timestamp in users registry. If not found, returns
 failure. If found, passes the remaining timeout in seconds remaining
 before we should remind the user
*****/ 
HRESULT getReminderTimeout(DWORD *pdwTimeDiff, UINT * /*pIndex*/)
{
	return getAddedTimeout(pdwTimeDiff, TIMEOUTVALUE);
}


HRESULT getReminderState(DWORD *pdwState)
{
	HKEY	hAUKey;
	LONG	lRet;
	DWORD	dwType = REG_DWORD, dwSize = sizeof(DWORD);
	return GetRegDWordValue(TIMEOUTSTATE,pdwState);
}


HRESULT	removeTimeOutKeys(BOOL fLastWaitReminderKeys)
{
	if (fLastWaitReminderKeys)
	{
		return DeleteRegValue(LASTWAITTIMEOUT);
	}
	else
	{
		HRESULT hr1 = DeleteRegValue(TIMEOUTVALUE);
		HRESULT hr2 = DeleteRegValue( TIMEOUTSTATE);
		if (FAILED(hr1) || FAILED(hr2))
		{
			return FAILED(hr1)? hr1 : hr2;
		}
		else
		{
			return S_OK;
		}	
	}
}
HRESULT	removeReminderKeys()
{
	return removeTimeOutKeys(FALSE);
}
HRESULT	setLastWaitTimeout(DWORD pdwLastWaitTimeout)
{
	return setAddedTimeout(pdwLastWaitTimeout, LASTWAITTIMEOUT);
}
HRESULT	getLastWaitTimeout(DWORD * pdwLastWaitTimeout)
{
	return getAddedTimeout(pdwLastWaitTimeout, LASTWAITTIMEOUT);
}
HRESULT	removeLastWaitKey(void)
{
	return removeTimeOutKeys(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\ausessions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ausessions.cpp
// 
//  History:    10/19/2001  annah
//                          transformed struct in class, added constructors
//                          destructors, and also proctected write operations
//                          with a critical session (on win2k the code can
//                          have race conditions). Also moved some functions
//                          from service.cpp to the class.
//
//--------------------------------------------------------------------------
#include "pch.h"
#include "tscompat.h" 
#include "service.h"

#pragma hdrstop

//SESSION_STATUS Functions
SESSION_STATUS::SESSION_STATUS (void)
{
	m_fInitCS = FALSE;
}

SESSION_STATUS::~SESSION_STATUS()
{
	if (m_fInitCS)
	{
		DeleteCriticalSection(&m_csWrite);
	}
}
	
BOOL SESSION_STATUS::Initialize(BOOL fUseCriticalSection, BOOL fAllActiveUsers)
{
    m_fAllActiveUsers = fAllActiveUsers;
	m_pSessionStateInfo =  NULL;		
	m_iLastSession = -1;
	m_cAllocBufSessions = 0;
	m_iCurSession = CDWNO_SESSION;		
    //
    // The code will only execute concurrent paths on win2K
    // It won't be expensive to use th critical session
    //  for all platforms, however
    //
	if (fUseCriticalSection)
	{
		if (!m_fInitCS)
		{
			m_fInitCS = SafeInitializeCriticalSection(&m_csWrite);
		}
	}
	else
	{
		AUASSERT(!m_fInitCS);
	}
	return (m_fInitCS == fUseCriticalSection);
}

void SESSION_STATUS::Clear(void)
{
	if (NULL != m_pSessionStateInfo)
	{
		free(m_pSessionStateInfo);
	}	
}

// Method used when we want to rebuild the array from scratch
void SESSION_STATUS::m_EraseAll()
{
	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}

    Clear();
    BOOL fRet = Initialize(m_fInitCS, m_fAllActiveUsers);
	AUASSERT(fRet);

	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}
}

void SESSION_STATUS::RebuildSessionCache()
{
	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}

	m_EraseAll();
    CacheExistingSessions();

	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}
}

BOOL SESSION_STATUS::m_FAddSession(DWORD dwSessionId, SESSION_STATE *pSesState)
{	
	BOOL fRet = TRUE;

	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}

    //
    // Fix for bug 498256 -- annah
    // It can happen that a user logs in right when the service is starting, so
    // we would add the session though the TS enumeration code AND
    // then possibly again through the code that receives SCM logon notifications.
    // The fix will be to test if the session is already stored, and skip
    // adding entries that for session ids that are already there.
    //
    if (m_iFindSession(dwSessionId) != CDWNO_SESSION)
    {
        // do nothing -- don't add duplicate entries if the session id 
        // is already there.
        fRet = FALSE;
        goto Done;
    }
	
	if (NULL == m_pSessionStateInfo || m_iLastSession >= m_cAllocBufSessions - 1)
	{
		int cSessions;

		if (m_cAllocBufSessions == 0)
		{
			cSessions = CMIN_SESSIONS;
			m_iCurSession = 0;
		}
		else
		{
			cSessions = m_cAllocBufSessions * 2;
		}
		if (!m_FChangeBufSession(cSessions))
		{
			fRet = FALSE;
			goto Done;
		}
	}
	m_iLastSession++;

	m_pSessionStateInfo[m_iLastSession].dwSessionId = dwSessionId;
	m_pSessionStateInfo[m_iLastSession].SessionState = *pSesState;

Done:
	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}
#ifdef DBG
    DEBUGMSG("After AddSession");
    m_DumpSessions();
#endif    
	return fRet;
}

//determine whether or not session dwSessionId is a cached AU session
BOOL SESSION_STATUS::m_FGetSessionState(DWORD dwSessionId, SESSION_STATE **pSesState )
{	
	int iSession = m_iFindSession(dwSessionId);

	BOOL fRet = (CDWNO_SESSION != iSession);
	
	if (fRet && (NULL != pSesState))
	{
		*pSesState = &m_pSessionStateInfo[iSession].SessionState;
	}
	return fRet;
}

BOOL SESSION_STATUS::m_FDeleteSession(DWORD dwSessionId)
{
	BOOL fRet= FALSE;

	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}
	
	int iSession = m_iFindSession(dwSessionId);
	if (CDWNO_SESSION == iSession)
	{
		goto Done;
	}
	if (iSession != m_iLastSession)
	{
		memmove(m_pSessionStateInfo + iSession, 
			m_pSessionStateInfo + iSession + 1, 
			sizeof(SESSION_STATE_INFO) * (m_iLastSession - iSession));
	}
	if (m_iCurSession > iSession)
	{
		m_iCurSession--;
	}
	//fixcode m_iCurSession should point to the previous session
	if (m_iCurSession == m_iLastSession)
	{
		m_iCurSession = 0;
	}
	m_iLastSession--;
	fRet = TRUE;

Done:
	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}
#ifdef DBG
    DEBUGMSG("After DeleteSession");
    m_DumpSessions();
#endif    
	return fRet;
}

BOOL SESSION_STATUS::m_FGetCurrentSession(DWORD *pdwSessionId)
{
	if (0 == CSessions())
	{
		return FALSE;
	}	
	
	*pdwSessionId = m_pSessionStateInfo[m_iCurSession].dwSessionId;	
	
	return TRUE;
}

BOOL SESSION_STATUS::m_FGetNextSession(DWORD *pdwSessionId)
{
	if (0 == CSessions())
	{
		return FALSE;
	}
	m_iCurSession = (m_iCurSession + 1 ) % CSessions();
	*pdwSessionId = m_pSessionStateInfo[m_iCurSession].dwSessionId;		
	
	return TRUE;
}
int SESSION_STATUS::m_iFindSession(DWORD dwSessionId)
{	

	for (int iSession = 0; iSession < CSessions(); iSession++)
	{		
		if (dwSessionId == m_pSessionStateInfo[iSession].dwSessionId)
		{	
			return iSession;		
		}		
	}
	return CDWNO_SESSION;
}

// this functions lets someone traverse the content of
// the array sequencially.
int SESSION_STATUS::m_iGetSessionIdAtIndex(int iIndex)
{
    if (iIndex < 0 || iIndex >= CSessions())
    {
        // Out of bound!!
        return -1;
    }

    return m_pSessionStateInfo[iIndex].dwSessionId;
}

BOOL SESSION_STATUS::m_FChangeBufSession(int cSessions)
{
	BOOL fRet = FALSE;
	SESSION_STATE_INFO *pSessionStateInfo = (SESSION_STATE_INFO *)realloc(m_pSessionStateInfo, sizeof(SESSION_STATE_INFO) * cSessions);
	if (NULL != pSessionStateInfo)
    {
       	m_pSessionStateInfo = pSessionStateInfo;
    }
    else
	{
		goto Done;
	}
	m_cAllocBufSessions = cSessions;
	fRet = TRUE;
Done:
	return fRet;
}	

// Function for debugging
VOID SESSION_STATUS::m_DumpSessions()
{	
    DEBUGMSG(">>>>>>> DUMPING cached sessions content ");

	for (int iSession = 0; iSession < CSessions(); iSession++)
	{		
		DEBUGMSG(">>> position %d: %lu", iSession, m_pSessionStateInfo[iSession].dwSessionId);
	}

    DEBUGMSG(">>>>>>> END DUMPING cached sessions content ");
}

/**
CacheExistingSessions() 
Enumerates existent sessions and persists the admin sessions for future reference
**/
VOID SESSION_STATUS::CacheExistingSessions()
{	
	PWTS_SESSION_INFO pSessionInfo = NULL;	
	DWORD             dwCount = 0;

    // 
    // Check if TS is enabled and try to enumerate existing
    // sessions. If TS is not running, query only session 0.
    //
	if (_IsTerminalServiceRunning())
    {
        if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &dwCount))
        {
            DEBUGMSG("WUAUENG WTSEnumerateSessions dwCount= %lu",dwCount);

            for (DWORD dwSession = 0; dwSession < dwCount; dwSession++)
            {	
                WTS_SESSION_INFO SessionInfo = pSessionInfo[dwSession];

                DEBUGMSG("WUAUENG CacheExistingSessions, enumerating SessionId =%lu, State =%d",SessionInfo.SessionId, SessionInfo.State);

				if (m_fAllActiveUsers)
				{
					if (WTSActive != SessionInfo.State)
					{
						continue;
					}
					HANDLE hImpersonationToken;
					if (AUGetUserToken(SessionInfo.SessionId, &hImpersonationToken))
					{
						SESSION_STATE SessionState;
						SessionState.fFoundEnumerating = TRUE;
						m_FAddSession(SessionInfo.SessionId, &SessionState);
						CloseHandle(hImpersonationToken);
					}
				}
				else
				{
	                if ((WTSActive != SessionInfo.State) && ( WTSConnected != SessionInfo.State) ||
	                    (m_iFindSession(SessionInfo.SessionId) != CDWNO_SESSION))
	                {
	                    //We only care about Active and Connected sessions that existed before 
	                    //the service was registered, this means that if fAdminSessionLoggedOn is turned on
	                    //the logon notification was received already and we must no check anything
	                    continue;
	                }
	                if (CacheSessionIfAUEnabledAdmin(SessionInfo.SessionId, TRUE))
	                {
	                    DEBUGMSG("WUAUENG Existent Admin Session = %lu",SessionInfo.SessionId);
	                }
				}
            }		

            WTSFreeMemory(pSessionInfo);
        }
        else
        {
            DWORD dwRet = GetLastError();
            DEBUGMSG("WUAUENG WTSEnumerateSessions failed dwRet = %lu", dwRet);
        }
    }
    else
    {
		if (m_fAllActiveUsers)
		{
			HANDLE hImpersonationToken;
			if (AUGetUserToken(0, &hImpersonationToken))
			{
				SESSION_STATE SessionState;
				SessionState.fFoundEnumerating = TRUE;
				m_FAddSession(0, &SessionState);
				CloseHandle(hImpersonationToken);
			}
		}
		else
		{
	        if (CacheSessionIfAUEnabledAdmin(0, TRUE))	//Check Session 0 because Terminal Services are disabled
	        {
	            DEBUGMSG("WUAUENG Existent Admin Session = %d",0);
	        }
		}
    }
#ifdef DBG
    DEBUGMSG("After CacheExistingSessions");
    m_DumpSessions();
#endif    
}

/**
CacheSessionIfAUEnabledAdmin
	Cache session in internal data structure if session has administrator logged on and
	has AU group policy allowing update
	Also store this admin session's origin (logon  notification or via Enumeration)
**/
BOOL SESSION_STATUS::CacheSessionIfAUEnabledAdmin(DWORD dwSessionId, BOOL fFoundEnumerating)
{
	BOOL fRet = TRUE;
	
	if (IsUserAUEnabledAdmin(dwSessionId))
	{
		SESSION_STATE SessionState;
			
		SessionState.fFoundEnumerating = fFoundEnumerating;	
		fRet = m_FAddSession(dwSessionId, &SessionState);		
	}
	else
	{
		fRet = FALSE;
	}

	return fRet;	
}

void SESSION_STATUS::ValidateCachedSessions()
{
    DWORD *rgMarkedForDelete = NULL;
    int   cSession           = 0;
    int   cMarkedForDelete   = 0;

    //m_DumpSessions();

    cSession = CSessions();

    rgMarkedForDelete = new DWORD[cSession];
    if (!rgMarkedForDelete)
    {
        goto cleanup;
    }

	if (m_fInitCS)
	{
		EnterCriticalSection(&m_csWrite);
	}
	for (int i = 0; i < cSession; i++)
	{
        DWORD dwAdminSession = m_iGetSessionIdAtIndex(i);
        if (!IsAUValidSession(dwAdminSession))
        {
            // store the sessions id to be deleted and deleted after we exit the loop
            rgMarkedForDelete[cMarkedForDelete] = dwAdminSession;
            cMarkedForDelete++;
        }
    }

    // delete the pending sessions that are now invalid
    for (int i=0; i < cMarkedForDelete; i++)
    {
        DEBUGMSG("WUAUENG Found cached admin session that is not valid anymore. Deleting entry for session %lu", rgMarkedForDelete[i]);
        m_FDeleteSession(rgMarkedForDelete[i]);
    }
	if (m_fInitCS)
	{
		LeaveCriticalSection(&m_csWrite);
	}

    //m_DumpSessions();

cleanup:

    if (rgMarkedForDelete)
    {
        delete [] rgMarkedForDelete;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\ausens.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  sens.h
//
//  Definition of classes needed for to handle SENS notifications.
//
//  10/9/2001   annah   Created
//
//----------------------------------------------------------------------------

#pragma once

#include <coguid.h>
#include <sens.h>
#include <sensevts.h>
#include <eventsys.h>

//----------------------------------------------------------------------------
// Information used to create the AU subscriptions with ISensLogon
//----------------------------------------------------------------------------

static struct { GUID MethodGuid; LPCWSTR pszMethodName; } g_oLogonSubscription = {
    // Declares the guid and name for our Logon method. 
    // L"{2f519218-754d-4cfe-8daa-5215cd0de0eb}", 
    { 0x2f519218, 0x754d, 0x4cfe, {0x8d, 0xaa, 0x52, 0x15, 0xcd, 0x0d, 0xe0, 0xeb} }, 
    L"Logon"
};
#define SUBSCRIPTION_NAME_TEXT          L"WU Autoupdate"
#define SUBSCRIPTION_DESCRIPTION_TEXT   L"WU Autoupdate Notification subscription"

class CBstrTable {
    void Cleanup()
    {
        SafeFreeBSTR(m_bstrLogonMethodGuid);
        SafeFreeBSTR(m_bstrLogonMethodName);
        SafeFreeBSTR(m_bstrSubscriptionName);
        SafeFreeBSTR(m_bstrSubscriptionDescription);
        SafeFreeBSTR(m_bstrSensEventClassGuid);
        SafeFreeBSTR(m_bstrSensLogonGuid);
    }

public:
    BSTR m_bstrLogonMethodGuid;
    BSTR m_bstrLogonMethodName;
    BSTR m_bstrSubscriptionName;
    BSTR m_bstrSubscriptionDescription;

    BSTR m_bstrSensEventClassGuid;
    BSTR m_bstrSensLogonGuid;

    CBstrTable() :
        m_bstrLogonMethodGuid(NULL),
        m_bstrLogonMethodName(NULL),
        m_bstrSubscriptionName(NULL),
        m_bstrSubscriptionDescription(NULL),
        m_bstrSensEventClassGuid(NULL),
        m_bstrSensLogonGuid(NULL) { }

    ~CBstrTable() { Cleanup(); }

    HRESULT Initialize();
};

//----------------------------------------------------------------------------
// Prototypes for functions used externally
//----------------------------------------------------------------------------

HRESULT ActivateSensLogonNotification();
HRESULT DeactivateSensLogonNotification();

//----------------------------------------------------------------------------
// CSimpleIUnknown
// 
// Light-weight class that implements the basic COM methods.
//----------------------------------------------------------------------------

template<class T> class CSimpleIUnknown : public T
{
public:
    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

protected:
    CSimpleIUnknown() : m_refs(1) {}; // always start with one ref count!
    LONG    m_refs;
};

template<class T> STDMETHODIMP CSimpleIUnknown<T>::QueryInterface(REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    if ((iid == IID_IUnknown) || (iid == _uuidof(T)))
    {
        *ppvObject = static_cast<T *> (this);
        (static_cast<IUnknown *>(*ppvObject))->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

template<class T> ULONG CSimpleIUnknown<T>::AddRef()
{
    ULONG newrefs = InterlockedIncrement(&m_refs);

    return newrefs;
}

template<class T> ULONG CSimpleIUnknown<T>::Release()
{
    ULONG newrefs = InterlockedDecrement(&m_refs);

    if (newrefs == 0)
    {
        DEBUGMSG("Deleting object due to ref count hitting 0");

        delete this;
        return 0;
    }

    return m_refs;
}


//----------------------------------------------------------------------------
// CLogonNotification
//
// This is the class that will be used to subscribe to SENS. As such,
// it needs to implement the IDispatch interface and the ISensLogon methods.
// 
// ISensLogon already inherits from IUnknown and IDispatch, so there's no
// need to make CLogonNotification to do this also.
//
//----------------------------------------------------------------------------

class CLogonNotification : public CSimpleIUnknown<ISensLogon>
{
public:
    CLogonNotification() :
      m_EventSystem( NULL ),
      m_TypeLib( NULL ),
      m_TypeInfo( NULL ),
      m_fSubscribed( FALSE ),
      m_oBstrTable(NULL) {}

    ~CLogonNotification() { Cleanup(); }

    HRESULT Initialize();

private:

    IEventSystem *m_EventSystem;
    ITypeLib     *m_TypeLib;
    ITypeInfo    *m_TypeInfo;

    CBstrTable *m_oBstrTable;
    BOOL        m_fSubscribed;

    void    Cleanup();
    HRESULT SubscribeMethod(const BSTR bstrMethodName, const BSTR bstrMethodGuid);
    HRESULT UnsubscribeAllMethods();
    HRESULT CheckLocalSystem();

public:
    // Other IUnknown methods come from CSimpleIUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);

    // IDispatch methods (needed for SENS subscription)
    HRESULT STDMETHODCALLTYPE GetTypeInfoCount(unsigned int FAR* pctinfo);
    HRESULT STDMETHODCALLTYPE GetTypeInfo(unsigned int iTInfo, LCID lcid, ITypeInfo FAR* FAR* ppTInfo); 
    HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames, LCID lcid, DISPID FAR* rgDispId);
    HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT FAR* pVarResult, EXCEPINFO FAR* pExcepInfo, unsigned int FAR* puArgErr);

    // ISensLogon methods -- we will be using only Logon & Logoff
    HRESULT STDMETHODCALLTYPE DisplayLock( BSTR UserName );
    HRESULT STDMETHODCALLTYPE DisplayUnlock( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StartScreenSaver( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StopScreenSaver( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logon( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logoff( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StartShell( BSTR UserName );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\ausessions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ausessions.h
//  		     Definition of the Updates class
//
//--------------------------------------------------------------------------

#pragma once

#define MAX_WTS 256 // replace 256 by whatever the limit of TS Client is
#define CDWNO_SESSION -2

#define CMIN_SESSIONS 4

//fixcode: why a structure with only one member
//fixcode: misleading name. fSource will be better
typedef struct _Session_State
{
	BOOL fFoundEnumerating;
} SESSION_STATE;

typedef struct _Session_State_Info
{
	DWORD dwSessionId;
	SESSION_STATE SessionState;
} SESSION_STATE_INFO;

class SESSION_STATUS
{
public:
    SESSION_STATUS();
    ~SESSION_STATUS();

	BOOL Initialize(BOOL fUseCriticalSection, BOOL fAllActiveUsers);
	void Clear(void);
	BOOL m_FAddSession(DWORD dwSessionId, SESSION_STATE *pSesState);
	BOOL m_FGetSessionState(DWORD dwSessionId, SESSION_STATE **pSesState ); //check if dwSessionId is in cache	
	BOOL m_FDeleteSession(DWORD dwSessionId);
	int  CSessions(void)
	{
		return m_iLastSession + 1;
	}
	BOOL m_FGetNextSession(DWORD *pdwSessionId);
	BOOL m_FGetCurrentSession(DWORD *pdwSessionId);
    int  m_iGetSessionIdAtIndex(int iIndex);
	int  m_iFindSession(DWORD dwSessionId); //get cache index for dwSessionId

    void m_DumpSessions();   // for debug purposes
    void m_EraseAll();

    BOOL CacheSessionIfAUEnabledAdmin(DWORD dwSessionId, BOOL fFoundEnumerating);
    VOID CacheExistingSessions();
    void ValidateCachedSessions();
    void RebuildSessionCache();
private:
	BOOL m_FChangeBufSession(int cSessions);

	SESSION_STATE_INFO *m_pSessionStateInfo;
	int m_iLastSession;
	int m_cAllocBufSessions;
	int m_iCurSession;	

    CRITICAL_SECTION m_csWrite;
    BOOL m_fAllActiveUsers; //Admin only otherwise
	BOOL m_fInitCS;	// whether critical section has been initialized
};

//#define ALL_SESSIONS -2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\auxml.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auxml.h
//
//  About:  header file for AU related XML and schema data structure and functions
//--------------------------------------------------------------------------

#pragma once
#include <windows.h>
#include <ole2.h>
#include <msxml.h>
#include <URLLogging.h>
#include "AUBaseCatalog.h"

class CItemDetails
{
	public:
		CItemDetails() : m_pxml(NULL) {};
		~CItemDetails() {};
		BOOL Init(BSTR bsxml);
		void Uninit(); 
		HRESULT CloneIdentityNode(BSTR bstrItemId, IXMLDOMDocument *pDesXml, IXMLDOMNode ** ppDesNode);
		HRESULT CloneDescriptionNode(BSTR bstrItemId,IXMLDOMDocument *pDesXml, IXMLDOMNode ** ppDesNode);
		HRESULT ClonePlatformNode(BSTR bstrItemId,IXMLDOMDocument *pDesXml, IXMLDOMNode ** ppDesNode);
		HRESULT GetItemIds(long *puItemNum, BSTR ** ppbstrItemIds);
		HRESULT GetItemInfo(LPCSTR szFieldName, BSTR bstrItemId, BSTR * pbstrItemInfo);
		HRESULT GetCabNames(BSTR bstrItemId, BSTR ** ppCabNames, BSTR **ppRealCabNames, BSTR **ppCabChecksums, UINT *pCabsNum);
        HRESULT GetRTFCRC(BSTR bstrItemId, BSTR * pRTFCRC);
		HRESULT FindFirstExclusiveItem(BSTR *pbstrItemId, AUCatalogItemList & hiddenItemList);
		HRESULT DeleteItem(BSTR bstrItemId);
		HRESULT GetXML(BSTR *pbstrxml);
		HRESULT BuildDirectDependency(AUCatalogItemList IN OUT &item);
		BSTR GetItemDownloadPath(BSTR bstrItemId);
		BOOL IsVisible(BSTR bstrItemId);
		HRESULT  GetItemIdentities(BSTR bstrItemId, IXMLDOMNodeList ** ppIdentityNodeList);

	private:
		IXMLDOMDocument * m_pxml;
		IXMLDOMNode * getIdentityNode(BSTR bstrItemId);
		IXMLDOMNode * getItemNode(BSTR bstrItemId);

};

BOOL fExtractItemInfo(BSTR bstrDetails, AUCatalogItemList & itemList, /*BOOL fDriver,*/ BOOL *pfFoundExclusiveItem/*, BOOL fIgnoreExclusiveNhidden*/);
BSTR ReadXMLFromFile(LPCTSTR szFile);
HRESULT PrepareInstallXML(BSTR bstrItemDetails, AUCatalogItemList &itemList, BSTR * pbstrDownloadResult, BSTR *pbstrInstallation);
HRESULT MergeCatalogs(BSTR bsCatalog1, BSTR bsCatalog2, BSTR *pbsDesCatalog );
HRESULT PersistHiddenItems(AUCatalogItemList &itemlist, URLLOGACTIVITY activity);
HRESULT GetDetailedItemInfoFromDisk(AUCatalogItemList OUT &ItemList, BSTR OUT *pbstrInstallation, BOOL fUpdateDriver);
HRESULT BuildDependencyList(AUCatalogItemList IN OUT &itemlist, BSTR IN bstrDriverDetail, BSTR IN bstrNonDriverDetail);
HRESULT MungleIdentity(IXMLDOMNode *pIdentity, DWORD dwSuffix);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\cauwait.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    CAUWait.h
//
//  Creator: PeterWi
//
//  Purpose: Event waiting management.
//
//=======================================================================

#pragma once
#include "pch.h"

//handle event number should be consecutive and 
// range from AU_HANDLE_EVENT_MIN to AU_HANDLE_EVENT_MAX
typedef enum tagAUEVENT {
	AU_HANDLE_EVENT_MIN = 0,
	AUEVENT_STATE_CHANGED     = AU_HANDLE_EVENT_MIN,
	AUEVENT_SERVICE_FINISHED,
	AUEVENT_NEW_ADMIN_SESSION   ,
	AUEVENT_WUAUCLT_FINISHED    ,
	AUEVENT_POLICY_CHANGE,
	AUEVENT_SETTINGS_CHANGE,
	AUEVENT_CATALOG_VALIDATED,
	AU_HANDLE_EVENT_MAX = AUEVENT_CATALOG_VALIDATED,
	AUEVENT_DUMMY,
	AUEVENT_REMINDER_TIMEOUT    ,
	AUEVENT_DO_DIRECTIVE,  		//skip wait once
	AUEVENT_RELAUNCH_TIMEOUT    ,
	AUEVENT_SCHEDULED_INSTALL,
	AUEVENT_REBOOTWARNING_TIMEOUT
} AUEVENT;
extern HANDLE ghActiveAdminSession;
extern HANDLE ghPolicyChanged;
extern HANDLE ghSettingsChanged;

//=======================================================================
// CAUState
//=======================================================================
class CAUWait
{
public:
    CAUWait() :m_pfSecondaryCltsIsAdmin(NULL), m_phSecondaryClts(NULL){ Reset(); }
    ~CAUWait() 
    {
    	Reset();
    }

    void Reset(void)
    {
//    	DEBUGMSG("CAUWait Reset() called");
		m_fFirstClientIsAdmin = TRUE;
        m_dwSecondaryClts= 0;
        m_timeoutID = AUEVENT_DUMMY;
        m_fProrateTimeout = TRUE;
        m_fSkipWaitOnce = FALSE;
        SafeFreeNULL(m_pfSecondaryCltsIsAdmin);
        SafeFreeNULL(m_phSecondaryClts);
        ZeroMemory(&m_hEventHandles, sizeof(m_hEventHandles));
        ZeroMemory(&m_stTimeout, sizeof(m_stTimeout));
        m_Add(AUEVENT_STATE_CHANGED);
        m_Add(AUEVENT_SERVICE_FINISHED);
        m_Add(AUEVENT_POLICY_CHANGE);
        m_Add(AUEVENT_SETTINGS_CHANGE);
    }

    BOOL  Add(AUEVENT eventID, HANDLE hEvent = NULL, BOOL fAdmin = FALSE)
    {
		if (AUEVENT_DO_DIRECTIVE == eventID)
		{
			m_fSkipWaitOnce = TRUE;
			return TRUE;
		}
       	return m_Add(eventID, hEvent, fAdmin);
    }

    void Timeout(AUEVENT eventID, DWORD dwTimeout, BOOL fProrate = TRUE)
    {
        m_timeoutID = eventID;
        GetSystemTime(&m_stTimeout);
        TimeAddSeconds(m_stTimeout, dwTimeout, &m_stTimeout);
        m_fProrateTimeout = fProrate;
#if 0        
#ifdef DBG
		TCHAR szTime[50];
		if (SUCCEEDED(SystemTime2String(m_stTimeout, szTime, ARRAYSIZE(szTime))))
		{
			DEBUGMSG("next time out time is %S", szTime);
		}
#endif
#endif
    }

   AUEVENT GetTimeoutEvent(void) 
   	{
   	return m_timeoutID;
   	}

   DWORD GetTimeoutValue(void)
   {
   	SYSTEMTIME stCur;
   	GetSystemTime(&stCur);
	return max(TimeDiff(stCur, m_stTimeout), 0);
   }
   
    BOOL Wait(HANDLE *pHandle, BOOL *pfAdmin, AUEVENT *pfEventId)
    {
    	DWORD dwTimeout;
    	BOOL fRet = TRUE;
    	AUASSERT(pHandle != NULL);
    	AUASSERT(pfAdmin != NULL);
    	AUASSERT(NULL != pfEventId);
    	*pHandle = NULL;
    	*pfAdmin = FALSE;
    	*pfEventId = AUEVENT_DUMMY;
    	if (m_fSkipWaitOnce)
    	{
    		m_fSkipWaitOnce = FALSE;
    		*pfEventId = AUEVENT_DO_DIRECTIVE;
    		return TRUE;
    	}
		if (AUEVENT_DUMMY == m_timeoutID)
		{
			dwTimeout = INFINITE;
		}
		else
		{
			SYSTEMTIME stCur;
			GetSystemTime(&stCur);
			dwTimeout = max(TimeDiff(stCur, m_stTimeout), 0);
			dwTimeout = m_fProrateTimeout ? dwTimeToWait(dwTimeout): dwTimeout * 1000;
//			DEBUGMSG("Wait() timeout value is %d msecs", dwTimeout);
		}

		HANDLE *phandles = NULL;
		DWORD dwCount = 0;
		HandleList(FALSE, &phandles, &dwCount); //get handle list
		AUASSERT(dwCount > 0);	
		AUASSERT(NULL != phandles);
		AUEVENT eventid = AUEVENT_DUMMY;
        DWORD dwRet = WaitForMultipleObjects(dwCount, phandles, FALSE, dwTimeout);
        if ( (WAIT_OBJECT_0 + dwCount - 1) >= dwRet )
        {
            *pHandle = phandles[dwRet - WAIT_OBJECT_0];
            eventid = GetEventID(*pHandle);
            if (AUEVENT_WUAUCLT_FINISHED == eventid)
            {
            	*pfAdmin = fIsCltAdmin(*pHandle);
            	DEBUGMSG("%s wuauclt exited", *pfAdmin ? "Admin" : "Nonadmin");
            }
			RemoveHandle(eventid, *pHandle);
        }
        else if ( WAIT_TIMEOUT == dwRet )
        {
            eventid = m_timeoutID;
	        m_timeoutID = AUEVENT_DUMMY;
        }
        else
        {
        	fRet = FALSE;
        }
   		HandleList(TRUE, &phandles); //free handle list if allocated
        	
#ifdef DBG
	char buf[100];
	    switch (eventid)
	        {
	        case AUEVENT_STATE_CHANGED: StringCchCopyExA(buf, ARRAYSIZE(buf), "state change", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_POLICY_CHANGE: StringCchCopyExA(buf, ARRAYSIZE(buf), "policy change", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_RELAUNCH_TIMEOUT: StringCchCopyExA(buf, ARRAYSIZE(buf), "relaunch timeout", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_REMINDER_TIMEOUT: StringCchCopyExA(buf, ARRAYSIZE(buf), "reminder timeout", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_SCHEDULED_INSTALL: StringCchCopyExA(buf, ARRAYSIZE(buf), "schedule install", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_WUAUCLT_FINISHED: StringCchCopyExA(buf, ARRAYSIZE(buf), "wuauclt finished", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_SERVICE_FINISHED: StringCchCopyExA(buf, ARRAYSIZE(buf), "service finished", NULL, NULL, MISTSAFE_STRING_FLAGS);break;
	        case AUEVENT_NEW_ADMIN_SESSION: StringCchCopyExA(buf, ARRAYSIZE(buf), "new admin session", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_SETTINGS_CHANGE: StringCchCopyExA(buf, ARRAYSIZE(buf), "settings changed", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_DO_DIRECTIVE: StringCchCopyExA(buf, ARRAYSIZE(buf), "doing directive, skip wait once", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_CATALOG_VALIDATED: StringCchCopyExA(buf, ARRAYSIZE(buf), "catalog validation done", NULL, NULL, MISTSAFE_STRING_FLAGS); break;
	        case AUEVENT_REBOOTWARNING_TIMEOUT: StringCchCopyExA(buf, ARRAYSIZE(buf), "reboot warning engine timeout", NULL, NULL, MISTSAFE_STRING_FLAGS);break;
	        default: StringCchCopyExA(buf, ARRAYSIZE(buf), "error", NULL, NULL, MISTSAFE_STRING_FLAGS);
	        }
	    DEBUGMSG("Wait object wake up for %s with handle %lx", buf, *pHandle);
#endif
		*pfEventId = eventid;
        return fRet;
    }

private:
	//assumption: handle is unique in the list
    BOOL m_Add(AUEVENT eventID, HANDLE hEvent = NULL, BOOL fAdmin = FALSE)
    {
    	if (eventID >= ARRAYSIZE(m_hEventHandles))
    	{
    		AUASSERT(FALSE); //should never be
    		return FALSE;
    	}
        if ( NULL != hEvent )
        {
        	if (AUEVENT_WUAUCLT_FINISHED != eventID)
        	{
        		m_hEventHandles[eventID] = hEvent;
        	}
        	else
        	{
        		if (NULL == m_hEventHandles[eventID])
        		{
        			m_hEventHandles[eventID] = hEvent;
        			m_fFirstClientIsAdmin = fAdmin;
        		}
        		else
        		{ //more than one client
					HANDLE *pTmp = (HANDLE *)malloc((m_dwSecondaryClts+1)*sizeof(*pTmp));
					if (NULL == pTmp)
					{
						return FALSE;
					}
					BOOL *pTmp2 = (BOOL *) malloc((m_dwSecondaryClts + 1) * sizeof(*pTmp2));
					if (NULL == pTmp2)
					{
						free(pTmp);
						return FALSE;
					}
					for (UINT i = 0; i < m_dwSecondaryClts; i++)
					{
						pTmp[i] = m_phSecondaryClts[i];
						pTmp2[i] = m_pfSecondaryCltsIsAdmin[i];
					}
					m_dwSecondaryClts++;
					pTmp[m_dwSecondaryClts-1] = hEvent;
					pTmp2[m_dwSecondaryClts-1] = fAdmin;
					SafeFree(m_phSecondaryClts);
					SafeFree(m_pfSecondaryCltsIsAdmin);
					m_phSecondaryClts = pTmp;
					m_pfSecondaryCltsIsAdmin = pTmp2;
        		}
        	}

            return TRUE;
        }
        else
        {
            switch (eventID)
            {
            case AUEVENT_STATE_CHANGED:
                return m_Add(eventID, ghEngineState);

            case AUEVENT_SERVICE_FINISHED:
                return m_Add(eventID, ghServiceFinished);

            case AUEVENT_NEW_ADMIN_SESSION:
                return m_Add(eventID, ghActiveAdminSession);

            case AUEVENT_POLICY_CHANGE:
                return m_Add(eventID, ghPolicyChanged);

            case AUEVENT_SETTINGS_CHANGE:
				return m_Add(eventID, ghSettingsChanged);

            case AUEVENT_CATALOG_VALIDATED:
            	return m_Add(eventID, ghValidateCatalog);
                
            default:
                DEBUGMSG("Unknown event id %d", eventID);
                AUASSERT(FALSE); //should never be here
                return FALSE;
            }
        }
    }

private:
    HANDLE  m_hEventHandles[AU_HANDLE_EVENT_MAX - AU_HANDLE_EVENT_MIN + 1];
    BOOL    m_fFirstClientIsAdmin; // for the first clt
    HANDLE  *m_phSecondaryClts;
    BOOL 	*m_pfSecondaryCltsIsAdmin;
    DWORD   m_dwSecondaryClts;
	SYSTEMTIME m_stTimeout; //when timeout should happen
    AUEVENT   m_timeoutID;
    BOOL 	m_fProrateTimeout;//whether to prorate Timeout when do actual wait
    BOOL 	m_fSkipWaitOnce;

    BOOL fIsEventInherent(DWORD dwEventId)
    {
    	if (AUEVENT_STATE_CHANGED == dwEventId ||
        	AUEVENT_SERVICE_FINISHED==dwEventId ||
        	AUEVENT_POLICY_CHANGE == dwEventId ||
        	AUEVENT_SETTINGS_CHANGE == dwEventId)
    	{
    		return TRUE;
    	}
    	else
    	{
    		return FALSE;
    	}
    }

	//get or free handle list
	//IN fFreeList: if TRUE, free *pHandles list got
	//			if FALSE, get the handle list
    void HandleList(BOOL fFreeList, HANDLE **pHandles, DWORD *pdwCount = NULL) const
    {
	    static HANDLE handles[ARRAYSIZE(m_hEventHandles)];
		DWORD dwCount = 0;

		if (NULL== pHandles )
		{
			return ;
		}
		if (fFreeList)
		{
			if (*pHandles != handles)
			{
				free(*pHandles);
			}
			return;
		}
		if  (NULL == pdwCount)
		{
			return;
		}

		*pHandles = NULL;
	    *pdwCount =0;
       	ZeroMemory(&handles, sizeof(handles));
	    for (UINT i = 0; i < ARRAYSIZE(m_hEventHandles); i++)
		{
			if (NULL != m_hEventHandles[i])
			{
				handles[dwCount++] = m_hEventHandles[i];
			}
		}
		*pHandles = handles;
		if (0 != m_dwSecondaryClts)
		{ //need to wait for more than one client
			AUASSERT(m_phSecondaryClts != NULL);
			if (NULL != (*pHandles = (HANDLE *) malloc((dwCount + m_dwSecondaryClts) * sizeof(**pHandles))))
			{
				for (UINT j = 0 ; j < dwCount; j++)
				{
					(*pHandles)[j] = handles[j];
				}
				for (j = 0; j< m_dwSecondaryClts; j++)
				{
					(*pHandles)[dwCount+j] = m_phSecondaryClts[j];
				}
				dwCount += m_dwSecondaryClts;
			}
			else
			{
				*pHandles = handles;
			}
		}
		*pdwCount = dwCount;
    }

	//return TRUE if handle removed from internal wait list or handle does not need to be removed
	//return FALSE if handle not found
	BOOL RemoveHandle(IN AUEVENT eventid , IN HANDLE & handle)
	{
		AUASSERT(NULL != handle);
		if (fIsEventInherent(eventid))
	   {
	   	return TRUE;
	   }
	   //remove non inhereant events once signalled
		for (UINT i = 0; i < ARRAYSIZE(m_hEventHandles); i++)
		{
			if (handle == m_hEventHandles[i])
			{
				m_hEventHandles[i] = NULL;
				return TRUE;
			}
		}
		for (i = 0; i < m_dwSecondaryClts; i++)
		{
			if (handle == m_phSecondaryClts[i])
			{
				m_phSecondaryClts[i] = m_phSecondaryClts[m_dwSecondaryClts-1];
				m_pfSecondaryCltsIsAdmin[i] = m_pfSecondaryCltsIsAdmin[m_dwSecondaryClts - 1];
				m_phSecondaryClts[m_dwSecondaryClts-1] = NULL;
				m_pfSecondaryCltsIsAdmin[m_dwSecondaryClts - 1] = FALSE;
				m_dwSecondaryClts--;
				if (0 == m_dwSecondaryClts)
				{
					SafeFreeNULL(m_phSecondaryClts);
					SafeFreeNULL(m_pfSecondaryCltsIsAdmin);
				}
				return TRUE;
			}
		}
		AUASSERT(FALSE); //should never be here
		return FALSE;
	}

	BOOL fIsCltAdmin(HANDLE & handle) const
	{
		AUASSERT(NULL != handle);
		if (handle == m_hEventHandles[AUEVENT_WUAUCLT_FINISHED])
		{
			return m_fFirstClientIsAdmin;
		}
		for (UINT i = 0; i < m_dwSecondaryClts; i++)
		{
			if (handle == m_phSecondaryClts[i])
			{
				return m_pfSecondaryCltsIsAdmin[i];
			}
		}
		AUASSERT(FALSE); //should never be here
		return FALSE;
	}

	AUEVENT GetEventID(HANDLE &handle) const
	{
		AUASSERT(NULL!= handle);
		for (UINT i = 0; i < ARRAYSIZE(m_hEventHandles); i++)
		{
			if (handle == m_hEventHandles[i])
			{
				return (AUEVENT)i;
			}
		}
		for (i = 0; i< m_dwSecondaryClts; i++)
		{
			if (handle == m_phSecondaryClts[i])
			{
				return AUEVENT_WUAUCLT_FINISHED;
			}
		}
		AUASSERT(FALSE); //should never be here
		return AUEVENT_DUMMY;
	}	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\pch.h ===
//#pragma warning( push, 3 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <comdef.h>
#include "iucommon.h"
#include "criticalfixreg.h"
#include "audirectory.h"
#include "wuaulib.h"
#include "caustate.h"
#include "wuaueng.h"
#include "AUSessions.h"
#include "aucatalog.h"
#include "wuaustate.h"
#include "aucpl.h"
#include "prsheet.h"
#include "resource.h"
#include "wuverp.h"
#include "auservinternals.h"
#include <shlobj.h>
#include <advpub.h>
#include <sfcapip.h>
#include <shlwapi.h>
#include <tchar.h>
#include "download.h"
#include "wuauengi.h"
#include <initguid.h>
#include <Wtsapi32.h>
#include "Updates.h"
extern "C"
{
#include <winsta.h>
#include <syslib.h>
}
#include "ausvc.h"
#include <winsock2.h>
#include <aumsgs.h>
#include <auregkeys.h>
#include <auwait.h>
#include <safefunc.h>
#include <RedirectUtil.h>
#include <windowsx.h>
#include "AUEventLog.h"
#include "schemamisc.h"
#include "auxml.h"
#include "audownload.h"
#include "logging.h"
#include "aucomres.h"
#include "schemakeys.h"
#include "CAUWait.h"
#include "ausens.h"
#include "tscompat.h"
#include "service.h"
#include <userenv.h>
#include "AUEventMsgs.h"
#include "memutil.h"
#include <msiquery.h>
#include <msi.h>
#include <sddl.h>
#include "fileutil.h"
#include "WUTestKeys.h"
#include "wusafefn.h"
#include "MISTSafe.h"

//#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\caustate.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    CAUState.h
//
//  Creator: PeterWi
//
//  Purpose: AU state functions.
//
//=======================================================================
#include "safefunc.h"
#include "wuaulib.h"
#include "wuaustate.h"
#include "auwait.h"


#pragma once

extern BOOL  gfDownloadStarted; //to be used to distinguish connection detection and actually downloading mode

typedef enum
{
    enAU_DomainPolicy,
    enAU_AdminPolicy,
    enAU_WindowsUpdatePolicy,
    enAU_IUControlPolicy
} enumAUPolicyType;

typedef enum
{
	AUPOLICYCHANGE_NOOP,
	AUPOLICYCHANGE_RESETENGINE,
	AUPOLICYCHANGE_RESETCLIENT,
	AUPOLICYCHANGE_DISABLE
}enumAUPOLICYCHANGEACTION;

//AU configurable registry settings
#ifdef DBG
extern const TCHAR REG_AUCONNECTWAIT[] ;//= _T("ConnectWait"); //REG_DWORD
extern const TCHAR REG_SELFUPDATE_URL[]; // = _T("SelfUpdateURL");
#endif

extern const TCHAR REG_WUSERVER_URL[]; // = _T("WUServer");
extern const TCHAR REG_WUSTATUSSERVER_URL[]; // = _T("WUStatusServer");
extern const TCHAR REG_IDENT_URL[]; // = _T("IdentServer");
extern const TCHAR WU_LIVE_URL[]; // = _T("http://windowsupdate.microsoft.com/v4");


BOOL fURLChanged(LPCTSTR url1, LPCTSTR url2);

//read only settings
class AUPolicySettings {
public:
	AUPolicySettings() :m_enPolicyType(enAU_DomainPolicy), m_dwOption(AUOPTION_UNSPECIFIED),
					m_dwSchedInstallDay(0), m_dwSchedInstallTime(0),
				 	m_pszWUServerURL(NULL), m_pszWUStatusServerURL(NULL), m_fRegAUOptionsSpecified(TRUE)
		{};
	~AUPolicySettings() {
	        SafeFree(m_pszWUServerURL);
	        SafeFree(m_pszWUStatusServerURL);
		}
	enumAUPolicyType m_enPolicyType;
	BOOL 	   m_fRegAUOptionsSpecified;
	DWORD m_dwOption;
	DWORD m_dwSchedInstallDay;
	DWORD m_dwSchedInstallTime;
	LPTSTR  m_pszWUServerURL;
	LPTSTR  m_pszWUStatusServerURL;

	void Reset(void) {
		m_enPolicyType = enAU_DomainPolicy;
		m_dwOption = AUOPTION_UNSPECIFIED;
		m_dwSchedInstallDay = 0;
		m_dwSchedInstallTime = 0;
		m_fRegAUOptionsSpecified = TRUE;
		SafeFreeNULL(m_pszWUServerURL);
		SafeFreeNULL(m_pszWUStatusServerURL);
	}
		
	HRESULT  m_ReadIn();
	HRESULT m_SetOption(AUOPTION & Option);
	HRESULT m_SetInstallSchedule(DWORD dwSchedInstallDay, DWORD dwSchedInstallTime);

	BOOL	operator == (AUPolicySettings & setting2)
		{ 
			return m_enPolicyType == setting2.m_enPolicyType 
					&& m_dwOption == setting2.m_dwOption
					&& m_dwSchedInstallDay == setting2.m_dwSchedInstallDay
					&& m_dwSchedInstallTime == setting2.m_dwSchedInstallTime
					&& !fURLChanged(m_pszWUServerURL, setting2.m_pszWUServerURL)
					&& !fURLChanged(m_pszWUStatusServerURL, setting2.m_pszWUStatusServerURL);
		}

	HRESULT  Copy (AUPolicySettings & setting2)
		{
			HRESULT hr = E_FAIL;
			AUASSERT(this != &setting2);
			if (this == &setting2)
			{
				return E_INVALIDARG;
			}
			Reset();
			m_enPolicyType = setting2.m_enPolicyType;
			m_dwOption = setting2.m_dwOption;
			m_dwSchedInstallDay = setting2.m_dwSchedInstallDay;
			m_dwSchedInstallTime = setting2.m_dwSchedInstallTime;
			m_fRegAUOptionsSpecified = setting2.m_fRegAUOptionsSpecified;
			if (NULL != setting2.m_pszWUServerURL)
			{
				size_t cchWUServerURL = lstrlen(setting2.m_pszWUServerURL) + 1;
				m_pszWUServerURL = (LPTSTR) malloc(cchWUServerURL * sizeof(TCHAR));
				if (NULL == m_pszWUServerURL)
				{
					hr = E_OUTOFMEMORY;
					goto done;
				}
                if (FAILED(hr = StringCchCopyEx(m_pszWUServerURL, cchWUServerURL, setting2.m_pszWUServerURL, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                {
                	goto done;
                }
			}
			if (NULL != setting2.m_pszWUStatusServerURL)
			{
				size_t cchWUStatusServerURL = lstrlen(setting2.m_pszWUStatusServerURL) + 1;
                m_pszWUStatusServerURL =(LPTSTR) malloc(cchWUStatusServerURL * sizeof(TCHAR));
				if (NULL == m_pszWUStatusServerURL)
				{
					hr = E_OUTOFMEMORY;
					goto done;
				}
                if (FAILED(hr = StringCchCopyEx(m_pszWUStatusServerURL, cchWUStatusServerURL, setting2.m_pszWUStatusServerURL, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                {
                	goto done;
                }
			}
			hr = S_OK;
			
done:
			//in case of failure, keep the most accurate information we could have
			if (FAILED(hr))
			{
				SafeFreeNULL(m_pszWUServerURL);
				SafeFreeNULL(m_pszWUStatusServerURL);
			}
			return hr;
		}				



#ifdef DBG
	void m_DbgDump(void)
	{
		    DEBUGMSG("Policy location: %s", (enAU_DomainPolicy == m_enPolicyType) ? "domain" : "admin");
		    DEBUGMSG("Option: %d", m_dwOption);
		    DEBUGMSG("ScheduledInstallDay: %d", m_dwSchedInstallDay);
		    DEBUGMSG("ScheduledInstallTime: %d", m_dwSchedInstallTime);
		    DEBUGMSG("WUServerURL string is: %S", m_pszWUServerURL);
		    DEBUGMSG("WUStatusServerURL string is: %S", m_pszWUStatusServerURL);
	}
#endif

private:
	HRESULT m_ReadOptionPolicy(void);
	HRESULT m_ReadScheduledInstallPolicy(void);
	HRESULT m_ReadWUServerURL(void);
};
	

class CAUState
{
public:
    static HRESULT HrCreateState(void);
    CAUState();
    ~CAUState()
    {
    	SafeCloseHandleNULL(m_hMutex);
        SafeFree(m_pszTestIdentServerURL);
#ifdef DBG        
        SafeFree(m_pszTestSelfUpdateURL);
#endif
    }

    // Option methods
    AUOPTION GetOption(void) ;
    HRESULT SetOption(AUOPTION & Option);
    HRESULT SetInstallSchedule(DWORD dwSchedInstallDay, DWORD dwSchedInstallTime);
    void GetInstallSchedule(DWORD *pdwSchedInstallDay, DWORD *pdwSchedInstallTime);
    BOOL fOptionAutoDownload(void)
    {
        return ((AUOPTION_INSTALLONLY_NOTIFY == m_PolicySettings.m_dwOption) ||
                (AUOPTION_SCHEDULED == m_PolicySettings.m_dwOption));
    }

    BOOL fOptionSchedInstall(void)
    	{
    		return AUOPTION_SCHEDULED == m_PolicySettings.m_dwOption;
    	}
    BOOL fOptionEnabled(void)
    	{
    		return AUOPTION_AUTOUPDATE_DISABLE != m_PolicySettings.m_dwOption;
    	}
    BOOL fShouldScheduledInstall(void)
    	{  //in which case launch AU client via local system
    	return (AUOPTION_SCHEDULED == m_PolicySettings.m_dwOption) 
    		&& (AUSTATE_DOWNLOAD_COMPLETE == m_dwState);
    	}

    BOOL fValidationNeededState(void)
    {
    	return AUSTATE_DETECT_COMPLETE == m_dwState || AUSTATE_DOWNLOAD_COMPLETE == m_dwState;
    }
    
    // State methods
    DWORD GetState(void) { return m_dwState; }
    void SetState(DWORD dwState);
    DWORD GetCltAction(void) { return m_dwCltAction;}
    void SetCltAction(DWORD dwCltAction) { m_dwCltAction = dwCltAction;}

    // Helper functions
    HRESULT HrInit(BOOL fInit = FALSE);
    HRESULT Refresh(enumAUPOLICYCHANGEACTION *pactcode);
    BOOL fWasSystemRestored(void);
    BOOL fDisconnected(void) { return m_fDisconnected; }
    void SetDisconnected(BOOL fDisconnected);

    static HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue, enumAUPolicyType enPolicyType = enAU_AdminPolicy);
	static HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue, enumAUPolicyType enPolicyType = enAU_AdminPolicy, DWORD options = REG_OPTION_NON_VOLATILE);
	static HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int nCharCount, enumAUPolicyType enPolicyType);
	static HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue, enumAUPolicyType enPolicyType);

    HRESULT CalculateScheduledInstallSleepTime(DWORD *pdwSleepTime );
	void GetSchedInstallDate(AUFILETIME & auftSchedInstallDate) { auftSchedInstallDate = m_auftSchedInstallDate; }

	void SetDetectionStartTime(BOOL fOverwrite);
	BOOL IsUnableToConnect(void);
	void RemoveDetectionStartTime(void);

    LPCTSTR GetIdentServerURL(void)
    {
        LPCTSTR pszRet = WU_LIVE_URL;

        if ( NULL != m_pszTestIdentServerURL )
        {
            pszRet = m_pszTestIdentServerURL;
        }
        else if ( NULL != m_PolicySettings.m_pszWUServerURL )
        {
            pszRet = m_PolicySettings.m_pszWUServerURL;
        }

        return pszRet;
    }

    LPTSTR GetSelfUpdateServerURLOverride(void)
    {
        LPTSTR pszRet = NULL;

#ifdef DBG
        if ( NULL != m_pszTestSelfUpdateURL )
        {
            return m_pszTestSelfUpdateURL;
        }
#endif        
		if ( NULL != m_PolicySettings.m_pszWUServerURL )
        {
            pszRet = m_PolicySettings.m_pszWUServerURL;
        }

        return pszRet;
    }

	BOOL fInCorpWU(void)
	{
		return (NULL != m_PolicySettings.m_pszWUStatusServerURL);
	}

    BOOL fWin2K(void) { return m_fWin2K; }
    BOOL fShouldAutoDownload(BOOL fUserAvailable)
    {
        return !fUserAvailable && (AUSTATE_DETECT_COMPLETE == m_dwState) && fOptionAutoDownload();
    }
public:
	HANDLE m_hMutex; //protect against simultaneous writing

private:
    HRESULT m_ReadPolicy(BOOL fInit);
    void m_ReadRegistrySettings(BOOL fInit);
    HRESULT m_ReadTestOverrides(void);
    HRESULT m_SetScheduledInstallDate(void);
    HRESULT m_CalculateScheduledInstallDate(AUFILETIME & auftSchedInstallDate, DWORD *pdwSleepTime);
    void m_Reset(void);
    BOOL m_lock(void)
    {
    	AUASSERT(NULL != m_hMutex);
    	if (WAIT_FAILED == WaitForSingleObject(m_hMutex, INFINITE))
    	{
    		AUASSERT(FALSE); //should never be here
    		return FALSE;
    	}
    	return TRUE;
    }
	void m_unlock(void)
	{
		ReleaseMutex(m_hMutex);
	}

#ifdef DBG
    void m_DbgDumpState(void);
#endif

    AUPolicySettings 	m_PolicySettings;
    DWORD    m_dwState;
    AUFILETIME m_auftSchedInstallDate;
    AUFILETIME m_auftDetectionStartTime;
    DWORD    m_dwCltAction;
    BOOL     m_fDisconnected;
    BOOL     m_fWin2K;
    LPTSTR   m_pszTestIdentServerURL;
#ifdef DBG
    LPTSTR   m_pszTestSelfUpdateURL;
#endif

};

// global state object pointer
extern CAUState *gpState;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\muiutil.cpp ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    muiutil.cpp

Abstract:
    Implements helper functions for self-updating MUI stuff

******************************************************************************/

#include "pch.h"
#include "muiutil.h"
#include "osdet.h"

typedef struct tagSLangIDStringMap
{
    LANGID langid;
    LPTSTR szISOName;
} SLangIDStringMap;

/*

// this is a combination of the languages used by WU and the languages used
//  by MUI
// Mappings determined from the following sources
// For langid to full language name : MSDN
// full language name to 2 char name: http://www.oasis-open.org/cover/iso639a.html
// country name to 2 character name : http://www.din.de/gremien/nas/nabd/iso3166ma

This table is no longer used, but is kept as a reference for langid -> string
mappings

const SLangIDStringMap g_rgLangMap[] = 
{
	{ 0x0401, _T("ar") },
	{ 0x0402, _T("bg") },
	{ 0x0403, _T("ca") },
	{ 0x0404, _T("zhTW") },
	{ 0x0405, _T("cs") },
	{ 0x0406, _T("da") },
	{ 0x0407, _T("de") },
	{ 0x0408, _T("el") },
	{ 0x0409, _T("en") },
	{ 0x040b, _T("fi") },
	{ 0x040c, _T("fr") },
	{ 0x040d, _T("he") },
	{ 0x040e, _T("hu") },
	{ 0x0410, _T("it") },
	{ 0x0411, _T("ja") },
	{ 0x0412, _T("ko") },
	{ 0x0413, _T("nl") },
	{ 0x0414, _T("no") },
	{ 0x0415, _T("pl") },
	{ 0x0416, _T("ptBR") },
	{ 0x0418, _T("ro") },
	{ 0x0419, _T("ru") },
	{ 0x041a, _T("hr") },
	{ 0x041b, _T("sk") },
	{ 0x041d, _T("sv") },
	{ 0x041e, _T("en") },
	{ 0x041f, _T("tr") },
	{ 0x0424, _T("sl") },
	{ 0x0425, _T("et") },
	{ 0x0426, _T("lv") },
	{ 0x0427, _T("lt") },
	{ 0x042d, _T("eu") },
	{ 0x0804, _T("zhCN") },
	{ 0x080a, _T("es") },
	{ 0x0816, _T("pt") },
	{ 0x0c0a, _T("es") }
};
*/


// ******************************************************************************
BOOL MapLangIdToStringName(LANGID langid, LPCTSTR pszIdentFile, 
                           LPTSTR pszLangString, DWORD cchLangString)
{
	LOG_Block("MapLangIdToStringName");

    TCHAR   szLang[32];
    DWORD   cch;
    LCID    lcid;
    BOOL    fRet = FALSE;

    lcid = MAKELCID(langid, SORT_DEFAULT);

    fRet = LookupLocaleStringFromLCID(lcid, szLang, ARRAYSIZE(szLang));
    if (fRet == FALSE)
    {
        LOG_ErrorMsg(GetLastError());
        goto done;
    }

    // first try the whole string ("<lang>-<country>")
    cch = GetPrivateProfileString(IDENT_LANG, szLang, 
                                  _T(""),
                                  pszLangString, cchLangString, 
                                  pszIdentFile);
    if (cch == cchLangString - 1)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        LOG_ErrorMsg(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }

    // if that fails, strip off the country code & just try the language
    else if (cch == 0)
    {
        LPTSTR pszDash;

        pszDash = StrChr(szLang, _T('-'));
        if (pszDash != NULL)
        {
            *pszDash = _T('\0');
            cch = GetPrivateProfileString(IDENT_LANG, szLang, 
                                          _T(""),
                                          pszLangString, cchLangString, 
                                          pszIdentFile);
            if (cch == cchLangString - 1)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                LOG_ErrorMsg(ERROR_INSUFFICIENT_BUFFER);
                goto done;
            }
        }
    }

    if (cch > 0 && pszLangString[0] == _T('/'))
    {
        // want to use the full cch (& not cch - 1) because we want to copy the
        //  NULL terminator also...
        MoveMemory(&pszLangString[0], &pszLangString[1], cch * sizeof(TCHAR));
    }

    fRet = TRUE;

done:
    return fRet;    
}

// ******************************************************************************
BOOL CALLBACK EnumUILangProc(LPTSTR szUILang, LONG_PTR lParam)
{
	LOG_Block("EnumUILangProc");

    AU_LANGLIST *paull = (AU_LANGLIST *)lParam;
    AU_LANG     *paulNew = NULL;
    HRESULT     hr;
    LANGID      langid;
    LPTSTR      pszStop;
    TCHAR       szAUName[32];
    DWORD       cchMuiName, cchAUName, cbNeed, cchAvail, dwLangID;
    BOOL        fRet = FALSE, fMap;

    if (szUILang == NULL || lParam == NULL)
        goto done;

    langid = (LANGID)_tcstoul(szUILang, &pszStop, 16);

    // if we don't have a mapping for a langid, then just skip the language
    //  and return success
    szAUName[0] = _T('\0');
    fMap = MapLangIdToStringName(langid, paull->pszIdentFile,
                                 szAUName, ARRAYSIZE(szAUName));
    if (fMap == FALSE || szAUName[0] == _T('\0'))
    {
        fRet = TRUE;
        goto done;
    }

    if (paull->cLangs >= paull->cSlots)
    {
        AU_LANG **rgpaulNew = NULL;
        DWORD   cNewSlots = paull->cSlots * 2;

        if (cNewSlots == 0)
            cNewSlots = 32;

        if (paull->rgpaulLangs != NULL)
        {
            rgpaulNew = (AU_LANG **)HeapReAlloc(GetProcessHeap(), 
                                                HEAP_ZERO_MEMORY,
                                                paull->rgpaulLangs,
                                                cNewSlots * sizeof(AU_LANG *));
        }
        else
        {
            rgpaulNew = (AU_LANG **)HeapAlloc(GetProcessHeap(),
                                              HEAP_ZERO_MEMORY,
                                              cNewSlots * sizeof(AU_LANG *));
        }
        if (rgpaulNew == NULL)
            goto done;

        paull->rgpaulLangs = rgpaulNew;
        paull->cSlots      = cNewSlots;
    }

    // we will be adding an '_' to the beginning of the AUName, so make sure
    //  the size we compute here reflects that.
    cchAUName  = lstrlen(szAUName) + 1;
    cchMuiName = lstrlen(szUILang);

    // alloc a buffer to hold the AU_LANG struct plus the two strings (and 
    //  don't forget the NULL terminators!).
    // The layout of the buffer is as follows:
    //  <AU_LANG>
    //  <szMuiName>
    //  _<szAUName>
    // NOTE: if this buffer format ever change, gotta make sure that the 
    //  contents are aligned properly (otherwise, we'll fault on ia64)
    cbNeed =  sizeof(AU_LANG);
    cbNeed += ((cchMuiName + cchAUName + 2) * sizeof(TCHAR));
    paulNew = (AU_LANG *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbNeed);
    if (paulNew == NULL)
        goto done;

    paulNew->szMuiName = (LPTSTR)((PBYTE)paulNew + sizeof(AU_LANG)); 
    paulNew->szAUName  = paulNew->szMuiName + cchMuiName + 1;

    // this should never truncate the buffers cuz we calc'ed the size above and
    //  allocated a buffer exactly long enuf to hold all of this
    cchAvail = (cbNeed - sizeof(AU_LANG)) / sizeof(TCHAR);
    hr = StringCchCopyEx(paulNew->szMuiName, cchAvail, szUILang, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto done;

    cchAvail -= (cchMuiName + 1);

    // need to put an '_' in front of the AU name, so add it to the buffer and
    //  reduce the available size by one.  Also make sure to start copying the
    //  AUName *after* the '_' character.
    paulNew->szAUName[0] = _T('_');
    cchAvail--;
    
    hr = StringCchCopyEx(&paulNew->szAUName[1], cchAvail, szAUName, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto done;
    
    paull->rgpaulLangs[paull->cLangs++] = paulNew;
    paulNew = NULL;

    fRet = TRUE;

done:
    if (paulNew != NULL)
        HeapFree(GetProcessHeap(), 0, paulNew);
    
    return fRet;
}

// ******************************************************************************
HRESULT GetMuiLangList(AU_LANGLIST *paull, 
                       LPTSTR pszMuiDir, DWORD *pcchMuiDir,
                       LPTSTR pszHelpMuiDir, DWORD *pcchHelpMuiDir)
{
	LOG_Block("GetMuiLangList");

    HRESULT hr = NOERROR;
    DWORD   cMuiLangs;
    int     iLang;

    paull->cLangs      = 0;
    paull->cSlots      = 0;
    paull->rgpaulLangs = NULL;
    
    if (EnumUILanguages(EnumUILangProc, 0, (LONG_PTR)paull) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // We need to deal with MUI stuff only if we've have more than 0 languages
    //  to worry about
    if (paull->cLangs > 0)
    {
        LPTSTR  pszHelp = NULL, pszMui = NULL;
        size_t  cchAvail, cchAvailHelp;
        TCHAR   szPath[MAX_PATH + 1];
        DWORD   dwAttrib;
        DWORD   cch, cLangs = (int)paull->cLangs;
        BOOL    fDeleteLang;
        
        // need to get the directory we'll stuff MUI updates into
        cch = GetSystemWindowsDirectory(pszMuiDir, *pcchMuiDir);

        // note 2nd compare takes into account the addition of an extra '\\' after
        //  the system windows dir
        if (cch == 0 || cch >= *pcchMuiDir)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }

        // tack on an extra '\\' if necessary
        if (pszMuiDir[cch - 1] != _T('\\'))
        {
            pszMuiDir[cch++] = _T('\\');
            pszMuiDir[cch] = _T('\0');
        }

        hr = StringCchCopyEx(pszHelpMuiDir, *pcchHelpMuiDir, pszMuiDir,
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;

        hr = StringCchCatEx(pszHelpMuiDir, *pcchHelpMuiDir, MUI_HELPSUBDIR,
                            &pszHelp, &cchAvailHelp, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;
        
        hr = StringCchCatEx(pszMuiDir, *pcchMuiDir, MUI_SUBDIR, 
                            &pszMui, &cchAvail, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;
        
        *pcchMuiDir     -= cchAvail;
        *pcchHelpMuiDir -= cchAvailHelp;

        // check and make sure that the MUI directories exist- remove all those that 
        //  do not.  This section also checks to make sure that the buffer passed in 
        //  is large enuf to hold the language
        for(iLang = (int)(cLangs - 1); iLang >= 0; iLang--)
        {   
            fDeleteLang = FALSE;

            hr = StringCchCopyEx(pszMui, cchAvail,
                                 paull->rgpaulLangs[iLang]->szMuiName, 
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
            
            dwAttrib = GetFileAttributes(pszMuiDir);
            if (dwAttrib == INVALID_FILE_ATTRIBUTES || 
                (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                fDeleteLang = TRUE;
            }
            else
            {
                hr = StringCchCopyEx(pszHelp, cchAvailHelp,
                                     paull->rgpaulLangs[iLang]->szMuiName, 
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;
                
                dwAttrib = GetFileAttributes(pszHelpMuiDir);
                if (dwAttrib == INVALID_FILE_ATTRIBUTES || 
                    (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    fDeleteLang = TRUE;
                }
            }

            if (fDeleteLang)
            {
                HeapFree(GetProcessHeap(), 0, paull->rgpaulLangs[iLang]);
                if (iLang != paull->cLangs - 1)
                {
                    MoveMemory(&paull->rgpaulLangs[iLang], 
                               &paull->rgpaulLangs[iLang + 1],
                               (paull->cLangs - iLang - 1) * sizeof(AU_LANG *));
                }
                paull->rgpaulLangs[--paull->cLangs] = NULL;
            }
        }

        pszMuiDir[*pcchMuiDir] = _T('\0');
        pszHelpMuiDir[*pcchHelpMuiDir] = _T('\0');
        
    }

done:
    if (FAILED(hr))
        CleanupMuiLangList(paull);

    return hr;
}

// ******************************************************************************
HRESULT CleanupMuiLangList(AU_LANGLIST *paull)
{
	LOG_Block("CleanupMuiLangList");

    HRESULT hr = S_OK;
    DWORD   i;

    // if it's NULL, just return success
    if (paull == NULL)
        return hr;

    if (paull->rgpaulLangs == NULL)
        goto done;

    for (i = 0; i < paull->cLangs; i++)
    {
        if (paull->rgpaulLangs[i] != NULL)
            HeapFree(GetProcessHeap(), 0, paull->rgpaulLangs[i]);
    }

    HeapFree(GetProcessHeap(), 0, paull->rgpaulLangs);

done:
    ZeroMemory(paull, sizeof(AU_LANGLIST));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\muiutil.h ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    muisu.h

Abstract:
    Implements helper functions for self-updating MUI stuff

******************************************************************************/

#pragma once

#ifndef MUIUTIL_H
#define MUIUTIL_H

const TCHAR MUI_SUBDIR[]     = _T("mui\\fallback\\");
const TCHAR MUI_HELPSUBDIR[] = _T("help\\mui\\");
const TCHAR MUI_EXT[]        = _T(".mui");
const TCHAR MUI_WEBSUBPATH[] = _T("/mui");

// selfupdate architecture flags
const TCHAR IDENT_ARCH[] = _T("ARCH");
const TCHAR IDENT_OS[] = _T("OS");
const TCHAR IDENT_LANG[] = _T("LANG");

// IU selfupdate arch keys
const TCHAR IDENT_X86[] = _T("x86");
const TCHAR IDENT_IA64[] = _T("ia64");


typedef struct tagAU_LANG
{
    LPTSTR szMuiName;
    LPTSTR szAUName;
} AU_LANG;

typedef struct tagAU_LANGLIST
{
    AU_LANG **rgpaulLangs;
    LPCTSTR pszIdentFile;
    DWORD   cSlots;
    DWORD   cLangs;
} AU_LANGLIST;

HRESULT GetMuiLangList(AU_LANGLIST *paull, 
                         LPTSTR pszMuiDir, DWORD *pcchMuiDir,
                         LPTSTR pszHelpMuiDir, DWORD *pcchHelpMuiDir);
HRESULT CleanupMuiLangList(AU_LANGLIST *paull);
BOOL MapLangIdToStringName(LANGID langid, LPCTSTR pszIdentFile, 
                           LPTSTR pszLangString, DWORD cchLangString);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\auxml.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auxml.cpp
//
//  About:  source file for AU related XML and schema data structure and functions
//--------------------------------------------------------------------------
#include "pch.h"

//when changed, search for all occurrance of m_pFieldNames for needed modifications
//fixcode: get rid of EULA stuff.
LPSTR  AUCatalogItem::m_pFieldNames[] = {"ItemID", "ProviderName", "Title", "Description", "RTFPath" , "EulaPath"};

#ifdef DBG
void DBGShowNodeName(IXMLDOMNode *pNode)
{
    BSTR bsNodeName;
    if (SUCCEEDED(pNode->get_nodeName(&bsNodeName)))
        {
        DEBUGMSG("node name is %S", bsNodeName);
        }
    else
        {
        DEBUGMSG("FAIL to get node name");
        }
}

void DBGDumpXMLNode(IXMLDOMNode *pNode)
{
    BSTR bsNodeName = NULL;
    BSTR bsNodeXML = NULL;
    if (SUCCEEDED(pNode->get_nodeName(&bsNodeName)) &&
		(SUCCEEDED(pNode->get_xml(&bsNodeXML))))
    {
	    DEBUGMSG("XML for %S is %S", bsNodeName, bsNodeXML);
    }
    SafeFreeBSTR(bsNodeName);
    SafeFreeBSTR(bsNodeXML);
}
#endif

#if 0
void DBGDumpXMLDocProperties(IXMLDOMDocument2 *pDoc)
{
    BSTR bsSelectionLanguage, bsSelectionNamespaces, bsServerHTTPRequest;
    VARIANT vVal;
    VariantInit(&vVal);
    pDoc->getProperty(L"SelectionLanguage", &vVal);
    DEBUGMSG("XMLDoc selection language is %S", vVal.bstrVal);
    VariantClear(&vVal);
    pDoc->getProperty(L"SelectionNamespaces", &vVal);
    DEBUGMSG("XMLDoc selection namespaces is %S", vVal.bstrVal);
    VariantClear(&vVal);
    pDoc->getProperty(L"ServerHTTPRequest", &vVal);
    DEBUGMSG("XMLDoc ServerHTTPRequest is %s", vVal.boolVal ? "True" : "False");
    VariantClear(&vVal);
}
#endif


BSTR ReadXMLFromFile(IN LPCTSTR szFileName)
{
    TCHAR tszFullFileName[MAX_PATH];
    IXMLDOMDocument *pxml = NULL;
    BSTR bstrXml  = NULL;
//    USES_CONVERSION;
//    DEBUGMSG("ReadXMLFromFile() starts");
    AUASSERT(_T('\0') != g_szWUDir[0]);
    if(FAILED(StringCchCopyEx(tszFullFileName, ARRAYSIZE(tszFullFileName), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
       FAILED(StringCchCatEx(tszFullFileName, ARRAYSIZE(tszFullFileName), szFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        DEBUGMSG("file name or path too long");
        goto done;
    }

    if (!fFileExists(tszFullFileName))
    {
        DEBUGMSG("%S doesn't exists on disk", tszFullFileName);
    }
    else
    {
        CAU_BSTR aubsFullFileName;
        HRESULT hr;
        if (!aubsFullFileName.append(T2W(tszFullFileName)))
            {
            DEBUGMSG("Out of memory, fail to create string");
            goto done;
            }
        if (FAILED(hr = LoadDocument(aubsFullFileName, &pxml, TRUE))) //offline
            {
            DEBUGMSG("Fail to load xml document %S with error %#lx", tszFullFileName, hr);
            goto done;
            }
        if (FAILED(hr = pxml->get_xml(&bstrXml)))
        {
        	DEBUGMSG("Fail to get xml string from document with error %#lx", hr);
        	goto done;
        }
    }
done:
    SafeRelease(pxml);
   // DEBUGMSG("ReadXMLFromFile() ends");
    return bstrXml;
}


HRESULT MungleIdentity(IN IXMLDOMNode *pIdentity, IN DWORD dwSuffix)
{
	BSTR bstrItemName = NULL;
	CAU_BSTR aubsTmp;
	WCHAR wcsBuf[12]; //will accomodate the maxium dword
	HRESULT hr = S_OK;

	if (0 == dwSuffix)
	{
		goto done;
	}
	if (NULL == pIdentity) 
	{
		hr = E_INVALIDARG;
		goto done;
	}
	if (FAILED(hr = GetAttribute(pIdentity, KEY_NAME, &bstrItemName)))
	{		DEBUGMSG("Fail to get name from identity with error %#lx", hr);
		goto done;
	}

	if (FAILED(StringCchPrintfExW(wcsBuf, ARRAYSIZE(wcsBuf), NULL, NULL, MISTSAFE_STRING_FLAGS, L"%lu", dwSuffix)) ||
		!aubsTmp.append(bstrItemName) ||
		!aubsTmp.append(L"_") ||
		!aubsTmp.append(wcsBuf))
	{
		DEBUGMSG("OUT OF MEMORY");
		hr = E_OUTOFMEMORY;
		goto done;
	}

	if (FAILED(hr = SetAttribute(pIdentity, KEY_NAME, aubsTmp)))
	{
		DEBUGMSG("Fail to set attribute with error %#lx", hr);
		goto done;
	}

done:
	SafeFreeBSTR(bstrItemName);
	return hr;
}

            
BSTR GetPattern(IN LPCSTR szFieldName)
{
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[0]))
       	{
       	return AUCatalog::bstrItemIDPattern;
       	}
       else
   	 if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[1]))
   	{
   	return AUCatalog::bstrProviderNamePattern;
   	}
       else
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[2]))
       	{
       	return AUCatalog::bstrTitlePattern;
       	}
       else
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[3]))
       	{
       	return AUCatalog::bstrDescPattern;
       	}
       else
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[4]))
       	{
       	return AUCatalog::bstrRTFUrlPattern;
       	}
       else
       if (0 == _stricmp(szFieldName, AUCatalogItem::m_pFieldNames[5]))
       	{
       	return AUCatalog::bstrEulaUrlPattern;
       	}
       else
       	{
       	return NULL;
       	}
}

BOOL IsPersistedHiddenItem(IN BSTR bstrItemID, IN AUCatalogItemList & hiddenItemList)
{
    BOOL fRet = (hiddenItemList.Contains(bstrItemID) >=0);
    DEBUGMSG("%S is %s hidden item ", bstrItemID,  fRet? "" : "NOT");
    return fRet;
}


BOOL CItemDetails::Init(IN BSTR bsItemDetails)
{
    BOOL fRet = TRUE;
    if (FAILED(CoCreateInstance(__uuidof(DOMDocument), NULL, CLSCTX_INPROC_SERVER, __uuidof( IXMLDOMDocument), (void**)&m_pxml)))
	{
		DEBUGMSG("CItemDetails::Init() fail to create XML document");
		fRet = FALSE;
		goto end;
	}
    if (FAILED(m_pxml->put_async(VARIANT_FALSE)) 
    	||FAILED(m_pxml->put_resolveExternals(VARIANT_FALSE))
    	|| FAILED(m_pxml->put_validateOnParse(VARIANT_FALSE)))
    {
    	fRet = FALSE;
    	goto end;
    }
	VARIANT_BOOL fOk;
	if (S_OK != m_pxml->loadXML(bsItemDetails, &fOk))
        {
          DEBUGMSG("CItemDetails::Init() fail to load XML");
          fRet = FALSE;
        }
    end:
        if (!fRet)
            {
            SafeReleaseNULL(m_pxml);
            }
        return fRet;
}

//should be callable event without Init() called first
void CItemDetails::Uninit()
{
    SafeRelease(m_pxml);
}	

HRESULT CItemDetails::GetItemIdentities(IN BSTR bstrItemId, OUT IXMLDOMNodeList ** ppIdentityNodeList)
{
    CAU_BSTR aubsPattern;
    HRESULT hr = S_OK ;

//    DEBUGMSG("CItemDetails::getIdentityNode() starts");
	*ppIdentityNodeList = NULL;
    if (!aubsPattern.append(L"/catalog/provider/item/identity[@itemID=\"") || !aubsPattern.append(bstrItemId) || !aubsPattern.append(L"\"]"))
        {
        DEBUGMSG("failed to create pattern string");
        hr = E_OUTOFMEMORY;
        goto done;
        }
    if (FAILED(hr = m_pxml->selectNodes(aubsPattern, ppIdentityNodeList))) 
        {
        DEBUGMSG(" failed to find identityNode %#lx", hr);
        goto done;
        }   

done:
//    DEBUGMSG("CItemDetails::getIdentityNode() done");
    return hr;
}	

////////////////////////////////////////////////////////////////////////////
// delete all items with ITEMID=bstrItemId
///////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::DeleteItem(IN BSTR bstrItemId)
{
    HRESULT hr = E_FAIL;
  IXMLDOMNode *pItemNode = NULL;
  IXMLDOMNode *pProviderNode = NULL;
  IXMLDOMNode *pCatalogNode = NULL;

  while (NULL != ( pItemNode = getItemNode(bstrItemId)))
  {
	  if (FAILED(hr = pItemNode->get_parentNode(&pProviderNode)) || NULL == pProviderNode)
	        {
	        DEBUGMSG(" fail to get provider node %#lx", hr);
	        goto done;
	        }        
	  if (FAILED(hr = pProviderNode->removeChild(pItemNode, NULL)))
	    {
	        DEBUGMSG(" fail to remove item node with error %#lx", hr);
	        goto done;
	    }
	//  DEBUGMSG("one item removed");
	  pItemNode ->Release();
	  pItemNode = NULL;
	  if (S_FALSE == (hr =pProviderNode->selectSingleNode(KEY_ITEM, &pItemNode)))
	    {
	        //provider had no children
	      if (FAILED(hr = pProviderNode->get_parentNode(&pCatalogNode)) || NULL == pCatalogNode)
	        {
	        DEBUGMSG(" fail to get catalog node %#lx", hr);
	        goto done;
	        }        
	      if (FAILED(hr = pCatalogNode->removeChild(pProviderNode, NULL)))
	        {
	            DEBUGMSG(" fail to remove provider node with error %#lx", hr);
	            goto done;
	        }
	    //  DEBUGMSG("one provider removed");
	    }
	SafeReleaseNULL(pItemNode);
	SafeReleaseNULL(pProviderNode);
	SafeReleaseNULL(pCatalogNode);
  }
      
  done:
    SafeRelease(pItemNode);
    SafeRelease(pProviderNode);
    SafeRelease(pCatalogNode);
    return hr;
}

HRESULT CItemDetails::GetXML(BSTR *pbstrxml)
{
    return m_pxml->get_xml(pbstrxml);
}

IXMLDOMNode * CItemDetails::getIdentityNode(IN BSTR bstrItemId)
{
    IXMLDOMNode * pIdentityNode = NULL ;
    CAU_BSTR aubsPattern;
    HRESULT hr ;

//    DEBUGMSG("CItemDetails::getIdentityNode() starts");
    if (!aubsPattern.append(L"/catalog/provider/item/identity[@itemID=\"") || !aubsPattern.append(bstrItemId) || !aubsPattern.append(L"\"]"))
        {
        DEBUGMSG("failed to create pattern string");
        goto done;
        }
    if (FAILED(hr = m_pxml->selectSingleNode(aubsPattern, &pIdentityNode))) 
        {
        DEBUGMSG(" failed to find identityNode %#lx", hr);
        goto done;
        }   
    if (NULL == pIdentityNode)
    {
    	goto done;
    }
done:
//    DEBUGMSG("CItemDetails::getIdentityNode() done");
    return pIdentityNode;
}

/////////////////////////////////////////////////////////
// caller should make sure item bstrItemId exists in itemdetails
////////////////////////////////////////////////////////
BOOL CItemDetails::IsVisible(IN BSTR bstrItemId)
{
    IXMLDOMNode * pItemNode = getItemNode(bstrItemId);
    IXMLDOMNode *pDescriptionNode = NULL;
    LONG  lRet = 0;
    HRESULT hr ;
//    DEBUGMSG("IsVisible() starts");
	//fixcode: really should return error instead of bogus TRUE
    if (NULL == pItemNode ) 
    {
        DEBUGMSG("fail to find node or fail to create string");
       goto done;
    }
   if (FAILED(hr = pItemNode->selectSingleNode(KEY_DESCRIPTION, &pDescriptionNode)) || NULL == pDescriptionNode)
    {
        DEBUGMSG("Fail to select node %S with error %#lx", KEY_DESCRIPTION, hr);
        goto done;
    }
   if (FAILED(hr = GetAttribute(pDescriptionNode, KEY_HIDDEN, &lRet)))
    {
        DEBUGMSG("Fail to get attribute %S with error %#lx", KEY_HIDDEN, hr);
        goto done;
    }
//   DEBUGMSG("Hidden attribute is %d for item %S", lRet, bstrItemId);
done:
   SafeRelease(pDescriptionNode);
   SafeRelease(pItemNode);
//   DEBUGMSG("IsVisible() return %s for %S", (0 == lRet) ? "true" : "false", bstrItemId);
   return 0 == lRet;
}
    
        
    

IXMLDOMNode * CItemDetails::getItemNode(IN BSTR bsItemId)
{
    IXMLDOMNode * pIdentityNode = getIdentityNode(bsItemId);
    IXMLDOMNode * pItemNode = NULL;
    HRESULT hr;

   //DEBUGMSG("CItemDetails::getItemNode() starts");
    if (NULL == pIdentityNode)
        {
        goto done;
        }
  if (FAILED(hr = pIdentityNode->get_parentNode(&pItemNode)) || NULL == pItemNode)
        {
        DEBUGMSG(" fail to get item node %#lx", hr);
        goto done;
        }
done:
    SafeRelease(pIdentityNode);
    //DEBUGMSG("CItemDetails::getItemNode() ends");
    return pItemNode;
}	


HRESULT CItemDetails::CloneIdentityNode(IN BSTR bsItemId, IN IXMLDOMDocument *pDesXml, OUT IXMLDOMNode ** ppDesNode)
{
    IXMLDOMNode * pIdentityNode ;
    HRESULT hr = E_FAIL;

   // DEBUGMSG("CItemDetails::CloneIdentityNode() starts");
   *ppDesNode = NULL;
    if (NULL == (pIdentityNode = getIdentityNode(bsItemId)))
        {
        goto done;
        }
    	
    if (FAILED(hr = CopyNode(pIdentityNode, pDesXml, ppDesNode)))
        {
        DEBUGMSG("CItemDetails::CloneIdentityNode() failed to clone identityNode %#lx", hr);
        }
done:
    SafeRelease(pIdentityNode);
   // DEBUGMSG("CItemDetails::CloneIdentityNode() ends");
    return hr;
}

HRESULT CItemDetails::CloneDescriptionNode(IN BSTR bsItemId, IN IXMLDOMDocument *pDesXml, OUT IXMLDOMNode **ppDesNode)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNode * pDescriptionNode = NULL;
    HRESULT hr = E_FAIL;

    *ppDesNode = NULL;
    if (NULL == pItemNode)
        {
        goto done;
        }
   if (!FindNode(pItemNode, KEY_DESCRIPTION, &pDescriptionNode))
    {
        DEBUGMSG("CItemDetails::CloneDescriptionNode() fail to get description node");
        goto done;
    }
     if (FAILED(hr = CopyNode(pDescriptionNode, pDesXml, ppDesNode)))
    {
        DEBUGMSG("CItemDetails::CloneDescriptionNode() fail to clone node %#lx", hr);
    }
done:
    SafeRelease(pItemNode);
    SafeRelease(pDescriptionNode);
    return hr;
}


HRESULT CItemDetails::ClonePlatformNode(IN BSTR bsItemId,  IN IXMLDOMDocument *pDesXml, OUT IXMLDOMNode **ppDesNode)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNode * pPlatformNode = NULL;
    HRESULT hr  = E_FAIL;

    *ppDesNode = NULL;
    if (NULL == pItemNode)
        {
        goto done;
        }
   if (!FindNode(pItemNode, KEY_PLATFORM, &pPlatformNode))
    {
        DEBUGMSG("CItemDetails::ClonePlatformNode() fail to get platform node");
        goto done;
    }
    if (FAILED(hr = CopyNode(pPlatformNode, pDesXml, ppDesNode)))
    {
        DEBUGMSG("CItemDetails::ClonePlatformNode() fail to clone node %#lx", hr);
    }
done:
    SafeRelease(pItemNode);
    SafeRelease(pPlatformNode);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
// retrieve cab names associated with an item identified by bsitemid
// called should free ppCabNames allocated in the function
// *pCabsNum contains number of cab names returned
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::GetCabNames(IN BSTR bsItemId, OUT  BSTR ** ppCRCCabNames,  OUT BSTR **ppRealCabNames, OUT BSTR **ppCabChecksums, OUT UINT *pCabsNum)
{
    IXMLDOMNode * pItemNode = getItemNode(bsItemId);
    IXMLDOMNodeList *pCodeBaseNodes = NULL;
    BSTR * pCRCCabNames = NULL;
    BSTR * pRealCabNames = NULL;
    BSTR * pCabChecksums = NULL;
    UINT uCabsNum = 0;
    CAU_BSTR aubsCodeBase;
    HRESULT hr = E_FAIL;

    //DEBUGMSG("CItemDetails::GetCabNames() starts");
    *ppRealCabNames = *ppCRCCabNames = *ppCabChecksums = NULL;
    *pCabsNum = 0;
    if (!aubsCodeBase.append(L"installation/codeBase"))
        {
        DEBUGMSG("fail to create aubs");
        goto done;
        }
    if (NULL == pItemNode)
        {
        goto done;
        }
    if (FAILED(hr = pItemNode->selectNodes(aubsCodeBase, &pCodeBaseNodes)) || NULL == pCodeBaseNodes)
        {
        DEBUGMSG("Fail to find codebase section");
        goto done;
        }
    if (FAILED(hr = pCodeBaseNodes->get_length((long *) &uCabsNum)))
    {
    	DEBUGMSG("Fail to get number of code base nodes with error %#lx", hr);
    	goto done;
    }
    pCRCCabNames  = (BSTR*) malloc(uCabsNum * sizeof(*pCRCCabNames));
    pRealCabNames = (BSTR*) malloc(uCabsNum * sizeof(*pRealCabNames));
    pCabChecksums = (BSTR*) malloc(uCabsNum * sizeof(*pCabChecksums));
    if (NULL != pCRCCabNames)
    {
	   	ZeroMemory((PVOID)pCRCCabNames, uCabsNum * sizeof(*pCRCCabNames));
    }
    if (NULL != pRealCabNames)
    {
	   	ZeroMemory((PVOID)pRealCabNames, uCabsNum * sizeof(*pRealCabNames));
    }
    if (NULL != pCabChecksums)
    {
	   	ZeroMemory((PVOID)pCabChecksums, uCabsNum * sizeof(*pCabChecksums));
    }
    if (NULL == pCRCCabNames || NULL == pRealCabNames || NULL == pCabChecksums)
    {
        DEBUGMSG("Fail to alloc memory for CRCCabsNames or RealCabNames");
        hr = E_OUTOFMEMORY;
        goto done;
    }
    for (UINT i = 0; i < uCabsNum ; i++)
    {
        IXMLDOMNode *pCodeBaseNode;
        if (S_OK != (hr = pCodeBaseNodes->get_item(i, &pCodeBaseNode)))
        {
            DEBUGMSG("Fail to get codebase %d", i);
            hr = FAILED(hr) ? hr : E_FAIL;
            goto done;
        }
        if (FAILED(hr = GetAttribute(pCodeBaseNode, KEY_HREF, &(pCRCCabNames[i]))))
        {
            DEBUGMSG("Fail to get attribute %S", KEY_HREF);
            pCodeBaseNode->Release();
            goto done;
        }
        if (FAILED(hr = GetAttribute(pCodeBaseNode, KEY_NAME, &(pRealCabNames[i]))))
        {
            DEBUGMSG("Fail to get attribute %S", KEY_NAME);
            pCodeBaseNode->Release();
            goto done;
        }        
        //Since CRC is optional, it might not exist for this cab
        GetAttribute(pCodeBaseNode, KEY_CRC, &(pCabChecksums[i]));
  
        pCodeBaseNode->Release();
    }

    *ppCRCCabNames = pCRCCabNames;
    *ppRealCabNames = pRealCabNames;
    *ppCabChecksums = pCabChecksums;
    *pCabsNum = uCabsNum;

done:
    SafeRelease(pCodeBaseNodes);
    SafeRelease(pItemNode);
    if (FAILED(hr))
    {
        if (NULL != pCRCCabNames)
        {
            for (UINT j = 0; j < uCabsNum; j++)
            {
                SafeFreeBSTR(pCRCCabNames[j]);
            }
            free(pCRCCabNames);
        }
        if (NULL != pRealCabNames)
        {
            for (UINT j = 0; j < uCabsNum; j++)
            {
                SafeFreeBSTR(pRealCabNames[j]);
            }
            free(pRealCabNames);
        }
        if (NULL != pCabChecksums)
        {
            for (UINT j = 0; j < uCabsNum; j++)
            {
                SafeFreeBSTR(pCabChecksums[j]);
            }
            free(pCabChecksums);
        }
    }
    //DEBUGMSG("CItemDetails::GetCabNames() ends");
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
// retrieve the CRC for the rtf file for the specified item
// caller should free pRTFCRC allocated in the function
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::GetRTFCRC(BSTR bstrItemId, BSTR *pRTFCRC)
{
    IXMLDOMNode * pItemNode   = getItemNode(bstrItemId);
    IXMLDOMNode *pDetailsNode = NULL;
    CAU_BSTR aubsDetails;
    HRESULT hr = E_FAIL;

    AUASSERT(NULL != pRTFCRC);
    *pRTFCRC = NULL;

    if( NULL == pItemNode ||
        !aubsDetails.append(L"description/descriptionText/details"))       
    {
        goto done;
    }
    if (FAILED(hr = pItemNode->selectSingleNode(aubsDetails, &pDetailsNode)) ||
        NULL == pDetailsNode)
    {
        DEBUGMSG("Fail to find details section");
        goto done;
    }
    if (FAILED(hr = GetAttribute(pDetailsNode, KEY_CRC, pRTFCRC)) ||
        hr == S_FALSE)      //GetAttribute returns S_FALSE if the attribute does not exist for the node
    {
        DEBUGMSG("Fail to get attribute RTF crc, hr is %x", hr);
        hr = (hr == S_FALSE) ? E_FAIL : hr;
    }

done:    
    if(FAILED(hr))
    {
        SafeFreeBSTRNULL(*pRTFCRC);
    }
    SafeRelease(pItemNode);
    SafeRelease(pDetailsNode);
    return hr;    
}

BSTR CItemDetails::GetItemDownloadPath(IN BSTR bstrItemId)
{
//    USES_CONVERSION; only needed for ansi version
    BSTR bstrRet = NULL;
    IXMLDOMNode * pIdentityNode= NULL;

//    DEBUGMSG("CItemDetails::GetItemDownloadPath starts");

    if (NULL == (pIdentityNode = getIdentityNode(bstrItemId)))
        {
            goto done;
        }
    BSTR bstrdownloadPath;
   if (FAILED(UtilGetUniqIdentityStr(pIdentityNode, &bstrdownloadPath, 0)))
    {
        DEBUGMSG("GetItemDownloadPath() fail to get unique identity string");
        goto done;
    }
    TCHAR tszPath[MAX_PATH];
    if (SUCCEEDED(GetCabsDownloadPath(tszPath, ARRAYSIZE(tszPath))) &&
		SUCCEEDED(StringCchCatEx(tszPath, ARRAYSIZE(tszPath), _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		SUCCEEDED(StringCchCatEx(tszPath, ARRAYSIZE(tszPath), W2T(bstrdownloadPath), NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		bstrRet = SysAllocString(T2W(tszPath));
	}
    SysFreeString(bstrdownloadPath);
done:
    SafeRelease(pIdentityNode);
   /// DEBUGMSG("CItemDetails::GetItemDownloadPath() got %S", bstrRet);
    if (NULL != bstrRet && !EnsureDirExists(W2T(bstrRet)))
        {
        DEBUGMSG("CItemDetails::GetItemDownloadPath() fail to create directory %S", bstrRet);
        SysFreeString(bstrRet);
        bstrRet = NULL;
        }
    return bstrRet;
}

HRESULT CItemDetails::GetItemIds(OUT long *plItemNum, OUT BSTR ** ppbstrItemIds)
{
     IXMLDOMNodeList *pItemIdsNodeList = NULL;
     HRESULT hr = E_FAIL;

//     DEBUGMSG("CItemDetails::GetItemIds() starts");
       *ppbstrItemIds = NULL;
       *plItemNum = 0;
 	
	if (FAILED(hr = m_pxml->selectNodes(AUCatalog::bstrItemIdsPattern, &pItemIdsNodeList)))
	{
		DEBUGMSG(" fail to find item id with error %#lx", hr);
		goto done;
	}

	if (FAILED(hr = pItemIdsNodeList->get_length(plItemNum)))
	{
		DEBUGMSG("Fail to get itemids number with error %#lx", hr);
		goto done;
	}
	*ppbstrItemIds = (BSTR *) malloc((*plItemNum) * sizeof(**ppbstrItemIds));
	if (NULL == *ppbstrItemIds)
	    {
	    DEBUGMSG("Fail to allocate memory for item ids");
	    hr = E_OUTOFMEMORY;
	    goto done;
	    }
	ZeroMemory(*ppbstrItemIds, (*plItemNum) * sizeof(**ppbstrItemIds));
	for (int i = 0; i < *plItemNum; i++)
	    {
	        IXMLDOMNode *pItemIdNode = NULL;
	        if (FAILED(hr = pItemIdsNodeList->get_item(i, &pItemIdNode)) || NULL == pItemIdNode)
	            {
	                DEBUGMSG("Fail to get item id node with error %#lx", hr);
	                hr = FAILED(hr) ? hr : E_FAIL;
	                goto done;
	            }
	        if (FAILED(hr = pItemIdNode->get_text(&((*ppbstrItemIds)[i]))) || NULL == (*ppbstrItemIds)[i])
	            {
	                DEBUGMSG("Fail to get item id no. %d with error %#lx", i+1, hr);
	                pItemIdNode->Release();
	                hr = FAILED(hr) ? hr : E_FAIL;
	                goto done;
	            }
               pItemIdNode->Release();
//	        DEBUGMSG(" got #%d item id %S", i+1, (*ppbstrItemIds)[i]);
	    }
	        
done:
    SafeRelease(pItemIdsNodeList);
    if (FAILED(hr))
        {
          if (NULL != *ppbstrItemIds)
        	{
 
	          for (int j = 0; j < *plItemNum; j++)
	            {
	                SafeFreeBSTR((*ppbstrItemIds)[j]);
	            }
	            SafeFree(*ppbstrItemIds);
	        }
          *plItemNum = 0;         
          *ppbstrItemIds = NULL;
        }
    else
        {
        DEBUGMSG(" got %d item ids", *plItemNum);
        }
//    DEBUGMSG("CItemDetails::GetItemIds() ends");
   return hr;
}
    	    
HRESULT CItemDetails::GetItemInfo(IN LPCSTR szFieldName, IN const BSTR bstrItemId, OUT BSTR * pbstrItemInfo)
{
   HRESULT hr = E_FAIL;
   IXMLDOMNode * pItemNode = getItemNode(bstrItemId);
   IXMLDOMNode * pProviderNode = NULL;
   IXMLDOMNode * pParentNode;
   IXMLDOMNode  *pItemInfoNode = NULL;

//    DEBUGMSG("GetItemInfo() for %s starts", szFieldName);

   *pbstrItemInfo = NULL;
   if (NULL == pItemNode)
    {
    DEBUGMSG("Fail to get item node for %S", bstrItemId);
    goto done;
    }
   //special case provider name
   if (0 == _strcmpi(szFieldName, AUCatalogItem::m_pFieldNames[1]))
    {
        if (FAILED(hr = pItemNode->get_parentNode(&pProviderNode)) || NULL == pProviderNode)
            {
                DEBUGMSG("Fail to get provider node");
                hr = E_FAIL;
                goto done;
            }
        pParentNode = pProviderNode;
    }
   else
    {
       pParentNode = pItemNode;
    }
   if (FAILED(hr = FindSingleDOMNode(pParentNode, GetPattern(szFieldName), &pItemInfoNode)))
    {
    DEBUGMSG("Fail to get field %s for item %S", szFieldName, bstrItemId);
    goto done;
    }
   if (FAILED(hr = pItemInfoNode->get_text(pbstrItemInfo))) //NULL content is fine
    { 
    DEBUGMSG("Fail to get value from title node with error %#lx", hr);
    goto done;
    }

//   DEBUGMSG(" item info %s is %S", szFieldName, *pbstrItemInfo);

done:
    SafeRelease(pItemNode);
    SafeRelease(pItemInfoNode);
    SafeRelease(pProviderNode);
    if (FAILED(hr))
    {
    	SafeFreeBSTRNULL(*pbstrItemInfo);
    }
//    DEBUGMSG("GetItemInfo() for %s ends", szFieldName);    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
//find first exclusive item that is NOT hidden and visible
//return S_OK if found one
//return S_FALSE if found none
//return E_FAIL if error occurs
HRESULT CItemDetails::FindFirstExclusiveItem(OUT BSTR *pbstrItemId, IN  AUCatalogItemList & hiddenItemList)
{
    IXMLDOMNodeList *pExclusiveItemNodes = NULL;
    HRESULT hr = E_FAIL;
    BOOL fFound = FALSE;

    DEBUGMSG("CItemDetails::FindFirstExclusiveItem() starts");
    *pbstrItemId = NULL;
    pExclusiveItemNodes = FindDOMNodeList(m_pxml, AUCatalog::bstrExclusiveItemPattern);
    if (NULL  == pExclusiveItemNodes)
        {   
            DEBUGMSG("No exclusive item found");
            hr = S_FALSE;
            goto done;
        }
    long lNum;
    if (FAILED(hr = pExclusiveItemNodes->get_length(&lNum)))
    {
    	DEBUGMSG("Fail to get exclusive item nodes number with error %#lx", hr);
    	goto done;
    }
    for (long l = 0; l < lNum; l++)
        {
            IXMLDOMNode *pExclusiveItemNode = NULL;
            if (S_OK != (hr = pExclusiveItemNodes->get_item(l, &pExclusiveItemNode)))
                {
                    DEBUGMSG("Fail to get item with error %#lx", hr);
                    hr = FAILED(hr) ? hr : E_FAIL;
                    goto done;
                }
            if (!FindNodeValue(pExclusiveItemNode, GetPattern(AUCatalogItem::m_pFieldNames[0]), pbstrItemId))
            {
                hr = E_FAIL;
            }
            pExclusiveItemNode->Release();
            if (FAILED(hr))
                {
                    DEBUGMSG("Fail to get item id text with error %#lx", hr);
                    goto done;
                }
            if (!IsPersistedHiddenItem(*pbstrItemId, hiddenItemList) && IsVisible(*pbstrItemId))
                {
                    fFound = TRUE;
                    break;
                }
            SysFreeString(*pbstrItemId);
            *pbstrItemId = NULL;
        }

    if (fFound)
        {
            DEBUGMSG("Find first exclusive item %S", *pbstrItemId);
            hr = S_OK;
        }
    else
        {
            DEBUGMSG("No unhidden and visible exclusive item found");
            hr = S_FALSE;
        }

done:
    SafeRelease(pExclusiveItemNodes);
    if (S_OK != hr)
    {
    	SafeFreeBSTRNULL(*pbstrItemId);
    }
    DEBUGMSG("CItemDetails::FindFirstExclusiveItem() ends");
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// populate m_DependentItems of each item in the lsit with direct dependency
// Also check the self containment of depending items with in the list, i.e. all the depending items should
// also be in the list. If not, the dependency will not be recorded.
// return S_OK : if item found and dependency built if any
//          E_XXXX: if error
//////////////////////////////////////////////////////////////////////////////
HRESULT CItemDetails::BuildDirectDependency(IN OUT AUCatalogItemList  &itemlist)
{
    HRESULT hr = S_OK;
    CAU_BSTR aubsDependentItemID;

//    DEBUGMSG("CItemDetails::BuildDirectDependency starts");
    if (!aubsDependentItemID.append(L"dependencies/identity/@itemID"))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    for (UINT i = 0; i < itemlist.Count(); i++)
        {
        IXMLDOMNodeList *pItemIDNodes = NULL;
        IXMLDOMNode *pItemNode = NULL; 
 
        if (NULL == (pItemNode = getItemNode(itemlist[i].bstrID())))
            {
//                DEBUGMSG("Warning: item %S not found in the list", itemlist[i].bstrID()); //legitimate error
                continue;
            }
        if (NULL == (pItemIDNodes  = FindDOMNodeList(pItemNode, aubsDependentItemID)))
            {
//                DEBUGMSG ("No dependency found for item %S", itemlist[i].bstrID());
                pItemNode->Release();
                continue;
            }
        long lNumOfDependency;
        if (FAILED(hr = pItemIDNodes->get_length(&lNumOfDependency)))
        {
        	DEBUGMSG("Fail to get item id node number with error %#lx", hr);
        	pItemNode->Release();
        	pItemIDNodes->Release();
        	continue;
        }
        for (long l = 0; l < lNumOfDependency; l++)
            {
                IXMLDOMNode * pItemIDNode  = NULL;
                if (S_OK == pItemIDNodes->get_item(l, &pItemIDNode))
                    {
                        BSTR bstrItemId = NULL;
                        if (FAILED(hr = pItemIDNode->get_text(&bstrItemId)) || NULL == bstrItemId)
                        {
                        	DEBUGMSG("Fail to get text for item id with error %#lx", hr);
                        	hr = FAILED(hr) ? hr : E_FAIL;
                        	pItemIDNode->Release();
                        	break;
                        }
                        pItemIDNode->Release(); 
                        AUCatalogItem *pdependingItem  = new AUCatalogItem;
                        if (NULL == pdependingItem)
                            {
                            DEBUGMSG("Out of Memory. Fail to create new item");
                            hr = E_OUTOFMEMORY;
                            SafeFreeBSTR(bstrItemId);
                            break;
                            }
                        if (NULL == bstrItemId)
                            {//although schema does not require itemid, we do
                              DEBUGMSG("Fail to find item id");
                              hr = E_FAIL;
                              delete pdependingItem;
                              break;
                            }
                        INT index = itemlist.Contains(bstrItemId);
                        if (index >= 0)
                            {
                            	BSTR bstrTmp = SysAllocString(itemlist[i].bstrID());
                            	if (NULL == bstrTmp)
                            	{
                            		DEBUGMSG("Fail to allocate memory");
                            		SysFreeString(bstrItemId);
                            		delete pdependingItem;
                            		hr = E_OUTOFMEMORY;
                            		break;
                            	}
	                            pdependingItem->SetField(AUCatalogItem::m_pFieldNames[0], bstrTmp);
	                            if (!itemlist[index].m_DependingItems.Add(pdependingItem))
	                            {
	                            	DEBUGMSG("fail to add depending item");
	                            	SysFreeString(bstrItemId);
	                            	delete pdependingItem;
	                            	hr = E_OUTOFMEMORY;
	                            	break;
	                            }
	                            else
	                            {
		                            DEBUGMSG("item %S depending on item %S. Dependency recorded", pdependingItem->bstrID(), itemlist[index].bstrID());
	                            }
                            }
                        else
                            {
                            DEBUGMSG("Warning: item %S depends on an item not in the list", itemlist[i].bstrID());
                            delete pdependingItem;
                            }
                        SysFreeString(bstrItemId);
                    }
                else
                    {
                        DEBUGMSG("Error: fail to get item id node");
                        hr = E_FAIL;
                        break;
                    }
            }
       pItemNode->Release();
       pItemIDNodes->Release();
    }
done:
//    DEBUGMSG("CItemDetails::BuildDirectDependency ends");
	if (FAILED(hr))
	{
		for (UINT i = 0; i < itemlist.Count(); i++)
		{
			itemlist[i].m_DependingItems.Clear();
		}
	}
    return hr;
}

////////////////////////////////////////////////////////////////////////////
// format of hidde.xml is
// <hiddenitems version = #> 
//      <item id = "...........">
//      ..............
//      <item id = "...........">
// </hiddenitems>
// return S_FALSE when no hidden items left in the xml file. The file will be deleted
///////////////////////////////////////////////////////////////////////////
// TO be finished
HRESULT PersistHiddenItems(IN AUCatalogItemList &itemlist, IN URLLOGACTIVITY activity)
{
//    USES_CONVERSION;
    IXMLDOMDocument *pHiddenXml = NULL;
    IXMLDOMNode *pHiddenItemsNode = NULL;
    IXMLDOMElement *pelemITEM = NULL;
     TCHAR tszFullFileName[MAX_PATH];
    CAU_BSTR aubsFullFileName;
    CAU_BSTR aubsItemPattern;
    UINT uItemAdded = 0;
    HRESULT hr = S_OK;

    DEBUGMSG("PersistHiddenItems() starts");
    if (itemlist.GetNumUnselected() == 0)
        {
            DEBUGMSG("No hidden items to persist");
            goto done;
        }
    AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(StringCchCopyEx(tszFullFileName, ARRAYSIZE(tszFullFileName), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(StringCchCatEx(tszFullFileName, ARRAYSIZE(tszFullFileName), HIDDEN_ITEMS_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		!aubsFullFileName.append(T2W(tszFullFileName)) ||
        !aubsItemPattern.append(AUCatalog::bstrHiddenItems) ||
        !aubsItemPattern.append(L"/") ||!aubsItemPattern.append(AUCatalog::bstrTagITEM))
    {
    DEBUGMSG("Fail to create string ");
    hr = E_OUTOFMEMORY;
    goto done;
    }

    if (fFileExists(tszFullFileName))
        {
            DEBUGMSG("file %S exists. Add hidden items to it", tszFullFileName);
            if (FAILED(hr = LoadDocument(aubsFullFileName, &pHiddenXml, TRUE))) //offline
                {
                    DEBUGMSG(" %S fail to load with error %#lx, delete it", aubsFullFileName, hr);
                    AUDelFileOrDir(tszFullFileName);
                }
        }
    if (NULL == pHiddenXml)
        {
            if (FAILED(hr = LoadXMLDoc(AUCatalog::bstrTemplate, &pHiddenXml, TRUE))) //offline
                {
                  DEBUGMSG("Fail to load template xml with error %#lx", hr);
                  goto done;
                }
        }

    if (!FindNode(pHiddenXml, AUCatalog::bstrHiddenItems, &pHiddenItemsNode))
        {
            hr = E_FAIL;
            DEBUGMSG("Fail to find node %S", AUCatalog::bstrHiddenItems);
            goto done;
        }

       VARIANT varValueID;
       varValueID.vt = VT_BSTR;
    // write out item information
	for ( DWORD index = 0; index < itemlist.Count(); index++ )
	{
        if (itemlist[index].fUnselected())
            { //hide unselected items
                varValueID.bstrVal = itemlist[index].bstrID();
                if ( FAILED(hr = pHiddenXml->createElement(AUCatalog::bstrTagITEM, &pelemITEM)) ||
                      FAILED(hr = pelemITEM->setAttribute(AUCatalog::bstrAttrID, varValueID)) ||
                      FAILED(hr = pHiddenItemsNode->appendChild(pelemITEM, NULL)) )
                {
                    DEBUGMSG("XML operation failure with error %#lx", hr);
                }
                else
                    {
    //                DEBUGMSG("item %S persisted", itemlist[index].bstrID());
                    uItemAdded++;
					gPingStatus.PingDeclinedItem(FALSE, activity, W2T(varValueID.bstrVal));
                    }
                SafeReleaseNULL(pelemITEM);
//                DEBUGMSG("Item %S now hidden", itemlist[index].bstrID());
                itemlist[index].SetStatusHidden();
            }
       }

      if (0 == uItemAdded)
        {
            DEBUGMSG("no new hidden items need to be persisted");
            hr = S_OK;
        }
      else
	if (FAILED(hr= SaveDocument(pHiddenXml, aubsFullFileName)))
	    {
	    DEBUGMSG("Fail to save hidden xml %S with error %#lx", T2W(tszFullFileName), hr);
           AUDelFileOrDir(tszFullFileName);
           goto done;
	    }
done:
   SafeRelease(pelemITEM);
   SafeRelease(pHiddenItemsNode);
   SafeRelease(pHiddenXml);
   DEBUGMSG("PersistHiddenItems() ends with %d items added", uItemAdded);
   return hr;
}

//////////////////////////////////////////////////////////////////////
// read hidden xml file if there is one
// and populate the hidden item list passed in
// return S_FALSE if there is no hidden items found
/////////////////////////////////////////////////////////////////////
HRESULT GetPersistedHiddenItems(AUCatalogItemList OUT & hiddenItemList)
{
    HRESULT hr ;
    IXMLDOMNodeList *pItemNodes = NULL;
    IXMLDOMDocument *pHiddenXml = NULL;
    CAU_BSTR aubsItemPattern;

    DEBUGMSG("GetPersistedHiddenItems() starts");
    TCHAR tszFullFileName[MAX_PATH];
    CAU_BSTR aubsFullFileName;

    AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(StringCchCopyEx(tszFullFileName, ARRAYSIZE(tszFullFileName), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(StringCchCatEx(tszFullFileName, ARRAYSIZE(tszFullFileName), HIDDEN_ITEMS_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		!aubsItemPattern.append(AUCatalog::bstrHiddenItems) ||
         !aubsItemPattern.append(L"/") ||
         !aubsItemPattern.append(AUCatalog::bstrTagITEM) ||
         !aubsFullFileName.append(T2W(tszFullFileName)))
        {
            DEBUGMSG("fail to create string");
            hr = E_OUTOFMEMORY;
            goto done;
        }

    if (!fFileExists(W2T(aubsFullFileName)))
        {
            DEBUGMSG("No persisted item found");
            hr = S_FALSE;
            goto done;
        }
    if (FAILED(hr = LoadDocument(aubsFullFileName, &pHiddenXml, TRUE))) //offline
    {
        DEBUGMSG(" %S fail to load with error %#lx", aubsFullFileName, hr); //might be expected if file is not there
        goto done;
    }
    pItemNodes = FindDOMNodeList(pHiddenXml, aubsItemPattern);
    if (NULL == pItemNodes)
        {
        	hr = S_FALSE;
            DEBUGMSG("no persisted hidden items found using pattern %S", aubsItemPattern);
            goto done;
        }
    long lItemNum;
    if (FAILED(hr = pItemNodes->get_length(&lItemNum)))
    {
    	DEBUGMSG("fail to get number of item nodes with error %#lx", hr);
    	goto done;
    }
    for (int i = 0; i < lItemNum; i++)
        {
            IXMLDOMNode *pItemNode = NULL;
            BSTR bstrItemID = NULL;
            if (S_OK != (hr = pItemNodes->get_item(i, &pItemNode)))
            {
            	DEBUGMSG("Fail to get item %d", i);
            	hr = FAILED(hr) ? hr : E_FAIL;
            	goto done;
            }
            hr = GetAttribute(pItemNode, AUCatalog::bstrAttrID, &bstrItemID);
            SafeRelease(pItemNode);
            if (FAILED(hr))
            {
            	goto done;
            }
            if (NULL != bstrItemID)
                {
                    AUCatalogItem *pItem = new AUCatalogItem();
                    if (NULL == pItem)
                        {
                            DEBUGMSG("Fail to create new item");
                            SysFreeString(bstrItemID);
                            hr = E_OUTOFMEMORY;
                            goto done;
                        }
                    else
                        {
                        pItem->SetField(AUCatalogItem::m_pFieldNames[0], bstrItemID);
                        DEBUGMSG("Find one hidden item %S", bstrItemID);
                        if (!hiddenItemList.Add(pItem))
                        {
                        	DEBUGMSG("OUT OF MEMORY: fail to add item");
                        	hr = E_OUTOFMEMORY;
                        	delete pItem;
                        	goto done;
                        }
                        }
                }
        }
    done:
        SafeRelease(pItemNodes);
        SafeRelease(pHiddenXml);
        if (hr != S_OK)
            {
            hiddenItemList.Clear();
            }
        DEBUGMSG("GetPersistedHiddenItems() ends");
        return hr;
}
                    
                
//////////////////////////////////////////////////////////////////////////////////////////////////////
// given a details xml, extract all the items in it
// and populate the AU catalog item list passed in
// all the persisted hidden items will be excluded
// bstrDetails: IN details xml
// itemlist :   IN/OUT receives items information
// fDriver:  IN whether bstrDetails is for driver or non driver
// pfFoundExclusive: OUT TRUE if found exclusive item. In that case, only exclusive item will be returned
// return : TRUE if items got from the xml
//              FALSE otherwise
/////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL fExtractItemInfo(IN const BSTR bstrDetails, OUT AUCatalogItemList & itemList, OUT BOOL *pfFoundExclusive) 
{
	long lNumItems = 0;
	BSTR *pbstrItemIds = NULL;
	BOOL fRet = FALSE;
	CItemDetails itemdetails;
	BSTR bstrExclusiveItemId; 
       AUCatalogItemList hiddenItemList;
       BOOL fHiddenItemsFound;
       BOOL fItemIdsAllocated = FALSE;
	HRESULT hr;

       DEBUGMSG("fExtractItemInfo() starts");
		*pfFoundExclusive = FALSE;
		itemList.Clear();
       if (!itemdetails.Init(bstrDetails))
        {
            DEBUGMSG("Fail to init itemdetails");
            goto done;
        }
       if (FAILED(hr = GetPersistedHiddenItems(hiddenItemList)))
       {
           DEBUGMSG("no persisted hidden items loaded with error %#lx", hr);
       }
       if (*pfFoundExclusive = (S_OK == itemdetails.FindFirstExclusiveItem(&bstrExclusiveItemId, hiddenItemList)))
        {
                DEBUGMSG("Found exclusive item, add it");
                lNumItems = 1;
                pbstrItemIds = &bstrExclusiveItemId;
        }
       else
        {
           if (FAILED(hr = itemdetails.GetItemIds(&lNumItems, &pbstrItemIds)))
            {
                DEBUGMSG("Fail to get item ids with error %#lx", hr);
                goto done;
            }
           else
            {
                fItemIdsAllocated = TRUE;
            }
        }

   
	for (long i = 0; i < lNumItems; i++)
	{
		if (itemList.Contains(pbstrItemIds[i]) >=0)
		{ //duplicate item id found
			continue;
		}
		AUCatalogItem *pitem = new AUCatalogItem();
		if (NULL == pitem)
		    {
		        DEBUGMSG("Out of memory and fail to create new item.");
		        goto done;
		    }
		BSTR bstrTmp = SysAllocString(pbstrItemIds[i]);
		if (NULL == bstrTmp)
		{
			DEBUGMSG("Out of memory ");
			delete pitem;
			goto done;
		}
		pitem->SetField(AUCatalogItem::m_pFieldNames[0], bstrTmp);
		 //even if one or more following item information is missing, add item anyway
		 for (int j = 1; j < ARRAYSIZE(AUCatalogItem::m_pFieldNames); j++)
		    {
	    		BSTR bstrItemInfo = NULL;
		       if (FAILED(itemdetails.GetItemInfo(AUCatalogItem::m_pFieldNames[j], pbstrItemIds[i], &bstrItemInfo)))
		        {
		            continue;
		        }
             	pitem->SetField(AUCatalogItem::m_pFieldNames[j], bstrItemInfo);
		    }
		  if ( IsPersistedHiddenItem(pbstrItemIds[i], hiddenItemList) ||
		        !itemdetails.IsVisible(pbstrItemIds[i]))
	            { //don't show non visible and hidden items
        	        pitem->SetStatusHidden(); 
	            }
	     	if (!itemList.Add(pitem))
	     	{
	     		DEBUGMSG("OUT OF MEMORY: fail to add new item");
	     		delete pitem;
	     		goto done;
	     	}
	}
    fRet = TRUE;
done:
        itemdetails.Uninit();
        if (!fRet)
            {
            itemList.Clear();
            }
        for (int k = 0; k < lNumItems; k++)
            {
                SafeFreeBSTR(pbstrItemIds[k]);
            }
        if (fItemIdsAllocated)
            {
                SafeFree(pbstrItemIds);
            }
        DEBUGMSG("fExtractItemInfo() ends");
        return fRet;
}


IXMLDOMNode * createDownloadItemStatusNode(IN IXMLDOMDocument * pxml, IN AUCatalogItem  &Item, IN const BSTR bsInstallation, OUT IXMLDOMNode **ppIdentity)
{
    IXMLDOMElement * pitemStatus = NULL;
    BOOL fError = FALSE; //no error occurs
    IXMLDOMNode * pdescription = NULL;
    IXMLDOMNode * pPlatform = NULL;
    IXMLDOMElement *pdownloadStatus = NULL;
    IXMLDOMElement *pdownloadPath = NULL;
    CItemDetails itemDetails;
    BSTR bsItemId, bsdownloadPath = NULL;
    VARIANT vComplete;
    IXMLDOMNode ** ItemStatusChildren[] = {ppIdentity, &pdescription, &pPlatform};

    DEBUGMSG("CAUCatalog::createDownloadItemStatusNode()  starts");
    *ppIdentity = NULL;
    if (!itemDetails.Init(bsInstallation))
        {
        DEBUGMSG("fail to init itemdetails");
        fError = TRUE;
        goto done;
        }

        
    bsItemId = Item.bstrID();
    DEBUGMSG("creating node for %S", bsItemId);
    if (NULL == bsItemId)
        {
        DEBUGMSG("fails to get item id");
        fError = TRUE;
        goto done;
        }
    if (FAILED(pxml->createElement(KEY_ITEMSTATUS, &pitemStatus)) || NULL == pitemStatus)
        {
        DEBUGMSG("fail to create item status node");
        fError = TRUE;
        goto done;
        }

    itemDetails.CloneIdentityNode(bsItemId, pxml, ppIdentity);
    itemDetails.CloneDescriptionNode(bsItemId, pxml, &pdescription);
    itemDetails.ClonePlatformNode(bsItemId, pxml, &pPlatform);
    if (NULL == *ppIdentity || NULL == pdescription || NULL == pPlatform)
        {
        fError = TRUE;
        goto done;
        }

  for (int i = 0; i < ARRAYSIZE(ItemStatusChildren); i++)
    {
      if (FAILED(pitemStatus->appendChild(*(ItemStatusChildren[i]), NULL)))
        {
        DEBUGMSG("fail to append identy node");
        fError = TRUE;
        goto done;
        }
    }

     if (FAILED(pxml->createElement(KEY_DOWNLOADPATH, &pdownloadPath)) || NULL == pdownloadPath)
        {
        DEBUGMSG("fail to create download path node");
        fError = TRUE;
        goto done;
        }

    bsdownloadPath = itemDetails.GetItemDownloadPath(bsItemId);
    if (NULL == bsdownloadPath)
        {
            fError = TRUE;
            goto done;
        }
    
    if (FAILED(pdownloadPath->put_text(bsdownloadPath)))
        {
        DEBUGMSG("fail to set download path text to %S", bsdownloadPath);
        fError = TRUE;
        goto done;
        }
    
    if (FAILED(pitemStatus->appendChild(pdownloadPath, NULL)))
        {
        DEBUGMSG("fail to append download path");
        fError = TRUE;
        goto done;
        }
    
    if (FAILED(pxml->createElement(KEY_DOWNLOADSTATUS, &pdownloadStatus)) || NULL == pdownloadStatus)
        {
        DEBUGMSG("fail to create download status node");
        fError = TRUE;
        goto done;
        }

    vComplete.vt = VT_BSTR;
    vComplete.bstrVal = SysAllocString(L"COMPLETE");
    if (NULL == vComplete.bstrVal)
    {
    	DEBUGMSG("Out of memory, fail to create string complete");
    	fError = TRUE;
    	goto done;
    }
    HRESULT hr = SetAttribute(pdownloadStatus, KEY_DOWNLOADSTATUS, vComplete);
    VariantClear(&vComplete);
    if (FAILED(hr))
        {
        DEBUGMSG("fail to set download status attribute");
        fError = TRUE;
        goto done;
        }

    if (FAILED(pitemStatus->appendChild(pdownloadStatus, NULL)))
        {
        DEBUGMSG("fail to append download status node");
        fError = TRUE;
        goto done;
        }

    
done:
    itemDetails.Uninit();
    SafeFreeBSTR(bsdownloadPath);
    if (fError)
        {
            SafeRelease(*ppIdentity);
            SafeRelease(pitemStatus);
            *ppIdentity = NULL;
            pitemStatus = NULL;
        }
    SafeRelease(pPlatform);
    SafeRelease(pdescription);
    SafeRelease(pdownloadPath);
    SafeRelease(pdownloadStatus);
    DEBUGMSG("CAUCatalog::createDownloadItemStatusNode() ends");
    return pitemStatus;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// *pbstrInstallation contains a subset of bsItemDetails (only items needs to be installed)
///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT PrepareInstallXML(
            IN  BSTR bsItemDetails, //a superset of items in the itemlist
            IN  AUCatalogItemList &itemList, 
            OUT BSTR * pbstrDownloadResult,
            OUT BSTR *pbstrInstallation)
{
  DEBUGMSG("::PrepareInstallXML");
  HRESULT hr = E_FAIL;
  BSTR bsRet = NULL;
  IXMLDOMNode * pItems = NULL;
  IXMLDOMDocument *pxml = NULL;
  CItemDetails  itemdetails;
  LONG lNumItems = 0;
  BSTR * pbstrItemIds = NULL;

   *pbstrDownloadResult = NULL;
   *pbstrInstallation = NULL;

    if (! itemdetails.Init(bsItemDetails))
        {
            DEBUGMSG("Fail to init item details ");
            goto done;
        }
    if (FAILED(hr = LoadXMLDoc(AUCatalog::bstrResultTemplate, &pxml)))
        {
        DEBUGMSG("::PrepareInstallXML() fail to load download result template with error %#lx", hr);
        goto done;
        }

     if (FAILED(hr = FindSingleDOMNode(pxml, KEY_ITEMS, &pItems)) || NULL == pItems)
        {
         DEBUGMSG("::PrepareInstallXML() fail to get items with error %#lx", hr);
         goto done;
        }

//    DEBUGMSG("need to insert %d items in download result", itemList.GetNumSelected());
     if (FAILED(hr = itemdetails.GetItemIds(&lNumItems, &pbstrItemIds)))
            {
                DEBUGMSG("Fail to get item ids with error %#lx", hr);
                goto done;
            }

    for (LONG l = 0; l < lNumItems; l++)
        {
            if (itemList.Contains(pbstrItemIds[l]) < 0)
                {
                    itemdetails.DeleteItem(pbstrItemIds[l]); //delete items not in the itemlist
                }
        }
    for (UINT i = 0; i < itemList.Count(); i++)
        {
            AUCatalogItem & item = itemList[i];
            if (item.fSelected() || itemList.ItemIsRelevant(i))
                {
                	long lItemNum = 0;
                	IXMLDOMNodeList *pIdentityNodeList = NULL;
                	if (FAILED(itemdetails.GetItemIdentities(item.bstrID(), &pIdentityNodeList)))
                	{
                		DEBUGMSG("Fail to get item identities for item %S", item.bstrID());
                		continue;
                	}
                	if (FAILED(pIdentityNodeList->get_length(&lItemNum)))
                	{

                		DEBUGMSG("Fail to get number of identity nodes"); //fixcode: bail out here
                		pIdentityNodeList->Release();
                		continue;
                	}
                	for (long lIndex = 0; lIndex < lItemNum; lIndex++)
                	{
                		DEBUGMSG("Create download status node %d for item %S", lIndex, item.bstrID());
                		IXMLDOMNode * pDetailsIdentity = NULL;
                        	IXMLDOMNode *pDownloadResultIdentity = NULL;
                		if (S_OK != pIdentityNodeList->get_item(lIndex, &pDetailsIdentity))
                		{
                			DEBUGMSG("Fail to get item %d", lIndex); //fixcode: bail out here
                			continue;
                		}
                		MungleIdentity(pDetailsIdentity, lIndex);
	                    IXMLDOMNode * pItemStatus = createDownloadItemStatusNode(pxml, item, bsItemDetails, &pDownloadResultIdentity);
	                    if (NULL != pItemStatus)
	                        {
					MungleIdentity(pDownloadResultIdentity, lIndex);
					if (FAILED(hr = pItems->appendChild(pItemStatus,NULL)))
					    {
					        DEBUGMSG("fail to insert item %d", i);
					    }
					else
					    {
					          DEBUGMSG("item %d inserted", i);
					    }
					pItemStatus->Release();
	                        }
	                    SafeRelease(pDetailsIdentity);
	                    SafeRelease(pDownloadResultIdentity);
                	}
                	pIdentityNodeList->Release();
                }
            else
                {
                    itemdetails.DeleteItem(item.bstrID());
                }
        }
   if ( FAILED(hr = pxml->get_xml(pbstrDownloadResult)) )
       {
        DEBUGMSG("::PrepareInstallXML() fail to get xml for the result %#lx", hr);
        goto done;
        }

   if (FAILED(hr = itemdetails.GetXML(pbstrInstallation)))
    {
        DEBUGMSG(" fail to get xml for installation with error %#lx", hr);
        goto done;
    }
   

done:
   itemdetails.Uninit();
   SafeRelease(pItems);
   SafeRelease(pxml);
   for (int k = 0; k < lNumItems; k++)
       {
           SafeFreeBSTR(pbstrItemIds[k]);
       }
   if (lNumItems > 0)
       {
           SafeFree(pbstrItemIds);
       }
   if (FAILED(hr))
    {
        SafeFreeBSTR(*pbstrDownloadResult);
        *pbstrDownloadResult = NULL;
        SafeFreeBSTR(*pbstrInstallation);
        *pbstrInstallation = NULL;
    }
   return hr;
}

///////////////////////////////////////////////////////////////////
// merge catalog 1 and catalog2 and make it destination catalog *pDesCatalog
// if either of bsCatalog1 and bsCatalog2 is NULL, return duplicate of the non NULL 
//  catalog 
// if both bsCatalog1 and bsCatalog2 are NULL, return NULL and S_FALSE
// 
///////////////////////////////////////////////////////////////////
HRESULT MergeCatalogs(IN const BSTR bsCatalog1, IN const BSTR bsCatalog2, OUT BSTR *pbsDesCatalog )
{
    IXMLDOMDocument * pCat1 = NULL;
    IXMLDOMDocument * pCat2 = NULL;
    IXMLDOMNodeList *pProviderNodeList = NULL;
    IXMLDOMNode *pCatalogNode = NULL;
    HRESULT hr = E_FAIL;

    DEBUGMSG("MergeCatalogs() starts");
    *pbsDesCatalog = NULL;
    if (NULL == bsCatalog1 && NULL == bsCatalog2)
    {
    	return S_FALSE;
    }
    if (NULL == bsCatalog1 || NULL == bsCatalog2)
        {
        *pbsDesCatalog = SysAllocString((NULL == bsCatalog1) ? bsCatalog2 : bsCatalog1);
        if (NULL == *pbsDesCatalog)
        {
        	DEBUGMSG("Out of memory");
        	hr = E_OUTOFMEMORY;
        	goto done;
        }
        hr = S_OK;
        goto done;
        }
    if ( FAILED(hr = LoadXMLDoc(bsCatalog1, &pCat1)) ||
         FAILED(hr = LoadXMLDoc(bsCatalog2,&pCat2)))
        {
        DEBUGMSG("MergeCatalogs() fail to load xml or fail or allocate string (with error %#lx)", hr);
        goto done;
        }
    if (FAILED(hr = FindSingleDOMNode(pCat1, AUCatalog::bstrCatalog, &pCatalogNode)))
        {
        DEBUGMSG("Fail to find provider in catalog 1");
        goto done;
        }
    if (NULL == (pProviderNodeList = FindDOMNodeList(pCat2, KEY_CATALOG_PROVIDER)))
        {
        DEBUGMSG("Fail to find provider in catalog 2 with error %#lx", hr);
        goto done;
        }
    long lNum;
    if (FAILED(hr = pProviderNodeList->get_length(&lNum)))
    {
    	DEBUGMSG("Fail to get nubmer of providers");
    	goto done;
    }
    for (int i = 0; i < lNum; i++)
        {
        IXMLDOMNode * pProviderNode = NULL;
        if (S_OK != (hr = pProviderNodeList->get_item(i, &pProviderNode)))
            {
            DEBUGMSG("Fail to get item in Provider List with error %#lx", hr);
            hr = FAILED(hr) ? hr : E_FAIL;
            goto done;
            }
        if (FAILED(hr = InsertNode(pCatalogNode, pProviderNode)))
            {
            DEBUGMSG("Fail to append provider node from catalog 2 to catalog 1 with error %#lx", hr);
            pProviderNode->Release();
            goto done;
            }
        pProviderNode->Release();
        }
    if (FAILED(hr = pCat1->get_xml(pbsDesCatalog)))
        {
            DEBUGMSG("Fail to get result xml for catalog 1 with error %#lx", hr);
            goto done;
        }
done:
    SafeRelease(pCat1);
    SafeRelease(pCat2);
    SafeRelease(pProviderNodeList);
    SafeRelease(pCatalogNode);
    if (FAILED(hr))
    {
    	SafeFreeBSTRNULL(*pbsDesCatalog);
    }
    DEBUGMSG("MergeCatalogs() ends");
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////
// populate itemlist for all items in the list with detailed information from local merged catalog xml file
// also return the merged catalog xml in pbstrInstallation
// if fDrvierNeeded, care to extract driver information. Otherwise, no driver info extracted
/////////////////////////////////////////////////////////////////////////////////////
HRESULT GetDetailedItemInfoFromDisk(IN OUT AUCatalogItemList  &ItemList, OUT BSTR *pbstrInstallation,  IN BOOL fDriverNeeded)
{
    HRESULT hr = S_OK;
    CItemDetails driverDetails, nonDriverDetails;
    BSTR bstrDriver = NULL;
    BSTR bstrNonDriver = NULL;

    *pbstrInstallation = NULL;

    if (NULL == (bstrNonDriver = ReadXMLFromFile(DETAILS_FILE)) ||
        (fDriverNeeded && (NULL == (bstrDriver = ReadXMLFromFile(DRIVERS_FILE)))))
        {
            DEBUGMSG("Fail to load driver or nondriver details xml file");
            hr = E_FAIL;
            goto done;
        }
    if (!nonDriverDetails.Init(bstrNonDriver) ||
          (fDriverNeeded && !driverDetails.Init(bstrDriver)))
        {
        DEBUGMSG("Fail to initialize item or driver details ");
        hr = E_FAIL;
        goto done;
        }
    if (FAILED(hr = MergeCatalogs(bstrDriver, bstrNonDriver, pbstrInstallation)))
        {
            DEBUGMSG("Fail to merge catalog with error %#lx", hr);
            goto done;
        }
    for (UINT u = 0; u < ItemList.Count(); u++)
        {
            for (int i = 1; i < ARRAYSIZE(AUCatalogItem::m_pFieldNames); i++)
                {
                    BSTR bstrItemInfo = NULL;
                    if (SUCCEEDED(nonDriverDetails.GetItemInfo(AUCatalogItem::m_pFieldNames[i], ItemList[u].bstrID(), &bstrItemInfo)) ||
                        (fDriverNeeded && SUCCEEDED(driverDetails.GetItemInfo(AUCatalogItem::m_pFieldNames[i], ItemList[u].bstrID(), &bstrItemInfo))))
                        {
                            ItemList[u].SetField(AUCatalogItem::m_pFieldNames[i], bstrItemInfo);
                        }
                    else  
                        {
                        DEBUGMSG("Warning: not getting information about %S for item %S", AUCatalogItem::m_pFieldNames[i], ItemList[u].bstrID());
                        }
                }
        }
    done:
        driverDetails.Uninit();
        nonDriverDetails.Uninit();
        if (FAILED(hr))
        {
	        SafeFreeBSTR(*pbstrInstallation);
	        *pbstrInstallation = NULL;
        }
        SafeFreeBSTR(bstrDriver);
	    SafeFreeBSTR(bstrNonDriver);
        return hr;
}



///////////////////////////////////////////////////////////////////////////////////////
// walk through the whole list of items, hidden or non hidden, build dependency list m_DependentItems
// for each item from scratch. The orginal m_DependentItems for each item is discarded
// bstrDriver could be NULL
/////////////////////////////////////////////////////////////////////////////////////////
HRESULT BuildDependencyList(
            AUCatalogItemList IN OUT &itemlist, 
            BSTR IN bstrDriver,
            BSTR IN bstrNonDriver)
{
    CItemDetails driverInfo;
    CItemDetails nondriverInfo;
    HRESULT hr = E_FAIL ;
    BOOL fHasDriverUpdate = TRUE;

    if (!nondriverInfo.Init(bstrNonDriver))
        {
            DEBUGMSG("Fail to initialize item details");
            goto done;
        }

    if (NULL != bstrDriver)
        {
            if (!driverInfo.Init(bstrDriver) )
                {
                    DEBUGMSG("Fail to initialize driver details");
                    goto done;
                }
        }
    else
        {
            fHasDriverUpdate = FALSE;
        }
    DEBUGMSG("Building direct dependency for non drivers");
    if (FAILED(hr = nondriverInfo.BuildDirectDependency(itemlist)))
            { //itemlist is a non driver and dependency built if any
            DEBUGMSG("Fail to build dependency for non drivers with error %#lx", hr);
            goto done;
            }
    if (fHasDriverUpdate)
        {
             DEBUGMSG("Building direct dependency for drivers");
             if (FAILED(hr = driverInfo.BuildDirectDependency(itemlist)))
                 { //itemlist is a driver and dependency built if any
                    DEBUGMSG("Fail to build dependency for drivers with error %#lx", hr);
                    goto done;
                 }
        }
     DEBUGMSG("Building indirect dependency");
    if (FAILED(hr = itemlist.BuildIndirectDependency()))
        {
            DEBUGMSG("Fail to build indirect dependency for itemlist with error %#lx", hr);
            goto done;
        }
    done:
        if (fHasDriverUpdate)
            {
                driverInfo.Uninit();
            }
        nondriverInfo.Uninit();
        DEBUGMSG("BuildDependencyList done");
#ifdef DBG
//        itemlist.DbgDump();
#endif
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\caustate.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    state.cpp
//
//  Creator: PeterWi
//
//  Purpose: State management functions.
//
//=======================================================================

#include "pch.h"
#pragma hdrstop

// global state object pointer
CAUState *gpState;
BOOL  gfDownloadStarted; //to be used to distinguish connection detection and actually downloading mode

#ifdef DBG
const TCHAR REG_AUCONNECTWAIT[] = _T("ConnectWait"); 
const TCHAR REG_SELFUPDATE_URL[] = _T("SelfUpdateURL");
#endif

const TCHAR REG_WUSERVER_URL[] = _T("WUServer");
const TCHAR REG_WUSTATUSSERVER_URL[] = _T("WUStatusServer");
const TCHAR REG_IDENT_URL[] = _T("IdentServer");
const TCHAR WU_LIVE_URL[] = _T("http://windowsupdate.microsoft.com/v4");


//AU configurable registry settings
const TCHAR REG_AUOPTIONS[] = _T("AUOptions"); //REG_DWORD
const TCHAR REG_AUSTATE[] = _T("AUState"); //REG_DWORD
const TCHAR REG_AUDETECTIONSTARTTIME[] = _T("DetectionStartTime"); //REG_SZ
const TCHAR REG_AUSCHEDINSTALLDAY[] = _T("ScheduledInstallDay"); //REG_DWORD
const TCHAR REG_AUSCHEDINSTALLTIME[] = _T("ScheduledInstallTime"); //REG_DWORD
const TCHAR REG_AUSCHEDINSTALLDATE[] = _T("ScheduledInstallDate"); //REG_SZ
const TCHAR REG_AUNOAUTOUPDATE[] = _T("NoAutoUpdate"); // REG_DWORD 1 means AU be disabled

//=======================================================================
//  CAUState::HrCreateState
//
//  Static function to create the global state object in memory.
//=======================================================================
/*static*/ HRESULT CAUState::HrCreateState(void)
{
    HRESULT hr;

    if ( NULL == (gpState = new CAUState()) )
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

	if (NULL == (gpState->m_hMutex = CreateMutex(NULL, FALSE, NULL)))
    {				
        DEBUGMSG("CAUState::HrCreateState() fail to CreateMutex with error %d",GetLastError());
        hr = E_FAIL;
        goto done;
    }
    hr = gpState->HrInit(TRUE);	
done:
    return hr;
}

CAUState::CAUState()
{ //only initialize members that destructor cares
    m_hMutex = NULL;
#ifdef DBG
    m_pszTestSelfUpdateURL = NULL;
#endif
    m_pszTestIdentServerURL = NULL;
}

void CAUState::m_Reset(void)
{
    m_PolicySettings.Reset();
    m_dwState = AUSTATE_OUTOFBOX;
#ifdef DBG    
    SafeFreeNULL(m_pszTestSelfUpdateURL);
#endif
    SafeFreeNULL(m_pszTestIdentServerURL);
    m_fWin2K = FALSE;
    m_auftSchedInstallDate.ull = AUFT_INVALID_VALUE;
    m_auftDetectionStartTime.ull = AUFT_INVALID_VALUE;
    m_dwCltAction = AUCLT_ACTION_NONE;
    m_fDisconnected = FALSE;
}
	

//=======================================================================
//  CAUState::HrInit
//
//  Initialize state.
//=======================================================================
HRESULT CAUState::HrInit(BOOL fInit)
{
        HRESULT hr = S_OK;

	    if (!m_lock())
	    {
	    	return HRESULT_FROM_WIN32(GetLastError());
	    }
        m_dwCltAction = AUCLT_ACTION_NONE;
        m_fDisconnected = FALSE;
        m_PolicySettings.m_fRegAUOptionsSpecified = TRUE;
		m_Reset();
    	m_ReadRegistrySettings(fInit);

        // read policy information.  If any domain policy setting is
        // invalid, we revert to admin policy settings.
        if ( FAILED(hr = m_ReadPolicy(fInit)) )	// called after getting m_dwState due to dependency
        { // only case this function fails is when out of memory
            goto done;
        }

        if (!gPingStatus.SetCorpServerUrl(m_PolicySettings.m_pszWUStatusServerURL))
		{
			hr = E_FAIL;
			goto done;
		}

        if ( FAILED(hr = m_ReadTestOverrides()))
	    {//only case this function fails is when out of memory
	        goto done;
	    }

		if (!m_PolicySettings.m_fRegAUOptionsSpecified)
		{
		    if (m_dwState >= AUSTATE_DETECT_PENDING)
		    {  //invalid option needs user attention via wizard
		  	m_dwState = AUSTATE_OUTOFBOX;
		    }
		}
		else if (!fOptionEnabled())
	    {
	        SetState(AUSTATE_DISABLED);
	    }
	    else if (m_dwState < AUSTATE_DETECT_PENDING)
	    {   // if domain policy set or auoption already configured, we skip the wizard state.
	        SetState(AUSTATE_DETECT_PENDING);
	    }
		
	    m_fWin2K = IsWin2K();
		gfDownloadStarted = FALSE;

done:
#ifdef DBG
    if ( SUCCEEDED(hr) )
    {
        m_DbgDumpState();
    }
#endif
    m_unlock();
	return hr;
}

BOOL fURLChanged(LPCTSTR url1, LPCTSTR url2)
{
    if (url1 == NULL && url2 == NULL)
        {
            return FALSE;
        }
    if ((url1 == NULL &&  url2 != NULL )
        || (url1 != NULL && url2 == NULL))
        {
            return TRUE;
        }
    return 0 != StrCmpI(url1, url2);
}

//read Policy info again and refresh state object (only care about possible admin policy change now)
//return S_FALSE if nothing changed
//return S_OK if policy changed and state successfully updated
//          *pActCode will indicate what to do
HRESULT CAUState::Refresh(enumAUPOLICYCHANGEACTION OUT *pActCode)
{
    AUPolicySettings  newsettings;
    HRESULT hr;

    if (!m_lock())
    {
    	return HRESULT_FROM_WIN32(GetLastError());
    }
    *pActCode = AUPOLICYCHANGE_NOOP;
    hr = newsettings.m_ReadIn();
    if (FAILED(hr))
        {
            goto done;
        }
    if (newsettings == m_PolicySettings)
        {
            hr = S_FALSE;
            goto done;
        }

    if (fURLChanged(newsettings.m_pszWUStatusServerURL, m_PolicySettings.m_pszWUStatusServerURL))
	{
		(void) gPingStatus.SetCorpServerUrl(newsettings.m_pszWUStatusServerURL);
	}

	if (!newsettings.m_fRegAUOptionsSpecified)
	{
		*pActCode = AUPOLICYCHANGE_NOOP;
	}
	else if ((fURLChanged(newsettings.m_pszWUServerURL, m_PolicySettings.m_pszWUServerURL) && AUSTATE_DISABLED != m_dwState)
            || (AUOPTION_AUTOUPDATE_DISABLE == m_PolicySettings.m_dwOption && newsettings.m_dwOption > m_PolicySettings.m_dwOption)
            || m_dwState < AUSTATE_DETECT_PENDING)
        { //stop client, cancel download if any, reset state to detect pending. do detect
            *pActCode = AUPOLICYCHANGE_RESETENGINE;
        }
    else if (AUOPTION_AUTOUPDATE_DISABLE == newsettings.m_dwOption && m_PolicySettings.m_dwOption != newsettings.m_dwOption)
        { //stop client, cancel download if any, set state to be disabled
            *pActCode = AUPOLICYCHANGE_DISABLE;
        }
    else if (AUSTATE_INSTALL_PENDING != m_dwState &&
            (newsettings.m_enPolicyType != m_PolicySettings.m_enPolicyType 
            ||newsettings.m_dwOption != m_PolicySettings.m_dwOption 
            ||newsettings.m_dwSchedInstallDay != m_PolicySettings.m_dwSchedInstallDay
            ||newsettings.m_dwSchedInstallTime != m_PolicySettings.m_dwSchedInstallTime))
        {
            *pActCode = AUPOLICYCHANGE_RESETCLIENT;
        }
    else
        {
            *pActCode = AUPOLICYCHANGE_NOOP;
        }
     m_PolicySettings.Copy(newsettings);
done:
#ifdef DBG
    m_DbgDumpState();
#endif
	m_unlock();
	DEBUGMSG("CAUState::Refresh() return %#lx with action code %d", hr, *pActCode);
    return hr;
}
    
            
void CAUState::m_ReadRegistrySettings(BOOL fInit)
{
        if ( FAILED(GetRegDWordValue(REG_AUSTATE, &m_dwState, enAU_AdminPolicy)) 
//        	||m_dwState < AUSTATE_MIN  //always false
        	|| m_dwState > AUSTATE_MAX)
        {
            m_dwState = AUSTATE_OUTOFBOX;
        }


        TCHAR tszDetectionStartTime[20];

        if ( fInit ||
        	 FAILED(GetRegStringValue(REG_AUDETECTIONSTARTTIME, tszDetectionStartTime,
                                      ARRAYSIZE(tszDetectionStartTime), enAU_AdminPolicy)) ||
             FAILED(String2FileTime(tszDetectionStartTime, &m_auftDetectionStartTime.ft)) )
        {
            m_auftDetectionStartTime.ull = AUFT_INVALID_VALUE;
        }

        if (!fInit)
        {
        	DeleteRegValue(REG_AUSCHEDINSTALLDATE);
        	m_auftSchedInstallDate.ull = AUFT_INVALID_VALUE;
        }
        else if (AUSTATE_DOWNLOAD_COMPLETE == m_dwState)
        {
        	TCHAR szSchedInstallDate[20];

        	if ( FAILED(GetRegStringValue(REG_AUSCHEDINSTALLDATE, szSchedInstallDate,
        								  ARRAYSIZE(szSchedInstallDate), enAU_AdminPolicy)) ||
        		 FAILED(String2FileTime(szSchedInstallDate, &m_auftSchedInstallDate.ft)) )
        	{
        		m_auftSchedInstallDate.ull = AUFT_INVALID_VALUE;
        	}
        }
    
        return;
}

//=======================================================================
//  CAUState::m_ReadPolicy
//  read in registry settings
//=======================================================================
HRESULT CAUState::m_ReadPolicy(BOOL fInit)
{
    return  m_PolicySettings.m_ReadIn();
}

HRESULT  AUPolicySettings::m_ReadIn()
{
    HRESULT hr = m_ReadWUServerURL();

	if (SUCCEEDED(hr))
	{
		m_enPolicyType = enAU_DomainPolicy;
	   for (int i = 0; i < 2; i++)
		{
			if ( FAILED(hr = m_ReadOptionPolicy()) ||
				 FAILED(hr = m_ReadScheduledInstallPolicy()) )
			{
				 m_enPolicyType = enAU_AdminPolicy;
				 continue;
			}
			break;
		}
	}

    DEBUGMSG("ReadPolicy: %d, hr = %#lx", m_enPolicyType, hr);
    return hr;
}

//=======================================================================
//  CAUState::m_ReadOptionPolicy
//  return S_FALSE if default option is returned 
//=======================================================================
HRESULT AUPolicySettings::m_ReadOptionPolicy(void)
{
    HRESULT hr = E_INVALIDARG;

	//  reading admin policy will always return success
    if ( enAU_DomainPolicy == m_enPolicyType )
    {
        // check if disabled by the NoAutoUpdate key
        if ( SUCCEEDED(CAUState::GetRegDWordValue(REG_AUNOAUTOUPDATE, &(m_dwOption), m_enPolicyType)) &&
             (AUOPTION_AUTOUPDATE_DISABLE == m_dwOption) )
        {
            hr = S_OK;
        }
    }

    if ( FAILED(hr) &&
            (FAILED(hr = CAUState::GetRegDWordValue(REG_AUOPTIONS, &(m_dwOption), m_enPolicyType)) ||
            (m_dwOption > AUOPTION_MAX) ||
            ((enAU_AdminPolicy == m_enPolicyType) && (m_dwOption < AUOPTION_ADMIN_MIN)) ||
            ((enAU_DomainPolicy == m_enPolicyType) && (m_dwOption < AUOPTION_DOMAIN_MIN))) )
    {
        if ( enAU_AdminPolicy == m_enPolicyType )
        {
           DEBUGMSG("bad admin option policy, defaulting to AUOPTION_INSTALLONLY_NOTIFY");
           m_fRegAUOptionsSpecified = (AUOPTION_UNSPECIFIED != m_dwOption);
           m_dwOption = AUOPTION_INSTALLONLY_NOTIFY;
           hr = S_FALSE; 
        }
        else
        {
           DEBUGMSG("invalid domain option policy");
           hr = E_INVALIDARG;
        }
    }

    DEBUGMSG("ReadOptionPolicy: type = %d, hr = %#lx", m_enPolicyType, hr);

    return hr;
}


//=======================================================================
//  CAUState::m_ReadScheduledInstallPolicy
//=======================================================================
HRESULT AUPolicySettings::m_ReadScheduledInstallPolicy()
{
    const DWORD DEFAULT_SCHED_INSTALL_DAY = 0;
    const DWORD DEFAULT_SCHED_INSTALL_TIME = 3;

    HRESULT hr = S_OK;

    if ( AUOPTION_SCHEDULED != m_dwOption )
    {
        m_dwSchedInstallDay = DEFAULT_SCHED_INSTALL_DAY;
        m_dwSchedInstallTime = DEFAULT_SCHED_INSTALL_TIME;
    }
    else
    {
        if ( FAILED(CAUState::GetRegDWordValue(REG_AUSCHEDINSTALLDAY, &m_dwSchedInstallDay, m_enPolicyType)) ||
             (m_dwSchedInstallDay > AUSCHEDINSTALLDAY_MAX) )
        {
            DEBUGMSG("invalid SchedInstallDay policy");
            if ( enAU_DomainPolicy == m_enPolicyType )
            {
                hr = E_INVALIDARG;
                goto done;
            }
            m_dwSchedInstallDay = DEFAULT_SCHED_INSTALL_DAY;
        }
        
        if ( FAILED(CAUState::GetRegDWordValue(REG_AUSCHEDINSTALLTIME, &m_dwSchedInstallTime, m_enPolicyType)) ||
             (m_dwSchedInstallTime > AUSCHEDINSTALLTIME_MAX) )
        {
            DEBUGMSG("invalid SchedInstallTime policy");
            if ( enAU_DomainPolicy == m_enPolicyType )
            {
                hr = E_INVALIDARG;
                goto done;
            }
            m_dwSchedInstallTime = DEFAULT_SCHED_INSTALL_TIME;
        }

    }
done:
    return hr;
}

//=======================================================================
//  CAUState::m_ReadWUServerURL
//  only error returned is E_OUTOFMEMORY
//=======================================================================
HRESULT AUPolicySettings::m_ReadWUServerURL(void)
{
    HRESULT hr = S_OK;
    
    LPTSTR *purls[2] = { &m_pszWUServerURL, &m_pszWUStatusServerURL};
    LPCTSTR RegStrs[2] = {REG_WUSERVER_URL, REG_WUSTATUSSERVER_URL};
    
    for (int i = 0 ; i < ARRAYSIZE(purls); i++)
    {
        DWORD dwBytes = INTERNET_MAX_URL_LENGTH * sizeof((*purls[i])[0]);

        if ( (NULL == *purls[i]) &&
             (NULL == (*purls[i] = (LPTSTR)malloc(dwBytes))) )
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = CAUState::GetRegStringValue(RegStrs[i], *purls[i],
                               dwBytes/sizeof((*purls[i])[0]), enAU_WindowsUpdatePolicy);

        if ( FAILED(hr) )
        {
            DEBUGMSG("invalid key %S; resetting both corp WU server URLs", RegStrs[i]);
            goto done;
        }
    }

done:
    if (FAILED(hr))
    {
        SafeFreeNULL(m_pszWUServerURL);
        SafeFreeNULL(m_pszWUStatusServerURL);

		if (E_OUTOFMEMORY != hr)
		{
			hr = S_OK;
		}
    }
        
    return hr;
}

HRESULT AUPolicySettings::m_SetInstallSchedule(DWORD dwSchedInstallDay, DWORD dwSchedInstallTime)
{
    HRESULT hr;
    if (enAU_DomainPolicy == m_enPolicyType)
        {
            return E_ACCESSDENIED; //if domain policy in force, option can not be changed
        }
    if (/*dwSchedInstallDay < AUSCHEDINSTALLDAY_MIN ||*/ dwSchedInstallDay > AUSCHEDINSTALLDAY_MAX 
        /*|| dwSchedInstallTime < AUSCHEDINSTALLTIME_MIN*/ || dwSchedInstallTime > AUSCHEDINSTALLTIME_MAX)
        {
        return E_INVALIDARG;
        }

    if (SUCCEEDED(hr = CAUState::SetRegDWordValue(REG_AUSCHEDINSTALLDAY, dwSchedInstallDay))
         && SUCCEEDED(hr = CAUState::SetRegDWordValue(REG_AUSCHEDINSTALLTIME, dwSchedInstallTime)))
        {
          m_dwSchedInstallDay = dwSchedInstallDay;
          m_dwSchedInstallTime = dwSchedInstallTime;
        }
    else
        { //roll back
        CAUState::SetRegDWordValue(REG_AUSCHEDINSTALLDAY, m_dwSchedInstallDay);
        CAUState::SetRegDWordValue(REG_AUSCHEDINSTALLTIME,m_dwSchedInstallTime);
        }
    return hr;
}

HRESULT AUPolicySettings::m_SetOption(AUOPTION & Option)
{
    HRESULT hr;
    if ( (Option.dwOption < AUOPTION_ADMIN_MIN) || (Option.dwOption > AUOPTION_MAX) )
    {
        return E_INVALIDARG;
    }

    if (enAU_DomainPolicy == m_enPolicyType)
    {
        return E_ACCESSDENIED; //if domain policy in force, option can not be changed
    }

    if (SUCCEEDED(hr = CAUState::SetRegDWordValue(REG_AUOPTIONS, Option.dwOption)))
    {
        m_dwOption = Option.dwOption;
    }
    else 
    {
	goto done;
    }

    if (AUOPTION_SCHEDULED == Option.dwOption)
        {
            hr = m_SetInstallSchedule(Option.dwSchedInstallDay, Option.dwSchedInstallTime);
        }

done:
    return hr;
}


//=======================================================================
//  CAUState::m_ReadTestOverrides
//=======================================================================
HRESULT CAUState::m_ReadTestOverrides(void)
{
    HRESULT hr = S_OK;
    DWORD dwBytes = 0;

#ifdef DBG
    dwBytes = INTERNET_MAX_URL_LENGTH * sizeof(m_pszTestSelfUpdateURL[0]);
    if ( (NULL == m_pszTestSelfUpdateURL) &&
         (NULL == (m_pszTestSelfUpdateURL = (LPTSTR)malloc(dwBytes))) )
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if ( FAILED(GetRegStringValue(REG_SELFUPDATE_URL, m_pszTestSelfUpdateURL,
                                   dwBytes/sizeof(m_pszTestSelfUpdateURL[0]), enAU_AdminPolicy)) )
    {
        SafeFreeNULL(m_pszTestSelfUpdateURL);
    }
#endif

    dwBytes = INTERNET_MAX_URL_LENGTH * sizeof(m_pszTestIdentServerURL[0]);

    if ( (NULL == m_pszTestIdentServerURL) &&
         (NULL == (m_pszTestIdentServerURL = (LPTSTR)malloc(dwBytes))) )
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if ( FAILED(GetRegStringValue(REG_IDENT_URL, m_pszTestIdentServerURL,
                                   dwBytes/sizeof(m_pszTestIdentServerURL[0]), enAU_IUControlPolicy)) )
    {
        SafeFreeNULL(m_pszTestIdentServerURL);
    }

done:
    return hr;
}


//=======================================================================
//  CAUState::m_SetScheduledInstallDate
//   returns
//    S_OK - there was no need to change the scheduled install date
//    other - error code
//=======================================================================
HRESULT CAUState::m_SetScheduledInstallDate(void)
{
    // fixcode need to put new scheduled time in event log
    HRESULT hr = S_OK;	// assume scheduled install date unchanged
    TCHAR szSchedInstallDate[20];

	if (SUCCEEDED(hr = FileTime2String(m_auftSchedInstallDate.ft, szSchedInstallDate, ARRAYSIZE(szSchedInstallDate))))
	{
		DEBUGMSG("New scheduled install date: %S", szSchedInstallDate);
		hr = SetRegStringValue(REG_AUSCHEDINSTALLDATE, szSchedInstallDate, enAU_AdminPolicy);
	}
	else
	{
		DEBUGMSG("failed m_SetScheduledInstallDate() == %#lx", hr);
	}
    return hr;
}


AUOPTION CAUState::GetOption(void)
{
    AUOPTION opt;
    BOOL fLocked = m_lock();
    opt.dwOption = m_PolicySettings.m_dwOption;
    opt.dwSchedInstallDay = m_PolicySettings.m_dwSchedInstallDay;
    opt.dwSchedInstallTime = m_PolicySettings.m_dwSchedInstallTime;
    opt.fDomainPolicy = (enAU_DomainPolicy == m_PolicySettings.m_enPolicyType);
    if (fLocked) 
    	m_unlock();
    return opt;
}

//=======================================================================
//  CAUState::SetOption
// option.fDomainPolicy is irrelevant. Not settable
//=======================================================================
HRESULT CAUState::SetOption(AUOPTION & Option)
{
    HRESULT hr;
    
    if (!m_lock())
    {
    	return HRESULT_FROM_WIN32(GetLastError());
    }
    hr = m_PolicySettings.m_SetOption(Option);
    m_unlock();
    return hr;
}

HRESULT CAUState::SetInstallSchedule(DWORD dwSchedInstallDay, DWORD dwSchedInstallTime)
{
    HRESULT hr;

    if (!m_lock())
    {
    	return HRESULT_FROM_WIN32(GetLastError());
    }
    hr = m_PolicySettings.m_SetInstallSchedule(dwSchedInstallDay, dwSchedInstallTime);
    m_unlock();
    return hr;
}




//=======================================================================
// CAUState::SetState
// it could also be called to kick state event in both engine and client
// even if no state change is involved
//=======================================================================
void CAUState::SetState(DWORD dwState)
{
	if (!m_lock())
    {
    	return ;
    }

    if ( m_dwState != dwState )
    {
	    m_dwState = dwState;		
	    SetRegDWordValue(REG_AUSTATE, dwState);
		DEBUGMSG("WUAUENG SetState Event, state = %d", dwState);
    }
    else
    {
        DEBUGMSG("kick state event in client and engine with state %d", dwState);
    }
	SetEvent(ghEngineState);
   	ghClientHandles.ClientStateChange();
	m_unlock();
}    

void CAUState::GetInstallSchedule(DWORD *pdwSchedInstallDay, DWORD *pdwSchedInstallTime)
{
	BOOL fLocked = m_lock();
    *pdwSchedInstallDay = m_PolicySettings.m_dwSchedInstallDay;
    *pdwSchedInstallTime = m_PolicySettings.m_dwSchedInstallTime;
    if (fLocked)
    	m_unlock();
}


//=======================================================================
// CAUState::fWasSystemRestored
//
// Determine if system was restored.
//=======================================================================
BOOL CAUState::fWasSystemRestored(void)
{
	if ( fIsPersonalOrProfessional() &&
		 fRegKeyExists(AUREGKEY_HKLM_SYSTEM_WAS_RESTORED) )
	{
    	fRegKeyDelete(AUREGKEY_HKLM_SYSTEM_WAS_RESTORED);
		return TRUE;
	}

	return FALSE;
}

void CAUState::SetDisconnected(BOOL fDisconnected)
{
	if (!m_lock())
    {
    	return ;
    }
	m_fDisconnected = fDisconnected;		
	m_unlock();
}

//=======================================================================
// CAUState::GetRegDWordValue
//=======================================================================
HRESULT CAUState::GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue, enumAUPolicyType enPolicyType)
{
    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

  	return ::GetRegDWordValue(lpszValueName, pdwValue, 
		                    (enAU_DomainPolicy == enPolicyType) ? AUREGKEY_HKLM_DOMAIN_POLICY : AUREGKEY_HKLM_ADMIN_POLICY);
}


//=======================================================================
// CAUState::SetRegDWordValue
//=======================================================================
HRESULT CAUState::SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue, enumAUPolicyType enPolicyType, DWORD options)
{
    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

   return ::SetRegDWordValue(lpszValueName, dwValue, options, 
    	(enAU_DomainPolicy == enPolicyType) ? AUREGKEY_HKLM_DOMAIN_POLICY : AUREGKEY_HKLM_ADMIN_POLICY);
}

//=======================================================================
// CAUState::GetRegStringValue
//=======================================================================
HRESULT CAUState::GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int nCharCount, enumAUPolicyType enPolicyType)
{
    LPCTSTR  pszSubKey; 


    if (lpszValueName == NULL || lpszBuffer == NULL)
    {
        return E_INVALIDARG;
    }

    switch (enPolicyType)
    {
    case enAU_DomainPolicy:          pszSubKey = AUREGKEY_HKLM_DOMAIN_POLICY; break;
    case enAU_AdminPolicy:           pszSubKey = AUREGKEY_HKLM_ADMIN_POLICY; break;
    case enAU_WindowsUpdatePolicy:   pszSubKey = AUREGKEY_HKLM_WINDOWSUPDATE_POLICY; break;
    case enAU_IUControlPolicy:       pszSubKey = AUREGKEY_HKLM_IUCONTROL_POLICY; break;
    default:                         return E_INVALIDARG;
    }

   return ::GetRegStringValue(lpszValueName, lpszBuffer, nCharCount, pszSubKey);
}


//=======================================================================
// CAUState::SetRegStringValue
//=======================================================================
HRESULT CAUState::SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue, enumAUPolicyType enPolicyType)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;
    
    if (lpszValueName == NULL || lpszNewValue == NULL)
    {
        return E_INVALIDARG;
    }

   
	return ::SetRegStringValue(lpszValueName, lpszNewValue, 
		(enAU_DomainPolicy == enPolicyType) ? AUREGKEY_HKLM_DOMAIN_POLICY : AUREGKEY_HKLM_ADMIN_POLICY);
}

//=======================================================================
//  Calculate Scheduled Date
//=======================================================================
HRESULT CAUState::m_CalculateScheduledInstallDate(AUFILETIME & auftSchedInstallDate,
                                             DWORD *pdwSleepTime)
{
    if ( (-1 == m_PolicySettings.m_dwSchedInstallDay) || (-1 == m_PolicySettings.m_dwSchedInstallTime) )
    {
        return E_INVALIDARG;
    }

    //DEBUGMSG("Schedule day: %d, time: %d", m_dwSchedInstallDay, m_dwSchedInstallTime);

    AUFILETIME auftNow;
    SYSTEMTIME stNow;
    GetLocalTime(&stNow);

    if ( !SystemTimeToFileTime(&stNow, &auftNow.ft) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    SYSTEMTIME stScheduled = stNow;
    stScheduled.wHour = (WORD)m_PolicySettings.m_dwSchedInstallTime;
    stScheduled.wMinute = stScheduled.wSecond = stScheduled.wMilliseconds = 0;

    DWORD dwSchedInstallDayOfWeek = (0 == m_PolicySettings.m_dwSchedInstallDay) ? stNow.wDayOfWeek : (m_PolicySettings.m_dwSchedInstallDay - 1);
    DWORD dwDaysToAdd = (7 + dwSchedInstallDayOfWeek - stNow.wDayOfWeek) % 7;

    //DEBUGMSG("daystoadd %d", dwDaysToAdd);

    AUFILETIME auftScheduled;

    if ( !SystemTimeToFileTime(&stScheduled, &auftScheduled.ft) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    auftScheduled.ull += (ULONGLONG)dwDaysToAdd * AU_ONE_DAY * NanoSec100PerSec;

    if ( auftScheduled.ull < auftNow.ull )
    {
        // we missed the time today, go to next scheduled day
        auftScheduled.ull += (ULONGLONG)((0 == m_PolicySettings.m_dwSchedInstallDay) ? AU_ONE_DAY : AU_ONE_WEEK) * NanoSec100PerSec;
    }

    auftSchedInstallDate = auftScheduled;

    *pdwSleepTime = (DWORD)((auftScheduled.ull - auftNow.ull) / NanoSec100PerSec);

    return S_OK;
}


//=======================================================================
//  CAUState::CalculateScheduledInstallSleepTime
//=======================================================================
HRESULT CAUState::CalculateScheduledInstallSleepTime(DWORD *pdwSleepTime)
{
    HRESULT hr = S_OK;
    *pdwSleepTime = 0;

	if (!m_lock())
    {
    	return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( (-1 == m_PolicySettings.m_dwSchedInstallDay) || (-1 == m_PolicySettings.m_dwSchedInstallTime) )
    {
        hr = E_INVALIDARG;
        goto done;
    }

    AUFILETIME auftSchedInstallDate;
    if (SUCCEEDED(hr = m_CalculateScheduledInstallDate(auftSchedInstallDate, pdwSleepTime)))
    {
        if (m_auftSchedInstallDate.ull != auftSchedInstallDate.ull)
        {     //recalculate sleep time if anything changes
        	m_auftSchedInstallDate = auftSchedInstallDate;
        	if (S_OK == (hr = m_SetScheduledInstallDate()))
        	{
        		hr = S_FALSE;
        	}
        }
    }

    AUFILETIME auftNow;
    SYSTEMTIME stNow;
    GetLocalTime(&stNow);
    
    if ( !SystemTimeToFileTime(&stNow, &auftNow.ft) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

	if (AUFT_INVALID_VALUE != m_auftSchedInstallDate.ull)
	{
		if ( auftNow.ull < m_auftSchedInstallDate.ull )
		{
			*pdwSleepTime = (DWORD) ((m_auftSchedInstallDate.ull - auftNow.ull) / NanoSec100PerSec);
		}
		else if ( ((auftNow.ull - m_auftSchedInstallDate.ull) / NanoSec100PerSec) <= AU_TEN_MINS )
        {
			// we should have done the scheduled install within the
			// last 10 minutes.  Close enough, do it now.
        }
	}

done:
//    DEBUGMSG("CalculateScheduleInstallSleepTime return %d sleeping secs with result %#lx", *pdwSleepTime, hr);
	m_unlock();
    return hr;
}

//=======================================================================
//  CAUState::SetDetectionStartTime
//=======================================================================
void CAUState::SetDetectionStartTime(BOOL fOverwrite)
{
	if (!m_lock())
    {
    	return ;
    }

	if (fOverwrite || AUFT_INVALID_VALUE == m_auftDetectionStartTime.ull)
	{
		AUFILETIME auftNow;
		SYSTEMTIME stNow;
		GetLocalTime(&stNow);
    
		if (SystemTimeToFileTime(&stNow, &auftNow.ft))
		{
			HRESULT hr;
			TCHAR tszDetectionStartTime[20];

			if (SUCCEEDED(hr = FileTime2String(auftNow.ft, tszDetectionStartTime, ARRAYSIZE(tszDetectionStartTime))))
			{
				m_auftDetectionStartTime = auftNow;
				DEBUGMSG("New last connection check time: %S", tszDetectionStartTime);
				SetRegStringValue(REG_AUDETECTIONSTARTTIME, tszDetectionStartTime, enAU_AdminPolicy);
			}
			else
			{
				DEBUGMSG("failed m_SetScheduledInstallDate() == %#lx", hr);
			}
		}
	}
	else
	{
		DEBUGMSG("CAUState::SetDetectionStartTime() fOverwrite==FALSE, time(%#lx%8lx) != AUFT_INVALID_VALUE.", m_auftDetectionStartTime.ft.dwHighDateTime, m_auftDetectionStartTime.ft.dwLowDateTime);
	}
	m_unlock();
}

//=======================================================================
//  CAUState::IsUnableToConnect
//=======================================================================
BOOL CAUState::IsUnableToConnect(void)
{
	AUFILETIME auftNow;
	SYSTEMTIME stNow;
	GetLocalTime(&stNow);

	if (!SystemTimeToFileTime(&stNow, &auftNow.ft))
	{
		return FALSE;	//REVIEW: or return TRUE?
	}

	if (!m_lock())
    {
    	return FALSE;
    }

	BOOL fRet = FALSE;
	if (AUFT_INVALID_VALUE != m_auftDetectionStartTime.ull &&
		(auftNow.ull - m_auftDetectionStartTime.ull) / NanoSec100PerSec >= dwSecsToWait(AU_TWO_DAYS))
	{
		fRet = TRUE;
	}
	m_unlock();
	return fRet;
}

//=======================================================================
//  CAUState::RemoveDetectionStartTime
//=======================================================================
void CAUState::RemoveDetectionStartTime(void)
{
	if (!m_lock())
    {
    	return ;
    }
	DeleteRegValue(REG_AUDETECTIONSTARTTIME);
	m_auftDetectionStartTime.ull = AUFT_INVALID_VALUE;
	m_unlock();
}

#ifdef DBG
//=======================================================================
//  CAUState::m_DbgDumpState
//=======================================================================
void CAUState::m_DbgDumpState(void)
{
    DEBUGMSG("======= Initial State Dump =========");
    m_PolicySettings.m_DbgDump();
    DEBUGMSG("State: %d", m_dwState);

    TCHAR szSchedInstallDate[20];

    if ( 0 == m_auftSchedInstallDate.ull )
    {
        (void)StringCchCopyEx(szSchedInstallDate, ARRAYSIZE(szSchedInstallDate), _T("none"), NULL, NULL, MISTSAFE_STRING_FLAGS);
    }
    else
    {
        if ( FAILED(FileTime2String(m_auftSchedInstallDate.ft, szSchedInstallDate, ARRAYSIZE(szSchedInstallDate))) )
        {
            (void)StringCchCopyEx(szSchedInstallDate, ARRAYSIZE(szSchedInstallDate), _T("invalid"), NULL, NULL, MISTSAFE_STRING_FLAGS);
        }
    }
    DEBUGMSG("ScheduledInstallDate: %S", szSchedInstallDate);
    //DEBUGMSG("WUServer Value: %S", gpState->GetWUServerURL());
    DEBUGMSG("Ident Server: %S", gpState->GetIdentServerURL());
    DEBUGMSG("Self Update Server URL Override: %S", (NULL != gpState->GetSelfUpdateServerURLOverride()) ? gpState->GetSelfUpdateServerURLOverride() : _T("none"));

    DEBUGMSG("=====================================");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\prsheet.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       prsheet.h
//
//--------------------------------------------------------------------------
#pragma once

HRESULT
CAutoUpdatePropSheet_CreateInstance(
    HINSTANCE hInstance,
    REFIID riid,
    void **ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       resource.h
//
//--------------------------------------------------------------------------
#include "aucomres.h"
#define IDS_HEADER_CONNECTING           1
#define IDS_HEADER_UNAVAILABLE          2
#define IDS_HEADER_CONNECTED            3
#define IDS_SERVICENAME                 10000  //also used by system property sheet. Should not be changed
//#define IDR_Wuaueng                     100
//#define IDS_UPDATES_DESC                101
//#define IDR_Updates           102
#define IDS_SERVICE_DESC	104
#define IDS_EVT_LISTITEMFORMAT	105
#define IDS_STR_EVERYDAY        106
#define IDS_STR_SUNDAY          107
#define IDS_STR_MONDAY          108
#define IDS_STR_TUESDAY         109
#define IDS_STR_WEDNESDAY       110
#define IDS_STR_THURSDAY        111
#define IDS_STR_FRIDAY          112
#define IDS_STR_SATURDAY        113
	

//#define IDS_PROPPAGE_NAME				10000

#define IDC_STATIC                     -1
#define IDI_AUTOUPDATE                500
#define IDD_AUTOUPDATE                501

//#define IDC_AUTOUPDATE_OPTION1       1000
//#define IDC_AUTOUPDATE_OPTION2       1001
//#define IDC_AUTOUPDATE_OPTION3       1002
//#define IDC_BTN_RESTORE		     1003
#define IDC_GRP_OPTIONS                 1004
#define IDC_TXT_HEADER                  1007
//#define IDC_CHK_KEEPUPTODATE		1008
//#define IDC_CMB_DAYS			1009
//#define IDC_CMB_HOURS			1010

#define IDC_STATICAT			1011
#define IDC_AUTOUPDATELINK		1012
#define IDC_SCHINSTALLINK		1013

#define IDD_RESTOREUPDATE 		1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\service.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  xx
//
//  Prototypes of functions defined on service.cpp and used externally. 
//
//  10/19/2001   annah   Created
//
//----------------------------------------------------------------------------

#pragma once

#include "pch.h"

extern SESSION_STATUS gAdminSessions;
extern const TCHAR AU_SERVICE_NAME[];

BOOL AUGetUserToken(ULONG LogonId, PHANDLE pImpersonationToken);
BOOL IsUserAUEnabledAdmin(DWORD dwSessionId);
BOOL IsSession0Active();
BOOL FSessionActive(DWORD dwAdminSession, WTS_CONNECTSTATE_CLASS *pWTSState = NULL);
BOOL IsAUValidSession(DWORD dwSessionId);
BOOL IsWin2K();
VOID SetActiveAdminSessionEvent();
void ResetEngine(void);
void DisableAU(void);
void ServiceFinishNotify(void);

//Current AU Engine version
const DWORD AUENGINE_VERSION = 1;

//Supported Service versions
const DWORD AUSRV_VERSION_1 = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\selfupdate.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       selfupdate.cpp
//
//  Desc:       This file contains all the functions necessary for self-update
//--------------------------------------------------------------------------

#include "pch.h"

#include <osdet.h>
#include <muiutil.h>

#define TCHAR_SCTRUCTURE_DELIMITER  _T('|')

struct AU_FILEINCAB
{
    TCHAR   szFilePath[MAX_PATH + 1];
    TCHAR   szNewFilePath[MAX_PATH + 1];
    TCHAR   szBackupFilePath[MAX_PATH + 1];
    TCHAR   szExtractFilePath[MAX_PATH + 1];
    BOOL    fCreatedBackup;
    BOOL    fFileExists;
    AU_FILEINCAB *pNextFileInCab;
};

struct AU_COMPONENT : AU_FILEINCAB
{
    TCHAR   *pszSectionName;
    TCHAR   szFileName[_MAX_FNAME + 1];
    TCHAR   szCabName[_MAX_FNAME + 1];
    TCHAR   szCabPath[MAX_PATH + 1];
    CHAR    a_szCabPath[MAX_PATH + 1];
    TCHAR   szInfName[_MAX_FNAME + 1];
    CHAR    a_szInfName[_MAX_FNAME + 1];
    DWORD   dwUpdateMS;
    DWORD   dwUpdateLS;
    BOOL    fDoUpgrade;
    BOOL    fNeedToCheckMui;
    BOOL    fMuiFile;
    BOOL    fHasHelpfile;
    AU_COMPONENT *pNext;
};


// AU_UPDATE_VERSION should be updated when incompatible changes are made to the
// self update mechanism required AU to go to a new directory for update info. 
const TCHAR IDENT_TXT[] = _T("iuident.txt");
const TCHAR WUAUCOMP_CAB[] = _T("wuaucomp.cab");
const TCHAR WUAUCOMP_CIF[] = _T("wuaucomp.cif");
const TCHAR WUAUENG_DLL[] = TEXT("wuaueng.dll");
const TCHAR AU_KEY_FILE_NAME[] = TEXT("file");
const TCHAR AU_KEY_FILE_VERSION[] = TEXT("version");
const TCHAR AU_KEY_CAB_NAME[] = TEXT("cab");
const TCHAR AU_KEY_INF_NAME[] = TEXT("inf");
const TCHAR AU_KEY_RESMOD_NAME[] = TEXT("resmodule");
const TCHAR AU_KEY_HELPFILE[] = TEXT("helpfile");
const DWORD MAX_SECTION = 30;

// main selfupdate keys
const TCHAR IDENT_SERVERURLEX[] = _T("ServerUrlEx");
const TCHAR IDENT_STRUCTUREKEYEX[] = _T("StructureKeyEx");

const TCHAR INIVALUE_NOTFOUND[] = _T("??");

BOOL fConvertVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);
HRESULT InstallUpdatedComponents(LPCTSTR pszSelfUpdateUrl,
                                 LPCTSTR pszMuiUpdateUrl,
                                 LPCTSTR pszIdentTxt,
                                 LPCTSTR pszFileCacheDir,
                                 LPCTSTR pszCif,
                                 BOOL *pfInstalledWUAUENG);
BOOL ReplaceFileInPath(LPCTSTR pszPath, LPCTSTR szNewFile, LPTSTR pszNewPathBuf, DWORD cchNewPathBuf);
BOOL MyGetPrivateProfileString( IN LPCWSTR lpAppName,
                                IN LPCWSTR lpKeyName,
                                OUT LPWSTR lpReturnedString,
                                IN DWORD nSize,
                                IN LPCWSTR lpFileName,
								IN LPCTSTR lpDefault=_T(""));

inline BOOL fNewerFile(DWORD dwUpdateMS, DWORD dwUpdateLS, DWORD dwExistingMS, DWORD dwExistingLS)
{
    return (dwUpdateMS > dwExistingMS) ||
            ((dwUpdateMS == dwExistingMS) && (dwUpdateLS > dwExistingLS));
}

inline HRESULT vAU_W2A(LPCWSTR lpWideCharStr, LPSTR lpMultiByteStr, int cbMultiByte)
{
	if ( 0 != WideCharToMultiByte(CP_ACP, 0, lpWideCharStr, -1, lpMultiByteStr, cbMultiByte, NULL, NULL))
	{
		return S_OK;
	}
	else
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
}

HRESULT SelfUpdate(void)
{
    HRESULT hr;
    BOOL    fInstalledWUAUENG = FALSE;

    DEBUGMSG("------------------------SELFUPDATE BEGINS---------------------------");
    
    
    if( FAILED(hr = CheckForUpdatedComponents(&fInstalledWUAUENG)) )
    {
        goto lCleanUp;
    }
    
    if ( fInstalledWUAUENG )
    {
        DEBUGMSG("SELFUPDATE installed new wuaueng");
        hr = S_FALSE;
        goto lCleanUp;      
    }

lCleanUp:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// CleanFileCache()
//
//////////////////////////////////////////////////////////////////////////////////////////

BOOL CleanFileCache(LPCTSTR pszFileCacheDir)
{
    BOOL fRet = TRUE;
    TCHAR szFileCacheDir[MAX_PATH + 1];
    TCHAR szFilePath[MAX_PATH + 1];
    WIN32_FIND_DATA fd;
    HANDLE hFindFile = INVALID_HANDLE_VALUE;

    
    if (FAILED(StringCchCopyEx(szFileCacheDir, ARRAYSIZE(szFileCacheDir), pszFileCacheDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        fRet = FALSE;
        goto done;
    }
    
    if (FAILED(PathCchAppend(szFileCacheDir, ARRAYSIZE(szFileCacheDir), TEXT("*.*"))))
    {
        fRet = FALSE;
        goto done;
    }

    // Find the first file
    hFindFile = FindFirstFile(szFileCacheDir, &fd);

    if ( INVALID_HANDLE_VALUE == hFindFile )
    {
        goto done;
    }

    do
    {
        if ( !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
        {
            // Make file path
            if (FAILED(StringCchCopyEx(szFilePath, ARRAYSIZE(szFilePath), pszFileCacheDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
                FAILED(PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), fd.cFileName)) || 
                !SetFileAttributes(szFilePath, FILE_ATTRIBUTE_NORMAL) ||
                !DeleteFile(szFilePath))
            {
                fRet = FALSE;
                DEBUGMSG("Couldn't delete file %S", szFilePath);
            }
        }
    }
    while ( FindNextFile(hFindFile, &fd) );// Find the next entry

done:
    if ( INVALID_HANDLE_VALUE != hFindFile )
    {
        FindClose(hFindFile);
    }
    
    return fRet;
}


//////////////////////////////////////////////////////////////////////
//
// GetSelfUpdateUrl()
//
// Should be like:
//
//	http://windowsupdate.microsoft.com/selfupdate/x86/XP/en
////////////////////////////////////////////////////////////////////////
HRESULT GetSelfUpdateUrl(LPCTSTR ptszName, 
                           LPCTSTR ptszBaseUrl, 
                           LPCTSTR pszIdentTxt, 
                           LPTSTR  pszSelfUpdateUrl,
                           DWORD   cchSelfUpdateUrl,
                           LPTSTR  pszMuiUpdateUrl,
                           DWORD   cchMuiUpdateUrl)
{
    LOG_Block("GetSelfUpdateUrl");
    HRESULT hr;
    TCHAR   tszKey[MAX_SECTION];    // at least MAX_ISO_CODE_LENGTH
    TCHAR   tszValue[MAX_PATH];
    BOOL    fLangField;
   
    if (FAILED(hr = StringCchCopyEx(tszKey, ARRAYSIZE(tszKey), ptszName, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
        FAILED(hr = StringCchCatEx(tszKey, ARRAYSIZE(tszKey), _T("SelfUpdate"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        goto lFinish;
    }

    if (NULL == ptszBaseUrl)
    {
        // Get SelfUpdate Server URL
        if (MyGetPrivateProfileString(
                tszKey,
                IDENT_SERVERURLEX,
                pszSelfUpdateUrl,
                cchSelfUpdateUrl,
                pszIdentTxt) == FALSE)
        {
            // no URL specified in iuident..
            hr = E_FAIL;
            goto lFinish;
        }
        else
        {
            if (FAILED(hr = StringCchCopyEx(pszMuiUpdateUrl, cchMuiUpdateUrl, pszSelfUpdateUrl, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                goto lFinish;
        }
    }
    else
    {
        if (FAILED(hr = StringCchCopyEx(pszSelfUpdateUrl, cchSelfUpdateUrl, ptszBaseUrl, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
            FAILED(hr = StringCchCopyEx(pszMuiUpdateUrl, cchMuiUpdateUrl, ptszBaseUrl, NULL, NULL, MISTSAFE_STRING_FLAGS)))
        {
            goto lFinish;
        }
        // Remove trailing _T('/') if present
        int nBaseUrlLen = lstrlen(pszSelfUpdateUrl);

        if(nBaseUrlLen <= 0)
        {
            hr = E_FAIL;
            goto lFinish;
        }
        if (_T('/') == pszSelfUpdateUrl[nBaseUrlLen-1])
        {
            pszSelfUpdateUrl[nBaseUrlLen-1] = _T('\0');
            pszMuiUpdateUrl[nBaseUrlLen-1] = _T('\0');
        }
    }

    TCHAR tszStructure[MAX_PATH];

    if (!MyGetPrivateProfileString(
            tszKey,
            IDENT_STRUCTUREKEYEX,
            tszStructure,
            ARRAYSIZE(tszStructure),
            pszIdentTxt))
    {
        // no STRUCTYREKEY specified in iuident..
        hr = E_FAIL;
        goto lFinish;
    }

    // Parse the SelfUpdate Structure Key for Value Names to Read
    LPTSTR ptszWalk = tszStructure;
    while (_T('\0') != ptszWalk[0])
    {
        LPTSTR ptszDelim;

        fLangField = FALSE;

        if (NULL != (ptszDelim = StrChr(ptszWalk, TCHAR_SCTRUCTURE_DELIMITER)))
        {
            *ptszDelim = _T('\0');
        }

        if (_T('/') == ptszWalk[0])
        {
            if (FAILED(hr = StringCchCopyEx(tszValue, ARRAYSIZE(tszValue), ptszWalk, NULL, NULL, MISTSAFE_STRING_FLAGS)))
            {
                goto lFinish;
            }
        }
        else
        {
            int nPrefixLength = lstrlen(ptszName);
            LPCTSTR ptszToken = ptszWalk;

            if (0 == StrCmpNI(ptszWalk, ptszName, nPrefixLength))
            {
                ptszToken += nPrefixLength;
            }

            if (0 == StrCmpI(ptszToken, IDENT_ARCH))
            {
                if (!MyGetPrivateProfileString(
                        ptszWalk,
#ifdef _IA64_
                        IDENT_IA64,
#else
                        IDENT_X86,
#endif
                        tszValue,
                        ARRAYSIZE(tszValue),
                        pszIdentTxt))
                {
                    // insufficient buffer
                    hr = E_FAIL;
                    goto lFinish;
                }
            }
            else if (0 == StrCmpI(ptszToken, IDENT_OS))
            {
                if (FAILED(hr = StringCchCopyEx(tszKey, ARRAYSIZE(tszKey), ptszWalk, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
                    FAILED(hr = StringCchCatEx(tszKey, ARRAYSIZE(tszKey), _T("NT"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
                {
                    goto lFinish;
                }

                if (S_OK != GetINIValueByOSVer(
                                pszIdentTxt,
                                tszKey,
                                tszValue,
                                ARRAYSIZE(tszValue)))
                {
                    hr = E_FAIL;
                    goto lFinish;
                }
            }
            else if (0 == StrCmpI(ptszToken, IDENT_LANG))
            {
                fLangField = TRUE;
                
                // Get the Current Locale String
                (void) LookupLocaleString(tszKey, ARRAYSIZE(tszKey), FALSE);

                if (0 == StrCmp(tszKey, _T("Error")))
                {
                    DEBUGMSG("GetSelfUpdateUrl() call to LookupLocaleString() failed.");
                    hr = E_FAIL;
                    goto lFinish;
                }

                if (!MyGetPrivateProfileString(
                        ptszWalk,
                        tszKey,
                        tszValue,
                        ARRAYSIZE(tszValue),
                        pszIdentTxt,INIVALUE_NOTFOUND))
                {
                    hr = E_FAIL;
                    goto lFinish;
                }
                if (0 == StrCmp(tszValue, INIVALUE_NOTFOUND))
                {
                    LPTSTR ptszDash = StrChr(tszKey, _T('-'));

                    if (NULL != ptszDash)
                    {
                        *ptszDash = _T('\0');
                        if (!MyGetPrivateProfileString(
                                ptszWalk,
                                tszKey,
                                tszValue,
                                ARRAYSIZE(tszValue),
                                pszIdentTxt))
                        {
                            hr = E_FAIL;
                            goto lFinish;
                        }
                    }
                    else
                    {
                        tszValue[0] = _T('\0');
                    }
                }
            }
            else
            {
                LOG_Internet(_T("Found Unrecognized Token in SelfUpdate Structure String: Token was: %s"), ptszWalk);
                tszValue[0] = _T('\0'); // ignore the unrecognized token
            }
        }

        if (_T('\0') != tszValue[0])
        {
            LPCTSTR ptszMuiCopy;
            
            if (FAILED(hr = StringCchCatEx(pszSelfUpdateUrl, cchSelfUpdateUrl, tszValue, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                goto lFinish;

            if (fLangField)
                ptszMuiCopy = MUI_WEBSUBPATH;
            else
                ptszMuiCopy = tszValue;

            if (FAILED(hr = StringCchCatEx(pszMuiUpdateUrl, cchMuiUpdateUrl, ptszMuiCopy, NULL, NULL, MISTSAFE_STRING_FLAGS)))
                goto lFinish;
        }

        if (NULL == ptszDelim)
        {
            break;
        }

        ptszWalk = ptszDelim + 1; // skip the previous token, and go to the next one in the string.
        *ptszDelim = TCHAR_SCTRUCTURE_DELIMITER;
    }

    DEBUGMSG("GetSelfUpdateUrl() Self Update URL is %S", pszSelfUpdateUrl);
    DEBUGMSG("GetSelfUpdateUrl() MUI Update URL is %S", pszMuiUpdateUrl);
    hr = S_OK;

lFinish:
    if (FAILED(hr))
    {
        if (cchMuiUpdateUrl > 0)
            *pszMuiUpdateUrl = _T('\0');
        if (cchSelfUpdateUrl > 0)
            *pszSelfUpdateUrl = _T('\0');
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// CheckForUpdatedComponents
//
////////////////////////////////////////////////////////////////////////////////////////

HRESULT CheckForUpdatedComponents(BOOL *pfInstalledWUAUENG)
{
    HRESULT     hr;
    LPCTSTR     ptszIdentServerUrl = NULL;
    LPTSTR      ptszSelfUpdateUrl = NULL;
    LPTSTR      ptszMuiUpdateUrl = NULL;

    if (NULL != (ptszSelfUpdateUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) &&
        NULL != (ptszMuiUpdateUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) &&
        NULL != (ptszIdentServerUrl = gpState->GetIdentServerURL()))
    {
        TCHAR   szFileCacheDir[MAX_PATH+1];


        if ( FAILED(hr = MakeTempDownloadDir(szFileCacheDir, ARRAYSIZE(szFileCacheDir))) ||
             !CleanFileCache(szFileCacheDir) )
        {
            DEBUGMSG("Couldn't fully clean file cache %S", szFileCacheDir);
		    hr = FAILED(hr) ? hr : E_FAIL;
		    goto done;
        }

        BOOL fInCorpWU = gpState->fInCorpWU();

        if (IsConnected(ptszIdentServerUrl, !fInCorpWU))
        {
            DWORD dwFlags = 0;

            if (fInCorpWU)
            {
                dwFlags |= WUDF_DONTALLOWPROXY;
            }

            if (SUCCEEDED(hr = DownloadIUIdent(
                                    ghServiceFinished,
                                    ptszIdentServerUrl,
                                    szFileCacheDir,
                                    dwFlags)))
            {
                TCHAR   tszIdentTxt[MAX_PATH];

                gPingStatus.ReadLiveServerUrlFromIdent();

                hr = PathCchCombine(tszIdentTxt, ARRAYSIZE(tszIdentTxt), 
                                    szFileCacheDir, IDENT_TXT);
                if (FAILED(hr))
                    goto done;

                if (SUCCEEDED(hr = GetSelfUpdateUrl(
                                        _T("AU"),
                                        gpState->GetSelfUpdateServerURLOverride(),
                                        tszIdentTxt,
                                        ptszSelfUpdateUrl,
                                        INTERNET_MAX_URL_LENGTH,
                                        ptszMuiUpdateUrl,
                                        INTERNET_MAX_URL_LENGTH)) &&
                    SUCCEEDED(hr = DownloadCab(
                                        ghServiceFinished,
                                        WUAUCOMP_CAB,
                                        ptszSelfUpdateUrl,
                                        szFileCacheDir,
                                        dwFlags)))
                {
                    TCHAR szWuaucompCif[MAX_PATH+1];

                    if (SUCCEEDED(hr = PathCchCombine(szWuaucompCif, ARRAYSIZE(szWuaucompCif), szFileCacheDir, WUAUCOMP_CIF)))
                    {
                        // install any updated components
                        hr = InstallUpdatedComponents(
                                     ptszSelfUpdateUrl,
                                     ptszMuiUpdateUrl,
                                     tszIdentTxt,
                                     szFileCacheDir,
                                     szWuaucompCif,
                                     pfInstalledWUAUENG);
#ifdef DBG
                        if (FAILED(hr))
                        {
                            DEBUGMSG("InstallUpdatedComponents failed");
                        }
#endif
                    }
                }
            }
        }
        else
        {
            DEBUGMSG("SelfUpdate: No connection found.");
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

done:
	SafeFree(ptszSelfUpdateUrl);
	SafeFree(ptszMuiUpdateUrl);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// SfcMoveFileEx
//
//////////////////////////////////////////////////////////////////////////////////////////

BOOL SfcMoveFileEx( IN LPCTSTR lpExistingFileName,
                    IN LPCTSTR lpNewFileName,
                    IN LPCTSTR lpSfcProtectedFile,
                    IN HANDLE SfcRpcHandle)
{
    BOOL fRet = TRUE;

    if ( SfcIsFileProtected(SfcRpcHandle, lpSfcProtectedFile) &&
         (ERROR_SUCCESS != SfcFileException(SfcRpcHandle,
                                            lpSfcProtectedFile,
                                            SFC_ACTION_RENAMED_OLD_NAME)) )
    {
        fRet = FALSE;
        goto done;
    }

    fRet = MoveFileEx(lpExistingFileName, lpNewFileName, MOVEFILE_REPLACE_EXISTING);

done:
    if ( !fRet )
    {
        DEBUGMSG("Could not rename %S --> %S", lpExistingFileName, lpNewFileName);
    }

    return fRet;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// Function BuildPaths()
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT BuildPaths(AU_FILEINCAB *paufic, LPCTSTR pszFileName, LPCTSTR pszBasePath, LPCTSTR pszExtractBase, 
                    AU_LANG *paul)
{
    HRESULT hr = S_OK;

    if (paufic == NULL || pszFileName == NULL || pszExtractBase == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (pszBasePath != NULL)
    {
        // build the full file path
        hr = PathCchCombine(paufic->szFilePath, ARRAYSIZE(paufic->szFilePath), 
                            pszBasePath, pszFileName);
        if (FAILED(hr))
            goto done;

        paufic->fFileExists = fFileExists(paufic->szFilePath);
    }

    // file path we'll temporarily copy the original file to
    if (ReplaceFileExtension(paufic->szFilePath, _T(".bak"), 
                             paufic->szBackupFilePath, 
                             ARRAYSIZE(paufic->szBackupFilePath)) == FALSE) 
    {
        hr = E_FAIL;
        goto done;
    }

    // file path we'll temporarily expand the new file to
    if (ReplaceFileExtension(paufic->szFilePath, _T(".new"),
                             paufic->szNewFilePath,
                             ARRAYSIZE(paufic->szNewFilePath)) == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }

    if (ReplaceFileInPath(pszExtractBase, pszFileName, 
                          paufic->szExtractFilePath, 
                          ARRAYSIZE(paufic->szExtractFilePath)) == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }

    // if we are processing a language file, append the language name to
    //  the end of the extraction path to avoid collisions in this directory. 
    if (paul != NULL)
    {
        hr = StringCchCatEx(paufic->szExtractFilePath, 
                            ARRAYSIZE(paufic->szExtractFilePath),
                            paul->szAUName,
                            NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;
    }


done:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function ProcessFile()
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFile(AU_COMPONENT *paucParent, AU_COMPONENT *paucCurr, LPCTSTR pszBasePath, 
                    AU_LANG *paul, LPCTSTR pszCif)
{
    USES_IU_CONVERSION;

    HRESULT hr = NOERROR;
    LPCTSTR pszIniFileVerToUse;
    DWORD   dwExistingMS = 0, dwExistingLS = 0;
    TCHAR   szValue[64], szIniFileVer[32];
    BOOL    fRet;
    int     cch, cchLang;

    // validate params
    if (paucCurr == NULL || pszBasePath == NULL || pszCif == NULL ||
        ((paucParent == NULL) != (paul == NULL)))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // build the full file path
    hr = PathCchCombine(paucCurr->szFilePath, ARRAYSIZE(paucCurr->szFilePath), 
                        pszBasePath, paucCurr->szFileName);
    if (FAILED(hr))
        goto done;


    // get the version of the file we should have
    if (paul != NULL)
    {
        hr = StringCchPrintfEx(szIniFileVer, ARRAYSIZE(szIniFileVer), 
                               NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("%s%s"), AU_KEY_FILE_VERSION, paul->szAUName);
        if (FAILED(hr))
            goto done;
        
        pszIniFileVerToUse = szIniFileVer;
    }
    else
    {
        pszIniFileVerToUse = AU_KEY_FILE_VERSION;
    }
    
    fRet = MyGetPrivateProfileString(paucCurr->pszSectionName,
                                     pszIniFileVerToUse,
                                     szValue, ARRAYSIZE(szValue),
                                     pszCif);
    if (fRet)
    {
        fRet = fConvertVersionStrToDwords(szValue, &paucCurr->dwUpdateMS, 
                                          &paucCurr->dwUpdateLS);
    }
    // if we couldn't find the version string in the ini file, get it from the
    //  parent AU_COMPONENT
    else if (paucParent != NULL)
    {
        paucCurr->dwUpdateMS = paucParent->dwUpdateMS;
        paucCurr->dwUpdateLS = paucParent->dwUpdateLS;
        fRet = TRUE;
    }

    if (fRet == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }

    // see if we need to replace the file
    paucCurr->fFileExists = fFileExists(paucCurr->szFilePath);
    if (paucCurr->fFileExists)
    {   
        LPSTR pszPathForVer;
        
        // if the file exists, then check for the version
        pszPathForVer = T2A(paucCurr->szFilePath);
        if (pszPathForVer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // this function will never return a failure code.  Intstead, check if 
        //  both return values are 0
        hr = GetVersionFromFileEx(pszPathForVer, &dwExistingMS, &dwExistingLS, 
                                  TRUE);
        if (FAILED(hr) || (dwExistingMS == 0 && dwExistingLS == 0))
        {
            hr = E_FAIL;
            goto done;
        }

        paucCurr->fDoUpgrade = fNewerFile(paucCurr->dwUpdateMS, 
                                          paucCurr->dwUpdateLS,
                                          dwExistingMS, 
                                          dwExistingLS);
    }
    else
    {
        // if the file doesn't exist, obviously gotta replace it
        paucCurr->fDoUpgrade = TRUE;
    }

    // if we don't need to update the file and it's not a parent file with 
    //  resources, then can just bail at this point.  
    if (paucCurr->fDoUpgrade == FALSE)
    {
        if (paul != NULL || 
            (paul == NULL && paucCurr->fNeedToCheckMui == FALSE))
        {
            hr = S_FALSE;
            goto done;
        }
    }
    else
    {
        DEBUGMSG("PASS 1 -- newer file in section %S", paucCurr->pszSectionName);
    }         

    // get the cab and inf name. For non-MUI files, we fetch this out of the ini.
    if (paul == NULL)
    {
        if (MyGetPrivateProfileString(paucCurr->pszSectionName,
                                      AU_KEY_CAB_NAME,
                                      paucCurr->szCabName,
                                      ARRAYSIZE(paucCurr->szCabName),
                                      pszCif) == FALSE)
        {
            hr = E_FAIL;
            goto done;
        }

        // if there is no inf, "" is value of field, so we're ok ignoring a  
        //  failure here
        MyGetPrivateProfileString(paucCurr->pszSectionName,
                                  AU_KEY_INF_NAME,
                                  paucCurr->szInfName,
                                  ARRAYSIZE(paucCurr->szInfName),
                                  pszCif);
    }
    // for MUI files, we base it on the name of the cab from the parent file.
    else
    {
        LPTSTR  pszExt;
        DWORD   cchExt, cchName;
        
        // make sure the buffer is big enuf
        cch = lstrlen(paucParent->szCabName);
        cchLang = lstrlen(paul->szAUName);
        if (cch + cchLang >= ARRAYSIZE(paucCurr->szCabName))
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto done;
        }
        
        hr = StringCchCopyEx(paucCurr->szCabName, ARRAYSIZE(paucCurr->szCabName),
                             paucParent->szCabName, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;

        // paucCurr->szCabName 
        for (pszExt = paucCurr->szCabName + cch, cchExt = 0;
             pszExt > paucCurr->szCabName && *pszExt != _T('\\') && *pszExt != _T('.');
             pszExt--, cchExt++);

        // if we hit a backslash or the beginning of the string, then move the
        //  extension pointer to the NULL terminator.
        if (*pszExt == _T('\\') || pszExt <= paucCurr->szCabName)
        {
            pszExt = paucCurr->szCabName + cch;
            cchExt = 0;
        }

        cchName = (DWORD)(pszExt - paucCurr->szCabName);

        // append the language to where the extension (if any) currently exists
        hr = StringCchCopyEx(pszExt, ARRAYSIZE(paucCurr->szCabName) - cchName, 
                             paul->szAUName,
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto done;

        // if there is an extension, copy it over from the original string in
        //  the parent AU_COMPONENT
        if (cchExt > 0)
        {
            hr = StringCchCopyEx(&paucCurr->szCabName[cchName + cchLang],
                                 ARRAYSIZE(paucCurr->szCabName) - cchName - cchLang,
                                 &paucParent->szCabName[cchName],
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
                goto done;
                     
        }
    }
    
    if (ReplaceFileInPath(pszCif, paucCurr->szCabName, 
                          paucCurr->szCabPath, 
                          ARRAYSIZE(paucCurr->szCabPath)) == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = BuildPaths(paucCurr, paucCurr->szFileName, NULL, pszCif, paul);
    if (FAILED(hr))
        goto done;
    
done:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// Function InstallUpdatedComponents()
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT InstallUpdatedComponents(LPCTSTR pszSelfUpdateUrl,
                                 LPCTSTR pszMuiUpdateUrl,
                                 LPCTSTR pszIdentTxt,
                                 LPCTSTR pszFileCacheDir,
                                 LPCTSTR pszCif,
                                 BOOL *pfInstalledWUAUENG)
{
    USES_IU_CONVERSION;

    AU_COMPONENT    *paucRoot = NULL;
    AU_COMPONENT    *paucCurr = NULL;
    AU_COMPONENT    *paucParent = NULL;
    AU_COMPONENT    *paucMui = NULL;
    AU_FILEINCAB    *paufic = NULL;

    
    HRESULT         hr = S_OK;
    HANDLE          SfcRpcHandle = NULL;
    LPTSTR          pszSection = NULL;
    TCHAR           szSectionNames[1024];
    TCHAR           szSysDir[MAX_PATH + 1];
    TCHAR           szSrcPath[MAX_PATH + 1];
    TCHAR           szHelpFile[_MAX_FNAME + 1];
    DWORD           cchSectionNames, cch;
    BOOL            fFailedInstall = FALSE;

    // MUI stuff
    AU_LANGLIST     aull;
    DWORD           cchMuiDir = 0, cchMuiDirAvail = 0;
    DWORD           cchHelpMuiDir = 0, cchHelpMuiDirAvail = 0;
    TCHAR           szMuiDir[MAX_PATH + 1];
    TCHAR           szHelpMuiDir[MAX_PATH + 1];
    
    ZeroMemory(&aull, sizeof(aull));
    aull.pszIdentFile = pszIdentTxt;
    szMuiDir[0] = _T('\0');
    szHelpMuiDir[0] = _T('\0');
    
    *pfInstalledWUAUENG = FALSE;
    SfcRpcHandle = SfcConnectToServer(NULL);
    if (NULL == SfcRpcHandle)
    {
        hr = E_FAIL;
        goto done;
    }

    // determine how many components there are to update.
    cchSectionNames = GetPrivateProfileSectionNames(szSectionNames, 
                                                    ARRAYSIZE(szSectionNames),
                                                    pszCif);
    if ((ARRAYSIZE(szSectionNames) - 2) == cchSectionNames)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto done;
    }
    
    cchMuiDir = ARRAYSIZE(szMuiDir);
    cchHelpMuiDir = ARRAYSIZE(szHelpMuiDir);
    hr = GetMuiLangList(&aull, szMuiDir, &cchMuiDir, szHelpMuiDir, &cchHelpMuiDir);
    if (FAILED(hr))
        goto done;

    cchMuiDirAvail = ARRAYSIZE(szMuiDir) - cchMuiDir;
    cchHelpMuiDirAvail = ARRAYSIZE(szHelpMuiDir) - cchHelpMuiDir;

    cch = GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir));
    if (cch == 0 || cch >= ARRAYSIZE(szSysDir))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // PASS 1: figure out which files to upgrade
    for (pszSection = szSectionNames; 
         *pszSection != _T('\0'); 
         pszSection += lstrlen(pszSection) + 1)
    {
        szHelpFile[0] = _T('\0');
        
        // if we didn't need to upgrade the parent file from the previous pass
        //  then we don't need to alloc a new blob- just reuse the one from the
        //  previous pass.  To signal this, we'll set paucParent to NULL if we
        //  add it to the linked list- note this covers us for the first time 
        //  thru the loop cuz we initialize paucParent to NULL.
        if (paucParent == NULL)
        {
            paucParent = (AU_COMPONENT *)malloc(sizeof(AU_COMPONENT));
            if (paucParent == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }
        ZeroMemory(paucParent, sizeof(AU_COMPONENT));
        paucParent->fMuiFile = FALSE;

        DEBUGMSG("PASS 1 -- section %S", pszSection);
        paucParent->pszSectionName = pszSection;
        if (MyGetPrivateProfileString(paucParent->pszSectionName,
                                      AU_KEY_FILE_NAME,
                                      paucParent->szFileName,
                                      ARRAYSIZE(paucParent->szFileName),
                                      pszCif) == FALSE)
        {
            hr = E_FAIL;
            goto done;
        }

        if (aull.cLangs > 0)
        {
            UINT uiHasResources;
            
            // see if we need to test for MUI file updates
            uiHasResources = GetPrivateProfileInt(paucParent->pszSectionName,
                                                  AU_KEY_RESMOD_NAME,
                                                  0,
                                                  pszCif);

            // if we do have resources, then check if we also have a helpfile
            if (uiHasResources == 1)
            {
                paucParent->fNeedToCheckMui = TRUE;

                if (MyGetPrivateProfileString(paucParent->pszSectionName,
                                              AU_KEY_HELPFILE,
                                              szHelpFile, ARRAYSIZE(szHelpFile),
                                              pszCif) == FALSE)
                {
                    szHelpFile[0] = _T('\0');
                }
            }
            else
            {
                paucParent->fNeedToCheckMui = FALSE;
            }
        }
        else
        {
            paucParent->fNeedToCheckMui = FALSE;
        }

        hr = ProcessFile(NULL, paucParent, szSysDir, NULL, pszCif);
        if (FAILED(hr))
            goto done;

        if (paucParent->fNeedToCheckMui)
        {
            DWORD   iLang;
            DWORD   cchParentFile;

            cchParentFile = lstrlen(paucParent->szFileName);
            if (cchParentFile + ARRAYSIZE(MUI_EXT) > ARRAYSIZE(paucParent->szFileName))
            {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                goto done;
            }


            for (iLang = 0; iLang < aull.cLangs; iLang++)
            {
                // if we didn't need to upgrade the file from the previous
                //  pass then we don't need to alloc a new blob- just reuse 
                //  the one from the previous pass. 
                if (paucMui == NULL)
                {
                    paucMui = (AU_COMPONENT *)malloc(sizeof(AU_COMPONENT));
                    if (paucMui == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }
                }
                ZeroMemory(paucMui, sizeof(AU_COMPONENT));
                paucMui->pszSectionName = paucParent->pszSectionName;
                paucMui->fMuiFile       = TRUE;

                // ProcessFile does not expect a trailing backslash, so be sure 
                //  not to add one.  Note that we've checked the size of the 
                //  buffer against the largest possible string it will contain
                //  above, so this should not fail.
                // The directory is build with the MUI langauge name (4 hex chars)
                hr = StringCchCopyEx(&szMuiDir[cchMuiDir], cchMuiDirAvail,
                                     aull.rgpaulLangs[iLang]->szMuiName, 
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;

                // the filename for a language is the same as the parent file with
                //  a ".mui" added to the end
                hr = StringCchCopyEx(paucMui->szFileName, ARRAYSIZE(paucMui->szFileName),
                                     paucParent->szFileName,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;
                
                hr = StringCchCopyEx(&paucMui->szFileName[cchParentFile],
                                     ARRAYSIZE(paucMui->szFileName) - cchParentFile,
                                     MUI_EXT,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                    goto done;

                hr = ProcessFile(paucParent, paucMui, 
                                 szMuiDir,
                                 aull.rgpaulLangs[iLang],
                                 pszCif);
                if (FAILED(hr))
                    goto done;

                // Clean up for the next language
                szMuiDir[cchMuiDir] = _T('\0');

                // don't need to update the file 
                if (paucMui->fDoUpgrade == FALSE)
                    continue;

                if (szHelpFile[0] != _T('\0'))
                {
                    paucMui->pNextFileInCab = (AU_FILEINCAB *)malloc(sizeof(AU_FILEINCAB));
                    if (paucMui->pNextFileInCab == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }
                    ZeroMemory(paucMui->pNextFileInCab, sizeof(AU_FILEINCAB));

                    hr = StringCchCopyEx(&szHelpMuiDir[cchHelpMuiDir], cchHelpMuiDirAvail,
                                         aull.rgpaulLangs[iLang]->szMuiName, 
                                         NULL, NULL, MISTSAFE_STRING_FLAGS);
                    if (FAILED(hr))
                        goto done;
                    
                    hr = BuildPaths(paucMui->pNextFileInCab, 
                                    szHelpFile, szHelpMuiDir, 
                                    pszCif, 
                                    aull.rgpaulLangs[iLang]);
                    if (FAILED(hr))
                        goto done;
                }

                // we do need to update the file, so add it to our list of files
                //  to update
                paucMui->pNext = paucRoot;
                paucRoot       = paucMui;
                paucMui        = NULL;
            }
        }

        // if we need to update the parent file, add it to our list of files to
        //  update
        if (paucParent->fDoUpgrade)
        {
            paucParent->pNext = paucRoot;
            paucRoot          = paucParent;
            paucParent        = NULL;
        }

    }

    // short cut the rest of the function if we have no work to do
    hr = S_OK;
    if (paucRoot == NULL)
        goto done;

    // PASS 2: bring down the required cabs
    DWORD dwFlags = 0;

    if (gpState->fInCorpWU())
    {
        dwFlags |= WUDF_DONTALLOWPROXY;
    }

    for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
    {   
        LPCTSTR pszDownloadUrl;

        pszDownloadUrl = (paucCurr->fMuiFile) ? pszMuiUpdateUrl : pszSelfUpdateUrl;
        
        DEBUGMSG("PASS 2 -- downloading %S", paucCurr->szCabName);

        // We have to install so bring down the full cab
        hr = DownloadCab(ghServiceFinished,
                         paucCurr->szCabName,
                         pszDownloadUrl,
                         pszFileCacheDir,
                         dwFlags);
        if (FAILED(hr))
        {
            DEBUGMSG("Failed to download %S (%#lx)", paucCurr->szCabName, hr);
            goto done;
        }

        //Verify that the extracted file is a binary and it's subsystem matches that of the OS
        if (FAILED(hr = IsBinaryCompatible(paucCurr->szExtractFilePath)))
        {
            DEBUGMSG("%S is not a valid binary file (error %#lx)", paucCurr->szExtractFilePath, hr);
            goto done;
        }

        // Check version number against cif
        DWORD dwNewMS, dwNewLS;

        LPSTR pszTmp;
        pszTmp = T2A(paucCurr->szExtractFilePath);
        if (pszTmp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // this function will never return a failure code.  Intstead, check if 
        //  both return values are 0
        hr = GetVersionFromFileEx(pszTmp, &dwNewMS, &dwNewLS, TRUE /* get version */);
        if (FAILED(hr) || (dwNewMS == 0 && dwNewLS == 0))
        {
            DEBUGMSG("Failed to get version info from %S (%#lx)", paucCurr->szExtractFilePath, hr);
            goto done;
        }

        if (paucCurr->dwUpdateMS != dwNewMS || 
            paucCurr->dwUpdateLS != dwNewLS)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSTALL_PACKAGE_VERSION);
            DEBUGMSG("Version mismatch for %S - %d.%d.%d.%d vs %d.%d.%d.%d",
                paucCurr->szExtractFilePath,
                HIWORD(paucCurr->dwUpdateMS),
                LOWORD(paucCurr->dwUpdateMS),
                HIWORD(paucCurr->dwUpdateLS),
                LOWORD(paucCurr->dwUpdateLS),
                HIWORD(dwNewMS),
                LOWORD(dwNewMS),
                HIWORD(dwNewLS),
                LOWORD(dwNewLS));
            goto done;
        }
    }

    hr = StringCchCopyEx(szSrcPath, ARRAYSIZE(szSrcPath), pszCif,
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto done;
    
    PathRemoveFileSpec(szSrcPath);
    
    // PASS 3: Copy files to *.new in destination directory.
    for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
    {
        if (FAILED(hr = vAU_W2A(paucCurr->szCabPath, 
                    paucCurr->a_szCabPath, 
                    sizeof(paucCurr->a_szCabPath))))
        {
            fFailedInstall = TRUE;
            goto done;
        }

        // copy all the files to their new locations
        for (paufic = paucCurr; paufic != NULL; paufic = paufic->pNextFileInCab)
        {
            DEBUGMSG("PASS 3 -- copying %S --> %S", 
                     paufic->szExtractFilePath, 
                     paufic->szNewFilePath);
            

            if ( !CopyFile(paufic->szExtractFilePath, paufic->szNewFilePath, FALSE) )
            {
                fFailedInstall = TRUE;
                hr = E_FAIL;
                goto done;
            }
        }

        // this comparison is sufficient because we don't care if we replaced a 
        //  MUI lang pack for wuaueng.dll.  The reason is that the service runs
        //  as local system, which always uses the native language (and the 
        //  service doesn't pop up UI anyway)
        // we do, however, need to check for a winhttp update
        if (StrCmpI(WUAUENG_DLL, paucCurr->szFileName) == 0 ||
            StrCmpI(c_szWinHttpDll, paucCurr->szFileName) == 0)
        {
            *pfInstalledWUAUENG = TRUE;
        }
    }

    // PASS 4: Move the <file>.new into its proper location
    for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
    {
        // copy all the files to their new locations
        for (paufic = paucCurr; paufic != NULL; paufic = paufic->pNextFileInCab)
        {
            if ( paufic->fFileExists )
            {
                DEBUGMSG("PASS 4 -- renaming %S --> %S", paufic->szFilePath, paufic->szBackupFilePath);
                if ( !SfcMoveFileEx(paufic->szFilePath, paufic->szBackupFilePath, 
                                    paufic->szFilePath, SfcRpcHandle) )
                {
                    fFailedInstall = TRUE;
                    hr = E_FAIL;
                    goto done;
                }
                paufic->fCreatedBackup = TRUE;
            }
            
            DEBUGMSG("PASS 4 -- renaming %S --> %S", paufic->szNewFilePath, paufic->szFilePath);
            if (!MoveFileEx(paufic->szNewFilePath, paufic->szFilePath, MOVEFILE_REPLACE_EXISTING))
            {
                fFailedInstall = TRUE;
                hr = E_FAIL;
                goto done;
            }
        }
    }

    // PASS 5: Run any .inf file.
    for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
    {
        if (paucCurr->szInfName[0] != _T('\0'))
        {
            DEBUGMSG("PASS 5A -- executing inf %S", paucCurr->szInfName);
            CABINFO cabinfo;
            HRESULT hr2;

            cabinfo.pszCab = paucCurr->a_szCabPath;
            cabinfo.pszInf = paucCurr->a_szInfName;
            if (FAILED( hr2 = vAU_W2A(paucCurr->szInfName, paucCurr->a_szInfName, sizeof(paucCurr->a_szInfName)))
               || FAILED(hr2 = vAU_W2A(szSrcPath, cabinfo.szSrcPath, sizeof(cabinfo.szSrcPath))))
            {
                DEBUGMSG("vAU_W2A failed: %#lx", hr2);
                if (SUCCEEDED(hr))
                {
                    hr = hr2;
                    fFailedInstall = TRUE;
                }
                // don't delete the backup file.  Need to restore it afterwards.
                continue;
            }
            
            
            cabinfo.pszSection = "DefaultInstall";
            cabinfo.dwFlags = ALINF_QUIET;
            if ( FAILED(hr2 = ExecuteCab(NULL, &cabinfo, NULL)) )
            {
                DEBUGMSG("ExecuteCab failed on %s (%#lx)", paucCurr->a_szInfName, hr2);
                if (SUCCEEDED(hr))
                {
                    hr = hr2;
                    fFailedInstall = TRUE;
                }
                // don't delete the backup file.  Need to restore it afterwards.
                continue;
            }
        }

        for (paufic = paucCurr; paufic != NULL; paufic = paufic->pNextFileInCab)
        {

            // delete the backup file corresponding to the .inf which was successfully installed
            if (paufic->fCreatedBackup &&
                StrCmpI(WUAUENG_DLL, paucCurr->szFileName) != 0)
            {
                DEBUGMSG("PASS 5B - deleting bak file %S", paufic->szBackupFilePath);
                if ( DeleteFile(paufic->szBackupFilePath) )
                {
                    paufic->fCreatedBackup = FALSE;
                }
#ifdef DBG
                else
                {
                    DEBUGMSG("Could not delete %S (error %d)", paufic->szBackupFilePath, GetLastError());
                }
#endif
            }
        }
    }
    
done:
    // if we failed an install, revert all the prior installs
    if ( fFailedInstall )
    {
        for (paucCurr = paucRoot; paucCurr != NULL; paucCurr = paucCurr->pNext)
        {
            for(paufic = paucCurr; paufic != NULL; paufic = paufic->pNextFileInCab)
            {
                if (paufic->fCreatedBackup)
                {
                    DEBUGMSG("Reverting %S --> %S", paufic->szBackupFilePath, paufic->szFilePath);
                    MoveFileEx(paufic->szBackupFilePath, paufic->szFilePath, MOVEFILE_REPLACE_EXISTING);
                }
            }
        }
    }

    if (paucParent != NULL)
        free(paucParent);
    if (paucMui != NULL)
    {
        while (paucMui->pNextFileInCab != NULL)
        {
            paufic = paucMui->pNextFileInCab;
            paucMui->pNextFileInCab = paucMui->pNextFileInCab->pNextFileInCab;
            free(paufic);
        }
        free(paucMui);
    }

    // cleanup the linked list of files
    while(paucRoot != NULL)
    {
        paucCurr = paucRoot;
        paucRoot = paucCurr->pNext;
        while (paucCurr->pNextFileInCab != NULL)
        {
            paufic = paucCurr->pNextFileInCab;
            paucCurr->pNextFileInCab = paucCurr->pNextFileInCab->pNextFileInCab;
            free(paufic);
        }
        free(paucCurr);
    }

    // cleanup the MUI stuff
    CleanupMuiLangList(&aull);

    if ( NULL != SfcRpcHandle )
    {
         SfcClose(SfcRpcHandle);
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
// fConvertDotVersionStrToDwords
//
////////////////////////////////////////////////////////////////////////////
BOOL fConvertVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwMS, LPDWORD pdwLS)
{
    DWORD   grVerFields[4] = {0,0,0,0};
    TCHAR   *pch = pszVer;
    int     i;

    // _ttol will stop when it hits a non-numeric character, so we're 
    //  safe calling it this way
    grVerFields[0] = _ttol(pch);

    for (i = 1; i < 4; i++)
    {
        while (*pch != _T('\0') && _istdigit(*pch))
            pch++;

        if (*pch == _T('\0'))
            break;
        pch++;

        // _ttol will stop when it hits a non-numeric character, so we're 
        //  safe calling it this way
        grVerFields[i] = _ttol(pch);
   }

   *pdwMS = (grVerFields[0] << 16) + grVerFields[1];
   *pdwLS = (grVerFields[2] << 16) + grVerFields[3];

   return true;
}

////////////////////////////////////////////////////////////////////////////
//
// MyGetPrivateProfileString
//
// Same as normal call but if buffer is too small or default string is returned
// then function returns FALSE.
////////////////////////////////////////////////////////////////////////////
BOOL MyGetPrivateProfileString(	IN LPCTSTR lpAppName,
								IN LPCTSTR lpKeyName,
								OUT LPTSTR lpReturnedString,
								IN DWORD nSize,
								IN LPCTSTR lpFileName, 
								IN LPCTSTR lpDefault)
{
    BOOL fRet = TRUE;


	if (NULL == lpAppName || NULL == lpKeyName || NULL == lpDefault || NULL == lpReturnedString)
	{
		return FALSE;
	}
	DWORD dwRet = GetPrivateProfileString(lpAppName,
										  lpKeyName,
										  lpDefault,
										  lpReturnedString,
										  nSize,
										  lpFileName);

    if ( ((nSize - 1) == dwRet) || (_T('\0') == *lpReturnedString) )
    {
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\register.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       register.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"
#include "service.h"

#pragma hdrstop

const TCHAR AU_SERVICE_NAME[]   = _T("wuauserv");
const TCHAR PING_STATUS_FILE[]  = _T("pingstatus.dat");

const TCHAR SVCHOST_CMDLINE_NETSVCS[]      = _T("%systemroot%\\system32\\svchost.exe -k netsvcs");
const TCHAR SVCHOST_CMDLINE_STANDALONE[]   = _T("%systemroot%\\system32\\svchost.exe -k wugroup");


//=======================================================================
//  CallRegInstall
//=======================================================================
inline HRESULT CallRegInstall(HMODULE hModule, LPCSTR pszSection)
{
    HRESULT hr = RegInstall(hModule, pszSection, NULL);
	if (FAILED(hr))
	{
		DEBUGMSG("CallRegInstall() call RegInstall failed %#lx", hr);
	}
    return hr;
}


//caller is responsible for closing hSCM
//Stopping service not needed during setup cuz service won't start in GUI setup mode
//Needed for command line dll registering
void  StopNDeleteAUService(SC_HANDLE hSCM)
{
		SC_HANDLE hService = OpenService(hSCM, AU_SERVICE_NAME, SERVICE_ALL_ACCESS);
		if(hService != NULL)
		{
			SERVICE_STATUS wuauservStatus;
			DEBUGMSG("Old wuauserv service found, deleting");
			
			if (0 == ControlService(hService, SERVICE_CONTROL_STOP, &wuauservStatus))
			{
				DEBUGMSG("StopNDeleteAUService() fails to stop wuauserv with error %d", GetLastError());
			}
			else
			{
				DEBUGMSG("wuauserv successfully stopped");
			}
			
			if (0 == DeleteService(hService))
			{
				DEBUGMSG("StopNDeleteAUService() could not delete wuauserv with error %d", GetLastError());
			}
			else
			{
				DEBUGMSG("wuauserv service successfully deleted");
			}
			CloseServiceHandle(hService);
		}
		else
		{
			DEBUGMSG("No old wuauserv service found");
		}
}


/////////////////////////////////////////////////////////////////////////
// Setup utility function for debugging only
// uncomment for testing
/////////////////////////////////////////////////////////////////////////
/*
void AUSetup::mi_DumpWUDir()
{
	WIN32_FIND_DATA fd;
	HANDLE hFindFile;
	BOOL fMoreFiles = FALSE;
	TCHAR tszFileName[MAX_PATH+1];
	TCHAR tszWUDirPath[MAX_PATH+1];

	if (!GetWUDirectory(tszWUDirPath) ||
		FAILED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), _T("*.*"), NULL, NULL, MISTSAFE_STRING_FLAGS))
		INVALID_HANDLE_VALUE == (hFindFile = FindFirstFile(tszFileName, &fd)))
	{
		DEBUGMSG("AUSetup::m_CleanUp() no more files found");
		goto done;
	}
	
	FindNextFile(hFindFile, &fd);				
	//"." and ".." skipped
	while (fMoreFiles = FindNextFile(hFindFile, &fd))
	{
		if (SUCCEEDED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), fd.cFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			DEBUGMSG("DumpWUDir() %S", tszFileName);
		}
	}
done:
	if (INVALID_HANDLE_VALUE != hFindFile)
	{
		FindClose(hFindFile);
	}
	return;

}
*/

const LPCTSTR AUSetup::mc_WUFilesToDelete[] =
{
	_T("*.des"),
	_T("*.inv"),
	_T("*.bkf"),
	_T("*.as"),
	_T("*.plt"),
	_T("*.bm"),
	_T("*.bin"),
	_T("*.cdm"),
	_T("*.ini"),
	_T("*.dll"),
	_T("*.gng"),
	_T("*.png"),
	_T("*.cab"),
	_T("*.jpg"),
	_T("*.gif"),
	_T("*.cif"),
	_T("*.bak"),
	_T("inventory.cat"),
	_T("catalog4.dat"),
	PING_STATUS_FILE,
	_T("ident.*"),
	_T("osdet.*"),
	_T("austate.cfg"),
	_T("inseng.w98"),
	_T("temp.inf"),
      ITEM_FILE,
      DETAILS_FILE,
#ifdef DBG      
      DETECT1_FILE,
      DETECT2_FILE,
      DETECT3_FILE ,
      INSTALLRESULTS_FILE,
      INSTALL_FILE,
      DOWNLOAD_FILE,
      DRIVER_SYSSPEC_FILE,
      NONDRIVER_SYSSPEC_FILE,
      PROVIDER_FILE,
      PRODUCT_FILE,
#endif     
     DRIVERS_FILE,
    CATALOG_FILE,
    HIDDEN_ITEMS_FILE
};

const LPCTSTR AUSetup::mc_WUDirsToDelete[] =
{
	_T("Cabs"),
	_T("RTF"),
	_T("wupd"),
    C_DOWNLD_DIR
};

void AUSetup::mi_CleanUpWUDir()
{
	TCHAR tszWUDirPath[MAX_PATH+1];

	if (!CreateWUDirectory() || FAILED(StringCchCopyEx(tszWUDirPath, ARRAYSIZE(tszWUDirPath), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		return;
	}

		
	DEBUGMSG("mi_CleanUpWUDir() Windows update directory is %S ", tszWUDirPath);

	// clean all known V3 files
	for (int i=0; i < ARRAYSIZE(mc_WUFilesToDelete); i++)
	{
		TCHAR tszFileName[MAX_PATH+1];
		if (SUCCEEDED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), mc_WUFilesToDelete[i], NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			//DEBUGMSG("AUSetup::mi_CleanUpWUDir() deleting file %S", tszFileName);
			RegExpDelFile(tszWUDirPath, mc_WUFilesToDelete[i]);
		}
		else
		{
			DEBUGMSG("AUSetup::mi_CleanUpWUDir() failed in name construction for file %d", i);
		}
	}

 	// clean all known V3 subdirectories
	for (int i =0; i< ARRAYSIZE(mc_WUDirsToDelete); i++)
	{
		TCHAR tszDirName[MAX_PATH+1];
		if (SUCCEEDED(StringCchCopyEx(tszDirName, ARRAYSIZE(tszDirName), tszWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszDirName, ARRAYSIZE(tszDirName), mc_WUDirsToDelete[i], NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			DelDir(tszDirName);
			RemoveDirectory(tszDirName);
		}
		else
		{
			DEBUGMSG("AUSetup::mi_CleanUpWUDir() failed in name construction for dir %d", i);
		}
	}	
 
	return;
}

HRESULT  AUSetup::mi_CreateAUService(BOOL fStandalone)
{
	TCHAR tServiceName[50] = _T("Automatic Updates");	
	HRESULT		hr = E_FAIL;
	const ULONG CREATESERVICE_RETRY_TIMES = 5;

	LoadString(g_hInstance, IDS_SERVICENAME, tServiceName, ARRAYSIZE(tServiceName));

    // First install the service
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	
	if(hSCM == NULL)
	{
		DEBUGMSG("Could not open SCManager, no service installed");
		goto done;
	}

	DEBUGMSG("Opened SCManager, removing any existing wuauserv service");

	StopNDeleteAUService(hSCM);
		
	DEBUGMSG("Installing new wuauserv service");

	for (int i = 0; i < CREATESERVICE_RETRY_TIMES;  i++) //retry for at most a number of times
	{
		SC_HANDLE hService = CreateService(hSCM,
			AU_SERVICE_NAME,
			tServiceName,		   
			SERVICE_ALL_ACCESS,
			SERVICE_WIN32_SHARE_PROCESS,
			SERVICE_AUTO_START,
			SERVICE_ERROR_NORMAL,
            fStandalone? SVCHOST_CMDLINE_STANDALONE : SVCHOST_CMDLINE_NETSVCS,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL);

		if(hService != NULL)
		{
			DEBUGMSG("Service installed, setting description");

			TCHAR serviceDescription[512];
			if(LoadString(g_hInstance, IDS_SERVICE_DESC, serviceDescription, ARRAYSIZE(serviceDescription)) > 0)
			{
				SERVICE_DESCRIPTION descriptionStruct;
				descriptionStruct.lpDescription = serviceDescription; //only member
				BOOL fRet = ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &descriptionStruct);
				DEBUGMSG("Setting service description %s", fRet? "Succeeded" : "Failed");
			}
			else
			{
				DEBUGMSG("Error loading description resource, no description set");
			}
			hr = S_OK;
			CloseServiceHandle(hService);
			break;
		}
		else
		{
			DWORD dwErr = GetLastError();
			// this error code is not documented in MSDN for CreateService()
			if (ERROR_SERVICE_MARKED_FOR_DELETE != dwErr)
			{
				DEBUGMSG("Error creating service with error code %d, no service installed", dwErr);
				goto done;
			}
			else
			{
				DEBUGMSG("ERROR_SERVICE_MARKED_FOR_DELETE got. Retry within 2 secs");
				Sleep(2000); //sleep 2 secs and retry
			}
		}
	} // for
	
done:
	if (NULL != hSCM) 
	{
		CloseServiceHandle(hSCM);
	}
	return hr;

}

HRESULT AUSetup::m_SetupNewAU()
{
	HRESULT hr                 = S_OK;
    BOOL    fWorkStation       = fIsPersonalOrProfessional();     // will be true for Workstation as well
    BOOL    fIsWin2K           = IsWin2K();
    BOOL    fStandaloneService = fIsWin2K;                        // if it is win2k we need to install standalone

	mi_CleanUpWUDir();
    if (FAILED(mi_CreateAUService(fStandaloneService)))
    {
        return E_FAIL;
    }

    //
    // Depending on which OS we are, choose different setup entry points.
    // For Win2K, wuauserv will be installed as a separate svchost group, wugroup.
    //
    if (fIsWin2K)
    {
        if (fWorkStation)
        {
            DEBUGMSG("m_SetupNewAU() setup win2k workstation");
            hr =  CallRegInstall(g_hInstance, "Win2KWorkStationDefaultInstall");
        }
        else
        {
            DEBUGMSG("m_SetupNewAU() setup win2k server");
            hr =  CallRegInstall(g_hInstance, "Win2KServerDefaultInstall");
        }
    }
    else
    {
        if (fWorkStation)
        {
            DEBUGMSG("m_SetupNewAU() setup workstation");
            hr =  CallRegInstall(g_hInstance, "WorkStationDefaultInstall");
        }
        else
        {
            DEBUGMSG("m_SetupNewAU() setup server");
            hr =  CallRegInstall(g_hInstance, "ServerDefaultInstall");
        }
    }

	return hr;
}

//=======================================================================
//  DllRegisterServer
//=======================================================================
STDAPI DllRegisterServer(void)
{
	AUSetup ausetup;

	return  ausetup.m_SetupNewAU();
}

//=======================================================================
//  DllUnregisterServer
//=======================================================================
STDAPI DllUnregisterServer(void)
{
	SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	
	if (NULL == hSCM)
	{
		DEBUGMSG("DllUnregisterServer() fail to open service manager: error %d", GetLastError());
		return E_FAIL;
	}
	StopNDeleteAUService(hSCM);
	return CallRegInstall(g_hInstance, "DefaultUninstall");
}

//=======================================================================
//  MSIUninstallOfCUN
//=======================================================================
void MSIUninstallOfCUN(void)
{
    DEBUGMSG("MSIUninstallOfCUN");

    typedef UINT (WINAPI * PFNMsiConfigureProduct)(LPCWSTR szProduct, int iInstallLevel, INSTALLSTATE eInstallState);
    typedef INSTALLUILEVEL (WINAPI *PFNMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND  *phWnd);
    typedef UINT (WINAPI *PFNMsiEnumClients)(LPCWSTR szComponent, DWORD iProductIndex, LPWSTR lpProductBuf);
    typedef UINT (WINAPI *PFNMsiGetProductInfo)(LPCWSTR szProduct, LPCWSTR szAttribute, LPWSTR lpValueBuf, DWORD *pcchValueBuf);
    
    PFNMsiConfigureProduct pfnMsiConfigureProduct;
    PFNMsiSetInternalUI    pfnMsiSetInternalUI;
    PFNMsiEnumClients      pfnMsiEnumClients;
    PFNMsiGetProductInfo   pfnMsiGetProductInfo;

    // component code for wuslflib.dll is constant across all localized versions of CUN
    // and can be used to determine which product version is on the machine.
    const TCHAR CUN_COMPONENT_CODE[] = _T("{2B313391-563D-46FC-876C-B95201166D11}");
    // name of product is not localized between versions (because the UI is always english)
    // and can thus be used as a safety check.
    const TCHAR CUN_PRODUCT_NAME[] = _T("Microsoft Windows Critical Update Notification");
    WCHAR szProductCode[39];
 
    
    HMODULE hMSI = LoadLibraryFromSystemDir(_T("msi.dll"));	
	
    if ( (NULL == hMSI) ||
         (NULL == (pfnMsiConfigureProduct = (PFNMsiConfigureProduct)GetProcAddress(hMSI, "MsiConfigureProductW"))) ||
         (NULL == (pfnMsiSetInternalUI =    (PFNMsiSetInternalUI)   GetProcAddress(hMSI, "MsiSetInternalUI"))) ||
         (NULL == (pfnMsiEnumClients =      (PFNMsiEnumClients)     GetProcAddress(hMSI, "MsiEnumClientsW"))) ||
         (NULL == (pfnMsiGetProductInfo =   (PFNMsiGetProductInfo)  GetProcAddress(hMSI, "MsiGetProductInfoW"))) )
	{
		DEBUGMSG("LoadLibraryFromSystemDir(msi.dll) or GetProc failed");
		goto done;
	}

    // highly unlikely that multiple clients will be installed, but just in case, enumerate
    // all MSI clients of wuslflib.dll.
    for ( int iProductIndex = 0;
          ERROR_SUCCESS == pfnMsiEnumClients(CUN_COMPONENT_CODE, iProductIndex, szProductCode);
          iProductIndex++ )
    {
        DEBUGMSG("szProductCode = %S", szProductCode);

        // verify that this product is the Windows CUN by double checking the Product Name. 
        // This string is not localized for localized versions of CUN.
        TCHAR szCurrentProductName[50];
        DWORD cchCurrentProductName = ARRAYSIZE(szCurrentProductName);

        // retrieve the product name. If the name is too long to fit in the buffer, this is obviously not CUN.
        // on error, do not attempt to uninstall the product.
        if ( (ERROR_SUCCESS == pfnMsiGetProductInfo(szProductCode, INSTALLPROPERTY_INSTALLEDPRODUCTNAME, szCurrentProductName, &cchCurrentProductName)) &&
             (0 == StrCmp(CUN_PRODUCT_NAME, szCurrentProductName)) )
        {
            // set completely silent install
            pfnMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

            DEBUGMSG("uninstall CUN");
            // uninstall the product.
            UINT uiResult = pfnMsiConfigureProduct(szProductCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_ABSENT);
            DEBUGMSG("MsiConfigureProduct = %d", uiResult);
            break;
        }
    }
done:
    if ( NULL != hMSI )
    {
        FreeLibrary(hMSI);
    }

    return;
}

inline void SafeCloseServiceHandle(SC_HANDLE h) { if ( NULL != h) { CloseServiceHandle(h); } }
inline void SafeFreeLibrary(HMODULE h) { if ( NULL != h) { FreeLibrary(h); } }

//=======================================================================
//  StartWUAUSERVService
//=======================================================================
HRESULT StartWUAUSERVService(void)
{
    DEBUGMSG("StartWUAUSERVService");
    HRESULT hr = E_FAIL;
    SC_HANDLE hService = NULL;
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if( hSCM == NULL )
    {
        DEBUGMSG("OpenSCManager failed");
        goto done;
    }

    if ( NULL == (hService = OpenService(hSCM, AU_SERVICE_NAME, SERVICE_ALL_ACCESS)) )
    {
        DEBUGMSG("OpenService failed");
        goto done;
    }

    if ( !StartService(hService, 0, NULL) )
    {
        DWORD dwRet = GetLastError();
        if ( ERROR_SERVICE_ALREADY_RUNNING != dwRet )
        {
            hr = HRESULT_FROM_WIN32(dwRet);
            DEBUGMSG("StartService failed, hr = %#lx", hr);
        }
        else
        {
            DEBUGMSG("StartService -- service already running");
        }
        goto done;
    }

    hr = S_OK;

done:
    SafeCloseServiceHandle(hService);
    SafeCloseServiceHandle(hSCM);

    return hr;
}

//=======================================================================
//  CRunSetupCommand
//=======================================================================
class CRunSetupCommand
{
public:
    CRunSetupCommand()
        : m_hAdvPack(NULL)
    {}
    ~CRunSetupCommand()
    {
        SafeFreeLibrary(m_hAdvPack);
    }
    
    HRESULT m_Init(void)
    {
        HRESULT hr = S_OK;
        
        if ( (NULL == (m_hAdvPack = LoadLibraryFromSystemDir(_T("advpack.dll")))) ||
		     (NULL == (m_pfnRunSetupCommand = (RUNSETUPCOMMAND)GetProcAddress(m_hAdvPack,
                                                                              achRUNSETUPCOMMANDFUNCTION))) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            CHAR szWinDir[MAX_PATH+1];
            if ( !GetWindowsDirectoryA(szWinDir, ARRAYSIZE(szWinDir)))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else if (SUCCEEDED(hr = PathCchCombineA(m_szInfDir, ARRAYSIZE(m_szInfDir), szWinDir, "inf")))
            {
                DEBUGMSG("inf dir is %s", m_szInfDir);
			}
        }
	
    	return hr;
    }

    HRESULT m_Run(LPCSTR pszInfFile, LPCSTR pszInfSection)
	{
        DEBUGMSG("run %s\\%s[%s]", m_szInfDir, pszInfFile, pszInfSection);

		HRESULT hr = m_pfnRunSetupCommand(NULL, 
                                          pszInfFile,
                                          pszInfSection,
                                          m_szInfDir,
                                          NULL,
                                          NULL,
                                          RSC_FLAG_INF | RSC_FLAG_NGCONV | RSC_FLAG_QUIET,
                                          NULL);
        DEBUGMSG("RunSetupCommand = %#lx", hr);
        return hr;
	}

private:
	HMODULE m_hAdvPack;
    RUNSETUPCOMMAND m_pfnRunSetupCommand;
    CHAR m_szInfDir[MAX_PATH+1];
};
	

//=======================================================================
//  DllInstall
//=======================================================================
STDAPI DllInstall(BOOL fInstall, LPCWSTR pszCmdLine)
{
    DEBUGMSG("fInstall = %s, pszCmdLine = %S", fInstall ? "TRUE" : "FALSE", (pszCmdLine == NULL) ? L"NULL" : /*const_cast<LPWSTR>*/(pszCmdLine));

    HRESULT hr = DllRegisterServer();
    DEBUGMSG("DllRegisterServer(), hr = %#lx", hr);

    if ( SUCCEEDED(hr) )
    {
        CRunSetupCommand cmd;

        //TerminateCUN();

        if ( SUCCEEDED(hr = cmd.m_Init()) &&
             //SUCCEEDED(hr = cmd.m_Run("AUBITS12.inf", "DefaultInstall")) &&
             SUCCEEDED(hr = StartWUAUSERVService()) )
        {
            MSIUninstallOfCUN();
            cmd.m_Run("AUCUN.inf", "DefaultUninstall");
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\service.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       service.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

#pragma hdrstop

SERVICE_STATUS          gMyServiceStatus; 
SERVICE_STATUS_HANDLE   ghMyServiceStatus;
HANDLE			hWorkerThread;
HANDLE			ghServiceFinished ; //= NULL;
HANDLE          ghPolicyChanged; //= NULL;
HANDLE          ghSettingsChanged;  //= NULL;
HANDLE			ghActiveAdminSession ; //= NULL;
HANDLE			ghEngineState ; //= NULL;
HANDLE			ghServiceDisabled ; //= NULL;
HANDLE			ghNotifyClient ; //= NULL;
HANDLE			ghValidateCatalog ; //= NULL;
HANDLE 			ghWorkerThreadMsgQueueCreation; //= NULL
DWORD			gdwWorkerThreadId = -1;
CLIENT_HANDLES  ghClientHandles;
CLIENT_NOTIFY_DATA	gClientNotifyData;
DWORD gdwServiceVersion = -1;


SESSION_STATUS gAdminSessions;

BOOL FEnsureValidEvent(HANDLE & hEvent, BOOL fManualState, BOOL fInitialState)
{
	hEvent = CreateEvent(NULL,					// for enable/disable
						  fManualState,		// manual reset
						  fInitialState,	// initial state
						  NULL);	// event name
	return (NULL != hEvent);	
}

void ServiceFinishNotify(void)
{
    DEBUGMSG("ServiceFinishNotify() starts");    
    if (NULL != ghMutex)
    {
        WaitForSingleObject(ghMutex, INFINITE);
        if (NULL != gpAUcatalog)
        {
            gpAUcatalog->CancelNQuit();
        }
        else
        {
            DEBUGMSG("No need to cancel catalag");
        }
        ReleaseMutex(ghMutex);
    }
    //Moving SetEvent to the end of the function since we could potentially have a deadlock if ServiceMain frees the resources (i.e. ghMutex is null) as soon as we call SetEvent
    SetEvent(ghServiceFinished);
    DEBUGMSG("ServiceFinishNotify() ends");
}

//** Returns true if the service was finished otherwise, waits dwSleepTime milliseconds
//** This function assumes that the handle hServiceFinished is actually a handle to
//** AUSERVICE_FINISHED_EVENT
BOOL FServiceFinishedOrWait(HANDLE hServiceFinished, DWORD dwSleepTime)
{
	DEBUGMSG("Entering FServiceFinishedOrWait dwSleepTime=%lu", dwSleepTime);
	DWORD dwRet = WaitForSingleObject(hServiceFinished, dwSleepTime);
	DEBUGMSG("Exiting FServiceFinishedOrWait");
	return (WAIT_OBJECT_0 == dwRet);
}



//utility function
BOOL _IsTokenAdmin(HANDLE hToken)
{
    static SID_IDENTIFIER_AUTHORITY sSystemSidAuthority = SECURITY_NT_AUTHORITY;

    BOOL    fResult = FALSE;
    PSID    pSIDLocalGroup;

    if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS, // Local Admins
                                0, 0, 0, 0, 0, 0,
                                &pSIDLocalGroup) != FALSE)
    {
        if (!CheckTokenMembership(hToken, pSIDLocalGroup, &fResult))
        {
        	DEBUGMSG("Fail to check token membership with error %d", GetLastError());
            fResult = FALSE;
        }

        FreeSid(pSIDLocalGroup);		
    }
    else
    {    
    	DEBUGMSG("_IsTokenAdmin fail to get AllocateAndInitializeSid with error %d", GetLastError());
    }

    return fResult;
}


//fixcode: return primary token instead
BOOL AUGetUserToken(ULONG LogonId, PHANDLE pImpersonationToken)
{
	BOOL fRet;
	HANDLE hUserToken;

    // _WTSQueryUserToken is defined on tscompat.cpp
	if (fRet = _WTSQueryUserToken(LogonId, &hUserToken))
	{
//		DEBUGMSG("WUAUENG AUGetUserToken() succeeded WTSQueryUserToken");
		if (!(fRet =DuplicateTokenEx(hUserToken, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE , NULL, SecurityImpersonation, TokenImpersonation, pImpersonationToken)))
		{
			DEBUGMSG("WUAUENG AUGetUserToken() DuplicateTokenEx failed");
		}
		CloseHandle(hUserToken);
	}
#ifdef DBG
	else // all failure 
	{	
		DEBUGMSG("WUAUENG AUGetUserToken() failed WTSQueryUserToken with session= %d, error=%d", LogonId, GetLastError());
	}
#endif

	return fRet;
}

BOOL IsUserAUEnabledAdmin(DWORD dwSessionId)
{
    HANDLE hImpersonationToken;
	BOOL   fDisableWindowsUpdateAccess = TRUE;

	if (AUGetUserToken(dwSessionId, &hImpersonationToken))
	{		
		// If user is an admin, impersonate them and steal their current user reg settings
		if( _IsTokenAdmin(hImpersonationToken) )
		{
			HKEY hCurrentUserKey;

			//Bother to check for the policy only if it is an Admin session
			if (!ImpersonateLoggedOnUser(hImpersonationToken))
			{
				DEBUGMSG("WUAUENG fail to ImpersonateLoggedOnUser() with error %d", GetLastError());
				CloseHandle(hImpersonationToken);
				goto done;
			}

			if(RegOpenCurrentUser(KEY_READ, &hCurrentUserKey) == ERROR_SUCCESS)
			{
                        HKEY   hkeyPolicy;	

                        if (ERROR_SUCCESS != RegOpenKeyEx(
                        					hCurrentUserKey,
                        					AUREGKEY_HKCU_USER_POLICY,
                        					0,
                        					KEY_READ,
                        					&hkeyPolicy))
                        {
                            fDisableWindowsUpdateAccess = FALSE;
                        }
                        else
                        {						
                            DWORD dwData;
                            DWORD dwType = REG_DWORD;
                            DWORD dwSize = sizeof(dwData);
                        	if ((ERROR_SUCCESS != RegQueryValueEx(
                        		hkeyPolicy,
                        		AUREGVALUE_DISABLE_WINDOWS_UPDATE_ACCESS,
                        		NULL,
                        		&dwType,
                        		(LPBYTE)&dwData,
                        		&dwSize)) ||
                        		(REG_DWORD != dwType) ||
                        		(1 != dwData) )
                        	{																
                        		fDisableWindowsUpdateAccess = FALSE;											
                        	}
                        	RegCloseKey(hkeyPolicy);
                        }
                        RegCloseKey(hCurrentUserKey);
			}
			RevertToSelf();
		}

		CloseHandle(hImpersonationToken);
	}	
	else
	{
		DEBUGMSG("WUAUENG AUGetUserToken in AUServiceHandler failed for session= %d, error=%d", dwSessionId, GetLastError());	
	}		
	
done:
	return (!fDisableWindowsUpdateAccess);	
}

BOOL IsSession0Active()
{
	BOOL fRet = FALSE;

        //DEBUGMSG("In IsSession0Active()");
	
	HWINSTA hwinsta = OpenWindowStation(_T("WinSta0"), FALSE, WINSTA_READATTRIBUTES);
	
	if (NULL == hwinsta)
	{		
		DEBUGMSG("WUAUENG OpenWindowStation failed");
		goto Done;
	}

	DWORD dwLength;
	USEROBJECTFLAGS stFlags;
	if (GetUserObjectInformation(hwinsta, UOI_FLAGS, (void *)&stFlags, sizeof(stFlags), &dwLength)
		&& (stFlags.dwFlags & WSF_VISIBLE))
	{
		// If there is no user associeted dwLenght is 0
		DWORD dwBuff;
		if (GetUserObjectInformation(hwinsta, UOI_USER_SID, (PVOID) &dwBuff, sizeof(DWORD), &dwLength))
		{
			fRet = dwLength > 0;
		}
		else
		{
			fRet = (ERROR_INSUFFICIENT_BUFFER == GetLastError()); 
		}
	}	
	else
	{
		DEBUGMSG("WUAUENG GetUserObjectInformation failed = %d", GetLastError());
	}
Done:
    if(NULL != hwinsta)
    {
        CloseWindowStation(hwinsta);
    }
	return fRet;
}


inline BOOL FOnlySession0WasLoggedOnBeforeServiceStarted()
{				
	/*We check for only one Sesion logged on because:
	1) When Terminal Services are enabled, Session State can be WTSConnected and the session is actually 
	   logged on (active), but since Terminal Services hadn't been started before the user logged on, they
	   didn't know and could not set the session to WTS Active and left it in WTSConnected. If there is more 
	   than one session, we don't know for sure if Session0's state is WTSConnected but really active or not,
	   we don't want to run the risk of launching the client in an inactive session	   
	*/	
	SESSION_STATE *pSessionState;

	return (gAdminSessions.m_FGetSessionState(0, &pSessionState) && pSessionState->fFoundEnumerating && 1 == gAdminSessions.CSessions());
}

BOOL FSessionActive(DWORD dwAdminSession, WTS_CONNECTSTATE_CLASS *pWTSState)
{
	LPTSTR  pBuffer;			
	DWORD dwBytes;
	WTS_CONNECTSTATE_CLASS wtsState = WTSDown;
	BOOL fRet = FALSE;

    // we might not be able to getthe TS status for the session,
    // so initialize WTSStatus with an invalid value (WTS Status is an enum of positive integers)
    if (_IsTerminalServiceRunning())
    {
        if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, dwAdminSession, WTSConnectState, 
            &pBuffer, &dwBytes))		
        {
           	wtsState = *((WTS_CONNECTSTATE_CLASS *)pBuffer);

            WTSFreeMemory(pBuffer);

            //DEBUGMSG("FSessionActive() get session state = %d for session %d", wtsState, dwAdminSession);
            if (WTSActive == (wtsState) || ((0 == dwAdminSession) && FOnlySession0WasLoggedOnBeforeServiceStarted()))
            {
    //			DEBUGMSG("WUAUENG Active Admin Session =%d", dwAdminSession);
                fRet = TRUE;
    			goto done;
            }		
        }	
        else
        {
	        DEBUGMSG("FSessionActive() fail to call WTSQuerySessionInformation");
        }
    }
    else
	{	
		if ((dwAdminSession == 0) && IsSession0Active())
		{
			//DEBUGMSG("WUAUENG Active Admin Session = 0");
			wtsState = WTSActive;
			fRet = TRUE;
			goto done;
		}
	}


done:
	if (fRet && NULL != pWTSState)
	{
		*pWTSState = wtsState;
	}
	return fRet;
}

// This function is only called on Win2K code, and as such contains specific logic that relates to
// how login/logoff are handled on win2k.
BOOL IsAUValidSession(DWORD dwSessionId)
{
    WTS_CONNECTSTATE_CLASS SessionState;

    // using this function only the retreive the current session status
    FSessionActive(dwSessionId, &SessionState);

    if ((SessionState == WTSActive || SessionState == WTSConnected || SessionState == WTSDisconnected) &&
        IsUserAUEnabledAdmin(dwSessionId))
    {
        DEBUGMSG("WUAUENG ValidateSession succeeded for session %d", dwSessionId);
        return TRUE;
    }
    else
    {
        DEBUGMSG("WUAUENG ValidateSession failed for session %d", dwSessionId);
        return FALSE;
    }
}

//** returns the first Active Admin Sesion ID available 
//** returns -1 if there is no Active Admin session at all
//** dwIgnoreSession is the SessionID that will not be considered as a candidate
//** for available admin sessions 
DWORD GetAllowedAdminSessionId(BOOL fGetSessionForRemindMe)
{
	DWORD dwAdminSession;	

//	DEBUGMSG("GetAllowedAdminSessionId() starts");
    //Sleep 15 seconds before we check Session Status so that we can get accurate information if there 
	//is an Admin Logging Off or any other Session Change notification. This is because it takes a while before 
	//the session information shows right info	
	if (FServiceFinishedOrWait(ghServiceFinished, 15000))
	{
		return DWNO_ACTIVE_ADMIN_SESSION_SERVICE_FINISHED;
	}

    if (IsWin2K())
    {
        DEBUGMSG("WUAUENG Forcing the session cache to be rebuilt (needed on win2k as we don't track logoffs).");
        gAdminSessions.ValidateCachedSessions();
    }

	//if for remind later timeout, try to use the same session as last time
	if (fGetSessionForRemindMe && gAdminSessions.m_FGetCurrentSession(&dwAdminSession) && FSessionActive(dwAdminSession))
	{
        return dwAdminSession;
	}

	for (int nSession = 0; nSession < gAdminSessions.CSessions(); nSession++)
	{ // get next available active session
		if (gAdminSessions.m_FGetNextSession(&dwAdminSession) && FSessionActive(dwAdminSession))			
        {
        	DEBUGMSG(" found available admin %d", dwAdminSession);
            goto Done;
        }
    }

    dwAdminSession = DWNO_ACTIVE_ADMIN_SESSION_FOUND;

Done:
//	DEBUGMSG("GetAllowedAdminSessionId() ends");
	return dwAdminSession;	
}

//return TRUE if AU client stopped.
//return FALSE otherwise
void AUStopClients(BOOL fWaitTillCltDone = FALSE, BOOL fRelaunch = FALSE)
{
    if ( ghClientHandles.fClient() )
    {
		ghClientHandles.StopClients(fRelaunch);
		if (fWaitTillCltDone)
		{
		    ghClientHandles.WaitForClientExits();
		}
    }
}

VOID SetActiveAdminSessionEvent()
{									
	if (NULL != ghActiveAdminSession)	
	{	
		DEBUGMSG("WUAUENG AUACTIVE_ADMIN_SESSION_EVENT triggered ");		
		SetEvent(ghActiveAdminSession);
	}
	else
	{
		DEBUGMSG("WUAUENG No  AUACTIVE_ADMIN_SESSION_EVENT handle settup propperly");
	}
}

BOOL FDownloadIsPaused()
{
	DWORD dwStatus;
	UINT upercentage;

	return ((AUSTATE_DOWNLOAD_PENDING == gpState->GetState()) &&
		(SUCCEEDED(GetDownloadStatus(&upercentage, &dwStatus, FALSE))) && 
		(DWNLDSTATUS_PAUSED == dwStatus));
}

BOOL fSPUpgraded()
{
	DWORD dwResetAU = 0;
	if (FAILED(GetRegDWordValue(_T("ResetAU"), &dwResetAU)))
	{
		dwResetAU = 0;
	}
	DeleteRegValue(_T("ResetAU"));
	return  (1 == dwResetAU);
}
		
		
		

///////////////////////////////////////////////////////////////////////////////////
// return nothing
//////////////////////////////////////////////////////////////////////////////////
void ProcessInitialState(WORKER_THREAD_INIT_DATA * pinitData)
{
     DWORD AuState;

       pinitData->uFirstMsg = -1;
       pinitData->fWaitB4Detect = FALSE;
       pinitData->dwWaitB4Detect = 0;

	// check if the system was just restored.
	if ( gpState->fWasSystemRestored() )
	{
		DEBUGMSG("The system was restored, going to state AUSTATE_DETECT_PENDING");
		AuState = AUSTATE_DETECT_PENDING;
		gpState->SetState(AuState);
	}
	else
	{
		AuState = gpState->GetState();
	}
	
	DEBUGMSG("WUAUENG Starting update cycle in state %d", gpState->GetState());
	// all states after Detect Pending require catalog validation

	switch(AuState)
	{
		case AUSTATE_OUTOFBOX:	
        		{
        		    pinitData->uFirstMsg = AUMSG_INIT;
        		    break;
			}		
		case AUSTATE_NOT_CONFIGURED:
        		    break;
		case AUSTATE_DISABLED:
                        if (gpState->fOptionEnabled())
                        {
                           	gpState->SetState(AUSTATE_DETECT_PENDING);
        			pinitData->uFirstMsg = AUMSG_DETECT;
                        }
                        break;
		
		case AUSTATE_DETECT_PENDING:
			pinitData->uFirstMsg = AUMSG_DETECT;
			break;

		case AUSTATE_DETECT_COMPLETE:
    		case AUSTATE_DOWNLOAD_COMPLETE:		
			if (FAILED(gpAUcatalog->Unserialize()))
			{
				DEBUGMSG("WUAUENG catalog unserializing failed. State -> Detect Pending");
				gpState->SetState(AUSTATE_DETECT_PENDING);
        			pinitData->uFirstMsg = AUMSG_DETECT;
				break;
			}
                    break;
		
		case AUSTATE_DOWNLOAD_PENDING:
		      {
                      if (FAILED(gpAUcatalog->Unserialize()))
                      {
                          	DEBUGMSG("WUAUENG catalog unserializing failed. State -> Detect Pending");
                          	gpState->SetState(AUSTATE_DETECT_PENDING);
        			pinitData->uFirstMsg = AUMSG_DETECT;
                          	break;
                      }
                      ResumeDownloadIfNeccesary();
      			pinitData->uFirstMsg = AUMSG_DOWNLOAD;
  			break;
                    }
	
		case AUSTATE_INSTALL_PENDING:
			// enter this code path when restore system restore point and after reboot completed
			DEBUGMSG("WUAUENG in INSTALL_PENDING state, State->Detect Pending");
			gpState->SetState(AUSTATE_DETECT_PENDING);
			pinitData->uFirstMsg = AUMSG_DETECT;
			break;
		case AUSTATE_WAITING_FOR_REBOOT:
			{
				if (!fCheckRebootFlag())
				{	
					//if there is no Reboot flag and the state was WAINTING_FOR_REBOOT means there was a 
					//a reboot and now it is time to set to DETECT_PENDING but wait for random hours
					gpState->SetState(AUSTATE_DETECT_PENDING);
                                   pinitData->fWaitB4Detect = TRUE;
                                   pinitData->dwWaitB4Detect = RandomWaitTimeBeforeDetect();
                                   pinitData->uFirstMsg = AUMSG_DETECT;
				}
				break;
			}
		default:
			{
			DEBUGMSG("WUAUENG ERROR Startup state = %d", AuState);
#ifdef DBG
			(void)ServiceFinishNotify();				
#endif
			break;
			}
	}

	DWORD dwNewState = gpState->GetState();
	if (fSPUpgraded() && dwNewState > AUSTATE_DETECT_PENDING )
    { //reset au engine after sp upgrade
    	DEBUGMSG("AU just got upgraded during SP install, reset AU engine state ");
       	if (AUSTATE_DISABLED != dwNewState && AUSTATE_WAITING_FOR_REBOOT != dwNewState)
       	{
	       	CancelDownload();
       		gpState->SetState(AUSTATE_DETECT_PENDING);
	       	pinitData->fWaitB4Detect = FALSE; //start detection right away
	        pinitData->dwWaitB4Detect = 0;
	        pinitData->uFirstMsg = AUMSG_DETECT;
       	}
    }

	SetEvent(ghEngineState); //jump start workerclient
	return ;
}



DWORD WINAPI ServiceHandler(DWORD fdwControl, DWORD dwEventType, LPVOID pEventData, LPVOID /*lpContext*/)
{
	switch(fdwControl)
	{
		case SERVICE_CONTROL_STOP:
		case SERVICE_CONTROL_SHUTDOWN:
			gMyServiceStatus.dwCurrentState	= SERVICE_STOP_PENDING;
			if (SERVICE_CONTROL_SHUTDOWN == fdwControl)
				{
				DEBUGMSG("WUAUENG AUServiceHandler received SERVICE_CONTROL_SHUTDOWN");
				}
			else if (SERVICE_CONTROL_STOP == fdwControl)
				{
				DEBUGMSG("WUAUENG AUServiceHandler received SERVICE_CONTROL_STOP");			
				}
			SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
			(void)ServiceFinishNotify();			
			break;

		case SERVICE_CONTROL_INTERROGATE:
			SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
			break;

        //
        // ATT: On Win2K this case will never be called. To replace this code, we will be 
        // subscribing to SENS (see ausens.cpp) and subscribing to logon/logoff notifications.
        // The SENS callbacks will call the same code it is called here for non-Win2K systems:
        // OnUserLogon and OnUserLogoff.
        // Note however that SENS will not raise notifications for CONNECT/DISCONNECTS, so
        // there's a change of functionality implied by this different code path.
        //
		case SERVICE_CONTROL_SESSIONCHANGE:
			{
				if (pEventData && !IsWin2K())
				{
					WTSSESSION_NOTIFICATION* pswtsi = (WTSSESSION_NOTIFICATION*)pEventData;
					DWORD dwSessionId = pswtsi->dwSessionId;

					switch (dwEventType)
					{
	                    case WTS_CONSOLE_CONNECT:
		                case WTS_REMOTE_CONNECT:    
							{								
								DEBUGMSG("WUAUENG session %d connected via %s", dwSessionId, 
								        WTS_CONSOLE_CONNECT==dwEventType ? "console" : "remote");
								//check if session is cached
								if (gAdminSessions.m_FGetSessionState(dwSessionId, NULL))
								{
									SetActiveAdminSessionEvent();
								}
								else
								{
									if (gAdminSessions.CacheSessionIfAUEnabledAdmin(dwSessionId, FALSE))
									{ //only add it if it is not cached and is AU enabled Admin
										DEBUGMSG("WUAUENG an Admin Session %d added", dwSessionId);
										SetActiveAdminSessionEvent();
									}
								}
								break;
							}							
			            case WTS_CONSOLE_DISCONNECT:
						case WTS_REMOTE_DISCONNECT:	
							{					
								DEBUGMSG("WUAUENG session %d disconnected via %s", dwSessionId,
								        WTS_CONSOLE_DISCONNECT==dwEventType ? "console" : "remote");
								if (ghClientHandles.fClient())
								{
									DWORD dwCurAdminSessionId;
									if (gAdminSessions.m_FGetCurrentSession(&dwCurAdminSessionId) &&
									    dwSessionId == dwCurAdminSessionId && 
										!FDownloadIsPaused())
									{
										DEBUGMSG("WUAUENG stopping client");									
	                                    AUStopClients(FALSE, TRUE); //non blocking
									}
								}			
								break;
							}				        
	                    case WTS_SESSION_LOGON:
							{											
								DEBUGMSG("WUAUENG session %d logged ON ", dwSessionId);
                                                        if (gAdminSessions.CacheSessionIfAUEnabledAdmin(dwSessionId, FALSE))
                                                        {
                                                            DEBUGMSG("WUAUENG an Admin Session %d added", dwSessionId);
                                                            SetActiveAdminSessionEvent();									
                                                        }
								break;
							}						
						case WTS_SESSION_LOGOFF:
							{
        							DEBUGMSG("WUAUENG session %d logged OFF", dwSessionId);
                                                        gAdminSessions.m_FDeleteSession(dwSessionId);
								break;
							}
						default:  /* WTS_SESSION_LOCK, WTS_SESSION_UNLOCK,WTS_SESSION_REMOTE_CONTROL*/
							break;
					}
				}					
				break;
			}
		default:
			return ERROR_CALL_NOT_IMPLEMENTED;
	}	

	return NO_ERROR ;		
}


BOOL WaitForShell(void)
{
    HANDLE hShellReadyEvent;
    UINT uCount = 0;
    BOOL fRet = FALSE;

    if (IsWin2K())
    {
        DEBUGMSG("WUAUENG WUAUSERV Ignoring WaitForShell on Win2K");
        fRet =  FALSE;   // we're not leaving because the service has finished.
        goto done;
    }

    while ((hShellReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("ShellReadyEvent"))) == NULL) {
        if ( FServiceFinishedOrWait(ghServiceFinished, dwTimeToWait(AU_TEN_SECONDS) ))
        {
            fRet =  TRUE;
            goto done;
        }
        if (uCount++ > 6) 
        {
            DEBUGMSG("ShellReadyEvent not set after one min");
            goto done;
        }
   }
 
  HANDLE 	hEvents[2] = {hShellReadyEvent, ghServiceFinished};
  DWORD dwRet  = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);
  if (WAIT_OBJECT_0 + 1 == dwRet)
  {
     fRet = TRUE;
  }
  else
  {
    DEBUGMSG("WUAUENG: ShellReadyEvent kicked");
  }
  CloseHandle(hShellReadyEvent);
 done:
    return fRet;
}


//=======================================================================
//  Calculate Reminder Time
//=======================================================================
inline HRESULT CalculateReminderTime(DWORD *pdwSleepTime /*in secs, no prorate*/)
{
    DWORD dwTimeOut;
    UINT index;
	
    *pdwSleepTime = 0;
    HRESULT hr = getReminderTimeout(&dwTimeOut, &index);

	if ( SUCCEEDED(hr) )
	{		
		DWORD dwReminderState = AUSTATE_DETECT_COMPLETE;
		AUOPTION auopt = gpState->GetOption();
		DWORD dwCurrentState = gpState->GetState();

		getReminderState(&dwReminderState);
		if (dwCurrentState != dwReminderState)
		{
			// Invalidate reminder timeout
			hr = E_FAIL;
		}
		// bug 502380
		// Wake up immediately if AUOptions was changed
		// from 2->3 during AUSTATE_DETECT_COMPLETE,
		// or from 2/3->4, has AU been running or not.
		else if (AUOPTION_SCHEDULED == auopt.dwOption ||
				 (AUOPTION_INSTALLONLY_NOTIFY == auopt.dwOption &&
				  AUSTATE_DETECT_COMPLETE == dwCurrentState))
		{
			DEBUGMSG("WUAUENG reminder no longer applies");
		}
		else
		{
			*pdwSleepTime = dwTimeOut;
		}
		if (0 == *pdwSleepTime)
		{
		    // reminder time is up
			removeReminderKeys();
		}
	}

    return hr;
}

void RebootNow()
{
	// Set AUState to "waiting for reboot" just in case anything fails in this function
	DEBUGMSG("WUAUENG in AUSTATE_WAITING_FOR_REBOOT state");
	gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);

	DEBUGMSG("WUAUENG initiating shutdown sequence...");

	HANDLE currentToken;
	if(OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &currentToken))
	{
		LUID shutdownluid;
		if(LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &shutdownluid) != 0)
		{
			BYTE OldPrivBuf[30]; //should be big enough to host one privilege entry
			TOKEN_PRIVILEGES privileges;
			ULONG cbNeeded = 0;
			privileges.PrivilegeCount = 1;
			privileges.Privileges[0].Luid = shutdownluid; 
			privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
			ZeroMemory(OldPrivBuf, sizeof(OldPrivBuf));
			if (AdjustTokenPrivileges(currentToken, FALSE, &privileges, sizeof(OldPrivBuf), (PTOKEN_PRIVILEGES)OldPrivBuf, &cbNeeded))
			{
				if (InitiateSystemShutdown(NULL, NULL, 0, TRUE, TRUE))
				{
					DEBUGMSG("WUAUENG first reboot successfully issued");
				}
				else
				{
					DEBUGMSG("Warning: Wuaueng fail to issue first reboot with error %lu", GetLastError());
				}

				const DWORD c_dwRetryWaitTimeInMS = 10000;
				DWORD dwRetryCountDown = 30;

				DEBUGMSG("WUAUENG keep on forcing restart until service finish");
				while ((0 < --dwRetryCountDown) &&
					   (WAIT_TIMEOUT == WaitForSingleObject(ghServiceFinished, c_dwRetryWaitTimeInMS)))
				{
					if (ExitWindowsEx(EWX_REBOOT | EWX_FORCE, 0))
					{
						DEBUGMSG("WUAUENG forceful reboot successfully issued");
					}
					else
					{
						DEBUGMSG("Warning: Wuaueng fail to reboot with error %lu; retry in %d secs", GetLastError(), c_dwRetryWaitTimeInMS / 1000);
					}
				}

				if (((PTOKEN_PRIVILEGES)OldPrivBuf)->PrivilegeCount > 0)
				{
					AdjustTokenPrivileges(currentToken, FALSE, (PTOKEN_PRIVILEGES)OldPrivBuf, 0, NULL, NULL); //restore privious privileges
				}
			}
			else
			{
				DEBUGMSG("Warning: wuaueng fail to adjust token previlege with error %d", GetLastError());
			}
		}
		else
		{
			DEBUGMSG("Warning: wuaueng fail to look up privilege value with error %lu", GetLastError());
		}
		CloseHandle(currentToken);
	}
	else
	{
		DEBUGMSG("Warning: Wuaueng fail to get process token to enable reboot with error %lu", GetLastError());
	}
}


//=======================================================================
//  ProcessClientFinished()
//=======================================================================
void ProcessClientFinished(CAUWait & wait, HANDLE hClientProcess, BOOL fAdmin)
{
    DEBUGMSG("ProcessClientFinished");

	// if client returns from installing, change state.
	//if the client exited because there was a timeout (due to no user interaction),
	//make sure that the session in which it (client) was launched will not be selected again										
	DWORD dwExitProc;	
	BOOL fRet = GetExitCodeProcess(hClientProcess, &dwExitProc);
	BOOL fRebootWarningMode = ghClientHandles.fRebootWarningMode();
	ghClientHandles.RemoveHandle(hClientProcess);																

	if (AUSTATE_DOWNLOAD_PENDING == gpState->GetState())							
	{// resume job if needed after user logs off or au client torn down
	    ResumeDownloadIfNeccesary();
	}

	if (!fRet)
	{
		DEBUGMSG("WUAUENG GetExitCodeProcess failed, last Error= %lu", GetLastError());
		wait.Reset();
	}		
    else
	{
		DEBUGMSG("WUAUENG GetExitCodeProcess succeded, sessionId is = %d, dwExitProc is = %lu", 0 , dwExitProc);
		if (!fAdmin)
		{ // for non admin, don't look at its return code
			DEBUGMSG("WUAUENG notice nonadmin wuauclt returned, do not look at the return code");
			return; 
		}
		if (CDWWUAUCLT_REBOOTTIMEOUT == dwExitProc || 
			(((STATUS_SUCCESS == dwExitProc) ||
			  (DBG_TERMINATE_PROCESS == dwExitProc) ||
			  (CDWWUAUCLT_ENDSESSION == dwExitProc))
			&& fRebootWarningMode))
		{
			DEBUGMSG("WUAUENG reboot warning client log off or time out ");
//			if (!ghClientHandles.fClient())
//			{//last reboot warning client timed out or logged off
//				RebootNow();
//			}	
            return;
		}
		//no need to wait for other clients
		wait.Reset();
              switch(dwExitProc)
			{													
				case CDWWUAUCLT_OK:
				{
					if ( AUSTATE_INSTALL_PENDING == gpState->GetState() )
					{
						DEBUGMSG("WUAUENG Install done, State->Detect Pending");
						gpState->SetState(AUSTATE_DETECT_PENDING);
						PostThreadMessage(gdwWorkerThreadId, AUMSG_POST_INSTALL, 0, 0);
					}
					break;
				}
				case CDWWUAUCLT_RELAUNCHNOW:
				{
                    wait.Timeout(AUEVENT_RELAUNCH_TIMEOUT, 0);
					break;
				}
				case CDWWUAUCLT_RELAUNCHLATER:			// sleep a while before relaunching client if asked by client
				{
                    //
                    // Fix for bug 493026
                    // Annah: Relaunching the client was taken too long because time of wait need to be specified in seconds
                    // (AU constants are already defined in seconds and dwWait should be in seconds).
                    //									 
					DEBUGMSG("WUAUENG wait for 3 min before relaunching WUAUCLT");													
			              wait.Timeout(AUEVENT_RELAUNCH_TIMEOUT, AU_THREE_MINS);
					break;
				}
                // STATUS_SUCCESS is the exit code for wuauclt.exe on Win2k and also for some cases of NtTerminateProcess (like pskill.exe)
                case STATUS_SUCCESS:      
				case DBG_TERMINATE_PROCESS:
				case CDWWUAUCLT_ENDSESSION:	// user logs off or system shuts down
				{
					//This is the only time that the service will Set the Engine State change event.
					//The client was terminated by the debugger and it didn't have the chance to set the event
					//and it is necessesary so that this loop (fServiceFinished) doesn't get stuck
					//this exit code is also returned when user logs off the session
                    if (fCheckRebootFlag())
					{ //AU client killed while showing waiting for reboot
						DEBUGMSG("WUAUENG in AUSTATE_WAITING_FOR_REBOOT state");
					    gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);
					}
					else if (AUSTATE_INSTALL_PENDING == gpState->GetState())
                                    { //AU client killed while installing 
                                        /*
                                         if (S_OK != (gpAUcatalog->ValidateItems(FALSE)))
                                        { //no items to install anymore
                                              ResetEngine(); 
                                        }
                                         else */
                                         { //show uninstall items again.
                                            gpState->SetState(AUSTATE_DOWNLOAD_COMPLETE);
                                         }
                                    }
                                    else
                                    {
                                        wait.Timeout(AUEVENT_RELAUNCH_TIMEOUT, 0);
                                    }
					break;
				}	
				case CDWWUAUCLT_INSTALLNOW:
				    {
				        //user say yes to install warning dialog
				        //launch client install via local system right away
				        gpState->SetCltAction(AUCLT_ACTION_AUTOINSTALL);
      					wait.Add(AUEVENT_DO_DIRECTIVE); //reenter workclient loop right away
				        break;
				    }
				case CDWWUAUCLT_REBOOTNOW:
				    { //now in install_pending state
				            DEBUGMSG("WUAUENG rebooting machine");
				            AUStopClients(TRUE); //stop all clients
                            RebootNow();
					        break;
				    }
				case CDWWUAUCLT_REBOOTLATER:
				    {
			                DEBUGMSG("WUAUENG change to AUSTATE_WAITING_FOR_REBOOT state");
			                AUStopClients(TRUE); //stop all clients
				            gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);
				            break;
				    }
				case CDWWUAUCLT_REBOOTNEEDED:
				        { //now in install_pending state
				            DEBUGMSG("WUAUENG need to prompt user for reboot choice");
				            gpState->SetCltAction(AUCLT_ACTION_SHOWREBOOTWARNING);
                            wait.Add(AUEVENT_DO_DIRECTIVE); //reenter workclient loop right away
				            break;
				    }

                case CDWWUAUCLT_FATAL_ERROR:
				default:
				{			
       				(void)ServiceFinishNotify();
					break;
				}
			}
        }
}

#if 0
inline BOOL fUserAvailable()
{
    return (DWNO_ACTIVE_ADMIN_SESSION_FOUND != gdwAdminSessionId);
}
#endif



void LaunchRebootWarningClient(CAUWait & wait, SESSION_STATUS & allActiveSessions)
{
    DEBUGMSG("LaunchRebootWarningClient()  starts");
	PROCESS_INFORMATION ProcessInfo;	
	HANDLE hCltExitEvt;
	TCHAR szCmd[MAX_PATH+1];	
	TCHAR szClientExitEvtName[100];
	LPTSTR lpszEnvBuf = NULL;

	wait.Reset();
	
	memset(&ProcessInfo, 0, sizeof(ProcessInfo));

	UINT ulen = GetSystemDirectory(szCmd, ARRAYSIZE(szCmd));
	if (0 == ulen || ulen >= ARRAYSIZE(szCmd))
	{
		DEBUGMSG("WUAUENG Could not get system directory");
		goto done;
	}

	const TCHAR szAUCLT[] = _T("wuauclt.exe");
	if (FAILED(PathCchAppend(szCmd, ARRAYSIZE(szCmd), szAUCLT)))
	{
		DEBUGMSG("WUAUENG Could not form full path to wuauclt.exe");
		goto done;
	}

	const size_t c_cchEnvBuf = AU_ENV_VARS::s_AUENVVARCOUNT * (2 * AU_ENV_VARS::s_AUENVVARBUFSIZE + 2) + 1;
	if (NULL == (lpszEnvBuf = (LPTSTR) malloc(c_cchEnvBuf * sizeof(TCHAR))))
	{
		DEBUGMSG("Fail to allocate memory for string for environment variables");
		goto done;
	}

	if (!ghClientHandles.CreateClientExitEvt(szClientExitEvtName, ARRAYSIZE(szClientExitEvtName)))
	{
		DEBUGMSG("Fail to create client exit event with error %d", GetLastError());
		goto done;
	}


	for (int nSession = 0; nSession < allActiveSessions.CSessions(); nSession++)
	{ // get next available active session
		DWORD dwActiveSession;

		if (allActiveSessions.m_FGetNextSession(&dwActiveSession) && FSessionActive(dwActiveSession))			
        {  
			AU_ENV_VARS auEnvVars;
			HANDLE hImpersonationToken = NULL;																	
		    HANDLE hUserToken = NULL;

        	DEBUGMSG("WUAUENG launch client in session %d", dwActiveSession);
			if (!AUGetUserToken(dwActiveSession, &hImpersonationToken))
			{								
				DEBUGMSG("WUAUENG WARNING: fails AUGetUserToken");
				continue;
			}
			  
			if (!DuplicateTokenEx(hImpersonationToken, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_ASSIGN_PRIMARY , NULL,
				SecurityImpersonation, TokenPrimary, &hUserToken))								
			{
				DEBUGMSG("WUAUENG WARNING: Could not DuplicateTokenEx, dw=%d", GetLastError());								
				CloseHandle(hImpersonationToken);
				continue;
			}
		  	CloseHandle(hImpersonationToken);
		  	BOOL fAUAdmin = IsUserAUEnabledAdmin(dwActiveSession);
		  	BOOL fEnableYes = (1 == allActiveSessions.CSessions()) && fAUAdmin; //only one active user and it is a AU admin
		  	BOOL fEnableNo = fAUAdmin;
			if (!auEnvVars.WriteOut(lpszEnvBuf, c_cchEnvBuf, TRUE, fEnableYes, fEnableNo, szClientExitEvtName))
			{
				DEBUGMSG("WUAUENG Could not write out environment variables");
				CloseHandle(hUserToken);
				continue;
			}
			LPVOID envBlock;
			if (!CreateEnvironmentBlock(&envBlock, hUserToken, FALSE))
			{
				DEBUGMSG("WUAUENG fail to get environment block for user");
				CloseHandle(hUserToken);
				continue;
			}
			STARTUPINFO StartupInfo;								
			memset(&StartupInfo, 0, sizeof(StartupInfo));
			StartupInfo.cb = sizeof(StartupInfo);
			StartupInfo.lpDesktop = _T("WinSta0\\Default");																	

			if (!CreateProcessAsUser(hUserToken, szCmd, lpszEnvBuf, NULL, NULL, FALSE /*Inherit Handles*/ , 
					DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT, envBlock, NULL, &StartupInfo, &ProcessInfo))
			{
				DEBUGMSG("WUAUENG Could not CreateProcessAsUser (WUAUCLT), dwRet = %d", GetLastError());
			    DestroyEnvironmentBlock(envBlock);
			    CloseHandle(hUserToken);
			    continue;
			}	
			DestroyEnvironmentBlock(envBlock);
			CloseHandle(hUserToken);
		   	DEBUGMSG("WUAUENG Created the client service (WUAUCLT)");
			ghClientHandles.AddHandle(ProcessInfo);
		    wait.Add(AUEVENT_WUAUCLT_FINISHED, ProcessInfo.hProcess, fAUAdmin);
		}
	}
done:
	wait.Timeout(AUEVENT_REBOOTWARNING_TIMEOUT,  AU_FIVE_MINS + 10, FALSE); //10 secs to make sure all clients time out
	SafeFree(lpszEnvBuf);
    DEBUGMSG("LaunchRebootWarningClient()  ends");
	return;
}

//=======================================================================
//  LaunchClient()
// if no admin logged on, launch client via local system
// update ghClientHandles
// return S_OK if client launched
//		S_FALSE if no session available or service finished, *pdwSessionId indicates the reason
//		E_XXX for all other failures
//=======================================================================
HRESULT  LaunchClient(IN CAUWait & wait, IN BOOL fAsLocalSystem, OUT DWORD *pdwSessionId, IN BOOL fGetSessionForRemindMe = FALSE )
{
//    DEBUGMSG("LaunchClient");
    HANDLE hImpersonationToken = NULL;																	
    HANDLE hUserToken = NULL;	
	DWORD    dwAdminSessionId = DWNO_ACTIVE_ADMIN_SESSION_FOUND ;
	HRESULT hr = E_FAIL;

	wait.Reset();
	AUASSERT(NULL != pdwSessionId);
	*pdwSessionId = DWNO_ACTIVE_ADMIN_SESSION_FOUND;
       if (!fAsLocalSystem)
        { //launch client in user context
            dwAdminSessionId = GetAllowedAdminSessionId(fGetSessionForRemindMe);
            if (DWNO_ACTIVE_ADMIN_SESSION_FOUND == dwAdminSessionId ||
            	DWNO_ACTIVE_ADMIN_SESSION_SERVICE_FINISHED == dwAdminSessionId)
            {
            	DEBUGMSG("WUAUENG find no admin or service finished before launching client");
            	hr = S_FALSE;
            	goto done;
            }
            DEBUGMSG("WUAUENG launch client in session %d", dwAdminSessionId);
        	if (!AUGetUserToken(dwAdminSessionId, &hImpersonationToken))
        	{								
        		DEBUGMSG("WUAUENG fails AUGetUserToken");
        		hr = HRESULT_FROM_WIN32(GetLastError());
        		goto done;
        	}
        	  
        	if (!DuplicateTokenEx(hImpersonationToken, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_ASSIGN_PRIMARY , NULL,
        		SecurityImpersonation, TokenPrimary, &hUserToken))								
        	{
        		DEBUGMSG("WUAUENG Could not DuplicateTokenEx, dw=%d", GetLastError());								
        		hr = HRESULT_FROM_WIN32(GetLastError());
        		goto done;
        	}

        	if ( WaitForShell() )
        	{
                // service finished
                dwAdminSessionId = DWNO_ACTIVE_ADMIN_SESSION_SERVICE_FINISHED ;
                hr = S_FALSE;
        		goto done;
        	}
        }
       else
       {
       	dwAdminSessionId = DWSYSTEM_ACCOUNT;
       }

	STARTUPINFO StartupInfo;								
	PROCESS_INFORMATION ProcessInfo;								
	TCHAR szCmd[MAX_PATH+1];																

	memset(&ProcessInfo, 0, sizeof(ProcessInfo));
	memset(&StartupInfo, 0, sizeof(StartupInfo));

	StartupInfo.cb = sizeof(StartupInfo);

	UINT ulen = GetSystemDirectory(szCmd, ARRAYSIZE(szCmd));
	if (0 == ulen)
	{
		DEBUGMSG("WUAUENG Could not get system directory");
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto done;
	}
	if (ulen >= ARRAYSIZE(szCmd))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto done;
	}

	const TCHAR szAUCLT[] = _T("wuauclt.exe");
	if (FAILED(hr =PathCchAppend(szCmd, ARRAYSIZE(szCmd), szAUCLT)))
	{
		DEBUGMSG("WUAUENG Could not form full path to wuauclt.exe");
		goto done;
	}
	ghClientHandles.ClientStateChange(); //let AU client process initial state
	WaitForSingleObject(ghMutex, INFINITE);
	StartupInfo.lpDesktop = _T("WinSta0\\Default");	
	if (fAsLocalSystem)
	    { //launch client via local system
	        DEBUGMSG("Launch client via local system"); //inherit local system's desktop
	        if (!CreateProcess(szCmd, NULL, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &StartupInfo, &ProcessInfo))
	        {
    		       DEBUGMSG("WUAUENG Could not CreateProcess (WUAUCLT), dwRet = %d", GetLastError());     
    		       ReleaseMutex(ghMutex);
    		       hr = HRESULT_FROM_WIN32(GetLastError());
    		       goto done;
    		 }
    }
	else
    {
		LPVOID envBlock = NULL;
		BOOL fResult = FALSE;		
		CreateEnvironmentBlock(&envBlock, hUserToken, FALSE); //if fail, use NULL
    	fResult = CreateProcessAsUser(hUserToken, szCmd, NULL, NULL, NULL, FALSE /*Inherit Handles*/ , 
    			DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT, envBlock, NULL, &StartupInfo, &ProcessInfo);
    	DWORD dwLastErr = GetLastError();
		if (NULL != envBlock)
		{
			DestroyEnvironmentBlock(envBlock);
		}
		if (!fResult)
		{
			DEBUGMSG("WUAUENG Could not CreateProcessAsUser (WUAUCLT), dwRet = %d", GetLastError());
            ReleaseMutex(ghMutex);
			hr = HRESULT_FROM_WIN32(dwLastErr);
            goto done;		
    	}		
    }
	DEBUGMSG("WUAUENG Created the client service (WUAUCLT)");
	ghClientHandles.SetHandle(ProcessInfo, fAsLocalSystem);
	ReleaseMutex(ghMutex);
    wait.Add(AUEVENT_WUAUCLT_FINISHED, ProcessInfo.hProcess, TRUE);
    hr = S_OK;
done:
    SafeCloseHandleNULL(hImpersonationToken);                            
    SafeCloseHandleNULL(hUserToken);	
   	*pdwSessionId = dwAdminSessionId;
    return hr;
}

void CalculateSleepTime(CAUWait & wait)
{
    DWORD dwReminderSleepTime = -1; //DWORD -1 is 0xFFFFFFFF
    DWORD dwSchedSleepTime = -1;
    DWORD dwSleepTimes[4] = { -1, -1, -1, -1};
    AUEVENT EventIds[4] = {AUEVENT_SCHEDULED_INSTALL, AUEVENT_REMINDER_TIMEOUT, AUEVENT_RELAUNCH_TIMEOUT, AUEVENT_REBOOTWARNING_TIMEOUT};
#ifdef DBG    
    LPSTR   szEventNames[4] = {"Schedule Install", "Reminder timeout", "Relaunch timeout", "RebootWarning timeout"};
#endif

//    DEBUGMSG("CalculateSleepTime starts");
    if ( FAILED(CalculateReminderTime((DWORD*) &dwReminderSleepTime)) )
    {
        dwReminderSleepTime = -1;
    }

    if (gpState->fShouldScheduledInstall())
    {
		HRESULT hr;
		if (SUCCEEDED(hr = gpState->CalculateScheduledInstallSleepTime(&dwSchedSleepTime)) )
        {
		    if (S_FALSE == hr)	// the scheduled install date has been changed
		    {
			    PostThreadMessage(gdwWorkerThreadId, AUMSG_LOG_EVENT, 0, 0);
		    }
        }
    }

    dwSleepTimes[0] = dwSchedSleepTime;
    dwSleepTimes[1] = dwReminderSleepTime;
    dwSleepTimes[2] = (AUEVENT_RELAUNCH_TIMEOUT == wait.GetTimeoutEvent()) ? wait.GetTimeoutValue(): -1;
    dwSleepTimes[3] = (AUEVENT_REBOOTWARNING_TIMEOUT == wait.GetTimeoutEvent())? wait.GetTimeoutValue(): -1;

    DWORD dwLeastTimeIndex = 0;
    for (int i = 0; i < ARRAYSIZE(dwSleepTimes); i++)
    {
        if (dwSleepTimes[i] < dwSleepTimes[dwLeastTimeIndex])
        {
            dwLeastTimeIndex = i;
        }
    }
    if (-1 == dwSleepTimes[dwLeastTimeIndex])
    {
        wait.Timeout(AUEVENT_DUMMY, INFINITE);
    }
    else
    {
    	BOOL fProrate = (AUEVENT_REBOOTWARNING_TIMEOUT != EventIds[dwLeastTimeIndex]);
        wait.Timeout(EventIds[dwLeastTimeIndex], dwSleepTimes[dwLeastTimeIndex], fProrate);
#ifdef DBG        
        DEBUGMSG("CalculateSleepTime: next time wake up in %d secs for %s", dwSleepTimes[dwLeastTimeIndex], szEventNames[dwLeastTimeIndex]);
#endif
        if ( AUEVENT_REMINDER_TIMEOUT != EventIds[dwLeastTimeIndex]
         && -1 != dwSleepTimes[1])
        {
                removeReminderKeys();
        }
    }

//        DEBUGMSG("CalculateSleepTime ends");
        return;
}

void ResetEngine(void)
{
    if ( fCheckRebootFlag() )
    {
    	DEBUGMSG("WUAUENG in AUSTATE_WAITING_FOR_REBOOT state");
    	gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);
    }
    else
    {
        ResetEvent(ghServiceDisabled);
        CancelDownload();
        gpState->SetState(AUSTATE_DETECT_PENDING);
        PostThreadMessage(gdwWorkerThreadId, AUMSG_DETECT, 0, 0);
        AUStopClients(); 
    }
}

void DisableAU(void)
{
    gpState->SetState(AUSTATE_DISABLED);		
    SetEvent(ghServiceDisabled); //intrinsticly cancel download
    AUStopClients();
}

//=======================================================================
//  WorkerClient
//=======================================================================
void WorkerClient(void)
{
	AUEVENT eventid;	
	DWORD dwLastState;
	CAUWait wait;
        
	 DEBUGMSG("WUAUENG Entering Worker Client");
	while ( TRUE )
	{	
		HANDLE hSignaledEvent;
		BOOL 	fAdmin = TRUE;
        CalculateSleepTime(wait);

        DEBUGMSG("WUAUENG before waiting for next worker client event");
        dwLastState = gpState->GetState();

		if (!wait.Wait(&hSignaledEvent, &fAdmin, &eventid))
		{
			DEBUGMSG("WUAUENG wait.wait() failed.");
			(void)ServiceFinishNotify();				
            goto done;
		}
        if ( AUEVENT_SERVICE_FINISHED == eventid )
        {
            AUStopClients(TRUE);
		    if ( fCheckRebootFlag() )
		    {
		    	DEBUGMSG("WUAUENG in AUSTATE_WAITING_FOR_REBOOT state");
		    	gpState->SetState(AUSTATE_WAITING_FOR_REBOOT);
		    }
            goto done;
        }

        if (AUEVENT_POLICY_CHANGE == eventid)
        {
                //find out what changed
                //if nothing changed, go back to the beginning of the loop
                //otherwise, take different actions
                enumAUPOLICYCHANGEACTION actcode;
                if (S_OK == gpState->Refresh(&actcode))
                    {
                        switch (actcode)
                            {
                                case AUPOLICYCHANGE_NOOP: break;
                                case AUPOLICYCHANGE_RESETENGINE: 
                                                    ResetEngine();
                                                    break;
                                case AUPOLICYCHANGE_RESETCLIENT:
                                                    ghClientHandles.ResetClient();
                                                    break;
                                case AUPOLICYCHANGE_DISABLE:
                                                    DisableAU();
                                                    break;
                            }
                    }
                continue;
        }

        if (AUEVENT_SETTINGS_CHANGE == eventid)
        {
            //go back to begining of loop and recalculate sleep time according to the new settings
            continue;
        }

        if (AUEVENT_REBOOTWARNING_TIMEOUT == eventid)
        {
	        AUStopClients(); //stop all clients, non blocking
        	RebootNow();
        	wait.Reset();
        	continue;
        }
        
        DWORD dwState = gpState->GetState();

        if ( (eventid == AUEVENT_STATE_CHANGED) && (dwState == dwLastState) )
        {
            DWORD dwTimeOut;
            DWORD dwTimeOutState;
            UINT index;
            if ( SUCCEEDED(getReminderTimeout(&dwTimeOut, &index))
            		&& SUCCEEDED(getReminderState(&dwTimeOutState)))
            {
            	 if (dwTimeOutState == dwState)
            	 {
	                continue;
            	 }
            }
        }



        switch (dwState)
        	{
        		case AUSTATE_OUTOFBOX:				
        		case AUSTATE_WAITING_FOR_REBOOT:
        		    continue;
        		case AUSTATE_DISABLED: 
                          CancelDownload(); //then process auclt finish event
        		case AUSTATE_DETECT_PENDING:									
        		{		
        		     if ( AUEVENT_WUAUCLT_FINISHED == eventid )
                                {
                                    ProcessClientFinished(wait, hSignaledEvent, TRUE);
                                }
                               continue;
        		}
        		case AUSTATE_DOWNLOAD_COMPLETE:	
                     case AUSTATE_NOT_CONFIGURED:
        		case AUSTATE_DETECT_COMPLETE:
        		case AUSTATE_DOWNLOAD_PENDING:
        		case AUSTATE_INSTALL_PENDING: 
        		{			
                        if ( AUEVENT_WUAUCLT_FINISHED == eventid )
                        {
                            ProcessClientFinished(wait, hSignaledEvent, fAdmin);
                            continue;
                        }
                        
                        BOOL fGetSessionForRemindMe = FALSE;

                        if ( AUEVENT_REMINDER_TIMEOUT == eventid )
                        {
                            // Reminder time is up 														
                            removeReminderKeys();	
                            fGetSessionForRemindMe = TRUE;
                        }                             

                      if (AUEVENT_DO_DIRECTIVE == eventid)
                      {
                                wait.Reset(); //timeout is infinite now
                                DWORD dwCltAction = gpState->GetCltAction();
                                switch (dwCltAction)
                                    {
                                    case AUCLT_ACTION_AUTOINSTALL:
                                    	{
                                    			DWORD dwAdminSessionId;
                                                if (FAILED(LaunchClient(wait, TRUE, &dwAdminSessionId)))
                                                {
                                                	ServiceFinishNotify();
                                                }
                                                break;
                                    	}
                                    case AUCLT_ACTION_SHOWREBOOTWARNING:
                                    	{
                                    			SESSION_STATUS allActiveSessions;
                                                 gpState->SetCltAction(AUCLT_ACTION_NONE); //reset
												 BOOL fInit = allActiveSessions.Initialize(FALSE, TRUE);
												 AUASSERT(fInit);
                                                 allActiveSessions.CacheExistingSessions();
                                                 if (allActiveSessions.CSessions() > 0)
                                                    {
                                                         LaunchRebootWarningClient(wait, allActiveSessions); //wait for client finish next time
                                                    }
                                                 else
                                                    {
                                                         RebootNow();
                                                    }
                                                 allActiveSessions.Clear();
                                                 break;
                                    }
                                   default: 
#ifdef DBG                                
                                                DEBUGMSG("ERROR: should not be here");
                                                ServiceFinishNotify();                                                    
#endif                                    
                                                break;
                                    }                                        
                                continue;
                    }
                    if ( AUEVENT_SCHEDULED_INSTALL == eventid )
                    {
                        if ( ghClientHandles.fClient())
                        {
                            ghClientHandles.ClientShowInstallWarning();
                        }
                        else
                        { 
                            gpState->SetCltAction(AUCLT_ACTION_AUTOINSTALL);
                            wait.Add(AUEVENT_DO_DIRECTIVE); //reenter workclient loop right away
                        }
                        continue;
                    }

                // eventid is one of these: AUEVENT_STATE_CHANGED, AUEVENT_NEW_ADMIN_SESSION, AUEVENT_REMINDER_TIMEOUT
#ifdef DBG                                        
                        AUASSERT(AUEVENT_STATE_CHANGED == eventid 
                        	||AUEVENT_NEW_ADMIN_SESSION == eventid
                        	||AUEVENT_REMINDER_TIMEOUT == eventid
                        	||AUEVENT_RELAUNCH_TIMEOUT == eventid
                        	||AUEVENT_CATALOG_VALIDATED == eventid);
#endif                           

  
                        if (AUEVENT_RELAUNCH_TIMEOUT == eventid)
                        {
                            wait.Reset();//reset time out
                        }
                        if ( !ghClientHandles.fClient() )
                        {//no client process running
                            DEBUGMSG( "WUAUENG Service detected that the client is not running.");

                            if (AvailableSessions() == 0)
                            {		
                                if (gpState->fShouldAutoDownload(FALSE))
                                { //do autodownload if appropriate
                                    StartDownload();
                                    continue;
                                }
                                DEBUGMSG("WUAUENG There is no Administrator Account, waiting for AUACTIVE_ADMIN_SESSION_EVENT to be triggered");					
                                wait.Reset();
                                wait.Add(AUEVENT_NEW_ADMIN_SESSION);
                                continue;
                            }
                            if (AUEVENT_CATALOG_VALIDATED != eventid && gpState->fValidationNeededState())
                            {
                                PostThreadMessage(gdwWorkerThreadId, AUMSG_VALIDATE_CATALOG, 0, 0);
                                wait.Reset();
                                wait.Add(AUEVENT_CATALOG_VALIDATED);
                                DEBUGMSG("WUAUENG needs to validate catalog before launching client");
                                continue;
                            }
                            DEBUGMSG("Trying to launch client");
                            DWORD dwCltSession;
                            HRESULT hr = LaunchClient(wait, FALSE, &dwCltSession, fGetSessionForRemindMe);
                            if (S_FALSE == hr && DWNO_ACTIVE_ADMIN_SESSION_FOUND == dwCltSession)
                            {
                            	DEBUGMSG("WUAUENG There is no Administrator Account, waiting for AUACTIVE_ADMIN_SESSION_EVENT to be triggered");					
                                wait.Reset();
                                wait.Add(AUEVENT_NEW_ADMIN_SESSION);
                                continue;
                            }
                            if (FAILED(hr))
                            {
								ServiceFinishNotify();
								continue;
                            }
                        }
                    break;
                	}
        default:
                //What about the other states, will the service get them?
                DEBUGMSG("WARNING: WUAUENG default dwState=%d", dwState);
                break;				
        }	
    }
done:
   	DEBUGMSG("WUAUENG Exiting Worker Client");	
}


DWORD WINAPI WorkerThread(void * pdata)
{
	CoInitialize(NULL);
	
       WORKER_THREAD_INIT_DATA *pInitData = (WORKER_THREAD_INIT_DATA*) pdata;
	DWORD dwRet = UpdateProc(*pInitData);

	if(FAILED(dwRet))
	{
		DEBUGMSG("WUAUENG pUpdates->m_pUpdateFunc() failed, exiting service");
		(void)ServiceFinishNotify();		
	}
	else if(dwRet == S_OK)
	{	
		DEBUGMSG("WUAUENG Update() finished succesfully");		
	}
	else if(dwRet == S_FALSE)
	{
		DEBUGMSG("WUAUENG Updates() indicated selfupdate");
		(void)ServiceFinishNotify(); //service will reload new wuaueng.dll instead of exiting
	}
	CoUninitialize();

	DEBUGMSG("WUAUENG Exiting WorkerThread");
    return dwRet;
}

#if 0
#ifdef DBG
void DbgDumpSessions(void)
{
	const LPSTR TSStates[] = {
		"Active", "Connected", "ConnectQuery", "Shadow",
		"Disconnected", "Idle", "Listen", "Reset", "Down", "Init"};
			
     PWTS_SESSION_INFO pSessionInfo = NULL;	
     DWORD dwCount;

     DEBUGMSG("DumpSessions starts....");
     if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &dwCount))
        {
            DEBUGMSG("Sessions Count= %d",dwCount);

            for (DWORD dwSession = 0; dwSession < dwCount; dwSession++)
            {	
                WTS_SESSION_INFO SessionInfo = pSessionInfo[dwSession];

                DEBUGMSG("  SessionId =%d, State Id =%d, State = %s",SessionInfo.SessionId, SessionInfo.State, TSStates[SessionInfo.State]);
            }
     }
     DEBUGMSG("DumpSessions end");
}



DWORD WINAPI DbgThread(void * pdata)
{
	DEBUGMSG("WUAUENG Starting Debug thread");
	CoInitialize(NULL);
	while (true)
	{
		DbgDumpSessions();
		if (FServiceFinishedOrWait(ghServiceFinished, 5000))
		{
			DEBUGMSG("DbgThread noticed service finished");
			break;
		}
	}
	CoUninitialize();

	DEBUGMSG("WUAUENG Exiting Debug Thread");
    return 0;
}
#endif
#endif

#ifdef DBG
//=======================================================================
//
//  DebugResetAutoPilot
//
//  Check to see if we want AU to run by itself.
//
//=======================================================================
void DebugResetAutoPilot(void)
{
	DWORD dwAutoPilot;
	
	if ( SUCCEEDED(GetRegDWordValue(TEXT("AutoPilot"), &dwAutoPilot)) &&
		 (0 != dwAutoPilot) )
	{
		SetRegDWordValue(TEXT("AutoPilotIteration"), 0);
	}
}
#endif // DBG


BOOL AllocateAUSysResource(BOOL *pfGPNotificationRegistered)
{
        BOOL fOk = FALSE;

        //Create WindowsUpdate Directory if it doesnt already exist
        if(!CreateWUDirectory())
        {
            goto lCleanUp;
        }

       if (NULL == (ghMutex = CreateMutex(NULL, FALSE, NULL)))
        {
            DEBUGMSG("WUAUENG fail to create global mutex");
            goto lCleanUp;
        }

	// Create ghServiceFinished
	if (!FEnsureValidEvent(ghServiceFinished, TRUE, FALSE))
	{	
		DEBUGMSG("WUAUENG FEnsureValidEvent for AUSERVICE_FINISHED_EVENT failed");
		ghServiceFinished = NULL;
		goto lCleanUp;
	}

	if (!FEnsureValidEvent(ghSettingsChanged, FALSE, FALSE)) //auto
	    {
	        DEBUGMSG("WUAUENG FEnsureValidEvent for settings change event failed");
	        ghSettingsChanged = NULL;
	        goto lCleanUp;
	    }

	if (!FEnsureValidEvent(ghPolicyChanged, FALSE, FALSE)) //auto
	    {
	        DEBUGMSG("WUAUENG FEnsureValidEvent for policy change event failed");
	        ghPolicyChanged = NULL;
	        goto lCleanUp;
	    }
	
       if (!(*pfGPNotificationRegistered = RegisterGPNotification(ghPolicyChanged, TRUE)))
        {
            DEBUGMSG("WUAUENG fail to register group policy notification");
            goto lCleanUp;
        }

	
	// Create ghActiveAdminSession
	if (!FEnsureValidEvent(ghActiveAdminSession, FALSE, TRUE))
	{
		DEBUGMSG("WUAUENG FEnsureValidEvent for AUACTIVE_ADMIN_SESSION_EVENT failed");
		ghActiveAdminSession = NULL;
		goto lCleanUp;
	}
	
	// Create ghEngineState
	if (!FEnsureValidEvent(ghEngineState, FALSE, FALSE))
	{
		DEBUGMSG("WUAUENG FEnsureValidEvent for AUENGINE_STATE_CHANGE_EVENT failed");
		ghEngineState = NULL;
		goto lCleanUp;
	}
	
	//Create ghServiceDisabled
	//fixcode: ghServiceDisabled could really be removed
	if (!FEnsureValidEvent(ghServiceDisabled, TRUE, FALSE))
	{	
		DEBUGMSG("WUAUENG FEnsureValidEvent for ghServiceDisabled failed\n");
		ghServiceDisabled = NULL;
		goto lCleanUp;
	}
	// Create ghNotifyClient
	if (!FEnsureValidEvent(ghNotifyClient, FALSE, FALSE))
	{	
		DEBUGMSG("WUAUENG FEnsureValidEvent for ghNotifyClient failed\n");
		ghNotifyClient = NULL;
		goto lCleanUp;
	}

	// Create ghValidateCatalog
	if (!FEnsureValidEvent(ghValidateCatalog, FALSE, FALSE))
	{	
		DEBUGMSG("WUAUENG FEnsureValidEvent for ghValidateCatalog failed\n");
		ghValidateCatalog = NULL;
		goto lCleanUp;
	}

	if (!FEnsureValidEvent(ghWorkerThreadMsgQueueCreation, FALSE,FALSE))
	{
		DEBUGMSG("WUAUENG FEnsureValidEvent for ghWorkerThreadMsgQueueCreation failed");
		ghWorkerThreadMsgQueueCreation = NULL;
		goto lCleanUp;
	}
	
       fOk = TRUE;
       
lCleanUp:
        return fOk;
}

void ReleaseAUSysResource(BOOL fGPNotificationRegistered)
{
    SafeCloseHandleNULL(ghMutex);
	SafeCloseHandleNULL(ghServiceFinished);	
	SafeCloseHandleNULL(ghActiveAdminSession);		
	SafeCloseHandleNULL(ghEngineState);
	SafeCloseHandleNULL(ghServiceDisabled);
	SafeCloseHandleNULL(ghNotifyClient);
	SafeCloseHandleNULL(ghValidateCatalog);
	SafeCloseHandleNULL(ghSettingsChanged);
	SafeCloseHandleNULL(ghWorkerThreadMsgQueueCreation);
	if (NULL != ghPolicyChanged)
        {
            if ( fGPNotificationRegistered)
                {
                UnregisterGPNotification(ghPolicyChanged); //handled closed as well
                }
            SafeCloseHandleNULL(ghPolicyChanged);
        }
}

    
///////////////////////////////////////////////////////////////////////////////////////////////////
// return S_FALSE when selfupdate happened before wizard is shown
// return S_OK if AU last state processing is done successfully
// 
HRESULT InitAUEngine(WORKER_THREAD_INIT_DATA *pinitData)
{
     HRESULT hr;

    if (FAILED(hr = HrCreateNewCatalog()))
    {
        DEBUGMSG("Fail to create new catalog with error %#lx", hr);
        goto done;
    }
    if (!AUCatalog::InitStaticVars())
	{
		DEBUGMSG("OUT OF MEMORY and Fail to initialize catalog static variable");
		hr = E_OUTOFMEMORY;
		goto done;
	}

    ProcessInitialState(pinitData);
    srand(GetTickCount());
done:
    return hr;
}

void UninitAUEngine(void)
{
		AUCatalog::UninitStaticVars();
    	SafeDeleteNULL(gpAUcatalog);
}

BOOL WINAPI RegisterServiceVersion(DWORD dwServiceVersion, DWORD *pdwEngineVersion)
{
    BOOL fIsServiceVersionSupported = TRUE;
    if(NULL == pdwEngineVersion)
        return FALSE;

    gdwServiceVersion = dwServiceVersion;
    *pdwEngineVersion = AUENGINE_VERSION;
    
    switch(gdwServiceVersion)
    {
    case AUSRV_VERSION_1:
        break;
    default:
        fIsServiceVersionSupported = FALSE;
        break;
    }
    return fIsServiceVersionSupported;
}


BOOL WINAPI GetEngineStatusInfo (void *pEngineInfo)
{
    BOOL fIsServiceVersionSupported = TRUE;
    AUENGINEINFO_VER_1 *pEngInfo1 = NULL;

    if(pEngineInfo == NULL)
        return FALSE;    

    switch(gdwServiceVersion)
    {
    case AUSRV_VERSION_1:
        pEngInfo1 =  (AUENGINEINFO_VER_1*)pEngineInfo;
        pEngInfo1->hServiceStatus = ghMyServiceStatus;
        pEngInfo1->serviceStatus = gMyServiceStatus;
        break;

    default:
        //If service version is -1 or any unsupported version
        fIsServiceVersionSupported = FALSE;
        break;
    }
    return fIsServiceVersionSupported;
}


HRESULT WINAPI ServiceMain(DWORD /*dwNumServicesArg*/, 
						LPWSTR * /*lpServiceArgVectors*/,
						AUSERVICEHANDLER pfnServiceHandler,
						BOOL fJustSelfUpdated)
{
    HMODULE hmodTransport = NULL;
    BOOL fUpdateObjectRegistered = FALSE;
    BOOL fGPNotificationRegistered = FALSE;
    BOOL fCOMInited = FALSE;
    Updates *pUpdates  = NULL;
    HRESULT hr = S_OK;
#ifdef DBG
	DebugResetAutoPilot();
#endif

	if (!gAdminSessions.Initialize(TRUE, FALSE))
	{
		DEBUGMSG("FAILED to initialize gAdminSessions");
		hr = E_FAIL;
		goto lCleanUp;
	}
       if (NULL == (g_pGlobalSchemaKeys= new CSchemaKeys))
      	{
      		hr = E_OUTOFMEMORY;
      		goto lCleanUp;
       }

	ZeroMemory(&gMyServiceStatus, sizeof(gMyServiceStatus));

	ghMyServiceStatus = RegisterServiceCtrlHandlerEx(AU_SERVICE_NAME, pfnServiceHandler, NULL);
	if(ghMyServiceStatus == (SERVICE_STATUS_HANDLE)0)
	{
        DEBUGMSG("FAILED to retrieve the service handle");
		hr =  E_FAIL;
		goto lCleanUp;
	}
        DEBUGMSG("WUAUENG Service handler Registered");
        
	gMyServiceStatus.dwServiceType 			= SERVICE_WIN32_SHARE_PROCESS;
	gMyServiceStatus.dwCurrentState 		= SERVICE_START_PENDING;
	gMyServiceStatus.dwCheckPoint			= 1;      
	gMyServiceStatus.dwWaitHint             = 15000;

    if (IsWin2K())
    {
        gMyServiceStatus.dwControlsAccepted		= SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    }
    else
    {
        gMyServiceStatus.dwControlsAccepted		= SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_SESSIONCHANGE;
    }

    // when RegisterServiceCtrlHandler is called, SCM will initialize the status to be
    // SERVICE_START_PENDING and checkpoint==0. So increment this to let it know
    // that we're making progress.
	SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
    DEBUGMSG("WUAUENG service status set to SERVICE_START_PENDING");

	//if need to exit service for some particuliar reason, e.g. during setup, exit here

	// Initialization
	fCOMInited = SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED));

    // 
    // fix for security bug 563069 -- annah
    // Set Security for COM in Win2k as the default is not IDENTIFY
    //
    if (IsWin2K())
    {
        hr = CoInitializeSecurity(
                        NULL,                       // pSecDesc
                        -1,                         // cAuthSvc
                        NULL,                       // asAuthSvc
                        NULL,                       // pReserved
                        RPC_C_AUTHN_LEVEL_PKT,      // dwAuthnLevel
                        RPC_C_IMP_LEVEL_IDENTIFY,   // dwImpLevel
                        NULL,                       // pReserved2
                        EOAC_NO_CUSTOM_MARSHAL | EOAC_DISABLE_AAA,
                        NULL );          

        // it is possible that svchost already set the security or another thread in this process, 
        // so we don't want to fail if we're just late.
        if (FAILED(hr) && hr != RPC_E_TOO_LATE)
        {
            DEBUGMSG("WUAUENG Failed in call to CoInitializeSecurity");
            goto lCleanUp;
        }
    }

	if (NULL == (pUpdates = new Updates()))
	{
		hr = E_OUTOFMEMORY;
		goto lCleanUp;
	}

	DWORD dwClassToken;
	ITypeLib *pUpdatesTypeLib;

	//fixcode: this needs to be done in setup code
	if ( FAILED(hr = LoadTypeLibEx(_T("wuaueng.dll"), REGKIND_REGISTER, &pUpdatesTypeLib)) )
	    {
			goto lCleanUp;
	    }
	pUpdatesTypeLib->Release();

	if ( FAILED(hr = CoRegisterClassObject(__uuidof(Updates),
			      		pUpdates,
			     		CLSCTX_LOCAL_SERVER,
			      		REGCLS_MULTIPLEUSE,
			      		&dwClassToken)) )
	{
		goto lCleanUp;
	}

	fUpdateObjectRegistered = TRUE;
       DEBUGMSG("WUAUENG Update class object Registered");

	ghClientHandles.InitHandle();

       if (!AllocateAUSysResource(&fGPNotificationRegistered))
        {
            hr = E_FAIL;
            goto lCleanUp;
        }
       
       DEBUGMSG("WUAUENG group policy notification registered");

	gMyServiceStatus.dwCurrentState	= SERVICE_RUNNING;
	gMyServiceStatus.dwCheckPoint	= 0;
	gMyServiceStatus.dwWaitHint     = 0;

	SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
        DEBUGMSG("Setting status to SERVICE_RUNNING");


       if ( FAILED(hr = CAUState::HrCreateState()) )
       {
   		goto lCleanUp;
   	}

   	if ( fJustSelfUpdated )
	{
		TCHAR szOldDll[MAX_PATH+1];

		gPingStatus.PingSelfUpdate(TRUE, URLLOGSTATUS_Success, 0);
		// if we just self updated, delete the old wuaueng.bak
		UINT ulen = GetSystemDirectory(szOldDll, ARRAYSIZE(szOldDll));
		if (0 == ulen || ulen >= ARRAYSIZE(szOldDll))
		{
			DEBUGMSG("WUAUENG fail to get system directory");
			goto lCleanUp;
		}

		if (FAILED(PathCchAppend(szOldDll, ARRAYSIZE(szOldDll), _T("wuaueng.bak"))) ||
			!DeleteFile(szOldDll))
		{
			DEBUGMSG("WUAUENG couldn't delete unused %S", szOldDll);		
		}
	}

	DEBUGMSG("WUAUENG Service Main sleeping first 60 seconds");	

	// Sleep 60 seconds before doing anything		
     if (FServiceFinishedOrWait(ghServiceFinished, dwTimeToWait(AU_ONE_MIN)))
	{
		DEBUGMSG("WUAUENG Service Stopping or Shutdown in first %d seconds", AU_ONE_MIN);
		goto lCleanUp;
	}
    //
    // If this is win2k, we will be receiving logon/logoff notifications through SENS, not SCM.
    // We need to subscribe to the events during initialization, then.
    //
    if (IsWin2K())
    {
        DEBUGMSG("WUAUENG Activating SENS notifications");
        hr = ActivateSensLogonNotification();
        if (FAILED(hr))
        {
            DEBUGMSG("WUAUENG Service failed to activate logon notifications... Error code is %x. Aborting.", hr);
            goto lCleanUp;
        }
    }

    gAdminSessions.CacheExistingSessions();	

	DEBUGMSG("Svc Worker thread enabled, beginning update process");

    // an optimiziation- load winhttp51.dll here so we don't keep loading & 
    //  unloading it later as needed cuz constant loading / unloading dlls
    //  can cause perf / memory leak issues on certain platforms.
    // In theory, we should just bail if this fails because we only want to
    //  proceed if we're going to use winhttp.dll
    hmodTransport =  LoadLibraryFromSystemDir(c_szWinHttpDll);

    WORKER_THREAD_INIT_DATA initData;
    if (FAILED(hr = InitAUEngine(&initData)))
    { //selfupdated or error
        goto lCleanUp;
    }

	hWorkerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WorkerThread, (LPVOID)&initData, 0, &gdwWorkerThreadId);
	DEBUGMSG("WUAUENG wait for worker thread to create its message queue ......");
	WaitForSingleObject(ghWorkerThreadMsgQueueCreation, INFINITE);
	(void)WorkerClient();
	DWORD dwRet = WaitForSingleObject(hWorkerThread,	// we can't stop until hWorkerThread exits
								INFINITE);

	gdwWorkerThreadId = -1;
	if ( WAIT_OBJECT_0 != dwRet || 
		!GetExitCodeThread(hWorkerThread, (LPDWORD)&hr /* the DWORD is actually an HRESULT */)
		 || (E_FAIL == hr) )
	{
		DEBUGMSG("Worker thread returned a failure, WaitForSingleObject() failed or we couldn't get its exit code");
		hr = E_FAIL;
	}
	else
	{
		DEBUGMSG("Svc Worker thread returned, ret=%#lx", hr);
	}
		
lCleanUp:
    UninitAUEngine();
    if (hmodTransport != NULL)
		FreeLibrary(hmodTransport);

	if (fUpdateObjectRegistered)
    {
        CoRevokeClassObject(dwClassToken);
    }
   
	ReleaseAUSysResource(fGPNotificationRegistered);

	SafeDelete(pUpdates);
	SafeDeleteNULL(gpState);

	if (IsWin2K())
	{
	    DEBUGMSG("WUAUENG Deactivating SENS notifications");
	    DeactivateSensLogonNotification();
	}

	gAdminSessions.Clear();
	if (fCOMInited) 
	{
		CoUninitialize();
	}

	SafeDelete(g_pGlobalSchemaKeys);
	CleanupDownloadLib();

    //If it's an old wuauserv version, stop the service
	if ( S_FALSE != hr && gdwServiceVersion == -1)
	{		
		gMyServiceStatus.dwCurrentState	= SERVICE_STOPPED;
		//gMyServiceStatus.dwCheckPoint	= 0;
		//gMyServiceStatus.dwWaitHint	= 0;
		SetServiceStatus(ghMyServiceStatus, &gMyServiceStatus);
	}
	else
	{	//selfupdate succeed
		//PingStatus::ms_ServicePingSelfUpdateStatus(PING_STATUS_CODE_SELFUPDATE_PENDING);
	}

	DEBUGMSG("WUAUENG ServiceMain exits. Error code is %x", hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\prsheet.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       prsheet.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#include "shellapi.h"
#include "htmlhelp.h"
#pragma hdrstop

#define IDH_LETWINDOWS					3000
#define IDH_AUTOUPDATE_OPTION1			3001
#define IDH_AUTOUPDATE_OPTION2			3002
#define IDH_AUTOUPDATE_OPTION3			3003
#define IDH_DAYDROPDOWN					3004
#define IDH_TIMEDROPDOWN				3005
#define IDH_AUTOUPDATE_RESTOREHIDDEN	3006
#define IDH_NOHELP						-1

const TCHAR g_szAutoUpdateItems[]     = TEXT("AutoUpdateItems");

//
// Create a structure for Updates Object data.  This structure
// is used to pass data between the property page and the
// Updates Object thread.  Today all we use is the "option" value 
// but there may be more later.
//
enum UPDATESOBJ_DATA_ITEMS
{
    UODI_OPTION = 0x00000001,
    UODI_ALL    = 0xFFFFFFFF
};

struct UPDATESOBJ_DATA
{
    DWORD fMask;     // UPDATESOBJ_DATA_ITEMS mask
    AUOPTION Option;  // Updates option setting.
};


//
// Private window message sent from the Updates Object thread proc
// to the property page telling the page that the object has been
// initialized.  
//
//      lParam - points to a UPATESOBJ_DATA structure containing 
//               the initial configuration of the update's object with
//               which to initialize the UI.  If wParam is 0, this 
//               may be NULL.
//
//      wParam - BOOL (0/1) indicating if object intialization was 
//               successful or not.  If wParam is 0, lParam may be NULL.
// 
const UINT PWM_INITUPDATESOBJECT = WM_USER + 1;
//
// Message sent from the property page to the Updates Object thread
// to tell it to configure the Auto Updates service.  
//
//      lParam - points to a UPDATESOBJ_DATA structure containing the 
//               data to set.
//
//      wParam - Unused.  Set to 0.
//
const UINT UOTM_SETDATA = WM_USER + 2;


//
// Message cracker for WM_HELP.  Not sure why windowsx.h doesn't have one.
//
// void Cls_OnHelp(HWND hwnd, HELPINFO *pHelpInfo)
//
#define HANDLE_WM_HELP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HELPINFO *)(lParam)))
#define FORWARD_WM_HELP(hwnd, pHelpInfo, fn) \
    (void)(fn)((hwnd), WM_HELP, (WPARAM)0, (LPARAM)pHelpInfo)

//
// Message cracker for PWM_INITUPDATESOBJECT.
//
#define HANDLE_PWM_INITUPDATESOBJECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (UPDATESOBJ_DATA *)(lParam)))


class CAutoUpdatePropSheet : public IShellExtInit, 
                             public IShellPropSheetExt
{
    public:
        ~CAutoUpdatePropSheet(void);
        //
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);
        //
        // IShellExtInit
        //
        STDMETHOD(Initialize)(LPCITEMIDLIST pidl, LPDATAOBJECT pdtobj, HKEY hkey);
        //
        // IShellPropSheetExt
        //
        STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
        STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
        //
        // Instance generator.
        //
        static HRESULT CreateInstance(HINSTANCE hInstance, REFIID riid, void **ppv);

    private:
        LONG      m_cRef;
        HINSTANCE m_hInstance;
        DWORD     m_idUpdatesObjectThread;
        HANDLE    m_hThreadUpdatesObject;
        
        static const DWORD s_rgHelpIDs[];

        BOOL _OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
        BOOL _OnNotify(HWND hwnd, UINT idFrom, LPNMHDR pnmhdr);
        BOOL _OnPSN_Apply(HWND hwnd);
        BOOL _OnDestroy(HWND hwnd);
        BOOL _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
        BOOL _OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);
        BOOL _OnHelp(HWND hwnd, HELPINFO *pHelpInfo);
        BOOL _OkToDisplayPage(void);
        BOOL _OnInitUpdatesObject(HWND hwnd, BOOL bObjectInit, UPDATESOBJ_DATA *pData);

		//newly added methods : a-josem
		BOOL _EnableOptions(HWND hwnd, BOOL bState);
		BOOL _EnableCombo(HWND hwnd, BOOL bState);
		BOOL _SetDefault(HWND hwnd);
		void _GetDayAndTimeFromUI( HWND hWnd,	LPDWORD lpdwSchedInstallDay,LPDWORD lpdwSchedInstallTime);
		BOOL _FillDaysCombo(HWND hwnd, DWORD dwSchedInstallDay);
		void _OnKeepUptoDate(HWND hwnd);
		static INT_PTR CALLBACK _DlgRestoreProc(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
		void LaunchLinkAction(HWND hwnd, UINT uCtrlId);
		void LaunchHelp(LPCTSTR szURL);
		//end of newly added methods,

        HRESULT _OnOptionSelected(HWND hwnd, int idOption);
        HRESULT _OnRestoreHiddenItems(void);
        HRESULT _EnableControls(HWND hwnd, BOOL bEnable);
        HRESULT _SetHeaderText(HWND hwnd, UINT idsText);
        HRESULT _AddPage(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

        static DWORD WINAPI _UpdatesObjectThreadProc(LPVOID pvParam);
        static HRESULT _QueryUpdatesObjectData(HWND hwnd, IUpdates *pUpdates, UPDATESOBJ_DATA *pData);
        static HRESULT _SetUpdatesObjectData(HWND hwnd, IUpdates *pUpdates, UPDATESOBJ_DATA *pData);
        static UINT CALLBACK _PageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
        static INT_PTR CALLBACK _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
       
        //
        // Allow public creation through instance generator only.
        //
        CAutoUpdatePropSheet(HINSTANCE hInstance);
        //
        // Prevent copy.
        //
        CAutoUpdatePropSheet(const CAutoUpdatePropSheet& rhs);              // not implemented.
        CAutoUpdatePropSheet& operator = (const CAutoUpdatePropSheet& rhs); // not implemented.
};



CAutoUpdatePropSheet::CAutoUpdatePropSheet(
    HINSTANCE hInstance
    ) : m_cRef(1),
        m_hInstance(hInstance),
        m_idUpdatesObjectThread(0),
        m_hThreadUpdatesObject(NULL)
{
    DllAddRef();
}



CAutoUpdatePropSheet::~CAutoUpdatePropSheet(
    void
    )
{
    if (NULL != m_hThreadUpdatesObject)
    {
        CloseHandle(m_hThreadUpdatesObject);
    }
    DllRelease();
}



HRESULT
CAutoUpdatePropSheet::CreateInstance(
    HINSTANCE hInstance,
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    if (NULL == ppvOut)
    {
    	return E_INVALIDARG;
    }
    	
    *ppvOut = NULL;

    CAutoUpdatePropSheet *pSheet = new CAutoUpdatePropSheet(hInstance);
    if (NULL != pSheet)
    {
        hr = pSheet->QueryInterface(riid, ppvOut);
        pSheet->Release();
    }
    return hr;
}



STDMETHODIMP
CAutoUpdatePropSheet::QueryInterface(
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IUnknown == riid ||
        IID_IShellExtInit == riid)
    {
        *ppvOut = static_cast<IShellExtInit *>(this);
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppvOut = static_cast<IShellPropSheetExt *>(this);
    }
    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }
    return hr;
}



STDMETHODIMP_(ULONG)
CAutoUpdatePropSheet::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG)
CAutoUpdatePropSheet::Release(
    void
    )
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


//
// IShellExtInit::Initialize impl.
//
STDMETHODIMP
CAutoUpdatePropSheet::Initialize(
    LPCITEMIDLIST /*pidlFolder*/, 
    LPDATAOBJECT /*pdtobj*/,
    HKEY /*hkeyProgID*/
    )
{
    return NOERROR;
}



//
// IShellPropSheetExt::AddPages impl.
//
STDMETHODIMP
CAutoUpdatePropSheet::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
    HRESULT hr = E_FAIL; // Assume failure.

    if (_OkToDisplayPage())
    {
        hr = _AddPage(lpfnAddPage, lParam);
    }
    return hr;
}



//
// IShellPropSheetExt::ReplacePage impl.
//
STDMETHODIMP
CAutoUpdatePropSheet::ReplacePage(
    UINT /*uPageID*/, 
    LPFNADDPROPSHEETPAGE /*lpfnAddPage*/, 
    LPARAM /*lParam*/
    )
{
    return E_NOTIMPL;
}



//
// Determines if it's OK to display the auto-update prop page.
// Reasons for NOT displaying:
//
//  1. User is not an administrator.
//  2. The "NoAutoUpdate" policy restriction is in place.
//
//
BOOL
CAutoUpdatePropSheet::_OkToDisplayPage(
    void
    )
{
    BOOL bOkToDisplay = TRUE;

    if (!IsNTAdmin(0,0))
    {
        bOkToDisplay = FALSE;
    }
    else
    {
        bOkToDisplay = fAccessibleToAU();
    }
    return bOkToDisplay;
}


//
// Add our page to the property sheet.
//
HRESULT
CAutoUpdatePropSheet::_AddPage(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
    HRESULT hr = E_FAIL;

    PROPSHEETPAGE psp;
    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK;
    psp.hInstance   = m_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_AUTOUPDATE);
    psp.pszTitle    = NULL;
    psp.pfnDlgProc  = CAutoUpdatePropSheet::_DlgProc;
    psp.pfnCallback = CAutoUpdatePropSheet::_PageCallback;
    psp.lParam      = (LPARAM)this;

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&psp);
    if (NULL != hPage)
    {
        if (lpfnAddPage(hPage, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hPage);
        }
    }
    return hr;
}



//
// We implement the page callback to manage the lifetime of the
// C++ object attached to the property page.
// We also use the callback to defer creation of the IUpdates object.
//
UINT CALLBACK
CAutoUpdatePropSheet::_PageCallback(  // [static]
    HWND /*hwnd*/,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    UINT uReturn = 1;
    if (NULL == ppsp)
    {
    	return uReturn;
    }
    CAutoUpdatePropSheet *pThis = (CAutoUpdatePropSheet *)ppsp->lParam;

    switch(uMsg)
    {
        case PSPCB_ADDREF:
            pThis->AddRef();
            break;

        case PSPCB_RELEASE:
            pThis->Release();
            break;
    }
    return uReturn;
}



//
// ISSUE-2000/10/12-BrianAu  Need help IDs.
//
const DWORD CAutoUpdatePropSheet::s_rgHelpIDs[] = {
	IDC_CHK_KEEPUPTODATE,         DWORD(IDH_LETWINDOWS),
    IDC_OPTION1,       DWORD(IDH_AUTOUPDATE_OPTION1),
    IDC_OPTION2,       DWORD(IDH_AUTOUPDATE_OPTION2),
    IDC_OPTION3,       DWORD(IDH_AUTOUPDATE_OPTION3),
	IDC_CMB_DAYS,				  DWORD(IDH_DAYDROPDOWN),
	IDC_CMB_HOURS,				  DWORD(IDH_TIMEDROPDOWN),
	IDC_RESTOREHIDDEN,			  DWORD(IDH_AUTOUPDATE_RESTOREHIDDEN),
	IDC_GRP_OPTIONS,			  DWORD(IDH_NOHELP),
	IDI_AUTOUPDATE,				  DWORD(IDH_NOHELP),
    0, 0
    };




INT_PTR CALLBACK 
CAutoUpdatePropSheet::_DlgProc(   // [static]
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    CAutoUpdatePropSheet *pThis = NULL;
    if (WM_INITDIALOG == uMsg)
    {
        PROPSHEETPAGE *psp = (PROPSHEETPAGE *)lParam;
        pThis = (CAutoUpdatePropSheet *)psp->lParam;
        if (!SetProp(hwnd, g_szPropDialogPtr, (HANDLE)pThis))
        {
            pThis = NULL;
        }
    }
    else
    {
        pThis = (CAutoUpdatePropSheet *)GetProp(hwnd, g_szPropDialogPtr);
    }

    if (NULL != pThis)
    {
        switch(uMsg)
        {
            HANDLE_MSG(hwnd, WM_INITDIALOG,  pThis->_OnInitDialog);
            HANDLE_MSG(hwnd, WM_COMMAND,     pThis->_OnCommand);
            HANDLE_MSG(hwnd, WM_DESTROY,     pThis->_OnDestroy);
            HANDLE_MSG(hwnd, WM_NOTIFY,      pThis->_OnNotify);
            HANDLE_MSG(hwnd, WM_CONTEXTMENU, pThis->_OnContextMenu);
            HANDLE_MSG(hwnd, WM_HELP,        pThis->_OnHelp);
            HANDLE_MSG(hwnd, PWM_INITUPDATESOBJECT, pThis->_OnInitUpdatesObject);
            default:
                break;
        }
    }
    return FALSE;
}


void EnableRestoreDeclinedItems(HWND hWnd, BOOL fEnable)
{
	EnableWindow(GetDlgItem(hWnd, IDC_RESTOREHIDDEN), fEnable);
}

//
// PWM_INITUPDATESOBJECT handler.
// This is called when the Updates Object thread has either successfully
// CoCreated the Updates object or CoCreation has failed.
// It's possible that the Windows Update Service is not running.
// This is how we handle that condition.
//
BOOL
CAutoUpdatePropSheet::_OnInitUpdatesObject(
    HWND hwnd,
    BOOL bObjectInitSuccessful,
    UPDATESOBJ_DATA *pData
    )
{
    if (bObjectInitSuccessful)
    {
    	if (NULL == pData)
    	{
    		return FALSE;
    	}
        //
        // Updates object was created and initialized.  The 
        // pData pointer refers to the initial state information retrieved 
        // from the object.  Initialize the property page.
        //
        _SetHeaderText(hwnd, IDS_HEADER_CONNECTED);
        _EnableControls(hwnd, TRUE);

		EnableRestoreDeclinedItems( hwnd, FHiddenItemsExist());

        switch(pData->Option.dwOption)
        {
            case AUOPTION_AUTOUPDATE_DISABLE:
				CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
				_EnableOptions(hwnd, FALSE);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_UNCHECKED,0);
                break;

            case AUOPTION_PREDOWNLOAD_NOTIFY:
                            CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION1);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

             case AUOPTION_INSTALLONLY_NOTIFY:
                            CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
				_EnableCombo(hwnd, FALSE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

		case AUOPTION_SCHEDULED:
                            CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION3);
				_EnableCombo(hwnd, TRUE);
				SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
                break;

            default:
				_SetDefault(hwnd);
                break;
        }
       _FillDaysCombo(hwnd, pData->Option.dwSchedInstallDay);
       FillHrsCombo(hwnd, pData->Option.dwSchedInstallTime);

        if (pData->Option.fDomainPolicy)
            {
                DisableUserInput(hwnd);
            }
    }
    else
    {
        //
        // Something failed when creating the Updates object.
        // Most likely, the Windows Update service is not running.
        //
        _SetHeaderText(hwnd, IDS_HEADER_UNAVAILABLE);
    }
        
    return FALSE;   
}




//
// WM_INITDIALOG handler.
//
BOOL
CAutoUpdatePropSheet::_OnInitDialog(
    HWND hwnd,
    HWND /*hwndFocus*/,
    LPARAM /*lParam*/
    )
{
    //
    // If the thread is created, the threadproc will call 
    // DllRelease();
    //
    DllAddRef();
    //
    // Disable all page controls and display a message in the 
    // header indicating that we're trying to connect to the
    // Windows Update service.
    //
    _SetHeaderText(hwnd, IDS_HEADER_CONNECTING);
    _EnableControls(hwnd, FALSE);
    //
    // Create the thread on which the Updates object lives.
    // Communication between the thread and the property page is
    // through the messages PWM_INITUPDATESOBJECT and UOTM_SETDATA.
    //
    m_hThreadUpdatesObject = CreateThread(NULL,
                                          0,
                                          _UpdatesObjectThreadProc,
                                          (LPVOID)hwnd,
                                          0,
                                          &m_idUpdatesObjectThread);
    if (NULL == m_hThreadUpdatesObject)
    {
        DllRelease();
    }
    return TRUE;
}



//
// WM_DESTROY handler.
//
BOOL 
CAutoUpdatePropSheet::_OnDestroy(
    HWND hwnd
    )
{
    RemoveProp(hwnd, g_szPropDialogPtr);
    if (0 != m_idUpdatesObjectThread)
    {
        //
        // Terminate the Update Objects thread.
        //
        if (0 != PostThreadMessage(m_idUpdatesObjectThread, WM_QUIT, 0, 0))
        {
            //
            // Wait for normal thread termination.
            //
            WaitForSingleObject(m_hThreadUpdatesObject, 5000);
        }
    }
    return FALSE;
}



//
// WM_COMMAND handler.
//
BOOL
CAutoUpdatePropSheet::_OnCommand(
    HWND hwnd,
    int id,
    HWND /*hwndCtl*/,
    UINT codeNotify
    )
{
	INT Result;
    switch(id)
    {
		case IDC_CHK_KEEPUPTODATE:
			if (BN_CLICKED == codeNotify)
			{
				_OnKeepUptoDate(hwnd);
			}
			break;

        case IDC_OPTION1:
        case IDC_OPTION2:
        case IDC_OPTION3:
            if(BN_CLICKED == codeNotify)
            {
                _OnOptionSelected(hwnd, id);
            }
            break;

		case IDC_CMB_DAYS:
		case IDC_CMB_HOURS:
			if(CBN_SELCHANGE == codeNotify)
			{
				//
				// Enable the "Apply" button.
				//
				SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);

			}
			break;

        case IDC_RESTOREHIDDEN:
				 Result = (INT)DialogBoxParam(m_hInstance, 
                 MAKEINTRESOURCE(IDD_RESTOREUPDATE), 
                 hwnd, 
                 (DLGPROC)CAutoUpdatePropSheet::_DlgRestoreProc, 
                 (LPARAM)NULL);
			if (Result == TRUE)
			{	
				if (SUCCEEDED (_OnRestoreHiddenItems()))			
				{		
					EnableRestoreDeclinedItems( hwnd, FALSE);
				}	
			}
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK CAutoUpdatePropSheet::_DlgRestoreProc(
    HWND hwnd,
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
	if (uMsg == WM_INITDIALOG)
	{
		HWND hwndOwner; 
		RECT rc, rcDlg, rcOwner; 
        // Get the owner window and dialog box rectangles. 
 
		if ((hwndOwner = GetParent(hwnd)) == NULL) 
		{
			hwndOwner = GetDesktopWindow(); 
		}

		GetWindowRect(hwndOwner, &rcOwner); 
		GetWindowRect(hwnd, &rcDlg); 
		CopyRect(&rc, &rcOwner); 

		 // Offset the owner and dialog box rectangles so that 
		 // right and bottom values represent the width and 
		 // height, and then offset the owner again to discard 
		 // space taken up by the dialog box. 
		OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top); 
		OffsetRect(&rc, -rc.left, -rc.top); 
		OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom); 

		 // The new position is the sum of half the remaining 
		 // space and the owner's original position. 
		SetWindowPos(hwnd, 
			HWND_TOP, 
			rcOwner.left + (rc.right / 2), 
			rcOwner.top + (rc.bottom / 2), 
			0, 0,          // ignores size arguments 
			SWP_NOSIZE); 
	}

	if (uMsg == WM_COMMAND)
	{
		switch (LOWORD(wParam))
		{
		case IDOK:
			EndDialog(hwnd, TRUE);
			return TRUE;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			return TRUE;
		}
	}
	return FALSE;
}


//
// WM_NOTIFY handler.
//
BOOL
CAutoUpdatePropSheet::_OnNotify(
    HWND hwnd,
    UINT idFrom,
    LPNMHDR pnmhdr
    )
{
    switch(pnmhdr->code)
    {
        case PSN_APPLY:
            _OnPSN_Apply(hwnd);
            break;

		case NM_RETURN:
		case NM_CLICK:
			if (idFrom == IDC_AUTOUPDATELINK || idFrom == IDC_SCHINSTALLINK)
				LaunchLinkAction(hwnd, idFrom);
			break;

        default:
            break;
    }
    return FALSE;
}

void CAutoUpdatePropSheet::LaunchLinkAction(HWND hwnd, UINT uCtrlId)
{
	switch (uCtrlId)
	{
		case IDC_AUTOUPDATELINK:
			LaunchHelp(gtszAUOverviewUrl);
			break;
		case IDC_SCHINSTALLINK:
			LaunchHelp(gtszAUXPSchedInstallUrl);
			break;
	}
	return;
}


//
// Called when the user presses the "Apply" button or the "OK"
// button when the page has been changed.
//
BOOL
CAutoUpdatePropSheet::_OnPSN_Apply(
    HWND hwnd
    )
{
    HRESULT hr = E_FAIL;
    //
    // Create a structure that can be passed to the Updates Object thread
    // by way of the UOTM_SETDATA thread message.  The thread will free
    // the buffer when it's finished with it.
    //
    UPDATESOBJ_DATA *pData = (UPDATESOBJ_DATA *)LocalAlloc(LPTR, sizeof(*pData));
    if (NULL == pData)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pData->Option.dwSchedInstallDay = -1;
        pData->Option.dwSchedInstallTime = -1;
        pData->fMask    = UODI_ALL;

        static const struct
        {
            UINT idCtl;
            DWORD dwOption;

        } rgMap[] = {
            { IDC_OPTION1,  AUOPTION_PREDOWNLOAD_NOTIFY },
            { IDC_OPTION2,  AUOPTION_INSTALLONLY_NOTIFY },
            { IDC_OPTION3,  AUOPTION_SCHEDULED }
		};

		if 	(IsDlgButtonChecked(hwnd, IDC_CHK_KEEPUPTODATE) == BST_CHECKED)
		{
			//
			// Determine the WAU option based on the radio button configuration.
			//
			for (int i = 0; i < ARRAYSIZE(rgMap); i++)
			{
				if (IsDlgButtonChecked(hwnd, rgMap[i].idCtl) == BST_CHECKED)
				{
					pData->Option.dwOption = rgMap[i].dwOption;
					break;
				}
			}
		}
		else
			pData->Option.dwOption = AUOPTION_AUTOUPDATE_DISABLE;

        if (AUOPTION_SCHEDULED == pData->Option.dwOption)
            {
                _GetDayAndTimeFromUI(hwnd, &(pData->Option.dwSchedInstallDay), &(pData->Option.dwSchedInstallTime));
            }

        if (0 != m_idUpdatesObjectThread)
        {
            if (0 != PostThreadMessage(m_idUpdatesObjectThread,
                                       UOTM_SETDATA,
                                       0,
                                       (LPARAM)pData))
            {
                hr    = S_OK;
                pData = NULL;
            }
        }
        if (NULL != pData)
        {
            LocalFree(pData);
            pData = NULL;
        }
    }
    if (SUCCEEDED(hr))
    {
        //
        // Inform the property sheet the update was successful and
        // disable the "Apply" button.
        //
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        SendMessage(GetParent(hwnd), PSM_UNCHANGED, (WPARAM)hwnd, 0);
    }
    return FALSE;
}



//
// WM_CONTEXTMENU handler.
//
BOOL 
CAutoUpdatePropSheet::_OnContextMenu(
    HWND hwnd, 
    HWND hwndContext, 
    UINT /*xPos*/, 
    UINT /*yPos*/
    )
{
	if ((hwndContext == GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE))||
	(hwndContext == GetDlgItem(hwnd,IDC_OPTION1))||
	(hwndContext == GetDlgItem(hwnd,IDC_OPTION2))||
	(hwndContext == GetDlgItem(hwnd,IDC_OPTION3))||
	(hwndContext == GetDlgItem(hwnd,IDC_CMB_DAYS))||
	(hwndContext == GetDlgItem(hwnd,IDC_CMB_HOURS))||
	(hwndContext == GetDlgItem(hwnd,IDC_RESTOREHIDDEN)))
	{
		HtmlHelp(hwndContext,g_szHelpFile,HH_TP_HELP_CONTEXTMENU,(DWORD_PTR)((LPTSTR)s_rgHelpIDs));
	}
    return FALSE;
}


//
// WM_HELP handler.
//
BOOL 
CAutoUpdatePropSheet::_OnHelp(
    HWND hwnd, 
    HELPINFO *pHelpInfo
    )
{
	if (NULL == pHelpInfo)
	{
		return TRUE;
	}
	if (HELPINFO_WINDOW == pHelpInfo->iContextType)
    {
		if ((pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_OPTION1))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_OPTION2))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_OPTION3))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CMB_DAYS))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_CMB_HOURS))||
			(pHelpInfo->hItemHandle == GetDlgItem(hwnd,IDC_RESTOREHIDDEN))
			)
        HtmlHelp((HWND)pHelpInfo->hItemHandle,
                 g_szHelpFile,
                 HH_TP_HELP_WM_HELP,
                 (DWORD_PTR)((LPTSTR)s_rgHelpIDs));
    }
    return TRUE;
}


//
// Called when user selects one of the 3 options radio buttons.
//
HRESULT
CAutoUpdatePropSheet::_OnOptionSelected(
    HWND hwnd,
    int idOption
    )
{
    const UINT idFirst = IDC_OPTION1;
    const UINT idLast  = IDC_OPTION3;
    CheckRadioButton(hwnd, idFirst, idLast, idOption);

	if (idOption == IDC_OPTION3)
		_EnableCombo(hwnd, TRUE);
	else
		_EnableCombo(hwnd, FALSE);

    //
    // Enable the "Apply" button.
    //
    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);

    return S_OK;
}



//
// Called when the user presses the "Restore Hidden Items" button
//
HRESULT
CAutoUpdatePropSheet::_OnRestoreHiddenItems(
    void
    )
{
    return RemoveHiddenItems() ? S_OK : E_FAIL;
}


//
// Enable or disable all controls on the property page.
// All but the header text control.
//
HRESULT
CAutoUpdatePropSheet::_EnableControls(
    HWND hwnd,
    BOOL bEnable
    )
{
    static const UINT rgidCtls[] = {
		IDC_CHK_KEEPUPTODATE,
        IDC_OPTION1,
        IDC_OPTION2,
        IDC_OPTION3,
        IDC_RESTOREHIDDEN,
        IDC_GRP_OPTIONS,
		IDC_CMB_DAYS,
		IDC_STATICAT,
		IDC_CMB_HOURS,
		IDC_SCHINSTALLINK,
		IDC_AUTOUPDATELINK
        };

    for (int i = 0; i < ARRAYSIZE(rgidCtls); i++)
    {
        EnableWindow(GetDlgItem(hwnd, rgidCtls[i]), bEnable);
    }
    return S_OK;
}


//
// Set the text to the right of the icon.
//
HRESULT 
CAutoUpdatePropSheet::_SetHeaderText(
    HWND hwnd, 
    UINT idsText
    )
{
    HRESULT hr;
    TCHAR szText[300] ;

	//ZeroMemory(szText, sizeof(szText));
    if (0 < LoadString(m_hInstance, idsText, szText, ARRAYSIZE(szText)))
    {
        SetWindowText(GetDlgItem(hwnd, IDC_TXT_HEADER), szText);
        hr = S_OK;
    }
    else
    {
        const DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}

        

//
// This thread is where the Updates object lives.  This allows us to 
// CoCreate the object without blocking the UI.  If the Windows Update
// service is not running, CoCreate can take several seconds.  Without
// placing this on another thread, this can make the UI appear to be
// hung.
//
// *pvParam is the HWND of the property page window.  
//
DWORD WINAPI
CAutoUpdatePropSheet::_UpdatesObjectThreadProc(   // [static]
    LPVOID pvParam
    )
{
    HWND hwndClient = (HWND)pvParam;
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        IUpdates *pUpdates;
        hr = CoCreateInstance(__uuidof(Updates),
                              NULL, 
                              CLSCTX_LOCAL_SERVER,
                              IID_IUpdates,
                              (void **)&pUpdates);
        if (SUCCEEDED(hr))
        {
            //
            // Query the object for it's current data and send it
            // to the property page.
            //
            UPDATESOBJ_DATA data;
            data.fMask    = UODI_ALL;

            HRESULT hrQuery = _QueryUpdatesObjectData(hwndClient, pUpdates, &data);
            SendMessage(hwndClient, PWM_INITUPDATESOBJECT, (WPARAM)SUCCEEDED(hrQuery), (LPARAM)&data);
            //
            // Now sit waiting for thread messages from the UI.  We receive
            // either messages to configure Windows Update or a 
            // WM_QUIT indicating it's time to go.
            // 
            bool bDone = false;
            MSG msg;
            while(!bDone)
            {
                if (0 == GetMessage(&msg, NULL, 0, 0))
                {
                    bDone = true;
                }
                else switch(msg.message)
                {
                    case UOTM_SETDATA:
                        if (NULL != msg.lParam)
                        {
                            UPDATESOBJ_DATA *pData = (UPDATESOBJ_DATA *)msg.lParam;
                            _SetUpdatesObjectData(hwndClient, pUpdates, pData);
                            LocalFree(pData);
                        }
                        break;
        
                    default:
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                        break;
                }
            }
            pUpdates->Release();
        }
        CoUninitialize();
    }
    if (FAILED(hr))
    {
        //
        // Something failed.  Notify the property page.
        // Most likely, the Windows Update service is not available.
        // That's the principal case this separate thread is addressing.
        //
        DEBUGMSG("AU cpl fails to create IUpdates object with error %#lx", hr);
        SendMessage(hwndClient, PWM_INITUPDATESOBJECT, FALSE, (LPARAM)NULL);
    }
    //
    // DllAddRef() was called before CreateThread in _OnInitDialog.
    //
    DllRelease();
    return 0;
}



HRESULT
CAutoUpdatePropSheet::_QueryUpdatesObjectData(  // [static]
    HWND /*hwnd*/,
    IUpdates *pUpdates,
    UPDATESOBJ_DATA *pData
    )
{
    HRESULT hr = S_OK;
    if (NULL == pData)
    {
    	return E_INVALIDARG;

    }
    if (UODI_OPTION & pData->fMask)
    {
        hr = pUpdates->get_Option(&(pData->Option));
        if (FAILED(hr))
        {
        	DEBUGMSG("AU cpl fail to get option with error %#lx", hr);
            //
            // ISSUE-2000/10/18-BrianAu  Display error UI?
            //
        }
    }
    return hr;
}


HRESULT
CAutoUpdatePropSheet::_SetUpdatesObjectData(  // [static]
    HWND /*hwnd*/,
    IUpdates *pUpdates,
    UPDATESOBJ_DATA *pData
    )
{
    HRESULT hr = S_OK;
    if (NULL == pData)
    {
    	return E_INVALIDARG;
    }
    if (UODI_OPTION & pData->fMask)
    {
        hr = pUpdates->put_Option(pData->Option);
    }
    return hr;
}

//
// Exported instance generator.  External coupling is reduced
// to this single function.
//
HRESULT
CAutoUpdatePropSheet_CreateInstance(
    HINSTANCE hInstance,
    REFIID riid,
    void **ppv
    )
{
    return CAutoUpdatePropSheet::CreateInstance(hInstance, riid, ppv);
}


void CAutoUpdatePropSheet::_GetDayAndTimeFromUI( 
	HWND hWnd,
	LPDWORD lpdwSchedInstallDay,
	LPDWORD lpdwSchedInstallTime
)
{
	HWND hComboDays = GetDlgItem(hWnd,IDC_CMB_DAYS);
	HWND hComboHrs = GetDlgItem(hWnd,IDC_CMB_HOURS);
	LRESULT nDayIndex = SendMessage(hComboDays,CB_GETCURSEL,0,(LPARAM)0);
	LRESULT nTimeIndex = SendMessage(hComboHrs,CB_GETCURSEL,0,(LPARAM)0);

	*lpdwSchedInstallDay = (DWORD)SendMessage(hComboDays,CB_GETITEMDATA, nDayIndex, (LPARAM)0);
	*lpdwSchedInstallTime = (DWORD)SendMessage(hComboHrs,CB_GETITEMDATA, nTimeIndex, (LPARAM)0);
}


BOOL CAutoUpdatePropSheet::_FillDaysCombo(HWND hwnd, DWORD dwSchedInstallDay)
{
    return FillDaysCombo(m_hInstance, hwnd, dwSchedInstallDay, IDS_STR_EVERYDAY, IDS_STR_SATURDAY);
}

void CAutoUpdatePropSheet::_OnKeepUptoDate(HWND hwnd)
{
	LRESULT lResult = SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_GETCHECK,0,0);
	
	//
    // Enable the "Apply" button.
    //
    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);

	if (lResult == BST_CHECKED)
	{
		_EnableOptions(hwnd, TRUE);
	}
	else if (lResult == BST_UNCHECKED)
	{
		_EnableOptions(hwnd, FALSE);
	}
	/*  //check box is either checked or not
	else
	{
		return FALSE;
	}
	*/
}

BOOL CAutoUpdatePropSheet::_EnableOptions(HWND hwnd, BOOL bState)
{
	EnableWindow(GetDlgItem(hwnd,IDC_OPTION1),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_OPTION2),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_OPTION3),bState);

	if (BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_OPTION3),BM_GETCHECK,0,0))
	{
		_EnableCombo(hwnd, bState);
	}

	return TRUE;
}

BOOL CAutoUpdatePropSheet::_SetDefault(HWND hwnd)
{
	LRESULT lResult = SendMessage(GetDlgItem(hwnd,IDC_CHK_KEEPUPTODATE),BM_SETCHECK,BST_CHECKED,0);
	CheckRadioButton(hwnd, IDC_OPTION1, IDC_OPTION3, IDC_OPTION2);
	return TRUE;
}

BOOL CAutoUpdatePropSheet::_EnableCombo(HWND hwnd, BOOL bState)
{
	EnableWindow(GetDlgItem(hwnd,IDC_CMB_DAYS),bState);
	EnableWindow(GetDlgItem(hwnd,IDC_STATICAT),bState);		
	EnableWindow(GetDlgItem(hwnd,IDC_CMB_HOURS),bState);
	return TRUE;
}

void 
CAutoUpdatePropSheet::LaunchHelp(LPCTSTR szURL)
{
	HtmlHelp(NULL,szURL,HH_DISPLAY_TOPIC,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\tscompat.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  tscompat.h
//
//  Exported prototypes and definitions for module tscompat.cpp 
//
//  10/11/2001   annah   Created
//
//----------------------------------------------------------------------------

// this is a private NT function that doesn't appear to be defined anywhere public
extern "C" 
{
    HANDLE GetCurrentUserTokenW(  WCHAR Winsta[], DWORD DesiredAccess);
}

BOOL WINAPI _WTSQueryUserToken(/* in */ ULONG SessionId, /* out */ PHANDLE phToken);
BOOL _IsTerminalServiceRunning (VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\statusping.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    statusping.cpp
//
//  Creator: PeterWi
//
//  Purpose: status ping back functions
//
//=======================================================================
#include "pch.h"
#pragma hdrstop


PingStatus gPingStatus;

void PingStatus::ReadLiveServerUrlFromIdent(void)
{
	LPTSTR ptszLiveServerUrl;

	if (NULL != (ptszLiveServerUrl = (TCHAR*) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)))
	{
		TCHAR tszIdentFile[MAX_PATH];

		if (SUCCEEDED(GetDownloadPath(tszIdentFile, ARRAYSIZE(tszIdentFile))) &&
			SUCCEEDED(PathCchAppend(tszIdentFile, ARRAYSIZE(tszIdentFile), IDENTTXT)))
		{
			DWORD dwStrLen = GetPrivateProfileString(
								_T("IUPingServer"),
								_T("ServerUrl"),
								_T(""),
								ptszLiveServerUrl,
								INTERNET_MAX_URL_LENGTH,
								tszIdentFile);
			if (0 != dwStrLen &&
				INTERNET_MAX_URL_LENGTH-1 != dwStrLen)	// do this until there's a better way to check for errors
			{
				(void) SetLiveServerUrl(ptszLiveServerUrl);
			}
			else
			{
				DEBUGMSG("PingStatus::ReadLiveServerUrlFromIdent() failed to read server URL from ident");
			}
		}
		free(ptszLiveServerUrl);
	}
}


void PingStatus::PingDetectionSuccess(
						BOOL fOnline,
						UINT cItems)
{
	TCHAR tszMessage[30];

	(void) StringCchPrintfEx(tszMessage, ARRAYSIZE(tszMessage), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("items=%u"), cItems);
	_Ping(
		fOnline,
		URLLOGACTIVITY_Detection,
		URLLOGSTATUS_Success,
		0,
		tszMessage,
		NULL,
		NULL);
}

void PingStatus::PingDetectionFailure(
						BOOL fOnline,
						DWORD dwError,
						LPCTSTR ptszMessage)
{
	_Ping(
		fOnline,
		URLLOGACTIVITY_Detection,
		URLLOGSTATUS_Failed,
		dwError,
		ptszMessage,
		NULL,
		NULL);
}


void PingStatus::PingDownload(
						BOOL fOnline,
						URLLOGSTATUS status,
						DWORD dwError,
						LPCTSTR ptszItemID,
						LPCTSTR ptszDeviceID,
						LPCTSTR ptszMessage)
{
	switch (status)
	{
	case URLLOGSTATUS_Success:
	case URLLOGSTATUS_Failed:
	case URLLOGSTATUS_Declined:
		break;
	default:
		DEBUGMSG("ERROR: PingDownload() invalid parameter");
		return;
	}

	_Ping(
		fOnline,
		URLLOGACTIVITY_Download,
		status,
		dwError,
		ptszMessage,
		ptszItemID,
		ptszDeviceID);
}


void PingStatus::PingDeclinedItem(
						BOOL fOnline,
						URLLOGACTIVITY activity,
						LPCTSTR ptszItemID)
{
	switch (activity)
	{
	case URLLOGACTIVITY_Download:
	case URLLOGACTIVITY_Installation:
		break;
	default:
		DEBUGMSG("ERROR: PingDeclinedItem() invalid activity code");
		return;
	}

	if (NULL == ptszItemID)
	{
		DEBUGMSG("ERROR: PingDeclinedItem() invalid item ID");
		return;
	}

	_Ping(
		fOnline,
		activity,
		URLLOGSTATUS_Declined,
		0x0,
		NULL,
		ptszItemID,
		NULL);
}


///////////////////////////////////////////////////////////////////////////////////
// status:		IN ping status code
// dwError:		IN error code
///////////////////////////////////////////////////////////////////////////////////
void PingStatus::PingSelfUpdate(
						BOOL fOnline,
						URLLOGSTATUS status,
						DWORD dwError)
{
	const TCHAR WUAUENGFILE[] = _T("wuaueng.dll");

	TCHAR tszFileVer[30];
	HRESULT hr;
	size_t cchVerLen;
    LPTSTR ptszFileVersion;

	switch (status)
	{
	case URLLOGSTATUS_Success:
	case URLLOGSTATUS_Failed:
	case URLLOGSTATUS_Pending:
		break;
	default:
		DEBUGMSG("ERROR: PingSelfUpdate() invalid parameter");
		return;
	}

    if (FAILED(hr = StringCchCopyEx(
						tszFileVer,
						ARRAYSIZE(tszFileVer),
						_T("ver="),
						&ptszFileVersion,
						&cchVerLen,
						MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = GetFileVersionStr(
						WUAUENGFILE,
						ptszFileVersion,
						cchVerLen)))
	{
		DEBUGMSG("ERROR: PingSelfUpdate() GetFileVersionStr() failed.");
		return;
	}

	_Ping(
		fOnline,
		URLLOGACTIVITY_SelfUpdate,
		status,
		dwError,
		tszFileVer,
		NULL,	// no item
		NULL);	// no device
}


//----------------------------------------------------------------------
//
// private function to gather common info and perform ping
//
//----------------------------------------------------------------------
void PingStatus::_Ping(
		BOOL fOnline,
		URLLOGACTIVITY activity,
		URLLOGSTATUS status,
		DWORD dwError,
		LPCTSTR ptszMessage,
		LPCTSTR ptszItemID,
		LPCTSTR ptszDeviceID)
{
	HRESULT hr = CUrlLog::Ping(
				fOnline,
				URLLOGDESTINATION_DEFAULT,
				&ghServiceFinished,
				1,
				activity,
				status,
				dwError,
				ptszItemID,
				ptszDeviceID,
				ptszMessage);	// use default base URL and client name
	if (FAILED(hr))
	{
		DEBUGMSG("PingStatus::_Ping() failed to send/queue the request");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\updates.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       updates.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

#pragma hdrstop


/////////////////////////////////////////////////////////////////////////////
//

GENERIC_MAPPING Updates::m_AdminGenericMapping = {

        STANDARD_RIGHTS_READ,                    // Generic read

        STANDARD_RIGHTS_WRITE,                   // Generic write

        STANDARD_RIGHTS_EXECUTE,                 // Generic execute

        STANDARD_RIGHTS_READ |                   // Generic all
        STANDARD_RIGHTS_WRITE |
        STANDARD_RIGHTS_EXECUTE
		};

Updates::Updates()
	: m_pAdminSid(NULL),
	  m_pAdminAcl(NULL),
	  m_refs(0)
{
	m_hEngineMutex = CreateMutex(NULL, FALSE, NULL);	
}

Updates::~Updates()
{
    CloseHandle(m_hEngineMutex);

    if ( NULL != m_pAdminAcl )
    {
        delete m_pAdminAcl;
    }

    if ( NULL != m_pAdminSid )
    {
        FreeSid(m_pAdminSid);
    }
	DEBUGMSG("Updates: CoDisconnectObject");
	if ( FAILED(CoDisconnectObject((IUnknown *)this, 0)) )
	{
		DEBUGMSG("CoDisconnectObject() failed");
	}
}

BOOL Updates::m_fInitializeSecurity(void)
{
    BOOL fStatus;
    ULONG cbAcl;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    fStatus = AllocateAndInitializeSid(
                &ntAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &m_pAdminSid);

    if ( !fStatus )
	{
	DEBUGMSG("Fail to initialize SID with error %d", GetLastError());
        return FALSE;
	}

    cbAcl = sizeof(ACL)
		  + sizeof(ACCESS_ALLOWED_ACE)
		  - sizeof(DWORD) //sizeof(ACCESS_ALLOWED_ACE.SidStart)
		  + GetLengthSid(m_pAdminSid);

    m_pAdminAcl = (PACL) new BYTE[ cbAcl ];

    if ( (NULL == m_pAdminAcl)
        || !InitializeAcl(m_pAdminAcl, cbAcl, ACL_REVISION)
		|| !AddAccessAllowedAce(m_pAdminAcl, ACL_REVISION, STANDARD_RIGHTS_WRITE, m_pAdminSid)
		|| !InitializeSecurityDescriptor(&m_AdminSecurityDesc, SECURITY_DESCRIPTOR_REVISION)
		|| !SetSecurityDescriptorOwner(&m_AdminSecurityDesc, m_pAdminSid, FALSE)
		|| !SetSecurityDescriptorGroup(&m_AdminSecurityDesc, m_pAdminSid, FALSE)
		|| !SetSecurityDescriptorDacl(&m_AdminSecurityDesc, TRUE, m_pAdminAcl, FALSE) )
	{
        if ( NULL != m_pAdminAcl )
		{
			delete m_pAdminAcl;
			m_pAdminAcl = NULL;
			FreeSid(m_pAdminSid);
			m_pAdminSid = NULL;
		}
		return FALSE;
	}

    return TRUE;
}

HRESULT Updates::m_AccessCheckClient(void)
{
    BOOL accessGranted = FALSE;
    DWORD grantedAccess;
    HANDLE clientToken = NULL;
    BYTE privilegeSet[500];                      // Large buffer
    DWORD privilegeSetSize = sizeof(privilegeSet);
    static BOOL fInitSecurity = FALSE;

	if ( !fInitSecurity )
	{
		if ( !(fInitSecurity = m_fInitializeSecurity()) )
		{
		    DEBUGMSG("Fail to initialized SID");
			return E_ACCESSDENIED;
		}
	}

    if (FAILED(CoImpersonateClient()))
	{
        return E_ACCESSDENIED;
	}

    if ( OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &clientToken) )
	{
	    if (FALSE == AccessCheck(
                    &m_AdminSecurityDesc,
                    clientToken,
                    STANDARD_RIGHTS_WRITE,
                    &m_AdminGenericMapping,
                    (PPRIVILEGE_SET) privilegeSet,
                    &privilegeSetSize,
                    &grantedAccess,
                    &accessGranted))
	        {
                    DEBUGMSG("Fail to call AccessCheck() with error %d", GetLastError());
	        }
	}

    if ( clientToken != NULL )
	{
        CloseHandle( clientToken );
	}

    if (FAILED(CoRevertToSelf()))
    {
    	return  E_ACCESSDENIED;;
    }

    return (accessGranted )? S_OK : E_ACCESSDENIED;
}

STDMETHODIMP Updates::QueryInterface(REFIID riid, void **ppvObject)
{
	if (NULL == ppvObject)
	{
		return E_INVALIDARG;
	}
	if(riid == IID_IUnknown ||
	   riid == IID_IClassFactory ||
	   riid == IID_IUpdates)
	{
		*ppvObject = this;
		AddRef();
	}
	else
	{
		*ppvObject = NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

ULONG __stdcall Updates::AddRef()
{
    long cRef = InterlockedIncrement(&m_refs);
	DEBUGMSG("Updates AddRef = %d", cRef);
	return cRef;	
}

ULONG __stdcall Updates::Release()
{
    long cRef = InterlockedDecrement(&m_refs);
	DEBUGMSG("Updates Release = %d", cRef);
	return cRef;
}
STDMETHODIMP Updates::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
	HRESULT hr = m_AccessCheckClient();
	
	if ( FAILED(hr) )
	{
		return hr;
	}

	if(pUnkOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION;
	}

	if (NULL == ppvObject)
	{
		return E_INVALIDARG;
	}

	if(riid == IID_IUnknown ||
	   riid == IID_IClassFactory ||
	   riid == IID_IUpdates)
	{
		*ppvObject = this;
		AddRef();
	}
	else
	{
		*ppvObject = NULL;
		return E_NOINTERFACE;
	}
	return S_OK;
}

STDMETHODIMP Updates::LockServer(BOOL /*bFlag*/)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	return E_FAIL;
}

STDMETHODIMP Updates::AvailableSessions(UINT *pcSess)
{
	HRESULT hr = m_AccessCheckClient();	
	
	if ( FAILED(hr))
	{
		return hr;
	}	
	if (NULL == pcSess)
	{
		return E_INVALIDARG;
	}	

	*pcSess = ::AvailableSessions();

    //DEBUGMSG("WUAUENG Updates::AvailableSessions was called and return value is %d", *pcSess);

	return S_OK;
}


STDMETHODIMP Updates::get_State(/*[out, retval]*/ AUSTATE *pAuState)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	if (NULL == pAuState)
	{
		return E_INVALIDARG;
	}	
	WaitForSingleObject(m_hEngineMutex, INFINITE);
	pAuState->dwState = gpState->GetState();
	pAuState->fDisconnected = gpState->fDisconnected();
	pAuState->dwCltAction = gpState->GetCltAction();
	gpState->SetCltAction(AUCLT_ACTION_NONE); //once client read it, reset
	ReleaseMutex(m_hEngineMutex);

	return S_OK;
}

STDMETHODIMP Updates::GetUpdatesList(/*[out]*/ VARIANT *pUpdates)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}
	
	DEBUGMSG("WUAUENG Getting updates list");
	if ( NULL == pUpdates )
	{
		return E_INVALIDARG;
	}

	WaitForSingleObject(m_hEngineMutex, INFINITE);
	hr = ::GetUpdatesList(pUpdates);
	ReleaseMutex(m_hEngineMutex);
	return hr;
}



STDMETHODIMP Updates::GetNotifyData(/*[out]*/ CLIENT_NOTIFY_DATA *pNotifyData)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}
	
	DEBUGMSG("WUAUENG Getting client notify data");
	if ( NULL == pNotifyData )
	{
		return E_INVALIDARG;
	}

	WaitForSingleObject(m_hEngineMutex, INFINITE);
	*pNotifyData = gClientNotifyData;
	ReleaseMutex(m_hEngineMutex);
	return hr;
}

/* fixcode, only used by client, could get rid of and add VARIANT to ClientMessage()*/
STDMETHODIMP Updates::SaveSelections(/*[in]*/ VARIANT vUpdates)
{
	HRESULT hr = m_AccessCheckClient();

       DEBUGMSG("Updates::SaveSelections start");
	if ( FAILED(hr) )
	{
		goto done;
	}

	DEBUGMSG("WUAUENG Saving selections, state is %d", gpState->GetState());
	if (vUpdates.vt != (VT_ARRAY | VT_VARIANT))
	{
		DEBUGMSG("WUAUENG invalid variant list");
		return E_INVALIDARG;
	}
	WaitForSingleObject(m_hEngineMutex, INFINITE);
    ::saveSelection(&vUpdates);
    hr = S_OK;
	ReleaseMutex(m_hEngineMutex);
done:
       DEBUGMSG("Updates::SaveSelections end");
	return hr;
}

STDMETHODIMP Updates::StartDownload(void)
{
	DEBUGMSG("WUAUENG updates->StartDownload called");

	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	WaitForSingleObject(m_hEngineMutex, INFINITE);
	hr = ::StartDownload();
	ReleaseMutex(m_hEngineMutex);
	return hr;
}

STDMETHODIMP Updates::GetDownloadStatus(UINT *pPercentage, DWORD *pStatus)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	if ((NULL == pPercentage) || (NULL == pStatus))
	{
		return E_INVALIDARG;
	}
	WaitForSingleObject(m_hEngineMutex, INFINITE);
	hr = ::GetDownloadStatus(pPercentage, pStatus);
	ReleaseMutex(m_hEngineMutex);
	return hr;
}

STDMETHODIMP Updates::SetDownloadPaused(/*[in]*/ BOOL bPaused)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	return PauseDownload(bPaused);
}

STDMETHODIMP Updates::ClientMessage(/*[in]*/ UINT msg)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	// fixcode is this whole interface just one big security whole? what about other
	// routines.  can't anyone call them?
	switch (msg)
	{
		case AUMSG_PRE_INSTALL:
			DEBUGMSG("WUAUENG ClientMessage(AUMSG_PRE_INSTALL)");
            DEBUGMSG("WUAUENG Msg:Install, State->Install Pending");
            gpState->SetState(AUSTATE_INSTALL_PENDING);      // is there any benefit to doing this?
			break;
	default:
		DEBUGMSG("WUAUENG ClientMessage(!!unknown!!)");
		break;
	}

	return S_OK;
}

STDMETHODIMP Updates::get_Option(AUOPTION * pVal)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	if (NULL == pVal)
	{
		return E_INVALIDARG;
	}

	if (NULL == gpState)
	{
	        return E_FAIL;
	}
	
    *pVal = gpState->GetOption();
    return S_OK;
}

STDMETHODIMP Updates::put_Option(AUOPTION    val)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

    AUOPTION CurrOption = gpState->GetOption();

    if ( FAILED(hr = gpState->SetOption(val)) )
    {
        return hr;
    }
            
	// if asking to disable, post msg
	if ( (AUOPTION_AUTOUPDATE_DISABLE == val.dwOption) && (CurrOption.dwOption != val.dwOption) )
	{
                DEBUGMSG("AU service disabled");
                DisableAU();
	}
	// else if asking to enable, post msg
	else if ((AUOPTION_AUTOUPDATE_DISABLE == CurrOption.dwOption) && (val.dwOption != CurrOption.dwOption)
	    || gpState->GetState() < AUSTATE_DETECT_PENDING)
	{
	    ResetEngine();
	}

       if (CurrOption.dwOption != val.dwOption
        || (AUOPTION_SCHEDULED == val.dwOption  
            && (CurrOption.dwSchedInstallDay != val.dwSchedInstallDay 
                || CurrOption.dwSchedInstallTime != val.dwSchedInstallTime)))
       {
            SetEvent(ghSettingsChanged);
       }
	return S_OK;
}
	
STDMETHODIMP Updates::ConfigureAU()
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	WaitForSingleObject(m_hEngineMutex, 10000);
	if ( AUSTATE_NOT_CONFIGURED == gpState->GetState() )
	{	
            PostThreadMessage(gdwWorkerThreadId, AUMSG_EULA_ACCEPTED, 0, 0);
	}
	ReleaseMutex(m_hEngineMutex);
	return S_OK;
}


STDMETHODIMP Updates::get_EvtHandles(DWORD dwCltProcId, AUEVTHANDLES *pauevtHandles)
{
	HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	WaitForSingleObject(ghMutex, INFINITE); // make sure proc id has been populated
       DWORD dwProcId = ghClientHandles.GetProcId();
       ReleaseMutex(ghMutex);
       
	if (dwProcId != dwCltProcId)
		{
		DEBUGMSG("WUAUENG Unauthorized client %d trying to get event handles for real client %d", dwCltProcId, dwProcId);
		return E_ACCESSDENIED;
		}

	if (NULL == pauevtHandles)
	{
		DEBUGMSG("WUAUENG GetEvtHandles invalid argument");
		return E_INVALIDARG;
	}
	WaitForSingleObject(m_hEngineMutex, INFINITE);
	hr = ::GetEvtHandles(pauevtHandles);
	ReleaseMutex(m_hEngineMutex);
	return hr;
}


STDMETHODIMP Updates::GetInstallXML(/*[out]*/ BSTR *pbstrCatalogXML, /*[out]*/ BSTR *pbstrDownloadXML)
{
    DEBUGMSG("Updates::GetInstallXML");

    HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		goto done;
	}

	if (NULL == pbstrCatalogXML || NULL == pbstrDownloadXML)
	{
		return E_INVALIDARG;
	}

	WaitForSingleObject(m_hEngineMutex, INFINITE);

    hr = ::GetInstallXML(pbstrCatalogXML, pbstrDownloadXML);

    ReleaseMutex(m_hEngineMutex);
done:
	return hr;
}

STDMETHODIMP Updates::LogEvent(/*[in]*/ WORD wType, /*[in]*/ WORD wCategory, /*[in]*/ DWORD dwEventID, /*[in]*/ VARIANT vItems)
{
    DEBUGMSG("Updates::LogEvent");

    HRESULT hr = m_AccessCheckClient();

	if ( FAILED(hr) )
	{
		return hr;
	}

	if ((VT_ARRAY | VT_BSTR) != vItems.vt ||
		NULL == vItems.parray)
	{
		DEBUGMSG("WUAUENG invalid variant list");
		return E_INVALIDARG;
	}
	WaitForSingleObject(m_hEngineMutex, INFINITE);

	CAUEventLog aueventlog(g_hInstance);
    hr = aueventlog.LogEvent(
			wType,
			wCategory,
			dwEventID,
			vItems.parray) ? S_OK : E_FAIL;

    ReleaseMutex(m_hEngineMutex);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\updates.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       updates.h
//  		     Definition of the Updates class
//
//--------------------------------------------------------------------------

#pragma once


#include "wuauengi.h"
#include "wuaulib.h"
#include <Wtsapi32.h>
#include <wuaustate.h>
#include <wuaueng.h>
#include <accctrl.h>
#include <aclapi.h>
#include "pch.h"

// functions IUpdates uses
void  HrUninit(void);
HRESULT StartDownload(void);
HRESULT PauseDownload(BOOL bPause);
HRESULT GetUpdatesList(VARIANT *vList);
HRESULT GetInstallXML(BSTR *pbstrCatalogXML, BSTR *pbstrDownloadXML);
void saveSelection(VARIANT *selection);
HRESULT GetDownloadStatus(UINT *pPercentage, DWORD *pdwnldStatus, BOOL fCareAboutConnection = TRUE);
HRESULT GetInstallStatus(UINT *pNumFinished, DWORD *pStatus);
HRESULT GetEvtHandles(AUEVTHANDLES *pAuEvtHandles);
DWORD AvailableSessions(void);
BOOL IsSessionAUEnabledAdmin(DWORD dwSessionId);

/////////////////////////////////////////////////////////////////////////////
// Updates
class Updates : 
	public IUpdates
{
public:
	HANDLE 	m_hEngineMutex;

	Updates();
	~Updates();
	BOOL m_fInitializeSecurity(void);
	HRESULT m_AccessCheckClient(void);
	HRESULT	GetServiceHandles();
	DWORD	ProcessState();
	BOOL	CheckConnection();

// IUnknown
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
       STDMETHOD_(ULONG, AddRef)(void);
       STDMETHOD_(ULONG, Release)(void);

// IClassFactory
	STDMETHOD(CreateInstance)(IUnknown*,REFIID,void**);
	STDMETHOD(LockServer)(BOOL);

// IUpdates
	STDMETHOD(get_State)(/*[out, retval]*/ AUSTATE *pAuState);
	STDMETHOD(get_Option)(/*[out, retval]*/ AUOPTION * pAuOpt);
	STDMETHOD(put_Option)(/*[in]*/ AUOPTION  auopt);
	STDMETHOD(GetUpdatesList)(/*[out]*/ VARIANT *pUpdates);
	STDMETHOD(SaveSelections)(/*[in]*/ VARIANT vUpdates);
	STDMETHOD(StartDownload)(void);
	STDMETHOD(GetDownloadStatus)(/*[out]*/ UINT *, /*[out]*/ DWORD *);
	STDMETHOD(SetDownloadPaused)(/*[in]*/ BOOL bPaused);
	STDMETHOD(ConfigureAU)();
	STDMETHOD(AvailableSessions(/*[out]*/ UINT *pcSess));
	STDMETHOD(get_EvtHandles(/*[in]*/DWORD dwCltProcId, /*[out]*/ AUEVTHANDLES *pauevtHandles));
	STDMETHOD(ClientMessage(/*[in]*/ UINT msg));
	//STDMETHOD(PingStatus(/*[in]*/ StatusEntry se));
	STDMETHOD(GetNotifyData(/*[out]*/ CLIENT_NOTIFY_DATA *pNotifyData));	
    STDMETHOD(GetInstallXML(/*[out]*/ BSTR *pbstrCatalogXML, /*[out]*/ BSTR *pbstrDownloadXML));
	STDMETHOD(LogEvent(/*[in]*/ WORD wType, /*[in]*/ WORD wCategory, /*[in]*/ DWORD dwEventID, /*[in]*/ VARIANT vItems));
private:
	SECURITY_DESCRIPTOR m_AdminSecurityDesc;
	static GENERIC_MAPPING m_AdminGenericMapping;	
    PSID m_pAdminSid;
    PACL m_pAdminAcl;	
	long m_refs;
};


class CLIENT_HANDLES
{
public:
	CLIENT_HANDLES(void){
		InitHandle();
	}
	~CLIENT_HANDLES(void){
		Reset(TRUE);
	}
	BOOL fRebootWarningMode()
	{
		return m_fRebootWarningMode;
	}
    void StopClients(BOOL fRelaunch) {
    	if (m_fRebootWarningMode)
    	{
	        DEBUGMSG("WUAUENG told %d CLIENT(S) to exit", m_dwRebootWarningClientNum);
    		if (NULL != m_hClientExitEvt)
    		{
    			SetEvent(m_hClientExitEvt);
    		}
    	}
    	else
    	{
			if (fClient())
			{
				if (fRelaunch)
				{
			        DEBUGMSG("WUAUENG told WUAUCLT to relaunch");
					NotifyClient(NOTIFY_RELAUNCH_CLIENT);
				}
				else
				{
					DEBUGMSG("WUAUENG told WUAUCLT to exit");
					NotifyClient(NOTIFY_STOP_CLIENT);
				}
			}
			else
			{
				DEBUGMSG("WARNING: StopClients() : no existing client");
			}
    	}
	}
    void ClientAddTrayIcon(void) {
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
    	{
    		DEBUGMSG("WARNING: ClientAddTrayIcon() called in wrong mode");
    		return;
    	}
    		if (fClient())
    		{
    			NotifyClient(NOTIFY_ADD_TRAYICON); 
    		}
    	}
    void ClientRemoveTrayIcon(void) {
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
    	{
    		DEBUGMSG("WARNING: ClientRemoveTrayIcon() called in wrong mode");
    		return;
    	}
    		if (fClient())
    		{
    			NotifyClient(NOTIFY_REMOVE_TRAYICON); 
    		}
    	}
    void ClientStateChange(void) { 
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
   		{
   			DEBUGMSG("WARNING: ClientStateChange() called in wrong mode");
   			return;
   		}
    	NotifyClient(NOTIFY_STATE_CHANGE);
    	}
    void ClientShowInstallWarning(void){
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
   		{
   			DEBUGMSG("WARNING: ClientShowInstallWarning() called in wrong mode");
   			return;
   		}
    		if (fClient())
    		{
    			NotifyClient(NOTIFY_SHOW_INSTALLWARNING);
    		}
	}
    void ResetClient(void) {
    	if (m_fRebootWarningMode || m_fAsLocalSystem)
   		{
   			DEBUGMSG("WARNING: ResetClient() called in wrong mode");
   			return;
   		}
    		if (fClient())
		{
			NotifyClient(NOTIFY_RESET);
		}
    	}

	//checking existence of client(s)    	
    BOOL fClient(void) { 
    	if (m_fRebootWarningMode)
    	{
    		return m_dwRebootWarningClientNum > 0;
    	}
    	else
    	{
    		return (-1 != m_dwProcId) && (NULL != m_hClientProcess);
   		 }
	}

void SetHandle(PROCESS_INFORMATION & ProcessInfo, BOOL fAsLocalSystem)
{
	m_fRebootWarningMode = FALSE;
	m_fAsLocalSystem = fAsLocalSystem;
	m_dwProcId = ProcessInfo.dwProcessId;
	m_hClientProcess   = ProcessInfo.hProcess;
	SafeCloseHandle(ProcessInfo.hThread);
}

BOOL AddHandle(PROCESS_INFORMATION    &   ProcessInfo)
{
	HANDLE *pTmp;
	
	m_fRebootWarningMode = TRUE;
	SafeCloseHandle(ProcessInfo.hThread);
	pTmp  = (HANDLE*) realloc(m_phRebootWarningClients, (m_dwRebootWarningClientNum+1)*sizeof(HANDLE));
	if (NULL == pTmp)
	{
		return FALSE;
	}
	m_phRebootWarningClients = pTmp;
	m_phRebootWarningClients[m_dwRebootWarningClientNum] = ProcessInfo.hProcess;
	m_dwRebootWarningClientNum ++;
	return TRUE;
}

void RemoveHandle(HANDLE hProcess)
{
	if (m_fRebootWarningMode)
	{
		for (DWORD i = 0; i < m_dwRebootWarningClientNum; i++)
		{
			if (hProcess == m_phRebootWarningClients[i])
			{
				CloseHandle(hProcess);
				m_phRebootWarningClients[i] = m_phRebootWarningClients[m_dwRebootWarningClientNum -1];
				m_dwRebootWarningClientNum --;
				DEBUGMSG("RemoveHandle in Reboot warning mode");				
			}
		}
		if (0 == m_dwRebootWarningClientNum)
		{//all clients are gone
			Reset();
		}
	}
	else
	{
		DEBUGMSG("RemoveHandle in regular mode");
		if (hProcess == m_hClientProcess)
		{ //all clients are gone
			Reset();
		}
	}
}
	
void InitHandle(void)
{
	DEBUGMSG("WUAUENG client handles initialized");
	m_hClientProcess = NULL;
	m_dwProcId = -1;
	m_dwRebootWarningClientNum = 0;
	m_phRebootWarningClients = NULL;
	m_fRebootWarningMode = FALSE;
	m_fAsLocalSystem = FALSE;
	m_hClientExitEvt = NULL;
}


DWORD GetProcId(void)
{
	if (m_fRebootWarningMode)
	{
		DEBUGMSG("WARNING: GetProcId() called in wrong mode");
		return -1;
	}
 	return m_dwProcId;
}

CONST HANDLE hClientProcess(void)
{
	if (m_fRebootWarningMode)
	{
		DEBUGMSG("WARNING: hClientProcess() called in wrong mode");
		return NULL;
	}
	return m_hClientProcess;
}

void WaitForClientExits()
{
	HANDLE *pTmp;

	if (!m_fRebootWarningMode)
	{
		if (NULL != m_hClientProcess)
		{
			WaitForSingleObject(m_hClientProcess, INFINITE);
		}
	}
	else
	{ 
		if (m_dwRebootWarningClientNum > 0)
		{
			WaitForMultipleObjects(m_dwRebootWarningClientNum, m_phRebootWarningClients, TRUE, INFINITE);
		}
	}
	Reset();
	return;
}

//////////////////////////////////////////////////////////////////
// szName should have size of at least MAX_PATH characters
//////////////////////////////////////////////////////////////////
BOOL CreateClientExitEvt(LPTSTR OUT szName, DWORD dwCchSize)
{	
	const TCHAR szClientName[]  = _T("Global\\Microsoft.WindowsUpdate.AU.ClientExitEvt.");
	TCHAR szBuf[50];
	GUID guid;
	HRESULT hr;

	AUASSERT(NULL == m_hClientExitEvt);
	if (FAILED(hr = CoCreateGuid(&guid)))
	{
		DEBUGMSG("Fail to Create guid with error %#lx", hr);
		return FALSE;
	}
	StringFromGUID2(guid, szBuf, ARRAYSIZE(szBuf)); // szBuf should be big enough, function always succeed

    if (FAILED(hr = StringCchCopyEx(szName, dwCchSize, szClientName, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(szName, dwCchSize, szBuf, NULL, NULL, MISTSAFE_STRING_FLAGS))) //szName is now 86 characters long
	{
		DEBUGMSG("Fail to construct client exit event name with error %#lx", hr);
		return FALSE;
	}

	if (NULL == (m_hClientExitEvt = CreateEvent(NULL, TRUE, FALSE, szName)))
	{
		DEBUGMSG("Fail to create client exit event with error %d", GetLastError());
		return FALSE;
	}
	if (!AllowEveryOne(m_hClientExitEvt))
	{
		DEBUGMSG("Fail to grant access on client exit event to everyone");
		SafeCloseHandleNULL(m_hClientExitEvt);
		return FALSE;
	}
	DEBUGMSG("access granted to everyone on client exit event");
	return TRUE;
}


private:
	void NotifyClient(CLIENT_NOTIFY_CODE notClientCode)
	{
		 //notify client even before or after it is created 
#ifdef DBG
				LPCSTR aClientCodeMsg[] = {"stop client", "add trayicon", "remove trayicon", "state change", "show install warning", "reset client", "relaunch client"};
				DEBUGMSG("Notify Client for %s", aClientCodeMsg[notClientCode-1]);
#endif
				gClientNotifyData.actionCode = notClientCode;
				SetEvent(ghNotifyClient);
				return;
	}

	////////////////////////////////////////////////////////////////////
	// grant SYNCHRONIZE access on hObject to everyone
	////////////////////////////////////////////////////////////////////
	BOOL AllowEveryOne (HANDLE hObject)             // handle to the event
	{
	LPTSTR pszTrustee;          // trustee for new ACE
	TRUSTEE_FORM TrusteeForm;   // format of trustee structure
	DWORD dwRes;
	PACL pOldDACL = NULL, pNewDACL = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;
	EXPLICIT_ACCESS ea;
	PSID pWorldSid = NULL;
	BOOL fRet;

	 // World SID
	SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
	if (! (fRet =AllocateAndInitializeSid(&WorldAuth,1, SECURITY_WORLD_RID, 0,0,0,0,0,0,0,&pWorldSid)))
	{
		DEBUGMSG("WUAUENG: AllowEveryOne() failed with error %d", GetLastError());
		goto Cleanup;
	}

	// Get a pointer to the existing DACL.
	dwRes = GetSecurityInfo(hObject, SE_KERNEL_OBJECT, 
	      DACL_SECURITY_INFORMATION,
	      NULL, NULL, &pOldDACL, NULL, &pSD);
	if (!(fRet = (ERROR_SUCCESS == dwRes))) {
	    DEBUGMSG( "GetSecurityInfo Error %u", dwRes );
	    goto Cleanup; 
	}  

	// Initialize an EXPLICIT_ACCESS structure for the new ACE. 

	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = SYNCHRONIZE;
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance= NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ea.Trustee.ptstrName = (LPTSTR)pWorldSid;

	// Create a new ACL that merges the new ACE
	// into the existing DACL.

	dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
	if (!(fRet = (ERROR_SUCCESS == dwRes)))  {
	    DEBUGMSG( "SetEntriesInAcl Error %u", dwRes );
	    goto Cleanup; 
	}  

	// Attach the new ACL as the object's DACL.
	dwRes = SetSecurityInfo(hObject, SE_KERNEL_OBJECT, 
	      DACL_SECURITY_INFORMATION,
	      NULL, NULL, pNewDACL, NULL);
	if (!(fRet = (ERROR_SUCCESS == dwRes)))  {
	    DEBUGMSG( "SetSecurityInfo Error %u", dwRes );
	    goto Cleanup; 
	}  

	Cleanup:
	    if(pSD != NULL) 
	        LocalFree((HLOCAL) pSD); 
	    if(pNewDACL != NULL) 
	        LocalFree((HLOCAL) pNewDACL); 
	    if (NULL != pWorldSid)
	    {
	    	FreeSid(pWorldSid);
	    }
	    return fRet;
	}

	void Reset( BOOL fDestructor = FALSE)
	{
		SafeCloseHandleNULL(m_hClientProcess);
		SafeCloseHandleNULL(m_hClientExitEvt);
		m_dwProcId = -1;
		if (!fDestructor)
		{
			ResetEvent(ghNotifyClient);
		}
		if (m_dwRebootWarningClientNum > 0)
		{
			DEBUGMSG("WUAUENG CLIENT_HANDLES::Reset() close %d handles", m_dwRebootWarningClientNum);
			for (DWORD  i = 0; i < m_dwRebootWarningClientNum; i++)
			{
				CloseHandle(m_phRebootWarningClients[i]);
			}
		}
		SafeFreeNULL(m_phRebootWarningClients); //still need to free even m_dwRebootWarningClientNum is 0
		m_dwRebootWarningClientNum = 0;
		m_phRebootWarningClients = NULL;
		m_fRebootWarningMode = FALSE;
		m_fAsLocalSystem = FALSE;
	}

private:
	HANDLE			m_hClientProcess;		//Handle to the client process
	DWORD 			m_dwProcId;
	HANDLE			*m_phRebootWarningClients;
	DWORD			m_dwRebootWarningClientNum; //number of valid handles in m_phRebootWarningClients
	BOOL 			m_fRebootWarningMode;
	BOOL 			m_fAsLocalSystem;
	HANDLE 			m_hClientExitEvt;

};

extern CLIENT_HANDLES  ghClientHandles;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\wuaueng.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       wuaueng.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//Handle for Download Events
ENGINE_EVENTS EngineEvents;

AUCatalog *gpAUcatalog;

inline BOOL FServiceDisabled(void)
{
	return (AUSTATE_DISABLED == gpState->GetState());
}

//cancel download if any
void CancelDownload(void)
{
    if (NULL != gpAUcatalog && gpAUcatalog->m_audownloader.getID() != GUID_NULL)
    {
        gpAUcatalog->m_audownloader.DrizzleOperation(DRIZZLEOPS_CANCEL);															
    }
    gpState->SetDisconnected(FALSE);	//In case the disabled happened during TRANSIENT_ERROR we don't want to keep the flag set to disconnected		
}

DWORD RandomWaitTimeBeforeDetect()
{
    return (ULONGLONG)AU_TWENTY_TWO_HOURS - ((ULONGLONG) AU_TWENTY_TWO_HOURS * rand() * AU_RANDOMIZATION_WINDOW ) /( (ULONGLONG) RAND_MAX * 100); //precision to hundredth
}


//void setAuStateDisconnected(BOOL fDisconnected);
BOOL FDisabledDuringDownload(void)
{
	BOOL fRet = FALSE;

	if (FServiceDisabled())
	{
		DEBUGMSG("WUAUENG Detected Disabled State during download");
		CancelDownload();
		fRet = TRUE;
	}
	return fRet;
}

#define ISERVICE_FINISHED	0
#define ISERVICE_DISABLED	1

#define WAIT_SERVICE_FINISHED 0
#define WAIT_SERVICE_DISABLED 1
#define WAIT_NOT_NEEDED		  2
#define WAIT_CONNECTION_FOUND 3
#define WAIT_DONE           4


//fixcode: don't always need to persist in registry
DWORD MWFMO(DWORD dwTimeout, DWORD dwMinTimeout = 1)
{
	HANDLE hEvents[2];	

	hEvents[ISERVICE_FINISHED] = ghServiceFinished;
	hEvents[ISERVICE_DISABLED] = ghServiceDisabled;
	
	if (FAILED(setLastWaitTimeout(dwTimeout)))
	{
		DEBUGMSG("WUAUENG setLastWaitTimeout failed with error %d", GetLastError());
	}

	return MsgWaitForMultipleObjectsEx(2, hEvents, dwTimeToWait(dwTimeout, dwMinTimeout), QS_POSTMESSAGE, MWMO_INPUTAVAILABLE );
}


DWORD _MyMWFMO(DWORD dwTimeout, DWORD dwMinTimeout = 1);
//dwTimeout in seconds
#define MyMWFMO(dwTimeout) _MyMWFMO(dwTimeout)

// wait until a timeout happens or we get a service finished event
DWORD _MyMWFMO(DWORD dwTimeout, DWORD dwMinTimeout)
{	
	DWORD dwRet = WAIT_TIMEOUT;

	while (1)
	{
		dwRet = MWFMO(dwTimeout, dwMinTimeout);
		if (WAIT_TIMEOUT == dwRet)
		{
			DEBUGMSG("WUAUENG MWFMO timed out");			
//			dwRet = WAIT_TIMEOUT;
			goto Done;
		}
		else if (WAIT_OBJECT_0 + ISERVICE_FINISHED == dwRet)
		{
			DEBUGMSG("WUAUENG MWFMO Service Finished");
			dwRet = WAIT_SERVICE_FINISHED;			
			goto Done;
		}
		else if (WAIT_OBJECT_0 + ISERVICE_DISABLED == dwRet)
		{
			DEBUGMSG("WUAUENG MWFMO Engine Changed to Disabled\n");			
			dwRet = WAIT_SERVICE_DISABLED;
			goto Done;
		}		
		else 
		{
			//we expect possible meaningful message here
			//leave it untouch in the queue
		
			MSG msg;
			if (0 == PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
				DEBUGMSG("MyMWFMO got no message. Possible error!");
				continue;	//no message got
			}
			if ( ((AUMSG_ENG_START <= msg.message) && (AUMSG_ENG_END >= msg.message))
				 || (WM_QUIT == msg.message))
			{
				DEBUGMSG("MyMWFMO got user msg %#lx, repost it to the queue", msg.message);
				PostThreadMessage(gdwWorkerThreadId, msg.message, msg.wParam, msg.lParam);
				dwRet = msg.message;
				goto Done;
			}
			else
			{
                DEBUGMSG("WUAUENG MWFMO got system message %#lx", msg.message);
                TranslateMessage( &msg );
                DispatchMessage( &msg );
			}
			
		}
	}
Done:
	if (WAIT_SERVICE_FINISHED != dwRet)
	{	
		removeLastWaitKey();
	}
	return dwRet;
}


	
//** WaitForConnection() will wait for connection or
//** will bail out if Service Finished or service disabled or getting a msg if fIgnoreNonDetectMsg is FALSE
DWORD  WaitForConnection(BOOL fIngoreNonDetectMsg = FALSE)
{
	static BOOL s_fWasConnected = FALSE;
        DWORD dwRet;

	DEBUGMSG("WUAUENG : Polling for connection");
	do
	{
		do
		{
			if (AUSTATE_DETECT_PENDING == gpState->GetState() &&
				gpState->IsUnableToConnect())
			{
				CAUEventLog aueventlog(g_hInstance);
				aueventlog.LogEvent(
								EVENTLOG_WARNING_TYPE,
								IDS_MSG_Download,
								IDS_MSG_UnableToConnect);
				gpState->SetDetectionStartTime(TRUE);
			}
			if (IsConnected(gpState->GetIdentServerURL(), !gpState->fInCorpWU()))
			{
				break;
			}
                     dwRet = MyMWFMO(AU_TEN_MINS);
                     if (WAIT_TIMEOUT != dwRet)
                     {
                        if (!fIngoreNonDetectMsg ||!IsValidAUMsg(dwRet) || AUMSG_DETECT == dwRet )
                        {
                            goto Done;
                        }
                     }
			s_fWasConnected = FALSE;
		}
		while (1);

		if (!s_fWasConnected)
		{
			DEBUGMSG("Found Connection");

			if (AUSTATE_DOWNLOAD_PENDING != gpState->GetState())
			{
				BOOL fWait = TRUE;
#ifdef DBG		
				//wait 5 mins by Default if 'ConnectWait' regvalue does not exist
				// or is set to 1
				DWORD dwConnectWait;
				if (SUCCEEDED(GetRegDWordValue(REG_AUCONNECTWAIT, &dwConnectWait)) 
					&& 0 == dwConnectWait)
				{
					fWait = FALSE;
				}
#endif					
				if (fWait)
				{
					DEBUGMSG("Wait for 5 mins "); 
	                dwRet = MyMWFMO(AU_FIVE_MINS);
	                if (WAIT_TIMEOUT != dwRet)
	                {
	                     if (!fIngoreNonDetectMsg || !IsValidAUMsg(dwRet) || AUMSG_DETECT == dwRet)
	                    {
	                        goto Done;
	                    }
	                }
				}
				if (!IsConnected(gpState->GetIdentServerURL(), !gpState->fInCorpWU()))
				{
					continue;
				}
			}
			s_fWasConnected = TRUE;
		}
		break;
	}
	while (1);
	DEBUGMSG("WUAUENG : Connection found. Polling end");
	dwRet = WAIT_CONNECTION_FOUND;
Done:
	return dwRet;
}


HRESULT PauseDownload(BOOL fPause)
{
       HRESULT hrRet = E_FAIL;
      
	if (NULL != gpAUcatalog)
	{
           hrRet = gpAUcatalog->m_audownloader.DrizzleOperation(fPause? DRIZZLEOPS_PAUSE: DRIZZLEOPS_RESUME);
	}
	DEBUGMSG("PauseDownload return %#lx", hrRet);
       return hrRet;
}

HRESULT GetEvtHandles(AUEVTHANDLES *pAuEvtHandles)
{
	HRESULT hr = E_FAIL;
	HANDLE hSourceProcess = NULL;	

//#define IEVT_ENGINESTATE		0
#define IEVT_NOTIFYCLIENT		0

	struct
	{
		HANDLE hSource;
		HANDLE hTarget;
	} rhandles [] = {/*{ghEngineState,0},*/{ghNotifyClient,0}};

   
	if (NULL == ghClientHandles.hClientProcess())
	{
		goto Done;
	}


	hSourceProcess = GetCurrentProcess();
	
	for ( int i = 0; i < (ARRAYSIZE(rhandles)); i++)
	{
		if (!DuplicateHandle(
			hSourceProcess,  // handle to source process
			rhandles[i].hSource,         // handle to duplicate
			ghClientHandles.hClientProcess(),  // handle to target process
			&rhandles[i].hTarget,      // duplicate handle
			0,        // requested access
			FALSE,          // handle inheritance option
			DUPLICATE_SAME_ACCESS      // optional actions
			))
		{
			DEBUGMSG("WUAUENG DuplicateHandle for rhandles[%d] failed with %#lx", i, GetLastError());
			//should not close target handle cuz it is in target process
			goto Done;
		}
	}
#ifdef _WIN64
	pAuEvtHandles->ulNotifyClient     = (LONG64) rhandles[IEVT_NOTIFYCLIENT].hTarget;
#else	
	pAuEvtHandles->ulNotifyClient     = (LONG) rhandles[IEVT_NOTIFYCLIENT].hTarget;
#endif

	hr = S_OK;
Done:
	return hr;
} 

DWORD AvailableSessions(void)
{
	DWORD dwRet = 0;
    //
    // For win2K, because we're not deleting sessions as soon as we receive
    // logoff notifications, the array gAdminSesssion might be out-of-date
    // in a given point in time. We need to validate the array before
    // saying to client things about it.
    // Remove any old sessions from our array if there's any
    //
    if (IsWin2K())
    {
        DEBUGMSG("WUAUENG Client is querying the number of sessions available; forcing rebuilt of the session cache (win2k)");
        gAdminSessions.ValidateCachedSessions();
    }

	for (int iSession = 0; iSession < gAdminSessions.CSessions(); iSession++)
	{
        DWORD dwAdminSession;
        if (gAdminSessions.m_FGetNextSession(&dwAdminSession) && FSessionActive(dwAdminSession))			
        {			
            dwRet ++;
        }
	}			

//	DEBUGMSG("AvailableSessions return %d", dwRet);

	return dwRet;
}

HRESULT HrCreateNewCatalog()
{	
	HRESULT hr = E_FAIL;

	SafeDeleteNULL(gpAUcatalog);
	gpAUcatalog = new AUCatalog;

	if (NULL == gpAUcatalog)
	{
		goto Done;
	}
	if (FAILED(hr = gpAUcatalog->Init()))
	{		
		SafeDeleteNULL(gpAUcatalog);
	}
Done:
	return hr;
}
/* This function will return only in case of selfupdate. Normally it will keep on looping
 * sleeping on various timeouts when necessary
 */
DWORD CompleteLastMyMWFMO(void)
{	
	DWORD dwRet = WAIT_NOT_NEEDED;
	DWORD dwTimeout; 
	HRESULT hr;

	hr = getLastWaitTimeout(&dwTimeout);
	MyMWFMO(0); //call user api to create the thread queue
	SetEvent(ghWorkerThreadMsgQueueCreation);
    if (FAILED(hr))
	{
	    DEBUGMSG("WUAUENG no need to complete last wait");
		goto Done;
	}
	DEBUGMSG("WUAUENG is going to complete last wait %d ", dwTimeout);
	dwRet = MyMWFMO(dwTimeout);
Done:
	return dwRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// return S_FALSE if selfupdate happens
// return S_OK otherwise
// pdwRet points to return code: service finish, service disabled, selfupdate done, or detect msg
HRESULT PerformSelfUpdate(DWORD *pdwRet)
{
       HRESULT hr= S_OK;
       DEBUGMSG("Doing selfupdate");
	DEBUGMSG("Selfupdate waiting for connection");
	DEBUGMSG("Wait for internet connection...");
	
        while ( WAIT_CONNECTION_FOUND == (*pdwRet = WaitForConnection(TRUE))
	        && ((hr = SelfUpdate()) != S_OK) )
	{
		switch (hr)
		{
			case S_FALSE:  //selfupdate happens
				DEBUGMSG("Telling wuauserv.dll to reload wuaueng.dll");
				gPingStatus.PingSelfUpdate(TRUE, URLLOGSTATUS_Pending, 0);
				*pdwRet = WAIT_DONE;
				goto Done;
			default:
				DEBUGMSG("Error during selfupdate (%#lx), timeout=%d secs", hr, dwTimeToWait(AU_ONE_DAY));
				gPingStatus.PingSelfUpdate(TRUE, URLLOGSTATUS_Failed, hr);
                            *pdwRet = MyMWFMO(AU_ONE_DAY);
                            if (WAIT_TIMEOUT != *pdwRet)
				{
					DEBUGMSG("WUAUENG need to abort wait during SelfUpdate");
					goto Done;                                    
				}
				break;
		}
	}

	if (WAIT_CONNECTION_FOUND == *pdwRet)
       {
         	*pdwRet = WAIT_DONE;
	}
       DEBUGMSG("Finished self update cycle");
    
Done:         
	return hr;
}


void ResumeDownloadIfNeccesary(void)
{	
	if (FDownloadIsPaused())
	{	
		PauseDownload(FALSE);
		DEBUGMSG("WUAUENG Resuming download job");				
	}
}

void PingSuccessfulDownloads(void)
{
	UINT uItemCount = gpAUcatalog->m_ItemList.Count();

	for (UINT i = 0; i < uItemCount; i++)
	{
		AUCatalogItem &item = gpAUcatalog->m_ItemList[i];

		if (item.fSelected())
		{
			BSTR bstrItemId = item.bstrID();

			if (NULL != bstrItemId)
			{
				USES_IU_CONVERSION;

				gPingStatus.PingDownload(
					TRUE,
					URLLOGSTATUS_Success,
					0,
					W2T(bstrItemId));
			}
#ifdef DBG
			else
			{
				DEBUGMSG("WUAUENG title for item %d is NULL!", i);
			}
#endif
		}
	}
}

void ResetState(void)
{
	gpState->SetState(AUSTATE_DETECT_PENDING);
	PostThreadMessage(gdwWorkerThreadId, AUMSG_DETECT, 0, 0);			
}

void ResetState(BOOL *pfWaitB4Detect, DWORD *pdwWaitB4Detect, BOOL fError)
{
	AUASSERT(NULL != pfWaitB4Detect);
	AUASSERT(NULL != pdwWaitB4Detect);
	 *pfWaitB4Detect = TRUE;
	 *pdwWaitB4Detect = fError ? AU_FIVE_HOURS : RandomWaitTimeBeforeDetect();
       ResetState();
}


HRESULT UpdateProc(WORKER_THREAD_INIT_DATA & initData)
{
	HRESULT hr = S_OK;
	DWORD	dwRet;	
	DWORD dwLastWait ;
    BOOL    fReloadAfterSelfUpdate = FALSE;
	MSG     msg;
	UINT uFirstMsg;
       static BOOL    s_fWaitBeforeDetect;
       static DWORD s_dwWaitB4Detect;

        uFirstMsg = initData.uFirstMsg;
        s_fWaitBeforeDetect = initData.fWaitB4Detect;
        s_dwWaitB4Detect = initData.dwWaitB4Detect;

       dwLastWait = CompleteLastMyMWFMO();
	
	switch (dwLastWait)
	    {
	        case WAIT_SERVICE_FINISHED:
                        goto Done;
                case WAIT_TIMEOUT:
                case WAIT_NOT_NEEDED:    
				if (IsValidAUMsg(uFirstMsg))
				{
				DEBUGMSG("Update post first msg %#x", uFirstMsg);
				PostThreadMessage(gdwWorkerThreadId,  uFirstMsg, 0, 0);
				}
				break;
                case WAIT_SERVICE_DISABLED:				
                default:        //msg got
                        break;
	}
                        
	
	DWORD dwRet2 ;
	while(WAIT_OBJECT_0 + 1 == (dwRet2 = MsgWaitForMultipleObjectsEx(1, &ghServiceFinished, INFINITE, QS_POSTMESSAGE, MWMO_INPUTAVAILABLE )))
	{
		if (0 == PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{ 
			DEBUGMSG("WUAUENG no message to retrieve. Possible error!");
			continue; 
		}
		if (WM_QUIT == msg.message)
		{
			break; 
		}

		switch(msg.message)
		{
		    case AUMSG_INIT:
                            {
                                  //we wait for the first connection so that we don't prompt users who never 
                                  //make a connection to the internet. no need to have them config AU if they have no
                                  //intention of using the internet
                            	dwRet = WaitForConnection();
                                   switch (dwRet)
                                    {
                                        case WAIT_SERVICE_FINISHED:
                                        		DEBUGMSG("WUAUENG detected that Service finished during WaitForConnection in AUSTATE_OUTOFBOX");
                                        		goto Done;
                                        case WAIT_CONNECTION_FOUND:         
                                                break;
                                        case WAIT_SERVICE_DISABLED:
                                        default:
                                                 continue;
                                   }

                                    dwRet = dwLastWait;
                                    if (WAIT_NOT_NEEDED == dwLastWait)
                                    {
                                            //there was no previous wait for 24 hours
                                    	DEBUGMSG("WUAUENG Out of box, waiting 24 hours (%d secs)", dwSecsToWait(AU_ONE_DAY));
                                    	dwRet = MyMWFMO(AU_ONE_DAY);
                                    }
                            	switch (dwRet)
                            	{
                            	    case WAIT_TIMEOUT:
                                                {
#if 0 //commented out for bug 493789                                                    
                                                    DWORD dwRet4;
                                                    hr = PerformSelfUpdate(&dwRet4);
                                                    if (WAIT_SERVICE_FINISHED == dwRet4)
                                                    {
                                                        setLastWaitTimeout(0);  //no wait next time
                                                        goto Done;
                                                    }
#endif                                                    
                                                    gpState->SetState(AUSTATE_NOT_CONFIGURED);
                                                    DEBUGMSG("WUAUENG waiting for user to configure AU");
#if 0 //commented out for bug 493789                                                     
                                                    if (S_FALSE == hr)
                                                    {
                                                        fReloadAfterSelfUpdate = TRUE;
                                                        goto Done;
                                                    }
#endif                                                    
                                                    break;
                                                }
                            	    case WAIT_SERVICE_FINISHED:
                            		goto Done;
                            	    case WAIT_SERVICE_DISABLED:
                            	    default:                            	        
                            	            continue;
                            	}
                            	break;
                            }
			case AUMSG_EULA_ACCEPTED:
				DEBUGMSG("WUAUENG Msg:Eula accepted, state -> Detect Pending");
				ResetState();
				break;

			case AUMSG_DETECT:
			       if (s_fWaitBeforeDetect)
			       {
			            s_fWaitBeforeDetect = FALSE;
			            DEBUGMSG("WUAUENG Wait %d secs before detection", s_dwWaitB4Detect);
			            DWORD dwRet3 = MyMWFMO(s_dwWaitB4Detect);					
			            s_dwWaitB4Detect = 0;
					if (WAIT_SERVICE_DISABLED == dwRet3)
					{
						break;
					}					
					if (WAIT_SERVICE_FINISHED == dwRet3)
					{
						goto Done;
					}
			       }

					DEBUGMSG("WUAUENG Msg:Detect");						
	                DEBUGMSG("--------------------------------------------------------");
	                DEBUGMSG("Set new detection start time");
					gpState->SetDetectionStartTime(FALSE);
					DEBUGMSG("Read in au option");
	                if (FAILED(hr = gpState->HrInit()))
	                {
	                DEBUGMSG("AU state object fail to init with error %#lx", hr);
	                goto Done;
	                }
	                CancelDownload();                            
					if (FAILED(HrCreateNewCatalog()))
					{ //fixcode: what is the expected behavior here?
						return E_FAIL;
					}
                                    
   			       hr = PerformSelfUpdate(&dwRet);
    			       if (S_FALSE == hr)
    			        {
    			            fReloadAfterSelfUpdate = TRUE;
    			            goto Done;
    			         }
    			       switch (dwRet)
    			       {
    			           case WAIT_SERVICE_FINISHED:
            			            goto Done;
                                case WAIT_SERVICE_DISABLED:
                                        gpState->RemoveDetectionStartTime();
            			            continue;  
            			    case WAIT_DONE:
            			            break;
            			    default: //detect msg got
            			            DEBUGMSG("Detect msg got while detecting");
            			            continue;
    			       }          
				
				hr = gpAUcatalog->DetectItems();

				if (FServiceDisabled())
				{
					gpState->RemoveDetectionStartTime();
					break;
				}

				if (SUCCEEDED(hr))
				{
					//Restart counting period w/ no connection at the beginning of the next cycle.
					gpState->RemoveDetectionStartTime();
				}

				if (S_OK == hr)
				{	
					DEBUGMSG("WUAUENG Catalog built");
					gpState->SetState(AUSTATE_DETECT_COMPLETE);
					DEBUGMSG("WUAUENG State->Detect complete");
				}
				else if (S_FALSE == hr)
				{
                        DEBUGMSG("WUAUENG No items in catalog, sleeping a while before next detection");
			        ResetState(&s_fWaitBeforeDetect,&s_dwWaitB4Detect, FALSE); //wait normal interval time
			        }
				else
				{
					DEBUGMSG("WUAUENG Couldn't build catalog");
					ResetState(&s_fWaitBeforeDetect, &s_dwWaitB4Detect, TRUE); //wait shorter time cuz of error
				}
				break;
			
			case AUMSG_DOWNLOAD:
				{		
				DEBUGMSG("WUAUENG Msg:Download");
				gfDownloadStarted = FALSE;
				gpState->SetState(AUSTATE_DOWNLOAD_PENDING);
				dwRet =WaitForConnection(TRUE);
				switch (dwRet)
				{
				    case WAIT_SERVICE_FINISHED:
					DEBUGMSG("WUAUENG detected that Service finished during WaitForConnection in AUMSG_DOWNLOAD");				
					goto Done;
                                case WAIT_CONNECTION_FOUND:
                                    break;
                                case WAIT_SERVICE_DISABLED:
                                default:
                                    continue;
				}
                                    
				if (S_OK != gpAUcatalog->ValidateItems(TRUE))
				{
					DEBUGMSG("WUAUENG Catalog validation failed or no items, State->Detect Pending");
					ResetState();
					break;	
				}
					
				DEBUGMSG("WUAUENG catalog:validateCatalog finished");						
				
				EngineEvents.CreateEvents();

                        // queue up items for download
		        if (S_OK != (hr = gpAUcatalog->DownloadItems()))
				{
                                  if (S_FALSE == hr)
		                    {
		                        DEBUGMSG("WUAUENG Catalog download items skipped because no items were selected");
		                    }
		                    else
		                    {
			                    DEBUGMSG("WUAUENG Catalog download items failed");
		                    }
					EngineEvents.CloseEvents();
                                  ResetState(&s_fWaitBeforeDetect,&s_dwWaitB4Detect, FALSE);					
					break;
				}
				gfDownloadStarted = TRUE;
				ghClientHandles.ClientStateChange(); //notify client again for status change

				do
				{
					dwRet = MsgWaitForMultipleObjectsEx( EngineEvents.cEvents(), EngineEvents.grEventHandles(), INFINITE, QS_POSTMESSAGE, MWMO_INPUTAVAILABLE );
					if (WAIT_OBJECT_0 + IDOWNLOAD_COMPLETE_EVT == dwRet)		//Download finished
					{				
						if (FDisabledDuringDownload())
						{
							goto CloseHandle;
						}
						DEBUGMSG("WUAUENG file download done");

						ghClientHandles.ClientRemoveTrayIcon();

			                        //Validate downloaded cabs before continuing
			                        AUASSERT(gpAUcatalog);
			                        BSTR bstrErrorItemId = NULL;       //should not be freed
			                        if(FAILED(hr = gpAUcatalog->ValidateDownloadedCabs(&bstrErrorItemId)))
			                        {
			                            USES_IU_CONVERSION;
			                            DEBUGMSG("ValidateDownloadedCabs: Checksum failed, error: %#lx", hr);                            
			                            //bstrErrorItemId will be NULL if it was some error other than ERROR_CRC
			                            if(NULL != bstrErrorItemId)
			                            {
			                                //Pingback failure with itemId
			                                gPingStatus.PingDownload(
									                            TRUE,
									                            URLLOGSTATUS_Failed,
									                            hr,
									                            W2T(bstrErrorItemId));
			                            }
			                            //Reset to detect pending
			                           ResetState(&s_fWaitBeforeDetect,&s_dwWaitB4Detect, TRUE); //wait shorter time cuz of error
			                            goto CloseHandle;
			                        }

						if (!gpState->fOptionSchedInstall())
						{
							DEBUGMSG("WUAUENG download complete, ready for UNSCHEDULED install");
							LogEvent_ItemList(
								EVENTLOG_INFORMATION_TYPE,
								IDS_MSG_Installation,
								IDS_MSG_InstallReady_Unscheduled);
						}
						PingSuccessfulDownloads();
						DEBUGMSG("WUAUENG validating items to prune out items already installed");
						if (  gpAUcatalog->ValidateItems(FALSE) != S_OK)
						{
		                			DEBUGMSG("WUAUENG Validation failed OR no items left in catalog, State->Detect Pending");
		                			ResetState();
						}
						else
						{
							DEBUGMSG(" Items still applicable, State->Download Complete");
							gpState->SetState(AUSTATE_DOWNLOAD_COMPLETE);
						}
						break;
					}
					else if (((WAIT_OBJECT_0 + IDOWNLOAD_TRANSIENT_ERROR_EVT) == dwRet)	||	//Transient error - connection lost
							 ((WAIT_OBJECT_0 + IDOWNLOAD_DOWNLOAD_IN_PROGRESS) == dwRet))	//Download in progress - connection recuperated
					{
						BOOL fCheckDisconnect;					

						fCheckDisconnect = ((WAIT_OBJECT_0 + IDOWNLOAD_DOWNLOAD_IN_PROGRESS) == dwRet);
						
						//AuStateAux = GetState();
						// setState again (and trigger Engine Change State) only if:
						// - It is not disconnected and you got Transient Error Event
						// - It is disconnected and you got a Download in Progress Event
						if ( fCheckDisconnect == gpState->fDisconnected() )
						{
							gpState->SetDisconnected(!fCheckDisconnect);
							gpState->SetState(AUSTATE_DOWNLOAD_PENDING); //relaunch client if it is not launched and notify client of new state
						}															
					}					
					else if ((WAIT_OBJECT_0 + IDOWNLOAD_SERVICE_FINISH) == dwRet)	//Service Finished
					{
						DEBUGMSG("WUAUENG Detected Service Finished while wating for download to be done");
						goto Done;
					}			
					else if ((WAIT_OBJECT_0 + IDOWNLOAD_SERVICE_DISABLED) == dwRet)		//Engine State, should be due to disabled
					{
						if (FDisabledDuringDownload())
						{
							goto CloseHandle;
						}
					}
					else if ((WAIT_OBJECT_0 + IDOWNLOAD_DOWNLOAD_CANCELED) == dwRet)
					{ 
						if (JOB_ERROR ==  gpAUcatalog->m_audownloader.m_FinishReason)
						{
							DEBUGMSG("WUAUENG got error during download, wait for sometime b4 redetect");
							ResetState(&s_fWaitBeforeDetect,&s_dwWaitB4Detect, TRUE); //wait shorter time cuz of error
						}
						else
						{
							DEBUGMSG("WUAUENG download job got canceled, State -> Detect Pending");
							ResetState();
						}
						goto CloseHandle;
					}
					else if ((WAIT_OBJECT_0 + IDOWNLOAD_MESSAGE) == dwRet)			//Messages
					{	
						MSG msg2;
						PeekMessage(&msg2, NULL, NULL, NULL, PM_REMOVE); //we don't expect meaningful message here
						TranslateMessage(&msg2);// Translates virtual key codes
						DispatchMessage(&msg2); // Dispatches message to window
						if ( msg2.message != WM_USER ) //WM_USER is the one to pump to drizzle for processing
						{
							DEBUGMSG("WUAUENG dispatched message %#lx during downloading", msg2.message);
						}
					}
                    else if (((WAIT_ABANDONED_0 + IDOWNLOAD_COMPLETE_EVT) == dwRet) ||
							((WAIT_ABANDONED_0 + IDOWNLOAD_TRANSIENT_ERROR_EVT) == dwRet)||
							((WAIT_ABANDONED_0 + IDOWNLOAD_DOWNLOAD_IN_PROGRESS) == dwRet)||
							((WAIT_ABANDONED_0 + IDOWNLOAD_SERVICE_FINISH) == dwRet)||
							(WAIT_FAILED == dwRet))
					{ //fixcode: when will this actually happen?
						DEBUGMSG("WUAUENG Error in Download Loop with MsgWaitForMultipleObjectsEx");
			                        ResetState();
			                        goto CloseHandle;
					}
					else
					{
						DEBUGMSG("WUAUENG Unexpected returned value dwRet = %d in n Download Loop with MsgWaitForMultipleObjectsEx", dwRet);
					}
				}
                while ( 1 );

CloseHandle:				
				EngineEvents.CloseEvents();
				}
				break;

			case AUMSG_POST_INSTALL:
			    {
                    DEBUGMSG("WUAUENG install done, sleeping a while before next detection");
				//	fixcode: should use ResetState() instead
				 s_fWaitBeforeDetect = TRUE;
			        s_dwWaitB4Detect = RandomWaitTimeBeforeDetect();
				 PostThreadMessage(gdwWorkerThreadId, AUMSG_DETECT, 0, 0);
				break;
			}

			case AUMSG_VALIDATE_CATALOG:
				DEBUGMSG("WUAUENG: validating catalog offline");
				if ( gpAUcatalog->ValidateItems(FALSE) != S_OK)
				{
					DEBUGMSG("WUAUENG Validation failed OR no items left in catalog, State->Detect Pending");
					ResetState();
				}
				SetEvent(ghValidateCatalog);
				break;

			case AUMSG_LOG_EVENT:
				DEBUGMSG("WUAUENG: logging the Ready To Install (Scheduled) event");
				if (gpState->fShouldScheduledInstall())
				{
					LogEvent_ScheduledInstall();
				}
				break;


			default:
				DEBUGMSG("WUAUENG Received unknown msg %#lx", msg.message);
                            TranslateMessage( &msg );
                            DispatchMessage( &msg );
				break;
		}
	}

	if (WAIT_OBJECT_0 == dwRet2)
	{
		DEBUGMSG("Update() exit in response to service finish event");
	}
Done:
	DEBUGMSG("WUAUENG Update func returning");
    // we may ask wuauserv.dll to reload us.
	return fReloadAfterSelfUpdate ? S_FALSE : S_OK;	
}

void saveSelection(VARIANT *selection)
{
    // fixcode this return should return an error
	long n = 0;
	DEBUGMSG("Start saveSelection");
	WaitForSingleObject(ghMutex, INFINITE);
	if ( FAILED(SafeArrayGetUBound(selection->parray, 1, &n)))
	{
		DEBUGMSG("WUAUENG SafeArrayGetUBond failed");
		goto done;
	}

	if (((n + 1) / 2) != gpAUcatalog->m_ItemList.Count())
	{
		AUASSERT(FALSE);
		DEBUGMSG("WUAUENG got unmatched number of items from client");
		goto done;
	}
	
    for ( long i = 0; i < (n + 1) / 2; i++ )
	{
		long dex = i * 2;
		VARIANT var;

		VariantInit(&var);
        if ( FAILED(SafeArrayGetElement(selection->parray, &dex, &var)) )
        {
            DEBUGMSG("SafeArrayGetElement failed");
            continue;
        }

        BOOL fMatch = (WUCompareStringI(var.bstrVal, gpAUcatalog->m_ItemList[i].bstrID()) == CSTR_EQUAL);
        VariantClear(&var);

        if ( fMatch )
        {
	    if ( SUCCEEDED(SafeArrayGetElement(selection->parray, &++dex, &var)) )
            {
        		gpAUcatalog->m_ItemList[i].SetStatus(var.lVal);
//        		DEBUGMSG("Status for item %S is now %d", gpAUcatalog->m_ItemList[i].bstrID(), gpAUcatalog->m_ItemList[i].dwStatus());   		
            }
        }
        else
        {
            DEBUGMSG("item ids did not match for saving selections");
        }
	}
    
//    gpAUcatalog->m_ItemList.DbgDump();
	gpAUcatalog->Serialize();
done:
	ReleaseMutex(ghMutex);
    DEBUGMSG("End saveSelection");
}

HRESULT StartDownload(void)
{
	//DEBUGMSG("WUAUENG ::StartDownload called");
	
	if ( AUSTATE_DETECT_COMPLETE != gpState->GetState() )
	{
		DEBUGMSG("WUAUENG ::StartDownload state incorrect");
		return E_FAIL;
	}
	PostThreadMessage(gdwWorkerThreadId, AUMSG_DOWNLOAD, 0, 0);
	return S_OK;
}

HRESULT GetUpdatesList(VARIANT *vList)
{
	HRESULT hr = E_FAIL;
	DWORD dwWait;

	dwWait = WaitForSingleObject(ghMutex, INFINITE);

	if (WAIT_FAILED == dwWait)
	{
		DEBUGMSG("WUAUENG GetUpdateList got WAIT_ABANDONED");
	}
	else
		DEBUGMSG("WUAUENG Getting Updates list dWait=%d",dwWait);

	if ( (AUSTATE_DETECT_COMPLETE != gpState->GetState()) && (AUSTATE_DOWNLOAD_COMPLETE != gpState->GetState()) )
    {
		goto Done;
    }
	
	hr = gpAUcatalog->getUpdatesList(vList);
Done:
	ReleaseMutex(ghMutex);
	return hr;
}

HRESULT GetInstallXML(/*[out]*/ BSTR *pbstrCatalogXML, /*[out]*/ BSTR *pbstrDownloadXML)
{
//    DEBUGMSG("::GetInstallXML");
	HRESULT hr = E_FAIL;
	DWORD dwWait;

        dwWait = WaitForSingleObject(ghMutex, INFINITE);

	if (WAIT_FAILED == dwWait)
	{
		DEBUGMSG("WUAUENG GetInstallXML got WAIT_ABANDONED");
	}
	else
        {
    		DEBUGMSG("WUAUENG Getting Updates list dWait=%d",dwWait);
        }

	hr = gpAUcatalog->GetInstallXML(pbstrCatalogXML, pbstrDownloadXML);

//Done:
	ReleaseMutex(ghMutex);
	return hr;
}

HRESULT GetDownloadStatus(UINT *pPercentage, DWORD *pdwnldStatus, BOOL fCareAboutConnection)
{
	DWORD dwComplete;
	DWORD dwstatus;
	HRESULT hr;

    if ( AUSTATE_DOWNLOAD_PENDING != gpState->GetState() )
	{
		*pPercentage = (AUSTATE_DOWNLOAD_COMPLETE == gpState->GetState()) ? 100 : 0 ;
		*pdwnldStatus = DWNLDSTATUS_DOWNLOADING;					//for trayicon to show 100%
		//DEBUGMSG("WUAUENG %% complete = %d", *pPercentage);
		return S_OK;
	}
	*pPercentage = 0;
	if (fCareAboutConnection && !gfDownloadStarted) 
	{
		DEBUGMSG("WUAUENG Download status is checking for connection");
		*pdwnldStatus = DWNLDSTATUS_CHECKING_CONNECTION;
		return S_OK;
	}
	WaitForSingleObject(ghMutex, INFINITE);	
	hr = gpAUcatalog->m_audownloader.getStatus(&dwComplete, &dwstatus);
	ReleaseMutex(ghMutex);
	if (FAILED(hr))
	{
		*pdwnldStatus = DWNLDSTATUS_NOT_DOWNLOADING;
		return S_OK;
	}	
	*pPercentage = (int)dwComplete;
	//DEBUGMSG("WUAUENG %% complete = %d", *pPercentage);
	
	switch (dwstatus)
	{
	case BG_JOB_STATE_TRANSFERRING:
	case BG_JOB_STATE_TRANSFERRED:		//for trayicon to show 100%, as in the beginning of the routine
        {
			*pdwnldStatus = DWNLDSTATUS_DOWNLOADING;
			break;
        }				
	case BG_JOB_STATE_SUSPENDED:
		{
			*pdwnldStatus = DWNLDSTATUS_PAUSED;
			break;
		}
	case BG_JOB_STATE_ERROR:			
	case BG_JOB_STATE_TRANSIENT_ERROR:
	case BG_JOB_STATE_ACKNOWLEDGED:
	case BG_JOB_STATE_CANCELLED:    
       case BG_JOB_STATE_QUEUED:
       case BG_JOB_STATE_CONNECTING:
		{
			*pdwnldStatus = DWNLDSTATUS_NOT_DOWNLOADING;
			break;
		}
	default:
		{
			DEBUGMSG("WUAUENG GetDownloadStatus got an unexpected BG_JOB_STATE %d", dwstatus);
			*pdwnldStatus  = DWNLDSTATUS_NOT_DOWNLOADING;
		}
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\aubasecatalog.cpp ===
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aucatalog.cpp
//
//  Purpose:	AU catalog file using IU 
//
//  Creator:	WeiW
//
//  History:	08-15-01 	first created
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

HANDLE                 ghMutex;


HRESULT AUBaseCatalog::PrepareIU(BOOL fOnline)
{
    HRESULT hr = S_OK;
  	Reset();
   	// all IU function pointers are initialized
   	DEBUGMSG("PrepareIU() starts");
#ifdef DBG
    DWORD dwStart = GetTickCount();
#endif
       m_hIUCtl = LoadLibraryFromSystemDir(_T("iuctl.dll"));	
	if (NULL == m_hIUCtl)
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to load iuctl.dll");
		goto end;
	}
	if (NULL == (m_pfnCtlLoadIUEngine = (PFN_LoadIUEngine) GetProcAddress(m_hIUCtl, "LoadIUEngine")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to GetProcAddress for LoadIUEngine");
		goto end;
	}

	if (NULL == (m_pfnCtlUnLoadIUEngine = (PFN_UnLoadIUEngine) GetProcAddress(m_hIUCtl, "UnLoadIUEngine")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for UnloadIUEngine");
		goto end;
	}
	if (NULL == (m_pfnCtlCancelEngineLoad = (PFN_CtlCancelEngineLoad) GetProcAddress(m_hIUCtl, "CtlCancelEngineLoad")))
    {
           hr = E_FAIL;
           DEBUGMSG("AUBaseCatalog:PrepareIU() fail to get procaddress for CtlCancelEngineLoad");
           goto end;
    }
	if (NULL == (m_hIUEng = m_pfnCtlLoadIUEngine(TRUE, !fOnline))) //synchronous mode, selfupdate IU engine if required
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to call LoadIUEngine");
		goto end;
	}
       m_fEngineLoaded = TRUE;
	if (NULL == (m_pfnGetSystemSpec = (PFN_GetSystemSpec) GetProcAddress(m_hIUEng, "EngGetSystemSpec")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for GetSystemSpec");
		goto end;
	}
	if (NULL == (m_pfnGetManifest = (PFN_GetManifest) GetProcAddress(m_hIUEng, "EngGetManifest")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for GetManifest");
		goto end;
	}

	if (NULL == (m_pfnDetect = (PFN_Detect)GetProcAddress(m_hIUEng, "EngDetect")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for Detect");
		goto end;
	}
	if (NULL == (m_pfnInstall = (PFN_Install)GetProcAddress(m_hIUEng, "EngInstall")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for Install");
		goto end;
	}
	if (NULL == (m_pfnSetOperationMode = (PFN_SetOperationMode)GetProcAddress(m_hIUEng, "EngSetOperationMode")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for SetOperationMode");
		goto end;
	}
	if (NULL == (m_pfnCreateEngUpdateInstance = (PFN_CreateEngUpdateInstance)GetProcAddress(m_hIUEng, "CreateEngUpdateInstance")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for CreateEngUpdateInstance");
		goto end;
	}
	if (NULL == (m_pfnDeleteEngUpdateInstance = (PFN_DeleteEngUpdateInstance)GetProcAddress(m_hIUEng, "DeleteEngUpdateInstance")))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to getprocaddress for DeleteEngUpdateInstance");
		goto end;
	}

	if (NULL == (m_hIUEngineInst = m_pfnCreateEngUpdateInstance()))
	{
		hr = E_FAIL;
		DEBUGMSG("AUBaseCatalog:PrepareIU() Fail to call CreateEngUpdateInstance");
		goto end;
	}
end:
       if (FAILED(hr))
            {
                FreeIU();
            }
#ifdef DBG
       DEBUGMSG("PrepareIU() take %d msecs", GetTickCount() - dwStart);
#endif
       DEBUGMSG("PrepareIU() done");
        return hr;
}


// could be called even if without PrepareIU() being called first
void AUBaseCatalog::FreeIU()
{
       DEBUGMSG("AUCatalog::FreeIU() starts");
#ifdef DBG
       DWORD dwStart = GetTickCount();
#endif

	if (NULL != m_hIUEng)
	{
		if (NULL != m_pfnDeleteEngUpdateInstance)
		{
			  DEBUGMSG("calling DeleteEngUpdateInstance ....");
			  m_pfnDeleteEngUpdateInstance(m_hIUEngineInst);
		}
		if (NULL != m_pfnCtlUnLoadIUEngine)
		{
			  DEBUGMSG("calling ctlunloadIUengine ....");
			  m_pfnCtlUnLoadIUEngine(m_hIUEng);
		}
	}
	if (NULL != m_hIUCtl)
        {
	   FreeLibrary(m_hIUCtl);
	 }

	Reset();
#ifdef DBG
    DEBUGMSG("FreeIU() take %d msecs", GetTickCount() - dwStart);
#endif
	DEBUGMSG("AUCatalog::FreeIU() done");
}

HRESULT AUBaseCatalog::CancelNQuit(void)
{
    HRESULT hr = S_OK;
    DEBUGMSG("AUBaseCatalog::CancelNQuit() starts");
    if (!m_fEngineLoaded && NULL != m_pfnCtlCancelEngineLoad)
        {
            DEBUGMSG("IU Engine not loaded. Cancel loading if so");
            hr =  m_pfnCtlCancelEngineLoad();
        }
    else if (m_fEngineLoaded && NULL != m_pfnSetOperationMode)
        {
            DEBUGMSG("IU Engine loaded. Cancel any IU operation");
            hr = m_pfnSetOperationMode(m_hIUEngineInst, NULL, UPDATE_COMMAND_CANCEL);
        }
    DEBUGMSG("AUBaseCatalog::CancelNQuit() ends");
    return hr;
}

AUBaseCatalog::~AUBaseCatalog(void)
{
//    DEBUGMSG("AUBaseCatalog::~AUBaseCatalog() starts");
    if (NULL != ghMutex) //client don't need this
        {
        WaitForSingleObject(ghMutex, INFINITE); //If CancelNQuit is being called, wait until it is done
        ReleaseMutex(ghMutex);
        }
//    DEBUGMSG("AUBaseCatalog::~AUBaseCatalog() ends");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\wuaueng.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      wuaueng.h
//
//--------------------------------------------------------------------------

#pragma once
#include <windows.h>
#include <wchar.h>
#include <tchar.h>
#include <ole2.h>
#include <setupapi.h>
#include <wininet.h>
#include <inseng.h>
//#include <newtrust.h>
#include <malloc.h>
#include <stddef.h>
//#include <atlconv.h>
#include <wuaustate.h>
#include "wuaulib.h"
#include "AUSessions.h"

#include <URLLogging.h>

#define AUSCHEDINSTALLDAY_MIN 		0
#define AUSCHEDINSTALLDAY_MAX 		7
#define AUSCHEDINSTALLTIME_MIN 		0
#define AUSCHEDINSTALLTIME_MAX 		23

typedef struct tagWORKER_THREAD_INIT_DATA 
{
	UINT uFirstMsg;
	BOOL fWaitB4Detect;
	DWORD dwWaitB4Detect;
} WORKER_THREAD_INIT_DATA;


#define E_NOCONNECTION		HRESULT_FROM_WIN32(ERROR_CONNECTION_UNAVAIL)

HRESULT	SelfUpdate(void);
HRESULT CheckForUpdatedComponents(BOOL   *pfInstalledWUAUENG);
HRESULT	InstallFromCIF(LPCTSTR pstrCifCab, LPCTSTR pstrDownloadDir, LPCTSTR pstrWhich);

/////////////////////////////////////////////////////////
// Status ping information
/////////////////////////////////////////////////////////
class PingStatus: public CUrlLog //group together status ping functions
{
public:
	inline PingStatus(void):CUrlLog(_T("au"), NULL, NULL){}

	void ReadLiveServerUrlFromIdent(void);
	void PingDetectionSuccess(
			BOOL fOnline,
			UINT cItems);
	void PingDetectionFailure(
			BOOL fOnline,
			DWORD dwError,
			LPCTSTR ptszMessage = NULL);
	void PingDownload(
			BOOL fOnline,
			URLLOGSTATUS status,
			DWORD dwError,
			LPCTSTR ptszItemID = NULL,
			LPCTSTR ptszDeviceID = NULL,
			LPCTSTR ptszMessage = NULL);
	void PingSelfUpdate(
			BOOL fOnline,
			URLLOGSTATUS status,
			DWORD dwError);
	void PingDeclinedItem(
			BOOL fOnline,
			URLLOGACTIVITY activity,
			LPCTSTR ptszItemID);


private:
	//----------------------------------------------------------------------
	//
	// private function to gather common info and perform ping
	//
	//----------------------------------------------------------------------
	void _Ping(
			BOOL fOnline,
			URLLOGACTIVITY activity,
			URLLOGSTATUS status,
			DWORD dwError,
			LPCTSTR ptszMessage,
			LPCTSTR ptszItemID,
			LPCTSTR ptszDeviceID);
};


#define IDOWNLOAD_COMPLETE_EVT			0
#define IDOWNLOAD_TRANSIENT_ERROR_EVT	1
#define IDOWNLOAD_DOWNLOAD_IN_PROGRESS  2
#define IDOWNLOAD_SERVICE_FINISH		3
#define IDOWNLOAD_SERVICE_DISABLED		4
#define IDOWNLOAD_DOWNLOAD_CANCELED		5

#define IDOWNLOAD_MESSAGE				6
#define CNUM_DOWNLOAD_EVT				6

extern HANDLE ghServiceFinished;
extern HANDLE ghEngineState;
extern HANDLE ghServiceDisabled;
extern HANDLE ghValidateCatalog;
extern HANDLE	ghNotifyClient;
extern HANDLE ghWorkerThreadMsgQueueCreation;
extern CLIENT_NOTIFY_DATA	gClientNotifyData;
extern DWORD	gdwWorkerThreadId;
extern SESSION_STATUS gAdminSessions;
extern PingStatus gPingStatus;


typedef struct _ENGINE_EVENTS
{
public:
void CloseEvents(void)
{
	//Don't close the ServiceFinish handle and EngineState events
	m_grEvents[IDOWNLOAD_SERVICE_FINISH] = NULL; 
	m_grEvents[IDOWNLOAD_SERVICE_DISABLED] = NULL; 	

	for ( int i = 0; i < CNUM_DOWNLOAD_EVT; i++) 
	{
		SafeCloseHandleNULL(m_grEvents[i]);
	}
}

BOOL CreateEvents(void)
{
	BOOL fRet = TRUE;
	ZeroMemory(m_grEvents, sizeof(m_grEvents));
	
	m_grEvents[IDOWNLOAD_SERVICE_FINISH] = ghServiceFinished;
	m_grEvents[IDOWNLOAD_SERVICE_DISABLED] = ghServiceDisabled; 

	for ( int i = 0; i < CNUM_DOWNLOAD_EVT; i++) 
	{
		if ( IDOWNLOAD_SERVICE_FINISH != i && IDOWNLOAD_SERVICE_DISABLED != i )
		{
			if ( NULL == (m_grEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL)) )
			{
				CloseEvents();
				fRet = FALSE;
				break;
			}
		}
	}

	return fRet;
}

void SetEvent(ULONG iEvent)
{
	if ( (iEvent < CNUM_DOWNLOAD_EVT) && (NULL != m_grEvents[iEvent]) )
	{
		::SetEvent(m_grEvents[iEvent]); 		
	}
}

ULONG cEvents(void)
{
	return CNUM_DOWNLOAD_EVT;
}

CONST HANDLE * grEventHandles(void)
{
	return m_grEvents;
}
private:
	HANDLE m_grEvents[CNUM_DOWNLOAD_EVT];

} ENGINE_EVENTS;

//defined in wuaueng.cpp
HRESULT HrCreateNewCatalog(void);
void CancelDownload(void);
void ResumeDownloadIfNeccesary(void);
HRESULT UpdateProc(WORKER_THREAD_INIT_DATA &initData);
DWORD RandomWaitTimeBeforeDetect();


//defined in service.cpp
BOOL FDownloadIsPaused();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaueng\tscompat.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  tscompat.cpp
//
//  This module include functions that were introduced to replace missing
//  functions/functionality from Windows XP to Windows 2000. 
//
//  10/11/2001   annah   Created
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "tscompat.h"
#include "service.h"


//----------------------------------------------------------------------------
// Replacements for TS functions
//----------------------------------------------------------------------------

//
// Copied from TS sources, as this function is not available on the
// win2k wtsapi32.dll. The function has the same functionality as WTSQueryUserToken().
//
BOOL WINAPI _WTSQueryUserToken(/* in */ ULONG SessionId, /* out */ PHANDLE phToken)
{
    BOOL IsTsUp = FALSE;
    BOOL    Result, bHasPrivilege;
    ULONG ReturnLength;
    WINSTATIONUSERTOKEN Info;
    HANDLE hUserToken = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    // Do parameter Validation
    if (NULL == phToken) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

	// If it is session 0, don't call winsta. Use GetCurrentUserToken instead. 
	if (SessionId == 0)
	{
        hUserToken = GetCurrentUserTokenW(L"WinSta0",
                                            TOKEN_QUERY |
                                            TOKEN_DUPLICATE |
                                            TOKEN_ASSIGN_PRIMARY
                                            );

        if (hUserToken == NULL)
            return FALSE;
        else 
            *phToken = hUserToken;
   	}
	else	// Non-zero sessions
	{
		// No one except TS has any idea about non-zero sessions. So, check if the TS is running.
	    IsTsUp = _IsTerminalServiceRunning();
		if (IsTsUp) 
		{	// This is so that CSRSS can dup the handle to our process
			Info.ProcessId = LongToHandle(GetCurrentProcessId());
			Info.ThreadId = LongToHandle(GetCurrentThreadId());

			Result = WinStationQueryInformation(
				        SERVERNAME_CURRENT,
					    SessionId,
						WinStationUserToken,
	                    &Info,
		                sizeof(Info),
			            &ReturnLength
				        );

	        if( !Result ) 
				return FALSE;
		    else 
				*phToken = Info.UserToken ; 
		}
		else
		{	// TS is not running. So, set error for non-zero sessions: WINSTATION_NOT_FOUND.
            SetLastError(ERROR_CTX_WINSTATION_NOT_FOUND);
            return FALSE;
        }
	}
			
    return TRUE;
}

//
// This function determines if the Terminal Service is currently Running.
// Copied from TS sources, as it is required on the _WTSQueryUserToken() function.
//
BOOL _IsTerminalServiceRunning (VOID)
{

    BOOL bReturn = FALSE;
    SC_HANDLE hServiceController;

    hServiceController = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hServiceController) 
    {
        SC_HANDLE hTermServ ;
        hTermServ = OpenService(hServiceController, L"TermService", SERVICE_QUERY_STATUS);
        if (hTermServ) 
        {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus)) 
            {
                bReturn = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
            } 
            else 
            {
                CloseServiceHandle(hTermServ);
                CloseServiceHandle(hServiceController);
                return FALSE;
            }

            CloseServiceHandle(hTermServ);
        } 
        else 
        {
            CloseServiceHandle(hServiceController);
            return FALSE;
        }
        CloseServiceHandle(hServiceController);
    } 
    else 
    {
        return FALSE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\auwait.cpp ===
#include "pch.h"
#pragma hdrstop
const TCHAR szAUTestValidationFile[] = _T("autest.cab");

DWORD dwTimeToWait(DWORD dwTimeInSecs, DWORD dwMinSecs)
{
    static DWORD dwSecsInADay = -1;

    if ( -1 == dwSecsInADay)
    {
  		dwSecsInADay = AU_ONE_DAY;

#ifndef DBG
		if (WUAllowTestKeys(szAUTestValidationFile) )
#endif
		{
			if (FAILED(GetRegDWordValue(_T("SecsInADay"), &dwSecsInADay)) ||
             (dwSecsInADay > AU_ONE_DAY) )
			{
				dwSecsInADay = AU_ONE_DAY;
			}
		}
    }

    DWORD dwMS = DWORD((((double(1000) * double(dwTimeInSecs)) / double(AU_ONE_DAY)) * double(dwSecsInADay)));
    DWORD dwMinMS = dwMinSecs * 1000;

    if ( dwMS < dwMinMS )
    {
        dwMS = dwMinMS;
    }

    if ( dwMS < AU_MIN_MS )
	{
		// we dont' wait less that 1 second
		dwMS = AU_MIN_MS;
	}

	return dwMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\aucompat.cpp ===
/****************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:
    aucompat.cpp

Revision History:
    DerekM      created     10/28/01

****************************************************************************/

#include "pch.h"
#pragma hdrstop

// **************************************************************************
BOOL AUIsTSRunning(void)
{
    SC_HANDLE   hsc;
    BOOL        fRet = FALSE;

    hsc = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hsc != NULL) 
    {
        SC_HANDLE hsvcTS;
        
        hsvcTS = OpenService(hsc, L"TermService", SERVICE_QUERY_STATUS);
        if (hsvcTS != NULL) 
        {
            SERVICE_STATUS ss;
            
            if (QueryServiceStatus(hsvcTS, &ss))
                fRet = (ss.dwCurrentState == SERVICE_RUNNING);

            CloseServiceHandle(hsvcTS);
        } 

        CloseServiceHandle(hsc);
    } 

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\audirectory.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       wudirectory.cpp
//  Desc:     This is the definition file that implements function(s)
//			related to find out where to get the Critical Fix cab file.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

TCHAR g_szWUDir[MAX_PATH+1] = _T("\0");        //Path to windows update directory
const TCHAR CABS_DIR[] = _T("cabs");
const TCHAR RTF_DIR[] = _T("RTF");
const TCHAR EULA_DIR[] = _T("EULA");
const TCHAR DETAILS_DIR[] = _T("Details");
const TCHAR C_DOWNLD_DIR[] = _T("wuaudnld.tmp");

BOOL AUDelFileOrDir(LPCTSTR szFileOrDir)
{
	if (NULL == szFileOrDir)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	BOOL fIsDir = TRUE;
	if (fFileExists(szFileOrDir, &fIsDir))
	{
		if (fIsDir)
		{
			if (DelDir(szFileOrDir))
			{
				return RemoveDirectory(szFileOrDir);
			}
			return FALSE;
		}
		else
		{
			return DeleteFile(szFileOrDir);
		}
	}
	SetLastError(ERROR_FILE_NOT_FOUND);
	return FALSE;
}

////////////////////////////////////////////////////////////////////////
// Create the WU directory if it doesnt already exist
// return FALSE if failed 
/////////////////////////////////////////////////////////////////////////
BOOL CreateWUDirectory(BOOL fGetPathOnly)
{
    BOOL fRet = FALSE;
    static BOOL fWUDirectoryExists = FALSE;

    // WindowsUpdate Directory already exists
    if (fWUDirectoryExists)  
    {
        fRet = TRUE;
        goto done;
    }

    //Get the path to the windows update directory
    if( !GetWUDirectory(g_szWUDir, ARRAYSIZE(g_szWUDir)))
    {
        goto done;
    }

    //If we need to set the acls to the directory
    if(!fGetPathOnly)
    {
        //Set ACLS, create directory if it doesnt already exist
        if( FAILED(CreateDirectoryAndSetACLs(g_szWUDir, TRUE)))
        {
            goto done;
        }
        //We shouldnt care if we couldnt set attributes
        SetFileAttributes(g_szWUDir, FILE_ATTRIBUTE_HIDDEN | GetFileAttributes(g_szWUDir));
    }
    //Append the backslash
    if(FAILED(StringCchCatEx(g_szWUDir, ARRAYSIZE(g_szWUDir), _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
    	goto done;
    }   

    fRet = TRUE;
    
done:
    if(!fRet)
    {
        g_szWUDir[0] = _T('\0');
    }
    else
    {
        fWUDirectoryExists = TRUE;
    }
    return fRet;
}


//this function delete all the files and subdirectories under lpszDir
int DelDir(LPCTSTR lpszDir)
{
	TCHAR szFilePattern[MAX_PATH], szFileName[MAX_PATH];
	HANDLE	hFind;
	WIN32_FIND_DATA	FindFileData;
	
	if ( NULL == lpszDir ||
		 FAILED(StringCchCopyEx(szFilePattern, ARRAYSIZE(szFilePattern), lpszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		 FAILED(StringCchCatEx(szFilePattern, ARRAYSIZE(szFilePattern), _T("\\*.*"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		 INVALID_HANDLE_VALUE == (hFind = FindFirstFile(szFilePattern, &FindFileData)))
	{
		return 0;
	}
	FindNextFile(hFind, &FindFileData);				//skip "." and ".."
	while(FindNextFile(hFind, &FindFileData))
	{
		if ( FAILED(StringCchCopyEx(szFileName, ARRAYSIZE(szFileName), lpszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			 FAILED(StringCchCatEx(szFileName, ARRAYSIZE(szFileName), _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			 FAILED(StringCchCatEx(szFileName, ARRAYSIZE(szFileName), FindFileData.cFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)) )
		{
			FindClose(hFind);
			return 0;
		}

		if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			DelDir(szFileName);
			RemoveDirectory(szFileName);
		}
		else
		{
			DeleteFile(szFileName);			
		}
	}
	FindClose(hFind);
	return 1;
}

////////////////////////////////////////////////////////////////////////
// Delete file using regular expression (e.g. *, ? etc)
// tszDir : the directory where file resides. It ends with '\'
// tszFilePattern: file(s) expressed in regular expression or plain format
/////////////////////////////////////////////////////////////////////////
int RegExpDelFile(LPCTSTR tszDir, LPCTSTR tszFilePattern)
{
	WIN32_FIND_DATA fd;
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	BOOL fMoreFiles = FALSE;
	TCHAR tszFileName[MAX_PATH+1];
	INT nRet = 1;

	if (FAILED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), tszFilePattern, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		nRet = 0;
		goto done;
	}
		
	hFindFile = FindFirstFile(tszFileName, &fd);
	if (INVALID_HANDLE_VALUE == hFindFile)
	{
//		DEBUGMSG("RegExpDelFile() no more files found");
		nRet = 0;
		goto done;
	}
	
	do
	{
		if (SUCCEEDED(StringCchCopyEx(tszFileName, ARRAYSIZE(tszFileName), tszDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
			SUCCEEDED(StringCchCatEx(tszFileName, ARRAYSIZE(tszFileName), fd.cFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
//		DEBUGMSG("RegExpDelFile() Deleting file %S", tszFileName);
			DeleteFile(tszFileName);
		}
		else
		{
//			DEBUGMSG("RegExpDelFile() failed to construct file name to delete");
			nRet = 0;
		}
	}
	while (fMoreFiles = FindNextFile(hFindFile, &fd));
	
done:
	if (INVALID_HANDLE_VALUE != hFindFile)
	{
		FindClose(hFindFile);
	}
	return nRet;
}

/////////////////////////////////////////////////////////////////////////////
//
// Function CreateDownloadDir()
//			Creates the download directory
//
// Input:   a string points to the directory to create
// Output:  None
// Return:  HRESULT to tell the result
// Remarks: If the directory already exists, takes no action
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CreateDownloadDir(LPCTSTR lpszDir)
{
//	USES_CONVERSION;
    DWORD dwRet = 0/*, attr*/;
    HRESULT hRet = E_FAIL;

    if (lpszDir == NULL || lpszDir[0] == EOS)
    {
        return E_INVALIDARG;
    }

    if (CreateDirectory(lpszDir, NULL))
    {
		if (!SetFileAttributes(lpszDir, FILE_ATTRIBUTE_HIDDEN))
        {
			dwRet = GetLastError();
            DEBUGMSG("CreateDownloadDir() failed to set hidden attribute to %S (%#lx).", lpszDir, dwRet);
            hRet = S_FALSE; // it's okay to use this dir.
        }
		else
			hRet = S_OK;
    }
    else
    {
		dwRet = GetLastError();

		if (dwRet != ERROR_ALREADY_EXISTS)
		{
			DEBUGMSG("CreateDownloadDir() failed to create directory %S (%#lx).", lpszDir, dwRet);
			hRet = HRESULT_FROM_WIN32(dwRet);
		}
		// ERROR_ALREADY_EXISTS is acceptable
		else
			hRet = S_OK;
	}

    return (hRet);
}


inline BOOL EnsureDirExists(LPCTSTR lpszDir)
{
	BOOL fIsDir = FALSE;
	BOOL fRet = FALSE;

	if (fFileExists(lpszDir, &fIsDir))
	{
		if (!fIsDir)
		{
			DEBUGMSG("WARNING: directory squatting. File with same name %S exists", lpszDir);
			DeleteFile(lpszDir);
		}
		else
		{
//			DEBUGMSG("Direcotry %S exists, no need to create again", lpszDir);
			return TRUE;
		}
	}
    if (!(fRet = CreateNestedDirectory(lpszDir)))
    {
    	DEBUGMSG("Fail to createnesteddirectory with error %d", GetLastError());
    }
	 
//	DEBUGMSG(" Create directory %S %s", lpszDir, fRet ? "succeeded": "failed");
	return fRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// Function GetDownloadPath()
//			Gets the download directory path
// Input:   a buffer to store the directory created and size of the buffer in TCHARs
// Output:  None
// Return:  HRESULT to tell the result
//
/////////////////////////////////////////////////////////////////////////////
HRESULT GetDownloadPath(LPTSTR lpszDir, DWORD dwCchSize)
{
    UINT	nSize;
    TCHAR	szDir[MAX_PATH];
    HRESULT hr;

    if (lpszDir == NULL)
    {
        return (E_INVALIDARG);
    }
    AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(hr = StringCchCopyEx(szDir, ARRAYSIZE(szDir), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        DEBUGMSG("GetDownloadPath() failed to get WinUpd directory");
        return hr;
    }
	if (FAILED(hr = PathCchAppend(szDir, ARRAYSIZE(szDir), C_DOWNLD_DIR)))
	{
        DEBUGMSG("GetDownloadPath() found input buffer too small.");
        return (hr);
	}
    if (FAILED(hr = StringCchCopyEx(lpszDir, dwCchSize, szDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		DEBUGMSG("GetDownloadPath() call to StringCchCopyEx() failed.");
		return hr;
	}
    return EnsureDirExists(lpszDir) ? S_OK : E_FAIL;
}

HRESULT GetDownloadPathSubDir(LPTSTR lpszDir, DWORD dwCchSize, LPCTSTR tszSubDir)
{
   HRESULT hr;
    if (FAILED(hr = GetDownloadPath(lpszDir, dwCchSize)))
        {
        DEBUGMSG("GetDownloadPathSubDir() fail to get download path");
        return hr;
        }
	if (FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, tszSubDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		DEBUGMSG("GetDownloadPathSubDir() failed to construct download path subdir with error %#lx.", hr);
		return hr;
	}
    return EnsureDirExists(lpszDir) ? S_OK : E_FAIL;
}    

///////////////////////////////////////////////////////////////
// get the path to download software update bits
// lpszDir  : IN buffer to store the path and its size in TCHARs
// return : S_OK if success
//           : E_INVALIDARG if buffer too small
//           : E_FAIL if other error
//////////////////////////////////////////////////////////////
HRESULT GetCabsDownloadPath(LPTSTR lpszDir, DWORD dwCchSize)
{
return GetDownloadPathSubDir(lpszDir, dwCchSize, CABS_DIR);
}

///////////////////////////////////////////////////////////////
// get the path to download UI specific data, like description and rtf
// lpszDir  : IN buffer to store the path and its size in TCHARs
// return : S_OK if success
//////////////////////////////////////////////////////////////
HRESULT GetUISpecificDownloadPath(LPTSTR lpszDir, DWORD dwCchSize, LANGID langid, LPCTSTR tszSubDir)
{
    HRESULT hr ;
    if (FAILED(hr = GetDownloadPath(lpszDir, dwCchSize)))
        {
        DEBUGMSG("GetUISpecificDownloadPath() fail to get download path");
        return hr;
        }
    TCHAR tszLangId[10];
    if (FAILED(StringCchPrintfEx(tszLangId, ARRAYSIZE(tszLangId), NULL, NULL, MISTSAFE_STRING_FLAGS, _T("%04x"), langid)))
	{
		return E_INVALIDARG;
	}
	if (FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, tszSubDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, _T("\\"), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(lpszDir, dwCchSize, tszLangId, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
		DEBUGMSG("GetUISpecificDownloadPath() failed to construct ui specific download path with error %#lx.", hr);
		return hr;
	}
    return EnsureDirExists(lpszDir)? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////
// get the rtf download path for a language
// lpszDir : IN buffer to store the path and its size in TCHARs
// return: S_OK if success
//           : E_INVALIDARG if buffer too small
//           : E_FAIL if other error
//////////////////////////////////////////////////////////////
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, DWORD dwCchSize, LANGID langid)
{
  return GetUISpecificDownloadPath(lpszDir, dwCchSize, langid, RTF_DIR);
}

/////////////////////////////////////////////////////////////////
// get language independent RTF directory
/////////////////////////////////////////////////////////////////
HRESULT GetRTFDownloadPath(LPTSTR lpszDir, DWORD dwCchSize)
{
    return GetDownloadPathSubDir(lpszDir, dwCchSize, RTF_DIR);
}

/////////////////////////////////////////////////////////////////////////////
//
// Function MakeTempDownloadDir()
//			Insures that a local temporary directory exists for downloads
//
// Input:   pstrTarget  - [out] path to temp dir and its size in TCHARs
// Output:  Makes a new directory if needed
// Return:  HRESULT
/////////////////////////////////////////////////////////////////////////////

HRESULT MakeTempDownloadDir(LPTSTR        pszTarget, DWORD dwCchSize)
{
    HRESULT hr;
    if (FAILED(hr = GetDownloadPath(pszTarget, dwCchSize)) ||
		// Make sure it exists
		FAILED(hr = CreateDownloadDir(pszTarget)))
        return hr;

    return NOERROR;
}

HRESULT GetRTFLocalFileName(BSTR bstrRTFPath, LPTSTR lpszFileName, DWORD dwCchSize, LANGID langid)
{
    HRESULT hr ;
    hr =  GetRTFDownloadPath(lpszFileName, dwCchSize, langid);
    if (SUCCEEDED(hr))
        {
        hr = PathCchAppend(lpszFileName, dwCchSize, PathFindFileName(W2T(bstrRTFPath)));
        }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\itemlist.cpp ===
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ItemList.cpp
//
//  Purpose:	AU Item List
//
//  Creator:	PeterWi
//
//  History:	08-27-01 	first created
//
//--------------------------------------------------------------------------
#include "pch.h"


//=======================================================================
//
//  AUCatalogItemList::Clear
//
//=======================================================================
void AUCatalogItemList::Clear(void)
{
    if ( NULL != pList )
    {
    	for ( DWORD index = 0; index < Count(); index++ )
		{
			delete pList[index];
		}
    }
    SafeFreeNULL(pList);
    uNum = 0;
}

UINT AUCatalogItemList::GetNum(DWORD dwSelectionStatus)
    {
	    UINT nNum = 0;
	    
        for ( UINT index = 0; index < Count(); index++ )
	    {
		    if ( dwSelectionStatus == operator[](index).dwStatus() )
		    {
			    nNum++;
		    }
	    }
        return nNum;
    }


void  AUCatalogItemList::DbgDump(void)
	{
#ifdef DBG
		DEBUGMSG("Iterating %d items in the list....", uNum);
		for (UINT i = 0; i < uNum; i++)
		{
			pList[i]->dump();
		}
		DEBUGMSG("Iterating item list done");
#endif
	}



//=======================================================================
//
//  AUCatalogItemList::Allocate(DWORD cItems)
//
//=======================================================================
HRESULT AUCatalogItemList::Allocate(DWORD cItems)
{
    HRESULT hr = S_OK;
    DWORD index = 0;

    Clear();

	//pList shouldn't be pointer to pointer
	pList = (AUCatalogItem**)malloc(cItems * sizeof(AUCatalogItem *));
	if ( NULL == pList )
	{
        hr = E_OUTOFMEMORY;
        goto done;
	}

	for ( index = 0; index < cItems; index++ )
	{
		pList[index] = (AUCatalogItem*) new AUCatalogItem;
		if ( NULL == pList[index] )
		{
			hr = E_OUTOFMEMORY;
                    goto done;
		}
	}
done:
    if (FAILED(hr))
    {
        for (DWORD i = 0; i < index; i++)
        {
            delete pList[i];
        }
        free(pList);        
    }
        
    uNum = SUCCEEDED(hr) ? cItems : 0;
	return hr;
}


//=======================================================================
//
//  AUCatalogItemList::Allocate(VARIANT & var)
//
//=======================================================================
HRESULT AUCatalogItemList::Allocate(VARIANT & var)
{
    HRESULT hr = S_OK;
	long UBound = 0;
    long cItems;

	if ( ((VT_ARRAY | VT_VARIANT) != var.vt) ||
		 FAILED(SafeArrayGetUBound(var.parray, 1, &UBound)) /*| (0 != (++cItems % 7))*/ )
	{
		// temp
		DEBUGMSG("Invalid array");
             hr = E_INVALIDARG;
             goto done;
	}

    cItems = (UBound + 1) / 7;
    DEBUGMSG("Variant Array size of %d", UBound + 1);

    hr = Allocate(cItems);
done:
	return hr;
}


//=======================================================================
//
//  AUCatalogItemList::Add
//
//=======================================================================
BOOL AUCatalogItemList::Add(AUCatalogItem *pitem)
{
	AUCatalogItem** pNewList = (AUCatalogItem**)realloc(pList, (uNum+1)*sizeof(AUCatalogItem *));

    BOOL fRet = (NULL != pNewList);

    if ( fRet )
    {
        pList = pNewList;
	    pList[uNum] = pitem;
	    uNum++;
    }

    return fRet;
}

//=======================================================================
//
//  AUCatalogItemList::Remove
//
//=======================================================================
void AUCatalogItemList::Remove(BSTR bstrItemID)
{
    int index = -1;
    AUASSERT(NULL != bstrItemID);
    AUASSERT(L'\0' != *bstrItemID);
    if (0 == SysStringLen(bstrItemID))
    {
    	return ;
    }
    for (UINT u = 0; u < uNum; u++)
        {
            if (0 == StrCmpI(W2T(bstrItemID), W2T(pList[u]->bstrID())))
            {
                index = u;
                break;
            }
        }
    if (-1 == index)
        {
            //DEBUGMSG("Fail to find the item to remove");
            return;
        }
    AUCatalogItem *ptmp;
    ptmp = pList[index];
    pList[index] = pList[uNum-1];
    delete ptmp;
    uNum--;
    return;
}

//=======================================================================
//
//  AUCatalogItemList::Contains
//  returns -1 if item not found. index of the item if it is found
//=======================================================================
INT AUCatalogItemList::Contains(BSTR bstrItemID)
{
  for (UINT u = 0; u < uNum; u++)
        {
            if (0 == StrCmpI(W2T(bstrItemID), W2T(pList[u]->bstrID())))
            {
                return u;
            }
        }
    return -1;
}

HRESULT AUCatalogItemList::Copy(AUCatalogItemList & itemlist2)
{
	AUASSERT(this != &itemlist2);
	if (this == &itemlist2)
	{
		return E_INVALIDARG;
	}
    long lNum = itemlist2.Count();
    HRESULT hr = S_OK;
    Clear();
    for (long l = 0; l < lNum; l++)
    {
        AUCatalogItem *pItem = new AUCatalogItem(itemlist2[l]);
        if ( NULL == pItem)
        {
            DEBUGMSG("Fail to create new aucatalog item");
            hr = E_OUTOFMEMORY;
            break;
        }
        if (!pItem->fEqual(itemlist2[l]) || !Add(pItem))
        {
        	DEBUGMSG("Fail to create new item or add the new item");
        	delete pItem;
        	hr = E_OUTOFMEMORY;
        	break;
        }
    }
	if (FAILED(hr))
	{
		Clear();
	}
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// walk through each item in the list and use the m_DependentItems information to 
// find all dependent items each item depends on indirectly, add them to m_DependentItems 
// list. 
/////////////////////////////////////////////////////////////////////////////
HRESULT AUCatalogItemList::BuildIndirectDependency()
{
    HRESULT hr = S_OK ;
    BOOL fNeedMoreScan;

//    DEBUGMSG("AUCatalogItemList::BuildIndirectDependency() starts");
    do
    {
        fNeedMoreScan = FALSE;
        for (UINT i = 0; i < uNum; i++)
            {
            if (pList[i]->m_DependingItems.Count() > 0)
                {//has direct depending items
                AUCatalogItem & item =operator[](i);
                for (UINT j = 0; j < item.m_DependingItems.Count() ; j++)
                    {
                     INT directDependingItemIndex = Contains(item.m_DependingItems[j].bstrID());
                     if (directDependingItemIndex < 0)
                        {
                            DEBUGMSG("WARNING: item list is not self contained");
                            continue;
                        }
                     AUCatalogItem & directDependingItem = operator[](directDependingItemIndex);
    //                 DEBUGMSG("direct depending item %S has %d depending items", directDependingItem.bstrID(), directDependingItem.m_DependingItems.Count());
                     for (UINT k = 0; k < directDependingItem.m_DependingItems.Count(); k++)
                        { //add all one level deep indirect depending items, if not duplicated
                            INT indirectDependingItemIndex = Contains(directDependingItem.m_DependingItems[k].bstrID());
                            if (indirectDependingItemIndex < 0)
                                {
                                DEBUGMSG("WARNING: item list is not self contained");
                                continue;
                                }
                            AUCatalogItem &indirectDependingItem = operator[](indirectDependingItemIndex);
                            if (item.m_DependingItems.Contains(indirectDependingItem.bstrID()) < 0)
                                { // need to add the indirect depending item
                                    AUCatalogItem * pnewdependingItem = new AUCatalogItem(indirectDependingItem);
                                    if (NULL == pnewdependingItem)
                                        {
                                            hr = E_OUTOFMEMORY;
                                            goto done;
                                        }
                                    if (!pnewdependingItem->fEqual(indirectDependingItem) || !item.m_DependingItems.Add(pnewdependingItem))
                                    {
                                    	delete pnewdependingItem;
                                    	hr = E_OUTOFMEMORY;
                                    	goto done;
                                    }
                                    
                                    DEBUGMSG("item %S indirectly depending on item %S. Dependency recorded", indirectDependingItem.bstrID(), item.bstrID());
                                    fNeedMoreScan = TRUE;
                               }
                            else
                                {
        //                        DEBUGMSG("item %d indirect dependency alreay in", i);
                                }
                        }
                    }
                }
            }
    }
    while (fNeedMoreScan);
done:
//    DEBUGMSG("AUCatalogItemList::BuildIndirectDependency() ends with result %#lx", hr);
	if (FAILED(hr))
	{
		for (UINT i = 0; i < Count(); i++)
		{
			pList[i]->m_DependingItems.Clear();
		}
	}

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
// check if item indexed is relevant in downloading and installation
// i.e. one or more of its depending items needs to be downloaded or installed (a.k.a selected)
//////////////////////////////////////////////////////////////////////////////
BOOL  AUCatalogItemList::ItemIsRelevant(UINT index) 
{
	if (index >= uNum)
	{
		AUASSERT(FALSE);  //should never be here
		return FALSE;
	}
    for (UINT i = 0;  i < pList[index]->m_DependingItems.Count(); i++)
        {
            AUCatalogItem & dependingItem = pList[index]->m_DependingItems[i];
            INT index2 = Contains(dependingItem.bstrID());
            if (index2 >= 0 && pList[index2]->fSelected())
                {
                    DEBUGMSG("Item %S is relevant because item %S is selected", pList[index2]->bstrID(), dependingItem.bstrID());
                    return TRUE;
                }
        }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\debug.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    debug.cpp
//
//  Creator: PeterWi
//
//  Purpose: debug functions
//
//=======================================================================

#include "pch.h"
#pragma hdrstop

#ifdef DBG

#define UNLEN 256
#define TYPE_KEY	TEXT("DebugType")
#define LOGFILE		1
#define DEBUGGEROUT	2

void WriteLogFile(LPCSTR s);

///////////////////////////////////////////////////////////////////////////////
//
// Function :	WuAUTrace
// In		:	Variable number of arguments
// Comments :	If DEBUGGEROUT is defined, uses OutputDebugString to write
//				debug messages. If LOGFILEOUT is defined, uses WriteLogFile
//				to write to a file. The filename is founf in the registry
//
///////////////////////////////////////////////////////////////////////////////
void _cdecl WUAUTrace(char* pszFormat, ...)
{
	USES_IU_CONVERSION;
	CHAR szBuf[1024+1];
	va_list ArgList;
	static DWORD dwType = 3;
	TCHAR szTimeString[80];
	SYSTEMTIME timeNow;
	CHAR szTemp[1040];
	LPSTR szTmp = NULL;

	if (! dwType ||			//on the second run this will be 0, 1 or 2
		NULL == pszFormat)
	{
		return;
	}

	va_start(ArgList, pszFormat);
    (void)StringCchVPrintfExA(szBuf, ARRAYSIZE(szBuf), NULL, NULL, MISTSAFE_STRING_FLAGS, pszFormat, ArgList);
	va_end(ArgList);

	if (dwType == 3)						//first time
	{
		if ((FAILED(GetRegDWordValue(TYPE_KEY, &dwType))) || (!dwType))
		{
			dwType = 0;
			return;						//no debug msg if no key or key==0
		}
	}

	GetLocalTime(&timeNow);
	if(SUCCEEDED(SystemTime2String(timeNow, szTimeString, ARRAYSIZE(szTimeString))))
	{
	    szTmp = T2A(szTimeString);
	}

	(void)StringCchPrintfExA(
			szTemp,
			ARRAYSIZE(szTemp),
			NULL, NULL, MISTSAFE_STRING_FLAGS,
			"%lx  %s : %s\r\n",
			GetCurrentThreadId(),
			NULL == szTmp ? "" : szTmp,
			szBuf);

	if (dwType==LOGFILE)
	{
		WriteLogFile(szTemp);
	}
	else
	{
		OutputDebugStringA(szTemp);
	}
}



///////////////////////////////////////////////////////////////////////////////
//
// Function :	CreateOrOpenDebugFile
// Out		:   File Handle to open debug file. Must be closed by caller
// Returns  :   TRUE for success, FALSE for failure
// Comments :	Creates a file "WinDir\wupd\username\wupdlog.txt"
//
///////////////////////////////////////////////////////////////////////////////
BOOL CreateOrOpenDebugFile(HANDLE& hFile)
{
	TCHAR szDir[MAX_PATH+1], szUser[UNLEN+1];
	DWORD dwNameLen = ARRAYSIZE(szUser), dwErr;
	const TCHAR szWUPDDir[] = _T("wupd");
	const TCHAR szLogFileName[] = _T("wupdlog.txt");
	const TCHAR szWUDir[] = _T("C:\\Program Files\\WindowsUpdate");

	if (FAILED(PathCchCombine(
					szDir,
					ARRAYSIZE(szDir),
					_T('\0') == g_szWUDir[0] ? szWUDir : g_szWUDir,
					szWUPDDir)))
	{
		return FALSE;
	}

	if (! CreateDirectory(szDir, NULL))
	{
		dwErr = GetLastError();
		if ((dwErr != ERROR_ALREADY_EXISTS) && (dwErr != ERROR_FILE_EXISTS))
		{
			return FALSE;
		}
	}

	if (! GetUserName(szUser, &dwNameLen))
	{
		const TCHAR szDefault[] = _T("default");

		(void)StringCchCopyEx(szUser, ARRAYSIZE(szUser), szDefault, NULL, NULL, MISTSAFE_STRING_FLAGS);
	}

	if (FAILED(PathCchAppend(szDir, ARRAYSIZE(szDir), szUser)))
	{
		return FALSE;
	}

	if (! CreateDirectory(szDir, NULL))
	{
		dwErr = GetLastError();
		if ((dwErr != ERROR_ALREADY_EXISTS) && (dwErr != ERROR_FILE_EXISTS))
		{
			return FALSE;
		}
	}

	if (FAILED(PathCchAppend(szDir, ARRAYSIZE(szDir), szLogFileName)))
	{
		return FALSE;
	}

	// We now have directory "drive:program files\windowsupdate\username\"
	if ((hFile = CreateFile(szDir,
							GENERIC_WRITE,
							FILE_SHARE_READ,
							NULL,
							OPEN_ALWAYS,
							0,
							NULL)) == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function :	WriteLogFile
// In		:	Variable number of arguments
// Comments :	If DEBUGGEROUT is defined, uses OutputDebugString to write
//				debug messages. If LOGFILEOUT is defined, uses WriteLogFile
//				to write to a file. The filename is found in the registry
//				If for some reason the reg value for filename is "", we
//				simply don't log.
// Courtesy	:	darshats
//
///////////////////////////////////////////////////////////////////////////////

void WriteLogFile(LPCSTR s)
{
	DWORD dwCurrSize = 0, cbWritten = 0;
	DWORD cbToWrite = lstrlenA(s);
	HANDLE hFile;

	if (!CreateOrOpenDebugFile(hFile))
		return;

	dwCurrSize = GetFileSize(hFile, NULL);
	SetFilePointer(hFile, dwCurrSize, NULL, FILE_BEGIN);
	(void) WriteFile(hFile, s, cbToWrite, &cbWritten, NULL);
	CloseHandle(hFile);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\cfreg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  SYSTEM:     Windows Update Critical Fix Notification
//
//  CLASS:      N/A
//  MODULE:     Connection Detection
//  FILE:       cfreg.CPP
//
/////////////////////////////////////////////////////////////////////
//
//  DESC:   This class implements all functions needed to access
//          machine registry to get information related to 
//          Windows Update  Critical Fix Notification feature.
//
//  AUTHOR: Charles Ma, Windows Update Team
//  DATE:   7/6/1998
//
/////////////////////////////////////////////////////////////////////
//
//  Revision History:
//
//  Date    Author          Description
//  ~~~~    ~~~~~~          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  7/6/98  Charles Ma      Created
//
/////////////////////////////////////////////////////////////////////
//
//      Copyrights:   1998 Microsoft  Corporation 
//
//      All rights reserved.
//
//      No portion of this source code may be reproduced
//      without express written permission of Microsoft Corporation.
//
//      This source code is proprietary and confidential.
/////////////////////////////////////////////////////////////////////
//
// CriticalFixReg.cpp: implementation of the functions used to 
// handle registry related operations
//
//////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

const TCHAR AUREGKEY_HKLM_DOMAIN_POLICY[] =        _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU");
const TCHAR	AUREGKEY_HKLM_WINDOWSUPDATE_POLICY[] = _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate");
const TCHAR	AUREGKEY_HKLM_IUCONTROL_POLICY[] =     _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR	AUREGKEY_HKLM_SYSTEM_WAS_RESTORED[] =  _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\SystemWasRestored");
const TCHAR AUREGKEY_HKCU_USER_POLICY[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate");
const TCHAR	AUREGKEY_HKLM_ADMIN_POLICY[] =         _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update");
const TCHAR AUREGVALUE_DISABLE_WINDOWS_UPDATE_ACCESS[] = _T("DisableWindowsUpdateAccess");
const TCHAR	AUREGKEY_REBOOT_REQUIRED[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired");


////////////////////////////////////////////////////////////////////////////
//
// Public Function  GetRegStringValue()
//                  Read the registry value for a REG_SZ key
// Input:   Name of value
// Output:  Buffer containing the registry value if successful
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int nCharCount, LPCTSTR lpszSubKeyName)
{
    HKEY        hKey;
    HRESULT hr = E_FAIL;

    if (lpszValueName == NULL || lpszBuffer == NULL)
    {
        return E_INVALIDARG;     
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(
                                    HKEY_LOCAL_MACHINE,
                                    lpszSubKeyName,
                                    0,
                                    KEY_READ,
                                    &hKey) )
    {
        hr = SafeRegQueryStringValueCch(
                                    hKey,
                                    lpszValueName,
                                    lpszBuffer,
                                    nCharCount,
                                    NULL,
                                    NULL);
        RegCloseKey(hKey);
    }
    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
// Public Function  SetRegStringValue()
//                  Set the registry value of timestamp as current system local time
// Input:   name of the value to set. pointer to the time structure to set time. if null,
//          we use current system time.
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue, LPCTSTR lpszSubKeyName)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;
    
    if (lpszValueName == NULL || lpszNewValue == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open the key 
    //
    if (RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,         // root key
                    lpszSubKeyName,     // subkey
                    0,                          // reserved
                    NULL,                       // class name
                    REG_OPTION_NON_VOLATILE,    // option
                    KEY_SET_VALUE,                  // security 
                    NULL,                       // security attribute
                    &hKey,
                    &dwResult) == ERROR_SUCCESS)
    {

        //
        // set the time to the lasttimestamp value
        //
        hRet = (RegSetValueEx(
                        hKey,
                        lpszValueName,
                        0,
                        REG_SZ,
                        (const unsigned char *)lpszNewValue,
                        (lstrlen(lpszNewValue) + 1) * sizeof(*lpszNewValue)
                        ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        RegCloseKey(hKey);
    }

    return hRet;
}



////////////////////////////////////////////////////////////////////////////
//
// Public Function  DeleteRegValue()
//                  Delete the registry value entry
// Input:   name of the value to entry,
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT DeleteRegValue(LPCTSTR lpszValueName)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    
    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open the key 
    //
    if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,         // root key
                    AUREGKEY_HKLM_ADMIN_POLICY,     // subkey
                    0,                          // reserved
                    KEY_WRITE,                  // security 
                    &hKey) == ERROR_SUCCESS)
    {

        //
        // set the time to the lasttimestamp value
        //
        hRet = (RegDeleteValue(
                        hKey,
                        lpszValueName
                        ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        RegCloseKey(hKey);
    }
    else
    {
    	DEBUGMSG("Fail to reg open key with error %d", GetLastError());
    }

    return hRet;

}

//=======================================================================
// GetRegDWordValue
//=======================================================================
HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue, LPCTSTR lpszSubKeyName)
{
    HKEY        hKey;
    int         iRet;
    DWORD       dwType = REG_DWORD, dwSize = sizeof(DWORD);

    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open critical fix key
    //
    if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    lpszSubKeyName,
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS)
    {

        //
        // query the last timestamp value
        //
        iRet = RegQueryValueEx(
                        hKey,
                        lpszValueName,
                        NULL,
                        &dwType,
                        (LPBYTE)pdwValue,
                        &dwSize);
        RegCloseKey(hKey);

        if (iRet == ERROR_SUCCESS && dwType == REG_DWORD && dwSize == sizeof(DWORD))
        {
            return S_OK;
        }
    }
    return E_FAIL;
}

////////////////////////////////////////////////////////////////////////////
//
// Public Function  SetRegDWordValue()
//                  Set the registry value as a DWORD
// Input:   name of the value to set. value to set
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue, DWORD options, LPCTSTR lpszSubKeyName)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;
    
    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }


    //
    // open the key 
    //
    if (RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,         // root key
                    lpszSubKeyName,     // subkey
                    0,                          // reserved
                    NULL,                       // class name
                    options,					// option
                    KEY_SET_VALUE,                  // security 
                    NULL,                       // security attribute
                    &hKey,
                    &dwResult) == ERROR_SUCCESS)
    {

        //
        // set the time to the lasttimestamp value
        //
        hRet = (RegSetValueEx(
                        hKey,
                        lpszValueName,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(DWORD)
                        ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        RegCloseKey(hKey);
    }
    return hRet;
}

BOOL fRegKeyCreate(LPCTSTR tszKey, DWORD dwOptions)
{
    HKEY        hKey;
    DWORD       dwResult;

    //
    // open the key 
    //
    if ( RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,         // root key
                    tszKey,     // subkey
                    0,                          // reserved
                    NULL,                       // class name
                    dwOptions,					// option
                    KEY_WRITE,                  // security 
                    NULL,                       // security attribute
                    &hKey,
                    &dwResult) == ERROR_SUCCESS )
    {
        RegCloseKey(hKey);
		return TRUE;
    }
    return FALSE;
}

BOOL fRegKeyExists(LPCTSTR tszSubKey, HKEY hRootKey)
{
	HKEY hKey;
	BOOL fRet = FALSE;

    if (RegOpenKeyEx(
//                    HKEY_LOCAL_MACHINE,
					hRootKey,
                    tszSubKey,
                    0,
                    KEY_READ,
                    &hKey) == ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
		fRet = TRUE;
    }

    return fRet;
}


DWORD getTimeOut()             
{
	DWORD dwValue = 0;
	GetRegDWordValue(_T("TimeOut"), &dwValue);
	return dwValue;
}

HRESULT setAddedTimeout(DWORD timeout, LPCTSTR strkey)
{
	HKEY hAUKey;
	SYSTEMTIME	tmCurr;
	SYSTEMTIME  tmTimeOut;
	TCHAR		szCurr[50];
	HRESULT		hr = E_FAIL;

	GetSystemTime(&tmCurr);

	if (FAILED(TimeAddSeconds(tmCurr, timeout, &tmTimeOut)))
	{
		return E_FAIL; 
	}

	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
						  AUTOUPDATEKEY,
						  0, TEXT(""),
						  REG_OPTION_NON_VOLATILE,
						  KEY_SET_VALUE,
						  NULL,
						  &hAUKey,
						  NULL) != ERROR_SUCCESS)
	{
		return E_FAIL;
	}

	if (SUCCEEDED(SystemTime2String(tmTimeOut, szCurr, ARRAYSIZE(szCurr))) &&
		RegSetValueEx(hAUKey,
					  strkey,
					  0, REG_SZ,
					  (BYTE *)szCurr,
					  sizeof(TCHAR)*(lstrlen(szCurr)+1)) == ERROR_SUCCESS)
	{
		hr = S_OK;
	}
	
	RegCloseKey(hAUKey);
	
	return hr;
}
HRESULT getAddedTimeout(DWORD *pdwTimeDiff, LPCTSTR strkey)
{
	HKEY hAUKey;
	LONG lRet;
	TCHAR		szTimeBuf[50];
	DWORD       dwType = REG_SZ, dwSize = sizeof(szTimeBuf);
	SYSTEMTIME	tmCurr, tmReminder;
	
	*pdwTimeDiff = 0;
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE ,
						  AUTOUPDATEKEY,
						  0, 
						  KEY_READ,
						  &hAUKey) != ERROR_SUCCESS)
	{
		return E_FAIL;
	}

	lRet = RegQueryValueEx(
                        hAUKey,
                        strkey,
                        NULL,
                        &dwType,
                        (LPBYTE)szTimeBuf,
                        &dwSize);

	RegCloseKey(hAUKey);

	if (lRet != ERROR_SUCCESS || dwType != REG_SZ ||
		FAILED(String2SystemTime(szTimeBuf, &tmReminder)))
	{
		return E_FAIL;
	}

	GetSystemTime(&tmCurr);
	
	*pdwTimeDiff = 	max (TimeDiff(tmCurr, tmReminder),0);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\helpers.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//	SYSTEM:		Windows Update AutoUpdate Client
//
//	CLASS:		N/A
//	MODULE:		
//	FILE:		helpers.CPP
//	DESC:	       This file contains utility functions
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#pragma hdrstop

const LPTSTR HIDDEN_ITEMS_FILE = _T("hidden.xml");

const LPCTSTR AU_ENV_VARS::s_AUENVVARNAMES[] = {_T("AUCLTEXITEVT"),_T("EnableNo"), _T("EnableYes"), _T("RebootWarningMode")};

BOOL AU_ENV_VARS::ReadIn(void)
{
	BOOL fRet = TRUE;
	
	if (!GetBOOLEnvironmentVar(s_AUENVVARNAMES[3], &m_fRebootWarningMode))
	{ // if not set, implies regular mode
		m_fRebootWarningMode = FALSE;
	}
	if (m_fRebootWarningMode)
	{
		if (!GetBOOLEnvironmentVar(s_AUENVVARNAMES[1], &m_fEnableNo)
			||!GetBOOLEnvironmentVar(s_AUENVVARNAMES[2], &m_fEnableYes)
			||!GetStringEnvironmentVar(s_AUENVVARNAMES[0], m_szClientExitEvtName, ARRAYSIZE(m_szClientExitEvtName)))
		{
			return FALSE;
		}
	}
	return TRUE;
}

BOOL AU_ENV_VARS::WriteOut(LPTSTR szEnvBuf,
		size_t IN cchEnvBuf,
		BOOL IN fRebootWarningMode,
		BOOL IN fEnableYes,
		BOOL IN fEnableNo,
		LPCTSTR IN szClientExitEvtName)
{
	TCHAR buf2[s_AUENVVARBUFSIZE];
	m_fEnableNo = fEnableNo;
	m_fEnableYes = fEnableYes;
	m_fRebootWarningMode = fRebootWarningMode;
	if (FAILED(StringCchCopyEx(
					m_szClientExitEvtName,
					ARRAYSIZE(m_szClientExitEvtName),
					szClientExitEvtName,
					NULL,
					NULL,
					MISTSAFE_STRING_FLAGS)))
	{
		return FALSE;
	}
	*szEnvBuf = _T('\0');
	for (int i = 0 ; i < ARRAYSIZE(s_AUENVVARNAMES); i++)
	{
        if (FAILED(GetStringValue(i, buf2, ARRAYSIZE(buf2))) || 
            FAILED(StringCchCatEx(szEnvBuf, cchEnvBuf, s_AUENVVARNAMES[i], NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			FAILED(StringCchCatEx(szEnvBuf, cchEnvBuf, _T("="), NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			FAILED(StringCchCatEx(szEnvBuf, cchEnvBuf, buf2, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
			FAILED(StringCchCatEx(szEnvBuf, cchEnvBuf, _T("&"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
		{
			return FALSE;
		}
	}
 	return TRUE;
}
	
HRESULT AU_ENV_VARS::GetStringValue(int index, LPTSTR buf, DWORD dwCchSize)
{
    HRESULT hr = E_INVALIDARG;
	switch (index)
	{
		case 0: hr = StringCchCopyEx(buf, dwCchSize, m_szClientExitEvtName, NULL, NULL, MISTSAFE_STRING_FLAGS);
				break;
		case 1: hr = StringCchCopyEx(buf, dwCchSize, m_fEnableNo? _T("true") : _T("false"), NULL, NULL, MISTSAFE_STRING_FLAGS);
				break;
		case 2: hr = StringCchCopyEx(buf, dwCchSize, m_fEnableYes? _T("true") : _T("false"), NULL, NULL, MISTSAFE_STRING_FLAGS);
				break;
		case 3: hr = StringCchCopyEx(buf, dwCchSize, m_fRebootWarningMode ? _T("true") : _T("false"), NULL, NULL, MISTSAFE_STRING_FLAGS);
				break;
	}
	return hr;
}
		
	
BOOL AU_ENV_VARS::GetBOOLEnvironmentVar(LPCTSTR szEnvVar, BOOL *pfVal)
{	
	TCHAR szBuf[20];
	if (GetStringEnvironmentVar(szEnvVar, szBuf, ARRAYSIZE(szBuf)))
	{
//     	DEBUGMSG("WUAUCLT   got environment variable %S = %S ", szEnvVar, szBuf);    
		*pfVal =(0 == lstrcmpi(szBuf, _T("true")));
		return TRUE;
	}
	return FALSE;
}	

/////////////////////////////////////////////////////////////////////////////////////////////
// dwSize: size of szBuf in number of characters
////////////////////////////////////////////////////////////////////////////////////////////
BOOL AU_ENV_VARS::GetStringEnvironmentVar(LPCTSTR szEnvVar, LPTSTR szBuf, DWORD dwSize)
{
	// Assume szEnvVar is not a proper substring in for any parameters in szCmdLine.
	LPTSTR szCmdLine = GetCommandLine();
	LPTSTR pTmp;
 	DWORD  index = 0;
//	DEBUGMSG("WUAUCLT read in command line %S", szCmdLine);
	if (NULL == szCmdLine || 0 == dwSize ||  (NULL == (pTmp = StrStr(szCmdLine, szEnvVar))))
	{
		return FALSE;
	}
 	
 	pTmp += lstrlen(szEnvVar) + 1; //skip '='
 	while (_T('\0') != *pTmp && _T('&') != *pTmp)
 	{
		if (index + 1 >= dwSize)
		{
			// insufficent buffer
			return FALSE;
		}
 		szBuf[index++] = *pTmp++;
 	}
 	szBuf[index] = _T('\0');
// 	DEBUGMSG(" read in %S = %S", szEnvVar, szBuf);
 	return TRUE;
}


#if 0
#ifdef DBG
void DBGCheckEventState(LPSTR szName, HANDLE hEvt)
{
	DWORD dwRet  = WaitForSingleObject(hEvt, 0);
	DEBUGMSG("WUAU   Event %s is %s signalled", szName,( WAIT_OBJECT_0 == dwRet) ? "" : "NOT");
	return;
}		
#endif
#endif




////////////////////////////////////////////////////////////////////////////////////////
// check whether it is win2k for the current system
////////////////////////////////////////////////////////////////////////////////////////
BOOL IsWin2K(void)
{
   static int iIsWin2K        = -1;     // force first time path

   if (iIsWin2K == -1)
   {
       OSVERSIONINFOEX osvi;
       DWORDLONG dwlConditionMask = 0;
       ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

       // This is information that identifies win2K
       osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
       osvi.dwMajorVersion      = 5;
       osvi.dwMinorVersion      = 0;

       // Initialize the condition mask.
       VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_EQUAL );
       VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_EQUAL );

       // Perform the test.
       iIsWin2K = (VerifyVersionInfo(&osvi, VER_MAJORVERSION | VER_MINORVERSION, dwlConditionMask)? 1 : 0);
   }

   return iIsWin2K;
}



/////////////////////////////////////////////////////////////////////////////////////
// check whether a policy is set to deny current user access to AU
/////////////////////////////////////////////////////////////////////////////////////
BOOL fAccessibleToAU(void)
{
    BOOL fAccessible = TRUE;
    DWORD dwType;
    DWORD dwValue;
    DWORD dwSize = sizeof(dwValue);
    DWORD dwResult = SHGetValue(HKEY_CURRENT_USER,
                                AUREGKEY_HKCU_USER_POLICY,
                                AUREGVALUE_DISABLE_WINDOWS_UPDATE_ACCESS,
                                &dwType,
                                &dwValue,
                                &dwSize);

    if (ERROR_SUCCESS == dwResult && REG_DWORD == dwType && 1 == dwValue)
    {
        fAccessible = FALSE;
    }
    return fAccessible;
}
 
/*
BOOL IsAdministrator()
{
	SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
	PSID pSID = NULL;
	BOOL bResult = FALSE;

	if (!AllocateAndInitializeSid(&SIDAuth, 2,
								 SECURITY_BUILTIN_DOMAIN_RID,
								 DOMAIN_ALIAS_RID_ADMINS,
								 0, 0, 0, 0, 0, 0,
								 &pSID) ||
		!CheckTokenMembership(NULL, pSID, &bResult))
	{
		bResult = FALSE;
	}
	if(pSID)
	{
		FreeSid(pSID);
	}
	return bResult;
}
*/


// following are hidden item related functions
BOOL FHiddenItemsExist(void)
{
    //USES_CONVERSION;
    DEBUGMSG("FHiddenItemsExist()");
    TCHAR szFile[MAX_PATH];
   
    //Initialize the global path to WU Dir
    if(!CreateWUDirectory(TRUE))
    {
        return FALSE;
    }
	return
		SUCCEEDED(StringCchCopyEx(szFile, ARRAYSIZE(szFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		SUCCEEDED(StringCchCatEx(szFile, ARRAYSIZE(szFile), HIDDEN_ITEMS_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		fFileExists(szFile);
}

BOOL RemoveHiddenItems(void)
{
    //USES_CONVERSION
   DEBUGMSG("RemoveHiddenItems()");
   TCHAR szFile[MAX_PATH];

   AUASSERT(_T('\0') != g_szWUDir[0]);
   return
		SUCCEEDED(StringCchCopyEx(szFile, ARRAYSIZE(szFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		SUCCEEDED(StringCchCatEx(szFile, ARRAYSIZE(szFile), HIDDEN_ITEMS_FILE, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
		AUDelFileOrDir(szFile);
}

/////////////////////////////////////////////////////////////////////////////////
// bstrRTFPath is URL for the RTF file on internet
// langid is the language id for the process who download this RTF
////////////////////////////////////////////////////////////////////////////////
BOOL IsRTFDownloaded(BSTR bstrRTFPath, LANGID langid)
{
    TCHAR tszLocalFullFileName[MAX_PATH];
    if (NULL == bstrRTFPath)
        {
            return FALSE;
        }
    if (FAILED(GetRTFDownloadPath(tszLocalFullFileName, ARRAYSIZE(tszLocalFullFileName), langid)) ||
        FAILED(PathCchAppend(tszLocalFullFileName, ARRAYSIZE(tszLocalFullFileName), W2T(PathFindFileNameW(bstrRTFPath)))))
    {
    	return FALSE;
    }    
//    DEBUGMSG("Checking existence of local RTF file %S", T2W(tszLocalFullFileName));
	BOOL fIsDir = TRUE;
    BOOL fExists = fFileExists(tszLocalFullFileName, &fIsDir);
	return fExists && !fIsDir;
}


void DisableUserInput(HWND hwnd)
{
    int ControlIDs[] = { IDC_CHK_KEEPUPTODATE, IDC_OPTION1, IDC_OPTION2,
                                    IDC_OPTION3, IDC_CMB_DAYS, IDC_CMB_HOURS,IDC_RESTOREHIDDEN };

    for (int i = 0; i < ARRAYSIZE(ControlIDs); i++)
        {
            EnableWindow(GetDlgItem(hwnd, ControlIDs[i]), FALSE);
        }
}


////////////////////////////////////////////////////////////////////////////
//
// Helper Function  Hours2LocalizedString()
//          helper function to standardized the way AU formats time string
//			for a given time. For example "3:00 AM"
//
// Parameters:
//		pst - ptr to SYSTEMTIME for localizing the time component
//		ptszBuffer - buffer to hold the resulting localized string
//		cbSize - size of buffer in TCHARs
// Return:  TRUE if successful; FALSE otherwise
//
////////////////////////////////////////////////////////////////////////////
BOOL Hours2LocalizedString(SYSTEMTIME *pst, LPTSTR ptszBuffer, DWORD cbSize)
{
	return (0 != GetTimeFormat(
					LOCALE_SYSTEM_DEFAULT,
					LOCALE_NOUSEROVERRIDE | TIME_NOSECONDS,
					pst,
					NULL,
					ptszBuffer,
					cbSize));
}


////////////////////////////////////////////////////////////////////////////
//
// Helper Function  FillHrsCombo()
//          helper function to standardized the way AU sets up the list
//			of hour values in a combo box.
//
// Parameters:
//		hwnd - handle to obtain the handle to the combobox
//		dwSchedInstallTime - hour value to default the combobox selection to
//							 3:00 AM will be used if this value is not valid.
// Return:  TRUE if successful; FALSE otherwise
//
////////////////////////////////////////////////////////////////////////////
BOOL FillHrsCombo(HWND hwnd, DWORD dwSchedInstallTime)
{
	HWND hComboHrs = GetDlgItem(hwnd,IDC_CMB_HOURS);
    DWORD dwCurrentIndex = 3;
	SYSTEMTIME st = {2000, 1, 5, 1, 0, 0, 0, 0};	// 01/01/2000 00:00:00 can be any valid date/time

	for (WORD i = 0; i < 24; i++)
	{
		TCHAR tszHrs[30];

		st.wHour = i;
		if (!Hours2LocalizedString(&st, tszHrs, ARRAYSIZE(tszHrs)))
		{
			return FALSE;
		}
		LRESULT nIndex = SendMessage(hComboHrs,CB_ADDSTRING,0,(LPARAM)tszHrs);
		SendMessage(hComboHrs,CB_SETITEMDATA,nIndex,i);
		if( dwSchedInstallTime == i )
		{
			dwCurrentIndex = (DWORD)nIndex;
		}
	}
	SendMessage(hComboHrs,CB_SETCURSEL,dwCurrentIndex,(LPARAM)0);
	return TRUE;
}


BOOL FillDaysCombo(HINSTANCE hInstance, HWND hwnd, DWORD dwSchedInstallDay, UINT uMinResId, UINT uMaxResId)
{
	HWND hComboDays = GetDlgItem(hwnd,IDC_CMB_DAYS);
	DWORD dwCurrentIndex = 0;
	for (UINT i = uMinResId, j = 0; i <= uMaxResId; i ++, j++)
	{
		WCHAR szDay[40];
		LoadStringW(hInstance,i,szDay,ARRAYSIZE(szDay));
		LRESULT nIndex = SendMessage(hComboDays,CB_ADDSTRING,0,(LPARAM)szDay);
		SendMessage(hComboDays,CB_SETITEMDATA,nIndex,j);
		if( dwSchedInstallDay == j )
		{
			dwCurrentIndex = (DWORD) nIndex;
		}
	}
	SendMessage(hComboDays,CB_SETCURSEL,dwCurrentIndex,(LPARAM)0);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\criticalfixreg.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    criticalfixreg.h
//
//  Creator: PeterWi
//
//  Purpose: AU registry related functions.
//
//=======================================================================

#pragma once
extern const TCHAR AUREGKEY_HKLM_DOMAIN_POLICY[]; // =        _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU");
extern const TCHAR	AUREGKEY_HKLM_WINDOWSUPDATE_POLICY[]; // = _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate");
extern const TCHAR	AUREGKEY_HKLM_IUCONTROL_POLICY[]; // =     _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
extern const TCHAR	AUREGKEY_HKLM_SYSTEM_WAS_RESTORED[]; // =  _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\SystemWasRestored");
extern const TCHAR	AUREGKEY_HKLM_ADMIN_POLICY[] ; // =         _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update");
extern const TCHAR AUREGKEY_HKCU_USER_POLICY[]; // = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate");
extern const TCHAR AUREGVALUE_DISABLE_WINDOWS_UPDATE_ACCESS[]; // = _T("DisableWindowsUpdateAccess"); 

////////////////////////////////////////////////////////////////////////////
//
// Public Function	GetRegStringValue()
//					Read the registry value of timestamp for last detection 
// Input:	Name of value, value, and size of value
// Output:	SYSTEMTIME structure contains the time
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int nCharCount, LPCTSTR lpszSubKeyName = AUREGKEY_HKLM_ADMIN_POLICY);


////////////////////////////////////////////////////////////////////////////
//
// Public Function	SetRegStringValue()
//					Set the registry value of timestamp as current system local time
// Input:	name of the value to set. and value,
//			
// Output:	None
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue, LPCTSTR lpszSubKeyName = AUREGKEY_HKLM_ADMIN_POLICY);


////////////////////////////////////////////////////////////////////////////
//
// Public Function	DeleteRegValue()
//					Delete the registry value entry
// Input:	name of the value to entry,
// Output:	None
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT DeleteRegValue(LPCTSTR lpszValueName);


////////////////////////////////////////////////////////////////////////////
//
// Public Function	GetRegDWordValue()
//					Get a DWORD from specified regustry value name
// Input:	name of the value to retrieve value
// Output:	pointer to the retrieved value
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue, LPCTSTR lpszSubKeyName = AUREGKEY_HKLM_ADMIN_POLICY);


////////////////////////////////////////////////////////////////////////////
//
// Public Function	SetRegDWordValue()
//					Set the registry value as a DWORD
// Input:	name of the value to set. value to set
// Output:	None
// Return:	HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue, DWORD options = REG_OPTION_NON_VOLATILE, LPCTSTR lpszSubKeyName = AUREGKEY_HKLM_ADMIN_POLICY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\pch.h ===
//#pragma warning( push, 3 )
#include <stdio.h>
#include <tchar.h>
#include <limits.h>
#include <windows.h>
#include <malloc.h>
#include <shlwapi.h>
#include "memutil.h"
#include "criticalfixreg.h"
#include "wuauengi.h"
#include <stdarg.h>
#include <shlobj.h>
#include "WUTestKeys.h"
#include "auwait.h"
#include "auregkeys.h"
#include "wuaulib.h"
#include "aucatitem.h"
#include "schemamisc.h"
#include "audirectory.h"
#include "schemakeys.h"
#include "aubasecatalog.h"
#include "aucomres.h"
#include "aucompat.h"
#include "fileutil.h"
#include "wusafefn.h"
#include "MISTSafe.h"
//#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\platform.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    platform.cpp
//
//  Creator: PeterWi
//
//  Purpose: platform functions.
//
//=======================================================================
#include "pch.h"
#pragma hdrstop



//=======================================================================
//
//  fIsPersonalOrProfessional
//
//  Determine if machine is personal or professional.
//
//  Note: personal is a type of suite of professional.
//  
//=======================================================================
BOOL fIsPersonalOrProfessional(void)
{
	OSVERSIONINFOEX osver;

	ZeroMemory(&osver, sizeof(osver));
	osver.dwOSVersionInfoSize = sizeof(osver);
	
	if ( GetVersionEx((OSVERSIONINFO *)&osver) )
	{
		return (VER_NT_WORKSTATION == osver.wProductType);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////
// GetFileVersionStr(...) get version of a file
//	and store it in parameter tszbuf in the format 
//  of "MajorVersion.MinorVersion.BuildNumber.XXX"
//	e.g. "5.4.2448.1" 
//  tszFile		: IN stores full path of the file name
//  tszbuf		: IN stores OS version string
//  ubufsize	: IN stores size of tszbuf in charaters. 
//				:	 must be at least 20 charaters long
// return : S_OK			if OS version string got
//		  : E_INVALIDARG	if argument not valid
//		  : STRSAFE_E_INSUFFICIENT_BUFFER	if insufficient buffer
//		  : E_FAIL			if any other error
HRESULT GetFileVersionStr(LPCTSTR tszFile, LPTSTR tszbuf, UINT uSize)
{
	DWORD	dwVerNumberMS = 0;
	DWORD   dwVerNumberLS = 0;
	HRESULT		hr = S_OK; 
	USES_IU_CONVERSION;

	if (uSize < 20 || NULL == tszbuf) 
	{
		hr = E_INVALIDARG;
		goto done;
	}
	LPSTR szTmp = T2A(tszFile);
	if (NULL == szTmp)
	{
	    hr = E_OUTOFMEMORY;
	    goto done;
	}
    	hr = GetVersionFromFileEx(
    		szTmp,
    		&dwVerNumberMS, 
    		&dwVerNumberLS,
    		TRUE);
    	if (SUCCEEDED(hr) &&
			SUCCEEDED(hr = StringCchPrintfEx(
						tszbuf, uSize, NULL, NULL, MISTSAFE_STRING_FLAGS, _T("%d.%d.%d.%d"), 
    					HIWORD(dwVerNumberMS),
    					LOWORD(dwVerNumberMS),
    					HIWORD(dwVerNumberLS),
    					LOWORD(dwVerNumberLS))))
		{
    		DEBUGMSG("file version for %S is %S", tszFile, tszbuf);
    	}
	
done:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\wuaulib.h ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    wuaulib.h
//
//  Creator: PeterWi
//
//  Purpose: library function declarations.
//
//=======================================================================

#pragma once

#include <tchar.h>
#include <wchar.h>
#include <timeutil.h>
#include "WUTestKeys.h"

#define	ARRAYSIZE(x)			(sizeof(x)/sizeof(x[0]))

// Defs for boolean AU options
#define AUOPTION_UNSPECIFIED 				0
#define AUOPTION_AUTOUPDATE_DISABLE             1
#define AUOPTION_PREDOWNLOAD_NOTIFY             2
#define AUOPTION_INSTALLONLY_NOTIFY             3
#define AUOPTION_SCHEDULED                      4
#define AUOPTION_ADMIN_MIN						AUOPTION_AUTOUPDATE_DISABLE
#define AUOPTION_DOMAIN_MIN						AUOPTION_PREDOWNLOAD_NOTIFY
#define AUOPTION_MAX							AUOPTION_SCHEDULED

// download status 
#define DWNLDSTATUS_NOT_DOWNLOADING	0
#define DWNLDSTATUS_DOWNLOADING		1
#define DWNLDSTATUS_PAUSED			2
#define DWNLDSTATUS_CHECKING_CONNECTION	3

//////////////////////Client (WUAUCLT) exit codes //////////////////////////
#define CDWWUAUCLT_UNSPECIFY	-1
#define CDWWUAUCLT_OK			1000
#define CDWWUAUCLT_RELAUNCHNOW		1001
#define CDWWUAUCLT_RELAUNCHLATER		1002	//ask service to launch client 
#define CDWWUAUCLT_ENDSESSION	1003	// user logs off or system shuts down
#define CDWWUAUCLT_FATAL_ERROR	1004
#define CDWWUAUCLT_INSTALLNOW 	1005
#define CDWWUAUCLT_REBOOTNOW 	1007
#define CDWWUAUCLT_REBOOTLATER 	1008
#define CDWWUAUCLT_REBOOTNEEDED	1009 	//user hasn't made decision as weather to reboot or not
#define CDWWUAUCLT_REBOOTTIMEOUT 1010 //reboot warning dialog times out

//////////////////////No Active Admin Session found//////////////////////////
#define DWNO_ACTIVE_ADMIN_SESSION_FOUND				-1		// No Active Admin Session Found
#define DWNO_ACTIVE_ADMIN_SESSION_SERVICE_FINISHED  -2		// No Active Admin Sesion found due to Service Finishing or because caller routine needs to finish service
#define DWSYSTEM_ACCOUNT	-3



class AU_ENV_VARS {
public:
	static const int s_AUENVVARCOUNT = 4;
	static const int s_AUENVVARBUFSIZE = 100;
	BOOL m_fRebootWarningMode ; //regular mode otherwise
	BOOL m_fEnableYes; //for reboot warning dialog
	BOOL m_fEnableNo; //for reboot warning dialog
	TCHAR m_szClientExitEvtName[s_AUENVVARBUFSIZE]; 
public:
	BOOL ReadIn(void);
	BOOL WriteOut(LPTSTR szEnvBuf, //at least size of 4*AUEVVARBUFSIZE
			size_t IN cchEnvBuf,
			BOOL IN fRebootWarningMode,
			BOOL IN fEnableYes = TRUE,
			BOOL IN fEnableNo = TRUE,
			LPCTSTR IN szClientExitEvtName = NULL);		
private:
	static const LPCTSTR s_AUENVVARNAMES[s_AUENVVARCOUNT];
	HRESULT GetStringValue(int index, LPTSTR buf, DWORD dwCchSize);			
	BOOL GetBOOLEnvironmentVar(LPCTSTR szEnvVar, BOOL *pfVal);
	BOOL GetStringEnvironmentVar(LPCTSTR szzEnvVar, LPTSTR szBuf, DWORD dwSize);
};

//////////////// The following functions are all called from the outside! ///////////////////////

/////////////////////////////////////////////////////////////////////
// cfreg.cpp - Functions to handle registry keys
/////////////////////////////////////////////////////////////////////
BOOL    fRegKeyCreate(LPCTSTR tszKey, DWORD dwOptions);
BOOL fRegKeyExists(LPCTSTR tszSubKey, HKEY hRootKey = HKEY_LOCAL_MACHINE);

inline HRESULT String2FileTime(LPCTSTR pszDateTime, FILETIME *pft)
{
    SYSTEMTIME st;
    HRESULT hr = String2SystemTime(pszDateTime, &st);
    if ( SUCCEEDED(hr) )
    {
        if ( !SystemTimeToFileTime(&st, pft) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

inline HRESULT FileTime2String(FILETIME & ft, LPTSTR pszDateTime, size_t cchSize)
{
    SYSTEMTIME st;
    HRESULT hr;

    if ( !FileTimeToSystemTime(&ft, &st) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = SystemTime2String(st, pszDateTime, cchSize);
    }

    return hr;
}

BOOL FHiddenItemsExist();
HRESULT setAddedTimeout(DWORD timeout, LPCTSTR strkey);
HRESULT getAddedTimeout(DWORD *pdwTimeDiff, LPCTSTR strkey);

extern const TCHAR	AUREGKEY_REBOOT_REQUIRED[]; // = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired");

inline BOOL fSetRebootFlag(void)
{
	return fRegKeyCreate(AUREGKEY_REBOOT_REQUIRED, REG_OPTION_VOLATILE);
}
inline BOOL    fRegKeyDelete(LPCTSTR tszKey)
{
	return (ERROR_SUCCESS == RegDeleteKey(HKEY_LOCAL_MACHINE, tszKey));
}
inline BOOL fCheckRebootFlag(void)
{
	return fRegKeyExists(AUREGKEY_REBOOT_REQUIRED);
}

/////////////////////////////////////////////////////////////////////
// helpers.cpp
/////////////////////////////////////////////////////////////////////
DWORD getTimeOut();
int TimeDiff(SYSTEMTIME tm1, SYSTEMTIME tm2);
HRESULT TimeAddSeconds(SYSTEMTIME tmBase, int iSeconds, SYSTEMTIME* pTimeNew);
inline void setTimeOut(DWORD dwTimeOut)            
{
	SetRegDWordValue(_T("TimeOut"), dwTimeOut);
}
BOOL IsRTFDownloaded(BSTR bstrRTFPath, LANGID langid);
BOOL FHiddenItemsExist(void);
BOOL RemoveHiddenItems(void);
void DisableUserInput(HWND hwnd);
BOOL Hours2LocalizedString(SYSTEMTIME *pst, LPTSTR ptszBuffer, DWORD cbSize);
BOOL FillHrsCombo(HWND hwnd, DWORD dwSchedInstallTime);
BOOL FillDaysCombo(HINSTANCE hInstance, HWND hwnd, DWORD dwSchedInstallDay, UINT uMinResId, UINT uMaxResId);
BOOL fAccessibleToAU(void);
BOOL IsWin2K(void);

extern const LPTSTR HIDDEN_ITEMS_FILE;

//////////////////////////////////////////////////////////////////////////////////////
// platform.cpp
//////////////////////////////////////////////////////////////////////////////////////
void GetOSName(LPTSTR _szOSName);
UINT  DetectPlatformID(void);
HRESULT GetOSVersionStr(LPTSTR tszbuf, UINT uSize);
BOOL fIsPersonalOrProfessional(void);
HRESULT GetFileVersionStr(LPCTSTR tszFile, LPTSTR tszbuf, UINT uSize);


const TCHAR g_szPropDialogPtr[]       = TEXT("AutoUpdateProp_DialogPtr");
const TCHAR g_szHelpFile[]            = _T("wuauhelp.chm::/auw2ktt.txt"); //TEXT("sysdm.hlp"); //used on both w2k and xp.
const TCHAR gtszAUOverviewUrl[] = _T("wuauhelp.chm"); //default
const TCHAR gtszAUW2kSchedInstallUrl[] = _T("wuauhelp.chm::/w2k_autoupdate_sched.htm");
const TCHAR gtszAUXPSchedInstallUrl[] = _T("wuauhelp.chm::/autoupdate_sched.htm");


//////////////////////////////////////////////////////////////////////////////////////
//                                      DEBUG STUFF                                 //
//////////////////////////////////////////////////////////////////////////////////////
#ifdef DBG

//===== DBG ==========================================================================

void _cdecl WUAUTrace(char* pszFormat, ...);

#define DEBUGMSG           WUAUTrace

inline BOOL fAUAssertBreak(void)
{
	static DWORD dwVal = -1;
	if (-1 != dwVal)
	{
		return 1 == dwVal;
	}
	if (FAILED(GetRegDWordValue(_T("AssertBreak"), &dwVal)))
	{ //if key is not there, don't read again and again
		dwVal = 0;
	}
	return 1 == dwVal;
}

#define AUASSERT(x)			{ if (!(x) && fAUAssertBreak()) DebugBreak();}

#else  // !DBG
//===== !DBG ==========================================================================

inline void _cdecl WUAUTrace(char* , ...) {}

#define DEBUGMSG          WUAUTrace
#define AUASSERT(x)			

#endif // DBG
//=====================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuppt.inc ===
#CODE=$(PROJECT_ROOT)\Windows.com
#WUPPT = $(CODE)\wuv3

INCLUDES = $(INCLUDES);$(WUV3)\cdminc;$(WUV3)\inc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuauserv\wuauserv.cpp ===
// wuauserv.cpp
#include <windows.h>
#include <ausvc.h>
#include <wusafefn.h>


typedef HRESULT (WINAPI *AUSERVICEMAIN)(DWORD dwNumServicesArg,
											   LPWSTR *lpServiceArgVectors,
											   AUSERVICEHANDLER pfnServiceHandler,
											   BOOL fJustSelfUpdated);

AUSERVICEMAIN		g_pfnServiceMain = NULL;
AUSERVICEHANDLER	g_pfnServiceHandler = NULL;
AUGETENGSTATUS      g_pfnGetEngineStatusInfo = NULL;
AUREGSERVICEVER     g_pfnRegisterServiceVersion = NULL;
CRITICAL_SECTION    csWuaueng; 

DWORD WINAPI ServiceHandler(DWORD fdwControl, DWORD dwEventType, LPVOID pEventData, LPVOID lpContext)
{
	DWORD dwRet = NOERROR;

	EnterCriticalSection(&csWuaueng);

	if ( NULL != g_pfnServiceHandler )
	{
		dwRet = g_pfnServiceHandler(fdwControl, dwEventType, pEventData, lpContext);
	}
	else
	{
		dwRet = ERROR_CALL_NOT_IMPLEMENTED;
	}

	LeaveCriticalSection(&csWuaueng);

	return dwRet;
}


void WINAPI ServiceMain(DWORD dwNumServicesArg, LPWSTR *lpServiceArgVectors)
{
	HRESULT hr = S_OK;
	HMODULE hModule = NULL;
    AUENGINEINFO_VER_1 engineInfo;
    DWORD dwEngineVersion = 0;
    BOOL fCompatibleEngineVersion = FALSE;
	
    if ( !SafeInitializeCriticalSection(&csWuaueng) )
	{
		return;
	}

	do
	{
	    EnterCriticalSection(&csWuaueng); 

        fCompatibleEngineVersion = FALSE;
        g_pfnServiceHandler = NULL;
	    g_pfnGetEngineStatusInfo = NULL;
    	g_pfnRegisterServiceVersion = NULL;

		// check if we need to release wuaueng.dll
		if ( (S_FALSE == hr) && !FreeLibrary(hModule) )
		{
			hr = E_FAIL;
			hModule = NULL;
			g_pfnServiceMain = NULL;
			g_pfnServiceHandler = NULL;
		}
		else
		{
			// if we can't load wuaueng.dll, we fail to start
			if ( (NULL == (hModule = LoadLibraryFromSystemDir(TEXT("wuaueng.dll")))) ||
				 (NULL == (g_pfnServiceMain = (AUSERVICEMAIN)::GetProcAddress(hModule, "ServiceMain"))) ||
				 (NULL == (g_pfnServiceHandler = (AUSERVICEHANDLER)::GetProcAddress(hModule, "ServiceHandler"))) )
			{
				 hr = E_FAIL;
				 g_pfnServiceMain = NULL;
				 g_pfnServiceHandler = NULL;
			}
            else    //wuaueng.dll successfully loaded, check to see if the engine supports following entry points
            {
                if ( (NULL != (g_pfnRegisterServiceVersion = (AUREGSERVICEVER)::GetProcAddress(hModule, "RegisterServiceVersion"))) &&
                     (NULL != (g_pfnGetEngineStatusInfo = (AUGETENGSTATUS)::GetProcAddress(hModule, "GetEngineStatusInfo"))) )
                {
                    fCompatibleEngineVersion = TRUE;
                }
                      
            }
		}

		LeaveCriticalSection(&csWuaueng);

		if ( SUCCEEDED(hr) )
		{
            if (fCompatibleEngineVersion)
            {
                // Register service version with engine and check if engine supports the service version
                fCompatibleEngineVersion = g_pfnRegisterServiceVersion(AUSRV_VERSION, &dwEngineVersion);
            }            

			hr = g_pfnServiceMain(dwNumServicesArg, lpServiceArgVectors, ServiceHandler, 
									  (S_FALSE == hr) ? TRUE: FALSE /* we just reloaded wuaueng.dll */);
            
            if(fCompatibleEngineVersion)
            {
                //The engine service main has exited, set the service status to SERVICE_STOP_PENDING
                fCompatibleEngineVersion = g_pfnGetEngineStatusInfo((void*)&engineInfo);
            }
        }
	} while ( S_FALSE == hr );

    EnterCriticalSection(&csWuaueng); 

	if ( NULL != hModule )
	{
		FreeLibrary(hModule);
	}
    g_pfnServiceHandler = NULL;
    g_pfnGetEngineStatusInfo = NULL;
    g_pfnRegisterServiceVersion = NULL;
    

	LeaveCriticalSection(&csWuaueng);

	DeleteCriticalSection(&csWuaueng);

    if(fCompatibleEngineVersion)
    {
        //stop the service
        engineInfo.serviceStatus.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(engineInfo.hServiceStatus, &engineInfo.serviceStatus);
    }

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdm\sources.inc ===
!IF 0

  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.

  File:   source.inc

  Owner:  YanL

  Description:

      CDM.DLL sources

!ENDIF

#!include ..\..\..\wu.inc

TARGETNAME=CDM
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK
DLLDEF=..\CDM.DEF
C_DEFINES = $(C_DEFINES) /D_CDM_ /D_UNICODE /DUNICODE
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
USE_STL=1
USE_STATIC_ATL=1
USE_MSVCRT=1

TARGETLIBS=     \
    $(SDK_LIB_PATH)\kernel32.lib        \
    $(SDK_LIB_PATH)\user32.lib          \
    $(SDK_LIB_PATH)\advapi32.lib        \
    $(SDK_LIB_PATH)\wininet.lib         \
    $(SDK_LIB_PATH)\cabinet.lib         \
    $(SDK_LIB_PATH)\shlwapi.lib         \
    $(SDK_LIB_PATH)\uuid.lib			\
    $(SDK_LIB_PATH)\ole32.lib			\
    $(SDK_LIB_PATH)\oleaut32.lib        \
    $(SDK_LIB_PATH)\wintrust.lib        \
    $(SDK_LIB_PATH)\rasapi32.lib	    \
    $(SDK_LIB_PATH)\crypt32.lib			\
    $(SDK_LIB_PATH)\cfgmgr32.lib		\
    $(SDK_LIB_PATH)\setupapi.lib		\
	$(SDK_LIB_PATH)\version.lib			\
	$(SDK_LIB_PATH)\shell32.lib

INCLUDES=..\..\cdminc

SOURCES= \
	..\cdm.cpp			\
	..\cdmp.cpp			\
	..\cdm.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdm\cdm.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdm.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      Functions exported by CDM
//
//			DownloadIsInternetAvailable	
//			OpenCDMContext
//			OpenCDMContextEx
//			QueryDetectionFiles
//			FindMatchingDriver
//			DownloadUpdatedFiles
//          DetFilesDownloaded
//			LogDriverNotFound
//			CloseCDMContext
//			GetPackage
//			InternalQueryDetectionFiles
//			InternalFindMatchingDriver
//          InternalDetFilesDownloaded
//			InternalLogDriverNotFound
//
//=======================================================================
#include <windows.h>
#include <osdet.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <tchar.h>

#include <wustl.h>
#include <log.h>
#include <wuv3cdm.h>
#include <bucket.h>
#include <newtrust.h>
#include <download.h>
#include <diamond.h>

#include <atlconv.h>
#define _ASSERTE(expr) ((void)0)
#include <atlconv.cpp>

#include "cdm.h"
#include "cdmp.h"
#include <drvinfo.h>
#include <cfgmgr32.h>
#include <shellapi.h>

typedef struct _CONTEXTHANDLE
{
	bool	fCloseConnection;				//Tracks if the connection to the internet was opened by CDM.DLL
	bool	fNeedUpdate;					//TRUE if we need to update CDM.DLL when its connection is closed.
	TCHAR	szSiteServer[MAX_PATH];			//Description server name.
	TCHAR	szDownloadServer[MAX_PATH];		//Download server name.
} CONTEXTHANDLE, *PCONTEXTHANDLE;

static frozen_array<CONTEXTHANDLE> g_handleArray;
static HMODULE g_hModule;
static bool g_fNeedUpdate;				//Flag that indicates that cdm.dll needs updating.

static int GetHandleIndex(IN HANDLE hConnection);


BOOL APIENTRY DllMain(
	HANDLE hModule, 
    DWORD  ul_reason_for_call, 
    LPVOID /*lpReserved*/
) {
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			g_fNeedUpdate = FALSE;
			g_hModule = (HMODULE)hModule; // to return to findoem;
			break;
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			//If we have downloaded a new dll then we need to update it.
			//Note: passing a global to a function is bad form as it can
			//cause problems. The only reason that I'm doing this is so
			//that the UpdateCDMDll API can be moved to other programs
			//since this ability to make a dll or exe self updating is
			//very usefull.
			if (g_fNeedUpdate)
				g_fNeedUpdate = !UpdateCdmDll();
			break;
    }
    return TRUE;
}

//This function determines if this client can connect to the internet.

BOOL DownloadIsInternetAvailable(
	void
) {
	LOG_block("DownloadIsInternetAvailable");

    int iDun		= GetDUNConnections();
    bool bWizard	= IsInternetConnectionWizardCompleted();
    bool bConnect	= IsInternetConnected();

    if (!bConnect && iDun <= 0)
	{
		LOG_error("if (!!bConnect && iDun <= 0) return false");
        return false;
	}

    if (!bWizard)
	{
		LOG_error("if (!bWizard) return false");
		return false;
	}

	LOG_out("return true");
    return true;
}

//This function Opens an internet connection for download. This connection
//context information is tracked though the returned handle.
//This functon returns a handle a CDM file download context if successful or
//NULL if not. If this function fails GetLastError() can be used to return
//the error code indicating the reason for failure.

HANDLE WINAPI OpenCDMContext(
    IN HWND /*hwnd*/	//Window handle to use for any UI that needs to be presented.
) {
	LOG_block("OpenCDMContext");
	return OpenCDMContextEx(TRUE);
}

HANDLE WINAPI OpenCDMContextEx(
    IN BOOL fConnectIfNotConnected
) {
	LOG_block("OpenCDMContextEx");

	//Initialize context handle array entry and mark it as is use.
	CONTEXTHANDLE cth;
	ZeroMemory(&cth, sizeof(cth));

	bool fConnected = IsInternetConnected();
#ifdef _WUV3TEST
	if (fConnected)
	{
		// catalog spoofing
		DWORD dwIsInternetConnected = 1;
		DWORD dwSize = sizeof(dwIsInternetConnected);
		auto_hkey hkey;
		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
			RegQueryValueEx(hkey, _T("IsInternetConnected"), 0, 0, (LPBYTE)&dwIsInternetConnected, &dwSize);
		}
		// only then do normal
		if (0 == dwIsInternetConnected)
		{
			fConnected = false;
		}
	}
#endif

	if (fConnectIfNotConnected || fConnected)
	{

		//Assume that we do not need to connect to the internet
		cth.fCloseConnection = !IsInternetConnected();


		//If we are not already connected to the internet and 
		//we fail in the attempt then we cannot download any
		//drivers so quit.
		if (InternetAttemptConnect(0) != NO_ERROR)
		{
			LOG_error("No internet connection");
			return 0;
		}

		TCHAR szSecurityServer[MAX_PATH] = {0};
		lstrcpy(szSecurityServer, SZ_SECURITY_SERVER);

		/* Test redirect*/{
			auto_hkey hkey;
			if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate"), 0, KEY_READ, &hkey)) {
				DWORD dwSize = sizeof(szSecurityServer);
				RegQueryValueEx(hkey, _T("SecurityServer"), 0, 0, (LPBYTE)&szSecurityServer, &dwSize);
			}
		}

		//Connect to and get server context.
		CDownload download;
		if (download.Connect(szSecurityServer))
		{
			LOG_out("Connected to SecurityServer '%s'", szSecurityServer);
		}
		else
		{
			LOG_error("No connection to SecurityServer '%s'", szSecurityServer);
			return 0;
		}
		
		//Init download
		CDiamond diamond;
		if (!diamond.valid()) {
			SetLastError(ERROR_GEN_FAILURE);
			LOG_error("cannot init diamond");
			return 0;
		}

		// do security url verification and get server locations
		if (!ProcessIdent(download, diamond, szSecurityServer, cth.szSiteServer, cth.szDownloadServer))
		{
			SetLastError(ERROR_ACCESS_DENIED);
			LOG_error("invalid identcdm.cab");
			return 0;
		}

		// reconnect fo Site server if we need to 
		if (0 != lstrcmpi(cth.szSiteServer,  szSecurityServer))
		{
			if (download.Connect(cth.szSiteServer))
			{
				LOG_out("Connected to SiteServer '%s'",  cth.szSiteServer);
			}
			else
			{
				LOG_error("No connection to SiteServer '%s'",  cth.szSiteServer);
				return 0;
			}
		}
		else
		{
			LOG_out("SiteServer is %s", szSecurityServer);
		}

		if (!DownloadCdmCab(download, diamond, cth.fNeedUpdate))
		{
			LOG_error("Failed to download cdm.cab");
			return 0;
		}
	}

	return LongToHandle(g_handleArray.add(cth) + 1);
}

//This function downloads the specified CDM package. The hConnection handle must have
//been returned from the OpenCDMContext() API.
//
//This function Returns TRUE if download is successful GetLastError() will return
//the error code indicating the reason that the call failed.

BOOL WINAPI DownloadUpdatedFiles(
	IN  HANDLE        hConnection,		//Connection handle from OpenCDMContext() API.
	IN  HWND          hwnd,				//Window handle for call context
	IN  PDOWNLOADINFO pDownloadInfo,	//download information structure describing
										//package to be read from server
	OUT LPWSTR        lpDownloadPath,	//local computer directory location of the
										//downloaded files
	IN  UINT          uSize,			//size of the download path buffer. If this
										//buffer is to small to contain the complete
										//path and file name no file will be downloaded.
										//The PUINT puReguiredSize parameter can be checked
										//to determine the size of buffer necessary to
										//perform the download.
	OUT PUINT         puRequiredSize	//required lpDownloadPath buffer size. This
										//parameter is filled in with the minimum size
										//that is required to place the complete path
										//file name of the downloaded file. If this
										//parameter is NULL no size is returned.
) {
	LOG_block("DownloadUpdatedFiles");

	int index = GetHandleIndex(hConnection);
	if (-1 == index)
	{
		LOG_error("invalid handle");
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}

	if (NULL == puRequiredSize)
	{
		LOG_error("puRequiredSize == NULL");
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	//Check and see if the download path is large enough to contain the return
	//directory where we will put the download cab files.
	TCHAR szTmpPath[MAX_PATH];
	int iLengthNeeded = GetDownloadPath(szTmpPath);

	if (lpDownloadPath == NULL || iLengthNeeded > (int)uSize)
	{
		LOG_error("uSize < then needed");
		*puRequiredSize = iLengthNeeded;
		SetLastError(ERROR_BUFFER_OVERFLOW);
		return FALSE;
	}

	// Declared locally
	typedef long (*PFN_GETPACKAGE)(PCONTEXTHANDLE pContextHandle, PDOWNLOADINFO pDownloadInfo, LPTSTR lpDownloadPath);
	PFN_GETPACKAGE pfnGetPackage = NULL;//Entry point in cdm.dll that actually performs the download


	// If there is cdmnew.dll in system directory use it
	auto_hlib hlib = LoadCdmnewDll();
	if (hlib.valid())
	{
		pfnGetPackage = (PFN_GETPACKAGE)GetProcAddress(hlib,"GetPackage");
		if (NULL == pfnGetPackage)
		{ 
			//if we cannot find our download function we need to return fail and not attempt
			//to download the update package.
			LOG_error("cannot find function 'GetPackage'");
			return FALSE;
		}
		LOG_out("Calling GetPackage() from cdmnew.dll");
	}
	else
	{
		// Declared locally
		long GetPackage(IN PCONTEXTHANDLE pContextHandle, IN PDOWNLOADINFO pDownloadInfo, OUT LPTSTR lpDownloadPath);
		pfnGetPackage = GetPackage;
		LOG_out("Calling internal GetPackage()");
	}
	int	iError = (pfnGetPackage)(&g_handleArray[index], pDownloadInfo, szTmpPath);

	if (iError != NO_ERROR)
	{
		SetLastError(iError);
		return FALSE;
	}
	*puRequiredSize = iLengthNeeded;
	lstrcpyW(lpDownloadPath, T2W(szTmpPath));
	return TRUE;
}

//This API closes the internet connection opened with the OpenCDMContext() API.
//If CDM did not open the internet connection this API simply returns. The CDM
//context handle must have been the same handle that was returned from
//the OpenCDMContext() API.
//
//This call cannot fail. If the pConnection handle is invalid this function
//simply ignores it.

VOID WINAPI CloseCDMContext (
	IN HANDLE hConnection	//CDM Connection handle returned with OpenCDMContext.
) {
	LOG_block("CloseCDMContext");

	int	index = GetHandleIndex(hConnection);

	if ( -1 == index)
	{
		LOG_error("invalid handle");
		return;
	}

	//If CDM.DLL opened this internet connection and if this connection is
	//for a modem then we need to close the internet connection. Note:
	//the Open context function only sets fCloseConnection for modem
	//connections.

    if (g_handleArray[index].fCloseConnection)
		InternetAutodialHangup(0);

	if (g_handleArray[index].fNeedUpdate)
	{
		//if any dll needs to be updated then
		//we set the global update flag. This will
		//force cdm.dll to be replaced when the last
		//process detaches.
		g_fNeedUpdate = true;
	}

	g_handleArray.remove(index);
}

int WINAPI QueryDetectionFiles(
    IN  HANDLE							hConnection, 
	IN	void*							pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
) {
	LOG_block("QueryDetectionFiles");

	int index = GetHandleIndex(hConnection);
	if (-1 == index)
	{
		LOG_error("invalid handle");
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}

	// Call external/internal implementetion
	typedef int (*PFN_InternalQueryDetectionFiles)(IN PCONTEXTHANDLE pContextHandle, IN void* pCallbackParam, IN PFN_QueryDetectionFilesCallback pCallback);
	PFN_InternalQueryDetectionFiles pfnInternalQueryDetectionFiles = NULL;

	auto_hlib hlib = LoadCdmnewDll();
	if (hlib.valid())
	{
		pfnInternalQueryDetectionFiles = (PFN_InternalQueryDetectionFiles)GetProcAddress(hlib, "InternalQueryDetectionFiles");
		if (NULL == pfnInternalQueryDetectionFiles)
		{ 
			LOG_error("cannot find function 'InternalQueryDetectionFiles'");
			return FALSE;
		}
		LOG_out("Calling InternalQueryDetectionFiles() from cdmnew.dll");
	}
	else
	{
		// Declared locally
		int InternalQueryDetectionFiles(IN PCONTEXTHANDLE pContextHandle, IN void* pCallbackParam, IN PFN_QueryDetectionFilesCallback pCallback);
		pfnInternalQueryDetectionFiles = InternalQueryDetectionFiles;
		LOG_out("Calling internal InternalQueryDetectionFiles()");
	}
	return (pfnInternalQueryDetectionFiles)(&g_handleArray[index], pCallbackParam, pCallback);
}

void WINAPI DetFilesDownloaded(
    IN  HANDLE hConnection
) {
	LOG_block("DetFilesDownloaded");

	int index = GetHandleIndex(hConnection);
	if (-1 == index)
	{
		LOG_error("invalid handle");
		return;
	}

	// Call external/internal implementetion
	typedef void (*PFN_InternalDetFilesDownloaded)(IN PCONTEXTHANDLE pContextHandle);
	PFN_InternalDetFilesDownloaded pfnInternalDetFilesDownloaded = NULL;

	auto_hlib hlib = LoadCdmnewDll();
	if (hlib.valid())
	{
		pfnInternalDetFilesDownloaded = (PFN_InternalDetFilesDownloaded)GetProcAddress(hlib, "InternalDetFilesDownloaded");
		if (NULL == pfnInternalDetFilesDownloaded)
		{ 
			LOG_error("cannot find function 'InternalDetFilesDownloaded'");
			return;
		}
		LOG_out("Calling InternalDetFilesDownloaded() from cdmnew.dll");
	}
	else
	{
		// Declared locally
		void InternalDetFilesDownloaded(IN PCONTEXTHANDLE pContextHandle);
		pfnInternalDetFilesDownloaded = InternalDetFilesDownloaded;
		LOG_out("Calling internal InternalDetFilesDownloaded()");
	}
	(pfnInternalDetFilesDownloaded)(&g_handleArray[index]);
}

// supports offline logging
// hConnection NOT used at all
// no network connection or osdet.dll needed for languauge, SKU, platform detection 
void WINAPI LogDriverNotFound(
    IN  HANDLE hConnection,
	IN LPCWSTR lpDeviceInstanceID,
	IN DWORD dwFlags
) {
	LOG_block("LogDriverNotFound");

	// Call external/internal implementetion
	typedef void (*PFN_InternalLogDriverNotFound)(IN PCONTEXTHANDLE pContextHandle, IN LPCWSTR lpDeviceInstanceID, IN DWORD dwFlags);
	PFN_InternalLogDriverNotFound pfnInternalLogDriverNotFound = NULL;
	CONTEXTHANDLE cth;

	ZeroMemory(&cth, sizeof(cth));

	auto_hlib hlib = LoadCdmnewDll();
	if (hlib.valid())
	{
		pfnInternalLogDriverNotFound = (PFN_InternalLogDriverNotFound)GetProcAddress(hlib, "InternalLogDriverNotFound");
		if (NULL == pfnInternalLogDriverNotFound)
		{ 
			LOG_error("cannot find function 'InternalLogDriverNotFound'");
			return;
		}
		LOG_out("Calling InternalLogDriverNotFound() from cdmnew.dll");
	}
	else
	{
		// Declared locally
		void InternalLogDriverNotFound(IN PCONTEXTHANDLE pContextHandle, IN LPCWSTR lpDeviceInstanceID, IN DWORD dwFlags);
		pfnInternalLogDriverNotFound = InternalLogDriverNotFound;
		LOG_out("Calling internal InternalLogDriverNotFound()");
	}
	// pass in dummy contexthandle
	(pfnInternalLogDriverNotFound)(&cth, lpDeviceInstanceID, dwFlags);
}


BOOL WINAPI  FindMatchingDriver(
	IN  HANDLE			hConnection,
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
) {
	LOG_block("FindMatchingDriver");

	int index = GetHandleIndex(hConnection);
	if (-1 == index)
	{
		LOG_error("invalid handle");
		SetLastError(ERROR_INVALID_HANDLE);
		return FALSE;
	}

	// Call external/internal implementetion
	typedef BOOL (*PFN_InternalFindMatchingDriver)(IN PCONTEXTHANDLE pContextHandle, IN PDOWNLOADINFO pDownloadInfo, OUT PWUDRIVERINFO	pWuDriverInfo);
	PFN_InternalFindMatchingDriver pfnInternalFindMatchingDriver = NULL;

	auto_hlib hlib = LoadCdmnewDll();
	if (hlib.valid())
	{
		pfnInternalFindMatchingDriver = (PFN_InternalFindMatchingDriver)GetProcAddress(hlib,"InternalFindMatchingDriver");
		if (NULL == pfnInternalFindMatchingDriver)
		{ 
			LOG_error("cannot find function 'InternalFindMatchingDriver'");
			return FALSE;
		}
		LOG_out("Calling InternalFindMatchingDriver() from cdmnew.dll");
	}
	else
	{
		// Declared locally
		BOOL InternalFindMatchingDriver(IN PCONTEXTHANDLE pContextHandle, IN PDOWNLOADINFO pDownloadInfo, OUT PWUDRIVERINFO	pWuDriverInfo);
		pfnInternalFindMatchingDriver = InternalFindMatchingDriver;
		LOG_out("Calling internal InternalFindMatchingDriver()");
	}
	return (pfnInternalFindMatchingDriver)(&g_handleArray[index], pDownloadInfo, pWuDriverInfo);
}


//This function is called to download the actual package. What happens is that the
//cdm.dll is copied from the server. This dll is then dynamically loaded by the
//DownloadGetUpdatedFiles() API and called. This allows the most recent cdm.dll
//to be used even if the client has an out dated version on their system.
//
//If this function is successfull then it returns NO_ERROR. If the case of a
//failure this function returns an error code.

long GetPackage(
	IN	PCONTEXTHANDLE pContextHandle,	//Pointer Context handle structure that contains the server and dll information needed to perform the download.
	IN	PDOWNLOADINFO pDownloadInfo,	//download information structure describing package to be read from server
	OUT LPTSTR lpDownloadPath			//Poitner to local directory on the client computer system where the downloaded files are to be stored.
) {
	LOG_block("GetPackage");
	
	USES_CONVERSION;

	SHelper helper;
	//
	// NTRAID#NTBUG9-185297-2000/11/21-waltw Fixed: bufBucket must have same scope as SHelper
	//
	byte_buffer bufBucket;
	DWORD dwError = PrepareCatalog(pContextHandle->szSiteServer, helper);
	if (NO_ERROR != dwError)
	{
		SetLastError(dwError);
		return FALSE;
	}

	//Clear out any files that might be in the temp download directory.
	if (!DeleteNode(lpDownloadPath))
	{
		LOG_out("DeleteNode(%s) failed last error %d", lpDownloadPath, GetLastError());
	}
	if (!CreateDirectory(lpDownloadPath, NULL))
	{
		LOG_out("CreateDirectory(%s) failed last error %d", lpDownloadPath, GetLastError());
	}


	bool fPlist = (
		NULL != pDownloadInfo->lpHardwareIDs && 
		0 == lstrcmpiW(L"3FBF5B30-DEB4-11D1-AC97-00A0C903492B", pDownloadInfo->lpHardwareIDs)
	);

	// Get to and from information
	TCHAR szCabLocalFile[MAX_PATH];
	GetWindowsUpdateDirectory(szCabLocalFile);

	if (fPlist) {
		TCHAR szCabServerFile[MAX_PATH];
		wsprintf(szCabServerFile, _T("%d_%#08x.plist"), helper.enPlatform, helper.dwLangID);
		LOG_out("getting PLIST %s", szCabServerFile);

		PathAppend(szCabLocalFile, szCabServerFile);

		// Now we can say that we are ready
		if (!helper.download.Copy(szCabServerFile, szCabLocalFile))
		{
			LOG_error("%s failed to download", szCabServerFile);
			return ERROR_FILE_NOT_FOUND;
		}
	}
	else
	{
		TCHAR szCabFileTitle[MAX_PATH];
		if (!FindUpdate(pDownloadInfo, helper, bufBucket))
		{
			LOG_error("no update has been found");
			return ERROR_FILE_NOT_FOUND;
		}
		LOG_out("PUID %d is found", helper.puid);

		CDownload downloadCabpool;
		if (downloadCabpool.Connect(pContextHandle->szDownloadServer))
		{
			LOG_out("Connected to DownloadServer '%s'",  pContextHandle->szDownloadServer);
		}
		else
		{
			LOG_error("No connection to DownloadServer '%s'", pContextHandle->szDownloadServer);
			return ERROR_GEN_FAILURE;
		}
		TCHAR szCabServerFile[MAX_PATH];
		lstrcpy(szCabServerFile, _T("CabPool/"));
		lstrcat(szCabServerFile, A2T(helper.DriverMatchInfo.pszCabFileTitle));

		PathAppend(szCabLocalFile, A2T(helper.DriverMatchInfo.pszCabFileTitle));

		// Now we can say that we are ready
		if (!downloadCabpool.Copy(szCabServerFile, szCabLocalFile))
		{
			LOG_error("%s failed to download", szCabServerFile);
			URLPingReport(helper, URLPING_FAILED);
			return ERROR_FILE_NOT_FOUND;
		}

		// Verify if it's not webntprn.cab
		HRESULT hr = VerifyFile(szCabLocalFile, FALSE);
		if (FAILED(hr))
		{
			LOG_error("signature verification failed");
			DeleteFile(szCabLocalFile);
			URLPingReport(helper, URLPING_FAILED);
			return hr;
		}
	}

	TCHAR szDownloadFiles[MAX_PATH];
	lstrcpy(szDownloadFiles, lpDownloadPath);
	PathAppend(szDownloadFiles, _T("*"));
	if (!helper.diamond.Decompress(szCabLocalFile, szDownloadFiles))
	{
		LOG_error("Decompress failed");
		if (!fPlist)
			URLPingReport(helper, URLPING_FAILED);
		return ERROR_FILE_NOT_FOUND;
	}
	LOG_out("Download to %s completed OK", lpDownloadPath);
	DeleteFile(szCabLocalFile);
	if (!fPlist)
		URLPingReport(helper, URLPING_SUCCESS);
	return S_OK;
}

static void UrlAppend(LPTSTR pszURL, LPCTSTR pszPath)
{
	if ('/' != pszURL[lstrlen(pszURL) - 1])
		lstrcat(pszURL, _T("/"));
	lstrcat(pszURL, pszPath);
}


inline bool IsNewer(
	IN LPCTSTR szFileName1, 
	IN LPCTSTR szFileName2
) {
	LOG_block("IsNewer");
	auto_hfile hFile1 = CreateFile(szFileName1, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hFile1.valid())
	{
		LOG_error("CreateFile(%s, ...) failed, error %d", szFileName1, GetLastError());
		return true;
	}
	auto_hfile hFile2 = CreateFile(szFileName2, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hFile2.valid())
	{
		LOG_error("CreateFile(%s, ...) failed, error %d", szFileName2, GetLastError());
		return false;
	}
	FILETIME ft1;
	if (!GetFileTime(hFile1, NULL, NULL, &ft1))
	{
		LOG_error("GetFileTime(%s, ...) failed, error %d", szFileName1, GetLastError());
		return true;
	}

	FILETIME ft2;
	if (!GetFileTime(hFile2, NULL, NULL, &ft2))
	{
		LOG_error("GetFileTime(%s, ...) failed, error %d", szFileName2, GetLastError());
		return false;
	}
	return CompareFileTime(&ft1, &ft2) < 0;

}

void DoCallback(
	IN void* pCallbackParam, IN PFN_QueryDetectionFilesCallback pCallback,
	SHelper& helper, LPCTSTR pszSiteServer, LPCTSTR pszFileTitle, bool fInCatalog = true
) {
	USES_CONVERSION;

	TCHAR szCatalog[32];
	wsprintf(szCatalog, _T("%d"), helper.puidCatalog);

	TCHAR szURL[INTERNET_MAX_URL_LENGTH];
	lstrcpy(szURL, pszSiteServer);
	if (fInCatalog)
		UrlAppend(szURL, szCatalog);
	UrlAppend(szURL, pszFileTitle);

	TCHAR szLocalFile[MAX_PATH];		
	GetWindowsUpdateDirectory(szLocalFile);
	PathAppend(szLocalFile, pszFileTitle);

	pCallback(pCallbackParam, T2W(szURL), T2W(szLocalFile));
}


int InternalQueryDetectionFiles(IN PCONTEXTHANDLE pContextHandle, IN void* pCallbackParam, IN PFN_QueryDetectionFilesCallback pCallback)
{
	LOG_block("InternalQueryDetectionFiles");

	SHelper helper;
	DWORD dwError = PrepareCatalog(pContextHandle->szSiteServer, helper);
	if (NO_ERROR != dwError)
	{
		SetLastError(dwError);
		return -1;
	}
#if 0
	// Get CDM inventory
	TCHAR szPath[MAX_PATH];
	wsprintf(szPath, _T("%d/%d.cab"), helper.puidCatalog, helper.puidCatalog);

	TCHAR szURL[INTERNET_MAX_URL_LENGTH];
	lstrcpy(szURL, pContextHandle->szSiteServer);
	UrlAppend(szURL, szPath);

	GetWindowsUpdateDirectory(szPath);
	PathAppend(szPath, _T("buckets.cab"));

	pCallback(pCallbackParam, T2W(szURL), T2W(szPath));
	return 1;
#else
	// Get CDM inventory
	TCHAR szPath[MAX_PATH];
	wsprintf(szPath, _T("%d/inventory.cdm"), helper.puidCatalog);

	byte_buffer bufInventory;
	if (!DownloadToBuffer(helper, szPath, bufInventory))
	{
		LOG_error("Dowload inventory failed");
		return -1;
	}
	
	//Here we need a trick to determine if we need to do anything: we do if inventory.cdm is a newer then inventory.cdm.last
	GetWindowsUpdateDirectory(szPath);
	PathAppend(szPath, _T("inventory.cdm"));
	TCHAR szPathLast[MAX_PATH];
	lstrcpy(szPathLast, szPath);
	lstrcat(szPathLast, _T(".last"));
	if (!IsNewer(szPathLast, szPath))
	{
		LOG_out("inventory.cdm is up to date");
		return 0;
	}
	CopyFile(szPath, szPathLast, FALSE);

	PCDM_HASHTABLE pHashTable = (PCDM_HASHTABLE)(LPBYTE)bufInventory;

	int nCount = 0;
	DoCallback(pCallbackParam, pCallback, helper, pContextHandle->szSiteServer, _T("oeminfo.bin"), false);
	nCount ++;
	DoCallback(pCallbackParam, pCallback, helper, pContextHandle->szSiteServer, _T("bitmask.cdm"));
	nCount ++;

	for (ULONG ulHashIndex = 0; ulHashIndex < pHashTable->hdr.iTableSize; ulHashIndex ++)
	{
		if(GETBIT(pHashTable->pData, ulHashIndex))
		{
			TCHAR szTitle[16];
			wsprintf(szTitle, _T("%d.bkf"), ulHashIndex);
			DoCallback(pCallbackParam, pCallback, helper, pContextHandle->szSiteServer, szTitle);
			nCount ++;
		}
	}
	return nCount;
#endif
}

void InternalDetFilesDownloaded(IN PCONTEXTHANDLE pContextHandle)
{
	LOG_block("InternalDetFilesDownloaded");
#if 0
	TCHAR szPath[MAX_PATH];
	GetWindowsUpdateDirectory(szPath);
	PathAppend(szPath, _T("buckets.cab"));
	
	CDiamond diamond;
	diamond.Decompress(szPath, _T("*"));
#endif
}


// pContextHandle not used. 
// dwFlags could be either 0 or BEGINLOGFLAG
void InternalLogDriverNotFound(IN PCONTEXTHANDLE pContextHandle, IN LPCWSTR lpDeviceInstanceID, IN DWORD dwFlags)
{
	LOG_block("InternalLogDriverNotFound");
	LOG_out("DeviceInstanceID is %s", lpDeviceInstanceID);

	using std::vector;
	
	DWORD bytes;
	//auto_pointer<IDrvInfo> pDrvInfo;
	tchar_buffer bufText;
	TCHAR tszFilename[MAX_PATH];
	TCHAR tszUniqueFilename[MAX_PATH];
	TCHAR tszBuffer[32];
	DEVINST devinst;
	HRESULT hr = E_FAIL;
	bool fXmlFileError = false;
	static vector<WCHAR*> vDIDList; //device instance id list
	LPWSTR pDID = NULL; //Device Instance ID
	FILE * fOut = NULL; //for XML file
	SHelper helper;
	HANDLE hFile = NULL;
	

	lstrcpy(tszFilename, _T("")); //initialize tszFilename
	if (lpDeviceInstanceID != NULL) 
	{ //append the new device instance id into internal list
		pDID = (LPWSTR) malloc((wcslen(lpDeviceInstanceID)+1) * sizeof(WCHAR));
		if (NULL == pDID)
		{
			LOG_error("memory allocation failed for new DeviceInstanceID");
		}
		else
		{
			lstrcpyW(pDID, lpDeviceInstanceID);
			vDIDList.push_back(pDID);
			LOG_out("new DeviceInstanceID added to internal list");
		}
	}

	if (0 == (dwFlags & BEGINLOGFLAG) || 0 == vDIDList.size())
	{ // not last log request or nothing to log
		LOG_out("Won't log to hardware_XXX.xml");
		return;
	}


	GetWindowsUpdateDirectory(tszFilename);
	hr = GetUniqueFileName(tszFilename,tszUniqueFilename, MAX_PATH, hFile);
	if (S_OK != hr) 
	{
		LOG_error("fail to get unique file name");
		fXmlFileError = true;
		goto CloseXML;
	}
	lstrcat(tszFilename, tszUniqueFilename);
	CloseHandle(hFile);
	fOut = _tfopen(tszFilename, _T("wb"));
	if (! fOut)
	{
		LOG_error("_tfopen failed");
		fXmlFileError = true;
		DeleteFile(tszFilename);
		goto CloseXML;
	}

	LOG_out("Logging to %s", tszFilename);
	
	
	// Don't need to get langID and platformID from catalog
	// get it offline using osdet.dll
	if (S_OK != ProcessOsdetOffline(helper))
	{
		LOG_error("platform and language detection failed");
		fXmlFileError = true;
		goto CloseXML;
	}
	
	_tstrdate(tszBuffer);

#ifdef _UNICODE
	fwprintf(fOut, _T("%c"), (int) 0xFEFF);
#else
	#error _UNICODE must be defined for InternalLogDriverNotFound
#endif

	TCHAR tszSKU[SKU_STRING_MAX_LENGTH];
	hr = GetSKUString(tszSKU, SKU_STRING_MAX_LENGTH);
	if (S_OK != hr) 
	{
		LOG_error("Fail to get SKU string");
		fXmlFileError = true;
		goto CloseXML;
	}
	if (0 > _ftprintf(fOut, _T("<?xml version=\"1.0\"?>\r\n<inventory date=\"%s\" locale=\"%p\" platform=\"%d\" sku=\"%s\">\r\n"), tszBuffer, helper.dwLangID, helper.enPlatform, tszSKU))
	{
		fXmlFileError = true;
		goto CloseXML;
	}

	for (int i = 0; i < vDIDList.size(); i++)
	{
		pDID = vDIDList[i];
		
		//
		// NTBUG9#151928 - Log both hardware and compatible IDs of the device that matches lpDeviceInstanceID
		//

		LOG_out("Log device instance with id %s", pDID);
		if (CR_SUCCESS == CM_Locate_DevNode(&devinst, (LPWSTR) pDID, 0))
		{
			if (0 > _ftprintf(fOut, _T("\t<device>\r\n")))
			{
				fXmlFileError = true;
				goto CloseXML;
			}

			//
			// Log device description
			//
			ULONG ulLength = 0;
			if (CR_BUFFER_SMALL == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_DEVICEDESC, NULL, NULL, &ulLength, 0))
			{
				bufText.resize(ulLength);

				if (bufText.valid() &&
					CR_SUCCESS == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_DEVICEDESC, NULL, bufText, &ulLength, 0))
				{
						if (0 > _ftprintf(fOut, _T("\t\t<description><![CDATA[%s]]></description>\r\n"), (LPCTSTR) bufText))
						{
							fXmlFileError = true;
							goto CloseXML;
						}
				}
			}


							  
			//
			// Log all the hardware IDs
			//
			ulLength = 0;
			if (CR_BUFFER_SMALL == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_HARDWAREID, NULL, NULL, &ulLength, 0))
			{
				bufText.resize(ulLength);

				if (bufText.valid() &&
					CR_SUCCESS == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_HARDWAREID, NULL, bufText, &ulLength, 0))
				{
					for (TCHAR* pszNextID = (TCHAR*) bufText; *pszNextID; pszNextID += (lstrlen(pszNextID) + 1))
					{
						if (0 > _ftprintf(fOut, _T("\t\t<hwid><![CDATA[%s]]></hwid>\r\n"), (LPCTSTR) pszNextID))
						{
							fXmlFileError = true;
							goto CloseXML;
						}
					}
				}
			}

			//
			// Log all the compatible IDs
			//
			ulLength = 0;
			if (CR_BUFFER_SMALL == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_COMPATIBLEIDS, NULL, NULL, &ulLength, 0))
			{
				bufText.resize(ulLength);

				if (bufText.valid() &&
					CR_SUCCESS == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_COMPATIBLEIDS, NULL, bufText, &ulLength, 0))
				{
					for (TCHAR* pszNextID = (TCHAR*) bufText; *pszNextID; pszNextID += (lstrlen(pszNextID) + 1))
					{
						if (0 > _ftprintf(fOut, _T("\t\t<compid><![CDATA[%s]]></compid>\r\n"), (LPCTSTR) pszNextID))
						{
							fXmlFileError = true;
							goto CloseXML;
						}
					}
				}
			}

			if (0 > _ftprintf(fOut, _T("\t</device>\r\n")))
			{
				fXmlFileError = true;
				goto CloseXML;
			}
		}
	} //for
	
	if(0 > _ftprintf(fOut, _T("</inventory>\r\n")))
	{
		fXmlFileError = true;
	}

CloseXML:
	if (fOut != NULL) fclose(fOut);
	for (int i = 0; i < vDIDList.size(); i++)
	{//free memory
		free(vDIDList[i]);
	}
	vDIDList.clear();

	//
	// Open Help Center only if we have valid xml
	//
	if (!fXmlFileError)
	{
		// open help center
		const static TCHAR szBase[] = _T("hcp://services/layout/contentonly?topic=hcp://system/dfs/uplddrvinfo.htm%3f"); //hardcode '?' escaping
		tchar_buffer tchCName(MAX_PATH); //file name canonicalized once
		tchar_buffer tchC2Name(INTERNET_MAX_URL_LENGTH); //file name canonicalized twice
		tchar_buffer tchFinalUrl;
		DWORD dwLen = 0;
		BOOL fBufferResized = FALSE;

		GetWindowsUpdateDirectory(tszFilename);
		lstrcat(tszFilename, tszUniqueFilename);
		
		LOG_out("Canonicalize %s", tszFilename);

		if (FAILED(CdmCanonicalizeUrl(tszFilename, tchCName, MAX_PATH, 0)))
		{
			goto CleanUp;
		}
		
		LOG_out("File name canonicalized %s", (LPTSTR) tchCName);	
		LOG_out("Canonicalize file name %s AGAIN", (LPTSTR)tchCName);

		if (FAILED(CdmCanonicalizeUrl((LPCTSTR)tchCName, tchC2Name, INTERNET_MAX_URL_LENGTH, ICU_ENCODE_PERCENT)))
		{
			goto CleanUp;
		}
					
		LOG_out("File name canonicalized twice %s", (LPTSTR)tchC2Name);
		
		//need one extra character space
		//for the ending null
		tchFinalUrl.resize(lstrlen(szBase) + lstrlen((LPCTSTR) tchC2Name) + 1);
		if (!tchFinalUrl.valid())
		{
			LOG_error("Out of memory for FinalUrl buffer");
			goto CleanUp;
		}

		wsprintf(tchFinalUrl, _T("%s%s"), szBase, (LPCTSTR) tchC2Name);
		
		LOG_out("Opening HelpCenter: \"%s\"", (LPCTSTR) tchFinalUrl);
		ShellExecute(NULL, NULL, (LPCTSTR) tchFinalUrl, NULL, NULL, SW_SHOWNORMAL);
		return; //keep the file and return
	}

//remove the file generated
CleanUp:
	if (fOut != NULL)
	{
		DeleteFile(tszFilename);
		fOut = NULL;
	}
	return;
}

BOOL InternalFindMatchingDriver(IN PCONTEXTHANDLE pContextHandle, IN PDOWNLOADINFO pDownloadInfo, OUT PWUDRIVERINFO	pWuDriverInfo)
{
	LOG_block("InternalFindMatchingDriver");
	
	bool fConnected = IsInternetConnected();
#ifdef _WUV3TEST
	if (fConnected)
	{
		// catalog spoofing
		DWORD dwIsInternetConnected = 1;
		DWORD dwSize = sizeof(dwIsInternetConnected);
		auto_hkey hkey;
		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
			RegQueryValueEx(hkey, _T("IsInternetConnected"), 0, 0, (LPBYTE)&dwIsInternetConnected, &dwSize);
		}
		// only then do normal
		if (0 == dwIsInternetConnected)
		{
			fConnected = false;
		}
	}
#endif

	SHelper helper;
	//
	// NTRAID#NTBUG9-185297-2000/11/21-waltw Fixed: bufBucket must have same scope as SHelper
	//
	byte_buffer bufBucket;
	DWORD dwError = PrepareCatalog(fConnected ? pContextHandle->szSiteServer : NULL, helper);
	if (NO_ERROR != dwError)
	{
		SetLastError(dwError);
		return FALSE;
	}

	if (!FindUpdate(pDownloadInfo, helper, bufBucket))
	{
		LOG_out("NO UPDATE IS FOUND");
		return FALSE;
	}
		
	LOG_out("PUID %d IS FOUND", helper.puid);
	// Fill out info
	if (
		0 == MultiByteToWideChar(CP_ACP, 0, helper.DriverMatchInfo.pszHardwareID,	-1, pWuDriverInfo->wszHardwareID, HWID_LEN) ||
		0 == MultiByteToWideChar(CP_ACP, 0, helper.DriverMatchInfo.pszDescription,	-1, pWuDriverInfo->wszDescription, LINE_LEN) ||
		0 == MultiByteToWideChar(CP_ACP, 0, helper.DriverMatchInfo.pszMfgName,		-1, pWuDriverInfo->wszMfgName, LINE_LEN) ||
		0 == MultiByteToWideChar(CP_ACP, 0, helper.DriverMatchInfo.pszProviderName, -1, pWuDriverInfo->wszProviderName, LINE_LEN) ||
		0 == MultiByteToWideChar(CP_ACP, 0, helper.DriverMatchInfo.pszDriverVer,	-1, pWuDriverInfo->wszDriverVer, LINE_LEN)
	) {
		LOG_error("MultiByteToWideChar failed");
		return FALSE;
	}
	return TRUE;
}

//This API gets the context handle array index from a connection handle.
//The connection context handle is checked if found invalid then -1 is
//returned. Otherwise the index that this handle references is returned.

int GetHandleIndex(
	IN HANDLE hConnection	//CDM Connect handle
) {
	int index = HandleToLong(hConnection) - 1;

	//If handle is invalid or not in use then return as nothing to do.
	if (!g_handleArray.valid_index(index))
		return -1;

	return index;
}

// for findoem
HMODULE GetModule()
{
	return g_hModule;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuau\wuaulib\xmllog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       auxml.cpp
//
//  About:  source file for AU related XML and schema data structure and functions
//--------------------------------------------------------------------------
#include "pch.h"

#if 0
HRESULT MYLoadXMLDoc(BSTR bstrXml, IXMLDOMDocument** ppDoc) //always offline
{
	HRESULT	hr;
	VARIANT_BOOL fSuccess ;

//       DEBUGMSG("MYLoadXMLDoc starts");
 	hr = CoCreateInstance(__uuidof(DOMDocument),
 	                                        NULL,
 	                                        CLSCTX_INPROC_SERVER,
 	                                        __uuidof( IXMLDOMDocument),
						  (void **) ppDoc);
      if (FAILED(hr))
	{
	        DEBUGMSG("Warning: Fail to create DOM document with error %#lx", hr);
            	goto done;
	}
	if (FAILED(hr = (*ppDoc)->put_validateOnParse(VARIANT_FALSE)) ||
	    FAILED(hr = (*ppDoc)->put_resolveExternals(VARIANT_FALSE)) ||
	    FAILED(hr = (*ppDoc)->put_async(VARIANT_FALSE)))
	{
	       DEBUGMSG("Warning: Fail to set document properties with error %#lx", hr);
		SafeRelease(*ppDoc);
        	goto done;
	}

	//
	// load the XML Doc from input string
	//
       if (S_OK != (hr = (*ppDoc)->loadXML(bstrXml, &fSuccess)))
	{
	       DEBUGMSG("Warning: Fail to load document with error %#lx", hr);
		SafeRelease(*ppDoc);
	}

       if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

done:
    //   DEBUGMSG("MYLoadXMLDoc ends");
       return hr;
       
}
#endif


#ifdef DBG 
void LOGFILE(LPTSTR szFileName, BSTR bstrMessage)
{
//    USES_CONVERSION;
       TCHAR szLogFile[MAX_PATH] ;
       AUASSERT(_T('\0') != g_szWUDir[0]);
	   if (FAILED(StringCchCopyEx(szLogFile, ARRAYSIZE(szLogFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
           FAILED(StringCchCatEx(szLogFile, ARRAYSIZE(szLogFile), szFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	   {
            DEBUGMSG("file name and path too long");
            return;
       }
	HANDLE hFile = CreateFile(szLogFile, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		DEBUGMSG("Fail to create file %S", T2W(szLogFile));
		return;
	}
		
	DWORD dwBytesWritten;
    BYTE bMagic1 = 0xff;
    BYTE bMagic2 = 0xfe;
	if (!WriteFile(hFile, &bMagic1, sizeof(bMagic1), &dwBytesWritten, NULL) ||
	    !WriteFile(hFile, &bMagic2, sizeof(bMagic2), &dwBytesWritten, NULL) ||
	    !WriteFile(hFile, bstrMessage, SysStringByteLen(bstrMessage), &dwBytesWritten, NULL))
	{
		DEBUGMSG("Fail to write to file %S with error %d", T2W(szLogFile), GetLastError());
	}
	CloseHandle(hFile);
	return;
}
#endif


HRESULT  LOGXMLFILE(LPCTSTR szFileName, BSTR bstrMessage)
{
    IXMLDOMDocument *pxml;
    HRESULT hr ;
    TCHAR szLogFile[MAX_PATH] ;

    if (NULL == szFileName)
    {	 //no logging needed
    	return E_INVALIDARG;
    }

	AUASSERT(_T('\0') != g_szWUDir[0]);
    if (FAILED(hr = StringCchCopyEx(szLogFile, ARRAYSIZE(szLogFile), g_szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
		FAILED(hr = StringCchCatEx(szLogFile, ARRAYSIZE(szLogFile), szFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)))
        {
            return hr;
        }

    CAU_BSTR aubsTmp;
    if (!aubsTmp.append(T2W(szLogFile)))
    {
    	return E_OUTOFMEMORY;
    }
    if (SUCCEEDED(hr = LoadXMLDoc(bstrMessage, &pxml)))
        {
            if (FAILED(hr = SaveDocument(pxml, aubsTmp)))
                {
                    DEBUGMSG("Warning: Fail to save xml file %S", T2W(szLogFile));
                }
            pxml->Release();
        }
    else
        {
            DEBUGMSG("Warning: fail to load ill formated xml with error %#lx", hr);
#ifdef DBG
            TCHAR szBadFileName[MAX_PATH+1];
            if (SUCCEEDED(StringCchCopyEx(szBadFileName, ARRAYSIZE(szBadFileName), szFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)) &&
				SUCCEEDED(StringCchCatEx(szBadFileName, ARRAYSIZE(szBadFileName), _T(".xml"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
			{
				LOGFILE(szBadFileName, bstrMessage);
			}
#endif
        }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdm\cdmp.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmp.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      CDM auxiliary functions
//
//			called by DownloadIsInternetAvailable()
//				GetDUNConnections
//				IsInternetConnectionWizardCompleted
//				IsInternetConnected
//	
//			called by DownloadGetUpdatedFiles()
//				FindDevInstID
//			
//			called by OpenCDMContext()
//				ProcessIdent
//				DownloadCdmCab
//			
//			called by DownloadUpdatedFiles()
//				GetDownloadPath
//				GetWindowsUpdateDirectory
//				LoadCdmnewDll
//			
//			called by GetPackage()
//				PrepareCatalog
//				ProcessOsdet
//				BuildExclusionsList
//				FindCatalog
//				FindUpdate
//				DeleteNode
//				URLPingReport
//			
//			called by InternalQueryDetectionFiles
//				DownloadToBuffer
//			
//			called by InternalLogDriverNotFound()
//				ProcessOsdetOffline
//				GetUniqueFileName
//				GetSKUString
//				CdmCanonicalizeUrl
//
//			called by DllMain()
// 				UpdateCdmDll
//			
//			called internally
//				IsInMap
//				GetOEMandLocalBitmask
//				DownloadToBuffer
//			
//			WU_VARIABLE_FIELD::
//				GetNext
//				Find
//				WU_VARIABLE_FIELD
//				GetSize
//
//=======================================================================

#include <windows.h>
#include <osdet.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <softpub.h>
#include <ras.h>
#include <regstr.h>
#include <tchar.h>
#include <atlconv.h>
#include <winver.h>

#include <wustl.h>
#include <log.h>
#include <wuv3cdm.h>
#include <bucket.h>
#include <findoem.h>
#include <DrvInfo.h>
#include <newtrust.h>
#include <download.h>
#include <diamond.h>
#include <mscat.h>

#include "cdm.h"
#include "cdmp.h"

static ULONG IsInMap(IN PCDM_HASHTABLE pHashTable, IN LPCTSTR pHwID);
static bool GetOEMandLocalBitmask(IN SHelper& helper, OUT byte_buffer& bufOut);
static bool FilesIdentical(IN LPCTSTR szFileName1, IN LPCTSTR szFileName2);
inline bool FileExists(IN LPCTSTR pszFile) { return 0xFFFFFFFF != GetFileAttributes(pszFile); }

// MSCAT32 support (CryptCAT API's)
const TCHAR MSCAT32DLL[] = _T("mscat32.dll");
const TCHAR CDMCAT[] = _T("cdm.cat");
const TCHAR CDMDLL[] = _T("cdm.dll");
const TCHAR CDMNEWDLL[] = _T("cdmnew.dll");
const TCHAR IUCDMDLL[] = _T("iucdm.dll");

// CryptCat Function Pointer Types
typedef BOOL (*PFN_CryptCATAdminAcquireContext)(OUT HCATADMIN *phCatAdmin, 
                                                IN const GUID *pgSubsystem, 
                                                IN DWORD dwFlags);
typedef HCATINFO (*PFN_CryptCATAdminAddCatalog)(IN HCATADMIN hCatAdmin, 
                                            IN WCHAR *pwszCatalogFile, 
                                            IN OPTIONAL WCHAR *pwszSelectBaseName, 
                                            IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATCatalogInfoFromContext)(IN HCATINFO hCatInfo,
                                                   IN OUT CATALOG_INFO *psCatInfo,
                                                   IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATAdminReleaseCatalogContext)(IN HCATADMIN hCatAdmin,
                                                       IN HCATINFO hCatInfo,
                                                       IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATAdminReleaseContext)(IN HCATADMIN hCatAdmin,
                                                IN DWORD dwFlags);


// ----------------------------------------------------------------------------------
//
// functions to compare file versions borrowed from IU
//	
// ----------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------
// 
// define a type to hold file version data
//
// ----------------------------------------------------------------------------------
typedef struct _FILE_VERSION
{
	WORD Major;
	WORD Minor;
	WORD Build;
	WORD Ext;
} FILE_VERSION, *LPFILE_VERSION;

static BOOL GetFileVersion(LPCTSTR lpsFile, LPFILE_VERSION lpstVersion)
{
	LOG_block("GetFileVersion()");

	DWORD	dwVerInfoSize;
	DWORD	dwHandle;
	DWORD	dwVerNumber;
	LPVOID	lpBuffer = NULL;
	UINT	uiSize;
	VS_FIXEDFILEINFO* lpVSFixedFileInfo;

	if (NULL != lpstVersion)
	{
		//
		// if this pointer not null, we always try to initialize
		// this structure to 0, in order to reduce the change of 
		// programming error, no matter the file exists or not.
		//
		ZeroMemory(lpstVersion, sizeof(FILE_VERSION));
	}
	if (NULL == lpsFile || NULL == lpstVersion)
	{
		LOG_error("E_INVALIDARG");
		return FALSE;
	}

	
	dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)lpsFile, &dwHandle);
	
	if (0 == dwVerInfoSize)
	{
		DWORD dwErr = GetLastError();
		if (0 == dwErr)
		{
			LOG_error("File %s does not have version data.", lpsFile);
		}
		else
		{
			LOG_error("Error: 0x%08x", dwErr);
		}
		return FALSE;
	}


	if (NULL == (lpBuffer = (LPVOID) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwVerInfoSize)))
	{
		LOG_error("Failed to allocate memory to get version info");
		return FALSE;
	}

	if (!GetFileVersionInfo((LPTSTR)lpsFile, dwHandle, dwVerInfoSize, lpBuffer))
	{
		LOG_error("GetFileVersionInfo: 0x%08x", GetLastError());
		HeapFree(GetProcessHeap(), 0, lpBuffer);
		return FALSE;
	}

	//
	// Get the value for Translation
	//
	if (!VerQueryValue(lpBuffer, _T("\\"), (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize))
	{
		LOG_error("VerQueryValue: 0x%08x", GetLastError());
		HeapFree(GetProcessHeap(), 0, lpBuffer);
		return FALSE;
	}

	dwVerNumber = lpVSFixedFileInfo->dwFileVersionMS;
	lpstVersion->Major	= HIWORD(dwVerNumber);
	lpstVersion->Minor	= LOWORD(dwVerNumber);

	dwVerNumber = lpVSFixedFileInfo->dwFileVersionLS;
	lpstVersion->Build	= HIWORD(dwVerNumber);
	lpstVersion->Ext	= LOWORD(dwVerNumber);

	LOG_out("File %s found version %d.%d.%d.%d", 
				lpsFile, 
				lpstVersion->Major, 
				lpstVersion->Minor, 
				lpstVersion->Build, 
				lpstVersion->Ext);

	HeapFree(GetProcessHeap(), 0, lpBuffer);
	
	return TRUE;
}

static int CompareVersions(const FILE_VERSION stVersion1, const FILE_VERSION stVersion2)
{

	if ((short)stVersion1.Major < 0 || (short)stVersion2.Major < 0)
	{
		//
		// two empty version structure to compare, we call it equal
		//
		return 0;
	}

	if (stVersion1.Major != stVersion2.Major)
	{
		//
		// major diff, then we know the answer 
		//
		return (stVersion1.Major < stVersion2.Major) ? -1 : 1;
	}
	else
	{
		if ((short)stVersion1.Minor < 0 || (short)stVersion2.Minor < 0)
		{
			//
			// if any minor missing, they equal
			//
			return 0;
		}

		if (stVersion1.Minor != stVersion2.Minor)
		{
			//
			// minor diff, then we know the answer
			//
			return (stVersion1.Minor < stVersion2.Minor) ? -1 : 1;
		}
		else
		{
			if ((short)stVersion1.Build < 0 || (short)stVersion2.Build < 0)
			{
				//
				// if any build is missing, they equal
				//
				return 0;
			}

			if (stVersion1.Build != stVersion2.Build)
			{
				//
				// if build diff then we are done
				//
				return (stVersion1.Build < stVersion2.Build) ? -1 : 1;
			}
			else
			{
				if ((short)stVersion1.Ext < 0 || (short)stVersion2.Ext < 0 || stVersion1.Ext == stVersion2.Ext)
				{
					//
					// if any ext is missing, or they equal, we are done
					//
					return 0;
				}
				else
				{
					return (stVersion1.Ext < stVersion2.Ext) ? -1 : 1;
				}
			}
		}
	}
}

// ----------------------------------------------------------------------------------
//
// return in pCompareResult:
//		-1: if file ver of 1st parameter < file ver of 2nd parameter
//		 0: if file ver of 1st parameter = file ver of 2nd parameter
//		+1: if file ver of 1st parameter > file ver of 2nd parameter
//
// ----------------------------------------------------------------------------------

static HRESULT CompareFileVersions(LPCTSTR lpsFile1, LPCTSTR lpsFile2, int *pCompareResult)
{

	LOG_block("CompareFileVersion()");

	FILE_VERSION stVer1 = {-1,-1,-1,-1}, stVer2 = {-1,-1,-1,-1};
	if (NULL == lpsFile1 || NULL == lpsFile2 || NULL == pCompareResult)
	{
		LOG_error("E_INVALIDARG");
		return E_INVALIDARG;
	}

	if (!GetFileVersion(lpsFile1, &stVer1))
	{
		LOG_error("E_INVALIDARG");
		return E_INVALIDARG;
	}
	if (!GetFileVersion(lpsFile2, &stVer2))
	{
		LOG_error("E_INVALIDARG");
		return E_INVALIDARG;
	}

	*pCompareResult = CompareVersions(stVer1, stVer2);
	return S_OK;
}

// NTRAID#NTBUG9-218586-2000/11/27-waltw FIX: CDM: Self Update broken by enhanced WFP
//
// Adapted from IUInstallSFPCatalogFile
//
// This function is used during the selfupdate process on systems that use SFP to make
// sure that we can update the engine DLL.
//
#if !(defined(UNICODE) || defined(_UNICODE))
#error This file must be compiled Unicode to insure we get a WCHAR string!
#endif
static HRESULT CDMInstallSFPCatalogFile(LPCWSTR pwszCatalogFile)
{
    LOG_block("IUInstallSFPCatalogFile()");
    HRESULT hr = S_OK;
    HCATADMIN hCatAdmin;
    HCATINFO hCatInfo;
    CATALOG_INFO CatalogInfo;
    DWORD dwSize = 0;
    DWORD dwRet;
	TCHAR wszCatalogFile[MAX_PATH];

    // First Try to Get Pointers to the CryptCAT API's
    PFN_CryptCATAdminAcquireContext fpnCryptCATAdminAcquireContext = NULL;
    PFN_CryptCATAdminAddCatalog fpnCryptCATAdminAddCatalog = NULL;
    PFN_CryptCATCatalogInfoFromContext fpnCryptCATCatalogInfoFromContext = NULL;
    PFN_CryptCATAdminReleaseCatalogContext fpnCryptCATAdminReleaseCatalogContext = NULL;
    PFN_CryptCATAdminReleaseContext fpnCryptCATAdminReleaseContext = NULL;

    HMODULE hMSCat32 = LoadLibrary(MSCAT32DLL);
    if (NULL == hMSCat32)
    {
        // This is Whistler only code - we require mscat32
        hr = E_FAIL;
        goto CleanUp;
    }

    fpnCryptCATAdminAcquireContext = (PFN_CryptCATAdminAcquireContext) GetProcAddress(hMSCat32, "CryptCATAdminAcquireContext");
    fpnCryptCATAdminAddCatalog = (PFN_CryptCATAdminAddCatalog) GetProcAddress(hMSCat32, "CryptCATAdminAddCatalog");
    fpnCryptCATCatalogInfoFromContext = (PFN_CryptCATCatalogInfoFromContext) GetProcAddress(hMSCat32, "CryptCATCatalogInfoFromContext");
    fpnCryptCATAdminReleaseCatalogContext = (PFN_CryptCATAdminReleaseCatalogContext) GetProcAddress(hMSCat32, "CryptCATAdminReleaseCatalogContext");
    fpnCryptCATAdminReleaseContext = (PFN_CryptCATAdminReleaseContext) GetProcAddress(hMSCat32, "CryptCATAdminReleaseContext");

    if ((NULL == fpnCryptCATAdminAcquireContext) ||
        (NULL == fpnCryptCATAdminAddCatalog) ||
        (NULL == fpnCryptCATCatalogInfoFromContext) ||
        (NULL == fpnCryptCATAdminReleaseCatalogContext) ||
        (NULL == fpnCryptCATAdminReleaseContext))
    {
        LOG_error("Some CryptCAT API's were not available, even though mscat32.dll was Available");
        hr = E_FAIL;
        goto CleanUp;
    }

    if (!fpnCryptCATAdminAcquireContext(&hCatAdmin, NULL, 0))
    {
        dwRet = GetLastError();
        LOG_error("CryptCATAdminAcquireContext Failed, Error was: %d", dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

	//
	// CryptCATAdminAddCatalog takes a non-const string so be safe
	//
	lstrcpy(wszCatalogFile, pwszCatalogFile);

    hCatInfo = fpnCryptCATAdminAddCatalog(hCatAdmin, wszCatalogFile, NULL, 0);
    if (!hCatInfo)
    {
        dwRet = GetLastError();
        LOG_error("CryptCATAdminAddCatalog Failed, Error was: %d", dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        fpnCryptCATAdminReleaseContext(hCatAdmin, 0);
        goto CleanUp;
    }

    fpnCryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);

    fpnCryptCATAdminReleaseContext(hCatAdmin, 0);

CleanUp:

    if (NULL != hMSCat32)
    {
        FreeLibrary(hMSCat32);
        hMSCat32 = NULL;
    }
    return hr;
}

//=======================================================================
//
// called by DownloadIsInternetAvailable()
//
//=======================================================================

//Returns the number of dial up networking connections that this client has created.
int GetDUNConnections(
	void
) {
    RASENTRYNAME    rname;
    rname.dwSize = sizeof(RASENTRYNAME);

    DWORD dwSize = sizeof(rname);
    DWORD dwEntries = 0;
    RasEnumEntries(NULL, NULL, &rname, &dwSize, &dwEntries);

    return dwSize/sizeof(RASENTRYNAME);
}


//HKEY_CURRENT_USER\Software\Microsoft\Internet Connection Wizard - Completed == 01 00 00 00

//Determines if the internet connection Wizzard has been completed.

bool IsInternetConnectionWizardCompleted(
	void
) {
    auto_hkey hKey;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Internet Connection Wizard"), 0, KEY_READ, &hKey) != NO_ERROR)
        return false;

    DWORD dwValue = 0;
    DWORD dwSize = sizeof(dwValue);
    return NO_ERROR == RegQueryValueEx(hKey, _T("Completed"), NULL, NULL, (PBYTE)&dwValue, &dwSize) && 1 == dwValue;
}

//Determines if the Internet is already connected to this client.
bool IsInternetConnected(
	void
) {
    DWORD dwFlags = INTERNET_CONNECTION_LAN | INTERNET_CONNECTION_PROXY | INTERNET_CONNECTION_MODEM;
    return InternetGetConnectedState(&dwFlags, 0) ? true : false;
}

//=======================================================================
//
// called by OpenCDMContext()
//
//=======================================================================

// security verification
bool ProcessIdent(
	IN CDownload& download, 
	IN CDiamond& diamond,			//pointer to diamond compress clas to use to expand ident.cab
	IN LPCTSTR szSecurityServerCur,
	OUT LPTSTR szSiteSever,	//returned description server to use.
	OUT LPTSTR szDownloadServer		//returned cab pool download server to use.
) {
	LOG_block("ProcessIdent");

	//We need to download ident.cab since it contains the server path
	//for cdm.dll and the catalog to use to get the cdm.dll from.

	TCHAR szIdentCab[MAX_PATH+1];
	GetWindowsUpdateDirectory(szIdentCab);
	PathAppend(szIdentCab, _T("identcdm.cab"));

	if (!download.Copy(_T("identcdm.cab"), szIdentCab))
	{
		LOG_error("Failed to download identcdm.cab");
		return false;
	}
#ifdef _WUV3TEST
	//
	// For test builds, it is ok to show certificate if WinTrustUI reg key == 1
	// (see CheckWinTrust in newtrust.cpp for details)
	//
	if (FAILED(VerifyFile(szIdentCab, TRUE)))
#else
	if (FAILED(VerifyFile(szIdentCab, FALSE)))
#endif
	{
		LOG_error("signature verification failed");
		DeleteFile(szIdentCab);
		SetLastError(ERROR_ACCESS_DENIED);
		return false;
	}

	if (!diamond.IsValidCAB(szIdentCab))
	{
		LOG_error("'%s' is not a valid cab", szIdentCab);
		return false;
	}

	TCHAR szIdentIni[MAX_PATH];
	GetWindowsUpdateDirectory(szIdentIni);
	PathAppend(szIdentIni, _T("identcdm.ini"));
	DeleteFile(szIdentIni);

	byte_buffer bufMemOut;
	if (!diamond.Decompress(szIdentCab, szIdentIni))
	{
		LOG_error("'%s' is not a valid cab", szIdentCab);
		return false;
	}

	TCHAR szSecurityServer[MAX_PATH];
	if (0 == GetPrivateProfileString(
		_T("cdm"), _T("SecurityServer"), _T(""), szSecurityServer, sizeOfArray(szSecurityServer), szIdentIni
	)) {
		LOG_error("GetPrivateProfileString(cdm, SecurityServer) failed");
		return false;
	}

	//If this ident.cab did not come from the same server in the ident.cab then it
	//is invalid and we cannot download any drivers.
	if (0 != lstrcmpi(szSecurityServer, szSecurityServerCur))
	{
		LOG_error("SecurityServer '%s' is invalid", szSecurityServer);
		return false;
	}
	//
	// szSiteServer and szDownloadServer are allocated MAX_PATH characters by caller.
	//
	if (0 == GetPrivateProfileString(
		_T("cdm"), _T("SiteServer"), _T(""), szSiteSever, MAX_PATH, szIdentIni
	)) {
		LOG_error("GetPrivateProfileString(cdm, SiteSever) failed");
		return false;
	}

	if (0 == GetPrivateProfileString(
		_T("cdm"), _T("DownloadServer"), _T(""), szDownloadServer, MAX_PATH, szIdentIni
	)) {
		LOG_error("GetPrivateProfileString(cdm, DownloadServer) failed");
		return false;
	}
	return true;
}

// get new cdm.cab for potential update
bool DownloadCdmCab(
	IN CDownload& download, 
	IN CDiamond& diamond,
	OUT bool& fNeedUpdate	// initialized to false by caller
) {
	LOG_block("DownloadCdmCab");

	bool fIsIUCab = false;

	#ifdef _WIN64
		static const TCHAR szCabNameServer[] = _T("cdm64.cab");
		static const TCHAR szIUCabNameServer[] = _T("iucdm64.cab");
	#else
		static const TCHAR szCabNameServer[] = _T("cdm32.cab");
		static const TCHAR szIUCabNameServer[] = _T("iucdm32.cab");
	#endif

	TCHAR szWUDir[MAX_PATH];
	GetWindowsUpdateDirectory(szWUDir);

	//
	// First, try to get the IU cab, but don't bail if it isn't there
	//
	TCHAR szCabNameLocal[MAX_PATH];
	PathCombine(szCabNameLocal, szWUDir, szIUCabNameServer);

	if (download.Copy(szIUCabNameServer, szCabNameLocal))
	{
		fIsIUCab = true;
	}
	else
	{
		//
		// It wasn't on the server or we didn't get it, go get the V3 version
		//
		LOG_out("download.Copy(%s) failed, try %s", szIUCabNameServer, szCabNameServer);

		PathCombine(szCabNameLocal, szWUDir, szCabNameServer);

		if (!download.Copy(szCabNameServer, szCabNameLocal))
		{
			LOG_out("download.Copy(%s) failed", szCabNameServer);
			return false;
		}
		
		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			LOG_out("%s is good enough", szCabNameLocal);
			return true;
		}
	}

	//
	// We got a cab, decompress to get cdm.dll and cdm.cat
	//
	if (!diamond.Decompress(szCabNameLocal, _T("*")))
	{
		LOG_error("Decompress '%s' failed", szCabNameLocal);
		// maybe it was a bogus cab - nuke the cab from our local dir
		DeleteFile(szCabNameLocal);
		return false;
	}

	TCHAR szSysDir[MAX_PATH];
	if (0 == GetSystemDirectory(szSysDir, MAX_PATH))
	{
		LOG_error("GetSystemDirectory: 0x%08x", GetLastError());
		return false;
	}

	TCHAR szCurrentCdmDll[MAX_PATH];
	PathCombine(szCurrentCdmDll, szSysDir, CDMDLL);

	TCHAR szDownloadedCdmDll[MAX_PATH];
	PathCombine(szDownloadedCdmDll, szWUDir, CDMDLL);
	
	TCHAR szLocalCatPath[MAX_PATH];
    PathCombine(szLocalCatPath, szWUDir, CDMCAT);

	HRESULT hr;
	//
	// If cab isn't IU version of CDM check version
	//
	if (!fIsIUCab)
	{
		// NTRAID#NTBUG9-207976-2000/11/28-waltw Check version info and only update if downloaded
		//	cdm.dll has a version > the existing cdm.dll.
		int nCompareResult;
		if FAILED(hr = CompareFileVersions(szDownloadedCdmDll, szCurrentCdmDll, &nCompareResult))
		{
			LOG_error("CompareFileVersions: 0x%08x", hr);
			return false;
		}

		if (0 >= nCompareResult)
		{
			LOG_error("Downloaded cdm.dll was smaller version than existing cdm.dll in system[32] folder");
			//
			// Clean up - they are the wrong version. No further action needed so return true.
			//
			DeleteFile(szDownloadedCdmDll);
			DeleteFile(szLocalCatPath);
			return true;
		}
	}

	// NTRAID#NTBUG9-218586-2000/11/27-waltw FIX: CDM: Self Update broken by enhanced WFP
	// Now we 'should' have two files from the cdmXx.cab in the WindowsUpdate Folder
    // One is the CDM.DLL, the other is the Catalog File CDM.CAT so
    // we can install the DLL on Whistler (a SystemFileProtected/WFP OS).
    hr = CDMInstallSFPCatalogFile(szLocalCatPath);
    DeleteFile(szLocalCatPath); // delete the CAT file, once its installed its copied to a new location.
    if (FAILED(hr))
    {
        // Since this is Whistler, we have to bail if we didn't install the catalog since we
		// know that cdm.dll is under SFP/WFP.
		return false;
    }

	/* copy cdm.dll to system directory as iucdm.dll or cdmnew.dll */
	TCHAR szCdmNewDll[MAX_PATH];
	PathCombine(szCdmNewDll, szSysDir, fIsIUCab ? IUCDMDLL : CDMNEWDLL);
	if (!CopyFile(szDownloadedCdmDll, szCdmNewDll, FALSE))
	{
		LOG_error("CopyFile(%s, %s) returns %d", szDownloadedCdmDll, szCdmNewDll, GetLastError());
		return false;
	}
	//
	// Now that it's copied, we can delete from the WU dir.
	//
	DeleteFile(szDownloadedCdmDll);

	//
	// Everything OK, indicate we need to call UpdateCdmDll() from DllMain
	//
	fNeedUpdate = true;

#ifdef _WUV3TEST
	/* Test redirect*/{
		auto_hkey hkey;
		DWORD dwSelfUpdate = 1; // On by default
		DWORD dwSize = sizeof(dwSelfUpdate);
		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
			RegQueryValueEx(hkey, _T("SelfUpdate"), 0, 0, (LPBYTE)&dwSelfUpdate, &dwSize);
		}
		if (0 == dwSelfUpdate)
		{
			LOG_out("New %s Has been downloaded but SELF UPDATE is OFF", szCabNameServer);
			fNeedUpdate = false;
		}
		else
		{
			LOG_out("New %s Has been downloaded", szCabNameServer);
		}
	}
#endif
	return true;
}


//=======================================================================
//
// called by DownloadUpdatedFiles()
//
//=======================================================================

//gets a path to the directory that cdm.dll will copy the install cabs to.
//returns the length of the path.
//Note: The input buffer must be at least MAX_PATH size.

int GetDownloadPath(
	IN LPTSTR szPath	//CDM Local directory where extracted files will be placed.
) {
	if(!GetTempPath(MAX_PATH, szPath))
	{
		lstrcpy(szPath,_T("C:\\temp\\"));
		CreateDirectory(szPath, NULL);
	}

	PathAppend(szPath, _T("CDMinstall"));
	CreateDirectory(szPath, NULL);

	return lstrlen(szPath) + 1;
}


//This function returns the location of the WindowsUpdate directory. All local
//files are store in this directory. The szDir parameter needs to be at least
//MAX_PATH.

void GetWindowsUpdateDirectory(
	OUT LPTSTR szDir		//returned WindowsUpdate directory
) {

	auto_hkey hkey;
	szDir[0] = '\0';
	if (RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"), &hkey) == NO_ERROR)
	{
		DWORD cbPath = _MAX_PATH;
		RegQueryValueEx(hkey, _T("ProgramFilesDir"), NULL, NULL, (LPBYTE)szDir, &cbPath);
	}
	if (szDir[0] == '\0')
	{
		if (! GetWindowsDirectory(szDir, _MAX_PATH))
		{
			lstrcpy(szDir, _T("C"));
		}
		szDir[1] = '\0';
		StrCat(szDir, _T(":\\Program Files"));
	}
	StrCat(szDir, _T("\\WindowsUpdate\\"));

	//Create Windows Update directory if it does not exist
	CreateDirectory(szDir, NULL);
	return;
}

HINSTANCE LoadCdmnewDll()
{
	// If there is cdmnew.dll in system directory use it
	TCHAR szCdmNewDll[MAX_PATH];
	GetSystemDirectory(szCdmNewDll, sizeOfArray(szCdmNewDll));
	PathAppend(szCdmNewDll, CDMNEWDLL);

	if (!FileExists(szCdmNewDll))
		return 0;

	TCHAR szCdmDll[MAX_PATH];
	GetSystemDirectory(szCdmDll, sizeOfArray(szCdmDll));
	PathAppend(szCdmDll, _T("cdm.dll"));

	if (FilesIdentical(szCdmNewDll, szCdmDll))
	{
		LOG_out1("remove cdmnew.dll after selfupdate");
		DeleteFile(szCdmNewDll);
		return 0;
	}

	HINSTANCE hlib = 0;
	
#ifdef _WUV3TEST
	auto_hkey hkey;
	DWORD dwSelfUpdate = 1; // On by default
	DWORD dwSize = sizeof(dwSelfUpdate);
	if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
		RegQueryValueEx(hkey, _T("SelfUpdate"), 0, 0, (LPBYTE)&dwSelfUpdate, &dwSize);
	}
	if (0 == dwSelfUpdate)
		LOG_out1("SELF UPDATE is OFF - using current dll");
	else
#endif
		hlib = LoadLibrary(szCdmNewDll);

	return hlib;
}

//=======================================================================
//
// called by GetPackage()
//
//=======================================================================

DWORD PrepareCatalog(
	IN LPCTSTR pszSiteServer,
	IN OUT SHelper& helper
) {
	LOG_block("PrepareCatalog");

	if (NULL != pszSiteServer)
	{
		if (helper.download.Connect(pszSiteServer))
		{
			LOG_out("Connected to SiteServer '%s'", pszSiteServer);
		}
		else
		{
			LOG_error("No connection to SiteServer '%s'",  pszSiteServer);
			return ERROR_GEN_FAILURE;
		}
	}
	if (!helper.diamond.valid()) 
	{
		LOG_error("cannot init diamond");
		return ERROR_GEN_FAILURE;
	}

	// Get system info
	helper.OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&helper.OSVersionInfo);
	SYSTEM_INFO	si;
	GetSystemInfo(&si);
	helper.dwArchitecture = si.wProcessorArchitecture;

	//Get the catalog path, platform e.t. to use
	DWORD dwError = ProcessOsdet(helper);
	if (NO_ERROR != dwError)
		return dwError;

	if (!FindCatalog(helper))
	{
		LOG_error("no catalog");
		dwError = GetLastError();
		if (ERROR_INVALID_FUNCTION == dwError)
			return ERROR_INVALID_FUNCTION;
		else
			return ERROR_FILE_NOT_FOUND;
	}
	BuildExclusionsList(helper);
	return NO_ERROR;
}

// get language and platform ID from osdet.dll
DWORD ProcessOsdet(
	IN OUT	SHelper& helper
) {
	LOG_block("ProcessOsdet");
	

	// give it a correct name
	TCHAR szOsdetDllLocal[MAX_PATH];
	GetWindowsUpdateDirectory(szOsdetDllLocal);
	PathAppend(szOsdetDllLocal, _T("osdet.dll"));

	if (helper.download.IsConnected())
	{
		#ifdef _WIN64
			static const TCHAR szOsdetCabSrv[] = _T("osdet.w64");
		#else
			static const TCHAR szOsdetCabSrv[] = _T("osdet.w32");
		#endif

		// Put it to the WU directory
		TCHAR szOsdetCabLocal[MAX_PATH];
		GetWindowsUpdateDirectory(szOsdetCabLocal);
		PathAppend(szOsdetCabLocal, szOsdetCabSrv);

		if (!helper.download.Copy(szOsdetCabSrv, szOsdetCabLocal))
		{
			DWORD dwError = GetLastError();
			LOG_error("download.Copy(%s) failed %d", szOsdetCabSrv, dwError);
			return dwError;
		}

		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			if (helper.diamond.IsValidCAB(szOsdetCabLocal))
			{
				if (!helper.diamond.Decompress(szOsdetCabLocal, szOsdetDllLocal))
				{
					DWORD dwError = GetLastError();
					LOG_error("Decompress '%s' failed %d", szOsdetCabLocal, dwError);
					return dwError;
				}
			}
			else
			{
				CopyFile(szOsdetCabLocal, szOsdetDllLocal, FALSE);
			}
		}
	}

	auto_hlib hlib = LoadLibrary(szOsdetDllLocal);
	if (!hlib.valid())
	{
		LOG_error("error loading library %s", szOsdetDllLocal);
		return ERROR_INVALID_FUNCTION;
	}

	PFN_V3_GetLangID fpnV3_GetLangID = (PFN_V3_GetLangID)GetProcAddress(hlib, "V3_GetLangID");
	if (NULL == fpnV3_GetLangID)
	{ 
		LOG_error("cannot find function 'V3_GetLangID'");
		return ERROR_CALL_NOT_IMPLEMENTED;
	}
	helper.dwLangID = (*fpnV3_GetLangID)();

	PFN_V3_Detection pfnV3_Detection = (PFN_V3_Detection)GetProcAddress(hlib, "V3_Detection");
	if (NULL == pfnV3_Detection)
	{ 
		LOG_error("cannot find function 'V3_Detection'");
		return ERROR_CALL_NOT_IMPLEMENTED;
	}
	PDWORD pdwPlatformList = 0;	//Detected Platform list.
	int iTotalPlatforms;	//Total number of detected platforms.
	(*pfnV3_Detection)(&pdwPlatformList, &iTotalPlatforms);
	if (NULL != pdwPlatformList)
	{
		helper.enPlatform = (enumV3Platform)pdwPlatformList[0];
		CoTaskMemFree(pdwPlatformList);
	}
	else
	{
		helper.enPlatform = enV3_DefPlat;
	}
	return S_OK;
}

//borrowed from osdet.cpp
static int aton(LPCTSTR ptr)
{
	int i = 0;
	while ('0' <= *ptr && *ptr <= '9')
	{
		i = 10 * i + (int)(*ptr - '0');
		ptr ++;
	}
	return i;
}


//borrowed from osdet.cpp
static WORD CorrectGetACP(void)
{
	WORD wCodePage = 0;
	auto_hkey hkey;
	const TCHAR REGKEY_ACP[]				= _T("ACP");
	const TCHAR REGPATH_CODEPAGE[] = _T("SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage");
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_CODEPAGE, 0, KEY_QUERY_VALUE, &hkey);
	DWORD type;
	TCHAR szCodePage[MAX_PATH];
	DWORD size = sizeof(szCodePage);
	if (NO_ERROR == RegQueryValueEx(hkey, REGKEY_ACP, 0, &type, (BYTE *)szCodePage, &size) &&
		type == REG_SZ) 
	{
		wCodePage = (WORD)aton(szCodePage);
	}
	return wCodePage;
}


//borrowed from osdet.cpp
static WORD CorrectGetOEMCP(void)
{
	WORD wCodePage = 0;
	auto_hkey hkey;
	// Registry keys to determine special OS's and enabled OS's.
	const TCHAR REGPATH_CODEPAGE[] = _T("SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage");
	const TCHAR REGKEY_OEMCP[]		= _T("OEMCP");
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_CODEPAGE, 0, KEY_QUERY_VALUE, &hkey);
	DWORD type;
	TCHAR szCodePage[MAX_PATH];
	DWORD size = sizeof(szCodePage);
	if (NO_ERROR == RegQueryValueEx(hkey, REGKEY_OEMCP, 0, &type, (BYTE *)szCodePage, &size) &&
		type == REG_SZ) 
	{
		wCodePage = (WORD)aton(szCodePage);
	}
	return wCodePage;
}

//borrowed from osdet.cpp
static LANGID MapLangID(LANGID langid)
{

	switch (PRIMARYLANGID(langid))
	{
		case LANG_ARABIC:
			langid = MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA);
			break;

		case LANG_CHINESE:
			if (SUBLANGID(langid) != SUBLANG_CHINESE_TRADITIONAL)
				langid = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
			break;

		case LANG_DUTCH:
			langid = MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH);
			break;

		case LANG_GERMAN:
			langid = MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN);
			break;

		case LANG_ENGLISH:
			if (SUBLANGID(langid) != SUBLANG_ENGLISH_UK)
				langid = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
			break;

		case LANG_FRENCH:
			langid = MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH);
			break;

		case LANG_ITALIAN:
			langid = MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN);
			break;

		case LANG_KOREAN:
			langid = MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN);
			break;

		case LANG_NORWEGIAN:
			langid = MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL);
			break;

		case LANG_PORTUGUESE:
			// We support both SUBLANG_PORTUGUESE and SUBLANG_PORTUGUESE_BRAZILIAN
			break;

		case LANG_SPANISH:
			langid = MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH);
			break;

		case LANG_SWEDISH:
			langid = MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH);
			break;
	};
	return langid;
}


//borrowed from osdet.cpp
static bool FIsNECMachine()
{
	const TCHAR NT5_REGPATH_MACHTYPE[]   = _T("HARDWARE\\DESCRIPTION\\System");
	const TCHAR NT5_REGKEY_MACHTYPE[]    = _T("Identifier");
	const TCHAR REGVAL_MACHTYPE_NEC[]	= _T("NEC PC-98");
	const PC98_KEYBOARD_ID				= 0x0D;

	bool fNEC = false;
	OSVERSIONINFO osverinfo;
	#define	LOOKUP_OEMID(keybdid)     HIBYTE(LOWORD((keybdid)))


	osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osverinfo))
	{
		if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			HKEY hKey;
			DWORD type;
			TCHAR tszMachineType[50];
			DWORD size = sizeof(tszMachineType);

			if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
								 NT5_REGPATH_MACHTYPE,
								 0,
								 KEY_QUERY_VALUE,
								 &hKey) == ERROR_SUCCESS)
			{
				if (RegQueryValueEx(hKey, 
										NT5_REGKEY_MACHTYPE, 
										0, 
										&type,
										(BYTE *)tszMachineType, 
										&size) == ERROR_SUCCESS)
				{
					if (type == REG_SZ)
					{
						if (lstrcmp(tszMachineType, REGVAL_MACHTYPE_NEC) == 0)
						{
							fNEC = true;
						}
					}
				}

				RegCloseKey(hKey);
			}
		}
		else // enOSWin98
		{
			// All NEC machines have NEC keyboards for Win98.  NEC
			// machine detection is based on this.
			if (LOOKUP_OEMID(GetKeyboardType(1)) == PC98_KEYBOARD_ID)
			{
				fNEC = true;
			}
		}
	}
	
	return fNEC;
}


// borrowed from osdet.cpp
// return V3 language ID
DWORD internalV3_GetLangID()
{
	const LANGID LANGID_ENGLISH		= 0x0409;
	const LANGID LANGID_GREEK		= 0x0408;
	const LANGID LANGID_JAPANESE	= 0x0411;
	const WORD CODEPAGE_ARABIC			= 1256;
	const WORD CODEPAGE_HEBREW			= 1255;
	const WORD CODEPAGE_THAI			= 874;
	const WORD CODEPAGE_GREEK_IBM		= 869;

	

	WORD wCodePage = 0;
	LANGID langidCurrent = GetSystemDefaultUILanguage();

	//
	// special handling for languages
	//
	switch (langidCurrent) 
	{
		case LANGID_ENGLISH:

			// enabled langauges
			wCodePage = CorrectGetACP();
			if (CODEPAGE_ARABIC != wCodePage && 
				CODEPAGE_HEBREW != wCodePage && 
				CODEPAGE_THAI != wCodePage)
			{
				wCodePage = 0;
			}
			break;
		
		case LANGID_GREEK:

			// Greek IBM?
			wCodePage = CorrectGetOEMCP();
			if (wCodePage != CODEPAGE_GREEK_IBM)
			{
				// if its not Greek IBM we assume its MS. The language code for Greek MS does not include
				// the code page
				wCodePage = 0;
			}
			break;
		
		case LANGID_JAPANESE:

			if (FIsNECMachine())
			{
				wCodePage = 1;  
			}

			break;
		
		default:

			// map language to the ones we support
			langidCurrent = MapLangID(langidCurrent);	
			break;
	}
	return MAKELONG(langidCurrent, wCodePage);
}

//borrowed from osdet.cpp
//called by V3_Detection
static enumV3Platform DetectClientPlatform(void)
{
	#ifdef _WIN64
		return enV3_Wistler64;
	#else
		return enV3_Wistler;
	#endif
}


//borrowed from osdet.cpp
void internalV3_Detection(
	PINT *ppiPlatformIDs,
	PINT piTotalIDs
	) 
{

	//We use coTaskMemAlloc in order to be compatible with the V3 memory allocator.
	//We don't want the V3 memory exception handling in this dll.

	*ppiPlatformIDs = (PINT)CoTaskMemAlloc(sizeof(INT));
	if ( !*ppiPlatformIDs )
	{
		*piTotalIDs = 0;
	}
	else
	{
#ifdef _WUV3TEST
		auto_hkey hkey;
		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) 
		{
			DWORD dwPlatform = 0;
			DWORD dwSize = sizeof(dwPlatform);
			if (NO_ERROR == RegQueryValueEx(hkey, _T("Platform"), 0, 0, (LPBYTE)&dwPlatform, &dwSize))
			{
				*ppiPlatformIDs[0] = (int)dwPlatform;
				*piTotalIDs = 1;
				return;
			}
		}
#endif
		*ppiPlatformIDs[0] = (int)DetectClientPlatform();
		*piTotalIDs = 1;
	}

}


// get language and platform ID of local machine
// similiar to ProcessOsdet
// not using osdet.dll
// If return is not S_OK, it means this function fails
DWORD ProcessOsdetOffline(
	IN OUT	SHelper& helper
) {
	LOG_block("ProcessOsdetOffline");
	
	LOG_out("Call internalV3_GetLangID()");
	helper.dwLangID = internalV3_GetLangID();
	PINT pdwPlatformList = 0;	//Detected Platform list.
	int iTotalPlatforms;	//Total number of detected platforms.
	LOG_out("Call internalV3_Detection()");
	internalV3_Detection(&pdwPlatformList, &iTotalPlatforms);
	if (NULL != pdwPlatformList)
	{
		helper.enPlatform = (enumV3Platform)pdwPlatformList[0];
		CoTaskMemFree(pdwPlatformList);
	}
	else
	{
		helper.enPlatform = enV3_DefPlat;
	}
	return S_OK;
}

// process excluded puids from catalog.ini
bool BuildExclusionsList(
	IN SHelper& helper
) {
	LOG_block("BuildExclusionsList");

	static const TCHAR szSrvPath[MAX_PATH] = _T("catalog.ini");

	TCHAR szCliPath[MAX_PATH];
	GetWindowsUpdateDirectory(szCliPath);
	PathAppend(szCliPath, szSrvPath);

	if (helper.download.IsConnected())
	{
		if (!helper.download.Copy(szSrvPath, szCliPath))
		{
			LOG_out("catalog.ini is not there");
			return false;
		}
	}
	TCHAR szValue[256];
	if (0 == GetPrivateProfileString(_T("exclude"), _T("puids"), _T(""), szValue, sizeOfArray(szValue), szCliPath))
	{
		LOG_out("nothing is excluded");
		return false;
	}
	LPCTSTR szInt = szValue;
	while(true)
	{
		helper.apuidExclude.push_back(_ttoi(szInt));
		szInt = _tcschr(szInt, ',');
		if (NULL == szInt)
			break;
		szInt ++;
	}
	return true;
}


// for the detected platform helper.enPlatform find catalog that has drivers
bool FindCatalog(
	IN OUT	SHelper& helper
) {
	LOG_block("FindCatalog");
	byte_buffer bufCatList;
	if (!DownloadToBuffer(helper, _T("inventory.cat"), bufCatList))
	{
		LOG_error("Download inventory.cat failed");
		return NULL;
	}
	int cnCatalogs = bufCatList.size() / sizeof(CATALOGLIST);
	PCATALOGLIST pCatalogs = (PCATALOGLIST)(LPBYTE)bufCatList;
	for (int nCatalog = 0; nCatalog < cnCatalogs; nCatalog ++)
	{
		LOG_out("%4d - %6d - %#08X", pCatalogs[nCatalog].dwPlatform, pCatalogs[nCatalog].dwCatPuid, pCatalogs[nCatalog].dwFlags);
		if (pCatalogs[nCatalog].dwPlatform == helper.enPlatform && (pCatalogs[nCatalog].dwFlags & CATLIST_DRIVERSPRESENT))
		{
			helper.puidCatalog = pCatalogs[nCatalog].dwCatPuid;
			LOG_out("catalog is %d", helper.puidCatalog);
			return true;
		}
	}
	LOG_error("catalog is not found");
	return false;
}


static bool IsExcluded(PUID puid, SHelper& helper) 
{
	for (int i = 0; i < helper.apuidExclude.size(); i ++)
	{
		if (helper.apuidExclude[i] == puid)
			return true;
	}
	return false;
}


//Returns NULL if there is not an update for this package or
//the download package's bucket file if there is an update.
bool FindUpdate(
	IN	PDOWNLOADINFO pDownloadInfo,	//download information structure describing package to be read from server
	IN OUT SHelper& helper,
	IN OUT byte_buffer& bufBucket
) {
	LOG_block("FindUpdate");

	USES_CONVERSION;

	// get bitmask
	byte_buffer bufBitmask;
	if (! GetOEMandLocalBitmask(helper, bufBitmask))
	{
		LOG_error("GetOEMandLocalBitmask() failed");
		return false;
	}
	// Get CDM inventory
	TCHAR szPath[MAX_PATH];
	wsprintf(szPath, _T("%d/inventory.cdm"), helper.puidCatalog);

	byte_buffer bufInventory;
	if (!DownloadToBuffer(helper, szPath, bufInventory))
	{
		LOG_error("Dowload inventory failed");
		return false;
	}

	PCDM_HASHTABLE pHashTable = (PCDM_HASHTABLE)(LPBYTE)bufInventory;

	auto_pointer< IDrvInfo > pDrvInfo;
	tchar_buffer bufHardwareIDs;

	// we have two types of calls
	if (pDownloadInfo->lpDeviceInstanceID) 
	{
		if (!CDrvInfoEnum::GetDrvInfo(pDownloadInfo->lpDeviceInstanceID, &pDrvInfo))
		{
			LOG_error("CDrvInfoEnum::GetDrvInfo(%s) failed", pDownloadInfo->lpDeviceInstanceID);
			return false;
		}
	}
	if (NULL != pDownloadInfo->lpHardwareIDs)
	{
		// one hardware id for a package - eather printers or w9x if we cannot find device instance ID
		// if architecture is not the same as current archtecture we need to prefix it
		bufHardwareIDs.resize(lstrlenW(pDownloadInfo->lpHardwareIDs) + 6);
		if (!bufHardwareIDs.valid())
			return false;

		int cnSize = bufHardwareIDs.size();
		ZeroMemory(bufHardwareIDs, cnSize);
		LPTSTR pszHardwareId = bufHardwareIDs;
		if (pDownloadInfo->dwArchitecture != helper.dwArchitecture)
		{
			if (PROCESSOR_ARCHITECTURE_INTEL == pDownloadInfo->dwArchitecture)
			{
				static const TCHAR szIntel[] = PRINT_ENVIRONMENT_INTEL;
				lstrcpy(pszHardwareId, szIntel);
				pszHardwareId += lstrlen(szIntel);
				cnSize -= lstrlen(szIntel);
			}
			else if (PROCESSOR_ARCHITECTURE_ALPHA == pDownloadInfo->dwArchitecture)
			{
				static const TCHAR szAlpha[] = PRINT_ENVIRONMENT_ALPHA;
				lstrcpy(pszHardwareId, szAlpha);
				pszHardwareId += lstrlen(szAlpha);
				cnSize -= lstrlen(szAlpha);
			}
		}
		lstrcpy(pszHardwareId, W2T((LPWSTR)pDownloadInfo->lpHardwareIDs));
	}
	else if (!pDrvInfo.valid() || !pDrvInfo->GetAllHardwareIDs(bufHardwareIDs))
	{
		LOG_error("!pDrvInfo.valid() || !pDrvInfo->GetAllHardwareIDs()");
		return false;
	}

	// Check if we have MatchingDeviceId
	tchar_buffer bufMatchingDeviceId;
	if (pDrvInfo.valid())
		pDrvInfo->GetMatchingDeviceId(bufMatchingDeviceId); // It's OK not to get it

//	#ifdef _WUV3TEST
		if (pDrvInfo.valid() && pDrvInfo->HasDriver())
		{
			if (bufMatchingDeviceId.valid())
				LOG_out("driver installed on MatchingDeviceId %s", (LPCTSTR)bufMatchingDeviceId);
			else
				LOG_error("driver installed, but HWID is not available");
		}
		else
		{
			if (bufMatchingDeviceId.valid())
				LOG_error("driver is not installed, but MatchingDeviceId is %s", (LPCTSTR)bufMatchingDeviceId);
			else
				LOG_out("no driver installed");
		}
//	#endif

	// Updates
	bool fMoreSpecific = true;
	for (LPCTSTR szHardwareId = bufHardwareIDs; fMoreSpecific && *szHardwareId; szHardwareId += lstrlen(szHardwareId) + 1)
	{
		// MatchingDeviceID is the last one to pay attention to
		fMoreSpecific = !bufMatchingDeviceId.valid() || 0 != lstrcmpi(szHardwareId, bufMatchingDeviceId); 
		
		ULONG ulHashIndex = IsInMap(pHashTable, szHardwareId);
		if (-1 == ulHashIndex)
			continue;

		// read bucket file
		TCHAR szPath[MAX_PATH];
		wsprintf(szPath, _T("%d/%d.bkf"), helper.puidCatalog, ulHashIndex);

		if (!DownloadToBuffer(helper, szPath, bufBucket))
		{
			LOG_error("No bucket where it has to be");
			continue;
		}

		FILETIME ftDriverInstalled = {0,0};
		if (!fMoreSpecific)
		{
			// Then it has to have a driver - Matching device ID is set
			if (!pDrvInfo->GetDriverDate(ftDriverInstalled)) 
			{
				LOG_error("!pDrvInfo->GetDriverDate(ftDriverInstalled)");
				return false;
			}
		}		
		DRIVER_MATCH_INFO DriverMatchInfo;
		helper.puid = CDM_FindUpdateInBucket(szHardwareId, fMoreSpecific ? NULL : &ftDriverInstalled, 
			bufBucket, bufBucket.size(), bufBitmask, &helper.DriverMatchInfo);
		if (0 == helper.puid)
			continue;
		if (IsExcluded(helper.puid, helper))
			continue;
	
		return true;
	}
	return false;
}

// delete the whole subtree starting from current directory
bool DeleteNode(LPCTSTR szDir)
{
	LOG_block("Delnode");

	TCHAR szFilePath[MAX_PATH];
	lstrcpy(szFilePath, szDir);
	PathAppend(szFilePath, TEXT("*.*"));

    // Find the first file
    WIN32_FIND_DATA fd;
    auto_hfindfile hFindFile = FindFirstFile(szFilePath, &fd);
    return_if_false(hFindFile.valid());

	do 
	{
		if (
			!lstrcmpi(fd.cFileName, TEXT(".")) ||
			!lstrcmpi(fd.cFileName, TEXT(".."))
		) continue;
		
		// Make our path
		lstrcpy(szFilePath, szDir);
		PathAppend(szFilePath, fd.cFileName);

		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
			(fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
		) {
			SetFileAttributes(szFilePath, FILE_ATTRIBUTE_NORMAL);
		}

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			return_if_false(DeleteNode(szFilePath));
		}
		else 
		{
			return_if_false(DeleteFile(szFilePath));
		}
	} 
	while (FindNextFile(hFindFile, &fd));// Find the next entry
	hFindFile.release();

	return_if_false(RemoveDirectory(szDir));
	return true;
}

void URLPingReport(IN SHelper& helper, IN LPCTSTR pszStatus)
{
	srand((int)GetTickCount());
	
	// build the URL with parameters
	TCHAR szURL[INTERNET_MAX_PATH_LENGTH];
	_stprintf(szURL, _T("ident/wutrack.bin?PUID=%d&PLAT=%d&LOCALE=0x%08x&STATUS=%s&RID=%04x%04x"), 
		helper.puid, helper.enPlatform, helper.dwLangID,
		pszStatus, rand(), rand());

	byte_buffer bufTmp;
	helper.download.Copy(szURL, bufTmp);
}

//=======================================================================
//
// called by InternalQueryDetectionFiles()
//
//=======================================================================

// helper to download to buffer and uncab is nessasary
inline bool FileToBuffer(LPCTSTR szFileName, byte_buffer& buf)
{
	auto_hfile hFile = CreateFile(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hFile.valid()) 
		return false;

	DWORD dwFileSize = GetFileSize(hFile, NULL);
	buf.resize(dwFileSize);
	if (!ReadFile(hFile, buf, dwFileSize, &dwFileSize, NULL))
		return false;

	return true;
}

bool DownloadToBuffer(
	IN SHelper& helper,
	IN LPCTSTR szPath,
	OUT byte_buffer& bufOut
) {
	LOG_block("DownloadToBuffer");

	// copy to local file to have a cached version
	TCHAR szTitle[MAX_PATH];
	lstrcpy(szTitle, szPath);
	PathStripPath(szTitle);
	TCHAR szLocalPath[MAX_PATH];
	GetWindowsUpdateDirectory(szLocalPath);
	PathAppend(szLocalPath, szTitle);

	if (helper.download.IsConnected())
	{
		if (!helper.download.Copy(szPath, szLocalPath))
		{
			LOG_error("download.Copy(%s) failed", szPath);
			return false;
		}
	}
	if (helper.diamond.IsValidCAB(szLocalPath))
	{
		if (!helper.diamond.Decompress(szLocalPath, bufOut))
		{
			LOG_error("diamond.Decompress(%s) failed", szPath);
			return false;
		}
	}
	else
	{
		//else the oem table is in uncompressed format.
		if (!FileToBuffer(szLocalPath, bufOut))
		{
			LOG_error("FileToBuffer(%s) failed", szPath);
			SetLastError(ERROR_INVALID_FUNCTION); //we might not be ready yet
			return false;
		}

	}
	return true;
}

//=======================================================================
//
// called by DllMain()
//
//=======================================================================

bool UpdateCdmDll() 
{
	LOG_block("UpdateCDMDll");

	TCHAR szCurrentDll[MAX_PATH];
	GetSystemDirectory(szCurrentDll, sizeOfArray(szCurrentDll));
	PathAppend(szCurrentDll, CDMDLL);

	TCHAR szIUCdmDll[MAX_PATH];
	GetSystemDirectory(szIUCdmDll, sizeOfArray(szCurrentDll));
	PathAppend(szIUCdmDll, IUCDMDLL);

	TCHAR szCdmNewDll[MAX_PATH];
	GetSystemDirectory(szCdmNewDll, sizeOfArray(szCdmNewDll));
	PathAppend(szCdmNewDll, CDMNEWDLL);

	//To replace DLLs already loaded in memory on NT we can rename the file on
	//disk to a temp name and copy the new dll over the old disk file image. The
	//next time that the dll is loaded it will load the new image.
	//

	TCHAR szOldDll[MAX_PATH];
	lstrcpy(szOldDll, szCurrentDll);
	lstrcat(szOldDll, _T(".old"));
	DeleteFile(szOldDll);

	if (!MoveFile(szCurrentDll, szOldDll))
	{
		LOG_error("MoveFile(%s, %s) returns %d", szCurrentDll, szOldDll, GetLastError());
		return false;
	}

	//
	// If iucdm.dll exists, rename it to cdm.dll, else rename cdmnew.dll to cdm.dll
	//
	if (!MoveFile(FileExists(szIUCdmDll) ? szIUCdmDll : szCdmNewDll, szCurrentDll))
	{
		LOG_error("MoveFile(%s, %s) returns %d", szCdmNewDll, szCurrentDll, GetLastError());
		MoveFile(szOldDll, szCurrentDll); // restore if update fails
		return false;
	}

	return true;
}

//Called by InternalLogDriverNotFound(...)
//ASSUME: only runs in Whislter, not working on lower than W2k
//called by InternalLogDriverNotFound()
//Get SKU information in a string for running OS
//return S_FALSE if no matching information found
//return S_FALSE if buffer not big enough for possible return string
//return E_FAIL if error happens, 
//return S_OK if success and the buffer will contain SKU string
//lpSKUBuffer: IN : buffer to store SKU string. Allocated and freed by caller
//dwSize: IN : size of lpSKUBuffer in bytes
HRESULT GetSKUString(
			   IN LPTSTR lpSKUBuffer,
			   IN DWORD dwSize
)
{
	enumSKU eSKU;
	OSVERSIONINFOEX osverEx;

	LOG_block("GetSKUString");
	ZeroMemory(&osverEx, sizeof(osverEx));
	osverEx.dwOSVersionInfoSize = sizeof(osverEx);
	if (!GetVersionEx((OSVERSIONINFO *) &osverEx))
	{
		LOG_error("GetVersionEx failed");
		return E_FAIL;
	}
	eSKU = SKU_NOT_SPECIFIED;
	if (VER_NT_SERVER == osverEx.wProductType)
	{
		if (osverEx.wSuiteMask & VER_SUITE_DATACENTER)
		{
			eSKU = SKU_DATACENTER_SERVER;
		}
		else
		{
			if (osverEx.wSuiteMask & VER_SUITE_ENTERPRISE)
			{
				eSKU = SKU_ADVANCED_SERVER;
			}
			else 
			{
				eSKU = SKU_SERVER;
			}
		}
	}
	if (VER_NT_WORKSTATION == osverEx.wProductType)
	{
		if (osverEx.wSuiteMask & VER_SUITE_PERSONAL ) 
		{
			eSKU = SKU_PERSONAL;
		}
		else
		{
			eSKU = SKU_PROFESSIONAL;
		}
	}

	if (dwSize < SKU_STRING_MIN_LENGTH)
	{
		LOG_error("buffer not big enough to store SKU information");
		return S_FALSE; //buffer not big enough for possible return string
	}
	switch (eSKU) 
	{
		case SKU_PERSONAL:
		case SKU_PROFESSIONAL:
		case SKU_SERVER:
		case SKU_ADVANCED_SERVER:
		case SKU_DATACENTER_SERVER:
			lstrcpy(lpSKUBuffer, SKU_STRINGS[eSKU]);
			break;
		default: //not specified
			LOG_error("Unrecognized SKU type");
			lstrcpy(lpSKUBuffer, SKU_STRINGS[0]);
			return S_FALSE;
	}
	return S_OK;
	
}


//called by InternalDriverNotFound(...)
//Find a file name not used so far into which hardware xml information will be inserted
//The file name will be in format hardware_xxx.xml where xxx is in range [1..MAX_INDEX_TO_SEARCH]
//The position file found last time is remembered and new search will start from the next position
//Caller is supposed to close handle and delete file
//tszDirPath IN : directory under which to look for unique file name. End with "\"
//lpBuffer IN : allocated and freed by caller. Buffer to store unique file name found
//dwSize IN : size of lpBuffer in bytes
//hFile OUT: store a handle to the opened file
//return S_OK if Unique File Name found 
//return S_FALSE if buffer not big enough to hold unique file name
//return E_FAIL if all qualified file names already taken
HRESULT GetUniqueFileName(
						IN LPTSTR tszDirPath,
						IN LPTSTR lpBuffer, 
						IN DWORD dwSize,
					   OUT HANDLE &hFile
)
{
	TCHAR tszPath[MAX_PATH];
	static DWORD dwFileIndex = 1;
	int nCount = 0;
	const TCHAR FILENAME[] = _T("Hardware_");
	const TCHAR FILEEXT[] = _T("xml");

	LOG_block("GetFileNameGenerator");
	LOG_out("Directory to search unique file names: %s", tszDirPath);
	hFile = NULL;
	do 
	{
		_stprintf(tszPath, _T("%s%s%d.%s"), tszDirPath, FILENAME, dwFileIndex, FILEEXT);
		LOG_out("check existing of %s", tszPath);
		hFile = CreateFile(tszPath, NULL, NULL, NULL, CREATE_NEW, NULL, NULL);
		if (INVALID_HANDLE_VALUE == hFile) 
		{ //file exists
			dwFileIndex ++;
			nCount ++;
			if (dwFileIndex > MAX_INDEX_TO_SEARCH)
			{
				dwFileIndex = 1;
			}
		}
		else 
		{
			break; //first available file name found
		}
	}while(nCount < MAX_INDEX_TO_SEARCH );
	
	if (nCount == MAX_INDEX_TO_SEARCH ) 
	{
		LOG_out("All %d file names have been taken", nCount);
		return E_FAIL;
	}
	_stprintf(tszPath, _T("%s%d.%s"), FILENAME, dwFileIndex, FILEEXT);
	if (dwSize < (_tcslen(tszPath) + 1) * sizeof(TCHAR))
	{
		LOG_out("buffer not big enough to hold unique file name");
		CloseHandle(hFile);
		DeleteFile(tszPath);
		return S_FALSE;
	}
	lstrcpy(lpBuffer, tszPath);
	LOG_out("unique file name %s found", lpBuffer);
	dwFileIndex++; //next time skip file name found this time
	if (dwFileIndex > MAX_INDEX_TO_SEARCH)
	{
		dwFileIndex = 1;
	}
	return S_OK;
}

/*
   Called by InternalLogDriverNotFound(...)
   canonicalize a url
   resize tchBuf if not big enough
   lpszUrl: IN	address of the string that contains the Url to canonicalize
   tchBuf : OUT	buffer that receives the resulting canonicalized URL
   dwLen  : IN  size of the tchBuf
   dwFlags: IN  any flag applicable to InternetCanonicalizeUrl(...)
   Return : S_OK if url canonicalization succeed
			E_FAIL if url canonicalization failed
*/
HRESULT CdmCanonicalizeUrl(
			IN	LPCTSTR lpszUrl,
			OUT tchar_buffer &tchBuf,
			IN	DWORD dwLen,
			IN  DWORD dwFlags)
{
	LOG_block("CdmCanonicalizeUrl");
	BOOL fBufferResized = FALSE;
	while (!InternetCanonicalizeUrl(lpszUrl, (LPTSTR) tchBuf, &dwLen, dwFlags))
	{
		if (fBufferResized || ERROR_INSUFFICIENT_BUFFER != GetLastError())
		{
			LOG_error("InternetCanonicalizeUrl Failed ");
			return E_FAIL;
		}
		else
		{
			LOG_out("buffer resized");
			tchBuf.resize((dwLen+1)); 
			fBufferResized = TRUE;
		}
	}
	return S_OK;
}

//=======================================================================
//
// called internally
//
//=======================================================================

// Check if given PNPID is current hash table mapping.
//if PnpID is in hash table then return index

ULONG IsInMap(
	IN PCDM_HASHTABLE pHashTable,	//hash table to be used to check and see if item is available.
	IN LPCTSTR pHwID		//hardware id to be retrieved
) {
	LOG_block("IsInMap");

	if(NULL != pHwID && 0 != pHwID[0])
	{
		ULONG ulTableEntry = CDM_HwID2Hash(pHwID, pHashTable->hdr.iTableSize);

		if(GETBIT(pHashTable->pData, ulTableEntry))
		{
			LOG_out("%s (hash %d) is found", pHwID, ulTableEntry);
			return ulTableEntry;
		}
		else
		{
			LOG_error("%s (hash %d) is not found", pHwID, ulTableEntry);
		}
	}
	else
	{
		LOG_error("pHwID is empty"); 
	}
	return -1;
}

//This method performs a logical AND operation between an array of bits and a bitmask bit array.
inline void AndBitmasks(
	PBYTE	pBitsResult,	//result array for the AND operation
	PBYTE	pBitMask,		//source array bitmask
	int		iMaskByteSize	//bitmask size in bytes
) {
	for(int i=0; i<iMaskByteSize; i++)
		pBitsResult[i] &= pBitMask[i];
}

bool GetOEMandLocalBitmask(
	IN SHelper& helper,
	OUT byte_buffer& bufOut
) {
	LOG_block("GetOEMandLocalBitmask");

	TCHAR szPath[MAX_PATH];
	wsprintf(szPath, _T("%d/bitmask.cdm"), helper.puidCatalog);

	byte_buffer bufBitmask;
	if (!DownloadToBuffer(helper, szPath, bufBitmask))
		return false;

	PBITMASK pMask = (PBITMASK)(LPBYTE)bufBitmask;
	int iMaskByteSize = (pMask->iRecordSize+7)/8;

	bufOut.resize(iMaskByteSize);
	if (!bufOut.valid())
		return false;
	memset(bufOut, 0xFF, iMaskByteSize);

	// Initial inventory
//	AndBitmasks(bufOut, pMask->GetBitMaskPtr(BITMASK_GLOBAL_INDEX), iMaskByteSize);

	//AND in OEM bitmask, we pick first hit since bitmasks are returned
	//from most specific to least specific.
	int nCurrentOEM = pMask->iOemCount; // out of range value
	{
		byte_buffer bufOEM;
		if (!DownloadToBuffer(helper, _T("oeminfo.bin"), bufOEM))
			return false;

		DWORD dwOemId = GetMachinePnPID(bufOEM);

		if (0 != dwOemId)
		{
			for (int nOEM = 0; nOEM < pMask->iOemCount; nOEM++)
			{
				if (dwOemId == pMask->bmID[nOEM])
					break;
			}
			nCurrentOEM = nOEM;
		}
	}
	int nBitmapIndex = (pMask->iOemCount == nCurrentOEM 
		? BITMASK_OEM_DEFAULT	// if we did not find an OEM bitmask specific to this client then use the default OEM mask.
		: nCurrentOEM+2			// bitmask is offset from GLOBAL and DEFAULT bitmasks
	);
	AndBitmasks(bufOut, pMask->GetBitMaskPtr(nBitmapIndex), iMaskByteSize);

	//And in LOCALE bitmask
	for(int iLocal = 0;  iLocal < pMask->iLocaleCount; iLocal++)
	{
		if (pMask->bmID[pMask->iOemCount+iLocal] == helper.dwLangID)
		{
			//We need to add in the oem count to get to the first local
			AndBitmasks(bufOut, pMask->GetBitMaskPtr(pMask->iOemCount+iLocal+2), iMaskByteSize);
			return true;
		}
	}
	LOG_error("language %08X is not found", helper.dwLangID);
	return false; //locale is not found
}


/////////////////////////////////////////////////////////////////////////////////
// Variable field functions
/////////////////////////////////////////////////////////////////////////////////

//The GetNext function returns a pointer to the next variable array item in a
//variable chain. If the next variable item does not exit then this method
//return NULL.

PWU_VARIABLE_FIELD WU_VARIABLE_FIELD::GetNext(
	void
) {
	PWU_VARIABLE_FIELD	pv;

	//walk though the varaible field array associated with this data item
	//and return the requested item or NULL if the item is not found.
	pv = this;
	if (pv->id == WU_VARIABLE_END)
		return NULL;

	pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);

	return pv;
}

//find a variable item in a variable item chain.
PWU_VARIABLE_FIELD WU_VARIABLE_FIELD::Find(
	short id	//id of variable size field to search for in the variable size chain.
) {
	LOG_block("WU_VARIABLE_FIELD::Find");

	PWU_VARIABLE_FIELD	pv;

	//walk though the varaible field array associated with this data item
	//and return the requested item or NULL if the item is not found.
	pv = this;

	//If this variable record only contains an end record then we
	//need to handle it specially since the normal find loop
	//updates the pv pointer before the end check is made so if
	//end is the first field it can be missed.

	if (pv->id == WU_VARIABLE_END)
		return (id == WU_VARIABLE_END) ? pv : (PWU_VARIABLE_FIELD)NULL;

	do
	{
		if (pv->id == id)
			return pv;
		pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);
	} while(pv->id != WU_VARIABLE_END);
 
	//case where caller asked to search for the WU_VARIABLE_END field
	if (pv->id == id)
		return pv;

	return (PWU_VARIABLE_FIELD)NULL;
}

//Variable size field constructor.

WU_VARIABLE_FIELD::WU_VARIABLE_FIELD(
	void
) {
	id = WU_VARIABLE_END;
	len = sizeof(id) + sizeof(len);
}

//returns the total size of a variable field
int WU_VARIABLE_FIELD::GetSize(
	void
) {
	PWU_VARIABLE_FIELD	pv;
	int					iSize;

	iSize = 0;
	pv = this;

	while(pv->id != WU_VARIABLE_END)
	{
		iSize += pv->len;
		pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);
	}

	iSize += pv->len;

	return iSize;
}

static bool FilesIdentical(
	IN LPCTSTR szFileName1, 
	IN LPCTSTR szFileName2
) {
	auto_hfile hFile1 = CreateFile(szFileName1, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hFile1.valid())
		return false;
	auto_hfile hFile2 = CreateFile(szFileName2, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hFile2.valid())
		return false;
	if(GetFileSize(hFile1, NULL) != GetFileSize(hFile2, NULL))
		return false;
	FILETIME ft1;
	if (!GetFileTime(hFile1, NULL, NULL, &ft1))
		return false;

	FILETIME ft2;
	if (!GetFileTime(hFile2, NULL, NULL, &ft2))
		return false;

	return CompareFileTime(&ft1, &ft2) == 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdm\cdmp.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmp.helper
//
//  Owner:  YanL
//
//  Description:
//
//      CDM internal header
//
//=======================================================================

#ifndef _CDMP_H

	#define SZ_SECURITY_SERVER	_T("http://windowsupdate.microsoft.com/v3content")
	#define REGKEY_WUV3TEST		_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test")

	#define MAX_INDEX_TO_SEARCH 100 //range to find unique file names for hardware_XXX.xml

	typedef enum tagSKU {
			SKU_NOT_SPECIFIED = 0,
			SKU_PERSONAL = 1,
			SKU_PROFESSIONAL = 2,
			SKU_SERVER = 3,
			SKU_ADVANCED_SERVER = 4,
			SKU_DATACENTER_SERVER = 5
	} enumSKU;

	const LPCTSTR SKU_STRINGS[]={
		_T("Unknown"),
		_T("Personal"),
		_T("Professional"),
		_T("Server"),
		_T("AdvancedServer"),
		_T("DataCenter")
	};

	//17 is the length of string "DataCenterServer" + 1
	const int SKU_STRING_MIN_LENGTH = 17 * sizeof(TCHAR); 
	const int SKU_STRING_MAX_LENGTH = 100; 

	struct SHelper
	{
		CDownload download;
		CDiamond diamond;
		OSVERSIONINFO OSVersionInfo;    // current OSVERSIONINFO from GetVersionEx()
		DWORD dwArchitecture;			// Specifies the system's processor architecture.
		DWORD dwLangID;
		enumV3Platform enPlatform;
		PUID puid;
		PUID puidCatalog;
		vector<PUID> apuidExclude;
		byte_buffer bufBucket;			// we need to keep it to have information in DRIVER_MATCH_INFO valid
		DRIVER_MATCH_INFO DriverMatchInfo;
	};



	
	

	#pragma pack()

	// called by DownloadIsInternetAvailable()
	int GetDUNConnections(void);
	bool IsInternetConnectionWizardCompleted(void);
	bool IsInternetConnected(void);
	
	// called by DownloadGetUpdatedFiles()
	bool FindDevInstID(IN LPCSTR szHardwareID, string& sDevInstID);

	// called by RealDownloadGetUpdatedFiles()
	bool IsWindowsNT(void);

	// called by OpenCDMContext()
	bool ProcessIdent(IN CDownload& download, IN CDiamond& diamond, 
		IN LPCTSTR szSecurityServerCur, OUT LPTSTR szSiteServer, OUT LPTSTR szDownloadServer);
	bool DownloadCdmCab(IN CDownload& download, IN CDiamond& diamond, OUT bool& fNeedUpdate);

	// called by DownloadUpdatedFiles()
	int GetDownloadPath(OUT LPTSTR szPath);
	void GetWindowsUpdateDirectory(IN LPTSTR szDir);
	HINSTANCE LoadCdmnewDll();

	// called by GetPackage()
	DWORD PrepareCatalog(IN LPCTSTR pszSiteServer, IN OUT SHelper& helper);
	DWORD ProcessOsdet(IN OUT SHelper& helper);	
	bool BuildExclusionsList(IN SHelper& helper);
	bool FindCatalog(IN OUT	SHelper& helper);
	bool FindUpdate(
		IN PDOWNLOADINFO pDownLoadInfo, 
		IN OUT SHelper& helper,
		IN OUT byte_buffer& bufBucket
	);
	bool DeleteNode(LPCTSTR szDir);

	// called by InternalQueryDetectionFiles()
	bool DownloadToBuffer(IN SHelper& helper, IN LPCTSTR szPath, OUT byte_buffer& bufOut);

	#define URLPING_FAILED		_T("DLOAD_FAILURE")
	#define URLPING_SUCCESS		_T("DLOAD_SUCCESS")
	void URLPingReport(IN SHelper& helper, IN LPCTSTR pszStatus);

	// called by DllMain
 	bool UpdateCdmDll();

	//called by InternalLogDriverNotFound()
	HRESULT GetUniqueFileName(
				IN LPTSTR tszDirPath,
				IN LPTSTR lpBuffer, 
				IN DWORD dwSize,
				OUT HANDLE &hFile
	);

	HRESULT GetSKUString(
				IN LPTSTR lpSKUBuffer,
				IN DWORD dwSize
	);

	DWORD ProcessOsdetOffline(
				IN OUT SHelper& helper
	);	

	HRESULT CdmCanonicalizeUrl(
				IN	LPCTSTR lpszUrl,
				OUT tchar_buffer &tchBuf,
				IN	DWORD dwLen,
				IN  DWORD dwFlags
	);

	#define _CDMP_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdm\cdmau\cdmau.cpp ===
#include <iostream>
using namespace std;

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>
#include <setupapi.h>
#include <objbase.h>
#include <shlwapi.h>
#include <wustl.h>
#include <download.h>

#include "..\cdm.h"

void usage();
void SimulateAU();
void FindUpdate(PDOWNLOADINFO pinfo);
void DownloadUpdate(PDOWNLOADINFO pinfo);

void __cdecl main(int argc, char *argv[])
{
	DOWNLOADINFO info;
	ZeroMemory(&info, sizeof(info));
	info.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
	info.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;

	if ( 2 == argc && 0 == lstrcmpi(argv[1], "SimulateAU") )
	{
		SimulateAU();
	}
	else if ( 4 == argc && 0 == lstrcmpi(argv[1], "FindUpdate") && 0 == lstrcmpi(argv[2], "devinst") )
	{
		WCHAR wszParam[2048];
		MultiByteToWideChar(CP_ACP, 0, argv[3], -1, wszParam, 2048);
		info.lpDeviceInstanceID = wszParam;
		FindUpdate(&info);
	}
	else if ( 4 == argc && 0 == lstrcmpi(argv[1], "FindUpdate") && 0 == lstrcmpi(argv[2], "hwid") )
	{
		WCHAR wszParam[2048];
		MultiByteToWideChar(CP_ACP, 0, argv[3], -1, wszParam, 2048);
		info.lpHardwareIDs = wszParam;
		FindUpdate(&info);
	}
	else if ( 4 == argc && 0 == lstrcmpi(argv[1], "DownloadUpdate") && 0 == lstrcmpi(argv[2], "devinst") )
	{
		WCHAR wszParam[2048];
		MultiByteToWideChar(CP_ACP, 0, argv[3], -1, wszParam, 2048);
		info.lpDeviceInstanceID = wszParam;
		DownloadUpdate(&info);
	}
	else if ( 4 == argc && 0 == lstrcmpi(argv[1], "DownloadUpdate") && 0 == lstrcmpi(argv[2], "hwid") )
	{
		WCHAR wszParam[2048];
		MultiByteToWideChar(CP_ACP, 0, argv[3], -1, wszParam, 2048);
		info.lpHardwareIDs = wszParam;
		DownloadUpdate(&info);
	}
	else
	{
		usage();
	}
}

void usage()
{
	cout << "usage:" << endl
		<< "	CdmAu SimulateAU" << endl
		<< "	CdmAu FindUpdate devinst [DevInst  ID]" << endl
		<< "	CdmAu FindUpdate hwid [Hardware ID]" << endl
		<< "	CdmAu DownloadUpdate devinst [DevInst  ID]" << endl
		<< "	CdmAu DownloadUpdate hwid [Hardware ID]" << endl;
}

void QueryDetectionFilesCallback( void* pCallbackParam, LPCSTR pszURL, LPCSTR pszLocalFile)
{
	printf("		%s - %s\n", pszURL, pszLocalFile);
	// download file
	CDownload download;

	char szURL[INTERNET_MAX_PATH_LENGTH];
	strcpy(szURL, pszURL);
	char* pszServerFile = strrchr(szURL, '/');
	*pszServerFile = 0;
	pszServerFile ++;

	char szDir[MAX_PATH];
	strcpy(szDir, pszLocalFile);
	*strrchr(szDir, '\\') = 0;

	char szDirCabs[MAX_PATH];
	strcpy(szDirCabs, szDir);
	*strrchr(szDirCabs, '\\') = 0;

	CreateDirectory(szDirCabs, NULL);
	CreateDirectory(szDir, NULL);

	if(!download.Connect(szURL))
	{
		printf("	ERROR - Connect(%s) fails\n", szURL);
		return;
	}
	if(!download.Copy(pszServerFile, pszLocalFile))
	{
		printf("	ERROR - Copy(%s, %s) fails\n", pszServerFile, pszLocalFile);
		return;
	}
}

void SimulateAU()
{
	cout << "--- SimulateAU ---" << endl;
	auto_hlib hlib = LoadLibrary("cdm.dll");
	if ( !hlib.valid() )
	{
		cout << "	ERROR: cdm.dll Load Library Failed. Return value = " << GetLastError() << endl;
		return;
	}
	OPEN_CDM_CONTEXT_EX_PROC fpOpenCDMContextEx	= (OPEN_CDM_CONTEXT_EX_PROC)GetProcAddress(hlib, "OpenCDMContextEx");
	QUERY_DETECTION_FILES_PROC fpQueryDetectionFiles	= (QUERY_DETECTION_FILES_PROC)GetProcAddress(hlib, "QueryDetectionFiles");
	DET_FILES_DOWNLOADED_PROC fpDetFilesDownloaded	= (DET_FILES_DOWNLOADED_PROC)GetProcAddress(hlib, "DetFilesDownloaded");
	CLOSE_CDM_CONTEXT_PROC fpCloseCDMContext	= (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hlib, "CloseCDMContext");
	if ( !fpOpenCDMContextEx || !fpQueryDetectionFiles || !fpDetFilesDownloaded || !fpCloseCDMContext )
	{
		cout << "	ERROR: GetProcAddress failed." << endl;
		return;
	}
	HANDLE handle = (fpOpenCDMContextEx)(TRUE);
	if ( !handle )
	{
		cout << "	ERROR: OpenCDMContextEx failed. GetLastError = "<< GetLastError() << endl;
		return;
	}
	int nCount = (*fpQueryDetectionFiles)(handle, 0, QueryDetectionFilesCallback);
	(fpDetFilesDownloaded)(handle);
	(fpCloseCDMContext)(handle);
	if (-1 == nCount)
		cout << "	ERROR: QueryDetectionFiles failed. GetLastError = "<< GetLastError() << endl;
	else
		cout << "	SUCCESS: " << nCount << " files downloaded, ready for offline detection" << endl;

}

void FindUpdate(PDOWNLOADINFO pinfo)
{
	cout << "--- FindUpdate ---" << endl;
	auto_hlib hlib = LoadLibrary("cdm.dll");
	if ( !hlib.valid() )
	{
		cout << "	ERROR: cdm.dll Load Library Failed. Return value = " << GetLastError() << endl;
		return;
	}

	OPEN_CDM_CONTEXT_EX_PROC fpOpenCDMContextEx	= (OPEN_CDM_CONTEXT_EX_PROC)GetProcAddress(hlib, "OpenCDMContextEx");
	FIND_MATCHING_DRIVER_PROC fpFindMatchingDriver	= (FIND_MATCHING_DRIVER_PROC)GetProcAddress(hlib, "FindMatchingDriver");
	CLOSE_CDM_CONTEXT_PROC fpCloseCDMContext	= (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hlib, "CloseCDMContext");
	if ( !fpOpenCDMContextEx|| !fpFindMatchingDriver || !fpCloseCDMContext )
	{
		cout << "	ERROR: GetProcAddress failed." << endl;
		return;
	}

	HANDLE handle = (fpOpenCDMContextEx)(FALSE);
	if ( !handle )
	{
		cout << "	ERROR: OpenCDMContextEx failed. GetLastError = "<< GetLastError() << endl;
		return;
	}

	WUDRIVERINFO wudrvinfo;
	BOOL fRC = (*fpFindMatchingDriver)(handle, pinfo, &wudrvinfo);
	DWORD dwError = GetLastError();
	(fpCloseCDMContext)(handle);
	if (!fRC)
	{
		if (dwError == ERROR_INVALID_FUNCTION)
			cout << "	Not ready for offline detection " << endl;
		else
			cout << "	No update is found. GetLastError = "<< dwError << endl;
		return;
	}
	cout << "	SUCCESS: CDM has driver" << endl;
	char szTmp[HWID_LEN];
	WideCharToMultiByte(CP_ACP, 0, wudrvinfo.wszHardwareID, -1, szTmp, sizeof(szTmp), NULL, NULL);
	cout << "	   HardwareID = " << szTmp << endl;
	WideCharToMultiByte(CP_ACP, 0, wudrvinfo.wszDescription, -1, szTmp, sizeof(szTmp), NULL, NULL);
	cout << "	   Description = " << szTmp << endl;
	WideCharToMultiByte(CP_ACP, 0, wudrvinfo.wszMfgName, -1, szTmp, sizeof(szTmp), NULL, NULL);
	cout << "	   MfgName = " << szTmp << endl;
	WideCharToMultiByte(CP_ACP, 0, wudrvinfo.wszProviderName, -1, szTmp, sizeof(szTmp), NULL, NULL);
	cout << "	   ProviderName = " << szTmp << endl;
	WideCharToMultiByte(CP_ACP, 0, wudrvinfo.wszDriverVer, -1, szTmp, sizeof(szTmp), NULL, NULL);
	cout << "	   DriverVer = " << szTmp << endl;
}

void DownloadUpdate(PDOWNLOADINFO pinfo)
{
	cout << "--- DownloadUpdate ---" << endl;
	auto_hlib hlib = LoadLibrary("cdm.dll");
	if ( !hlib.valid() )
	{
		cout << "	ERROR: cdm.dll Load Library Failed. Return value = " << GetLastError() << endl;
		return;
	}

	OPEN_CDM_CONTEXT_EX_PROC fpOpenCDMContextEx	= (OPEN_CDM_CONTEXT_EX_PROC)GetProcAddress(hlib, "OpenCDMContextEx");
	DOWNLOAD_UPDATED_FILES_PROC fpDownloadUpdatedFiles	= (DOWNLOAD_UPDATED_FILES_PROC)GetProcAddress(hlib, "DownloadUpdatedFiles");
	CLOSE_CDM_CONTEXT_PROC fpCloseCDMContext	= (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hlib, "CloseCDMContext");
	if ( !fpOpenCDMContextEx|| !fpDownloadUpdatedFiles || !fpCloseCDMContext )
	{
		cout << "	ERROR: GetProcAddress failed." << endl;
		return;
	}

	HANDLE handle = (fpOpenCDMContextEx)(TRUE);
	if ( !handle )
	{
		cout << "	ERROR: OpenCDMContextEx failed. GetLastError = "<< GetLastError() << endl;
		return;
	}

	UINT uRequired;
	WCHAR wszPath[MAX_PATH];
	BOOL fRC = (fpDownloadUpdatedFiles)(handle, NULL, pinfo, wszPath, MAX_PATH, &uRequired);
	DWORD dwError = GetLastError();
	(fpCloseCDMContext)(handle);
	if (!fRC)
	{
		cout << "	ERROR: DownloadUpdatedFiles failed. GetLastError = "<< dwError << endl;
		return;
	}
	char szPath[MAX_PATH];
	WideCharToMultiByte(CP_ACP, 0, wszPath, -1, szPath, sizeof(szPath), NULL, NULL);
	cout << "SUCCESS:Downloaded Driver Files @ " << szPath << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdm\testcdm\testcdm.cpp ===
#include <iostream>
using namespace std;

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdarg.h>

#include <setupapi.h>
#include <cdm.h>

//
// Compile #if 0 for LogDriverNotFound test and #if 1 for original code
//
#if 1
//Win 98 DOWNLOADINFO
typedef struct _DOWNLOADINFOWIN98
{
	DWORD		dwDownloadInfoSize;	//size of this structure
	LPTSTR		lpHardwareIDs;		//multi_sz list of Hardware PnP IDs
	LPTSTR		lpCompatIDs;		//multi_sz list of compatible IDs
	LPTSTR		lpFile;			//File name (string)
	OSVERSIONINFO	OSVersionInfo;		//OSVERSIONINFO from GetVersionEx()
	DWORD		dwFlags;		//Flags
	DWORD		dwClientID;		//Client ID
} DOWNLOADINFOWIN98, *PDOWNLOADINFOWIN98;

typedef BOOL (*PFN_DownloadGetUpdatedFiles)(
	PDOWNLOADINFOWIN98	pDownLoadInfoWin98,
	LPSTR lpDownloadPath,	
	UINT uSize			
);

void DoNT(int argc, char *argv[]);
void Do9x(int argc, char *argv[]);
void usage(bool fNT);
bool GetDriverPackage(PDOWNLOADINFO pinfo, LPWSTR wszPath);

int __cdecl main(int argc, char *argv[])
{
	OSVERSIONINFO	versionInformation;
	versionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&versionInformation);
	if (versionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT)
		DoNT(argc, argv);
	else
		Do9x(argc, argv);
	return 0;
}


void DoNT(int argc, char *argv[])
{
	if ( argc < 3 )
	{
		usage(true);
		return;
	}

	DOWNLOADINFO info;
	ZeroMemory(&info, sizeof(info));
	info.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
	info.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
	bool fHwId = true;
	if ( 0 == strcmp(argv[1], "0") )
	{
		fHwId = false;
	}
	else if ( 0 == strcmp(argv[1], "1") )
	{
		if ( 3 < argc )
		{
			// check 3rd param
			if ( 0 == strcmp(argv[3], "PROCESSOR_ARCHITECTURE_INTEL") )
				info.dwArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
			else if ( 0 == strcmp(argv[3], "PROCESSOR_ARCHITECTURE_ALPHA") )
				info.dwArchitecture = PROCESSOR_ARCHITECTURE_ALPHA;
		}
	}
	else
	{
		usage(true);
		return;
	}

	WCHAR wszParam[2048];
	MultiByteToWideChar(CP_ACP, 0, argv[2], -1, wszParam, 2048);
	LPCWSTR wszHardwareID = NULL;
	LPCWSTR wszDeviceInstanceID = NULL;
	if ( fHwId )
		info.lpHardwareIDs = wszParam;
	else 
		info.lpDeviceInstanceID = wszParam;

	WCHAR wszPath[MAX_PATH];
	if ( GetDriverPackage(&info, wszPath) )
	{
		char szPath[MAX_PATH];
		WideCharToMultiByte(CP_ACP, 0, wszPath, -1, szPath, sizeof(szPath), NULL, NULL);
		cout << "TESTCDM   SUCCESS:Downloaded Driver Files @ " << szPath << endl;
	}
	else
	{
		cout << "TESTCDM   FAILED:Return value = " << GetLastError() << endl;
	}
}

void Do9x(int argc, char *argv[])
{
	if ( argc < 2 )
	{
		usage(false);
		return;
	}

	DOWNLOADINFOWIN98 info;
	ZeroMemory(&info, sizeof(info));
	info.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
	info.lpHardwareIDs = argv[1];

	HMODULE hModule = LoadLibrary("cdm.dll");
	if ( !hModule )
	{
		cout << "TESTCDM   ERROR:cdm.dll Load Library Failed. Return value = " << GetLastError() << endl;
		return;
	}

	PFN_DownloadGetUpdatedFiles fpDownloadGetUpdatedFiles	= (PFN_DownloadGetUpdatedFiles)GetProcAddress(hModule, "DownloadGetUpdatedFiles");
	if ( !fpDownloadGetUpdatedFiles )
	{
		cout << "TESTCDM   ERROR:GetProcAddress failed." << endl;
		return;
	}

	char szPath[MAX_PATH];
	if ( !fpDownloadGetUpdatedFiles(&info, szPath, sizeof(szPath)) )
	{
		cout << "TESTCDM   ERROR:fpDownloadGetUpdatedFiles failed. Return value = " << GetLastError() << endl;
	}
	else
	{
		cout << "TESTCDM   SUCCESS:Downloaded Driver Files @ " << szPath << endl;
	}
}


void usage(bool fNT)
{
	if (fNT)
	{
		cout << "USAGE on NT: testcdm 0 [DevInst  ID]" << endl
			 << "             testcdm 1 [Hardware ID]" << endl
			 << "             testcdm 1 [Hardware ID] PROCESSOR_ARCHITECTURE_INTEL" << endl
			 << "             testcdm 1 [Hardware ID] PROCESSOR_ARCHITECTURE_ALPHA" << endl;
	}
	else
	{
		cout << "USAGE on 9x: testcdm [Hardware ID]" << endl;
	}
}

bool GetDriverPackage(PDOWNLOADINFO pinfo, LPWSTR wszPath)
{
	HMODULE hModule = LoadLibrary("cdm.dll");
	if ( !hModule )
	{
		cout << "TESTCDM   ERROR:cdm.dll Load Library Failed. Return value = " << GetLastError() << endl;
		return false;
	}

	CDM_INTERNET_AVAILABLE_PROC fpDownloadIsInternetAvailable	= (CDM_INTERNET_AVAILABLE_PROC)GetProcAddress(hModule, "DownloadIsInternetAvailable");
	OPEN_CDM_CONTEXT_PROC fpOpenCDMContext	= (OPEN_CDM_CONTEXT_PROC)GetProcAddress(hModule, "OpenCDMContext");
	DOWNLOAD_UPDATED_FILES_PROC fpDownloadUpdatedFiles	= (DOWNLOAD_UPDATED_FILES_PROC)GetProcAddress(hModule, "DownloadUpdatedFiles");
	CLOSE_CDM_CONTEXT_PROC fpCloseCDMContext	= (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hModule, "CloseCDMContext");
	if ( !fpDownloadIsInternetAvailable || !fpOpenCDMContext || !fpDownloadUpdatedFiles || !fpCloseCDMContext )
	{
		cout << "TESTCDM   ERROR:GetProcAddress failed." << endl;
		return false;
	}
	if (!(*fpDownloadIsInternetAvailable)())
	{
		cout << "TESTCDM   ERROR:GInternat is not available." << endl;
		return false;
	}

	HANDLE handle = (*fpOpenCDMContext)(NULL);
	if ( !handle )
	{
		cout << "TESTCDM   ERROR:fpOpenCDMContext failed. GetLastError = "<< GetLastError() << endl;
		return false;
	}

	UINT uRequired;
	BOOL bRc = (*fpDownloadUpdatedFiles)(handle, NULL, pinfo, wszPath, MAX_PATH, &uRequired);
	(*fpCloseCDMContext)(handle);
    FreeLibrary(hModule);
	return TRUE == bRc;
}

#else

int __cdecl main(int argc, char * argv[], char * envp[])
{
	HMODULE hLib;
	INT nTimes = 0;
	BOOL fBatchMode = FALSE;
	INT nEndFlag = 2; //flush logging to file for every device

	if (2 <= argc)
	{
		nTimes = atoi(argv[1]);
	}
	if (3 <= argc)
	{
		fBatchMode = TRUE;
		nEndFlag = 0; //hold off flushing
	}
	if (0 == nTimes) 
	{
		nTimes = 1;
	}
	hLib = LoadLibrary("cdm.dll");
	if (!hLib)
	{
		cout << "Load lib failed" << endl;
		return -1;
	}

	OPEN_CDM_CONTEXT_EX_PROC fpOpenCDMContextEx	= (OPEN_CDM_CONTEXT_EX_PROC)GetProcAddress(hLib, "OpenCDMContextEx");
	LOG_DRIVER_NOT_FOUND_PROC fpLogDriverNotFound	= (LOG_DRIVER_NOT_FOUND_PROC)GetProcAddress(hLib, "LogDriverNotFound");
	CLOSE_CDM_CONTEXT_PROC fpCloseCDMContext	= (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hLib, "CloseCDMContext");

	if (!fpOpenCDMContextEx || !fpLogDriverNotFound || !fpCloseCDMContext)
	{
		cout << "Get proc address failed" << endl;
		return -1;
	}

	HANDLE hCtxt = (*fpOpenCDMContextEx)(false);
	
	for (int i = 0; i < nTimes; i++)
	{
		(*fpLogDriverNotFound)(hCtxt, L"PCI\\VEN_1011&DEV_0024&SUBSYS_00000000&REV_03\\2&ebb567f&0&78", nEndFlag);
		printf("device %d logged, sleep 2 secs\n", i+1);
		Sleep(2000);
	}
	//(*fpLogDriverNotFound)(hCtxt, L"PCI\\VEN_10B7&DEV_9055&SUBSYS_00821028&REV_24\\2&ebb567f&0&88", 0);
	(*fpLogDriverNotFound)(hCtxt, L"DISPLAY\\Default_Monitor\\4&2e81f5bd&0&80000000&01&00", 2);
	(*fpCloseCDMContext)(hCtxt);

	return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\ar.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   ar.h
//
//  Owner:  YanL
//
//  Description:
//
//      auto_resource and dirived definitions
//
//
//=======================================================================

#pragma once

//----------------------------------------------------------------------
//
// class auto_resource
//		This class eliminates need for cleanup when working with pointers and 
//		handles  of the different kind
//
//		class _Rh			- resource "handle"
//
//		class _Rh_Traits	- required traits for this recource "handle"
//			Should be define as:
//				struct _Rh_Traits {
//					static _Rh invalid() {}
//					static void release(_Rh rh) {}
//				};
//
//----------------------------------------------------------------------
template< class _Rh, class _Rh_Traits >
class auto_resource {
public:
	auto_resource(_Rh rh = _Rh_Traits::invalid()) : _r(rh) 
	{
	}
	~auto_resource() 
	{ 
		release(); 
	}
	void release()	
	{	
		if (valid()) 
		{
			_Rh_Traits::release(_r);
			_r = _Rh_Traits::invalid();
		}
	}
	const auto_resource& operator=(_Rh rh)
	{
		release();
		_r = rh;
		return *this;
	}
	operator _Rh() const 
	{
		return _r;
	}
	_Rh* operator&()
	{
		release();
		return &_r;
	}
	bool valid() const	
	{	
		return (_Rh_Traits::invalid() != _r);	
	}
	_Rh detach() 
	{
		_Rh rh = _r;
		_r = _Rh_Traits::invalid();
		return rh;
	}
protected:
	_Rh _r;
	
private:
	// should not use copy constructor etc.
	auto_resource(const auto_resource&) {}
	const auto_resource& operator=(const auto_resource&) {}
	operator bool() const {}
	bool operator !() const {}
};

// handle to file has -1 as invalid
struct auto_hfile_traits {
	static HANDLE invalid() { return INVALID_HANDLE_VALUE; }
	static void release(HANDLE h) { CloseHandle(h); }
};
typedef auto_resource< HANDLE, auto_hfile_traits > auto_hfile;

// handle to all other kernel objects
struct auto_handle_traits {
	static HANDLE invalid() { return 0; }
	static void release(HANDLE h) { CloseHandle(h); }
};
typedef auto_resource< HANDLE, auto_handle_traits > auto_handle;

// handle to registry key (RegOpenKey, etc.)
struct auto_hkey_traits {
	static HKEY invalid() { return (HKEY)0; }
	static void release(HKEY hkey) { RegCloseKey(hkey); }
};
typedef auto_resource<HKEY, auto_hkey_traits> auto_hkey;

// handle to SetupDiXxxx registry key - invalid is INVALID_HANDLE_VALUE, not 0
struct auto_hkeySetupDi_traits {
	static HKEY invalid() { return (HKEY) INVALID_HANDLE_VALUE; }
	static void release(HKEY hkey) { RegCloseKey(hkey); }
};
typedef auto_resource<HKEY, auto_hkeySetupDi_traits> auto_hkeySetupDi;

// handle to load lib key
struct auto_hlib_traits {
	static HINSTANCE invalid() { return 0; }
	static void release(HINSTANCE hlib) { FreeLibrary(hlib); }
};

typedef auto_resource< HINSTANCE, auto_hlib_traits > auto_hlib;

// auto handle to HANDLE FindFirstFile
struct auto_hfindfile_traits {
	static HANDLE invalid() { return INVALID_HANDLE_VALUE; }
	static void release(HANDLE hFindFile) { FindClose(hFindFile); }
};

typedef auto_resource< HANDLE, auto_hfindfile_traits > auto_hfindfile;


// Pointer
template< class _Ty >
struct auto_pointer_traits {
	static _Ty* invalid() { return 0; }
	static void release(_Ty* p) { delete p; }
};

template< class _Ty > 
class auto_pointer : public auto_resource< _Ty*, auto_pointer_traits< _Ty > > {
public:
	auto_pointer(_Ty* p = 0) 
		: auto_resource<_Ty*, auto_pointer_traits< _Ty > >(p)
	{
	}
	const auto_pointer& operator=(_Ty* p)
	{
		auto_resource<_Ty*, auto_pointer_traits< _Ty > >::operator=(p);
		return *this;
	}
	_Ty* operator->() const
	{
		return _r;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\drvinfo.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   DrvInfo.h
//
//  Owner:  YanL
//
//  Description:
//
//      Interface to device enumeration
//
//	Note:
//		wustl.h required
//
//=======================================================================

#ifndef _DRVINFO_H
	
	// auto handle to HDEVINFO`
	struct auto_hdevinfo_traits {
		static HDEVINFO invalid() { return INVALID_HANDLE_VALUE; }
		static void release(HDEVINFO hDevInfo) { SetupDiDestroyDeviceInfoList(hDevInfo); }
	};
	typedef auto_resource< HDEVINFO, auto_hdevinfo_traits > auto_hdevinfo;

	// auto handle to HINF
	struct auto_hinf_traits {
		static HINF invalid() { return INVALID_HANDLE_VALUE; }
		static void release(HINF hinf) { SetupCloseInfFile(hinf); }
	};
	typedef auto_resource< HINF, auto_hinf_traits > auto_hinf;

	// auto handle to HSPFILEQ
	struct auto_hspfileq_traits {
		static HSPFILEQ invalid() { return INVALID_HANDLE_VALUE; }
		static void release(HSPFILEQ hspfileq) { SetupCloseFileQueue(hspfileq); }
	};
	typedef auto_resource< HINF, auto_hspfileq_traits > auto_hspfileq;

	// Main working interface
	// We are using an interface - not an object to hide the fact that 
	//		we can return both real and fake devices
	//		It will let as query properties at the run time
	struct IDrvInfo 
	{
		virtual bool GetDeviceInstanceID(tchar_buffer& bufDeviceInstanceID) = 0;
		virtual bool HasDriver() = 0;
		virtual bool IsPrinter() = 0;
		virtual bool GetAllHardwareIDs(tchar_buffer& bufHardwareIDs) = 0;
		virtual bool GetHardwareIDs(tchar_buffer& bufHardwareIDs) = 0;
		virtual bool GetCompatIDs(tchar_buffer& bufHardwareIDs) = 0;
		virtual bool GetMatchingDeviceId(tchar_buffer& bufMatchingDeviceId) = 0;
		virtual bool GetManufacturer(tchar_buffer& bufMfg) = 0;
		virtual bool GetProvider(tchar_buffer& bufProvider) = 0;
		virtual bool GetDescription(tchar_buffer& bufDescription) = 0;
		virtual bool GetDriverDate(FILETIME& ftDriverDate) = 0;
		virtual ~IDrvInfo() {}
	
	protected:
		// to be used interally
		friend class CDrvInfoEnum;
		virtual bool Init(LPCTSTR szDevInstID) = 0;
	};

	// Device enumerator will return IDrvInfo ofr real or fake device
	class CDrvInfoEnum
	{
	public:
		// to be used by CDM.DLL with wszDevInstID set from DOWNLOADINFO struct
		static bool GetDrvInfo(LPCWSTR wszDevInstID, IDrvInfo** ppDrvInfo);
	
	public:
		// to be used by WUV3IS.DLL and Win98 part of CDM.DLL
		CDrvInfoEnum();
		bool GetNextDrvInfo(IDrvInfo** ppDrvInfo);

	protected:
		auto_hdevinfo m_hDevInfoSet;
		DWORD m_dwDeviceIndex;
	};

	#define _DRVINFO_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\diamond.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   diamond.h
//
//  Owner:  YanL
//
//  Description:
//
//      Diamond decompressor
//
//=======================================================================

#ifndef _DIAMOND_H

	#ifndef INCLUDED_TYPES_FCI_FDI
		extern "C"
		{
			#include <fdi.h>
		};
	#endif


	/*
	 * This is from the FDI.H file and gives a good high level overview of the
	 * method used for reading and decompressing files that are already in
	 * memory as opposed to on disk.
	 *
	 * Notes for Memory Mapped File fans:
	 *  You can write wrapper routines to allow FDI to work on memory
	 *  mapped files.  You'll have to create your own "handle" type so that
	 *  you can store the base memory address of the file and the current
	 *  seek position, and then you'll allocate and fill in one of these
	 *  structures and return a pointer to it in response to the PFNOPEN
	 *  call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE
	 *  functions will do memcopy(), and update the seek position in your
	 *  "handle" structure.  PFNSEEK will just change the seek position
	 *  in your "handle" structure.
	 */

	struct HANDLEINFO
	{
		HANDLE			handle;			//If this is a file IO then this is the file
										//handle to pass to ReadFile or WriteFile. If
										//this is an in memory operation then this field
										//is INVALID_HANDLE_VALUE.
		ULONG			offset;			//current memory file offset
	};
	typedef frozen_array<HANDLEINFO> CHInfoArray;

	class CDiamond
	{
	public:
		CDiamond(void);
		~CDiamond(void);
		bool valid() const
		{
			return FALSE == m_erf.fError;
		}
		bool IsValidCAB(
			IN LPCTSTR szCabPath
		);

		bool IsValidCAB(
			IN byte_buffer& bufIn	// Mem buffer in
		);

		//Decompresses a cab either into memory or disk.
		bool Decompress(
			IN LPCTSTR szFileIn,		// Full path to input cab file.
			IN LPCTSTR szFileOut
		);
		bool Decompress(
			IN LPCTSTR szFileIn,		// Full path to input cab file.
			IN byte_buffer& bufOut	// Mem buffer out
		);
		bool Decompress(
			IN byte_buffer& bufIn,	// Mem buffer in
			IN LPCTSTR szFileOut
		);
		bool Decompress(
			IN byte_buffer& bufIn,	// Mem buffer in
			IN byte_buffer& bufOut	// Mem buffer out
		);

		int GetLastError()
		{
			return m_erf.fError ? m_erf.erfOper : FDIERROR_NONE;
		}

	protected:
		void SetInput(
			IN LPCTSTR szFileIn
		) {
			m_szFileIn = szFileIn;
			s_pbufIn = NULL;
		}
		void SetInput(
			IN byte_buffer& bufIn
		) {
			m_szFileIn = NULL;
			s_pbufIn = &bufIn;
		}
		void SetOutput(
			IN LPCTSTR szFileOut
		) {
			m_szFileOut = szFileOut;
			s_pbufOut = NULL;
		}
		void SetOutput(
			IN byte_buffer& bufOut	// Mem buffer out
		) {
			m_szFileOut = NULL;
			s_pbufOut = &bufOut;
		}
		bool DoDecompress();


	private:
		static void * __cdecl DEXMemAlloc(ULONG cb);
		static void	__cdecl DEXMemFree(void HUGE *pv);
		static INT_PTR	__cdecl DEXFileOpen(char *pszFile, int oflag, int pmode);
		static UINT	__cdecl DEXFileRead(INT_PTR hf, void *pv, UINT cb);
		static UINT	__cdecl DEXFileWrite(INT_PTR hf, void *pv, UINT cb);
		static int	__cdecl DEXFileClose(INT_PTR hf);
		static long	__cdecl DEXFileSeek(INT_PTR hf, long dist, int seektype);

	private:
		ERF						m_erf;				//diamond compression Error structure
		HFDI					m_hfdi;				//Handle to FDI context
		
		LPCTSTR					m_szFileOut;		//pointer to output file or "?" for in memory operation.
		LPCTSTR					m_szFileIn;			//pointer to input file used when outfile is set to *.

		static byte_buffer*		s_pbufIn;			
		static byte_buffer*		s_pbufOut;			

		static CHInfoArray		s_handles;			//Memory decompression handle information arrays
													//increases and allocates the handle.
		static INT_PTR __cdecl Notification(FDINOTIFICATIONTYPE fdiNotifType, PFDINOTIFICATION pfdin);
	};

	#define _DIAMOND_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\filecrc.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    filecrc.h
//
//  Purpose: Calculating and using CRC for files
//
//=======================================================================
#ifndef _FILECRC_H
#define _FILECRC_H

// size of the CRC hash in bytes
const int WUCRC_HASH_SIZE =  20;


// binary structure to hold the hash
struct WUCRC_HASH
{
    BYTE HashBytes[WUCRC_HASH_SIZE];
};


struct WUCRCMAP
{
	DWORD dwKey;
	WUCRC_HASH CRC;
};


HRESULT CalculateFileCRC(LPCTSTR pszFN, WUCRC_HASH* pCRC);

HRESULT StringFromCRC(const WUCRC_HASH* pCRC, LPTSTR pszBuf, int cbBuf);

HRESULT CRCFromString(LPCSTR pszCRC, WUCRC_HASH* pCRC);

HRESULT SplitCRCName(LPCSTR pszCRCName, WUCRC_HASH* pCRC, LPSTR pszName);

HRESULT MakeCRCName(LPCTSTR pszFromName, const WUCRC_HASH* pCRC, LPTSTR pszToName, int cbToName);

HRESULT GetCRCNameFromList(int iNo, PBYTE pmszCabList, PBYTE pCRCList, LPTSTR pszCRCName, int cbCRCName, LPTSTR pszCabName);

int __cdecl CompareWUCRCMAP(const void* p1, const void* p2);


class CCRCMapFile
{
public:
	CCRCMapFile(const BYTE* pMemData, DWORD dwMemSize);

	HRESULT GetValue(DWORD dwKey, WUCRC_HASH* pCRC);
	HRESULT GetCRCName(DWORD dwKey, LPCTSTR pszFromName, LPTSTR pszToName, int cbToName);

private:
	CCRCMapFile() {}  // cannot use default constructor

	WUCRCMAP* m_pEntries;
	DWORD m_cEntries;
};


#endif // _FILECRC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\bucket.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   bucket.h
//
//  Owner:  YanL
//
//  Description:
//
//      CDM bucket support
//
//=======================================================================

#ifndef _BUCKET_H

	#pragma pack(1)

	//CDM hash table structures
	//Hash table header
	typedef struct _CDM_HASHTABLEHDR
	{
		DWORD	iVersion;			//hash table version
		long	iTableSize;			//hash table size in bits
	} CDM_HASHTABLEHDR, *PCDM_HASHTABLEHDR;

	//hash table format
	typedef struct _CDM_HASHTABLE
	{
		CDM_HASHTABLEHDR	hdr;	//hash table header

		#pragma warning( disable : 4200 )
			BYTE	pData[];		//actual hash table bits
		#pragma warning( default : 4200 )

	} CDM_HASHTABLE, *PCDM_HASHTABLE;

	//This structure represents a cdm bucket file. A CDM bucket file
	typedef struct _CDM_RECORD_HEADER
	{
		long		cnRecordLength;					//Total length of the record
		long		nBitmaskIdx;						//cdm bitmask index
		PUID		puid;							//Windows Update assigned id that is unique
													//across catalogs and records. This id names
	} CDM_RECORD_HEADER, *PCDM_RECORD_HEADER;
	// Followed by:
	//	char		szHardwareID[];			\0 terminated
	//	char		szDescription[];		\0 terminated
	//	char		szMfgName[];			\0 terminated
	//	char		szProviderName[];		\0 terminated
	//	char		szDriverVer[];			\0 terminated
	//	char		szCabFileTitle[];		\0 terminated

	#pragma pack()

	// Prefixes for Printer Hardware IDs
	#define PRINT_ENVIRONMENT_INTEL						_T("0001")	// Windows NT x86
	#define PRINT_ENVIRONMENT_ALPHA						_T("0002")	// Windows NT Alpha_AXP

	struct IDrvInfo;

	ULONG CDM_HwID2Hash(IN LPCTSTR szHwID, IN ULONG iTableSize);
	
	typedef struct _DRIVER_MATCH_INFO {
		LPCSTR pszHardwareID;
		LPCSTR pszDescription;
		LPCSTR pszMfgName;
		LPCSTR pszProviderName;
		LPCSTR pszDriverVer;
		LPCSTR pszCabFileTitle;
	} DRIVER_MATCH_INFO, *PDRIVER_MATCH_INFO;

	PUID CDM_FindUpdateInBucket(
		IN LPCTSTR szHardwareIdFromDevice, FILETIME* pftInstalled,
		IN LPBYTE pBucket, IN int cbBucket, IN LPBYTE pBitmask, 
		OUT PDRIVER_MATCH_INFO pDriverMatchInfo
	);
	PUID CDM_FindInstalledInBucket(
		IN IDrvInfo* pDrvInfo, IN LPCTSTR szHardwareIdInstalled,
		IN LPBYTE pBucket, IN int cbBucket, IN LPBYTE pBitmask, 
		OUT PDRIVER_MATCH_INFO pDriverMatchInfo
	);

	#define _BUCKET_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\cdm.h ===
//=======================================================================
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdm.cpp
//
//  Owner:  YanL
//
//  Description:
//
//    Public header file for Windows NT Code Download Manager services Dll.
//
//=======================================================================

#ifndef _INC_CDM
#define _INC_CDM

//
// Define API decoration for direct importing of DLL references.
//
#if !defined(_CDM_)
#define CDMAPI DECLSPEC_IMPORT
#else
#define CDMAPI
#endif

#define HWID_LEN						2048
#ifndef LINE_LEN
	#define LINE_LEN                    256 // Win95-compatible maximum for displayable
											// strings coming from a device INF.
#endif                                        

typedef struct _DOWNLOADINFO {
    DWORD          dwDownloadInfoSize;    // size of this structure
    LPCWSTR        lpHardwareIDs;         // multi_sz list of Hardware PnP IDs
    LPCWSTR        lpDeviceInstanceID;    // Device Instance ID
    LPCWSTR        lpFile;                // File name (string)
    OSVERSIONINFOW OSVersionInfo;         // OSVERSIONINFO from GetVersionEx()
    DWORD          dwArchitecture;        // Specifies the system's processor architecture.
                                          //This value can be one of the following values: 
                                          //PROCESSOR_ARCHITECTURE_INTEL
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_MIPS
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_ALPHA
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_PPC
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_UNKNOWN 
    DWORD          dwFlags;               // Flags
    DWORD          dwClientID;            // Client ID
    LCID           localid;               // local id
} DOWNLOADINFO, *PDOWNLOADINFO;


typedef struct _WUDRIVERINFO
{
    DWORD dwStructSize;					// size of this structure
	WCHAR wszHardwareID[HWID_LEN];		// ID being used to match
	WCHAR wszDescription[LINE_LEN];	// from INF	
	WCHAR wszMfgName[LINE_LEN];		// from INF
	WCHAR wszProviderName[LINE_LEN];	// INF provider
	WCHAR wszDriverVer[LINE_LEN];		// from INF
} WUDRIVERINFO, *PWUDRIVERINFO;

CDMAPI
HANDLE
WINAPI
OpenCDMContext(
    IN HWND hwnd
    );

CDMAPI
HANDLE
WINAPI
OpenCDMContextEx(
    IN BOOL fConnectIfNotConnected
    );

CDMAPI
BOOL
WINAPI
DownloadIsInternetAvailable(
	void
	);

CDMAPI
BOOL
WINAPI
DownloadUpdatedFiles(
    IN  HANDLE        hConnection, 
    IN  HWND          hwnd,  
    IN  PDOWNLOADINFO pDownloadInfo, 
    OUT LPWSTR        lpDownloadPath, 
    IN  UINT          uSize, 
    OUT PUINT         puRequiredSize
    );


typedef void (*PFN_QueryDetectionFilesCallback)(void* pCallbackParam, LPCWSTR pszURL, LPCWSTR pszLocalFile);

CDMAPI
int
WINAPI
QueryDetectionFiles(
    IN  HANDLE							hConnection, 
	IN	void*							pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
	);

CDMAPI
void
WINAPI
DetFilesDownloaded(
    IN  HANDLE			hConnection
	);

CDMAPI
BOOL
WINAPI
FindMatchingDriver(
    IN  HANDLE			hConnection, 
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
	);

CDMAPI
void
WINAPI
LogDriverNotFound(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
	);

CDMAPI
VOID
WINAPI
CloseCDMContext(
    IN HANDLE hConnection
    );


//
// CDM prototypes
//
typedef HANDLE (WINAPI *OPEN_CDM_CONTEXT_PROC)(
    IN  HWND   hwnd
    );

typedef HANDLE (WINAPI *OPEN_CDM_CONTEXT_EX_PROC)(
    IN BOOL fConnectIfNotConnected
    );

typedef BOOL (WINAPI *DOWNLOAD_UPDATED_FILES_PROC)(
    IN HANDLE hConnection,
    IN HWND hwnd,
    IN PDOWNLOADINFO pDownloadInfo,
    OUT LPWSTR lpDownloadPath,
    IN UINT uSize,
    OUT PUINT puRequiredSize
    );

typedef int (WINAPI *QUERY_DETECTION_FILES_PROC)(
    IN  HANDLE hConnection, 
	IN	void* pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
    );

typedef void (WINAPI *DET_FILES_DOWNLOADED_PROC)(
    IN  HANDLE hConnection 
    );

typedef BOOL (WINAPI *FIND_MATCHING_DRIVER_PROC)(
    IN  HANDLE hConnection,
	IN  PDOWNLOADINFO pDownloadInfo,
	OUT PWUDRIVERINFO pWuDriverInfo
    );

typedef void (WINAPI *LOG_DRIVER_NOT_FOUND_PROC)(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
    );

typedef VOID (WINAPI *CLOSE_CDM_CONTEXT_PROC)(
    IN HANDLE hConnection
    );

typedef BOOL (WINAPI *CDM_INTERNET_AVAILABLE_PROC)(
    void
    );


//
// The following defines and structures are private internal interfaces so 
// they are in cdm.h and not in setupapi.h
//
#define DIF_GETWINDOWSUPDATEINFO            0x00000025

#define DI_FLAGSEX_SHOWWINDOWSUPDATE        0x00400000L

	
//For dwFlags parameter of LogDriverNotFound(...) 
//used with bitwising
#define BEGINLOGFLAG 0x00000002	//if 1, batch logging ends, flushing internal hardware id list to file


//
// Structure corresponding to a DIF_GETWINDOWSUPDATEINFO install function.
//
typedef struct _SP_WINDOWSUPDATE_PARAMS_A {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    CHAR                   PackageId[MAX_PATH];
    HANDLE                 CDMContext;
} SP_WINDOWSUPDATE_PARAMS_A, *PSP_WINDOWSUPDATE_PARAMS_A;

typedef struct _SP_WINDOWSUPDATE_PARAMS_W {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    WCHAR                  PackageId[MAX_PATH];
    HANDLE                 CDMContext;
} SP_WINDOWSUPDATE_PARAMS_W, *PSP_WINDOWSUPDATE_PARAMS_W;


#ifdef UNICODE
typedef SP_WINDOWSUPDATE_PARAMS_W SP_WINDOWSUPDATE_PARAMS;
typedef PSP_WINDOWSUPDATE_PARAMS_W PSP_WINDOWSUPDATE_PARAMS;
#else
typedef SP_WINDOWSUPDATE_PARAMS_A SP_WINDOWSUPDATE_PARAMS;
typedef PSP_WINDOWSUPDATE_PARAMS_A PSP_WINDOWSUPDATE_PARAMS;
#endif


#endif // _INC_CDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\download.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   download.h
//
//  Owner:  YanL
//
//  Description:
//
//      Internet download
//
//=======================================================================

#ifndef _DOWNLOAD_H

	#include <wininet.h>

	// handle to internet
	struct auto_hinet_traits {
		static HINTERNET invalid() { return 0; }
		static void release(HINTERNET h) { InternetCloseHandle(h); }
	};
	typedef auto_resource<HANDLE, auto_hinet_traits> auto_hinet;

	#define MAX_THREADS_LIMIT	8

	class CLock : protected CRITICAL_SECTION
	{
	public:
		CLock()
		{
			InitializeCriticalSection(this);
		}
		LONG Increment(LONG* pl)
		{
			LONG l;
			EnterCriticalSection(this);
			l = ++ *pl;
			LeaveCriticalSection(this);
			return l;
		}
		LONG Decrement(LONG* pl)
		{
			LONG l;
			EnterCriticalSection(this);
			l = -- *pl;
			LeaveCriticalSection(this);
			return l;
		}
		~CLock()
		{
			DeleteCriticalSection(this);
		}

	};

	// Notification
	struct IDownloadAdviceSink
	{
		virtual void JobStarted(int nJob) = 0;
		virtual void JobDownloadSize(int nJob, DWORD dwTotalSize) = 0;
		virtual void BlockDownloaded(int nJob, DWORD dwBlockSize, DWORD dwTimeSpan) = 0;
		virtual void JobDownloadTime(int nJob, DWORD dwTotalTimeSpan) = 0;
		virtual void JobDone(int nJob) = 0;
		virtual bool WantToAbortJob(int nJob) = 0;
	};

	class CDownload
	{
	public:
		CDownload(IN OPTIONAL int cnMaxThreads = 1);
		~CDownload();
		
		// Connect to server and set the base URL
		bool Connect(IN LPCTSTR szURL);
		bool IsConnected() { return m_hConnection.valid(); }
		
		// Download one file to file. Calls CopyEx internally
		bool Copy(IN LPCTSTR szSourceFile, IN LPCTSTR szDestFile, IN OPTIONAL IDownloadAdviceSink* pSink = 0);
										
		// Download one file to memory. Calls CopyEx interanlly
		bool Copy(IN LPCTSTR szSourceFile, IN byte_buffer& bufDest, IN OPTIONAL IDownloadAdviceSink* pSink = 0);

		// Download set of files to specified destinations
		struct JOB
		{
			LPCTSTR pszSrvFile;		// name file relative to szURL from Connect
			LPCTSTR pszDstFile;		// path to destination file, if NULL use pDstBuf
			byte_buffer* pDstBuf;	// pointer to memory buffer, to be used
			DWORD dwResult;			// Win32 error code
			void* pUser;			// for user to hookup
		};
		typedef JOB * PJOB;
		typedef const JOB * PCJOB;
		void CopyEx(IN PJOB pJobs, IN int cnJobs, IN OPTIONAL IDownloadAdviceSink* pSink = 0, IN bool fWaitComplete = true);

	private:
		static DWORD WINAPI StaticThreadProc(IN LPVOID lpParameter);
		void ThreadProc();
		void DoJob(int nJob);
		DWORD DoCopyToFile(IN int nJob, IN LPCTSTR szSourceFile, IN LPCTSTR szDestFile);
		DWORD DoCopyToBuf(IN int nJob, IN LPCTSTR szSourceFile, IN byte_buffer& bufDest);
		DWORD OpenInetFile(LPCTSTR szFullSourcePath, SYSTEMTIME* pstIfModifiedSince,
			auto_hinet& hInetFile, DWORD* pdwServerFileSize, SYSTEMTIME* pstServer);

		auto_hinet m_hSession;		//handle to wininet library
		auto_hinet m_hConnection;	//handle to server connection.

		auto_handle m_ahThreads[MAX_THREADS_LIMIT];	// threads pool
		int m_cnMaxThreads;				// current max number of therads
		int m_cnThreads;				// current number of running threads

		PJOB m_pJobsQueue;				// jobs queue
		long m_cnJobsTotal;				// total number of jobs in the queue
		long m_nJobTop;					// top job in a queue
		long m_cnJobsToComplete;		// m_cnJobsTotal - number of completed jobs
		CLock m_lock;					// win95 and nt 4 don't support InterlockIncrement

		IDownloadAdviceSink* m_pSink;	//progress report

		auto_handle	m_hEventExit;		// request to exit, set by main thread, 
										//					WaitFor... by working threads
		auto_handle	m_hEventJob;		// request to start download, set by main thread, 
										//							  WaitFor... by working threads
										//							  reset when queue is empty
		auto_handle	m_hEventDone;		// set by working thread, WaitFor... by main thread

		TCHAR m_szRootPath[INTERNET_MAX_PATH_LENGTH];	//server that this context is connected to.
	};

	#define _DOWNLOAD_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\findoem.h ===
/*** findoem.h - Public header for GetOemInfo
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/08/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _FINDOEM_H
#define _FINDOEM_H


/*** GetMachinePnPID - Find IDs corresponding to Make and Model code
 *
 *  ENTRY
 *      PSZ szTable
 *		Table format is 
 *
 *		|##| ... |##|00|##|##|##|##|
 *		|           |  |           |
 *		  OEM Model  \0    PnP ID   
 *
 *		|00|00|00|00|
 *		|           |
 *           00000
 *
 *  EXIT
 *      PnP ID  or 0
 */
DWORD GetMachinePnPID(PBYTE szTable);

/*** DetectMachineID - Gather all available machine OEM and model information and return ID
 *
 *  EXIT
 *		returns ID
 */
LPCTSTR DetectMachineID(bool fAlwaysDetectAndDontSave = false);

typedef struct _OEMINFO
{
	DWORD dwMask;
	TCHAR  szWbemOem[65];
	TCHAR  szWbemProduct[65];
	TCHAR  szAcpiOem[65];
	TCHAR  szAcpiProduct[65];
	TCHAR  szSmbOem[65];
	TCHAR  szSmbProduct[65];
	DWORD dwPnpOemId;
	TCHAR  szIniOem[256];
} OEMINFO, * POEMINFO;

#define OEMINFO_WBEM_PRESENT	0x0001
#define OEMINFO_ACPI_PRESENT	0x0002
#define OEMINFO_SMB_PRESENT		0x0004
#define OEMINFO_PNP_PRESENT		0x0008
#define OEMINFO_INI_PRESENT		0x0010

/*** GetOemInfo - Gather all available machine OEM and model information
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *		BOOL fAlwaysDetectAndDontSave - do what is says
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void GetOemInfo(POEMINFO pOemInfo, bool fAlwaysDetectAndDontSave = false);

/*** MakeAndModel - Return ID for a machine
 *
 *		returns ID
 */
LPCTSTR MakeAndModel(POEMINFO pOemInfo);

/*** ID support
 */
BOOL IsValidStringID(PSZ pszID);
DWORD NumericID(PSZ psz);
PSZ StringID(DWORD dwID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\osdet.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   log.h
//
//  Owner:  Yan Leshinsly
//
//  Description:
//
//      V3 Platform anad language detection
//
//=======================================================================

#ifndef _OSDET_INC

	#if !defined(_OSDET_)
		#define OSDETAPI DECLSPEC_IMPORT
	#else
		#define OSDETAPI
	#endif

	typedef void (*PFN_V3_Detection)(PDWORD *ppiPlatformIDs, PINT piTotalIDs);
	typedef DWORD (*PFN_V3_GetLangID)();
    typedef DWORD (*PFN_V3_GetUserLangID)();

	OSDETAPI void WINAPI V3_Detection(
		PINT *ppiPlatformIDs,
		PINT piTotalIDs
	);

	OSDETAPI DWORD WINAPI V3_GetLangID();
    OSDETAPI DWORD WINAPI V3_GetUserLangID();

	#define _OSDET_INC
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\log.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   log.h
//
//  Original Author:  Yan Leshinsky
//
//  Description:
//
//      Logging support
//
//=======================================================================
#pragma once
#include <stdio.h>

#if 1

	#ifndef LOGGING_LEVEL
		#define LOGGING_LEVEL 0
	#endif

	const DWORD MAX_FORMATTED_STRING = 1024;
	class CLogger
	{
	public:
		CLogger(const char* szBlockName = 0, int nLoggingLevel = 0, const char* szFileName = 0, int nLine = 0);
		~CLogger();
		void __cdecl out(const char *szFormat, ...);
		void __cdecl error(const char *szFormat, ...);
		static void __cdecl out1(const char *szFormat, ...);

	private:
		void v_out( const char* szFormat, va_list va);

		bool m_fOut;
		char m_szBlockName[64];
		DWORD m_dwStartTick;
		
		static FILE* c_pfile;
		static int c_cnIndent;
		static int c_cnLevels;
	};

	#define THIS_FILE          		__FILE__
	#define LOG_block(name)			CLogger logger(name, LOGGING_LEVEL, THIS_FILE, __LINE__)
	#define LOG_out					logger.out
	#define LOG_out1				CLogger::out1
	#define LOG_error				logger.error
#ifdef _UNICODE
	#define return_if_false(f)			if (f) {/*OK*/} else {  LOG_error("%S LastError = %d", #f, GetLastError()); return false;}
	#define return_error_if_false(f)	if (f) {/*OK*/} else { DWORD dwErr = GetLastError(); LOG_error("%S LastError = %d", #f, dwErr); return dwErr;}
	#define return_if_error(f)			{ DWORD dwErr = f; if (dwErr) { LOG_error("%S LastError = %d", #f, dwErr); return dwErr;} }
#else
	#define return_if_false(f)			if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); return false;}
	#define return_error_if_false(f)	if (f) {/*OK*/} else { DWORD dwErr = GetLastError(); LOG_error("%s LastError = %d", #f, dwErr); return dwErr;}
	#define return_if_error(f)			{ DWORD dwErr = f; if (dwErr) { LOG_error("%s LastError = %d", #f, dwErr); return dwErr;} }
#endif																											

#else
	#define LOG_block(name)
	inline void __cdecl ___LOG(const char *szFormat, ...){}
	#define LOG_out					true ? (void)0 : ___LOG
	#define LOG_out1				true ? (void)0 : ___LOG
	#define LOG_error				true ? (void)0 : ___LOG

	#define return_if_false(f)			if (f) {/*OK*/} else { return false;}
	#define return_error_if_false(f)	if (f) {/*OK*/} else { return GetLastError(); }
	#define return_if_error(f)			{ DWORD dwErr = f; if (dwErr) { return dwErr;} }

#endif	
#define tab_out(){if(c_pfile){ for(int i = 0; i < c_cnIndent; i ++)	{_fputtc(_T('\t'),c_pfile);}}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\newtrust.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998, 1999, 2000 Microsoft Corporation.  All Rights Reserved.
//
//	SYSTEM:		Windows Update Critical Fix Notification
//
//	CLASS:		N/A
//	MODULE:		MS Cab Trusting Function Header
//	FILE:		NewTrust.h
//
/////////////////////////////////////////////////////////////////////
//
//	DESC:	this header file declares functions used to make Microsoft
//			signed cab trusted.
//
//	AUTHOR:	Alessandro Muti, Windows Update Team
//	DATE:	3/11/1999
//
/////////////////////////////////////////////////////////////////////
//
//	Revision History:
//
//	Date	    Author			Description
//	~~~~	    ~~~~~~			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//	10/17/2000  Nick Dallett    Porting Charlma's new cert-checking code from SLM tree:
// (8/31/2000	charlma			Changed to only publish VerifyFile())
//
//
/////////////////////////////////////////////////////////////////////
//
//     	(c) Copyrights:   1998, 1999, 2000 Microsoft Corporation 
//
//    	All rights reserved.
//
//     	No portion of this source code may be reproduced
//     	without express written permission of Microsoft Corporation.
//
//     	This source code is proprietary and confidential.
/////////////////////////////////////////////////////////////////////
//

#ifndef __NEWTRUST_HEADER
#define __NEWTRUST_HEADER



//HRESULT CheckWinTrust(LPCTSTR pszFileName, DWORD dwUIChoice);
//HRESULT CheckMSCert(LPCTSTR pszFileName);

#include <wintrust.h>
/////////////////////////////////////////////////////////////////////////////
// 
// Public Function VerifyFile()
//
// This is a wrapper function for CheckWinTrust that both Whistler 
// and WU classic code should use.
//
// Input:	szFileName - the file with complete path
//			fShowBadUI - whether pop up UI in cases 
//						 (1) inproperly signed signature, or
//						 (2) properly signed with a non-MS cert
//
// Return:	HRESULT - S_OK the file is signed with a valid MS cert
//					  or error code.
//					  If the file is signed correctly but cert is not
//					  a known Microsoft cert included in this feature, then
//					  CERT_UNTRUSTED_ROOT is returned.
//
// Good Cert: Here is the deifnition of a good cert, in addition to the fact
//			  that the signature must be valid and not expired.
//				(1) The signature was signed with a cert that has 
//					"Microsoft Root Authority" as root, or
//				(2) The signature was signed with one of the following known
//					Microsoft cert's (they are not rooted to MS)
//					* Microsoft Corporation
//					* Microsoft Corporation MSN
//					* MSNBC Interactive News LLC
//					* Microsoft Corporation MSN (Europe)
//					* Microsoft Corporation (Europe)
//
// Note:	If _WUV3TEST flag is set (for test build), then fShowBadUI is
//			ignored:
//				if reg key SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\wuv3test\WinTrustUI
//				is set to 1, then no UI is shown, and this function always return S_OK;
//				otherwise, UI always show no matter what cert, and return value is same
//				as the live build.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT VerifyFile(IN LPCTSTR szFileName, BOOL fShowBadUI = TRUE);
						
#endif //__NEWTRUST_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\try_catch.h ===
/*** try_catch.h - Error processing through structured exceptions
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/08/98
 *
 *  MODIFICATION HISTORY
 */

#pragma once
#pragma warning( disable : 4102 )	// many of the labels will remain unreferenced

inline HRESULT MakeHRESULT(int iRet) { return HRESULT_FROM_WIN32(iRet); }
inline HRESULT MakeHRESULT(LONG lRet) { return HRESULT_FROM_WIN32(lRet); }
inline HRESULT MakeHRESULT(DWORD lRet) { return HRESULT_FROM_WIN32(lRet); }

#ifdef USE_EXCEPTIONS

	#define try_block			try { HRESULT __hr = S_OK;
	
	#define catch_all			} catch (HRESULT){}
	#define catch_return		} catch (HRESULT __hr){ return __hr; } 
	#define catch_set(hr)		} catch (HRESULT __hr){ hr = __hr; } 
	
	#define throw_now			throw __hr

	// Compiler com support
	inline void __stdcall _com_issue_error(HRESULT hr) { throw hr; } 

#else

	#define try_block				{ HRESULT __hr = S_OK;
	
	#define catch_all				catch_block: ; }
	#define catch_return			catch_block: return __hr; } 
	#define catch_set(hr)			catch_block: hr = __hr; } 
	
	#define throw_now				goto catch_block
	
	// Disable throw in compiler com support
	inline void __stdcall _com_issue_error(HRESULT hr) {}	

#endif

#ifdef _DEBUG

	// Print erroneous line
	#define THIS_FILE          		_T(__FILE__)
	inline void __dump(LPCTSTR szFileName, int nLine, LPCTSTR szPrompt, HRESULT hr) {
 		TCHAR szMsg[ 1024 ];
		TCHAR szErr[ 256 ];
		DWORD cMsgLen = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD)hr, LANG_NEUTRAL, szErr, sizeof(szErr), NULL);
		wsprintf(szMsg, _T("ERROR File %hs, Line %d\r\n\t\t\t%s\r\n\t\t\t0x%08X\t%s"), szFileName, nLine, szPrompt, (DWORD)hr, 
			cMsgLen ? szErr : _T("Unknown error") );
		OutputDebugString(szMsg);
	}

#else

	#define __dump(szFileName, nLine, szPrompt, hr)

#endif /* _DEBUG */

// If return code FAILED throw it
#define throw_hr(f)			{ __hr = (f); if (FAILED(__hr)) { __dump(THIS_FILE, __LINE__, #f, __hr); throw_now; } }

// If return code isn't ERROR_SUCCESS convert it to HRESULT and throw it
#define throw_err(f)		{ __hr = MakeHRESULT(f); if (FAILED(__hr)) { __dump(THIS_FILE, __LINE__, #f, __hr); throw_now; } }

// If return code false throw last error
#define throw_flast(f)		if (!(f)) { __hr = MakeHRESULT(GetLastError()); __dump(THIS_FILE, __LINE__, #f, __hr); throw_now; }

// If return code false throw specific HRESULT
#define throw_fhr(f, hr)	if (!(f)) { __hr = hr; __dump(THIS_FILE, __LINE__, #f, __hr); throw_now; }

// If return code false throw specific Win32 error
#define throw_ferr(f, err)	if (!(f)) { __hr = MakeHRESULT(err); __dump(THIS_FILE, __LINE__, #f, __hr); throw_now; }

#define throw_fmem(f)		throw_fhr(f, E_OUTOFMEMORY)
#define throw_fpar(f)		throw_fhr(f, E_INVALIDARG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\wustl.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   wustl.h
//
//  Owner:  
//
//  Description:
//
//      Common definition and templates useful acros projects
//
//
//=======================================================================

#ifndef _WUSTL_H

	#pragma warning(disable:4530)	// C++ exception handler used, but unwind semantics are not enabled. Specify -GX

	#include <vector>
	#include <map>
	#include <string>

    using std::string;
    using std::wstring;
    using std::pair;
    using std::vector;
    using std::map;
	#include <ar.h>

	//----------------------------------------------------------------------
	//
	// Common definitions...
	//
	//----------------------------------------------------------------------
	#define sizeOfArray(a)  (sizeof(a) / sizeof(a[0]))
	#pragma intrinsic(memcmp)
	#pragma intrinsic(memcpy)
	#pragma intrinsic(memset)
	#pragma intrinsic(strcat)
	#pragma intrinsic(strcmp)
	#pragma intrinsic(strcpy)
	#pragma intrinsic(strlen)
 

	//----------------------------------------------------------------------
	//
	// class frozen_array
	//		Resizable buffer
	//
	//----------------------------------------------------------------------
	template< class _Ty >
		class frozen_array
	{
	public:
        typedef pair<_Ty, bool> _My_pair;
        typedef vector< _My_pair > _My_vector;
		
		frozen_array() : _cnFree(0)
		{
		}
		int add(const _Ty& x)
		{
			if (_cnFree > 0)
			{
				//Find spare handle or add one
				int index = 0;
				while(_v[index].second)
				{
					// ASSERT(index < g_handleArray.size());
					index ++;
				}
				_v[index].first = x;
				_v[index].second = true;
				_cnFree --;
				return index;
			}
			else
			{
				_v.push_back(_My_pair(x, true));
				return _v.size() - 1;
			}
		}
		void remove(int index)
		{
			_v[index].second = false;
			_cnFree ++;
		}
		_Ty& operator[](int index)
		{
			return _v[index].first;
		}
		bool valid_index(int index) 
		{
			return 0 <= index &&  index < _v.size() && _v[index].second;
		};

	protected:
		_My_vector _v;
		int _cnFree;
	};

	//----------------------------------------------------------------------
	//
	// class buffer
	//		Resizable buffer
	//
	//----------------------------------------------------------------------
	template< class _Ty >
		class safe_buffer {
	public:
		safe_buffer(int cb = 0) 
			: _cb(0), _pb(0)
		{
			if (cb)
				resize(cb);
		}
		safe_buffer(const safe_buffer& b) 
			: _cb(0), _pb(0)
		{
			if (b._cb)
				resize(b._cb);
			// do copy if resize ok
			if (_cb)
				memcpy(_pb, b._pb, _cb * sizeof(_Ty));
			
		}
		int size() const
		{ 
			return _cb; 
		}
		void resize(int cb)  
		{ 
			_pb = (_Ty*)realloc(_pb, cb * sizeof(_Ty));
			_cb = (0 != _pb) ? cb : 0;
		}
		bool valid() const
		{
			return _pb != 0;	
		}
		operator _Ty*() const 
		{
			return _pb;
		}
		operator const _Ty*() const 
		{
			return _pb;
		}
		void operator <<(safe_buffer& b) 
		{
			free(_pb); 
			_cb = b._cb;
			_pb = b._pb;
			b._cb = 0;
			b._pb = 0;
		}
		void zero_buffer()
		{
		   memset(_pb, '\0', _cb);
		}
		_Ty* detach()
		{
			_Ty* pb = _pb;
			_pb = 0;
			_cb = 0;
			return pb;
		}
		~safe_buffer() 
		{ 
			free(_pb); 
		}

	protected:
		_Ty* _pb;
		int _cb;

	private:
		// forbid
		operator bool() const {}
		bool operator !() const {}
	};

	typedef safe_buffer< BYTE > byte_buffer;
	typedef safe_buffer< char > char_buffer;
	typedef safe_buffer< WCHAR > wchar_buffer;
	#ifdef _UNICODE
		#define tchar_buffer wchar_buffer
	#else
		#define tchar_buffer char_buffer
	#endif

	#define _WUSTL_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\calccrc.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    filecrc.h
//
//  Purpose: Calculating and using CRC for files
//
//=======================================================================

#include <windows.h>
#include <objbase.h>

#include <filecrc.h>
#include <wincrypt.h>
#include <mscat.h>


HRESULT CalculateFileCRC(LPCTSTR pszFN, WUCRC_HASH* pCRC)
{

	HANDLE hFile;
	HRESULT hr = S_OK;
    DWORD cbHash = WUCRC_HASH_SIZE;

	
	hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
 		if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, pCRC->HashBytes, 0))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
		
		CloseHandle(hFile);
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdminc\wuv3cdm.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   wuv3cdm.h
//
//  Owner:  YanL
//
//  Description:
//
//      This file defines the structures, values, macros, and functions
//       used by the Version 3 Windows Update Catalog
//
//=======================================================================

#ifndef _WUV3CDM_H

	#pragma pack(1)

	#ifndef PUID
		typedef long	PUID;		//Windows Update assigned identifier
									//that is unique across catalogs.
		typedef PUID	*PPUID;		//Pointer to a PUID type.
	#endif

	//The WU_VARIABLE_END field is the only required field variable field. It is used to signify
	//that there are no more variable fields associated with an inventory record.

	#define	WU_VARIABLE_END						((short)0)

	struct WU_VARIABLE_FIELD
	{
		WU_VARIABLE_FIELD();

		short	id;		//record type identifier
		short	len;	//length of variable record data

		//size we are using a 0 size array place hold we need to disable the
		//compiler warning since it will complain about this being non standard
		//behavor.
		#pragma warning( disable : 4200 )
		BYTE	pData[];	//variable field record data
		#pragma warning( default : 4200 )

		//The GetNextItem function returns a pointer to the next variable array item
		//if it exists or NULL if it does not.
		WU_VARIABLE_FIELD *GetNext(void);

		//The FindItem function returns a pointer to the next variable array item
		//if the requested item is found or NULL the item is not found.
		WU_VARIABLE_FIELD *Find(short id);

		//returns the total size of this variable field array.
		int GetSize(void);
	};
	typedef WU_VARIABLE_FIELD * PWU_VARIABLE_FIELD;

	//defined variable Description file items.
	#define WU_DESCRIPTION_NONE				((short)0)		//no other description flags only valid if used with no other flags
	#define WU_DESCRIPTION_TITLE			((short)1)		//title of item that is to be displayed
	#define WU_DESCRIPTION_DESCRIPTION		((short)2)		//description text that is displayed with item
	#define WU_DESCRIPTION_PACKAGE			((short)3)		//?????
	#define WU_DESCRIPTION_EURLA_URL		((short)4)		//license text url that needs read and accepted before package is installed
	#define WU_DESCRIPTION_READTHIS_URL		((short)5)		//read this first url
	#define WU_DESCRIPTION_PATCH			((short)6)		//?????? this is not a patch in the clasic sense need to find out what this is
	#define WU_DESCRIPTION_UNINSTALL_KEY	((short)7)		//uninstall command
	#define	WU_DESCRIPTION_INSTALLCABNAME	((short)8)		//name of cab file that contains the installation CIF. This cab name is a NULL terminated string and is passed to active setup to install the package.
	#define	WU_DESCRIPTION_CABFILENAME		((short)9)		//cab file name for installation this is one or more and is in the format of an array of NULL terminated strings with the last entry double null terminated. This is known as a multisz string in the langauge of the registry.
	#define WU_DESCRIPTION_SERVERROOT		((short)10)		//Server root3rd Level - Server root for install cabs. The tools and database will also need to understand that at times a piece of content can be located on a different download server from the main server and the structures need to be able to handle this. This allows us to host a single server site, a split server site like what we have today and a multi headed download server farm. The real goal behind this is to make sure we can host OEM content on the site without having to store the cabs on our servers.
	#define WU_USE_DEFAULT_PLATFORM			((short)46)
	#define WU_DESC_CRC_ARRAY               ((short)61)		// An array of CRC hash structs (WUCRC_HASH) for each CAB
																
	typedef struct _WU_DESCRIPTION
	{
		DWORD				flags;					//Icon flags to display with description
		DWORD				size;					//compressed total size of package
		DWORD				downloadTime;			//time to download @ 28,800
		PUID				dependency;				//display dependency link
		PWU_VARIABLE_FIELD	pv;						//variable length fields associated with this description file
	} WU_DESCRIPTION, *PWU_DESCRIPTION;

	#define BITMASK_GLOBAL_INDEX		0		//index of global bitmask
	#define BITMASK_OEM_DEFAULT			1		//index of default OEM bitmask

	#define BITMASK_ID_OEM				((BYTE)1)	//BITMASKID entry is an OEM id
	#define BITMASK_ID_LOCALE			((BYTE)2)	//BITMASKID entry is a LOCALE id

	//The bitmask file is arranged as a series of bit bitmasks in the same order as
	//the oem and langauge ids. For example if DELL1 was the second id in the id
	//array section of the bitmask file then is bitmask would begin the third bitmask
	//in the bitmask section of the file. The reason that it is the third and not
	//second is that the first bitmask is always the global bitmask and there is no
	//corrisponding id field for the global mask as this mask is always present.

	//A bitmask OEM or LOCALE id is a DWORD.

	typedef DWORD BITMASKID;
	typedef DWORD *PBITMASKID;

	typedef struct _BITMASK
	{
		int	iRecordSize;	//number of bits in a single bitmask record
		int iBitOffset;		//offset to bitmap bits in bytes
		int	iOemCount;		//Total number of oem ids in bitmask
		int	iLocaleCount;	//Total number of locale ids in bitmask
		int	iPlatformCount;	//Total number of platforms defined.

		#pragma warning( disable : 4200 )
			BITMASKID	bmID[];		//OEM & LANGAUGE & future types arrays.
		#pragma warning( default : 4200 )

		//since there are one or more array of OEM & LANGAUGE types this needs to be
		//a pointer and will need to be manually set to the correct location when the
		//bitmask file is created or read.

		PBYTE GetBitsPtr(void) { return ((PBYTE)this+iBitOffset); }		//beginning of bitmask bit arrays
		PBYTE GetBitMaskPtr(int index) { return GetBitsPtr() + ((iRecordSize+7)/8) * index; }

	} BITMASK, *PBITMASK;

	//catalog list

	#define	CATLIST_STANDARD			((DWORD)0x00)	
	#define CATLIST_CRITICALUPDATE		((DWORD)0x01)	
	#define CATLIST_DRIVERSPRESENT		((DWORD)0x02)	

	typedef struct _CATALOGLIST
	{
		DWORD dwPlatform;
		DWORD dwCatPuid;
		DWORD dwFlags;
	} CATALOGLIST, *PCATALOGLIST;

	#pragma pack()

	//bitmask helper macros
	//returns 1 if bit is set 0 if bit is not set
	inline bool GETBIT(PBYTE pbits, int index) { return (pbits[(index/8)] & (0x80 >> (index%8))) != 0; }

	//sets requested bit to 1
	inline void SETBIT(PBYTE pbits, int index) { pbits[index/8] |= (0x080 >> (index%8)); }
	
	//clears requested bit to 0
	inline void CLRBIT(PBYTE pbits, int index) { pbits[index/8] &= (0xff ^ (0x080 >> (index%8))); }

	//These values are written into the bitmask.plt file as the platform ids. When additional
	//platforms are added we will need to add a new enumeration value here.
	//
	//IMPORTANT NOTE!!! 
	//  This definition must be consistant with osdet.cpp detection as well as with the database
	typedef enum
	{
		enV3_DefPlat = 0,
		enV3_W95IE5 = 1,
		enV3_W98IE4 = 2,
		enV3_W98IE5 = 3,
		enV3_NT4IE5X86 = 4,
		enV3_NT4IE5ALPHA = 5,
		enV3_NT5IE5X86 = 6,
		//enV3_NT5IE5ALPHA = 7,
		enV3_NT4IE4ALPHA = 8,
		enV3_NT4IE4X86 = 9,
		enV3_W95IE4 = 10,
		enV3_MILLENNIUMIE5 = 11,
		enV3_W98SEIE5 = 12,
		//enV3_NEPTUNEIE5 = 13,
		enV3_NT4IE5_5X86 = 14,
		enV3_W95IE5_5 = 15,
		enV3_W98IE5_5 = 16,
		enV3_NT5IE5_5X86 = 17,
		enV3_Wistler = 18,
		enV3_Wistler64 = 19,
		enV3_NT5DC = 20,
	} enumV3Platform;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\bucket.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   bucket.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      CDM bucket related functions
//
//=======================================================================

#include <windows.h>
#include <ole2.h>
#include <setupapi.h>
#include <tchar.h>
#include <atlconv.h>

#include <wustl.h>
#include <wuv3cdm.h>
#include <bucket.h>
#include <findoem.h>
#include <DrvInfo.h>
#define LOGGING_LEVEL 1
#include <log.h>

#include "cdmlibp.h"

PUID CDM_FindUpdateInBucket(
	IN LPCTSTR szHardwareIdFromDevice, IN FILETIME* pftInstalled,
	IN LPBYTE pBucket, IN int cbBucket, IN LPBYTE pBitmask, 
	OUT PDRIVER_MATCH_INFO pDriverMatchInfo
) {
	LOG_block("CDM_FindUpdateInBucket");
	LOG_out("szHardwareIdFromDevice = %s", szHardwareIdFromDevice);

	USES_CONVERSION;

	// Driver for update
	PUID puid = 0;
	FILETIME ftLatest;
	for(
		LPBYTE pEnd = pBucket + cbBucket;
		pBucket < pEnd;
		pBucket += ((PCDM_RECORD_HEADER)pBucket)->cnRecordLength
	) {
		PCDM_RECORD_HEADER pRecord = (PCDM_RECORD_HEADER)pBucket;

		// Should not be masked
		if (!GETBIT(pBitmask, pRecord->nBitmaskIdx))
		{
			LOG_out("puid %d Masked out", pRecord->puid);
			continue;
		}
			
		// Hadware ID has to match
		LPCSTR szHardwareId = (LPCSTR)pBucket + sizeof(CDM_RECORD_HEADER);
		if (0 != lstrcmpi(szHardwareIdFromDevice, A2T(const_cast<char*>(szHardwareId))))
		{
			LOG_out("puid %d HardwareID %s doesn't match device", pRecord->puid, A2T(const_cast<char*>(szHardwareId)));
			continue;
		}
		// Skip all this - we don't need it now
		LPCSTR szDescription = szHardwareId + strlen(szHardwareId) + 1;
		LPCSTR szMfg = szDescription + strlen(szDescription) + 1;
		LPCSTR szProvider = szMfg + strlen(szMfg) + 1;
		LPCSTR szDriverVer = szProvider + strlen(szProvider) + 1;
		LPCSTR szCabFileTitle = szDriverVer + strlen(szDriverVer) + 1;

		FILETIME ftDriver = {0,1};
		DriverVer2FILETIME(A2T(const_cast<char*>(szDriverVer)), ftDriver); // don't check driver ver

		// Check if this one is the latest on the site
		if (0 != puid && CompareFileTime(&ftDriver, &ftLatest) <= 0)
		{
//			#ifdef _WUV3TEST
				SYSTEMTIME stDriver;
 				FileTimeToSystemTime(&ftDriver, &stDriver);
				SYSTEMTIME stLatest;
 				FileTimeToSystemTime(&ftLatest, &stLatest);
				LOG_out("puid %d (DriverVer=%2d/%02d/%4d) is not the latest (DriverVer=%2d/%02d/%4d)",
					pRecord->puid, (int)stDriver.wMonth, (int)stDriver.wDay, (int)stDriver.wYear, 
					(int)stLatest.wMonth, (int)stLatest.wDay, (int)stLatest.wYear
				);
//			#endif
			continue;
		}

		// Check if it's later then installed
		if (pftInstalled && CompareFileTime(&ftDriver, pftInstalled) <= 0)
		{
//			#ifdef _WUV3TEST
				SYSTEMTIME stDriver;
 				FileTimeToSystemTime(&ftDriver, &stDriver);
				SYSTEMTIME stDriverInstalled;
 				FileTimeToSystemTime(pftInstalled, &stDriverInstalled);
				LOG_out("puid %d (DriverVer=%2d/%02d/%4d) isn't later then installed (DriverVer=%2d/%02d/%4d)",
					pRecord->puid, (int)stDriver.wMonth, (int)stDriver.wDay, (int)stDriver.wYear, 
					(int)stDriverInstalled.wMonth, (int)stDriverInstalled.wDay, (int)stDriverInstalled.wYear
				);
//			#endif
			continue;
		}
		
		// got a match
		puid = pRecord->puid;
		pDriverMatchInfo->pszHardwareID		= szHardwareId;	
		pDriverMatchInfo->pszDescription	= szDescription;
		pDriverMatchInfo->pszMfgName		= szMfg;	
		pDriverMatchInfo->pszProviderName	= szProvider;
		pDriverMatchInfo->pszDriverVer		= szDriverVer;	
		pDriverMatchInfo->pszCabFileTitle	= szCabFileTitle;

		ftLatest = ftDriver;

//		#ifdef _WUV3TEST
			SYSTEMTIME stDriver;
 			FileTimeToSystemTime(&ftDriver, &stDriver);
			LOG_out("puid %d (DriverVer=%2d/%02d/%4d) is the latest",
				pRecord->puid, (int)stDriver.wMonth, (int)stDriver.wDay, (int)stDriver.wYear
			);
//		#endif
	}
	if (puid)
		LOG_out("UPDATE FOUND puid %d for %s", puid, szHardwareIdFromDevice);
	return puid;
}

PUID CDM_FindInstalledInBucket(
	IN IDrvInfo* pDrvInfo, IN LPCTSTR szHardwareIdInstalled,
	IN LPBYTE pBucket, IN int cbBucket, IN LPBYTE pBitmask, 
	OUT PDRIVER_MATCH_INFO pDriverMatchInfo
) {
	LOG_block("CDM_FindInstalledInBucket");
	LOG_out("szHardwareIdInstalled = %s", szHardwareIdInstalled);

	USES_CONVERSION;

	FILETIME ftDriverInstalled = {0,0};
	if (!pDrvInfo->GetDriverDate(ftDriverInstalled))
	{
		LOG_error("!pDrvInfo->GetDriverDate(ftDriverInstalled)");
		return NULL;
	}

	for(
		LPBYTE pEnd = pBucket + cbBucket;
		pBucket < pEnd;
		pBucket += ((PCDM_RECORD_HEADER)pBucket)->cnRecordLength
	) {
		PCDM_RECORD_HEADER pRecord = (PCDM_RECORD_HEADER)pBucket;

		// Should not be masked
		if (!GETBIT(pBitmask, pRecord->nBitmaskIdx))
		{
			LOG_out("puid %d masked out", pRecord->puid);
			continue;
		}

		// Hadware ID has to match
		LPCSTR szHardwareId = (LPCSTR)pBucket + sizeof(CDM_RECORD_HEADER);
		if (0 != lstrcmpi(szHardwareIdInstalled, A2T(const_cast<char*>(szHardwareId))))
		{
			LOG_out("puid %d HardwareID %s doesn't match installed", pRecord->puid, A2T(const_cast<char*>(szHardwareId)));
			continue;
		}
		LPCSTR szDescription = szHardwareId + strlen(szHardwareId) + 1;
		LPCSTR szMfg = szDescription + strlen(szDescription) + 1;
		LPCSTR szProvider = szMfg + strlen(szMfg) + 1;
		LPCSTR szDriverVer = szProvider + strlen(szProvider) + 1;
		FILETIME ftDriver = {0,1};
		DriverVer2FILETIME(A2T(const_cast<char*>(szDriverVer)), ftDriver);

		LPCSTR szCabFileTitle = szDriverVer + strlen(szDriverVer) + 1;

		// Check if it's later then installed
		if (0 != CompareFileTime(&ftDriver, &ftDriverInstalled))
		{
//			#ifdef _WUV3TEST
				SYSTEMTIME stDriver;
 				FileTimeToSystemTime(&ftDriver, &stDriver);
				SYSTEMTIME stDriverInstalled;
 				FileTimeToSystemTime(&ftDriverInstalled, &stDriverInstalled);
				LOG_out("puid %d (DriverVer=%2d/%02d/%4d) isn't the same as installed (DriverVer=%2d/%02d/%4d)",
					pRecord->puid, (int)stDriver.wMonth, (int)stDriver.wDay, (int)stDriver.wYear, 
					(int)stDriverInstalled.wMonth, (int)stDriverInstalled.wDay, (int)stDriverInstalled.wYear
				);
//			#endif
			continue;
		}

		// got a match
		pDriverMatchInfo->pszHardwareID		= szHardwareId;	
		pDriverMatchInfo->pszDescription	= szDescription;
		pDriverMatchInfo->pszMfgName		= szMfg;	
		pDriverMatchInfo->pszProviderName	= szProvider;
		pDriverMatchInfo->pszDriverVer		= szDriverVer;	
		pDriverMatchInfo->pszCabFileTitle	= szCabFileTitle;

		LOG_out("INSTALLED FOUND puid %d for %s", pRecord->puid, szHardwareIdInstalled);
		return pRecord->puid;
	}
	return 0;
}


//These functions form a hash lookup for hwIDs.
static ULONG HashFunction(
	IN ULONG seed	//Seed value to use for hashing hwid.
) {
	ULONG	q;
	ULONG	r;
	ULONG	a;
	ULONG	m;
	ULONG	val;

	q = 127773L;
	r = 2836L;
	a = 16807L;
	m = 2147483647;

	val = ((seed % q) * a) - (seed / q) * r;

	if(((long)val) <= 0)
		val = val + m;

	return val;
}


//These functions form a hash lookup for hwIDs.
ULONG CDM_HwID2Hash(
	IN LPCTSTR szHwID,	//Hardware id being hashed.
	IN ULONG iTableSize	//Size of downloaded hash table.
) {
	if (0 == iTableSize)
		return 0; // error

	ULONG	ulHashIndex = 1;
	while(*szHwID)
	{
		ulHashIndex = ulHashIndex + HashFunction(ulHashIndex + (ULONG)(INT_PTR)CharUpper((LPTSTR)*szHwID));
		szHwID++;
	}

	return (ulHashIndex % iTableSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\diamond.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   diamond.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      Diamond decompressor implementation
//
//=======================================================================
#include <windows.h>
#include <shlwapi.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <tchar.h>
#include <atlconv.h>

#include <wustl.h>
//#define LOGGING_LEVEL 3
//#include <log.h>

#include <diamond.h>


//Note: The use of statics means that this code is not thread safe. It also means that
//this code can only perform 1 decompression at a time. I think that I may need to
//rewrite this to be callable from multiple places as it may end up that CDM and
//Active Setup both need to access this class at the same time.

CHInfoArray CDiamond::s_handles;
byte_buffer* CDiamond::s_pbufIn = NULL;			
byte_buffer* CDiamond::s_pbufOut = NULL;			

CDiamond::CDiamond(
	void
) :
	m_hfdi(0)
{
	ZeroMemory(&m_erf, sizeof(ERF));

	m_hfdi = FDICreate(DEXMemAlloc, DEXMemFree, DEXFileOpen, DEXFileRead, DEXFileWrite, DEXFileClose, DEXFileSeek, cpu80386, &m_erf);
	
}

CDiamond::~CDiamond(
	void
) {

	if (NULL != m_hfdi)
		FDIDestroy(m_hfdi);
}

bool CDiamond::IsValidCAB
(
	IN byte_buffer& bufIn	// Mem buffer in
) {
	//LOG_block("CDiamond::IsValidCAB");

	s_pbufIn = &bufIn;

	int hf = DEXFileOpen("?", _O_RDWR, 0);
	if ((INT_PTR)INVALID_HANDLE_VALUE == hf)
		return FALSE;

	FDICABINETINFO	fdici;
	bool bRc = TRUE == FDIIsCabinet(m_hfdi, hf, &fdici);

	DEXFileClose(hf);

	return bRc;
}

bool CDiamond::IsValidCAB(
	IN LPCTSTR szCabPath
) {
	//LOG_block("CDiamond::IsValidCAB");

	USES_CONVERSION;

	int hf = DEXFileOpen(T2A(const_cast<TCHAR*>(szCabPath)), _O_RDWR, 0);
	if ((INT_PTR)INVALID_HANDLE_VALUE == hf)
		return FALSE;

	FDICABINETINFO	fdici;
	bool bRc = TRUE == FDIIsCabinet(m_hfdi, hf, &fdici);

	DEXFileClose(hf);

	return bRc;
}

bool CDiamond::Decompress(
	IN LPCTSTR szFileIn,		// Full path to input cab file.
	IN LPCTSTR szFileOut
) {
	SetInput(szFileIn);
	SetOutput(szFileOut);
	return DoDecompress();
}

bool CDiamond::Decompress(
	IN LPCTSTR szFileIn,		// Full path to input cab file.
	IN byte_buffer& bufOut	// Mem buffer out
) {
	SetInput(szFileIn);
	SetOutput(bufOut);
	return DoDecompress();
}

bool CDiamond::Decompress(
	IN byte_buffer& bufIn,	// Mem buffer in
	IN LPCTSTR szFileOut
) {
	SetInput(bufIn);
	SetOutput(szFileOut);
	return DoDecompress();
}

bool CDiamond::Decompress(
	IN byte_buffer& bufIn,	// Mem buffer in
	IN byte_buffer& bufOut	// Mem buffer out
) {
	SetInput(bufIn);
	SetOutput(bufOut);
	return DoDecompress();
}

bool CDiamond::DoDecompress(
	void
) {
	//LOG_block("CDiamond::DoDecompress");

	USES_CONVERSION;

	const static TCHAR szQuestion[] =  _T("?");

	TCHAR szCabinet[MAX_PATH] = {0}; 
	TCHAR szCabPath[MAX_PATH] = {0};
	if (NULL != m_szFileIn)
	{
		lstrcpy(szCabinet, PathFindFileName(m_szFileIn));
		lstrcpy(szCabPath, m_szFileIn);
		PathRemoveFileSpec(szCabPath);
		PathAddBackslash(szCabPath);
	}
	else
	{
		lstrcpy(szCabinet, szQuestion);
	}

	if (NULL == m_szFileOut)
		m_szFileOut = szQuestion;

	//LOG_out("FDICopy(szCabinet= %s, szCabPath = %s)", szCabinet, szCabPath);
	return TRUE == FDICopy(m_hfdi, T2A(szCabinet), T2A(szCabPath), 0, Notification, NULL, this);
}


void *DIAMONDAPI CDiamond::DEXMemAlloc(
	ULONG cb
) {
	return malloc(cb);
}

void DIAMONDAPI CDiamond::DEXMemFree(
	void HUGE *pv
) {
	free(pv);
}

BOOL CreatePath(LPCTSTR pszPath)
{
    if (CreateDirectory(pszPath, NULL) || GetLastError() == ERROR_ALREADY_EXISTS)
		return TRUE;
	TCHAR* pcLastSlash = _tcsrchr(pszPath, _T('\\'));
	if (NULL == pcLastSlash)
		return FALSE;
    *pcLastSlash = 0;
	if (!CreatePath(pszPath))
		return FALSE;
    *pcLastSlash = _T('\\');
    return CreateDirectory(pszPath, NULL);
}

INT_PTR DIAMONDAPI CDiamond::DEXFileOpen(
	char *pszFile, 
	int oflag, 
	int pmode
) {

	USES_CONVERSION;

	HANDLEINFO hinfo;
	ZeroMemory(&hinfo, sizeof(HANDLEINFO));

	//if the file name begins with an invalid ? character then we have
	//an in memory operation.
	hinfo.offset	= 0L;	//Set memory file pointer to beginning of file
	hinfo.handle = INVALID_HANDLE_VALUE; // It will stay that way if it's in memory operation

	if ('?' != pszFile[0]) // if not in memory op
	{
		if (oflag & _O_CREAT)
		{
			// file to be opened for write.
			// Make sure that path exists
			TCHAR szPath[MAX_PATH];
			lstrcpy(szPath, A2T(pszFile));
			PathRemoveFileSpec(szPath);
			CreatePath(szPath);
			hinfo.handle = CreateFile(A2T(pszFile), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		}
		else
		{
			//file to be opened for reading.
			hinfo.handle = CreateFile(A2T(pszFile), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		}
		if (hinfo.handle == INVALID_HANDLE_VALUE)
			return (INT_PTR)INVALID_HANDLE_VALUE;
	}
	return s_handles.add(hinfo) + 1;
}

UINT DIAMONDAPI CDiamond::DEXFileRead(
	INT_PTR hf, 
	void *pv, 
	UINT cb
) {
	//LOG_block("CDiamond::DEXFileRead");

	HANDLEINFO& rhinfo = s_handles[hf-1];
	ULONG cnLength = -1;

	//if this is a file read operation use normal 32 bit I/O
	if (rhinfo.handle == INVALID_HANDLE_VALUE)
	{
		// we have an in memory operation and need to copy the requested data.
		//Note: while we would like to avoid even this memory copy we can't since
		//the diamond libary is allocating an internal read buffer.
		byte_buffer& rbuf = *s_pbufIn;
		if (rhinfo.offset + cb < rbuf.size())
			cnLength = cb;
		else
			cnLength = rbuf.size() - rhinfo.offset;

		if ((int)cnLength > 0)
		{
			memcpy(pv, (LPBYTE)rbuf + rhinfo.offset, cnLength);
			rhinfo.offset += cnLength;
		}
		else
		{
			cnLength = 0;
		}
	}
	else
	{
		// this is a file read operation use normal 32 bit I/O
        (void)ReadFile(rhinfo.handle, pv, cb, &cnLength, NULL);
		//if( !ReadFile(rhinfo.handle, pv, cb, &cnLength, NULL))
		//	LOG_error("ReadFile - GetLastError() = %d", ::GetLastError());
	}

	return cnLength;
}

UINT DIAMONDAPI CDiamond::DEXFileWrite(
	INT_PTR hf, 
	void *pv, 
	UINT cb
) {
	//LOG_block("CDiamond::DEXFileWrite");

	HANDLEINFO& rhinfo = s_handles[hf-1];
	ULONG cnLength = -1;

	if (rhinfo.handle == INVALID_HANDLE_VALUE)
	{
		//Since we can dynamically increase the output buffer array and also
		//access it in the normal C++ way though a pointer writes are very easy
		//we simply need to make sure that there is sufficient space in the
		//output buffer, get a pointer to the current file offset and memcpy
		//the new data into the file buffer.
		byte_buffer& rbuf = *s_pbufOut;
		if (rbuf.size() < rhinfo.offset + cb)
		{
			rbuf.resize(rhinfo.offset + cb);
			if (!rbuf.valid()) 
				return 0;
		}
		memcpy((LPBYTE)rbuf + rhinfo.offset, pv, cb);

		rhinfo.offset += cb;

		cnLength = cb;
	}
	else
	{
		// this is a file write operation use normal 32 bit I/O
        (void)WriteFile(rhinfo.handle, pv, cb, &cnLength, NULL);
		//if( !WriteFile(rhinfo.handle, pv, cb, &cnLength, NULL))
			//LOG_error("WriteFile - GetLastError() = %d", ::GetLastError());
	}
	return cnLength;
}

long DIAMONDAPI CDiamond::DEXFileSeek(
	INT_PTR hf, 
	long dist, 
	int seektype
) {

	HANDLEINFO& rhinfo = s_handles[hf-1];


	//Since we are using 32 bit file io we need to remap the seek method
	DWORD dwMoveMethod;
	switch (seektype)
	{
		case SEEK_CUR:
			dwMoveMethod = FILE_CURRENT;
			break;
		case SEEK_END:
			dwMoveMethod = FILE_END;
			break;
		case SEEK_SET:
		default:
			dwMoveMethod = FILE_BEGIN;
			break;
	}

	//if this is a file read operation use normal 32 bit I/O
	if (rhinfo.handle != INVALID_HANDLE_VALUE)
		return SetFilePointer(rhinfo.handle, dist, NULL, dwMoveMethod);

	//else we need to interpret the seek based on the type

	switch (dwMoveMethod)
	{
		case FILE_CURRENT:
			rhinfo.offset += dist;
			break;
		case FILE_END:
			rhinfo.offset -= dist;
			break;
		case FILE_BEGIN:
		default:
			rhinfo.offset = dist;
			break;
	}

	return rhinfo.offset;
}

int DIAMONDAPI CDiamond::DEXFileClose(
	INT_PTR hf
) {

	HANDLEINFO& rhinfo = s_handles[hf-1];

	//if this is a file operation close the file handle and make the
	//internal handle structure available for use.
	if (rhinfo.handle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(rhinfo.handle);
	}

	//If this is a write buffer then we exit and let the Decompress
	//function take care of allocating and copying the data back
	//to the caller if necessary.
	s_handles.remove(hf-1);
	return 0;
}

INT_PTR __cdecl CDiamond::Notification(
	FDINOTIFICATIONTYPE fdiNotifType, 
	PFDINOTIFICATION pfdin
) {

	USES_CONVERSION;

	switch (fdiNotifType)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			return 0;
		case fdintNEXT_CABINET: // file continued to next cabinet
		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			return 0;
		case fdintCOPY_FILE:    // file to be copied, returns 0 = skip, -1 = abort, else file handle
		case fdintCLOSE_FILE_INFO:
			break;
		default:
			return 0;
	}

	CDiamond	*pDiamond = (CDiamond *)pfdin->pv;

	// prepare output file name
	TCHAR szFileOut[MAX_PATH];
	if (pDiamond->m_szFileOut[0] == _T('*'))
	{
		//Special case where the caller has asked for all files in the cab to
		//be expanded. In this case we need to construct an output file name
		//for this imput file.
		lstrcpy(szFileOut, pDiamond->m_szFileIn);
		PathRemoveFileSpec(szFileOut);
		PathAppend(szFileOut, A2T(pfdin->psz1));
	}
	else if (StrChr(pDiamond->m_szFileOut, _T('*')))
	{
		lstrcpy(szFileOut, pDiamond->m_szFileOut);
		PathRemoveFileSpec(szFileOut);
		PathAppend(szFileOut, A2T(pfdin->psz1));
	}
	else
	{
		lstrcpy(szFileOut, pDiamond->m_szFileOut);
	}

	// two cases we want to do
	if (fdintCOPY_FILE == fdiNotifType)
	{
		return pDiamond->DEXFileOpen(T2A(szFileOut), _O_CREAT | _O_BINARY | _O_TRUNC | _O_RDWR, _S_IREAD | _S_IWRITE);

	}
	else // fdintCLOSE_FILE_INFO == fdiNotifType
	{
		pDiamond->DEXFileClose(pfdin->hf);
		if( '?' != pfdin->psz1[0])
		{
			auto_hfile hFile = CreateFile(
				szFileOut,
				GENERIC_READ | GENERIC_WRITE,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL
			);
			if (hFile.valid()) 
			{
				FILETIME ftLocal;
				FILETIME ftUTC;
				SetFileAttributes(szFileOut, FILE_ATTRIBUTE_NORMAL);
				if (DosDateTimeToFileTime(pfdin->date, pfdin->time, &ftLocal) &&
					LocalFileTimeToFileTime(&ftLocal, &ftUTC))
				{
					SetFileTime(hFile, NULL, NULL, &ftUTC);
				}
			}
		}
		return 1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\cdmlibp.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmlibp.h
//
//  Owner:  YanL
//
//  Description:
//
//      Private header for CDMLIB.lib
//
//=======================================================================

#ifndef _CDMLIBP_H
	
	#define REGKEY_WUV3TEST		_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test")
	bool DriverVer2FILETIME(LPCTSTR szDate, FILETIME& ftDate);// Date has to be in format mm-dd-yyyy or mm/dd/yyyy
	#define _CDMLIBP_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\download.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   download.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      Internet download implementation
//
//=======================================================================
#include <windows.h>
#include <wininet.h>
#include <shlwapi.h>
#include <tchar.h>

#include <wustl.h>
#define LOGGING_LEVEL 2
#include <log.h>

#include <download.h>

static void InfiniteWaitForSingleObject(HANDLE hHandle);

CDownload::CDownload(
	IN OPTIONAL int cnMaxThreads /*= 1*/
) :
	m_cnMaxThreads(min(cnMaxThreads, MAX_THREADS_LIMIT)),
	m_cnThreads(0)
{
	LOG_block("CDownload::CDownload");
	
	// syncronization
	m_hEventExit	= CreateEvent(NULL, /*bManualReset*/ TRUE, /*bInitialState*/ FALSE, NULL);
	m_hEventJob		= CreateEvent(NULL, /*bManualReset*/ TRUE, /*bInitialState*/ FALSE, NULL);
	m_hEventDone	= CreateEvent(NULL, /*bManualReset*/ FALSE, /*bInitialState*/ FALSE, NULL);
	
	m_hSession = InternetOpen(_T("Windows Update Catalog"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
}
	
CDownload::~CDownload(
	void
) {
	LOG_block("CDownload::~CDownload");
	
	if (m_cnThreads)
	{
		// Wait for all threads to exit:
		HANDLE ahThreads[MAX_THREADS_LIMIT];
		for (int i = 0; i < m_cnThreads; i ++)
			ahThreads[i] = m_ahThreads[i];
		SetEvent(m_hEventExit);
		WaitForMultipleObjects(m_cnThreads, ahThreads, /*bWaitAll*/TRUE, INFINITE);
	}
	// to insure that m_hConnection is released before m_hSession
	m_hConnection.release(); 
	m_hSession.release(); 
}

bool CDownload::Connect(
	IN LPCTSTR szURL
) {
	LOG_block("CDownload::Connect");

	// check that constructor created everything we need
	if (
		!m_hEventExit.valid()	||
		!m_hEventJob.valid()	||
		!m_hEventDone.valid()	||  
		!m_hSession.valid()	
	) {
		return false;
	}

	// check parameters
	if (NULL == szURL)
		return false;

	// Prepare to crack URL
	URL_COMPONENTS url; 
	ZeroMemory(&url, sizeof(url)); 
	url.dwStructSize = sizeof(url); 

	TCHAR szServerName[INTERNET_MAX_HOST_NAME_LENGTH];
	url.lpszHostName = szServerName;
	url.dwHostNameLength = sizeOfArray(szServerName);

	m_szRootPath[0] = 0;
	url.lpszUrlPath = m_szRootPath;
	url.dwUrlPathLength = sizeOfArray(m_szRootPath);

	TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
	url.lpszUserName = szUserName;
	url.dwUserNameLength = sizeOfArray(szUserName);

	TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
	url.lpszPassword = szPassword;
	url.dwPasswordLength = sizeOfArray(szPassword);

	if (!InternetCrackUrl(szURL, 0, 0, &url))
	{
		LOG_error("InternetCrackUrl(%s) failed, last error %d", szURL, GetLastError());
		return false;
	}
	if (url.nScheme != INTERNET_SCHEME_HTTP && url.nScheme != INTERNET_SCHEME_HTTPS)
	{
		LOG_error("http or https only");
		return false;
	}
	if (_T('/') == m_szRootPath[lstrlen(m_szRootPath) - 1])
		m_szRootPath[lstrlen(m_szRootPath) - 1] = 0;
	LOG_out("connecting to %s at %s", szServerName, m_szRootPath);
	
	m_hConnection = InternetConnect(m_hSession, szServerName, url.nPort, szUserName, szPassword, INTERNET_SERVICE_HTTP, 0, 1);
	return m_hConnection.valid();
}

bool CDownload::Copy(IN LPCTSTR	szSourceFile, IN LPCTSTR	szDestFile, IN OPTIONAL IDownloadAdviceSink* pSink /*= 0*/)
{
	LOG_block("CDownload::Copy");
	JOB job = {	szSourceFile, szDestFile, 0, NO_ERROR, 0  };
	CopyEx(&job, 1, pSink);
	SetLastError(job.dwResult);
	return NO_ERROR == job.dwResult || ERROR_ALREADY_EXISTS == job.dwResult ? true : false;
}

bool CDownload::Copy(IN LPCTSTR	szSourceFile, IN byte_buffer& bufDest, IN OPTIONAL IDownloadAdviceSink* pSink /*= 0*/)
{
	LOG_block("CDownload::Copy");
	JOB job = {	szSourceFile, 0, &bufDest, NO_ERROR, 0 };
	CopyEx(&job, 1, pSink);
	SetLastError(job.dwResult);
	return NO_ERROR == job.dwResult || ERROR_ALREADY_EXISTS == job.dwResult ? true : false;
}

void CDownload::CopyEx(IN PJOB pJobs, IN int cnJobs, IN OPTIONAL IDownloadAdviceSink* pSink /*= 0*/, IN bool fWaitComplete /*= true*/)
{
	LOG_block("CDownload::CopyEx");

	// Init jobs queue
	m_pJobsQueue = pJobs;
	m_cnJobsTotal = cnJobs;
	m_cnJobsToComplete = cnJobs;
	m_nJobTop = 0;
	
	// init status
	m_pSink = pSink;

	// Create more threads if we need to
	int cnThreadsNeed = min(m_cnMaxThreads, cnJobs);
	while (m_cnThreads < cnThreadsNeed)
	{
		DWORD dwThreadId;
		m_ahThreads[m_cnThreads] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)StaticThreadProc, this, 0, &dwThreadId);
		if (!m_ahThreads[m_cnThreads].valid())
			break;
		m_cnThreads ++;
	}

	if (0 == m_cnThreads) // No threads to work on
	{
		// This case is only if we are in new device wizard on 98
		DWORD dwError = GetLastError();
		LOG_out("No thread to work on (last error = %d), will work on the main one", dwError);

		// turn proxy autodetection off
		INTERNET_PER_CONN_OPTION option = { INTERNET_PER_CONN_FLAGS, 0 };
		INTERNET_PER_CONN_OPTION_LIST list = { sizeof(INTERNET_PER_CONN_OPTION_LIST), 0, 1, 0, &option };
		DWORD dwBufLen = sizeof(list);
		
		BOOL fQueryOK = InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufLen);
		DWORD dwConnFlags = option.dwOption;
		if (fQueryOK)
		{
			option.dwOption &= ~PROXY_TYPE_AUTO_DETECT;
			InternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, sizeof(list));
		}

		while (m_nJobTop < m_cnJobsTotal)
		{
			DoJob(m_nJobTop);
			m_nJobTop ++;
		}

		// restore proxy autodetection
		if (fQueryOK)
		{
			option.dwOption = dwConnFlags;
			InternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, sizeof(list));
		}
	}
	else
	{
		// Normal case

		// Start
		ResetEvent(m_hEventDone);
		SetEvent(m_hEventJob);

		// Wait for all jobs to complete
		if (fWaitComplete)
		{
			while(0 < m_cnJobsToComplete) 
				InfiniteWaitForSingleObject(m_hEventDone);
		}
	}
	
}

DWORD WINAPI CDownload::StaticThreadProc(IN LPVOID lpParameter)
{
	// just call member function so we can access members
	CDownload* pThis = static_cast<CDownload*>(lpParameter);
	pThis->ThreadProc();
	return 0;
}

void CDownload::ThreadProc()
{
	LOG_block("CDownload::ThreadProc");
	HANDLE ahevents[2] = { (HANDLE)m_hEventJob, (HANDLE)m_hEventExit };
	while(true)
	{
		// wait for job or exit
		DWORD dwRet = WaitForMultipleObjects(2, ahevents, FALSE, INFINITE);
		if (WAIT_OBJECT_0+1 == dwRet)
		{
			return; // called to exit
		}
		else if (WAIT_OBJECT_0 == dwRet)
		{
			int nJob = m_lock.Increment(&m_nJobTop) - 1;
			if (nJob < m_cnJobsTotal)			// Job is waiting
			{
				DoJob(nJob);

				// Increment complete counter
				m_lock.Decrement(&m_cnJobsToComplete);
				SetEvent(m_hEventDone);
			}
			else
			{
				ResetEvent(m_hEventJob); // queue is empty
			}
		}
	}
}

void CDownload::DoJob(int nJob)
{
	LOG_block("CDownload::DoJob");

	DWORD dwStartTime;
	if (NULL != m_pSink)
	{
		m_pSink->JobStarted(nJob);// Notify start

		if (NO_ERROR != m_pJobsQueue[nJob].dwResult) // this will inforce abort on all jobs
		{
			LOG_error("Job result is set to %d", m_pJobsQueue[nJob].dwResult);
			m_pSink->JobDone(nJob);
			return;
		}
		
		if (m_pSink->WantToAbortJob(nJob)) // this will inforce abort on all jobs
		{
			LOG_error("Job %d aborted", nJob);
			m_pJobsQueue[nJob].dwResult = ERROR_OPERATION_ABORTED;
			m_pSink->JobDone(nJob);
			return;
		}
		
		dwStartTime = GetTickCount(); // for progress
	}
	//Make Full path
	TCHAR szFullSourcePath[MAX_PATH];
	lstrcpy(szFullSourcePath, m_szRootPath);
	lstrcat(szFullSourcePath, _T("/"));
	lstrcat(szFullSourcePath, m_pJobsQueue[nJob].pszSrvFile);
	
	// Do one of two copy functions
	if (NULL != m_pJobsQueue[nJob].pszDstFile)
	{
		m_pJobsQueue[nJob].dwResult = DoCopyToFile(nJob, szFullSourcePath, m_pJobsQueue[nJob].pszDstFile);	// to  file
	}
	else
	{
		m_pJobsQueue[nJob].dwResult = DoCopyToBuf(nJob, szFullSourcePath, *(m_pJobsQueue[nJob].pDstBuf));	// to buffer
	}

	if (NULL != m_pSink)
	{
		if (NO_ERROR == m_pJobsQueue[nJob].dwResult)
			m_pSink->JobDownloadTime(nJob, GetTickCount() - dwStartTime); // only if success
		m_pSink->JobDone(nJob);
	}
}

DWORD CDownload::DoCopyToFile(
	IN int nJob, // for notifications
	IN LPCTSTR szSourceFile,
	IN LPCTSTR szDestFile
) {
	LOG_block("CDownload::DoCopyToFile");
	LOG_out("source %s, destination %s", szSourceFile, szDestFile);

	// If destination file exist let see if we even need to download - compare it's date and size with server
	FILETIME ftLocal = {0};
	SYSTEMTIME stLocal = {0};
	auto_hfile hFileOut = CreateFile(szDestFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFileOut.valid()) 
	{
		GetFileTime(hFileOut, NULL, NULL, &ftLocal);
 		FileTimeToSystemTime(&ftLocal, &stLocal);
	}

	auto_hinet hInetFile;
	DWORD dwServerFileSize;
	SYSTEMTIME stServer;
	DWORD dwError = OpenInetFile(szSourceFile, hFileOut.valid() ? &stLocal: 0, hInetFile, &dwServerFileSize, &stServer);
	if (NO_ERROR != dwError)
	{
		if (ERROR_ALREADY_EXISTS != dwError)
			LOG_error("OpenInetFile failed %d", dwError);
		return dwError;
	}

	if (NULL != m_pSink)
		m_pSink->JobDownloadSize(nJob, dwServerFileSize);// Notify start

	// get server file time to compare with existing local and timestamp it if replaced
	FILETIME ftServer = {0};
 	SystemTimeToFileTime(&stServer, &ftServer);

	// If destination file exist let see if we even need to download - compare it's date and size with server
	if (hFileOut.valid()) 
	{
//#ifdef _WUV3TEST
		DWORD dwLocalFileSize = GetFileSize(hFileOut, NULL);
		LOG_out("'%s' \t server (%d bytes) %2d/%02d %2d:%02d:%02d:%03d \t local (%d bytes) %2d/%02d %2d:%02d:%02d:%03d", szSourceFile,
			dwServerFileSize, (int)stServer.wMonth, (int)stServer.wDay, (int)stServer.wHour, (int)stServer.wMinute, (int)stServer.wSecond, (int)stServer.wMilliseconds,
			dwLocalFileSize, (int)stLocal.wMonth, (int)stLocal.wDay, (int)stLocal.wHour, (int)stLocal.wMinute, (int)stLocal.wSecond, (int)stLocal.wMilliseconds
		);
//#endif
		hFileOut.release();
	}

	// coping through 8K buffer
	byte_buffer bufTmp;
	bufTmp.resize(min(dwServerFileSize, 8 * 1024)); // use 8K buffer
	if (!bufTmp.valid())
	{
		LOG_error("Out of memory");
		return ERROR_NOT_ENOUGH_MEMORY;
	}

	hFileOut = CreateFile(szDestFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	return_error_if_false(hFileOut.valid());

	dwError = NO_ERROR;
	DWORD dwFileWritten	= 0;
	while(dwFileWritten < dwServerFileSize)
	{
		DWORD dwReadStartTime;
		if (NULL != m_pSink)
		{
			if (m_pSink->WantToAbortJob(nJob))
			{
				LOG_error("Job %d aborted", nJob);
				dwError = ERROR_OPERATION_ABORTED;
				break;
			}
			dwReadStartTime = GetTickCount(); // for progress
		}

		DWORD dwNeedToRead = dwServerFileSize - dwFileWritten;
		dwNeedToRead = min(dwNeedToRead, bufTmp.size());

		DWORD dwReadSize;
		if (!InternetReadFile(hInetFile, bufTmp, dwNeedToRead, &dwReadSize))
		{
			dwError = GetLastError();
			LOG_error("InternetReadFile(hInetFile... failed %d", dwError);
			break;
		}

		DWORD dwWritten;
		if (!WriteFile(hFileOut, bufTmp, dwReadSize, &dwWritten, NULL))
		{
			dwError = GetLastError();
			LOG_error("WriteFile(hFileOut... failed %d", dwError);
			break;
		}
		dwFileWritten += dwReadSize;
		if (NULL != m_pSink)
			m_pSink->BlockDownloaded(nJob, dwReadSize, GetTickCount() - dwReadStartTime);
	}

	if(dwError)
	{
		hFileOut.release();
		DeleteFile(szDestFile); // file is not complete
		return dwError;
	}

	// timestamp destination file
	SetFileTime(hFileOut, NULL, NULL, &ftServer);
	
	return NO_ERROR;
}

DWORD CDownload::DoCopyToBuf(
	IN int nJob, // for notifications
	IN LPCTSTR szSourceFile,
	IN byte_buffer& bufDest
) {
	LOG_block("CDownload::DoCopyToBuf");
	LOG_out("source %s", szSourceFile);

	auto_hinet hInetFile;
	DWORD dwServerFileSize;
	DWORD dwError = OpenInetFile(szSourceFile, NULL, hInetFile, &dwServerFileSize, NULL);
	if (NO_ERROR != dwError)
	{
		if (ERROR_ALREADY_EXISTS != dwError)
			LOG_error("OpenInetFile failed %d", dwError);
		return dwError;
	}

	if (NULL != m_pSink)
		m_pSink->JobDownloadSize(nJob, dwServerFileSize);// Notify start

	bufDest.resize(dwServerFileSize);
	if (!bufDest.valid())
	{
		LOG_error("Out of memory");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	
	DWORD dwReadSize;
	return_error_if_false(InternetReadFile(hInetFile, bufDest, dwServerFileSize, &dwReadSize));
	return NO_ERROR;
}

// commont part for both downloads
DWORD CDownload::OpenInetFile(
	LPCTSTR	szFullSourcePath,
	SYSTEMTIME* pstIfModifiedSince,
	auto_hinet& hInetFile,
	DWORD* pdwServerFileSize,
	SYSTEMTIME*	pstServer
) {
	LOG_block("CDownload::OpenInetFile");
	hInetFile = HttpOpenRequest(m_hConnection, NULL, szFullSourcePath, _T("HTTP/1.0"), NULL, NULL, INTERNET_FLAG_DONT_CACHE|INTERNET_FLAG_KEEP_CONNECTION, 1);
	return_error_if_false(hInetFile.valid());

	if (pstIfModifiedSince) // local file exist co send If-Modified-Since: header
	{
	    TCHAR szHttpTime[INTERNET_RFC1123_BUFSIZE + 1];
		DWORD dwSize = sizeof(szHttpTime);
        return_error_if_false(InternetTimeFromSystemTime(pstIfModifiedSince, INTERNET_RFC1123_FORMAT, szHttpTime, dwSize));

		//prepare and set the header
		static const TCHAR szFormat[] = _T("If-Modified-Since: %s\r\n");
		TCHAR szHeader[INTERNET_RFC1123_BUFSIZE + sizeOfArray(szFormat)];
		wsprintf(szHeader, szFormat, szHttpTime);
		return_error_if_false(HttpAddRequestHeaders(hInetFile, szHeader, -1L, HTTP_ADDREQ_FLAG_ADD));
	}

	return_error_if_false(HttpSendRequest(hInetFile, NULL, 0, NULL, 0));

	DWORD dwStatus;
	DWORD dwLength = sizeof(dwStatus);
	return_error_if_false(HttpQueryInfo(hInetFile, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, &dwStatus, &dwLength, NULL));

	if (HTTP_STATUS_NOT_MODIFIED == dwStatus)
	{
		LOG_out("file '%s' is the same as on server", szFullSourcePath);
		return ERROR_ALREADY_EXISTS;
	}
	else if (HTTP_STATUS_OK != dwStatus)
	{
		LOG_error("file '%s' is not found", szFullSourcePath);
		return ERROR_FILE_NOT_FOUND;
	}
	dwLength = sizeof(DWORD);
	return_error_if_false(HttpQueryInfo(hInetFile, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_CONTENT_LENGTH, pdwServerFileSize, &dwLength, NULL));

	if (0 == *pdwServerFileSize)
	{	// 0 length files are not supported
		LOG_error("file '%s' is 0 length", szFullSourcePath);
		return ERROR_FILE_NOT_FOUND;
	}

	if (pstServer)
	{
		dwLength = sizeof(SYSTEMTIME);
		return_error_if_false(HttpQueryInfo(hInetFile, HTTP_QUERY_FLAG_SYSTEMTIME  | HTTP_QUERY_LAST_MODIFIED, pstServer, (ULONG *)&dwLength, NULL));
	}
	return NO_ERROR;
}

// wait forever until hHandle signals
static void InfiniteWaitForSingleObject(
	HANDLE hHandle
) {
	while (WAIT_OBJECT_0 + 1 == MsgWaitForMultipleObjects(1, &hHandle, FALSE, INFINITE, QS_ALLINPUT))
	{
		// Process messasges
		MSG msg;
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\findoem.cpp ===
/*** findoem.cpp - OEM detection interface
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/08/98
 *
 *  MODIFICATION HISTORY
 */

//#define _WIN32_WINNT 0x0400
#include <comdef.h>
#include <windows.h>
#include <ole2.h>
#include <stdlib.h>
#include <wbemcli.h>
#include <tchar.h>
#include <atlconv.h>

#include <wustl.h>

#include "cdmlibp.h"

// Smart pointers
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

// hardcodes - not defined in any header
const CLSID CLSID_WbemLocator = {0x4590f811,0x1d3a,0x11d0,{0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24}};

#include "try_catch.h"

#include "findoem.h"

#define BYTEOF(d,i)	(((BYTE *)&(d))[i])

/*** That will let me to include file into queryoem and avoid having additional dll
 */
extern HMODULE GetModule();

/*** Local function prototypes
 */
static void UseOeminfoIni(POEMINFO pOemInfo);
static void UseWBEM(POEMINFO pOemInfo);
static bool ReadFromReg(POEMINFO pOemInfo);
static void SaveToReg(POEMINFO pOemInfo);

/*** Registry access
 */
static const TCHAR REGSTR_KEY_OEMINFO[]		= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\OemInfo");
static const TCHAR REGSTR_VAL_MASK[]			= _T("Mask");
static const TCHAR REGSTR_VAL_ACPIOEM[]		= _T("AcpiOem");
static const TCHAR REGSTR_VAL_ACPIPRODUCT[]	= _T("AcpiProduct");
static const TCHAR REGSTR_VAL_SMBOEM[]		= _T("SmbOem");
static const TCHAR REGSTR_VAL_SMBPRODUCT[]	= _T("SmbProduct");
static const TCHAR REGSTR_VAL_PNPOEMID[]		= _T("PnpOemId");
static const TCHAR REGSTR_VAL_INIOEM[]		= _T("IniOem");
static const TCHAR REGSTR_VAL_WBEMOEM[]		= _T("WbemOem");
static const TCHAR REGSTR_VAL_WBEMPRODUCT[]	= _T("WbemProduct");
static const TCHAR REGSTR_VAL_OEMINFO_VER[]	= _T("OemInfoVersion");	// used to determine if we need to nuke old values


//
//	Increment REG_CURRENT_OEM_VER whenever you need to force override of
//	old values written to the OemInfo key. Doesn't need to change for each
//	new control version.
//
#define REG_CURRENT_OEM_VER	1

/*** GetMachinePnPID - Find IDs corresponding to Make and Model code
 *
 *  ENTRY
 *      PSZ szTable
 *		Table format is 
 *
 *		|##| ... |##|00|##|##|##|##|
 *		|           |  |           |
 *		  OEM Model  \0    PnP ID   
 *
 *		|00|00|00|00|
 *		|           |
 *           00000
 *
 *  EXIT
 *      PnP ID  or 0
 */
DWORD GetMachinePnPID(PBYTE pbTable)
{
	USES_CONVERSION;

	LPTSTR sz = (LPTSTR)DetectMachineID();
	LPSTR szMnM = T2A(sz);
	if (NULL == szMnM)
	{
		return 0;
	}
	while (*pbTable)
	{
		PDWORD pId = (PDWORD)(pbTable + strlen((LPSTR)pbTable) + 1); // Skip code position on IDs
		if (0 == strcmp((LPSTR)pbTable, szMnM))
			return *pId;
		pbTable = (PBYTE)(pId + 1); // Skip last 0
	}
	return 0;
}

/*** DetectMachineID - Gather all available machine OEM and model information nad return ID
 *
 *  EXIT
 *		returns ID
 */
LPCTSTR DetectMachineID(bool fAlwaysDetectAndDontSave /*= false*/)
{
	OEMINFO oi;
	GetOemInfo(&oi, fAlwaysDetectAndDontSave);
	return MakeAndModel(&oi);
}


/*** MakeAndModel - Return ID for a machine
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *		returns ID
 */
LPCTSTR MakeAndModel(POEMINFO pOemInfo)
{
	static TCHAR szMnM[256];

#ifdef _WUV3TEST
	auto_hkey hkey;
	if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
		DWORD dwLangID = 0;
		DWORD dwSize = sizeof(szMnM);
		if (NO_ERROR == RegQueryValueEx(hkey, _T("MachineID"), 0, 0, (LPBYTE)szMnM, &dwSize))
		{
		return szMnM;
		}
	}
#endif

	szMnM[0] = 0;
	if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
	{
		lstrcpy(szMnM, pOemInfo->szWbemOem);
		lstrcat(szMnM, _T(" "));
		lstrcat(szMnM, pOemInfo->szWbemProduct);
		lstrcat(szMnM, _T(";"));
	}
	else if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
	{
		lstrcat(szMnM, pOemInfo->szIniOem);
		lstrcat(szMnM, _T(";"));
	}
	return szMnM;
}


/*** GetOemInfo - Gather all available machine OEM and model information
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void GetOemInfo(POEMINFO pOemInfo, bool fAlwaysDetectAndDontSave /*= false*/)
{
	// Worst case:
	memset(pOemInfo, 0, sizeof(OEMINFO)); 

	// Do detection if necessary or requested
	if (fAlwaysDetectAndDontSave || ! ReadFromReg(pOemInfo))
	{
		UseWBEM(pOemInfo);
		UseOeminfoIni(pOemInfo);
		// Save info to the registry
		if (!fAlwaysDetectAndDontSave)
		{
			SaveToReg(pOemInfo);
		}
	}
}

/***LP	IsValidStringID - check if string ID is valid
 *
 *  ENTRY
 *	pszID pOemInfo-> Pnp ID string
 *
 *  EXIT-SUCCESS
 *			returns TRUE
 *  EXIT-FAILURE
 *			returns FALSE
 */

BOOL IsValidStringID(PSZ pszID)
{

    return (strlen(pszID) == 7) &&
		isupper(pszID[0]) && isupper(pszID[1]) && isupper(pszID[2]) &&
		isxdigit(pszID[3]) && isxdigit(pszID[4]) && isxdigit(pszID[5]) && isxdigit(pszID[6]);
}	//IsValidStringID

/***LP  NumericID - convert string ID to numeric ID
 *
 *  ENTRY
 *      psz pOemInfo-> PnP ID string
 *
 *  EXIT
 *      returns numeric ID
 */

DWORD NumericID(PSZ psz)
{
    DWORD dwID;
    WORD wVenID;
	int i;
    for (i = 0, wVenID = 0; i < 3; ++i)
    {
		wVenID <<= 5;
		wVenID |= (psz[i] - 0x40) & 0x1f;
    }
    dwID = strtoul(&psz[3], NULL, 16);
    dwID = ((dwID & 0x00ff) << 8) | ((dwID & 0xff00) >> 8);
    dwID <<= 16;
    dwID |= (wVenID & 0x00ff) << 8;
    dwID |= (wVenID & 0xff00) >> 8;
    return dwID;
}       //NumericID

/***LP  StringID - convert numeric ID to string ID
 *
 *  ENTRY
 *      dwID - numeric PnP ID
 *
 *  EXIT
 *      returns string ID
 */

PSZ StringID(DWORD dwID)
{
	static char szID[8];
    WORD wVenID;
    int i;

	wVenID = (WORD)(((dwID & 0x00ff) << 8) | ((dwID & 0xff00) >> 8));
	wVenID <<= 1;

	for (i = 0; i < 3; ++i)
	{
		szID[i] = (char)(((wVenID & 0xf800) >> 11) + 0x40);
		wVenID <<= 5;
	}
	wVenID = HIWORD(dwID);
	wVenID = (WORD)(((wVenID & 0x00ff) << 8) | ((wVenID & 0xff00) >> 8));
	for (i = 6; i > 2; --i)
	{
		szID[i] = (char)(wVenID & 0x000F);
		if(szID[i] > 9)
		{
			szID[i] += 0x37; // 'A' - 0xA	for digits A to F
		}
		else
		{
			szID[i] += 0x30; // '0'			for digits 0 to 9
		}
		wVenID >>= 4;
	}
    return szID;
} //StringID


/*** UseOeminfoIni - get OemInfo from OEMINFO.INI
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void UseOeminfoIni(POEMINFO pOemInfo)
{
	USES_CONVERSION;

	static const TCHAR szFile[]		= _T("OEMINFO.INI");
	static const TCHAR szSection[]	= _T("General");
	static const TCHAR szKey[]		= _T("Manufacturer");
	TCHAR szPath[MAX_PATH];
	// WU Bug# 11921 -- OEMINFO.INI is in system directory not Windows directory 
	if (GetSystemDirectory(szPath, sizeOfArray(szPath)) > 0)
	{
		// check for "c:\"
		if (szPath[lstrlen(szPath)-1] != '\\')
		{
			lstrcat(szPath, _T("\\"));
		}
		lstrcat(szPath, szFile);
		GetPrivateProfileString(szSection, szKey, _T(""), 
			pOemInfo->szIniOem, sizeOfArray(pOemInfo->szIniOem), szPath);
		if (lstrlen(pOemInfo->szIniOem))
		{
			pOemInfo->dwMask |= OEMINFO_INI_PRESENT;
		}
   }
}

/*** UseWBEM - Get info through WBEM access
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void UseWBEM(POEMINFO pOemInfo)
{
	try_block 
	{

		USES_CONVERSION;
		
		// Create Locator
		IWbemLocatorPtr pWbemLocator;
		throw_hr(pWbemLocator.CreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER));
		
		// Get services
		IWbemServicesPtr pWbemServices;
		throw_hr(pWbemLocator->ConnectServer(bstr_t(L"\\\\.\\root\\cimv2"), NULL, NULL, 0L, 0L, NULL, NULL, &pWbemServices));
        throw_hr(CoSetProxyBlanket(pWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE));

		// Create enumerator
		IEnumWbemClassObjectPtr pEnum;
		throw_hr(pWbemServices->CreateInstanceEnum(bstr_t(L"Win32_ComputerSystem"), 0, NULL, &pEnum));
        throw_hr(CoSetProxyBlanket(pEnum, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE));

		// Get our object now
		ULONG uReturned = 1;
		IWbemClassObjectPtr pObject;
		throw_hr(pEnum->Next(
                6000,           // timeout in two seconds
                1,              // return just one storage device
                &pObject,		// pointer to storage device
                &uReturned));	// number obtained: one or zero

		variant_t var;
		throw_hr(pObject->Get(L"Manufacturer", 0L, &var, NULL, NULL));
		if (VT_BSTR == var.vt)
		{
			lstrcpy(pOemInfo->szWbemOem, W2T(var.bstrVal));
		}
		throw_hr(pObject->Get(L"Model", 0L, &var, NULL, NULL));
		if (VT_BSTR == var.vt) 
		{
			lstrcpy(pOemInfo->szWbemProduct, W2T(var.bstrVal));
		}
		if (0 != lstrlen(pOemInfo->szWbemOem) || 0 != lstrlen(pOemInfo->szWbemProduct))
		{
			pOemInfo->dwMask |= OEMINFO_WBEM_PRESENT;
		}
	} catch_all;
}

/*** ReadFromReg - read OEMINFO from registry
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      true if info is present
 *		false otherwise
 */
bool ReadFromReg(POEMINFO pOemInfo)
{
	DWORD dwVersion = 0;
	//read registry first
	auto_hkey hkeyOemInfo;
	if	(NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_KEY_OEMINFO, 0, KEY_READ, &hkeyOemInfo))
	{
		DWORD dwCount = sizeof(pOemInfo->dwMask);	
		RegQueryValueEx(hkeyOemInfo, REGSTR_VAL_MASK, 0, 0, (LPBYTE)&(pOemInfo->dwMask), &dwCount);
		
		//
		// ***** WU Bug# 11921 *****
		//
		
		//
		//	No bits set requires detection
		//
		if(!pOemInfo->dwMask)
			return false;

		//
		//	If an older version of the detection wrote the OemInfo return false to force detection.
		//	This value is written starting with 1 around August 2000 for the Classic control.
		//
		dwCount = sizeof(dwVersion);
		if (NO_ERROR == RegQueryValueEx(hkeyOemInfo, REGSTR_VAL_OEMINFO_VER, 0, 0, (LPBYTE)&dwVersion, &dwCount))
		{
			if(REG_CURRENT_OEM_VER > dwVersion)
				return false;
		}
		else
		{
			return false;
		}

		//
		// ***** end WU Bug *****
		//

		if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
		{
			dwCount = sizeof(pOemInfo->szIniOem);	
			RegQueryValueEx(hkeyOemInfo, REGSTR_VAL_INIOEM, 0, 0, (LPBYTE)&(pOemInfo->szIniOem), &dwCount);
		}
		if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
		{
			dwCount = sizeof(pOemInfo->szWbemOem);	
			RegQueryValueEx(hkeyOemInfo, REGSTR_VAL_WBEMOEM, 0, 0, (LPBYTE)&(pOemInfo->szWbemOem), &dwCount);
			dwCount = sizeof(pOemInfo->szWbemProduct);	
			RegQueryValueEx(hkeyOemInfo, REGSTR_VAL_WBEMPRODUCT, 0, 0, (LPBYTE)&(pOemInfo->szWbemProduct), &dwCount);
		}
		return true;
	}
	else
	{
		return false;
	}
}

/*** SaveToReg - Save OEMINFO
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      none
 */
void SaveToReg(POEMINFO pOemInfo)
{
	DWORD dwDisp;
	DWORD dwVersion = REG_CURRENT_OEM_VER;
	auto_hkey hkeyOemInfo;
	if	(NO_ERROR == RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_KEY_OEMINFO, 0, NULL, 
		REG_OPTION_NON_VOLATILE, KEY_WRITE, 0, &hkeyOemInfo, &dwDisp))
	{
		RegSetValueEx(hkeyOemInfo, REGSTR_VAL_MASK, 0, REG_DWORD, (LPBYTE)&(pOemInfo->dwMask), sizeof(pOemInfo->dwMask));

		//
		//	Write the current version so future controls can check version of detection that wrote this key.
		//	WU RAID # 11921
		//
		RegSetValueEx(hkeyOemInfo, REGSTR_VAL_OEMINFO_VER, 0, REG_DWORD, (LPBYTE)&dwVersion, sizeof(dwVersion));

		if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
		{
			RegSetValueEx(hkeyOemInfo, REGSTR_VAL_INIOEM, 0, REG_SZ, 
				(LPBYTE)&(pOemInfo->szIniOem), (lstrlen(pOemInfo->szIniOem) + 1) * sizeof(TCHAR));
		}
		if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
		{
			RegSetValueEx(hkeyOemInfo, REGSTR_VAL_WBEMOEM, 0, REG_SZ, 
				(LPBYTE)&(pOemInfo->szWbemOem),(lstrlen(pOemInfo->szWbemOem) + 1) * sizeof(TCHAR));
			RegSetValueEx(hkeyOemInfo, REGSTR_VAL_WBEMPRODUCT, 0, REG_SZ, 
				(LPBYTE)&(pOemInfo->szWbemProduct), (lstrlen(pOemInfo->szWbemProduct) + 1) * sizeof(TCHAR));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\drvinfo.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   DrvInfo.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      Implementation of device enumeration
//
//=======================================================================

#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <regstr.h>
#include <devguid.h>
#include <tchar.h>
//#include <atlconv.h>

#include <wustl.h>
#include <DrvInfo.h>
#define LOGGING_LEVEL 2
#include <log.h>

#include "cdmlibp.h"

#define DEVICE_INSTANCE_SIZE    128

//*********************************************************************************//
// Global UNICODE<>ANSI translation helpers
//*********************************************************************************//

#include <malloc.h>	// for _alloca


#define USES_CONVERSION int _convert = 0; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	//
	lpw[0] = '\0';
	MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	//
	lpa[0] = '\0';
	WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

#define A2W(lpa) (\
		((_lpa = lpa) == NULL) ? NULL : (\
			_convert = (lstrlenA(_lpa)+1),\
			AtlA2WHelper((LPWSTR)_alloca(_convert*2), _lpa, _convert, CP_ACP)))

#define W2A(lpw) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (lstrlenW(_lpw)+1)*2,\
			AtlW2AHelper((LPSTR)_alloca(_convert), _lpw, _convert, CP_ACP)))
#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))
#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(LPTSTR lp) { return lp; }
	inline LPTSTR W2T(LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(LPTSTR lp) { return lp; }
	inline LPTSTR A2T(LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif
#define OLE2T(p) W2T(p)
#define T2OLE(p) T2W(p)

#ifdef _WUV3TEST

// Check the registry to see if we have been called to fake
static bool FakeDetection()
{
	auto_hkey hkey;
	DWORD dwFake = 0;
	DWORD dwSize = sizeof(dwFake);
	if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
		RegQueryValueEx(hkey, _T("UseIni"), 0, 0, (LPBYTE)&dwFake, &dwSize);
	}
	return 1 == dwFake;
}

#endif

static bool CanOpenInf(LPCTSTR szInfFile);
static bool DriverVerFromInf(LPCTSTR szInfFile, LPCTSTR szMfg, LPCTSTR szDesc, LPTSTR szValue/*size_is(256)*/);
static bool IsOriginalFile(LPCTSTR szInfFile);


// Implementation that gets real devices quering DevMan
class CRealDrvInfo : public IDrvInfo
{
protected:
	tchar_buffer m_sDevInstID;
	auto_hdevinfo m_hDevInfo;
	SP_DEVINFO_DATA m_DevInfoData;
	FILETIME m_ftDriverDate;

protected:
	bool GetPropertySetupDi(ULONG ulProperty, tchar_buffer& bufHardwareIDs);
	bool GetPropertyReg(LPCTSTR szProperty, tchar_buffer& bufHardwareIDs);
	bool LatestDriverFileTime(LPCTSTR szInfFile, LPCTSTR szMfgName, LPCTSTR szDescription, 
		LPCTSTR szProvider, FILETIME& ftDate);

	virtual bool Init(LPCTSTR szDevInstID)
	{
		LOG_block("CRealDrvInfo::Init");
		LOG_out("[%s]", szDevInstID);

		m_hDevInfo = (HDEVINFO)SetupDiCreateDeviceInfoList(NULL, NULL);
		return_if_false(m_hDevInfo.valid()) ;

		ZeroMemory(&m_DevInfoData, sizeof(SP_DEVINFO_DATA));

		m_DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

		return_if_false(SetupDiOpenDeviceInfo(m_hDevInfo, szDevInstID, 0, 0, &m_DevInfoData)) ;

		m_sDevInstID.resize(lstrlen(szDevInstID) + 1);
		if (!m_sDevInstID.valid()) return false;
		lstrcpy(m_sDevInstID, szDevInstID);
		m_ftDriverDate.dwHighDateTime = -1;
		return true;
	}

public:
	virtual bool GetDeviceInstanceID(tchar_buffer& bufDeviceInstanceID) 
	{
		bufDeviceInstanceID.resize(m_sDevInstID.size());
		if (!bufDeviceInstanceID.valid()) return false;
		lstrcpy(bufDeviceInstanceID, m_sDevInstID);
		return true;
	}
	virtual bool HasDriver()
	{
		tchar_buffer bufDriver;
		return GetPropertySetupDi(SPDRP_DRIVER, bufDriver);
	}
	virtual bool IsPrinter()
	{
		return IsEqualGUID(m_DevInfoData.ClassGuid, GUID_DEVCLASS_PRINTER) ? true : false;
	}
	virtual bool GetAllHardwareIDs(tchar_buffer& bufHardwareIDs);
	virtual bool GetHardwareIDs(tchar_buffer& bufHardwareIDs)
	{
		return GetPropertySetupDi(SPDRP_HARDWAREID, bufHardwareIDs);
	}
	virtual bool GetCompatIDs(tchar_buffer& bufHardwareIDs)
	{
		return GetPropertySetupDi(SPDRP_COMPATIBLEIDS, bufHardwareIDs);
	}

	virtual bool GetMatchingDeviceId(tchar_buffer& bufMatchingDeviceId)
	{
		return GetPropertyReg(REGSTR_VAL_MATCHINGDEVID, bufMatchingDeviceId);
	}
	virtual bool GetManufacturer(tchar_buffer& bufMfg)
	{
		return GetPropertySetupDi(SPDRP_MFG, bufMfg);
	}
	virtual bool GetProvider(tchar_buffer& bufProvider)
	{
		return GetPropertyReg(REGSTR_VAL_PROVIDER_NAME, bufProvider);
	}
	virtual bool GetDescription(tchar_buffer& bufDescription)
	{
		return GetPropertySetupDi(SPDRP_DEVICEDESC, bufDescription);
	}
	virtual bool GetDriverDate(FILETIME& ftDriverDate);
};

#ifdef _WUV3TEST

// Implementation that gets fake devices from wuv3test.ini
class CFakeDrvInfo : public IDrvInfo
{
protected:
	TCHAR m_szDevInstID[MAX_PATH];

protected:
	bool GetString(LPCTSTR szKeyName, tchar_buffer& buf)
	{
		buf.resize(256);
		if (!buf.valid()) return 0;
		return 0 != GetPrivateProfileString(m_szDevInstID, szKeyName, _T(""), buf, 256 / sizeof(TCHAR), _T("wuv3test.ini"));
	}
	virtual bool Init(LPCTSTR szDevInstID)
	{
		lstrcpy(m_szDevInstID, szDevInstID);
		// Lets see if this section exists at all
		tchar_buffer buf;
		return GetString(NULL, buf);
	}

public:
	virtual bool GetDeviceInstanceID(tchar_buffer& bufDeviceInstanceID) 
	{
		bufDeviceInstanceID.resize(lstrlen(m_szDevInstID) + 1);
		if (!bufDeviceInstanceID.valid()) return false;
		lstrcpy(bufDeviceInstanceID, m_szDevInstID);
		return true;
	}
	virtual bool HasDriver()
	{
		tchar_buffer bufMfg;
		return GetString(_T("Manufacturer"), bufMfg);
	}
	virtual bool IsPrinter()
	{
		return false;
	}
	virtual bool GetAllHardwareIDs(tchar_buffer& bufHardwareIDs)
	{
		return GetHardwareIDs(bufHardwareIDs);
	}
	virtual bool GetHardwareIDs(tchar_buffer& bufHardwareIDs)
	{
		return GetString(_T("HardwareIDs"), bufHardwareIDs);
	}
	virtual bool GetCompatIDs(tchar_buffer& bufHardwareIDs)
	{
		return false;
	}
	virtual bool GetMatchingDeviceId(tchar_buffer& bufMatchingDeviceId)
	{
		return GetString(_T("MatchingDeviceId"), bufMatchingDeviceId);
	}
	virtual bool GetManufacturer(tchar_buffer& bufMfg)
	{
		return GetString(_T("Manufacturer"), bufMfg);
	}
	virtual bool GetProvider(tchar_buffer& bufMfg)
	{
		return GetString(_T("Provider"), bufMfg);
	}
	virtual bool GetDescription(tchar_buffer& bufDescription)
	{
		return GetString(_T("Description"), bufDescription);
	}
	virtual bool GetDriverDate(FILETIME& ftDriverDate)
	{
		tchar_buffer bufDriverDate;
		if (!GetString(_T("DriverDate"), bufDriverDate))
			return false;
		return DriverVer2FILETIME(bufDriverDate, ftDriverDate);
	}
};
#endif

// 
// CDrvInfoEnum not inline implementation
// 
bool CDrvInfoEnum::GetDrvInfo(LPCWSTR wszDevInstID, IDrvInfo** ppDrvInfo)
{
	LOG_block("CDrvInfoEnum::GetDrvInfo");

	USES_CONVERSION;

	auto_pointer<IDrvInfo> pDrvInfo;

#ifdef _WUV3TEST
	if ( FakeDetection())
		pDrvInfo = new CFakeDrvInfo;
	else 
#endif
		pDrvInfo = new CRealDrvInfo;

	return_if_false(pDrvInfo.valid());

	return_if_false(pDrvInfo->Init(W2T(const_cast<WCHAR*>(wszDevInstID))));

	*ppDrvInfo = pDrvInfo.detach();
	return true;
}

CDrvInfoEnum::CDrvInfoEnum()
	: m_dwDeviceIndex(0)
{
#ifdef _WUV3TEST
	if (! FakeDetection())
#endif
		m_hDevInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES);
}

bool CDrvInfoEnum::GetNextDrvInfo(IDrvInfo** ppDrvInfo)
{
	LOG_block("CDrvInfoEnum::GetNextDrvInfo");

	auto_pointer<IDrvInfo> pDrvInfo;
	TCHAR szDevInstID[DEVICE_INSTANCE_SIZE];
	if (m_hDevInfoSet.valid()) // real
	{
		SP_DEVINFO_DATA DevInfoData;
		memset(&DevInfoData, 0, sizeof(SP_DEVINFO_DATA));
		DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

		return_if_false(SetupDiEnumDeviceInfo(m_hDevInfoSet, m_dwDeviceIndex, &DevInfoData));

		return_if_false(SetupDiGetDeviceInstanceId(m_hDevInfoSet, &DevInfoData, szDevInstID, sizeof(szDevInstID)/sizeof(szDevInstID[0]), NULL));
		
		pDrvInfo = new CRealDrvInfo;
	}
#ifdef _WUV3TEST
	else // fake
	{
		wsprintf(szDevInstID, _T("Device%d"), (int)m_dwDeviceIndex);
		pDrvInfo = new CFakeDrvInfo;
	}
#endif
	return_if_false(pDrvInfo.valid());
	return_if_false(pDrvInfo->Init(szDevInstID));
	
	m_dwDeviceIndex ++;
	*ppDrvInfo = pDrvInfo.detach();
	return true;
}

// 
// CRealDrvInfo not inline implementation
// 
bool CRealDrvInfo::GetAllHardwareIDs(tchar_buffer& bufHardwareIDs)
{
	if (!GetHardwareIDs(bufHardwareIDs))
		return false;
	tchar_buffer bufCompatIDs;
	if (!GetCompatIDs(bufCompatIDs))
		return true; // no campats

	// find \0\0 in the first buffer
	for (LPTSTR sz = bufHardwareIDs; *sz; sz += lstrlen(sz) + 1);
	int cnOldSize = sz - (LPCTSTR)bufHardwareIDs;
	// NTBUG9#145086 size was increased by byte rather than sizeof(TCHAR)
	bufHardwareIDs.resize(cnOldSize + ((bufCompatIDs.size() + 1) * sizeof(TCHAR))); // I've found a case where there are no \0\0 at the end of compat ID
	sz = bufHardwareIDs; sz += cnOldSize;
	// NTBUG9#145086 size is # chars rather than bytes
	memcpy(sz, bufCompatIDs, bufCompatIDs.size() * sizeof(TCHAR));
	sz[bufCompatIDs.size()] = 0;
	return true;
}

bool CRealDrvInfo::GetDriverDate(FILETIME& ftDriverDate)
{
	LOG_block("CRealDrvInfo::GetDriverDate");

	if (-1 == m_ftDriverDate.dwHighDateTime)
	{
		OSVERSIONINFO	osvi;
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		GetVersionEx(&osvi);

		// Check if we are on new or old schema
		bool fNew =  osvi.dwPlatformId == VER_PLATFORM_WIN32_NT || osvi.dwMajorVersion > 4 || osvi.dwMinorVersion >= 90;
		if (fNew)
		{
			// DriverVer has to be present on NT
			tchar_buffer bufDriverDate;
			return_if_false(GetPropertyReg(REGSTR_VAL_DRIVERDATE, bufDriverDate));
			return_if_false(DriverVer2FILETIME(bufDriverDate, m_ftDriverDate));
		}
		else
		{
			// Get INF File first
			tchar_buffer bufInf;
			return_if_false(GetPropertyReg(REGSTR_VAL_INFPATH, bufInf));

			if (IsOriginalFile(bufInf))
			{
				// on of the original OS drivers
				ZeroMemory(&m_ftDriverDate, sizeof(m_ftDriverDate));
			}
			else
			{
				tchar_buffer bufMfg;
				return_if_false(GetManufacturer(bufMfg));
				tchar_buffer bufDescription;
				return_if_false(GetDescription(bufDescription));
				
				TCHAR szInf[MAX_PATH]; // %systemroot%\inf\other\foo.inf or %systemroot%\inf\foo.inf
				GetWindowsDirectory(szInf, sizeOfArray(szInf));
				PathAppend(szInf, _T("inf\\other"));
				PathAppend(szInf, bufInf);
				if (!CanOpenInf(szInf))
				{
					GetWindowsDirectory(szInf, sizeOfArray(szInf));
					PathAppend(szInf, _T("inf"));
					PathAppend(szInf, bufInf);
					if (!CanOpenInf(szInf))
					{
						LOG_error("Cannot find %s", (LPCTSTR)bufInf);
						return false;
					}
				}
				
				// first try to get it from inf
				tchar_buffer bufDriverDate(256);
				if (DriverVerFromInf(szInf, bufMfg, bufDescription, bufDriverDate))
				{
					return_if_false(DriverVer2FILETIME(bufDriverDate, m_ftDriverDate))
				}
				else // enum files not
				{
					tchar_buffer bufProvider;
					if (!GetProvider(bufProvider))
					{
						bufProvider.resize(1);
						return_if_false(bufProvider.valid());
						lstrcpy(bufProvider, _T(""));
					}
					return_if_false(LatestDriverFileTime(szInf, bufMfg, bufDescription, bufProvider, m_ftDriverDate));
				}
			}
		}

	}
	ftDriverDate = m_ftDriverDate;
	return true;


}

bool CRealDrvInfo::GetPropertySetupDi(ULONG ulProperty, tchar_buffer& buf)
{
	LOG_block("CRealDrvInfo::GetPropertySetupDi");

	ULONG ulSize = 0;
	SetupDiGetDeviceRegistryProperty(m_hDevInfo, &m_DevInfoData, ulProperty, NULL, NULL, 0, &ulSize);
	return_if_false(0 != ulSize);
    // Win98 has a bug when requesting SPDRP_HARDWAREID
    // NTBUG9#182680 We make this big enough to always have a Unicode double-null at the end
    // so that we don't fault if the reg value isn't correctly terminated
	ulSize += 4; 
	buf.resize(ulSize/sizeof(TCHAR));
    buf.zero_buffer(); // NTBUG9#182680 zero the buffer so we don't get random garbage - REG_MULTI_SZ isn't always double-null terminated
	return_if_false(buf.valid());

	return_if_false(SetupDiGetDeviceRegistryProperty(m_hDevInfo, &m_DevInfoData, ulProperty, NULL, (LPBYTE)(LPTSTR)buf, ulSize - 4 , NULL));
	return true;
}

bool CRealDrvInfo::GetPropertyReg(LPCTSTR szProperty, tchar_buffer& buf)
{
	LOG_block("CRealDrvInfo::GetPropertyReg");

	//Open the device's driver key and retrieve the INF from which the driver was installed.
	auto_hkeySetupDi hKey = SetupDiOpenDevRegKey(m_hDevInfo, &m_DevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
	return_if_false(hKey.valid());
	
	ULONG ulSize = 0;
	RegQueryValueEx(hKey, szProperty, NULL, NULL, NULL, &ulSize);
	return_if_false(0 != ulSize);
	buf.resize(ulSize/sizeof(TCHAR));
	return_if_false(buf.valid());
	return_if_false( NO_ERROR == RegQueryValueEx(hKey, szProperty, NULL, NULL, (LPBYTE)(LPTSTR)buf, &ulSize));
	return true;
}

inline bool IsDriver(LPCTSTR szFile)
{
	LPCTSTR szExt = PathFindExtension(szFile);
	if (NULL == szExt)
	{
		return FALSE;
	}

	static const TCHAR* aszExt[] = {
		_T(".sys"),
		_T(".dll"),
		_T(".drv"),
		_T(".vxd"),
	};
	for(int i = 0; i < sizeOfArray(aszExt); i ++)
	{
		if(0 == lstrcmpi(aszExt[i], szExt))
			return true;
	}
	return false;
}

static UINT CALLBACK FileQueueScanCallback(
	IN PVOID pContext,			// setup api context
	IN UINT ulNotification,		// notification message
	IN UINT_PTR ulParam1,				// extra notification message information 1
	IN UINT_PTR /*Param2*/			// extra notification message information 2
) {
	if (SPFILENOTIFY_QUEUESCAN == ulNotification)
	{
		PFILETIME pftDateLatest = (PFILETIME)pContext;
		LPCTSTR szFile = (LPCTSTR)ulParam1; 
		// Is this a binary
		if (IsDriver(szFile)) 
		{
			auto_hfile hFile = CreateFile(szFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			FILETIME ft;
			if (hFile.valid() && GetFileTime(hFile, NULL, NULL, &ft))
			{
//				#ifdef _WUV3TEST
					SYSTEMTIME st;
 					FileTimeToSystemTime(&ft, &st);
					LOG_out1("%s : %2d/%02d/%04d", szFile, (int)st.wMonth, (int)st.wDay, (int)st.wYear);
//				#endif
				if (CompareFileTime(pftDateLatest, &ft) < 0)
					*pftDateLatest = ft;

			}
		}
		else
		{
			LOG_out1("%s : not a driver", szFile);
		}
	}
	return NO_ERROR;
}

bool CRealDrvInfo::LatestDriverFileTime(
	LPCTSTR szInfFile, LPCTSTR szMfgName, LPCTSTR szDescription, LPCTSTR szProvider, FILETIME& ftDate
) {
	LOG_block("CRealDrvInfo::LatestDriverFileTime");

	SP_DEVINSTALL_PARAMS	DeviceInstallParams;
	DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
	return_if_false(SetupDiGetDeviceInstallParams(m_hDevInfo, &m_DevInfoData, &DeviceInstallParams));
	
	lstrcpy(DeviceInstallParams.DriverPath, szInfFile);
	DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;

	return_if_false(SetupDiSetDeviceInstallParams(m_hDevInfo, &m_DevInfoData, &DeviceInstallParams));

	//Now build a class driver list from this INF.
	return_if_false(SetupDiBuildDriverInfoList(m_hDevInfo, &m_DevInfoData, SPDIT_CLASSDRIVER));

	//Prepare driver info struct
	SP_DRVINFO_DATA	DriverInfoData;
	ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));
	DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA_V1); // 98
	DriverInfoData.DriverType	= SPDIT_CLASSDRIVER;
	DriverInfoData.Reserved	= 0;

	lstrcpyn(DriverInfoData.MfgName, szMfgName, LINE_LEN-1);
	lstrcpyn(DriverInfoData.Description, szDescription, LINE_LEN-1);
	lstrcpyn(DriverInfoData.ProviderName, szProvider, LINE_LEN-1);

	return_if_false(SetupDiSetSelectedDriver(m_hDevInfo, &m_DevInfoData, (SP_DRVINFO_DATA*)&DriverInfoData));

	auto_hspfileq hspfileq = SetupOpenFileQueue();
	return_if_false(hspfileq.valid());

	// Set custom queue to device installl params
	return_if_false(SetupDiGetDeviceInstallParams(m_hDevInfo, &m_DevInfoData, &DeviceInstallParams));

	DeviceInstallParams.FileQueue	 = hspfileq;
	DeviceInstallParams.Flags		|= DI_NOVCP;

	return_if_false(SetupDiSetDeviceInstallParams(m_hDevInfo, &m_DevInfoData, &DeviceInstallParams));

	return_if_false(SetupDiInstallDriverFiles(m_hDevInfo, &m_DevInfoData));
	
	// Parce the queue
	FILETIME ftDateTmp = {0,0};
	DWORD dwScanResult;
	return_if_false(SetupScanFileQueue(hspfileq, SPQ_SCAN_USE_CALLBACK, NULL, (PSP_FILE_CALLBACK)FileQueueScanCallback, &ftDateTmp, &dwScanResult));

//#ifdef _WUV3TEST
	SYSTEMTIME st;
 	FileTimeToSystemTime(&ftDateTmp, &st);
	LOG_out("%s - %s %2d/%02d/%04d", szMfgName, szDescription, (int)st.wMonth, (int)st.wDay, (int)st.wYear);
//#endif

	ftDate = ftDateTmp;
	return true;
}

// Date has to be in format mm-dd-yyyy or mm/dd/yyyy
bool DriverVer2FILETIME(LPCTSTR szDate, FILETIME& ftDate)
{
	LOG_block("DriverVer2FILETIME");

	LPCTSTR szMonth = szDate;
	while (*szDate && (*szDate != TEXT('-')) && (*szDate != TEXT('/')))
		szDate++;
	return_if_false(*szDate);

	LPCTSTR szDay = ++ szDate ;
	while (*szDate && (*szDate != TEXT('-')) && (*szDate != TEXT('/')))
		szDate++;
	return_if_false(*szDate);

	++ szDate; 
	SYSTEMTIME SystemTime;
	ZeroMemory(&SystemTime, sizeof(SYSTEMTIME));
	SystemTime.wMonth = (WORD)(short)StrToInt(szMonth);
	SystemTime.wDay = (WORD)(short)StrToInt(szDay);
	SystemTime.wYear = (WORD)(short)StrToInt(szDate);
	return_if_false(SystemTimeToFileTime(&SystemTime, &ftDate));
	return true;
}

static bool GetFirstStringField(HINF hInf, LPCTSTR szSection, LPCTSTR szKey, LPTSTR szValue/*size_is(256)*/)
{
	LOG_block("GetFirstStringField");

	INFCONTEXT ctx;
	return_if_false(SetupFindFirstLine(hInf, szSection, szKey, &ctx));

	return_if_false(SetupGetStringField(&ctx, 1, szValue, 256, NULL));	//Driver section

	return true;
}

static inline bool DriverVerFromInfInstallSection(HINF hInf, LPCTSTR szMfg, LPCTSTR szDesc, LPTSTR szValue/*size_is(256)*/)
{
	LOG_block("DriverVerFromInfInstallSection");
	TCHAR szDeviceSec[256];
	return_if_false(GetFirstStringField(hInf, _T("Manufacturer"), szMfg, szDeviceSec));	// Driver section

	TCHAR szInstallSec[256];
	return_if_false(GetFirstStringField(hInf, szDeviceSec, szDesc, szInstallSec));	// Install section

	return_if_false(GetFirstStringField(hInf, szInstallSec, _T("DriverVer"), szValue));	// DriverVer
	return true;
}

static bool CanOpenInf(LPCTSTR szInfFile)
{
	auto_hinf hInf = SetupOpenInfFile(szInfFile, NULL, INF_STYLE_WIN4, NULL);
	return hInf.valid();
}

static bool DriverVerFromInf(LPCTSTR szInfFile, LPCTSTR szMfg, LPCTSTR szDesc, LPTSTR szValue/*size_is(256)*/)
{
	LOG_block("DriverVerFromInf");

	auto_hinf hInf = SetupOpenInfFile(szInfFile, NULL, INF_STYLE_WIN4, NULL);
	return_if_false(hInf.valid());
	bool fFound = DriverVerFromInfInstallSection(hInf, szMfg, szDesc, szValue) ||
		GetFirstStringField(hInf, _T("Version"), _T("DriverVer"), szValue);

//#ifdef _WUV3TEST
	// RAID# 146771
	if (fFound)
		LOG_out("DriverVerFromInf - %s, return true", szValue);
	else
		LOG_out("DriverVerFromInf, return false");
//#endif
	
	return fFound;
}

static bool IsOriginalFile(LPCTSTR szInfFile)
{
	LOG_block("IsOriginalFile");
	if (0 == szInfFile || 0 == lstrlen(szInfFile))
	{
		LOG_out("empty szInfFile, return false");
	}

	// construct full title
	LPTSTR szInfTitle = PathFindFileName(szInfFile);
	const static LPCTSTR aszLayoutTitle[] = {
		_T("layout.inf"),
		_T("layout1.inf"),
		_T("layout2.inf"),
	};
	for (int i = 0; i < sizeOfArray(aszLayoutTitle); i ++)
	{
		TCHAR szLayout[MAX_PATH];
		if (! GetWindowsDirectory(szLayout, sizeOfArray(szLayout)))
		{
			lstrcat(szLayout, _T("C:\\Windows"));
		}
		PathAppend(szLayout, _T("inf"));
		PathAppend(szLayout, aszLayoutTitle[i]);
		TCHAR szDummy[16];
		if( 0 != GetPrivateProfileString(_T("SourceDisksFiles"), szInfTitle, _T(""), szDummy, sizeOfArray(szDummy), szLayout))
		{
			LOG_out("%s found in %s, return true", szInfFile, szLayout);
			return true;
		}
	}
	LOG_out("%s in not found, return false", szInfFile);
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\sources.inc ===
!IF 0

  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.

  File:   source

  Owner:  YanL

  Description:

      cdmlib.lib sources

!ENDIF

MAJORCOMP =WU
MINORCOMP =cdmlib
TARGETNAME=cdmlib
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
INCLUDES  =.; ..\..\cdminc
USE_STATIC_ATL=1
#we'll define these in the ANSI and UNICODE dirs
#C_DEFINES=/D_UNICODE /DUNICODE
USE_MSVCRT=1

SOURCES   = \
	..\download.cpp  \
	..\diamond.cpp  \
	..\findoem.cpp  \
	..\bucket.cpp   \
	..\DrvInfo.cpp  \
	..\newtrust.cpp \
	..\calccrc.cpp \
	..\usecrc.cpp \
	..\log.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\log.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   log.cpp
//
//  Original Author:  Yan Leshinsky
//
//  Description:
//
//      Logging support implementation
//
//=======================================================================


#if 1

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <atlconv.h>
#include <wustl.h>
#include <log.h>

#include "cdmlibp.h"

const TCHAR* LIVE_LOG_FILENAME = _T("c:\\wuv3live.log");

FILE* CLogger::c_pfile = stdout;
int CLogger::c_cnIndent = 0;
int CLogger::c_cnLevels = -1;

CLogger::CLogger(
	const char* szBlockName /*= 0*/, 
	int nLoggingLevel/*= 0*/, 
	const char* szFileName/*= 0*/, 
	int nLine/*= 0*/
) {
	USES_CONVERSION;

	if (-1 == c_cnLevels)
	{
		c_cnLevels = 0;
		auto_hkey hkey;
		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
			DWORD dwSize = sizeof(c_cnLevels);
			RegQueryValueEx(hkey, _T("LogLevel"), 0, 0, (LPBYTE)&c_cnLevels, &dwSize);
			TCHAR szLogFile[MAX_PATH] = {0};
#ifdef _WUV3TEST
			// RAID# 156253
			dwSize = sizeof(szLogFile);
			RegQueryValueEx(hkey, _T("LogFile"), 0, 0, (LPBYTE)&szLogFile, &dwSize);
#else
			// Hardwire log to root of c: for "Live" controls
			_tcscpy(szLogFile, LIVE_LOG_FILENAME);
#endif
			FILE* pfile = _tfopen(szLogFile, _T("at"));
			if (pfile)
				c_pfile = pfile;
		}
	}
	m_szBlockName[0] = 0;
	m_fOut = nLoggingLevel < c_cnLevels;
	if (m_fOut && NULL != szBlockName) 
	{
		strncpy(m_szBlockName, szBlockName, sizeOfArray(m_szBlockName));
#ifdef _WUV3TEST
		// RAID# 146771
		out("%s %s(%d)", A2T(const_cast<char*>(szBlockName)), A2T(const_cast<char*>(szFileName)), nLine);
#else
		out("%s", A2T(const_cast<char*>(szBlockName)));
#endif
		m_dwStartTick = GetTickCount();
		c_cnIndent ++;
	}
}

CLogger::~CLogger()
{
	USES_CONVERSION;

	if (m_fOut && NULL != m_szBlockName[0]) 
	{
		c_cnIndent --;
		out("~%s (%d msecs)", A2T(const_cast<char*>(m_szBlockName)), GetTickCount() - m_dwStartTick);
	}
}

void __cdecl CLogger::out(const char *szFormat, ...)
{
	if (m_fOut) 
	{
		va_list va;
		va_start (va, szFormat);
		tab_out();
		v_out(szFormat, va);
		va_end (va);
	}
}

void __cdecl CLogger::error(const char *szFormat, ...)
{
	USES_CONVERSION;

	if (m_fOut) 
	{
		va_list va;
		va_start (va, szFormat);
		tab_out();
		_fputts(_T("ERROR - "), c_pfile);
		v_out(szFormat, va);
		va_end (va);
	}
}

void __cdecl CLogger::out1(const char *szFormat, ...)
{
	CLogger logger;
	va_list va;
	va_start (va, szFormat);
	logger.v_out(szFormat, va);
	va_end (va);
}

void CLogger::v_out( const char* szFormat, va_list va)
{
	USES_CONVERSION;
	_vftprintf(c_pfile, A2T(const_cast<char*>(szFormat)), va);
	_fputtc(_T('\n'), c_pfile);
	fflush(c_pfile);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\applog.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    applog.h
//
//  Purpose: Application logging 
//
//  History: 22-Feb-99   YAsmi    Created
//
//=======================================================================

#ifndef _APPLOG_H_
#define _APPLOG_H_


#define LOG_FIELD_SEPARATOR    "|"


class CAppLog
{
public:
	CAppLog(LPCTSTR pszLogFileName = NULL);    
	~CAppLog();

	void SetLogFile(LPCTSTR pszLogFileName);

	//
	// writing
	//
	void Log(LPCSTR pszLogStr);

	//
	// reading
	//
	void StartReading();
	BOOL ReadLine();
	LPCSTR GetLineStr();
	BOOL CopyNextField(LPSTR pszBuf, int cBufSize);
	void StopReading();

	static void FormatErrMsg(HRESULT hr, LPSTR pszBuf, int cBufSize);

	LPCTSTR GetLogFile()
	{
		return m_pszLogFN;
	}

	
private:
	void CheckBuf(DWORD dwSize);

	LPTSTR m_pszLogFN;
	LPSTR m_pszLine;

	LPSTR m_pszBuf;
	DWORD m_dwBufLen;
	LPSTR m_pszFldParse;

	LPSTR m_pFileBuf;
	DWORD m_dwFileOfs;
	DWORD m_dwFileSize;
	
};



#endif // _APPLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\autoupd.h ===
/*
 * autoupd.h - AutoUpdate interface to Windows Update site
 *
 *       Copyright (c) 1999, Microsoft Corporation. All rights reserved.
 *
 */

#ifndef _AUTOUPD_H

	//
	// IAutoUpdate interface
	//
	typedef void (*PFN_QueryDownloadFilesCallback)(void* pCallbackParam, long puid, LPCWSTR pszURL, LPCWSTR pszLocalFile);
	typedef void (*PFN_InstallCallback)(void* pCallbackParam, long puid, int iStatus/*as defined is cstate.h*/, HRESULT hrError);

	#define IAUTOUPDATE_METHODS(IPURE) \
		STDMETHOD(BuildCatalog)(BOOL fGoOnline, DWORD dwType, BSTR bstrServerUrl)IPURE; \
		STDMETHOD(GetPuidsList)(LONG* pcnPuids, long** ppPuids) IPURE; \
		STDMETHOD(QueryDownloadFiles)(long puid, void* pCallbackParam, PFN_QueryDownloadFilesCallback pCallback) IPURE; \
		STDMETHOD(GetCatalogArray)(VARIANT *pCatalogArray) IPURE; \
		STDMETHOD(SelectAllPuids)() IPURE; \
		STDMETHOD(UnselectAllPuids)() IPURE; \
		STDMETHOD(SelectPuid)(long puid) IPURE; \
		STDMETHOD(UnselectPuid)(long puid) IPURE; \
		STDMETHOD(HidePuid)(long puid) IPURE; \
		STDMETHOD(InstallSelectedPuids)(void* pCallbackParam, PFN_InstallCallback pCallback) IPURE; \
		STDMETHOD(CleanupCabsAndReadThis)(void) IPURE; \
		STDMETHOD(UnhideAllPuids)() IPURE; \
		STDMETHOD(StatusReport)(long puid, LPCSTR pszStatus) IPURE; \
		STDMETHOD(DownloadReadThisPage)(long puid) IPURE; \


	class __declspec(novtable) IAutoUpdate : public IUnknown
	{
	public:
		IAUTOUPDATE_METHODS(PURE)
	};

	class __declspec(uuid("C2DD72DC-A77E-48c4-8E16-EB7E9B2812BD")) IAutoUpdate;

	// versa PURE
	#define IMPLEMENTED

	#define _AUTOUPD_H
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\newtrust.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998,1999,2000 Microsoft Corporation.  All Rights Reserved.
//
//  SYSTEM:     Windows Update Critical Fix Notification
//
//  CLASS:      N/A
//  MODULE:     MS Cab Trusting Function Implementation
//  FILE:       Newtrust.CPP
//
/////////////////////////////////////////////////////////////////////
//
//  DESC:   this file implements the functions used by class CTrust
//          these function are copied from inseng.dll of IE5 Active Setup.
//          
//
//  AUTHOR: Alessandro Muti, Windows Update Team
//  DATE:   3/11/1999
//
/////////////////////////////////////////////////////////////////////
//
//  Revision History:
//
//  Date        Author          Description
//  ~~~~        ~~~~~~          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  10/17/2000  Nick Dallett    Porting Charlma's new cert-checking code from SLM tree:
// (8/28/00	    Charles Ma		Rewrite CheckMSCert() function to handle certs with MS root and special cases )
//
/////////////////////////////////////////////////////////////////////
//
//      (c) Copyrights:   1998, 1999, 2000 Microsoft Corporation 
//
//      All rights reserved.
//
//      No portion of this source code may be reproduced
//      without express written permission of Microsoft Corporation.
//
//      This source code is proprietary and confidential.
/////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <urlmon.h>
#include <wintrust.h>
#include <wincrypt.h>
#include <softpub.h>
//#include <atlconv.h>
#include <tchar.h>
#include <wustl.h>

#include "cdmlibp.h"
#include "newtrust.h"

#define LOGGING_LEVEL 3
#include <log.h>

//*********************************************************************************//
// Global UNICODE<>ANSI translation helpers
//*********************************************************************************//

#include <malloc.h>	// for _alloca


#define USES_CONVERSION int _convert = 0; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	//
	lpw[0] = '\0';
	MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
	//
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	//
	lpa[0] = '\0';
	WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

#define A2W(lpa) (\
		((_lpa = lpa) == NULL) ? NULL : (\
			_convert = (lstrlenA(_lpa)+1),\
			AtlA2WHelper((LPWSTR)_alloca(_convert*2), _lpa, _convert, CP_ACP)))

#define W2A(lpw) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (lstrlenW(_lpw)+1)*2,\
			AtlW2AHelper((LPSTR)_alloca(_convert), _lpw, _convert, CP_ACP)))
#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))
#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(LPTSTR lp) { return lp; }
	inline LPTSTR W2T(LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(LPTSTR lp) { return lp; }
	inline LPTSTR A2T(LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif
#define OLE2T(p) W2T(p)
#define T2OLE(p) T2W(p)

/////////////////////////////////////////////////////////////////////////////
// 
// typedefs for APIs used in the CheckTrust() function
//
//      Since some of these APIs are new and only available on IE5 we have to
//      try to dynamicaly use them when available and do without the extra checks
//      when we are on an OS that has not been upgraded to the new crypto code.
//
/////////////////////////////////////////////////////////////////////////////


const TCHAR WINTRUST[] =  _T("wintrust.dll");

const TCHAR CRYPT32[] =  _T("crypt32.dll");

//
// declare a global crypt32.dll library handler, so we don't
// need to load the library every time these functions are called.
// NOTE: we do not release the library though. When the process of
// calling this feature exits, the library is released.
// same as wintrust.dll
//
static HINSTANCE shWinTrustDllInst = NULL;
static HINSTANCE shCrypt32DllInst = NULL;


//
// define prototype for function WinVerifyTrust()
// and declare a global variable to point to this function
//
typedef HRESULT 
(WINAPI * PFNWinVerifyTrust)(
                        HWND hwnd, GUID *ActionID, LPVOID ActionData);
PFNWinVerifyTrust pfnWinVerifyTrust = NULL; 


//
// define prototype for function WTHelperProvDataFromStateData()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_DATA * 
(WINAPI * PFNWTHelperProvDataFromStateData)(
						HANDLE hStateData);
PFNWTHelperProvDataFromStateData pfnWTHelperProvDataFromStateData = NULL;


//
// define prototype for function WTHelperGetProvSignerFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_SGNR * 
(WINAPI * PFNWTHelperGetProvSignerFromChain)(
						CRYPT_PROVIDER_DATA *pProvData,
						DWORD idxSigner,
						BOOL fCounterSigner,
						DWORD idxCounterSigner);
PFNWTHelperGetProvSignerFromChain pfnWTHelperGetProvSignerFromChain = NULL;


//
// define prototype for function PFNWTHelperGetProvCertFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_CERT * 
(WINAPI * PFNWTHelperGetProvCertFromChain)(
						CRYPT_PROVIDER_SGNR *pSgnr,
						DWORD idxCert);
PFNWTHelperGetProvCertFromChain pfnWTHelperGetProvCertFromChain = NULL;


//
// define prototype for function CryptHashPublicKeyInfo()
// and declare a global variable to point to this function
//
typedef BOOL 
(WINAPI * PFNCryptHashPublicKeyInfo)(
						HCRYPTPROV hCryptProv,
						ALG_ID Algid,
						DWORD dwFlags,
						DWORD dwCertEncodingType,
						PCERT_PUBLIC_KEY_INFO pInfo,
						BYTE *pbComputedHash,
						DWORD *pcbComputedHash);
PFNCryptHashPublicKeyInfo pfnCryptHashPublicKeyInfo = NULL;


//
// define prototype for function CertGetCertificateContextProperty()
// and declare a global variable to point to this function
//
typedef BOOL 
(WINAPI * PFNCertGetCertificateContextProperty)(
						PCCERT_CONTEXT pCertContext,          
						DWORD dwPropId,                       
						void *pvData,                         
						DWORD *pcbData);
PFNCertGetCertificateContextProperty pfnCertGetCertificateContextProperty = NULL;



/////////////////////////////////////////////////////////////////////////////
// 
// pre-defined cert data to check against
//
/////////////////////////////////////////////////////////////////////////////

//
// The following is the sha1 key identifier for the Microsoft root
//
static BYTE rgbSignerRootKeyId[20] = {
    0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,
    0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D
};


//
// define the size of each hash values in the known id buffer
// for special certs.
//
//static size_t rgbSpecialCertIdSize[5] = {20, 20, 20, 20, 20};

//
// this is the size of buffer to receive the cert hash value
// it must be not less than the largest number in the
// above-defined array
//
const size_t ShaBufSize = 20;

//
// id buffer to store hash values of all special certs
// Warning: the size of this buffer should match the sum 
// of size_t values defined above.
//
static BYTE rgbSpecialCertId[200] = {
	0xB1,0x59,0xA5,0x2E,0x3D,0xD8,0xCE,0xCD,0x3A,0x9A,0x4A,0x7A,0x73,0x92,0xAA,0x8D,0xA7,0xE7,0xD6,0x7F,	// MS cert
	0xB1,0xC7,0x75,0xE0,0x4A,0x9D,0xFD,0x23,0xB6,0x18,0x97,0x11,0x5E,0xF6,0xEA,0x6B,0x99,0xEC,0x76,0x1D,	// MSN cert
	0x11,0xC7,0x10,0xF3,0xCB,0x6C,0x43,0xE1,0x66,0xEC,0x64,0x1C,0x7C,0x01,0x17,0xC4,0xB4,0x10,0x35,0x30,	// MSNBC cert
	0x95,0x25,0x58,0xD4,0x07,0xDE,0x4A,0xFD,0xAE,0xBA,0x13,0x72,0x83,0xC2,0xB3,0x37,0x04,0x90,0xC9,0x8A,	// MSN Europe
	0x72,0x54,0x14,0x91,0x1D,0x6E,0x10,0x84,0x8E,0x0F,0xFA,0xA0,0xB0,0xA1,0x65,0xBF,0x44,0x8F,0x9F,0x6D,	// MS Europe
	0x20,0x5E,0x48,0x43,0xAB,0xAD,0x54,0x77,0x71,0xBD,0x8D,0x1A,0x3C,0xE0,0xE5,0x9D,0xF5,0xBD,0x25,0xF9,	// Old MS cert: 97~98
	0xD6,0xCD,0x01,0x90,0xB3,0x1B,0x31,0x85,0x81,0x12,0x23,0x14,0xB5,0x17,0xA0,0xAA,0xCE,0xF2,0x7B,0xD5,	// Old MS cert: 98~99
	0x8A,0xA1,0x37,0xF5,0x03,0x9F,0xE0,0x28,0xC9,0x26,0xAA,0x55,0x90,0x14,0x19,0x68,0xFA,0xFF,0xE8,0x1A,	// Old MS cert: 99~00
	0xF3,0x25,0xF8,0x67,0x07,0x29,0xE5,0x27,0xF3,0x77,0x52,0x34,0xE0,0x51,0x57,0x69,0x0F,0x40,0xC6,0x1C,	// Old MS Europe cert: 99~00
    0x6A,0x71,0xFE,0x54,0x8A,0x51,0x08,0x70,0xF9,0x8A,0x56,0xCA,0x11,0x55,0xF6,0x76,0x45,0x92,0x02,0x5A     // Old MS Europe cert: 98~99
    
};



/////////////////////////////////////////////////////////////////////////////
// 
// Private Function ULONG CompareMem(PVOID pBlock1, PVOID pBlock2, ULONG Length)
//
//      This function acts in the same way as RtlCompareMemory() 
//
//
// Input:   two pointers to two memory blocks, and a byte size to compare
// Return:  the number of bytes that compared as equal. 
//			If all bytes compare as equal, the input Length is returned.
//			If any pointer is NULL, 0 is returned.
//
/////////////////////////////////////////////////////////////////////////////
ULONG CompareMem(const BYTE* pBlock1, const BYTE* pBlock2, ULONG Length)
{
	ULONG uLen = 0L;
	if (pBlock1 != NULL && pBlock2 != NULL)
	{
		for (; uLen < Length; uLen++, pBlock1++, pBlock2++)
		{
			if (*pBlock1 != *pBlock2) return uLen;
		}
	}
	return uLen;
}






/////////////////////////////////////////////////////////////////////////////
// 
// Private Function VerifyMSRoot()
//
//      This function takes the passed-in certificate as a root cert,
//		and verifies its public key hash value is the same as 
//		known "Microsoft Root Authority" cert value.
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//			pRootCert - the certificate context of the root cert
//
// Return:  HRESULT - result of execution, S_OK if matched.
//			the result code, in case of error, are code retuned by
//			crypt32.dll, with these the exception of E_INVALIDARG if
//			the passed-in parameters are NULL.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT VerifyMSRoot(
					 HINSTANCE hCrypt32DllInst,			// handle point to loaded crypt32.dll librar
					 PCCERT_CONTEXT pRootCert
					 )
{
	HRESULT hr = S_OK;
	BYTE	rgbKeyId[sizeof(rgbSignerRootKeyId)];
    DWORD	cbKeyId = sizeof(rgbSignerRootKeyId);

	LOG_block("VerifyMSRoot()");

	//
	// valid parameter values
	//
	if (NULL == hCrypt32DllInst || NULL == pRootCert)
	{
		hr = E_INVALIDARG;
		goto ErrHandler;
	}

	//
	// get the function we need from the passed in library handle
	// If not available, return error
	//
	if (NULL == (pfnCryptHashPublicKeyInfo = (PFNCryptHashPublicKeyInfo)
		GetProcAddress(hCrypt32DllInst, "CryptHashPublicKeyInfo")))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto ErrHandler;
	}

	//
	// get the public key hash value of this cert
	//
	ZeroMemory(rgbKeyId, sizeof(rgbKeyId));
    if (!pfnCryptHashPublicKeyInfo(
							0,						// use default crypto svc provider
							CALG_SHA1,				// use SHA algorithm
							0,						// dwFlags
							X509_ASN_ENCODING,
							&pRootCert->pCertInfo->SubjectPublicKeyInfo,
							rgbKeyId,
							&cbKeyId
							))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ErrHandler;
	}

	//
	// compare the hash value of public key of this root cert with the known MS root cert value
	//
	if (sizeof(rgbSignerRootKeyId) != cbKeyId || cbKeyId != CompareMem(rgbSignerRootKeyId, rgbKeyId, cbKeyId))
	{
		hr = S_FALSE;
	}


ErrHandler:

	if (FAILED(hr))
	{
		LOG_out("Faied inside function VerifyMSRoot() with HRESULT 0x%0x", hr);
	}
	else
	{
		LOG_out("Exit VerifyMSRoot() with %s", (S_OK == hr) ? "S_OK" : "S_FALSE");
	}

	return hr;
}





/////////////////////////////////////////////////////////////////////////////
// 
// Private Function VerifySpecialMSCerts()
//
//      This function takes the passed-in certificate as a leaf cert,
//		and verifies its hash value matches the hash value of one of
//		known Microsoft special certs that does not have MS root.
//
//		The known certs are, in comparing order:
//			Microsoft Corporation
//			Microsoft Corporation MSN
//			MSNBC Interactive News LLC
//			Microsoft Corporation MSN (Europe)
//			Microsoft Corporation (Europe)
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//			pRootCert - the certificate context of the root cert
//
// Return:  HRESULT - result of execution, S_OK if matched.
//			if not matched, CERT_E_UNTRUSTEDROOT, or
//			E_INVALIDARG if arguments not right, or
//			crypt32.dll error returned by API calls
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifySpecialMSCerts(					 
							 HINSTANCE hCrypt32DllInst,			// handle point to loaded crypt32.dll librar
							 PCCERT_CONTEXT pLeafCert
							 )
{
	HRESULT hr = S_FALSE;
	BYTE	btShaBuffer[ShaBufSize];
	DWORD	dwSize = sizeof(btShaBuffer);
	LPBYTE	pId;
	int		i;

	LOG_block("VerifySpecialMSCerts()");

	//
	// valid parameter values
	//
	if (NULL == hCrypt32DllInst || NULL == pLeafCert)
	{
		hr = E_INVALIDARG;
		goto ErrHandler;
	}

	//
	// get the function we need from the passed in library handle
	// If not available, return error
	//
	if (NULL == (pfnCertGetCertificateContextProperty = (PFNCertGetCertificateContextProperty)
		GetProcAddress(hCrypt32DllInst, "CertGetCertificateContextProperty")))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto ErrHandler;
	}
	
	//
	// find out the id hash of leaf cert
	//
	ZeroMemory(btShaBuffer, dwSize);
	if (!pfnCertGetCertificateContextProperty(
						pLeafCert,					// pCertContext
						CERT_SHA1_HASH_PROP_ID,	// dwPropId
						btShaBuffer,
						&dwSize
						))
	{
		hr = GetLastError();
		goto ErrHandler;
	}

	//
	// iterrate through all known id hash values to see if this file is signed
	// with any of these special certs.
	//
	if (ShaBufSize == dwSize)
	{
		for (i = 0,pId = rgbSpecialCertId; i < sizeof(rgbSpecialCertId)/ShaBufSize; i++, pId += ShaBufSize)
		{
			if (CompareMem(btShaBuffer, pId, ShaBufSize) == ShaBufSize)
			{
				//
				// found a matching known cert!
				//
				hr = S_OK;
				break;
			}
		}
	}

ErrHandler:

	if (FAILED(hr))
	{
		LOG_out("Faied inside function VerifySpecialMSCerts() with HRESULT 0x%0x", hr);
	}
	else
	{
		LOG_out("Exit VerifySpecialMSCerts() with %s", (S_OK == hr) ? "S_OK" : "S_FALSE");
	}

	return hr;


}

/////////////////////////////////////////////////////////////////////////////
// 
// Private Function CheckWinTrust()
//
//      This function will return the HRESULT for the trust state on the
//      specified file. The file can be pointing to any URL or local file.
//      The verification will be done by the wintrust.dll. 
//
//
// Input:   Fully qualified filename, UIChoice
// Return:  HRESULT - result of execution
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CheckWinTrust(LPCTSTR pszFileName, DWORD dwUIChoice)
{

	LOG_block("CheckWinTrust()");

    USES_CONVERSION;

    // Now verify the file
    WINTRUST_DATA               winData;
    WINTRUST_FILE_INFO          winFile;
    GUID                        gAction = WINTRUST_ACTION_GENERIC_VERIFY_V2; 
    CRYPT_PROVIDER_DATA const   *pProvData = NULL;
    CRYPT_PROVIDER_SGNR         *pProvSigner = NULL;
    CRYPT_PROVIDER_CERT	        *pProvCert = NULL;
    HRESULT                     hr = S_OK;


#ifdef _WUV3TEST
	//
	// handling test case:
	// if a reg key value is set to 1, then we will see if we need to pop up ALL certs
	//
	// NOTE:
	//
	// for the certs that user has checked "Always trust this provider..." previously, 
	// WinCheckTrust() API will still NOT show any UI even if we signal Show-ALL flag
	//
	HKEY	hkey;
	DWORD	dwWinTrustUI = 0;
	DWORD	dwSize = sizeof(dwWinTrustUI);
	if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) 
	{
		RegQueryValueEx(hkey, _T("WinTrustUI"), 0, 0, (LPBYTE)&dwWinTrustUI, &dwSize);
		RegCloseKey(hkey);
	}
	if (1 == dwWinTrustUI && WTD_UI_NONE != dwUIChoice)
	{
		//
		// if there is a WinTrustUI reg key exist, and value is 1
		// and caller does not request silence, then we
		// pop up all certs
		//
		dwUIChoice = WTD_UI_ALL;
	}
#endif


	//
	// dynamically load the wintrust.dll
	//
	if (NULL == shWinTrustDllInst)
	{
		if (NULL == (shWinTrustDllInst = LoadLibrary(WINTRUST)))
		{
			LOG_error("Failed to load libary %s, exit function.", WINTRUST);
            hr = HRESULT_FROM_WIN32(GetLastError());
		    goto Done;
		}
	}

	//
	// dynamically load the crypt32.dll, which will be used by the two
	// helper functions to verify the cert is MS cert
	//
	if (NULL == shCrypt32DllInst)
	{
		if (NULL == (shCrypt32DllInst = LoadLibrary(CRYPT32)))
		{
			LOG_error("Failed to load libary %s, exit function.", CRYPT32);
            hr = HRESULT_FROM_WIN32(GetLastError());
		    goto Done;
		}
	}
	//
	// find the functions we need
	//
	if (NULL == (pfnWinVerifyTrust = (PFNWinVerifyTrust)
				GetProcAddress(shWinTrustDllInst, "WinVerifyTrust")) ||
		NULL == (pfnWTHelperProvDataFromStateData = (PFNWTHelperProvDataFromStateData)
				GetProcAddress(shWinTrustDllInst, "WTHelperProvDataFromStateData")) ||
		NULL == (pfnWTHelperGetProvSignerFromChain = (PFNWTHelperGetProvSignerFromChain) 
				GetProcAddress(shWinTrustDllInst, "WTHelperGetProvSignerFromChain")) ||
		NULL == (pfnWTHelperGetProvCertFromChain = (PFNWTHelperGetProvCertFromChain)
				GetProcAddress(shWinTrustDllInst, "WTHelperGetProvCertFromChain")))
	{
		//
		// at least one function was not found in the loaded cryp32.dll libary.
		// we can not continue, jsut quit. 
		// NOTE: this shouldn't happen since we have tried to get 
		// the least common denomination of different version of this dll
		// on both IE4 and IE5
		//
		LOG_error("CheckWinTrust() did not find functions needed from %s", CRYPT32);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto Done;
	}


	//
	// initialize the data structure used to verify trust
	//
    winFile.cbStruct       = sizeof(WINTRUST_FILE_INFO);
    winFile.hFile          = INVALID_HANDLE_VALUE;
    winFile.pcwszFilePath  = T2OLE((LPTSTR)pszFileName);
    winFile.pgKnownSubject = NULL;

    winData.cbStruct            = sizeof(WINTRUST_DATA);
    winData.pPolicyCallbackData = NULL;
    winData.pSIPClientData      = NULL;
    winData.dwUIChoice          = (WTD_UI_ALL == dwUIChoice) ? dwUIChoice : WTD_UI_NONE;
    winData.fdwRevocationChecks = 0;
    winData.dwUnionChoice       = WTD_CHOICE_FILE;
    winData.dwStateAction       = WTD_STATEACTION_VERIFY;
    winData.hWVTStateData       = 0;
    winData.dwProvFlags         = 0x00000010;
    winData.pFile               = &winFile;

	//
	// verify the signature
	//
    hr = pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

    if (FAILED(hr))
    {
        //
        // The object isn't even trusted so just get out here
        //
		LOG_error("WinVerifyTrust(%s) found error 0x%0x.", pszFileName, hr);
        goto Return;
    }


	//
	// the real usage should never pass in WTD_UI_ALL. If this is the case, 
	// then we are calling this recursively in order to force the show
	// a good but non-MS cert only, so no need to check MS cert again.
	//
	// or, in test mode, we always do this part
	//
	if (WTD_UI_ALL != dwUIChoice)
	{
		//
		// the rset of code is used to verify the signed cert is
		// a valid MS cert.
		//
		pProvData = pfnWTHelperProvDataFromStateData(winData.hWVTStateData);
    
		pProvSigner = pfnWTHelperGetProvSignerFromChain(
										(PCRYPT_PROVIDER_DATA) pProvData, 
										0,      // first signer
										FALSE,  // not a counter signer
										0);

		//
		// check root cert then check leaf (signing) cert if that fails
		//
		// 0 is signing cert, csCertChain-1 is root cert
		//
		pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, pProvSigner->csCertChain - 1);

		hr = VerifyMSRoot(shCrypt32DllInst, pProvCert->pCert);

		if (S_OK != hr)
		{
			pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, 0);

			hr = VerifySpecialMSCerts(shCrypt32DllInst, pProvCert->pCert);
		}


	}

Return:

    //
    // free the wintrust state that was used to get the cert in the chain
    //
    winData.dwStateAction = WTD_STATEACTION_CLOSE;
    pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

//#ifndef _WUV3TEST
	//
	// recursively call this function if not in test mode so we can show
	// UI for this non-MS but good cert.
	// Only the two functions checking MS cert will return S_FALSE
	//
	if (S_OK != hr)
	{
		if (WTD_UI_NOGOOD == dwUIChoice)
		{
			//
			// we need to show UI, so we will have to call this thing again
			// in case this is not a MS cert. From UI, if user clicks YES
			// then the return value will be S_OK;
			//
			hr = CheckWinTrust(pszFileName, WTD_UI_ALL);
			LOG_error("CheckWinTrust() found file not signed by a known MS cert. If user has not checked \"Always trust this\", UI should be shown, and user selected %s", 
				SUCCEEDED(hr) ? "YES" : "NO");
		}
		else
		{
			LOG_error("CheckWinTrust() found file not signed by a known MS cert!");
			hr = TRUST_E_SUBJECT_NOT_TRUSTED;
		}
	}
//#endif

	if (WTD_UI_ALL != dwUIChoice)
	{
		if (FAILED(hr))
		{
			LOG_error("CheckWinTrust(%s) returns 0x%0x", T2CA(pszFileName), hr);
		}
		else
		{
			LOG_out("CheckWinTrust(%s) returns S_OK", T2CA(pszFileName));
		}
	}

Done:
    if (NULL != shWinTrustDllInst)
    {
        FreeLibrary(shWinTrustDllInst);
        shWinTrustDllInst = NULL;
    }
    if (NULL != shCrypt32DllInst)
    {
        FreeLibrary(shCrypt32DllInst);
        shCrypt32DllInst = NULL;
    }

    return (hr); 
}    

/////////////////////////////////////////////////////////////////////////////
// 
// Public Function VerifyFile()
//
// This is a wrapper function for CheckWinTrust that both Whistler 
// and WU classic code should use.
//
// Input:	szFileName - the file with complete path
//			fShowBadUI - whether pop up UI in cases 
//						 (1) inproperly signed signature, 
//						 (2) properly signed but not Microsoft signature
//
// Return:	HRESULT - S_OK the file is signed with a valid MS cert
//					  or error code.
//
// Note:	If _WUV3TEST flag is set (for test build), then fShowBadUI is
//			ignored:
//				if reg key SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\wuv3test\WinTrustUI
//				is set to 1, then no UI is shown, and this function always return S_OK;
//				otherwise, UI always show no matter what cert, and return value is same
//				as the live build.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyFile(
				   IN LPCTSTR szFileName,
				   BOOL fShowBadUI /* = TRUE */
				   )
{
	DWORD dwUIChoice = WTD_UI_NOGOOD;

	if (!fShowBadUI)
	{
		dwUIChoice = WTD_UI_NONE;
	}

	return CheckWinTrust(szFileName, dwUIChoice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\cdmlib\usecrc.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    filecrc.h
//
//  Purpose: Calculating and using CRC for files
//
//=======================================================================

#include <windows.h>
#include <objbase.h>
#include <filecrc.h>
#include <search.h>   // for bsearch
#include <tchar.h>
#include <atlconv.h>


HRESULT GetCRCNameFromList(int iNo, PBYTE pmszCabList, PBYTE pCRCList, LPTSTR pszCRCName, int cbCRCName, LPTSTR pszCabName)
{
	USES_CONVERSION;
	
	int i = 0;
	WUCRC_HASH* pCRC = (WUCRC_HASH*)pCRCList;

	if ( (NULL == pmszCabList) || (NULL == pCRCList) )
		return E_INVALIDARG;

	for (LPSTR pszFN = (LPSTR)pmszCabList; *pszFN; pszFN += strlen(pszFN) + 1)
	{
		if (i == iNo)
		{
			lstrcpy(pszCabName, A2T(pszFN));
			
			return MakeCRCName(A2T(pszFN), pCRC, pszCRCName, cbCRCName);
		}
		pCRC++;
		i++;
	}

	// if we got here that means we did not find the request element
	return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}


HRESULT StringFromCRC(const WUCRC_HASH* pCRC, LPTSTR pszBuf, int cbBuf)
{
	LPTSTR p = pszBuf;
	BYTE b;
	
	//check the input argument, to see that it is not NULL
	if (NULL == pCRC)
	{
		return E_INVALIDARG;
	}

    if (cbBuf < ((WUCRC_HASH_SIZE * 2) + 1))
	{
		return TYPE_E_BUFFERTOOSMALL;
	}
	
	for (int i = 0; i < WUCRC_HASH_SIZE; i++)
	{
		b = pCRC->HashBytes[i] >> 4;
		if (b <= 9)
			*p = '0' + (TCHAR)b;
		else
			*p = 'A' + (TCHAR)(b - 10);
		p++;

		b = pCRC->HashBytes[i] & 0x0F;
		if (b <= 9)
			*p = '0' + (TCHAR)b;
		else
			*p = 'A' + (TCHAR)(b - 10);
		p++;
	}
	*p = _T('\0');
	
	return S_OK;
}



static BYTE hex2dec(char ch)
{
    if (ch >= '0' && ch <= '9')
    {
	    return (ch - '0');
    }

    if (ch >= 'A' && ch <= 'F')
    {
	    return (ch - 'A' + 0xA);
    }

    if (ch >= 'a' && ch <= 'f')
    {
	    return (ch - 'a' + 0xA);
    }

	// we do not expect illegal values here
	return 0;
}



HRESULT CRCFromString(LPCSTR pszCRC, WUCRC_HASH* pCRC)
{
	if (strlen(pszCRC) != (2 * WUCRC_HASH_SIZE))
	{
		return E_INVALIDARG;
	}
	
	LPCSTR p = pszCRC;
    
    
	for (int i = 0; i < WUCRC_HASH_SIZE; i++)
	{
        // broken into two lines because the optimizer was doing the wrong thing when on one line
		pCRC->HashBytes[i] = (hex2dec(*p++) << 4);
        pCRC->HashBytes[i] += hex2dec(*p++);
	}
	
	return S_OK;
}




HRESULT MakeCRCName(LPCTSTR pszFromName, const WUCRC_HASH* pCRC, LPTSTR pszToName, int cbToName)
{
	int iLen = lstrlen(pszFromName);
	LPTSTR pDot;
	TCHAR szCRC[WUCRC_HASH_SIZE * 2 + 1];
	HRESULT hr = S_OK;

	// make sure we have enough space for orignal file name + hash + a '_' + null terminator
	if (cbToName < (WUCRC_HASH_SIZE * 2 + iLen + 2))
	{
		return TYPE_E_BUFFERTOOSMALL;
	}

	hr = StringFromCRC(pCRC, szCRC, sizeof(szCRC));
	if (FAILED(hr))
	{
		return hr;
	}

	lstrcpy(pszToName, pszFromName);

	// find the extension in the new copy
	pDot = _tcschr(pszToName, _T('.'));
	if (pDot != NULL)
	{
		*pDot = _T('\0');
	}
	lstrcat(pszToName, _T("_"));
	lstrcat(pszToName, szCRC);

	// copy the extension from the original name
	pDot = _tcschr(pszFromName, _T('.'));
	if (pDot != NULL)
	{
		lstrcat(pszToName, pDot);
	}

	return hr;
}




// splits abc_12345.cab into  abc.cab and 12345 returned as CRC
HRESULT SplitCRCName(LPCSTR pszCRCName, WUCRC_HASH* pCRC, LPSTR pszName)
{
// YANL - unreferenced local variable
//	char szCRC[WUCRC_HASH_SIZE * 2 + 1];
	char szTmp[MAX_PATH];
	int l = strlen(pszCRCName);
	int i;
	LPSTR pszExt = NULL;
	LPSTR pszHash = NULL;

	pszName[0] = '\0';
	if (l < (2 * WUCRC_HASH_SIZE))
	{
		// cannot be a valid name if it does not have atleast 2*WUCRC_HASH_SIZE characters
		return E_INVALIDARG;
	}

	strcpy(szTmp, pszCRCName);

	// start at the end, set pointers to put nulls at last period and last underscore
	// record the starting position of the extension and hash code
	i = l - 1;
	while (i >= 0)
	{
		if ((szTmp[i] == '.') && (pszExt == NULL))
		{
			pszExt = &(szTmp[i + 1]);
			szTmp[i] = '\0';
		}
		else if ((szTmp[i] == '_') && (pszHash == NULL))
		{
			pszHash = &(szTmp[i + 1]);
			szTmp[i] = '\0';
		}
		i--;
	}

	if (pszHash == NULL)
	{
		return E_INVALIDARG;
	}

	// copy original cab name
	strcpy(pszName, szTmp);
	if (pszExt != NULL)
	{
		strcat(pszName, ".");
		strcat(pszName, pszExt);
	}


	return CRCFromString(pszHash, pCRC);
}



int __cdecl CompareWUCRCMAP(const void* p1, const void* p2)
{
	//check if the input arguments are not NULL
	if (NULL == p1 || NULL == p2)
	{
		return 0;
	}

	DWORD d1 = ((WUCRCMAP*)p1)->dwKey;
	DWORD d2 = ((WUCRCMAP*)p2)->dwKey;

	if (d1 > d2)
		return +1;
	else if (d1 < d2)
		return -1;
	else
		return 0;
}


//
// CCRCMapFile class
//


// Constructs an object to search the CRC index file data passed in 
// with pMemData.  
//
// NOTE: The memory pointed by pMemData buffer must stay valid
//       for the lifetime of this object
//
// structure for map file:
//   DWORD count
//   WUCRCMAP[0]
//   WUCRCMAP[1]
//   WUCRCMAP[count - 1]
//
CCRCMapFile::CCRCMapFile(const BYTE* pMemData, DWORD dwMemSize)
{
	//check the input argument for NULLs
	if (NULL == pMemData) 
	{
		m_pEntries = NULL;
		m_cEntries = 0;
		return;
	}

	// get the count
	m_cEntries = *((DWORD*)pMemData);

	// validate the memory buffer size
	if ((sizeof(DWORD) + m_cEntries * sizeof(WUCRCMAP)) != dwMemSize)
	{
		// invalid size is passed, we cannot process it
		m_pEntries = NULL;
		m_cEntries = 0;
	}
	else
	{
		// set the pointer to begining of the map entries
		m_pEntries = (WUCRCMAP*)(pMemData + sizeof(DWORD));
	}
}


HRESULT CCRCMapFile::GetValue(DWORD dwKey, WUCRC_HASH* pCRC)
{
	WUCRCMAP* pEntry;
	WUCRCMAP key;

	if (m_cEntries == 0)
	{
		// memory buffer passed to us was invalid
		return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	}

	// fill the key field need for compare function in the structure
	key.dwKey = dwKey;

	// binary search to find the item
	pEntry = (WUCRCMAP*)bsearch((void*)&key, (void*)m_pEntries, m_cEntries, sizeof(WUCRCMAP), CompareWUCRCMAP);

	if (pEntry == NULL)
	{
		// not found
		return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	}

	// found the entry
	memcpy(pCRC, &pEntry->CRC, sizeof(WUCRC_HASH));

	return S_OK;
}


HRESULT CCRCMapFile::GetCRCName(DWORD dwKey, LPCTSTR pszFromName, LPTSTR pszToName, int cbToName)
{
	WUCRC_HASH CRC;

	HRESULT hr = GetValue(dwKey, &CRC);

	if (SUCCEEDED(hr))
	{
		hr = MakeCRCName(pszFromName, &CRC, pszToName, cbToName);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\bstr.h ===
/*
 * bstr.h - definitions/declarations for Windows Update V3 Catalog infra-structure
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 * Purpose:
 *      This file contains the prototypes of library functions that convert bstrs
 *	to LPSTRs and LPSTRs to BSTRs.
 *
 */

	#include <objbase.h>

	//This function converts an Ansi string into a BSTR.

	//This method convers an Ansi string into a BSTR for inclusion in a BSTR variant structure.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\ccdm.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   ccdm.h
//
//  Owner:  YanL
//
//  Description:
//
//      CDM interface
//
//=======================================================================

#ifndef _CCDM_H_

	#include <wustl.h>
	#include <wuv3.h>
	#include <varray.h>
	#include <v3stdlib.h>
	#include <cwudload.h>
	#include <diamond.h>
	#include <cbitmask.h>
	#include <bucket.h>

	#ifdef _UNICODE
		#define tstring wstring
	#else
		#define tstring string
	#endif

	class CCdm
	{

	enum enumDriverDisposition
	{
		CDM_NEW_DRIVER,
		CDM_UPDATED_DRIVER,
		CDM_CURRENT_DRIVER,
	};

	struct SCdmItem {
		PUID puid;
		enumDriverDisposition fInstallState;
		tchar_buffer bufHardwareIDs;
		tstring sDriverVer;
		tstring sPrinterDriverName;
		tstring sArchitecture;
	};

	public:
		int							m_iCDMTotalItems;		//Total CDM items in m_items array. This member is only valid after a call to CreateCDMInventoryList. Subsequent calls to CreateCDMInventoryList will overwrite this variable.
		Varray<PINVENTORY_ITEM>		m_items;				//Array of detected CDM catalog items. This member is only valid after a call to CreateCDMInventoryList. Subsequent calls to CreateCDMInventoryList will overwrite the data stored in this array.

	public:

		CCdm(){}

		~CCdm(){}


		void CreateInventoryList
		(
			IN		CBitmask	*pBm,			//bitmask to be used to prune the inventory list.
			IN		CWUDownload	*pDownload,		//pointer to internet server download class.
			IN		CDiamond	*pDiamond,		//pointer to diamond de-compression class.
			IN		PUID		puidCatalog,	//puid identifier of catalog where device drivers are stored.
			IN		PBYTE		pOemInfoTable	//Pointer OEM info table that OEM detection needs.
		);

		//Returns an inventory item formated for insertion into the
		//main inventory catalog. This record will still need the
		//description record setup but is otherwise ready for main
		//pruning.

		PINVENTORY_ITEM ConvertCDMItem(
			int index		//Index of cdm record to be converted
		);

	protected:
		byte_buffer	m_bufInventory;

		typedef pair< ULONG, byte_buffer > my_pair;
		vector< my_pair > m_aBuckets;

		void AddItem(
			vector<SCdmItem>& acdmItem, 
			PUID puid, 
			enumDriverDisposition fDisposition,
			LPCTSTR szHardwareId, 
			LPCTSTR szDriverVer, 
			LPCTSTR szPrinterDriverName = NULL,
			LPCTSTR szArchitecture = NULL
		);

		void AddInventoryRecords(
			vector<SCdmItem>& acdmItem
		);

		//Reads a compressed CDM hash table from an internet server.
		void ReadHashTable(
			IN	CWUDownload	*pDownload,		//pointer to internet server download class.
			IN	CDiamond	*pDiamond,		//pointer to diamond de-compression class.
			IN	PUID		puidCatalog		//PUID id of catalog for which cdm hash table is to be retrieved.
		);

		//returns the index of a possible hardware match if it is in the hash table
		//if the hardware id is not found then this method returns -1

		ULONG IsInMap(
			IN LPCTSTR pHwID		//hardware id to be retrieved
		);

		//Reads and initializes a compressed CDM bucket file from an internet server.
		//Returnes the array index where the bucket file is stored.

		byte_buffer& ReadBucketFile(
			IN	CWUDownload	*pDownload,		//pointer to internet server download class.
			IN	CDiamond	*pDiamond,		//pointer to diamond de-compression class.
			IN	PUID		puidCatalog,	//PUID id of catalog for which cdm hash table is to be retrieved.
			IN	ULONG		iHashIndex		//Hash table index of bucket file to be retrieved
		);
	};

	enum EDriverStatus 
	{
		edsBackup,
		edsCurrent,
		edsNew,
	};

	void CdmInstallDriver(BOOL bWindowsNT, EDriverStatus eds, LPCTSTR szHwIDs, LPCTSTR szInfPathName, LPCTSTR szDisplayName, PDWORD pReboot);

	#define	_CCDM_H_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\debug.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    debug.h
//
//  Purpose: Debug Routines
//
//  History: 15-Jan-99   YAsmi    Created
//
//=======================================================================

#ifndef _DEBUG_H
#define _DEBUG_H


#if DBG == 1
	#define _DEBUG
#else
	#undef _DEBUG
#endif


#ifdef _DEBUG

void _cdecl WUTrace(char* pszFormat, ...);
void _cdecl WUTraceHR(unsigned long hr, char* pszFormat, ...);

#define TRACE            WUTrace
#define TRACE_HR         WUTraceHR

#else  //_DEBUG

inline void _cdecl WUTrace(char* , ...) {}
inline void _cdecl WUTraceHR(unsigned long, char* , ...) {}

#define TRACE            1 ? (void)0 : WUTrace
#define TRACE_HR         1 ? (void)0 : WUTraceHR


#endif //_DEBUG
 
#endif //_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\cbitmask.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.

#ifndef _INC_CBITMASK

#include <cwudload.h>
#include <diamond.h>


//used with Read method to determine what type of bitmask to retrieve.
#define	BITMASK_CDM_TYPE			1		//read a device driver cdm bitmask file
#define	BITMASK_ACTIVESETUP_TYPE	2		//read an active setup bitmask file


class CBitmask
{
public:
	
	//create a new memory bitmask with the specified number of
	//masks and number of bits in each bitmask record
	CBitmask(
		int iMaxMasks,		//iMaxMasks			maximum number of bit masks to allocate space for
		int iMaxMaskBits,	//iMaxMaskBits		size of each individual mask in bits
		int	iTotalOEMs,		//iTotalOEMs		total oem bitmask records
		int	iTotalLangs,		//iTotalLangs		total locale bitmask records
		int	iTotalPlatforms	//Total number of platforms defined.
		);

	//create an empty uninitialized bitmask
	CBitmask();

	~CBitmask();

	//read bitmask into memory bitmask
	void Read(
		IN	CWUDownload* pDownload,		//pointer to internet server download class.
		IN	CDiamond*	 pDiamond,		//pointer to diamond de-compression class.
		IN	PUID		 puidCatalog,	//PUID id of catalog where bitmask file is stored.
		IN	int			 iType,			//BITMASK_CDM_TYPE or BITMASK_ACTIVESETUP_TYPE
		IN  LPCTSTR		 pszBaseName
		);

	//parse an in memory array that contains a bitmask into a bitmask class
	void Parse(
		IN	PBYTE	pBuffer,		//memory buffer that contains the bitmask file
		IN	int		iMaskFileSize	//file size of memory buffer file
		);

	//returns the number of bits in an individual bitmask
	int GetBitSize()
	{ 
		return m_pMask->iRecordSize; 
	}
	
	//returns a pointer to the beginning of the bitmask id array
	PBITMASKID GetIDPtr()
	{ 
		return m_pMask->bmID; 
	}

	//returns a pointer to the beginning of the bitmask array
	PBYTE GetBitPtr()
	{ 
		return m_pMask->GetBitsPtr(); 
	}

	//returns the beginning of a given bitmask based on its physical index.
	//Note: this method and the GetBitmaskPtr are the only ways to get the
	//global bitmask by since the global bitmask does not have a corrisponding
	//id
	PBYTE GetBitMaskPtr(
		IN int index	//index of bitmask to retrieve
		)
	{ 
		return (m_pMask->GetBitsPtr() + ((m_pMask->iRecordSize+7)/8) * index); 
	}

	//returns the state of a selected bit in a bitmask
	BYTE GetBit(
		IN int index,	//index of bitmask to get bit from
		IN int bit		//bitmask bit position to retrieve
		)
	{ 
		return GETBIT(GetBitMaskPtr(index), bit); 
	}

	//This is a hack to alloc the mkinv app to write out the bitmask file this is not
	//needed by the client application.
	PBITMASK GetBITMASKPtr()
	{ 
		return m_pMask; 
	}

	//returns a pointer to a bitmask customized for the client computer that we are running on.
	//Note: This bitmask only has one record. This record is the correctly anded bitmask for
	//OEM and LOCALE.
	PBYTE GetClientBits(
		DWORD		dwOemId,	// PnP ID for current machine
		DWORD		langid		//pointer to variable that receives the OS locale id
		);

	//Returns a pointer to a bitmask customized for the detected platform list.
	PBYTE CBitmask::GetClientBits(
		PDWORD	pdwPlatformIdList,	//Array of Platform ids.
		int		iTotalPlatforms		//Total Platform ids in previous array.
		);

	int GetMaskFileSize()
	{ 
		return m_iMaskFileSize; 
	}


private:
	PBITMASK	m_pMask;						//pointer to bitmask structure array
	int			m_iTotalBitMasks;				//total number of bitmasks in bitmask class
	int			m_iMaskFileSize;				//total size of bitmask file

	//This method performs a logical AND operation between an array of bits and a bitmask bit array.

	void AndBitmasks(
		PBYTE	pBitsResult,	//result array for the AND operation
		PBYTE	pBitMask,		//bitmask array to AND into the result array
		int		iMaskByteSize	//size of bitmask
		);

};

#define _INC_CBITMASK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\ccatalog.h ===
/*
 * ccatalog.h - definitions/declarations for Windows Update V3 Catalog infra-structure
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 * Purpose:
 *       This file defines the class structures that allow reading, writing, and
 *       parsing of the V3 Windows Update catalog.
 */

#ifndef _INC_V3_CATALOG

#include <varray.h>
#include <wuv3.h>
#include <cbitmask.h>
#include <cwudload.h>
#include <diamond.h>
#include <ccdm.h>
#include <filecrc.h>

#define REGISTRYHIDING_KEY _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\HiddenItems")

#ifdef _UNICODE
#define T2A W2A
#else
#define T2A
#endif

class CCatalog;   //forward

const DWORD		DISP_PUID_NOT_IN_MAP = 1;
const DWORD    DISP_DESC_NOT_FOUND = 2;

void RegistryHidingRead(Varray<PUID>& vPuids, int& cPuids);
BOOL RegistryHidingUpdate(PUID puid, BOOL bHide);
void GlobalExclusionsRead(Varray<PUID>& vPuids, int& cPuids, CCatalog* pCatalog, CWUDownload *pDownload);
HRESULT DownloadFileToMem(CWUDownload* pDownload, LPCTSTR pszFileName, CDiamond* pDiamond, BYTE** ppMem, DWORD* pdwLen);

struct DEPENDPUID
{
	PUID puid;
	DWORD dwPriority;
	PUID puidParent;                  // contains the PUID of the parent
	PINVENTORY_ITEM pTopLevelItem;    // points to top level item of a dependant item or NULL
};


typedef struct _WORKERQUEUEENTRY
{
    CWUDownload        *lpdl;
    CDiamond           *lpdm;
    PINVENTORY_ITEM     pItem;
    _WORKERQUEUEENTRY  *Next;          // next queue entry
} WORKERQUEUEENTRY, *LPWORKERQUEUEENTRY;

#define MAX_WORKERS				4


typedef struct _HANDLEANDINDEX
{
    HANDLE      hThread;
    DWORD       dwIndex;
} HANDLEANDINDEX, *LPHANDLEANDINDEX;


class CCatalog
{
private:

    // Functions for the worker threads
    HANDLEANDINDEX          m_hWorkers[MAX_WORKERS];   // Up to four workers
    HANDLE                  m_hEvents[MAX_WORKERS];
    LPWORKERQUEUEENTRY      m_lpWorkQueue;             // queue of work
    HANDLE                  m_mutexWQ;                 // Access to workqueue
    HANDLE                  m_mutexDiamond;
    BOOL                    m_bTerminateWorkers;       // shutdown read workers
    void 					PurgeQueue();              // Clear the queue
    LPWORKERQUEUEENTRY 		DeQueue();
    LPWORKERQUEUEENTRY 		EnQueue(LPWORKERQUEUEENTRY lpwqe);
    void 					TerminateWorkers();

friend ULONG WINAPI	Worker(LPVOID lpv);
//friend unsigned int WINAPI	Worker(LPVOID lpv);

public:
	CCatalog(
			LPCTSTR szServer = NULL,	//server and share catalog is stored at.
			PUID puidCatalog	= 0	//PUID identifier of catalog.
		);

	~CCatalog();

	//Adds a memory inventory item to a catalog
	void AddItem(
			IN	PINVENTORY_ITEM	pItem		//Pointer to inventory item to be added to memory catalog file
		);


	//Reads an inventory catalog's items from an http server
	void Read(
			IN	CWUDownload	*pDownload,		//pointer to internet server download class.
			IN	CDiamond	*pDiamond		//pointer to diamond de-compression class.
		);

	//read and attaches a description file to an inventory catalog item record.
	HRESULT ReadDescription(
			IN	CWUDownload	*pDownload,		//pointer to internet server download class.
			IN	CDiamond	*pDiamond,		//pointer to diamond de-compression class.
			IN  PINVENTORY_ITEM	pItem,		//Pointer to item to attach description to.
			IN  CCRCMapFile* pIndex,        //pointer to map file structure
			OUT DWORD *pdwDisp = NULL    //DWORD describing reason for an error
		);

	HRESULT MergeDescription(
			CWUDownload* pDownload,		// internet server download class.
			CDiamond* pDiamond,			// diamond de-compression class.
			PINVENTORY_ITEM pItem,		// item to attach description to.
			CCRCMapFile* pIndex	        // must be for machine language	
		);

	
	HRESULT ReadDescriptionEx(
			IN	CWUDownload	*pDownload,		//pointer to internet server download class.
			IN	CDiamond	*pDiamond,		//pointer to diamond de-compression class.
			IN  PINVENTORY_ITEM	pItem		//Pointer to item to attach description to.
		);

	HRESULT ReadDescriptionGang(
			IN	CWUDownload	*pDownload,		//pointer to internet server download class.
			IN	CDiamond	*pDiamond		//pointer to diamond de-compression class.
		);

	HRESULT BlankDescription(
			IN PINVENTORY_ITEM pItem		//Pointer to item to attach description to.
		);


	void Prune();

	//returned the header record for an inventory catalog.
	PWU_CATALOG_HEADER GetHeader()
	{ 
		return &m_hdr; 
	}

	//returns a specific inventory item record.
	PINVENTORY_ITEM	GetItem
		(
			int index
		)
		{ 
			if(index < m_items.SIZEOF())
			{
				return m_items[index]; 
			}
			else
			{
				return (PINVENTORY_ITEM)NULL;
			}
		}

	void BitmaskPruning
		(
			IN CBitmask *pBm,			//bitmask to be used to prune inventory list
			IN PBYTE	pOemInfoTable	//Pointer OEM info table that OEM detection needs.
		);

	//This method prunes the inventory.plt list with the bitmask.plt
	void BitmaskPruning(
			IN CBitmask *pBm,			//bitmask to be used to prune inventory list
			IN PDWORD pdwPlatformId,	//platform id list to be used.
			IN long iTotalPlatforms		//platform id list to be used.
		);

	void ProcessExclusions(
			IN	CWUDownload	*pDownload
		);
	
	//this method returns the index in the inventory list where the specified
	//record type is stored or -1 if not found. This method is used to find
	//the the CDM device driver insertion record or the printer insertion
	//record at present.
	int GetRecordIndex(
			int iRecordType	//Record type to find.
		);

	void AddCDMRecords(
			IN CCdm	*pCdm	//cdm class to be used to add Device Driver
		);

	BYTE GetItemFlags(
			int index	//index of record for which to retrieve the item flags
		);

	//Helper function that returns an inventory item's puid.
	PUID GetItemPuid(
			int index	//index of record for which to retrieve the item flags
		);

	//returns information about an inventory item.
	BOOL GetItemInfo(
			int	index,		//index of inventory record
			int	infoType,	//type of information to be returned
			PVOID	pBuffer		//caller supplied buffer for the returned information. The caller is
						//responsible for ensuring that the return buffer is large enough to
						//contain the requested information.
		);

	//Returns the server that this catalog was read from.
	LPTSTR GetCatalogServer()
	{
		return m_szServer;
	}

	PUID GetCatalogPuid()
	{
		return m_puidCatalog;
	}

	void SetBrowserLocale(LPCTSTR szLocale)
	{
		lstrcpy(m_szBrowserLocale, szLocale);
	}

	DWORD GetBrowserLocaleDW()
	{
		USES_CONVERSION;
		return (DWORD)atoh(T2A(m_szBrowserLocale));
	}

	LPCTSTR GetBrowserLocaleSZ()
	{
		return m_szBrowserLocale;
	}


	LPCTSTR GetBaseName()
	{
		return m_szBaseName;
	}

	LPCTSTR GetBitmaskName()
	{
		return m_szBitmaskName;
	}

	void SetPlatform(DWORD platformId)
	{
		m_platformId = platformId;
	}

	DWORD GetPlatform(void)
	{
		return m_platformId;
	}


	LPCTSTR GetMachineLocaleSZ();
    LPCTSTR GetUserLocaleSZ();
	BOOL LocalesDifferent();

	void GetItemDirectDependencies(PINVENTORY_ITEM pItem, Varray<DEPENDPUID>& vDepPuids, int& cDepPuids);

private:

	int CCatalog::GetRecordType
		(
			PINVENTORY_ITEM pItem	//inventory item to use to determine the record type.
		);

	void ConvertLinks();


	int FindPuid(
			PUID puid	//PUID identifier of inventory record to find.
		);

	//parses a binary character memory array into a memory catalog file format.
	void Parse(
			IN	PBYTE	pCatalogBuffer			//decompressed raw catalog memory image from server.
		);

	//returns a pointer to the next inventory record in an inventory record memory file.
	PBYTE GetNextRecord(
			IN	PBYTE			pRecord,		//pointer to current inventory record
			IN	int				iBitmaskIndex,	//bitmask index for the current record
			IN	PINVENTORY_ITEM	pItem			//pointer to item structure that will be filled in by this method.
		);

	PUID m_puidCatalog;			//The puid identifier for this catalog.
	TCHAR m_szBrowserLocale[32];	//Browser locale that this catalog was retrieved with.


	WU_CATALOG_HEADER m_hdr;			//catalog header structure
	Varray<PINVENTORY_ITEM>	m_items;		//array of catalog items
	PBYTE m_pBuffer;		//internal buffer allocated and managed by Read() and Parse() methods.
	
	TCHAR m_szServer[MAX_PATH];	//server and share that this catalog is stored at.
	DWORD m_platformId;			//platform id for this catalog

	TCHAR m_szMachineLocale[32];	//current machine locale
    TCHAR m_szUserLocale[32];	//current user locale
	BOOL m_bLocalesDifferent;   //machine and browser locales are different
	
	PBYTE m_pGangDesc;

	TCHAR m_szBaseName[64];      // contains base name of the catalog (ie CRC name);
	TCHAR m_szBitmaskName[64];    // contains base name of the active setup bitmask 
};

#define _INC_V3_CATALOG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\cstate.h ===
/*
 * CState.h - definitions/declarations for Windows Update V3 Catalog infra-structure
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 * Purpose:
 *       This file defines the structures, values, macros, and functions
 *       used by the Version 3 Windows Update Catalog State management.
 *
 */

#ifndef _WU_V3_STATE_INC

#include <varray.h>
#include <wuv3.h>
#include <ccatalog.h>
#include <stdlib.h>	//For MAX_FNAME.
#include <applog.h>

#define ITEM_STATUS_SUCCESS						0	//The package was installed successfully.
#define ITEM_STATUS_INSTALLED_ERROR				1	//The package was Installed however there were some minor problems that did not prevent installation.
#define ITEM_STATUS_FAILED						2	//The packages was not installed.
#define ITEM_STATUS_SUCCESS_REBOOT_REQUIRED		3	//The package was installed and requires a reboot.
#define ITEM_STATUS_DOWNLOAD_COMPLETE			4   //The package was downloaded but not installed
#define ITEM_STATUS_UNINSTALL_STARTED			5	//uninstall was started 

const unsigned int WUV3_CLIENT_AUTOUPDATE = 1;
const unsigned int WUV3_CLIENT_UNSPECIFIED = 0;
const unsigned int WUV3_CLIENT_WEBSITE = 2;



typedef struct _STATESTRUCT
{
	PUID		puid;			//catalog name
	CCatalog	*pCatalog;		//pointer to pruned catalog structure
} STATESTRUCT, *PSTATESTRUCT;


typedef struct _SELECTITEMINFO	
{
	PUID		puid;		//item identifier
	int			iStatus;	//last installation status
	HRESULT		hrError;	//specific error number if an error occured on installation.
	SYSTEMTIME	stDateTime;	//date time of item install or removal.
	BOOL		bInstall;	//TRUE if item was installed or FALSE if item was removed.
	int			iCount;		//useage count when this becomes 0 array element is removed.
} SELECTITEMINFO, *PSELECTITEMINFO;


#define SERVERTYPE_SITE    1
#define SERVERTYPE_CABPOOL 2
#define SERVERTYPE_CONTENT 3

struct TRUSTEDSERVER
{
	int iServerType;
	TCHAR szServerName[MAX_PATH];
};


struct DETDLLNAME
{
	TCHAR szDLLName[32];   //we store file name only
};


//
// CSelectItems class
//
class CSelectItems
{
public:
	CSelectItems();
	
	//This method selects an item for installation.
	void Select(
		PUID puid,		//Inventory catalog item identifier to be selected.
		BOOL bInstall	//If TRUE then the item is being selected for installation, FALSE=Remove
		);
	
	//This method unselects an item.
	void Unselect(PUID puid);
	
	void Clear();
	
	//This method returns the total number of selected items in selected item array.
	int GetTotal()
	{ 
		return m_iTotalItems; 
	}
	
	//This method returns a pointer to the selected items array.
	PSELECTITEMINFO GetItems()
	{ 
		return &m_info[0]; 
	}
	
private:
	int	m_iTotalItems;					//Total items currently in selected item array.
	Varray<SELECTITEMINFO> m_info;		//Array of selected items
};




//
// CState class
//
class CState
{
public:
	//Class constructor, Note: There is only 1 state management class for the entire V3
	//control. This class is created when the control is first loaded by the VBscript
	//page. The state management class is destroyed when the control is freed by the
	//VB script page.
	CState();
	~CState();
	
	//This method retrieves a catalog from the state array. The catalog is
	//retrieved by name. If the catalog name is not found NULL is returned.
	CCatalog* Get(PUID puid);
	
	//This function gets a catalog inventory item and or catalog within the state store
	//by puid. The caller can retrieve the specific catalog item catalog or both. For
	//info that is not needed pass in NULL to the parameter. For example, if you do not
	//require the catalog parameter set the parameter to NULL.
	BOOL GetCatalogAndItem(
		IN				PUID			puid,		//puid of item to be returned.
		IN	OPTIONAL	PINVENTORY_ITEM	*ppItem,	//returned pointer to specific item that equates to this puid
		IN	OPTIONAL	CCatalog		**ppCatalog	//returned pointer to specific catalog that this puid is in.
		);
	
	//Retrieves the full list of items that have this puid. The return value is the number
	//of returned items. If the case of an error 0 is returned. Note: This function is only
	//called from the ChangeItemState method.
	
	int GetItemList(
		IN PUID			puid,				//puid of item to be returned.
		IN Varray<PINVENTORY_ITEM> &itemsList	//returned array of pointers to inventory items
		//that match this puid
		);
	
	//This method adds a new pruned catalog into the state array. This method returns
	//the total number of catalogs currently stored in the state array. This number
	//includes the new catalog. Note: The application must not delete a catalog that
	//is added to the state structure. Once the catalog is added it is the
	//responsibility of this class to delete the catalog.
	int Add(
		PUID	puid,		//PUID of Catalog to be added to state management class.
		CCatalog *pCatalog	//Pointer to pruned catalog class to be added to state array.
		);
	
	//This function gets a catalog inventory item within the state store by puid.
	//If the catalog item is not found then NULL is returned.
	PINVENTORY_ITEM	GetItem(
		PUID puid	//puid of item to be returned.
		);
	
	//checks if the specified server is trusted or not
	void CheckTrustedServer(LPCTSTR pszIdentServer, CDiamond* pDiamond);
	
	void Reset();
	
	BOOL CacheDLLName(LPCTSTR pszDLLName);

	CAppLog& AppLog()
	{
		return m_AppLog;
	}
	
	LPCTSTR GetCabPoolServer()
	{
		return m_vTrustedServers[m_iCabPoolServer].szServerName;
	}

	LPCTSTR GetSiteServer()
	{
		return m_vTrustedServers[m_iSiteServer].szServerName;
	}

	LPCTSTR GetContentServer()
	{
		return m_vTrustedServers[m_iContentServer].szServerName;
	}

	LPCTSTR GetIdentServer()
	{
		return m_vTrustedServers[m_iIdentServer].szServerName;
	}

	LPCTSTR GetRootServer()
	{
		return m_vTrustedServers[m_iRootServer].szServerName;
	}

	LPCTSTR GetSiteURL()
	{
		return m_szSiteURL;
	}

	void SetSiteURL(LPCTSTR pszURL)
	{
		lstrcpy(m_szSiteURL, pszURL);
	}

	// Can only be called after SetSiteURL() has been called
	BOOL ValidateSiteURL();

	// returns the numeric browser locale set in the first catalog
	// in the state catalog array
	DWORD GetBrowserLocale();

	PBYTE			m_pOemInfoTable;	//OEM table used in client machine detection.
	CSelectItems	m_selectedItems;	//Selected items array.
	PDWORD			m_pdwPlatformList;	//Detected Platform list.
	int				m_iTotalPlatforms;	//Total number of detected platforms.
	int				m_DefPlat;			//default platform id
	BOOL			m_bRebootNeeded;  //true if reboot is required after install
	CAppLog			m_AppLog;
	BOOL			m_bInsengChecked;
        unsigned int            m_nClient;
	
private:
	
	//This method finds a catalog within the state store by name. If the catalog is
	//not found then NULL is returned.
	int Find(PUID puid);
	
	// catalogs
	int	m_iTotalCatalogs;			
	Varray<STATESTRUCT> m_vState;	
	
	// trusted servers
	int m_cTrustedServers;					 
	Varray<TRUSTEDSERVER> m_vTrustedServers; 
	int m_iCabPoolServer;
	int m_iSiteServer;
	int m_iContentServer;
	int m_iIdentServer;
	int m_iRootServer;    
	
	// detection dlls
	int m_cDetDLLs;
	Varray<DETDLLNAME> m_vDetDLLs;

	// URL of the site
	TCHAR m_szSiteURL[MAX_PATH];

};


#define _WU_V3_STATE_INC

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\cwudload.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.

#ifndef _INC_CWUDownload

	#include <wininet.h>
	#include <wustl.h>

	//
	// NOTE: IWUProgress not an OLE interface.  We will report progress
	//       using this interface.  Currently CWUProgress implmenents 
	//       this interface and displays a progress dialog box
	class IWUProgress
	{
	public:
		virtual void SetDownloadTotal(DWORD dwTotal) = 0;
		virtual void SetDownload(DWORD dwDone = 0xffffffff) = 0;
		virtual void SetDownloadAdd(DWORD dwAddSize, DWORD dwTime = 0) = 0;

		virtual void SetInstallTotal(DWORD dwTotal) = 0;
		virtual void SetInstall(DWORD dwDone = 0xffffffff) = 0;
		virtual void SetInstallAdd(DWORD dwAdd) = 0;

		virtual void SetStatusText(LPCTSTR pszStatus) = 0;

		virtual HANDLE GetCancelEvent() = 0;
	};


	#define NO_DOWNLOAD_FLAGS	0x00
	#define CACHE_FILE_LOCALLY	0x01
	#define DOWNLOAD_NEWER		0x02
	#define EXACT_FILENAME		0x04
	const int MAX_TIMESTRING_LENGTH	= 100;

	// session ID initialization constants
	const int SID_INITIALIZED	= 1;
	const int SID_NOT_INITIALIZED   = 0;

	class CWUDownload
	{
	public:
		static BOOL s_fOffline;
        static TCHAR        m_szWUSessionID[MAX_TIMESTRING_LENGTH]; // unique session ID (SID)
        static int          m_fIsSIDInitialized; // flag - has the static SID beein initialized?

		CWUDownload(
			IN				LPCTSTR	pszURL,
			IN	OPTIONAL	int 	iBufferSize = 1024
		);


		~CWUDownload();

		/*
		 * BOOL Copy(IN LPCTSTR szSourceFile, IN OPTIONAL LPCTSTR szDestFile, IN OPTIONAL PBYTE *ppData, IN OPTIONAL ULONG *piDataLen, IN OPTIONAL int (*CallBack)(int iPercent))
		 *
		 * PURPOSE: This method reads a file from an internet server.
		 *
		 * ARGUMENTS:
		 *
		 *		IN LPSTR szSourceFile			name of file to download. This is relative to the
		 *										server root so that http://www.server.com/myfile.txt
		 *										would be specified as: myfile.txt.
		 *		IN OPTIONAL LPSTR szDestFile	local destination this is NULL if no local file required
		 *		OUT OPTIONAL PBYTE *ppData		returned pointer to memory block that will contain the
		 *										downloaded file on a successfull return. This parameter
		 *										can be NULL if this functionality is not required.
		 *		IN OPTIONAL ULONG *piDataLen	pointer to returned downloaded data file length. This
		 *										parameter can be NULL if the downloaded file size is
		 *										not required. The caller is responsible for freeing this
		 *										pointer if a non NULL pointer is returned to the caller.
		 *		IN	OPTIONAL	BOOL	dwFlags	Flags that control the specific download behavior. This
		 *										parameter can be 0 which is the default or one or more of
		 *										of the following:
		 *											NO_DOWNLOAD_FLAGS	no download modifiers, this is the same as 0.
		 *											CACHE_FILE_LOCALLY	cache the file in the Windows Update directory.
		 *											DOWNLOAD_NEWER		download the file only if it's date and time is
		 *																newer than the file with the same name in the
		 *																Local machines Windows Update cache.
		 *																use local file if it is the same or newer.
		 *											EXACT_FILENAME		If this flag is specified then the file
		 *																created in the cache will be exactly the
		 *																same as the file on the server. If this 
		 *																flags is not specified then the cache file
		 *																name will be constructed of the entire
		 *																directory path name.
		 *		IN OPTIONAL IWUProgress* pProgress
		 *										A pointer to a IWUProgress interface. This paramter
		 *										can be NULL if progress is not required. 
		 *
		 *
		 * COMMENTS:
		 *
		 * If a callback function is specified as long as FALSE is returned the download continued. If
		 * the callback function returns TRUE then the download is aborted and LastError is set to
		 * ERROR_OPERATION_ABORTED. This allows the application to control the download process.
		 */
		BOOL Copy(
			IN				LPCTSTR	szSourceFile,
			IN	OPTIONAL	LPCTSTR	szDestFile = NULL,
			OUT	OPTIONAL	PVOID	*ppData = NULL,
			OUT	OPTIONAL	ULONG	*piDataLen = NULL,
			IN	OPTIONAL	BOOL	dwFlags = NO_DOWNLOAD_FLAGS,
			IN	OPTIONAL	IWUProgress* pProgress = NULL
		);


		/*
		 * BOOL QCopy(IN LPSTR szSourceFile, IN PBYTE *ppData, IN OPTIONAL ULONG *piDataLen)
		 *
		 * PURPOSE: This method reads a file from an internet server into memory. This function
		 *			is used when the file being read is < 1024 bytes in length so can be read
		 *			quickly.
		 *
		 * ARGUMENTS:
		 *
		 *		IN LPSTR szSourceFile			name of file to download. This is relative to the
		 *										server root so that http://www.server.com/myfile.txt
		 *										would be specified as: myfile.txt.
		 *		OUT PBYTE *ppData				returned pointer to memory block that will contain the
		 *										downloaded file on a successfull return. This parameter
		 *										can be NULL if this functionality is not required.
		 *		IN OPTIONAL ULONG *piDataLen	pointer to returned downloaded data file length. This
		 *										parameter can be NULL if the downloaded file size is
		 *										not required. The caller is responsible for freeing this
		 *										pointer if a non NULL pointer is returned to the caller.
		 *
		 * COMMENTS:
		 *
		 */
		BOOL QCopy(
			IN				LPCTSTR	szSourceFile,
			OUT	OPTIONAL	PVOID	*ppData,
			OUT	OPTIONAL	ULONG	*piDataLen
		);

		BOOL MemCopy(
			IN	LPCTSTR szSourceFile,
			OUT byte_buffer& bufDest
		);

		// posts formdata and downloads the response to szDestFile
		BOOL PostCopy(LPCTSTR pszFormData, LPCTSTR szDestFile, IWUProgress* pProgress);


		LPTSTR GetServerPath()
		{
			return m_szServerPath;
		}

		BOOL CacheUsed()
		{
			return m_bCacheUsed;
		}

		// return time taken for last download operation in Millisecons, 0 if cache used
		DWORD GetCopyTime()
		{
			return m_dwCopyTime;
		}

		// return size in bytes of the last file downloaded
		DWORD GetCopySize()
		{
			return m_dwCopySize;
		}


	private:
		int			m_iBufferSize;	//internal copy buffer size.
		PSTR		m_szBuffer;		//internal copy buffer of m_iBufferSize bytes.
		HINTERNET	m_hSession;		//handle to wininet library
		HINTERNET	m_hConnection;	//handle to server connection.
		HANDLE		m_exitEvent;	//request thread handler to exit
		HANDLE		m_readEvent;	//request internet block read
		HANDLE		m_finished;		//requested event (read or exit) is finished
	
		TCHAR		*m_szServerPath;	
		TCHAR		*m_szRelURL;
		BOOL		m_bCacheUsed;
		DWORD		m_dwCopyTime;
		DWORD		m_dwCopySize;
	};

	#define _INC_CWUDownload

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\selection.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Selection.h
//
//  Owner:  CharlMa
//
//  Description:
//
//      interface for the CSelection class. It implements 
//		a collection of type CORP_SELECTION, used to 
//		record the selected (checked) status of items in the
//		corporate catalog.
//
//		structure type CORP_SELECTOIN is also defined here
//
//=======================================================================
// Selection.h: interface for the CSelection class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _SELECTION_H_INCLUDED_


typedef struct _CORP_SELECTION
{
	PUID			puid;
	DWORD			dwLocale;
	enumV3Platform	platform;
	BOOL			bSelected;
	int			iStatus;		//installation status
	HRESULT		hrError;	   //installation error code
} CORP_SELECTION, *PCORP_SELECTION;


class CSelections  
{
public:
	CSelections();
	CSelections(int iSize);
	
	~CSelections();

	//
	// adjust the collection size
	//
	HRESULT	SetCollectionSize(int iSize);
	void	Clear(void);

	//
	// add a new item to the selection collection
	//
	HRESULT AddItem(PUID puid, DWORD dwLocale, enumV3Platform platform, BOOL bSelected);
	HRESULT AddItem(CORP_SELECTION Item);

	//
	// retrive item information from collection
	//
	inline int GetCount(void) { return m_iCount; };
	PCORP_SELECTION GetItem(int Index);
	inline BOOL isItemChecked(int Index) 
		{return m_pSelections[Index].bSelected; };

	//
	// modify the selection status of one item
	//
	HRESULT SetItemSelection(int index, BOOL bSelected);
	HRESULT SetItemErrorCode(int index, HRESULT hr);

private:

	PCORP_SELECTION m_pSelections;
	int			m_iSize;
	int			m_iCount;
};



#define _SELECTION_H_INCLUDED_
#endif // !defined(_SELECTION_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\locstr.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    locstr.h
//
//  Purpose: Localized strings and templates
//
//=======================================================================

#ifndef _LOCSTR_H
#define _LOCSTR_H

#include <windows.h>
#include <objbase.h>
#include "debug.h"


//
// string types
//
#define LOC_STRINGS           0   // localized strings
#define TEMPLATE_STRINGS	  1   // template strings


//
// NOTE: Do not change these defines.  They are positional
//

// localized strings
#define IDS_PROG_DOWNLOADCAP  0   // "Download progress:"
#define IDS_PROG_TIMELEFTCAP  1   // "Download time remaining:"
#define IDS_PROG_INSTALLCAP   2   // "Install progress:"
#define IDS_PROG_CANCEL 	  3   // "Cancel"
#define IDS_PROG_BYTES		  4   // "%d KB/%d KB"
#define IDS_PROG_TIME_SEC	  5   // "%d sec"
#define IDS_PROG_TIME_MIN	  6   // "%d min"
#define IDS_PROG_TIME_HRMIN   7   // "%d hr %d min"

#define IDS_APP_TITLE		  8   // "Microsoft Windows Update"
#define IDS_REBOOT1 		  9   // "You must restart Windows so that installation can finish."
#define IDS_REBOOT2 		  10  // "Do you want to restart now?"

#define LOCSTR_COUNT          11


// template strings
#define IDS_TEMPLATE_ITEM		0  // item template
#define IDS_TEMPLATE_SEC		1  // section template
#define IDS_TEMPLATE_SUBSEC 	2  // sub section template
#define IDS_TEMPLATE_SUBSUBSEC	3  // subsub section template

#define TEMPLATESTR_COUNT		4



HRESULT SetStringsFromSafeArray(VARIANT* vStringsArr, int iStringType);

void SetLocStr(int iNum, LPCTSTR pszStr);
LPCTSTR GetLocStr(int iNum);

void SetTemplateStr(int iNum, LPCTSTR pszStr);
LPCTSTR GetTemplateStr(int iNum);


#endif // _LOCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\servpaus.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    servpaus.h
//
//  Purpose: Service Pauser class.  Allows pausing the taskscheduler and then automatically 
//  restoring it to original state if we wanted more services to be paused like 
//  screen savers etc, we will add methods here
//
//=======================================================================

#ifndef _SERVPAUS_H
#define _SERVPAUS_H

#include <windows.h>

//
// CServPauser class
//
class CServPauser
{
public:
	void PauseTaskScheduler()
	{
		iSageRestoreTo = EnableSage(DISABLE_AGENT);
		bSageRestore = (iSageRestoreTo == ENABLE_AGENT);
	}

	CServPauser() :
		bSageRestore(FALSE)
	{
	}

	~CServPauser()
	{
		if (bSageRestore)
		{
			EnableSage(iSageRestoreTo);
		}
	}

private:
	enum {ENABLE_AGENT = 1, DISABLE_AGENT = 2, GET_AGENT_STATUS = 3};   // from sage.h

	BOOL bSageRestore;	
	int iSageRestoreTo;

	int EnableSage(int iEnable);
};


#endif // _SERVPAUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\varray.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.

#ifndef _INC_ARRAY_TEMPLATE


	//If the Version 3 catalog standard library has been included then use its
	//memory allocation definations as these types include the correct error
	//handling.

	#define LOCALMALLOC(size)	V3_calloc(1, size)
	#define LOCALREALLOC(memblock, size)	V3_realloc(memblock, size)
	#define LOCALFREE(p)	V3_free(p)


	/*
	 * Variable Array Template
	 *
	 * This header defines a variable element array. This allows run time arrays
	 * of any size to be used with having to worry about managing the internal
	 * memory.
	 *
	 * For example:
	 *
	 * To use an array of longs declair Varray<long> x;
	 *
	 * You can then say x[50] = 5L; and the array will size itself to provide space for at least
	 * 50 longs.
	 *
	 * You can also specify an initial size in the constructor. So to create a variable array of
	 * class type Cfoo with an initial size of 50 you would declair Varray<Cfoo> x(50);
	 *
	 * To access the array simply use the array symbols in the first example you would write
	 * long ll = x[5]; to get the sixth element.
	 *
	 * Note: The array is 0 based.
	 *
	 * Also when memory for the template's internal storage is allocted it is not initialize in
	 * any manner. This means that a classes constructor is not called. It is the responsibility
	 * of the caller to have any classes that are placed into the array to already be initialized.
	 * 
	 */

	template <class TYPE> class Varray
	{
	public:
			Varray(int iInitialSize = 1);
			~Varray<TYPE>();
			inline TYPE &operator[]( int index );
			inline TYPE &Insert(int insertAt, int iElements);
			inline int SIZEOF(void);
			inline int LastUsed(void);
			//inline TYPE *operator &(); Note: To pass a pointer to the beginning
			//of the array simply use &array[0].
	private:
			TYPE	*m_pArray;
			int		m_iMaxArray;
			int		m_iMinAllocSize;
			int		m_iLastUsedArray;
	};

	/*
	 * Varray class constructor
	 *
	 * Constructs a dynamic size class array of the specified type.
	 *
	 * The array is initialized to have space for 1 element.
	 *
	 */

	template <class TYPE> Varray<TYPE>::Varray(int iInitialSize)
	{
		if ( iInitialSize <= 0 )
			iInitialSize = 1;

		m_pArray = (TYPE *)LOCALMALLOC(iInitialSize * sizeof(TYPE));

		m_iMaxArray			= 1;
		m_iMinAllocSize		= 1;
		m_iLastUsedArray	= -1;
	}

	/*
	 * Varray class destructor
	 *
	 * frees up the space used by a Varray
	 *
	 */

	template <class TYPE>Varray<TYPE>::~Varray()
	{
		if ( m_pArray )
			LOCALFREE( m_pArray );

		m_iMaxArray = 0;
		m_iMinAllocSize	= 1;
	}

	/*
	 * Varray operator [] handler
	 *
	 * Allows one to access the elements of a Varray. The array is resized
	 * as necessary to accomidate the number of elements needed.
	 *
	 *
	 * There are three cases that need to be handled by the allocation scheme.
	 * Sequential allocation this is where the caller is initializing an array
	 * in a sequential manner. We want to keep new requests to the memory
	 * allocator to a mimimum. Two is where the client asks for an array element
	 * far outside the currently allocated block size. Three when the client is
	 * using an element that is allready allocated.
	 * 
	 * This class's solution is to keep a block size count and double it. This
	 * keeps going up to a fixed size limit. The allocation occurs every time
	 * a new array allocation is required.
	 */

	template <class TYPE> inline TYPE &Varray<TYPE>::operator[]( int index )
	{
		int iCurrentSize;
		int	nextAllocSize;

		if ( index >= m_iMaxArray )
		{
			nextAllocSize = m_iMinAllocSize;
			if ( nextAllocSize < 512 )
				nextAllocSize = m_iMinAllocSize * 2;

			iCurrentSize = m_iMaxArray;

			if ( index - m_iMaxArray >= nextAllocSize )
				m_iMaxArray = index + 1;
			else
			{
				m_iMaxArray = m_iMaxArray + nextAllocSize;
				m_iMinAllocSize = nextAllocSize;
			}
			m_pArray = (TYPE *)LOCALREALLOC(m_pArray, m_iMaxArray * sizeof(TYPE));

			//clear out new cells
			memset(m_pArray+iCurrentSize, 0, (m_iMaxArray-iCurrentSize) * sizeof(TYPE));
		}

		if ( index > m_iLastUsedArray )
			m_iLastUsedArray = index;

		return (*((TYPE*) &m_pArray[index]));
	}

	template <class TYPE> inline TYPE &Varray<TYPE>::Insert(int insertAt, int iElements)
	{
		int	i;
		int iCurrentSize;

		iCurrentSize = m_iMaxArray;

		m_iMaxArray += iElements+1;

		m_pArray = (TYPE *)LOCALREALLOC(m_pArray, m_iMaxArray * sizeof(TYPE));

		for(i=iCurrentSize; i>=insertAt; i--)
			memcpy(&m_pArray[i+iElements], &m_pArray[i], sizeof(TYPE));

		//clear out new cells
		memset(m_pArray+insertAt, 0, iElements * sizeof(TYPE));

		return (*((TYPE*) &m_pArray[insertAt]));
	}

	/*
	 * Varray SIZEOF method
	 *
	 * The SIZEOF method returns the currently allocated size of the
	 * internal array.
	 */

	template <class TYPE> inline int Varray<TYPE>::SIZEOF(void)
	{
		return m_iMaxArray;
	}

	//Note: This method will be invalid after elements are inserted into the
	//varray. So use with caution.

	template <class TYPE> inline int Varray<TYPE>::LastUsed(void)
	{
		return m_iLastUsedArray;
	}

	#define _INC_ARRAY_TEMPLATE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\wuerror.h ===
/
// THIS FILE IS OBSOLETE AND IS NOT BEING USED.  WE WILL REMOVE THIS FILE SOON.
// 



#ifndef _WUV3IS_ERROR_CODES

	#define WU_SEVERITY_ERROR	3
	#define WU_FACILITY_ERROR	255

	#define WU_CATALOG_DOES_NOT_EXIST		(HRESULT)26000	//requested atalog does not exist.
	#define WU_ITEM_DOES_NOT_EXIST			(HRESULT)26001	//requested item does not exist in any known catalog.
	#define WU_ITEM_INSTALL_DEPENDENCY_EXISTS	(HRESULT)26002	//Selected state has installation dependencies.
	#define WU_INVALID_PARAMETER			(HRESULT)26003	//Invalid parameter passed to method.
	#define WU_NO_ITEM_DEPENDENCIES_FOUND		(HRESULT)26004	//Item identified by the puid parameter is not dependent on any other items.
	#define WU_MISSING_INSTALL_CIF			(HRESULT)26006	//The Item cannot be installed because the install CIF cab is not present in the item record.
	#define WU_MISSING_INSTALL_CABS			(HRESULT)26007	//The Item cannot be installed because the install cab list is not present in the item record.
	#define WU_INSTALL_FAILED			(HRESULT)26008	//The Item cannot be installed.
	#define WU_MISSING_HWID				(HRESULT)26009	//The Item cannot be installed becuase the device hwid is missing.
	#define WU_CREATEVXDFAILS			(HRESULT)26010	//The wubios.vxd cannot be created.
	#define WU_INVALID_INSTALLATION_RECORD_TYPE	(HRESULT)26011	//The inventory record is not of a type that can be installed.

	#define _WUV3IS_ERROR_CODES

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\v3stdlib.h ===
/*
 * v3stdlib.h - definitions/declarations for shared functions for the V3 catalog
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 */

#ifndef _INC_V3STDLIB
#define _INC_V3STDLIB

//
// memory management wrappers
//
void *V3_calloc(size_t num,	size_t size);

void V3_free(void *p);

void *V3_malloc(size_t size);

void *V3_realloc(void *memblock, size_t size);

BOOL V3_CreateDirectory(LPCTSTR szPath);
BOOL V3_RebootSystem();

//returned a pointer to string 2 within string 1 or a NULL pointer if
//string2 is not found within string1. This function is similar to the
//strstr library function except it works in a case insensitive
//manner.
char *stristr(
	  const char*	string1,	//string to search
	  const char*	string2		//string to look for in string 1
	  );

LPTSTR lstristr(
	  LPCTSTR	string1,	//string to search
	  LPCTSTR	string2		//string to look for in string 1
	  );


//Adds a backslash character to the end of a string if the end ofthe string does
//not already contain a backslash. This function is very usefull in file path
//operations.
void AddBackSlash(LPTSTR szStr);

//This function skips any white space (space, tab, return, life feed characters)
//beginning at the character at ptr up to the end of string. The end of the string
//is assumed to be NULL terminated.
char *SkipSpaces(LPSTR ptr);


//This function takes an ascii string of hex digits and returned the numeric value.
//The function terminates on an invalid hex digit.
int atoh(LPCSTR ptr);

//This function works the same as strncpy except it ensures that that
//the returned string is NULL terminated at count characters. This allows
//a safe way to perform a strcpy since the count can be set to the
//sizeof(strDest).
LPTSTR __cdecl lstrzncpy(
	LPTSTR strDest,
	LPCTSTR strSource,
	size_t count
	);

char* __cdecl strzncpy(
	char* strDest,
	const char* strSource,
	size_t count
	);

LPCTSTR lstrcpystr(LPCTSTR pszStr, LPCTSTR pszSep, LPTSTR pszTokOut);
const char* strcpystr(const char* pszStr, const char* pszSep, char* pszTokOut);

void GetWindowsUpdateDirectory(LPTSTR pszPath);

void GetCurTime(SYSTEMTIME* pstDateTime);

BOOL FileExists(LPCTSTR szFile);

DWORD LaunchProcess(LPCTSTR pszCmd, LPCTSTR pszDir, UINT uShow, BOOL bWait);

bool DeleteNode(LPCTSTR szDir);

void RemoveLastSlash(LPTSTR szPath);

BOOL ReplaceSingleToken(LPSTR* ppszNewStr, LPCSTR pszStr, LPCSTR pszToken, LPCSTR pszValue);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\speed.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    speed.h
//
//  Purpose: Connection speed tracker
//
//=======================================================================

#ifndef _SPEED_H
#define _SPEED_H

#include <windows.h>
 

class CConnSpeed
{
public:
	// size in bytes and time in milliseconds
	static void Learn(DWORD dwBytes, DWORD dwTime);

	static DWORD BytesPerSecond();
	static void ReadFromRegistry();
	static void WriteToRegistry();
	
private:

	static DWORD m_dwBytesSoFar;
	static DWORD m_dwTimeSoFar;
	static DWORD m_dwAverage;
	static DWORD m_dwNewWeightPct;

};


#endif // _SPEED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\wuv3.h ===
/*
 * wuv3.h - definitions/declarations for Windows Update V3 Catalog infra-structure
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 * Purpose:
 *       This file defines the structures, values, macros, and functions
 *       used by the Version 3 Windows Update Catalog
 *
 */

#ifndef _WU_V3_CATALOG_INC

	#pragma pack(1)

	#define BLOCK

	typedef struct _WU_VERSION
	{
		WORD	major;		//major package version (5)
		WORD	minor;		//minor package version (0)
		WORD	build;		//build package version (2014)
		WORD	ext;		//additional version specification (216)
	} WU_VERSION, *PWU_VERSION;

	//Active setup and Driver type inventory record flags.
	//The WU_BROWSER_LANGAUGE_FLAG is used to specify that the browser
	//language should be used when determining what localized description
	//to display.

	//No other flags this value is only valid with no other defines are used.
	//This will cause the OS langauge to be used to use browser languge for
	//this inventory catalog item pass in the WU_BROWSER_LANGUAGE_FLAG

	#define WU_NOSPECIAL_FLAGS			((BYTE)0x00)

	//If this flag is set then we use the install cabs based on the browser locale else
	//else the install cabs come from the detected OS locale.

	#define	WU_BROWSER_LANGAUGE_FLAG	((BYTE)0x01)

	//The WU_HIDDEN_ITEM_FLAG is used to specify that the item should be hidden even
	//if it would normally detect as available.

	#define WU_HIDDEN_ITEM_FLAG			((BYTE)0x02)

	//The WU_PATCH_ITEM_FLAG is set if this inventory item is a patch.
	//Patch packages are only offered if the version that is detected on
	//the client's computer exactly matches the patch version.

	#define	WU_PATCH_ITEM_FLAG			((BYTE)0x04)

	//The WU_UPDATE_ONLY_FLAG is set if this inventory item is only to be shown
	//if it is detected as an update item.

	#define WU_UPDATE_ONLY_FLAG			((BYTE)0x08)

	//The WU_MULTILANGUAGE_FLAG is set if this inventory item is only applicable to
	//multi language OS and is a multi language enable package. This changes the way
	//in which the bitmask is process for this item. The bitmask is interpreted as
	//this update applies to systems where it is determined that the update contains
	//a language version applicable for the selected set of languages installed on this OS.
 
	#define WU_MULTILANGUAGE_FLAG		((BYTE)0x10)

	//Item is marked as a critical update. This flag also applies to the inventory.plt
	//list of catalogs.

	#define WU_CRITICAL_UPDATE_ITEM_FLAG	((BYTE)0x20)

	//The following defines are used for the inventory catalog record's variable type fields.

	//The WU_VARIABLE_END field is the only required field variable field. It is used to signify
	//that there are no more variable fields associated with an inventory record.
	#define	WU_VARIABLE_END						((short)0)

	//codes 1 - 25 are for detection dlls. This allows us to reduce catalog size
	//over time when the detection dll is used by may different packages

	#define WU_DETECT_DLL_GENERIC				(short)1		//detection dll other than wudetect name follows
	#define WU_DETECT_DLL_REG_KEY_EXISTS		(short)2		//wudetect.dll,RegKeyExists no additional data

	//codes 26 - 39 are for reg values this equates to the DetRegKey= key in the detection CIF file.

	//This will cause the line DetRegKey=string data to be placed into the detection CIF.
	//The string data is a null terminated string that indicates what data to copy for example:
	//DetRegKey=HKLM,software\microsoft\windows\currentversion\setup\optionalcomponents\games
	//would have the string data set to HKLM,software\microsoft\windows\currentversion\setup\optionalcomponents\games
	#define	WU_DETREGKEY						(short)25

		//This will cause the string that follows to be placed into the CIF as "DetRegValue=string"
	#define WU_DETREGVALUE_INSTALLED_GENERIC	(short)40

	//This will cause the CIF line to be placed into the detection CIF, DetRegValue=Installed,SZ,1
	#define WU_DETREGVALUE_INSTALLED_SZ1		(short)41

	//This variable length field is used in the corporate version of the WU catalog and it contains the CDM driver file bucket id. This id is a DWORD. This field allows the CDM corporate catalog control to bypass the normal CDM groveling and download all of the the server driver content in the corporate catalog.
	#define	WU_CDM_BUCKETID_VALUE				(short)42

	//This variable length field is used by the V3 control to store the grovled hwid in with
	//the cdm record. This is necessary because when the description file for this record is
	//read from the server it needs to grovel the local machine for a registry key and if this
	//key is present the Description read function will need to create an uninstall variable
	//field for the clients in memory description structure.

	#define	WU_CDM_HARDWARE_ID					(short)43


	//This variable length field contains the letter designation of the active setup detection
	//locale that is to be used for this package. If this variable field is not present then
	//the locale id '*' is used. The '*' causes Active setup to accept the default locale.
	#define WU_DET_CIF_LOCALE					(short)44

	//This data structure defines the format for a WU_PATH_FILEINFO type.
	typedef struct _PATCHINFO
	{
		DWORD	checkSum;	//File checksum for this patch file.
		#pragma warning( disable : 4200 )
			char	szFileName[];	//NULL terminated file name that this checksum belongs to.
		#pragma warning( default : 4200 )
	} PATCHINFO, *PPATCHINFO;

	//This variable field is used to provide the information needed to install patch items. Patch
	//items required an exact match on the each file type to be allowed an installation. The data
	//type used for the patch variable is composed of the id followed by one or more patchinfo
	//structures. The AddPatchField() API in the util.cpp is used by the backend creation tool to
	//add fields of this type into an inventory record's variable length field.

	#define	WU_PATCH_FILEINFO				(short)45

	
	//This variable length field is used by an inventory record to inform the installer
	//that the default cab pool platform should be used to find the installation cabs.
	//This variable length field has no data associated with it so its length is 4 bytes.
	#define WU_USE_DEFAULT_PLATFORM			(short)46

	//This variable length field is used by an inventory record to inform the installer
	//that this field contains a PUID that shows where the installation cabs are. So the
	//length of this field will be 8 bytes. id=2,len=2, PUID=4
	#define WU_PUID_OVERRIDE				(short)47

	//Following variable length id is used to mark an entry inactive 
	#define WU_VARIABLE_MERGEINACTIVE		(short)48

	// Driver date/version format mm/dd/yyyy,...
	#define WU_VARIABLE_DRIVERVER			(short)49

	#define	WU_PLOC							(short)50   // obsolete

	#define WU_PLOCLEGEND					(short)51   // obsolete
	
	#define WU_PLOCBITMASK					(short)52   // obsolete

	#define	WU_CDM_DRIVER_NAME				(short)53

	//value of the uninstallkey to be used in detection CIF
	#define WU_KEY_UNINSTALLKEY             (short)54

	//depends key with PUIDs
	#define WU_KEY_DEPENDSKEY				(short)55

	// all the _keys used by detection DLLs separated by \n
    #define WU_KEY_CUSTOMDETECT             (short)56

	// install priority description file (DWORD)
    #define WU_DESC_INSTALL_PRIORITY        (short)57


	// product id for 128 bit security check
    #define WU_DESC_128BIT_PRODID			(short)58

	// URL for 128 bit security check 
    #define WU_DESC_128BIT_URL				(short)59

	// AltName 
	#define WU_DESC_ALTNAME					(short)60

	// An array of CRC hash structs (WUCRC_HASH) for each CAB file name specified in WU_DESCRIPTION_CABFILENAME
	// in the same order.
	#define WU_DESC_CRC_ARRAY               (short)61

	// Architecture string for printer driver
	#define WU_CDM_PRINTER_DRIVER_ARCH      (short)62


	// An array of CRC hash structs (WUCRC_HASH) for RTF HTM (always the first item) and images 
	// the images following the first item are in the same order as WU_DESC_RTF_IMAGES
	#define WU_DESC_RTF_CRC_ARRAY           (short)63
	
	// contains names of the images and which correspond to WU_DESC_RTF_CRC_ARRAY starting from second item
	// does not contain name of the read this RTF HTM which is assumed to be PUID.HTM
	// field is missing if there are no images
	#define WU_DESC_RTF_IMAGES              (short)64
	
	// contains the CRC for the install cif file in the form of a WUCRC_HASH
	#define WU_DESC_CIF_CRC					(short)65


	// contains the name of the EULA to be used for this item.  If the field is empty
	// then we assume that its EULA.HTM found in the EULA directory under content folder.  
	// We modify the file name by adding plat_loc_ prefix to it.  For example, 2_0x00000409_eula.htm
	#define WU_DESC_EULA					(short)66


	struct DESCDIAGINFO
	{
		long puid;
		DWORD dwLocale;
		DWORD dwPlat;
	};

	// diagnostic information only (DESCDIAGINFO)
	#define WU_DESC_DIAGINFO				(short)67

	//
	// These values are written into the bitmask.plt file as the platform ids. When additional
	// platforms are added we will need to add a new enumeration value here.
	//
	// IMPORTANT NOTE!!! 
	//     This definition must be consistant with osdet.cpp detection as well as with the database
	typedef enum
	{
		enV3_DefPlat = 0,
		enV3_W95IE5 = 1,
		enV3_W98IE4 = 2,
		enV3_W98IE5 = 3,
		enV3_NT4IE5X86 = 4,
		enV3_NT4IE5ALPHA = 5,
		enV3_NT5IE5X86 = 6,
		//enV3_NT5IE5ALPHA = 7,
		enV3_NT4IE4ALPHA = 8,
		enV3_NT4IE4X86 = 9,
		enV3_W95IE4 = 10,
		enV3_MILLENNIUMIE5 = 11,
		enV3_W98SEIE5 = 12,
		//enV3_NEPTUNEIE5 = 13,
		enV3_NT4IE5_5X86 = 14,
		enV3_W95IE5_5 = 15,
		enV3_W98IE5_5 = 16,
		enV3_NT5IE5_5X86 = 17,
		enV3_Wistler = 18,
		enV3_Wistler64 = 19,
		enV3_NT5DC = 20,
	} enumV3Platform;


	/*
	// (05/01/2001)
	// Since the following structure is marked as obsolete and is not being used anywhere, I am commenting it out, 
	// as it gives the follwoing warning when build with /w4
	// d:\nt\wurel\os\xp\cltrc1\wincom\wuv3\inc\wuv3.h(255) : error C4310: cast truncates constant value

	//obsolete
	typedef struct _PLOC  
	{
		WORD	platform;	//Platform ID for this identifier. This currently can be one of:
		DWORD	dwLocale;	//Locale id that this PLOC is for.
		BOOL IsSelected(void) { return ((platform & (WORD)0x8000) != 0 ); }
		void Select(void) { (platform |= (WORD)0x8000); return; }
		void Clear(void) { (platform &= (BYTE)0x7fff); return; }
	} PLOC, *PPLOC;

	*/	


	#ifndef PUID
		typedef long	PUID;		//Windows Update assigned identifier
									//that is unique across catalogs.
		typedef PUID	*PPUID;		//Pointer to a PUID type.
	#endif

	//defined value used in the link and installLink fields to indicate
	//no link dependencies

	#define WU_NO_LINK						(PUID)-1

	//PUID's cannot normally be 0 so 0 is used as a special identifier in the case of
	//GetCatalog. GetCatalog uses a 0 puid to indicate the master list of sub-catalogs.

	#define WU_CATALOG_LIST_PUID			(PUID)0




	typedef struct ACTIVESETUP_RECORD
	{
		GUID		g;								//guid that identifies the item to be updated
		PUID		puid;							//Windows Update assigned unique identifier. This value is unique for all inventory record types, (Active Setup, CDM, and Section records). This ID specifies the name of the description and installation cab files.
		WU_VERSION	version;						//version of package that is this inventory record identifies
		BYTE		flags;							//flags specific to this record.
		PUID		link;							//PUID value of other record in inventory list that this record is dependent on. This field contains WU_NO_LINK if this item has no dependencies.
		PUID		installLink;					//The installLink field contains either WU_NO_LINK if there are no install
													//dependencies else this is the index of an item that must be
													//installed before this item can be installed. This is mainly
													//used for device drivers however there is nothing in the catalog
													//structure that precludes this link being used for applications
													//as well.
	} ACTIVESETUP_RECORD, *PACTIVESETUP_RECORD;

	GUID const WU_GUID_SPECIAL_RECORD	= { 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x0, 0x00, 0x0, 0x00, 0x0, 0x00 } };

	#define WU_GUID_DRIVER_RECORD				WU_GUID_SPECIAL_RECORD
	#define WU_GUID_DETECTION_DLL_RECORD		WU_GUID_SPECIAL_RECORD 

	//Add a new section record identifier if a new detection method needs to be added.

	#define SECTION_RECORD_TYPE_SECTION					(BYTE)1
	#define SECTION_RECORD_TYPE_DEVICE_DRIVER			(BYTE)2
	//This is simply for consistenty with the spec. The spec refers to
	//device driver insertion record. From the codes standpoint the is
	//a SECTION_RECORD_TYPE_DEVICE_DRIVER however this define makes it
	//a little unclear so I defined another type with the same value and
	//will change the v3 control code to use it. I am leaving the old define
	//above in place so that the backend tool set does not break.
	#define SECTION_RECORD_TYPE_DEVICE_DRIVER_INSERTION	(BYTE)2
	#define SECTION_RECORD_TYPE_PRINTER					(BYTE)3
	#define SECTION_RECORD_TYPE_DRIVER_RECORD			(BYTE)4
	#define	SECTION_RECORD_TYPE_CATALOG_RECORD			(BYTE)5	//Inventory.plt catalog item record that describes a sub catalog.

	#define SECTION_RECORD_LEVEL_SECTION				(BYTE)0

	#define SECTION_RECORD_LEVEL_SUBSECTION				(BYTE)1	//sub section of current section
	#define SECTION_RECORD_LEVEL_SUBSUBSECTION			(BYTE)2	//sub section of previous sub section

	//The SECTION_RECORD_UPDATE specifies that the section record update is
	//a special section. This type is used if present to place items that
	//are to be shown as recommended updates. A record update section is
	//always tied to the previous section or sub section. For example if
	//the inventory catalog order was:
	//
	//section
	//	sub section
	//		item 1 - Detects as Update
	//		item 2 - Detects as new offering
	//		item 3 - already present
	//	update section
	//
	//Then the processed list would read
	//
	//section
	//	sub section
	//		item 2 - Detects as new offering
	//	update section
	//		item 1 - Detects as Update

	#define SECTION_RECORD_UPDATE				(BYTE)3


	typedef struct _SECTION_RECORD
	{
		GUID	g;								//guid this type of record is WU_GUID_SPECIAL_RECORD
		BYTE	type;							//section record type
		PUID	puid;							//Windows Update assigned unique identifier. This value is unique for all inventory record types, (Active Setup, CDM, and Section records). This ID specifies the name of the description and installation cab files.
		BYTE	flags;							//flags specific to this record.
		BYTE	level;							//section level can be a section, sub section or sub sub section
	} SECTION_RECORD, *PSECTION_RECORD;

	typedef struct _DRIVER_RECORD
	{
		GUID		g;							//guid this type of record is WU_GUID_DRIVER_RECORD
		BYTE		type;						//driver record indicator flag, This type is set to
												//SECTION_RECORD_TYPE_DEVICE_DRIVER
												//i.e. SECTION_RECORD_TYPE_DEVICE_DRIVER_INSERTION
												//for a device driver or printer record place holder.
		PUID		puid;						//Windows Update assigned unique identifier. This value is unique for all inventory record types, (Active Setup, CDM, and Section records). This ID specifies the name of the description and installation cab files.
		WU_VERSION	reserved;						
		BYTE		flags;						//flags specific to this record.
		PUID		link;						//PUID value of other record in inventory list that this record is dependent on. This field contains WU_NO_LINK if this item has no dependencies.
		PUID		installLink;				//The installLink field contains either 0 if there are no install
												//dependencies else this is the index of an item that must be
												//installed before this item can be installed. This is mainly
												//used for device drivers however there is nothing in the catalog
												//structure that precludes this link being used for applications
												//as well.
	} DRIVER_RECORD, *PDRIVER_RECORD;

	typedef union _WU_INV_FIXED
	{
		ACTIVESETUP_RECORD	a;					//Active Setup detection record
		SECTION_RECORD		s;					//Catalog section record
		DRIVER_RECORD		d;					//CDM driver record insertion point
												//if additional inventory detection
												//record types are added they need to be added here.
	} WU_INV_FIXED, *PWU_INV_FIXED;


	typedef struct _WU_VARIABLE_FIELD
	{
		_WU_VARIABLE_FIELD();

		short	id;		//record type identifier
		short	len;	//length of variable record data

		//size we are using a 0 size array place hold we need to disable the
		//compiler warning since it will complain about this being non standard
		//behavor.
		#pragma warning( disable : 4200 )
		BYTE	pData[];	//variable field record data
		#pragma warning( default : 4200 )

		//The GetNextItem function returns a pointer to the next variable array item
		//if it exists or NULL if it does not.
		struct _WU_VARIABLE_FIELD *GetNext(void);

		//The FindItem function returns a pointer to the next variable array item
		//if the requested item is found or NULL the item is not found.
		struct _WU_VARIABLE_FIELD *Find(short id);

		//returns the total size of this variable field array.
		int GetSize(void);
	} WU_VARIABLE_FIELD, *PWU_VARIABLE_FIELD;


	#define	WU_ITEM_STATE_UNKNOWN	0	//Inventory item state has not been detected yet
	#define	WU_ITEM_STATE_INSTALL	1	//Inventory item has been detected as an installable item
	#define	WU_ITEM_STATE_UPDATE	2	//Inventory item has been detected as an Updatable item
	#define	WU_ITEM_STATE_PRUNED	3	//Inventory item has been pruned from the list.
	#define	WU_ITEM_STATE_CURRENT	4	//Inventory item has been detected at the currently installed item.

	#define WU_STATE_REASON_NONE        0
	#define WU_STATE_REASON_UPDATEONLY  1
	#define WU_STATE_REASON_BITMASK     2
	#define WU_STATE_REASON_PERSONALIZE 3
	#define WU_STATE_REASON_BACKEND     4
	#define WU_STATE_REASON_OLDERUPDATE 5
	#define WU_STATE_REASON_DRIVERINS   6
	#define WU_STATE_REASON_HIDDENDEP   7
	#define WU_STATE_REASON_PRUNED      8
	#define WU_STATE_REASON_CURRENT     9

	typedef struct _WU_INV_STATE
	{
		BYTE	state;					//Currently defined item state (Unknown, Installed, Update, Pruned)
		BOOL	bChecked;				//TRUE if the user has selected this item to be installed | updated
		BOOL	bHidden;				//Item display state, TRUE = hide from user FALSE = show item to user.
		BOOL    dwReason;			    //reason for the items current state
		WU_VERSION	verInstalled;						
	} WU_INV_STATE, *PWU_INV_STATE;

	//Description specific flags

	#define	DESCRIPTION_FLAGS_COOL			((DWORD)0x01)	//new update
	#define DESCRIPTION_FLAGS_POWER			((DWORD)0x02)	//best for power users
	#define DESCRIPTION_FLAGS_NEW			((DWORD)0x04)	//cool stuff
	#define	DESCRIPTION_FLAGS_REGISTRATION	((DWORD)0x08)	//registration required
	#define DESCRIPTION_EXCLUSIVE			((DWORD)0x10)	//This item cannot be selected with other items.
	#define DESCRIPTION_WARNING_SCARY		((DWORD)0x20)	//Display a scary warning message
	#define DESCRIPTION_128BIT				((DWORD)0x40)	//128bit stuff

	//defined variable Description file items.
	#define WU_DESCRIPTION_NONE				((short)0)		//no other description flags only valid if used with no other flags
	#define WU_DESCRIPTION_TITLE			((short)1)		//title of item that is to be displayed
	#define WU_DESCRIPTION_DESCRIPTION		((short)2)		//description text that is displayed with item
	#define WU_DESCRIPTION_PACKAGE			((short)3)		//?????
	#define WU_DESCRIPTION_EURLA_URL		((short)4)		//license text url that needs read and accepted before package is installed
	#define WU_DESCRIPTION_READTHIS_URL		((short)5)		//read this first url
	#define WU_DESCRIPTION_PATCH			((short)6)		//?????? this is not a patch in the clasic sense need to find out what this is
	#define WU_DESCRIPTION_UNINSTALL_KEY	((short)7)		//uninstall command
	#define	WU_DESCRIPTION_INSTALLCABNAME	((short)8)		//name of cab file that contains the installation CIF. This cab name is a NULL terminated string and is passed to active setup to install the package.
	#define	WU_DESCRIPTION_CABFILENAME		((short)9)		//cab file name for installation this is one or more and is in the format of an array of NULL terminated strings with the last entry double null terminated. This is known as a multisz string in the langauge of the registry.
	#define WU_DESCRIPTION_SERVERROOT		((short)10)		//Server root3rd Level - Server root for install cabs. The tools and database will also need to understand that at times a piece of content can be located on a different download server from the main server and the structures need to be able to handle this. This allows us to host a single server site, a split server site like what we have today and a multi headed download server farm. The real goal behind this is to make sure we can host OEM content on the site without having to store the cabs on our servers.
															
	typedef struct _WU_DESCRIPTION
	{
		DWORD				flags;					//Icon flags to display with description
		DWORD				size;					//compressed total size of package
		DWORD				downloadTime;			//time to download @ 28,800
		PUID				dependency;				//display dependency link
		PWU_VARIABLE_FIELD	pv;						//variable length fields associated with this description file
	} WU_DESCRIPTION, *PWU_DESCRIPTION;

	//These flags are used by the client in memory inventory file to quickly determine
	//the type of inventory record. This is stored in each inventory item

	//add new inventory detection record types if required here.

	#define WU_TYPE_ACTIVE_SETUP_RECORD			((BYTE)1)	//active setup record type
	#define WU_TYPE_CDM_RECORD_PLACE_HOLDER		((BYTE)2)	//cdm code download manager place holder record. This is used to set the insertion point for other CDM driver records. Note: There is only one of these per inventory catalog.
	#define WU_TYPE_CDM_RECORD					((BYTE)3)	//cdm code download manager record type
	#define WU_TYPE_SECTION_RECORD				((BYTE)4)	//a section record place holder
	#define WU_TYPE_SUBSECTION_RECORD			((BYTE)5)	//a sub section record place holder
	#define WU_TYPE_SUBSUBSECTION_RECORD		((BYTE)6)	//a sub sub section record place holder
	#define	WU_TYPE_RECORD_TYPE_PRINTER			((BYTE)7)	//a printer detection record type
	#define	WU_TYPE_CATALOG_RECORD				((BYTE)8)	//Inventory.plt catalog item record that describes a sub catalog.

	//data return values used with GetItemInfo
	#define WU_ITEM_GUID			1	//item's guid.
	#define WU_ITEM_PUID			2	//item's puid.
	#define WU_ITEM_FLAGS			3	//item's flags.
	#define WU_ITEM_LINK			4	//item's detection dependency link.
	#define WU_ITEM_INSTALL_LINK		5	//item's install dependency link.
	#define WU_ITEM_LEVEL			6	//section record's level.

	typedef struct _INVENTORY_ITEM
	{
		int					iReserved;		//inventory record bitmask index
		BYTE				recordType;		//in memory item record type. This is setup when the catalog is parsed by the ParseCatalog method.
		int					ndxLinkDetect;	//index of item upon which this item is dependent. If this item is not dependent on any other items then this item will be -1.
		int					ndxLinkInstall;	//index of item upon which this item is dependent. If this item is not dependent on any other items then this item will be -1.
		PWU_INV_FIXED		pf;				//fixed record portion of the catalog inventory.
		PWU_VARIABLE_FIELD	pv;				//variable portion of the catalog inventory
		PWU_INV_STATE		ps;				//Current item state
		PWU_DESCRIPTION		pd;				//item description structure

		//Copies information about an inventory item to a user supplied buffer.
		BOOL GetFixedFieldInfo
			(
				int		infoType,	//type of information to be returned
				PVOID	pBuffer		//caller supplied buffer for the returned information. The caller is responsible for ensuring that the return buffer is large enough to contain the requested information.
			);

		//Quickly returns an items puid id to a caller.
		PUID GetPuid
			(
				void
			);
	} INVENTORY_ITEM, *PINVENTORY_ITEM;

	typedef struct _WU_CATALOG_HEADER
	{
		short	version;		//version of the catalog (this allows for future expansion)
		int		totalItems;		//total items in catalog
		BYTE	sortOrder;		//catalog sort order. 0 is the default and means use the position value of the record within the catalog.
	} WU_CATALOG_HEADER, *PWU_CATALOG_HEADER;

	typedef struct _WU_CATALOG
	{
		WU_CATALOG_HEADER	hdr;		//catalog header record (note the parsing function will need to fixup the items pointer when the catalog is read)
		PINVENTORY_ITEM		*pItems;	//beginning of individual catalog items
	} WU_CATALOG, *PWU_CATALOG;

	//size of the OEM field in a bitmask record. This is for documentation and clarity
	//The actual field in the BITMASK structure is a pointer to an array of OEM fields.

	//bitmask helper macros
	//returns 1 if bit is set 0 if bit is not set
	inline bool GETBIT(PBYTE pbits, int index) { return (pbits[(index/8)] & (0x80 >> (index%8))) != 0; }

	//sets requested bit to 1
	inline void SETBIT(PBYTE pbits, int index) { pbits[index/8] |= (0x080 >> (index%8)); }
	
	//clears requested bit to 0
	inline void CLRBIT(PBYTE pbits, int index) { pbits[index/8] &= (0xff ^ (0x080 >> (index%8))); }

	#define BITMASK_GLOBAL_INDEX		0		//index of global bitmask
	#define BITMASK_OEM_DEFAULT			1		//index of default OEM bitmask

	#define BITMASK_ID_OEM				((BYTE)1)	//BITMASKID entry is an OEM id
	#define BITMASK_ID_LOCALE			((BYTE)2)	//BITMASKID entry is a LOCALE id

	//The bitmask file is arranged as a series of bit bitmasks in the same order as
	//the oem and langauge ids. For example if DELL1 was the second id in the id
	//array section of the bitmask file then is bitmask would begin the third bitmask
	//in the bitmask section of the file. The reason that it is the third and not
	//second is that the first bitmask is always the global bitmask and there is no
	//corrisponding id field for the global mask as this mask is always present.

	//A bitmask OEM or LOCALE id is a DWORD.

	typedef DWORD BITMASKID;
	typedef DWORD *PBITMASKID;

	typedef struct _BITMASK
	{
		int	iRecordSize;	//number of bits in a single bitmask record
		int iBitOffset;		//offset to bitmap bits in bytes
		int	iOemCount;		//Total number of oem ids in bitmask
		int	iLocaleCount;	//Total number of locale ids in bitmask
		int	iPlatformCount;	//Total number of platforms defined.

		#pragma warning( disable : 4200 )
			BITMASKID	bmID[];		//OEM & LANGAUGE & future types arrays.
		#pragma warning( default : 4200 )

		//since there are one or more array of OEM & LANGAUGE types this needs to be
		//a pointer and will need to be manually set to the correct location when the
		//bitmask file is created or read.

		PBYTE GetBitsPtr(void) { return ((PBYTE)this+iBitOffset); }		//beginning of bitmask bit arrays
		PBYTE GetBitMaskPtr(int index) { return GetBitsPtr() + ((iRecordSize+7)/8) * index; }

	} BITMASK, *PBITMASK;



	//catalog list

	#define	CATLIST_STANDARD			((DWORD)0x00)	
	#define CATLIST_CRITICALUPDATE		((DWORD)0x01)	
	#define CATLIST_DRIVERSPRESENT		((DWORD)0x02)	
	#define CATLIST_AUTOUPDATE			((DWORD)0x04)
	#define CATLIST_SILENTUPDATE		((DWORD)0x08)
	#define CATLIST_64BIT				((DWORD)0x10)
    #define CATLIST_SETUP               ((DWORD)0x20)

	typedef struct _CATALOGLIST
	{
		DWORD dwPlatform;
		DWORD dwCatPuid;
		DWORD dwFlags;
	} CATALOGLIST, *PCATALOGLIST;
	
	
	//Global scope functions that handle creation of variable size objects for the
	//inventory item and description structures.

	//Adds a variable size field to an inventory type Variable size field
	void __cdecl AddVariableSizeField
		(
			IN OUT PINVENTORY_ITEM	*pItem,	//pointer to variable field after pvNew is added.
			IN PWU_VARIABLE_FIELD	pvNew	//new variable field to add
		);

	//Adds a variable size field to a description type Variable size field
	void __cdecl AddVariableSizeField
		(
			IN	PWU_DESCRIPTION	*pDescription,	//pointer to variable field after pvNew is added.
			PWU_VARIABLE_FIELD pvNew	//new variable field to add
		);

	//Adds a variable size field to a variable field chain.
	//The format of a variable size field is:
	//[(short)id][(short)len][variable size data]
	//The variable field always ends with a WU_VARIABLE_END type.

	PWU_VARIABLE_FIELD CreateVariableField
		(
			IN	short	id,			//id of variable field to add to variable chain.
			IN	PBYTE	pData,		//pointer to binary data to add.
			IN	int		iDataLen	//Length of binary data to add.
		);

	//Converts a ##,##,##,## to the V3 catalog version format
	void __cdecl StringToVersion
		(
			IN		LPSTR		szStr,		//string version
			IN OUT	PWU_VERSION	pVersion	//WU version structure that contains converted version string
		);

	//Converts a V3 catalog version to a string format ##,##,##,##
	void __cdecl VersionToString
		(
			IN		PWU_VERSION	pVersion,		//WU version structure that contains the version to be converted to a string.
			IN OUT	LPSTR		szStr			//character string array that will contain the converted version, the caller
												//needs to ensure that this array is at least 16 bytes.
		);

	//0 if they are equal
	//1 if pV1 > pv2
	//-1 if pV1 < pV2
	//compares active setup type versions and returns:

	int __cdecl CompareASVersions
		(
			PWU_VERSION pV1,	//pointer to version1
			PWU_VERSION pV2		//pointer to version2
		);


	BOOL IsValidGuid(GUID* pGuid);


	#define _WU_V3_CATALOG_INC

	//This USEWUV3INCLUDES define is for simplicity. If this present then we include
	//the other headers that are commonly used for V3 control objects. Note: These
	//objects still come from a 1:1 interleave library wuv3.lib. So you only get
	//the objects that you use in your application.

	#pragma pack()

	#ifdef USEWUV3INCLUDES
		#include <debug.h>
		#include <cwudload.h>
		#include <diamond.h>
		#include <ccatalog.h>
		#include <cbitmask.h>
		#include <ccdm.h>
		#include <selection.h>
		#undef _MAC
		#include <wuv3sys.h>
	#endif

    const int MAX_CATALOG_INI = 1024;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\wuv3sys.h ===
/*
* wuv3sys.h - definitions/declarations for Windows Update V3 Catalog infra-structure
*
*  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
*
*/
#ifndef _WU_V3_WUV3SYS
#define _WU_V3_WUV3SYS

#include <wuv3.h>

DWORD GetMachineLangDW();
DWORD GetUserLangDW();
BOOL IsAlpha();
BOOL DoesClientPlatformSupportDrivers();
BOOL IsWindowsNT();
BOOL CallOsDet(LPCTSTR pszOsDetFile, PDWORD* ppiPlatformIDs, PINT piTotalIDs);
BOOL AppendExtForOS(LPTSTR pszFN);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\inc\wuv3ctl.h ===
/*
 * WUV3CTL.h - definitions/declarations for Windows Update V3 Catalog infra-structure
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 * Purpose:
 *       This file defines the structures, values, macros, and functions
 *       used by the Version 3 Windows Update Catalog Control
 *
 */

#ifndef _WUV3CTL_INC

	#pragma pack(1)

	//GetCatalog lFilters


	#define USEWUV3INCLUDES
	#include <wuv3.h>
	#undef USEWUV3INCLUDES


	//filter values for GetCatalog
	#define WU_ALL_ITEMS				(long)0x00000000    //all items (no hidden items)
	#define WU_UPDATE_ITEMS				(long)0x10000000	//items that are not currently installed

	#define WU_NO_DEVICE_DRIVERS		(long)0x00000200	//do not return drivers (can be used with WU_ALL_ITEMS)
	#define WU_PERSONALIZE_HIDDEN       (long)0x00000800    //items hidden by user (can be used with WU_ALL_ITEMS)
	#define WU_HIDDEN_ITEMS 			(long)0x00000001	//only items marked as hidden.
	#define WU_SELECTED_ITEMS			(long)0x00000002	//selected items.
	#define WU_NOT_SELECTED_ITEMS		(long)0x00000004	//items that are not currently selected.
	#define WU_NEW_ITEMS				(long)0x00000008	//items that are marked as new
	#define WU_POWER_ITEMS				(long)0x00000010	//items that are marked as power user items
	#define WU_REGISTER_ITEMS			(long)0x00000020	//items that are marked as needing registration
	#define WU_COOL_ITEMS				(long)0x00000040	//items that are marked as cool
	#define WU_EUAL_ITEMS				(long)0x00000080	//items that are marked as having a End user
	#define WU_PATCH_ITEMS				(long)0x00000100	//items that are marked as a patch.
	

	//used for ProcessCatalog
	#define WU_NO_PRUNING				(long)0x00000400		//This flag is mainly used for corporate catalog as well as internal
															//debugging and testing, it will cause the pruning logic to not be
	//applied to the retrieved catalog.

	//GetCatalog array status values
	#define GETCATALOG_STATUS_HIDDEN				(long)0x00000001	//Catalog item hidden.
	#define GETCATALOG_STATUS_SELECTED				(long)0x00000002	//Catalog item selected for installation.
	#define GETCATALOG_STATUS_NEW					(long)0x00000004	//Catalog item is a new offering.
	#define GETCATALOG_STATUS_POWER					(long)0x00000008	//Catalog item is best for power users.
	#define GETCATALOG_STATUS_REGISTRATION			(long)0x00000010	//Catalog item requires that the client be registered.
	#define GETCATALOG_STATUS_COOL					(long)0x00000020	//Catalog item is considered an interesting item.
	#define GETCATALOG_STATUS_PATCH					(long)0x00000040	//Catalog item is a patch so requires special handling.
	#define GETCATALOG_STATUS_SECTION				(long)0x00000080	//Catalog item is a section header.
	#define GETCATALOG_STATUS_SUBSECTION			(long)0x00000100	//Catalog item is a sub section header.
	#define GETCATALOG_STATUS_SUBSUBSECTION			(long)0x00000200	//Catalog item is a sub sub section header.
	#define GETCATALOG_STATUS_INSTALL				(long)0x00000400	//Catalog item is an install for an item that the client current does not have.
	#define GETCATALOG_STATUS_UPDATE				(long)0x00000800	//Catalog item is an update for an item that currently exists on the client computer.
	#define GETCATALOG_STATUS_CURRENT				(long)0x00001000	//Catalog item is currently installed on the client system.
	#define GETCATALOG_STATUS_UNKNOWN				(long)0x00002000	//Catalog item's status could not be determined.
	#define GETCATALOG_STATUS_CRITICALUPDATE		(long)0x00004000	//Catalog item is marked as a critical update item.
	#define GETCATALOG_STATUS_EXCLUSIVE				(long)0x00008000	//Catalog item is exclusive it cannot be selected with other components.
	#define GETCATALOG_STATUS_PERSONALIZE_HIDDEN	(long)0x00010000	//Catalog item hidden by registry
	#define GETCATALOG_STATUS_WARNING_SCARY			(long)0x00020000	//Display a scary warning message


	//ChangeItemState possible states
	#define ITEM_STATE_HIDE_ITEM			(long)0x00000001	//Hide Catalog item
	#define ITEM_STATE_SHOW_ITEM			(long)0x00000002	//Show Catalog item
	#define ITEM_STATE_SELECT_ITEM			(long)0x00000004	//Select Catalog item
	#define ITEM_STATE_UNSELECT_ITEM		(long)0x00000008	//Unselect Catalog item
	#define ITEM_STATE_PERSONALIZE_HIDE		(long)0x00000010	//Hide item using registry hiding
	#define ITEM_STATE_INSTALL_ITEM			(long)0x00000020	//The item is to be selected for installation.
	#define ITEM_STATE_REMOVE_ITEM			(long)0x00000040	//The item is to be selected for removal.
	#define ITEM_STATE_PERSONALIZE_UNHIDE	(long)0x00000080	//Unhide item from registry hiding

	//InstallSelectedItems flags
	#define	WU_NO_SPECIAL_FLAGS			(long)0x00000000	//This flag is only valid if used by itself. It is used

	#define	WU_COPYONLY_NO_INSTALL		(long)0x00000001	//This flag is used to indicate that the selected packages
															//should be copied to the client machine but not installed.

	//The OPERATION_SUCCESS and OPERATION_FAILED equate to
	//ITEM_STATUS_SUCCESS and ITEM_STATUS_INSTALLED_ERROR which
	//are defined in cstate.h

	#define OPERATION_SUCCESS	(long)0x0000000	//Log entry operation was successfull.
	#define OPERATION_ERROR		(long)0x0000001	//Log entry operation had one or more errors.
	#define OPERATION_STARTED	(long)0x0000002	//Log entry operation was started
	
	#define INSTALL_OPERATION	(long)0x0001000	//Log entry is for an Install Operation.
	#define REMOVE_OPERATION	(long)0x0002000	//Log entry is for an Remove Operation.

	//flags for FinalizeInstall
	#define FINALIZE_DOREBOOT         0x00000001
	#define FINALIZE_NOREBOOTPROMPT   0x00000002

	//Install Remove Item History structure.

	typedef struct _HISTORYSTRUCT
	{
		PUID		puid;				//item's puid.
		char		szTitle[256];		//items title.
		BOOL		bInstall;			//TRUE if installed, FALSE if removed
		DWORD		bResult;			//OPERATION_SUCCESS, OPERATION_ERROR, OPERATION_STARTED
		HRESULT		hrError;			//specific error code if an error occured.
		char		szVersion[40];      //formated version or driverver
		char		szDate[32];
		char		szTime[32];
		BYTE		RecType;            //record type: driver or activesetup
		BOOL		bV2;                //imported from V2
	} HISTORYSTRUCT, *PHISTORYSTRUCT;


	//Each catalog item is returned in a structure of this type.
	typedef struct _CATALOG32ITEM
	{
		PUID	puid;			//Items puid identifier.
		PTCHAR	pTitle;			//localized title display text.
		PTCHAR	pDescription;	//localized description text.
		long	lStatus;		//status of this item.
		int		iDownloadSize;	//download size in bytes.
		int		iDownloadTime;	//download time in minutes.
		PSTR	pUninstallKey;	//uninstall string
	} CATALOG32ITEM, *PCATALOG32ITEM;

	//Structures used with the C++ Interfaces
	typedef struct _CATALOG32
	{
		int				iTotalItems;	//Total items in catalog
		PCATALOG32ITEM	pItems;			//Array of catalog item structures.
	} CATALOG32, *PCATALOG32;

	//Install Results item structure
	typedef struct _INSTALLRESULTSTATUS
	{
		PUID	puid;		//The identifier for this record.
		int		iStatus;	//This field is one of the following:
							//ITEM_STATUS_SUCCESS			The package was installed successfully.
 							//ITEM_STATUS_INSTALLED_ERROR	The package was Installed however there were some minor problems that did not prevent installation.
							//ITEM_STATUS_FAILED			The packages was not installed.
		HRESULT	hrError;	//Error describing the reason that the package did not install if the Status field is not equal to SUCCESS.
	} INSTALLRESULTSTATUS, *PINSTALLRESULTSTATUS;

	//Install results array returned from GetInstallStatus32().
	typedef struct _INSTALLRESULTSARRAY
	{
		int						iTotalItems;	//Total items returned in array.
		PINSTALLRESULTSTATUS	pItems;			//Specific install status items.
	} INSTALLRESULTSARRAY, *PINSTALLRESULTSARRAY;

	//Install Metrics item structure
	typedef struct _INSTALLMETRICSITEMS
	{
		PUID	puid;		//The identifier for this record.
		int		iDownloadSize;	//download size in bytes.
		int		iDownloadTime;	//download time in minutes.
	} INSTALLMETRICSITEMS, *PINSTALLMETRICSITEMS;

	//Install results array returned from GetInstallStatus32().
	typedef struct _INSTALLMETRICSARRAY
	{
		int						iTotalItems;	//Total items returned in array.
		PINSTALLMETRICSITEMS	pItems;			//Specific install status items.
	} INSTALLMETRICSARRAY, *PINSTALLMETRICSARRAY;

	//Returned install and remove history structure array. This array
	//is returned from the GetInstallHistory32() method.
	typedef struct _HISTORYARRAY
	{
		int				iTotalItems;	//Total returned items.
		#pragma warning( disable : 4200 )
		HISTORYSTRUCT	HistoryItems[];	//Array of history items.
		#pragma warning( default : 4200 )
	} HISTORYARRAY, *PHISTORYARRAY;


	//
	// IWUpdateCatalog interface
	//
	class __declspec(novtable) IWUpdateCatalog : public IUnknown
	{
	public:
		STDMETHOD(WUIsCatalogAvailable)(long puidCatalog, BSTR bstrServerUrl) = 0;
		STDMETHOD(WUGetCatalog)(long puidCatalog, BSTR bstrServerUrl, long platformId, BSTR bstrBrowserLangauge, CCatalog** ppCatalogArray) = 0;
		STDMETHOD(WUDownloadItems)(CSelections* pSelections, BSTR bstrServer, BSTR bstrTempDir) = 0;
		STDMETHOD(WUInstallItems)(CSelections* pSelections, BSTR bstrServer, BSTR bstrTempDir) = 0;
		STDMETHOD(WURemoveItems)(CSelections* pSelections) = 0;
		STDMETHOD(WUCopyInstallHistory)(HISTORYARRAY** ppHistoryArray) = 0;
		STDMETHOD(WUCopyDependencyList)(long puidItem, long** ppDepPuid) = 0;
		STDMETHOD(WUProgressDlg)(BOOL bOn) = 0;
	};

	class __declspec(uuid("1B1FA90D-96CD-11d2-9E16-00C04F79E980")) IWUpdateCatalog;

	#include <autoupd.h>

	#pragma pack()

	#define _WUV3CTL_INC
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\osdet\sources.inc ===
#!include ..\..\..\wu.inc

!IF 0

  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.

  File:   source.inc

  Owner:  YanL

  Description:

      OSDET.DLL sources

!ENDIF

TARGETNAME=OSDET
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK

UMTYPE=windows

USE_NOLIBS=1
DLLENTRY=DllMain
C_DEFINES = $(C_DEFINES) -D_OSDET_ -DUNICODE -D_UNICODE
DLLDEF=..\OSDET.DEF

TARGETLIBS=\
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\ole32.lib

SOURCES=..\osdet.cpp ..\osdet.rc

INCLUDES=..\..\cdminc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\osdet\osdet.cpp ===
/*** osdet.cpp - OS Platform detection dll for V3
 *
 *  Created     11/18/98
 *
 *  MODIFICATION HISTORY
 * This currently just detects the client platform and returns it. As we detemine
 * what platform detection needs to do this module will change.
 *
 */

#include <windows.h>
#include <objbase.h>
#include <tchar.h>
#include <osdet.h>
#include <wuv3cdm.h>
#include <ar.h>

static enumV3Platform DetectClientPlatform(void);
static BOOL GetIEVersion(DWORD* dwMajor, DWORD* dwMinor);
static WORD CorrectGetACP(void);
static WORD CorrectGetOEMCP(void);
static LANGID MapLangID(LANGID langid);
static bool FIsNECMachine();

const LANGID LANGID_ENGLISH			= MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);			// 0x0409
const LANGID LANGID_GREEK			= MAKELANGID(LANG_GREEK, SUBLANG_DEFAULT);				// 0x0408
const LANGID LANGID_JAPANESE		= MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);			// 0x0411

const LANGID LANGID_ARABIC			= MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA);	// 0x0401
const LANGID LANGID_HEBREW			= MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT);				// 0x040D
const LANGID LANGID_THAI			= MAKELANGID(LANG_THAI, SUBLANG_DEFAULT);				// 0x041E


const TCHAR Win98_REGPATH_MACHLCID[] = _T("Control Panel\\Desktop\\ResourceLocale");
const TCHAR REGPATH_CODEPAGE[]		= _T("SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage");
const TCHAR REGKEY_OEMCP[]			= _T("OEMCP");
const TCHAR REGKEY_ACP[]				= _T("ACP");
const TCHAR REGKEY_LOCALE[]			= _T("Locale");

const WORD CODEPAGE_ARABIC			= 1256;
const WORD CODEPAGE_HEBREW			= 1255;
const WORD CODEPAGE_THAI			= 874;
const WORD CODEPAGE_GREEK_MS		= 737;
const WORD CODEPAGE_GREEK_IBM		= 869;

#define REGKEY_WUV3TEST		_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test")


// Registry keys to determine NEC machines
const TCHAR NT5_REGPATH_MACHTYPE[]   = _T("HARDWARE\\DESCRIPTION\\System");
const TCHAR NT5_REGKEY_MACHTYPE[]    = _T("Identifier");
const TCHAR REGVAL_MACHTYPE_AT[]		= _T("AT/AT COMPATIBLE");
const TCHAR REGVAL_MACHTYPE_NEC[]	= _T("NEC PC-98");

#define	LOOKUP_OEMID(keybdid)     HIBYTE(LOWORD((keybdid)))
#define	PC98_KEYBOARD_ID          0x0D


BOOL APIENTRY DllMain(
	HANDLE hModule, 
	DWORD  ul_reason_for_call, 
	LPVOID lpReserved
	)
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


//We have not defined what goes here yet. This will be the method called
//by the V3 control to determine platform ids that are then used with
//the catalog inventory.plt and bitmask.plt files.

void WINAPI V3_Detection(
	PINT *ppiPlatformIDs,
	PINT piTotalIDs
	) 
{

	//We use coTaskMemAlloc in order to be compatible with the V3 memory allocator.
	//We don't want the V3 memory exception handling in this dll.

	*ppiPlatformIDs = (PINT)CoTaskMemAlloc(sizeof(INT));
	if ( !*ppiPlatformIDs )
	{
		*piTotalIDs = 0;
	}
	else
	{
#ifdef _WUV3TEST
		auto_hkey hkey;
		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) 
		{
			DWORD dwPlatform = 0;
			DWORD dwSize = sizeof(dwPlatform);
			if (NO_ERROR == RegQueryValueEx(hkey, _T("Platform"), 0, 0, (LPBYTE)&dwPlatform, &dwSize))
			{
				*ppiPlatformIDs[0] = (int)dwPlatform;
				*piTotalIDs = 1;
				return;
			}
		}
#endif
		*ppiPlatformIDs[0] = (int)DetectClientPlatform();
		*piTotalIDs = 1;
	}

}

static LANGID MapLangID(LANGID langid)
{
	switch (PRIMARYLANGID(langid))
	{
		case LANG_ARABIC:
			langid = MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA);
			break;

		case LANG_CHINESE:
			if (SUBLANGID(langid) != SUBLANG_CHINESE_TRADITIONAL)
				langid = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
			break;

		case LANG_DUTCH:
			langid = MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH);
			break;

		case LANG_GERMAN:
			langid = MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN);
			break;

		case LANG_ENGLISH:
			//if (SUBLANGID(langid) != SUBLANG_ENGLISH_UK)
				langid = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
			break;

		case LANG_FRENCH:
			langid = MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH);
			break;

		case LANG_ITALIAN:
			langid = MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN);
			break;

		case LANG_KOREAN:
			langid = MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN);
			break;

		case LANG_NORWEGIAN:
			langid = MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL);
			break;

		case LANG_PORTUGUESE:
			// We support both SUBLANG_PORTUGUESE and SUBLANG_PORTUGUESE_BRAZILIAN
			break;

		case LANG_SPANISH:
			langid = MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH);
			break;

		case LANG_SWEDISH:
			langid = MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH);
			break;
	};
	return langid;
}



// return V3 language ID
DWORD WINAPI V3_GetLangID()
{

#ifdef _WUV3TEST
	// language spoofing
	auto_hkey hkey;
	if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
		DWORD dwLangID = 0;
		DWORD dwSize = sizeof(dwLangID);
		if (NO_ERROR == RegQueryValueEx(hkey, _T("LangID"), 0, 0, (LPBYTE)&dwLangID, &dwSize))
		{
			return dwLangID;
		}
	}
#endif

	WORD wCodePage = 0;
	LANGID langidCurrent = GetSystemDefaultUILanguage();

	//
	// special handling for languages
	//
	switch (langidCurrent) 
	{
		case LANGID_ENGLISH:

			// enabled langauges
			wCodePage = CorrectGetACP();
			if (CODEPAGE_ARABIC != wCodePage && 
				CODEPAGE_HEBREW != wCodePage && 
				CODEPAGE_THAI != wCodePage)
			{
				wCodePage = 0;
			}
			break;
		
		case LANGID_GREEK:

			// Greek IBM?
			wCodePage = CorrectGetOEMCP();
			if (wCodePage != CODEPAGE_GREEK_IBM)
			{
				// if its not Greek IBM we assume its MS. The language code for Greek MS does not include
				// the code page
				wCodePage = 0;
			}
			break;
		
		case LANGID_JAPANESE:

			if (FIsNECMachine())
			{
				wCodePage = 1;  
			}

			break;
		
		default:

			// map language to the ones we support
			langidCurrent = MapLangID(langidCurrent);	
			break;
	}
	return MAKELONG(langidCurrent, wCodePage);
}

DWORD WINAPI V3_GetUserLangID()
{

	WORD wCodePage = 0;
	LANGID langidCurrent = GetUserDefaultUILanguage();

	//
	// special handling for languages
    // (NOTE: duplicated above - can probably be optimized by putting this code into MapLangID
	//
	switch (langidCurrent) 
	{
		case LANGID_ENGLISH:

			// enabled langauges
			wCodePage = CorrectGetACP();
			if (CODEPAGE_ARABIC != wCodePage && 
				CODEPAGE_HEBREW != wCodePage && 
				CODEPAGE_THAI != wCodePage)
			{
				wCodePage = 0;
			}
			break;
		
		case LANGID_GREEK:

			// Greek IBM?
			wCodePage = CorrectGetOEMCP();
			if (wCodePage != CODEPAGE_GREEK_IBM)
			{
				// if its not Greek IBM we assume its MS. The language code for Greek MS does not include
				// the code page
				wCodePage = 0;
			}
			break;
		
		case LANGID_JAPANESE:

			if (FIsNECMachine())
			{
				wCodePage = 1;  
			}

			break;
		
		default:

			// map language to the ones we support
			langidCurrent = MapLangID(langidCurrent);	
			break;
	}
	return MAKELONG(langidCurrent, wCodePage);
}


static enumV3Platform DetectClientPlatform(void)
{
	#ifdef _WIN64
		return enV3_Wistler64;
	#else
		return enV3_Wistler;
	#endif
}


static BOOL GetIEVersion(DWORD* dwMajor, DWORD* dwMinor)
{	
	HKEY hSubKey;	
	DWORD	dwType;	
	ULONG	nLen;
	TCHAR szValue[MAX_PATH];	
	BOOL bResult = FALSE;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Internet Explorer"),
						  0, KEY_READ, &hSubKey) == NO_ERROR)	
	{
		nLen = MAX_PATH;
		if (RegQueryValueEx(hSubKey, _T("Version"), NULL, &dwType, (LPBYTE)szValue, &nLen) == NO_ERROR)
		{
			if ((nLen > 0) && (dwType == REG_SZ))
			{
				*dwMajor = (DWORD)szValue[0] - (DWORD)'0';

				if (nLen >= 3)
					*dwMinor = (DWORD)szValue[2] - (DWORD)'0';
				else
					*dwMinor = 0;

				return TRUE;
			}
				
		}	
		RegCloseKey(hSubKey);	
	}
	return FALSE;
}

static int aton(LPCTSTR ptr)
{
	int i = 0;
	while ('0' <= *ptr && *ptr <= '9')
	{
		i = 10 * i + (int)(*ptr - '0');
		ptr ++;
	}
	return i;
}




static WORD CorrectGetACP(void)
{
	WORD wCodePage = 0;
	auto_hkey hkey;
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_CODEPAGE, 0, KEY_QUERY_VALUE, &hkey);
	DWORD type;
	TCHAR szCodePage[MAX_PATH];
	DWORD size = sizeof(szCodePage);
	if (NO_ERROR == RegQueryValueEx(hkey, REGKEY_ACP, 0, &type, (BYTE *)szCodePage, &size) &&
		type == REG_SZ) 
	{
		wCodePage = (WORD)aton(szCodePage);
	}
	return wCodePage;
}


static WORD CorrectGetOEMCP(void)
{
	WORD wCodePage = 0;
	auto_hkey hkey;
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_CODEPAGE, 0, KEY_QUERY_VALUE, &hkey);
	DWORD type;
	TCHAR szCodePage[MAX_PATH];
	DWORD size = sizeof(szCodePage);
	if (NO_ERROR == RegQueryValueEx(hkey, REGKEY_OEMCP, 0, &type, (BYTE *)szCodePage, &size) &&
		type == REG_SZ) 
	{
		wCodePage = (WORD)aton(szCodePage);
	}
	return wCodePage;
}


static bool FIsNECMachine()
{
	
	bool fNEC = false;
	OSVERSIONINFO osverinfo;

	osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osverinfo))
	{
		if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			HKEY hKey;
			DWORD type;
			TCHAR tszMachineType[50];
			DWORD size = sizeof(tszMachineType);

			if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
								 NT5_REGPATH_MACHTYPE,
								 0,
								 KEY_QUERY_VALUE,
								 &hKey) == ERROR_SUCCESS)
			{
				if (RegQueryValueEx(hKey, 
										NT5_REGKEY_MACHTYPE, 
										0, 
										&type,
										(BYTE *)tszMachineType, 
										&size) == ERROR_SUCCESS)
				{
					if (type == REG_SZ)
					{
						if (lstrcmp(tszMachineType, REGVAL_MACHTYPE_NEC) == 0)
						{
							fNEC = true;
						}
					}
				}

				RegCloseKey(hKey);
			}
		}
		else // enOSWin98
		{
			// All NEC machines have NEC keyboards for Win98.  NEC
			// machine detection is based on this.
			if (LOOKUP_OEMID(GetKeyboardType(1)) == PC98_KEYBOARD_ID)
			{
				fNEC = true;
			}
		}
	}
	
	return fNEC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdu\dynamic.h ===
// wininet function pointer defs
typedef HINTERNET (*PFN_InternetOpen)(IN LPCSTR lpszAgent, IN DWORD dwAccessType, IN LPCSTR lpszProxyName, 
    IN LPCTSTR lpszProxyBypass, IN DWORD dwFlags);

typedef HINTERNET (*PFN_InternetConnect)(IN HINTERNET hInternet, IN LPCSTR lpszServerName, IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName, IN LPCSTR lpszPassword, IN DWORD dwService, IN DWORD dwFlags, IN DWORD_PTR dwContext);

typedef HINTERNET (*PFN_HttpOpenRequest)(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, 
    IN LPCSTR lpszVersion, IN LPCSTR lpszReferrer, IN LPCSTR FAR * lplpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext);

typedef BOOL (*PFN_HttpSendRequest)(IN HINTERNET hRequest, IN LPCSTR lpszHeaders, IN DWORD dwHeadersLength, 
    IN LPVOID lpOptional, IN DWORD dwOptionalLength);

typedef BOOL (*PFN_HttpQueryInfo)(IN HINTERNET hRequest, IN DWORD dwInfoLevel, IN OUT LPVOID lpBuffer, 
    IN OUT LPDWORD lpdwBufferLength, IN OUT LPDWORD lpdwIndex);

typedef BOOL (*PFN_InternetSetOption)(IN HINTERNET hInternet, IN DWORD dwOption, IN LPVOID lpBuffer, IN DWORD dwBufferLength);

typedef BOOL (*PFN_HttpAddRequestHeaders)(IN HINTERNET hConnect, IN LPCSTR lpszHeaders, IN DWORD dwHeadersLength,
    IN DWORD dwModifiers);

typedef BOOL (*PFN_InternetReadFile)(IN HINTERNET hFile, IN LPVOID lpBuffer, IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead);

typedef BOOL (*PFN_InternetCloseHandle)(IN HINTERNET hInternet);

typedef BOOL (*PFN_InternetCrackUrl)(IN LPCSTR lpszUrl, IN DWORD dwUrlLength, IN DWORD dwFlags, 
    IN OUT LPURL_COMPONENTSA lpUrlComponents);

typedef BOOL (*PFN_InternetGetConnectedState)(OUT LPDWORD dwFlags, IN DWORD dwReserved);

// shlwapi function pointer defs
typedef BOOL (*PFN_PathAppend)(LPSTR pszPath, LPCSTR pMore);

typedef BOOL (*PFN_PathRemoveFileSpec)(LPSTR pszPath);

// private function in wsdueng to set the estimated download speed
typedef void (*PFN_SetEstimatedDownloadSpeed)(DWORD dwBytesPerSecond);

// RogerJ --- add autodial function
typedef BOOL (*PFN_InternetAutodial) (IN DWORD dwFlags, IN HWND hParentWnd);

typedef BOOL (*PFN_InternetAutodialHangup) (IN DWORD dwReserved);
// DONE RogerJ



// callback function declaration
typedef struct 
{
    BOOL fHandled;
    BOOL fUnSupported;
    // char szDriverVer[32]; // not used
} PNPID_INFO, *PPNPID_INFO;

typedef BOOL (WINAPI * PWINNT32QUERY)(IN DWORD dwSetupQueryID, 
                                      IN PVOID pinData, 
                                      IN DWORD dwDataSize, 
                                      IN OUT PVOID poutData, 
                                      IN OUT PDWORD pdwDataSize);

#define SETUPQUERYID_PNPID 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdu\fdi.cpp ===
#include "wsdu.h"
#include <io.h>
#include <sys/stat.h>
#include <fcntl.h>

/*
 * Function prototypes 
 */
BOOL	fdi(char *cabinet_file, char *dir);
int		get_percentage(unsigned long a, unsigned long b);
char   *return_fdi_error_string(int err);


/*
 * Destination directory for extracted files
 */
char	dest_dir[256];

/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
	return malloc(cb);
}

/*
 * Memory free function
 */
FNFREE(mem_free)
{
	free(pv);
}


FNOPEN(file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
	return _read((int)hf, pv, cb);
}


FNWRITE(file_write)
{
	return _write((int)hf, pv, cb);
}


FNCLOSE(file_close)
{
	return _close((int)hf);
}


FNSEEK(file_seek)
{
	return _lseek((int)hf, dist, seektype);
}


FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
        	INT_PTR		handle;
            int		response;
			char	destination[256];

            wsprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);

            handle = file_open(
					destination,
					_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
					_S_IREAD | _S_IWRITE 
				);

            return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];
            
            wsprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);
			file_close(pfdin->hf);


            handle = CreateFile(
                destination,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime(
                    pfdin->date,
                    pfdin->time,
                    &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime(
                        &datetime,
                        &local_filetime))
                    {
                        (void) SetFileTime(
                            handle,
                            &local_filetime,
                            NULL,
                            &local_filetime
                        );
                     }
                }

                CloseHandle(handle);
            }

            attrs = pfdin->attribs;

            attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

            (void) SetFileAttributes(
                destination,
                attrs
            );

			return TRUE;
        }

		case fdintNEXT_CABINET:	// file continued to next cabinet
			return 0;
        
	}
	return 0;
}


BOOL fdi(char *cabinet_fullpath, char * directory)
{
	LOG_block("fdi()");
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR				hf;
	char			*p;
	char			cabinet_name[256];
	char			cabinet_path[256];

    strcpy(dest_dir, directory);
	if (dest_dir[strlen(dest_dir)] != '\\')
	{
		strcat(dest_dir, "\\");
	}

	hfdi = FDICreate(
		mem_alloc,
		mem_free,
		file_open,
		file_read,
		file_write,
		file_close,
		file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		LOG_error("FDICreate() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
		return FALSE;
	}


	/*
	 * Is this file really a cabinet?
	 */
	hf = file_open(
		cabinet_fullpath,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		LOG_error("Unable to open '%s' for input\n", cabinet_fullpath);
		return FALSE;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		// The file is not compressed, nothing to do. This is not an error, A lot of files on the V3 server use
		// conditional compression depending on whether it benefits the file size. 
		_close((int)hf);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}
	else
	{
		_close((int)hf);
	}

	p = strrchr(cabinet_fullpath, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, cabinet_fullpath);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		strncpy(cabinet_path, cabinet_fullpath, (int) (p-cabinet_fullpath)+1);
		cabinet_path[ (int) (p-cabinet_fullpath)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		notification_function,
		NULL,
		NULL))
	{
		LOG_error("FDICopy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
		LOG_error("FDIDestroy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
		return FALSE;
	}

	return TRUE;
}


char *return_fdi_error_string(int err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return "No error";

		case FDIERROR_CABINET_NOT_FOUND:
			return "Cabinet not found";
			
		case FDIERROR_NOT_A_CABINET:
			return "Not a cabinet";
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return "Unknown cabinet version";
			
		case FDIERROR_CORRUPT_CABINET:
			return "Corrupt cabinet";
			
		case FDIERROR_ALLOC_FAIL:
			return "Memory allocation failed";
			
		case FDIERROR_BAD_COMPR_TYPE:
			return "Unknown compression type";
			
		case FDIERROR_MDI_FAIL:
			return "Failure decompressing data";
			
		case FDIERROR_TARGET_FILE:
			return "Failure writing to target file";
			
		case FDIERROR_RESERVE_MISMATCH:
			return "Cabinets in set have different RESERVE sizes";
			
		case FDIERROR_WRONG_CABINET:
			return "Cabinet returned on fdintNEXT_CABINET is incorrect";
			
		case FDIERROR_USER_ABORT:
			return "User aborted";
			
		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdu\log.cpp ===
#include "wsdu.h"

#define REGKEY_WUV3TEST     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test"

FILE* CLogger::c_pfile = stdout;
int CLogger::c_cnIndent = 0;
int CLogger::c_cnLevels = -1;

CLogger::CLogger(
    const char* szBlockName /*= 0*/, 
    int nLoggingLevel/*= 0*/, 
    const char* szFileName/*= 0*/, 
    int nLine/*= 0*/
) 
{
    if (-1 == c_cnLevels)
    {
        /*c_cnLevels = 0;
        HKEY hkey;
        if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) 
        {
            DWORD dwSize = sizeof(c_cnLevels);
            RegQueryValueEx(hkey, "LogLevel", 0, 0, (LPBYTE)&c_cnLevels, &dwSize);
            char szLogFile[MAX_PATH] = {0};
            dwSize = sizeof(szLogFile);
            RegQueryValueEx(hkey, "LogFile", 0, 0, (LPBYTE)&szLogFile, &dwSize);
            FILE* pfile = fopen(szLogFile, "at");
            if (pfile)
            {
                c_pfile = pfile;
            }
            RegCloseKey(hkey);
        }*/
        char sz_LogFileName[MAX_PATH];
        c_cnLevels = 4; // default to log level 4
        ExpandEnvironmentStrings(cszLoggingFile, sz_LogFileName, MAX_PATH);
        FILE* pfile = fopen(sz_LogFileName, "wt");
        if (pfile)
        {
        	c_pfile = pfile;
        	fprintf(c_pfile,"****************************************\n");
        	SYSTEMTIME timeLocal;
        	GetLocalTime(&timeLocal);
        	fprintf(c_pfile,"%02d/%02d/%4d, %02d:%02d\n", timeLocal.wMonth, timeLocal.wDay, timeLocal.wYear, timeLocal.wHour, timeLocal.wMinute);
        	fprintf(c_pfile,"****************************************\n");
        }
    }
    m_szBlockName[0] = 0;
    //m_fOut = nLoggingLevel < c_cnLevels;
    m_fOut = TRUE;
    if (m_fOut && NULL != szBlockName) 
    {
        lstrcpyn(m_szBlockName, szBlockName, sizeOfArray(m_szBlockName));
        //out("%s %s(%d)", szBlockName, szFileName, nLine);
        out ("%s",szBlockName);
        m_dwStartTick = GetTickCount();
        c_cnIndent ++;
    }
}

CLogger::~CLogger()
{
    if (c_pfile && m_fOut && NULL != m_szBlockName[0]) 
    {
        c_cnIndent --;
        out("~%s (%d msecs)", m_szBlockName, GetTickCount() - m_dwStartTick);
    }
}

void __cdecl CLogger::out(const char *szFormat, ...)
{
    if (m_fOut) 
    {
        va_list va;
        va_start (va, szFormat);
        v_out(szFormat, va);
        va_end (va);
    }
}

void __cdecl CLogger::error(const char *szFormat, ...)
{
    if (m_fOut) 
    {
        va_list va;
        va_start (va, szFormat);
        char szOut[4 * 1024];
        wvsprintf(szOut, szFormat, va);
        va_end (va);
        out("ERROR - %s", szOut);
    }
}

void __cdecl CLogger::out1(const char *szFormat, ...)
{
    CLogger logger;
    va_list va;
    va_start (va, szFormat);
    logger.v_out(szFormat, va);
    va_end (va);
}

void CLogger::v_out( const char* szFormat, va_list va)
{
    char szOut[5 * 1024];
    char* pszOut = szOut;
    // Indent first
    for(int i = 0; i < c_cnIndent; i ++)
        *(pszOut ++) = '\t';
    wvsprintf(pszOut, szFormat, va);
    // move the file pointer to the end
    if (0 == fseek(c_pfile, 0, SEEK_END))
    {
        fprintf(c_pfile, "%s\n", szOut);
        fflush(c_pfile);
    }
}

void CLogger::close(void)
{
	if (c_pfile) fclose(c_pfile);
	c_pfile = NULL;
	c_cnLevels = -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdu\log.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   log.h
//
//  Owner:  Yan Leshinsly
//
//  Description:
//
//      Logging support
//
//=======================================================================
#pragma once

#ifndef LOGGING_LEVEL
    #define LOGGING_LEVEL 0
#endif

const char cszLoggingFile[] = "%WinDir%\\wsdu.log";

class CLogger
{
public:
    CLogger(const char* szBlockName = 0, int nLoggingLevel = 0, const char* szFileName = 0, int nLine = 0);
    ~CLogger();
    void __cdecl out(const char *szFormat, ...);
    void __cdecl error(const char *szFormat, ...);
    static void __cdecl out1(const char *szFormat, ...);
    static void __cdecl close(void);

private:
    void v_out( const char* szFormat, va_list va);

    bool m_fOut;
    char m_szBlockName[64];
    DWORD m_dwStartTick;
    
    static FILE* c_pfile;
    static int c_cnIndent;
    static int c_cnLevels;
};

#define THIS_FILE               __FILE__
#define LOG_block(name)         CLogger logger(name, LOGGING_LEVEL, THIS_FILE, __LINE__)
#define LOG_out                 logger.out
#define LOG_out1                CLogger::out1
#define LOG_error               logger.error
#define LOG_close				CLogger::close

#define report_error_if_false(f)    if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); } 
#define return_error_if_false(f)    if (f) {/*OK*/} else { DWORD dwErr = GetLastError(); LOG_error("%s LastError = %d", #f, dwErr); return dwErr;}
#define return_if_error(f)          { DWORD dwErr = f; if (dwErr) { LOG_error("%s LastError = %d", #f, dwErr); return dwErr;} }
#define return_if_false(f)      if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); return FALSE;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\dynamic.h ===
typedef BOOL (WINAPI * PWINNT32QUERY)(IN DWORD dwSetupQueryID, IN PVOID pinData, IN DWORD dwDataSize, IN OUT PVOID poutData, IN OUT PDWORD pdwDataSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\dudriver.h ===
//=======================================================================
//
//  File:   DuDriver.h (cut and paste slim down version of bucket.h)
//
//  Owner:  RogerJ (Original creator: YanL)
//
//  Description:
//
//      CDM bucket support
//
//=======================================================================

#ifndef _BUCKET_H

	#pragma pack(1)

	//CDM hash table structures
	//Hash table header
	typedef struct _CDM_HASHTABLEHDR
	{
		DWORD	iVersion;			//hash table version
		long	iTableSize;			//hash table size in bits
	} CDM_HASHTABLEHDR, *PCDM_HASHTABLEHDR;

	//hash table format
	typedef struct _CDM_HASHTABLE
	{
		CDM_HASHTABLEHDR	hdr;	//hash table header

		#pragma warning( disable : 4200 )
			BYTE	pData[];		//actual hash table bits
		#pragma warning( default : 4200 )

	} CDM_HASHTABLE, *PCDM_HASHTABLE;

	//This structure represents a cdm bucket file. A CDM bucket file
	typedef struct _CDM_RECORD_HEADER
	{
		long		cnRecordLength;					//Total length of the record
		long		nBitmaskIdx;						//cdm bitmask index
		PUID		puid;							//Windows Update assigned id that is unique
													//across catalogs and records. This id names
	} CDM_RECORD_HEADER, *PCDM_RECORD_HEADER;
	// Followed by:
	//	char		szHardwareID[];			\0 terminated
	//	char		szDescription[];		\0 terminated
	//	char		szMfgName[];			\0 terminated
	//	char		szProviderName[];		\0 terminated
	//	char		szDriverVer[];			\0 terminated
	//	char		szCabFileTitle[];		\0 terminated

	#pragma pack()

	// Prefixes for Printer Hardware IDs
	#define PRINT_ENVIRONMENT_INTEL						"0001"	// Windows NT x86
	#define PRINT_ENVIRONMENT_ALPHA						"0002"	// Windows NT Alpha_AXP


	ULONG CDM_HwID2Hash(IN LPCSTR szHwID, IN ULONG iTableSize);
	
	typedef struct _DRIVER_MATCH_INFO {
		LPCSTR pszHardwareID;
		LPCSTR pszDescription;
		LPCSTR pszMfgName;
		LPCSTR pszProviderName;
		LPCSTR pszDriverVer;
		LPCSTR pszCabFileTitle;
	} DRIVER_MATCH_INFO, *PDRIVER_MATCH_INFO;

	#define _BUCKET_H

	typedef struct _DRIVER_DOWNLOAD_INFO {
		int  nDriverVer;
		PosIndex Position;
		char szCabFile[MAX_PATH];
        PUID puid;
	} DRIVER_DOWNLOAD_INFO, *PDRIVER_DOWNLOAD_INFO;

	void PlaceHolderCleanUp(PDRIVER_DOWNLOAD_INFO* pTemp, int nTotal);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\dudriver.cpp ===
// ----------------------------------------------------------------------------------
//
// Created By RogerJ, October 3rd, 2000
// This CPP file has all the functions that related to driver detection (on W2K) and 
// driver downloading.  The setup item download part is in Wsdueng.cpp
//
// ----------------------------------------------------------------------------------

#include "Wsdueng.h"
#include <winspool.h>
// DuDriver.h includes definition of structures used in driver bitmap and bucket file, it is a
// cut and paste version of "bucket.h" (minus some unused function declaration)
#include "DuDriver.h"
#include "..\wsdu\Dynamic.h"

extern CDynamicUpdate* g_pDynamicUpdate;
// --------------------------------------------------------------------------------------------
// DLL Exposed function starts here
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversA()
// Function Description: This function is the entry point function of Win9x. It will construct 
//		the list of PnPId for searching of the web site and call DuDoSetUpItemDetection to get
// 		other item information
// Return Code: BOOL
//		TRUE --- if succeed
//		FALSE --- if failed, call GetLastError() to get the extensive error information
//
BOOL DuQueryUnsupportedDriversA (IN HANDLE hConnection, // connection handle
								 IN PCSTR *ListOfDriversNotOnCD, // multi-sz string array
								 OUT PDWORD pdwEstimatedTime,
								 OUT PDWORD pdwEstimatedSize)
{
	LOG_block("CDynamicUpdate::DuQueryUnsupportedDriversA");

	// parameter validation
	if (INVALID_HANDLE_VALUE == hConnection ||
		NULL == pdwEstimatedTime ||
		NULL == pdwEstimatedSize )
	{
		LOG_error("Invalid Parameter");
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	
	// do setup item detection first

    if (NULL == g_pDynamicUpdate)
        return FALSE;

    DWORD dwRetSetup, dwRetDriver;

    dwRetSetup = dwRetDriver = 0;
   
    g_pDynamicUpdate->ClearDownloadItemList();
    
    dwRetSetup = g_pDynamicUpdate->DoSetupUpdateDetection();
    if (ERROR_SUCCESS != dwRetSetup)
    {
        LOG_error("Setup item detection failed --- %d", dwRetSetup);
    }

    // do driver detection next
	// clean up the hardware id list first 
	g_pDynamicUpdate->m_arrayHardwareId.RemoveAll();
	
	// determine if there are drivers need download
    if (ListOfDriversNotOnCD) 
    {
		// iternate the PnPId list and construct the m_arrayHardwareId
		PSTR* ListIternator = const_cast<PSTR*>(ListOfDriversNotOnCD);
		while (*ListIternator)
		{
			g_pDynamicUpdate->m_arrayHardwareId.Add(*ListIternator);
			ListIternator++;
		}
		if (!g_pDynamicUpdate->DoWindowsUpdateDriverDetection())
		{
			dwRetDriver = GetLastError();
			LOG_error("Driver detection failed");
		}
	}

	if (dwRetSetup && dwRetDriver)
	{
		LOG_error("Both Setup item and Driver detection failed");
		return FALSE;
	}

	// determine the download time and download size
    if (g_pDynamicUpdate->m_dwDownloadItemCount > 0)
    {
        g_pDynamicUpdate->UpdateDownloadItemSize();
        *pdwEstimatedSize = g_pDynamicUpdate->m_dwTotalDownloadSize; // size in bytes
        // Time Estimate is based on roughly how long it took us to download the data files.
        if (0 == g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond)
            g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond = 2048; // default to 120k per minute, (2048 bytes per second).

        *pdwEstimatedTime = g_pDynamicUpdate->m_dwTotalDownloadSize / g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond; // number of seconds
        if (*pdwEstimatedTime == 0)
            *pdwEstimatedTime = 1; // at least one second

		if (dwRetSetup)
			SetLastError(dwRetSetup);
		if (dwRetDriver)
			SetLastError(dwRetDriver);

        return TRUE;
    }
    else
    {
        // At this point there was no error, but we have no items to download, 
        SetLastError(ERROR_NO_MORE_ITEMS);
        return TRUE;
    }
}

// ----------------------------------------------------------------------------------
// member function of CDynamicUpdate starts from here
// ----------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------
// Function Name: DoDriverDetection
// Function Description: This function will detect all the device currently installed 
//			in the machine and return (via member parameter) a multi-sz string array 
//			of all the hardware ids and the compatible ids.  The array will be NULL 
//			terminated
// Return Value: BOOL
//			TRUE for success
//			FALSE for failure, use GetLastError() to retrieve error code
//
BOOL CDynamicUpdate::DoDriverDetection (void) // connection handle
{
	// log
	LOG_block("DuDoDriverDetection");

	// Clean up and previous error code might exist
	SetLastError(0);

	BOOL fIsPrinterInfo6Supported = FALSE;
		
	// this function will call some setup API which is only supported on a certain 
	// platform.  We will do a platform detection here.  If the current platform 
	// does not support all the setup API we need, bail out.
	{
		OSVERSIONINFO OsInfo;
		ZeroMemory( (PVOID) &OsInfo, sizeof (OsInfo) );
		OsInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

		if (!GetVersionEx( &OsInfo ))
			// Function call failed, last error is set by GetVersionEx()
			return FALSE;

		if ( VER_PLATFORM_WIN32_NT == OsInfo.dwPlatformId )
		{
			// WinNT, DU driver is supported only from W2K and up
			if ( 4 >= OsInfo.dwMajorVersion )
			{
				// NT 3.51 or NT 4.0
				LOG_error("DU driver is not supported on NT 3.51 or NT 4.0");
				SetLastError(ERROR_OLD_WIN_VERSION);
				return TRUE; // no detection to do, succeed
			}
			else 
				// Win2K and beyond
				fIsPrinterInfo6Supported = TRUE;
		}
		else if ( VER_PLATFORM_WIN32_WINDOWS == OsInfo.dwPlatformId )
		{
			// Win9x, DU driver detection is supported only from Win98 and up
			// for Win9x, we should call DuQueryUnsupportedDrivers() instead
			// Since this function should also work for Win98 and up, we will
			// allow this call

			// ROGERJ, october 31th, 2000, remove driver support for win9x platform
			//if ( 0 == OsInfo.dwMinorVersion )
			//{
			//	// Win95
			//	LOG_error("DU driver is not supported on Win95");
			//	SetLastError(ERROR_OLD_WIN_VERSION);
			//	return FALSE;
			//}
			
			//if (90 <= OsInfo.dwMinorVersion)
			//	// WinME
			//	fIsPrinterInfo6Supported = TRUE;
			
			LOG_error("DU driver is not supported on Win9x");
			SetLastError(ERROR_OLD_WIN_VERSION);
			return TRUE; // no detection to do, succeed
		}
		else
		{
			// Win 3.x and below, not supported
			LOG_error("DU driver is not supported on Win 3.x");
			SetLastError(ERROR_OLD_WIN_VERSION);
			return FALSE;
		}
	}

	// Do the driver detection 

	BOOL fRetValue = TRUE;

	// clean up the hardware id list first 
	m_arrayHardwareId.RemoveAll();


	// Get all the device class installed in the machine
	HDEVINFO hDeviceInfoSet = INVALID_HANDLE_VALUE;
	int nIndex = 0;
	SP_DEVINFO_DATA DeviceInfoData;

	if ( INVALID_HANDLE_VALUE == 
		(hDeviceInfoSet = SetupDiGetClassDevs ( NULL, // class guid
		  								     NULL, // enumerator
											 NULL, // parent window handler
											 DIGCF_PRESENT|DIGCF_ALLCLASSES))) // all class, device presented
	{
		// function call failed, error will be set by Setup API
		LOG_error("SetupDiGetClassDevs failed --- %d", GetLastError());
		return FALSE;
	}
	
	// initialize SP_DEVINFO_DATA structure
	ZeroMemory((PVOID)&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
	DeviceInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

	while ( SetupDiEnumDeviceInfo( hDeviceInfoSet, // handle of device info set
								   nIndex++, // 0 based index
								   &DeviceInfoData)) // retrieved device info data
	{
		ULONG uHwidSize, uCompatidSize;
		uHwidSize = uCompatidSize = 0;
		unsigned char *pszBuffer = NULL;
		DWORD dwError = 0;

		// get the size needed for hard ware id
		if (!SetupDiGetDeviceRegistryProperty( hDeviceInfoSet, // handle of device info set
											   &DeviceInfoData, // device info data
											   SPDRP_HARDWAREID, // hardware id
											   NULL, // reg data type
											   NULL, // buffer
											   0, // buffer size
											   &uHwidSize)) // out buffer size
		{
			if (!uHwidSize)
			{
                // missing a HWID is not catastrophic, we just need to skip this device node
                continue;
			}
			dwError = GetLastError();
			if (ERROR_INSUFFICIENT_BUFFER != dwError)
			{
				LOG_error("SetupDiGetDeviceRegistryProperty 1st call --- %d, skipping device", dwError);
                continue;
			}
			
		}
			
		if (!SetupDiGetDeviceRegistryProperty( hDeviceInfoSet, // handle of device info set
											   &DeviceInfoData, // device info data
											   SPDRP_COMPATIBLEIDS , // compatible ids
											   NULL, // reg data type
											   NULL, // buffer
											   0, // buffer size
											   &uCompatidSize) && uCompatidSize) // out buffer size
		{
			dwError = GetLastError();
			if (ERROR_INSUFFICIENT_BUFFER != dwError)
			{
				LOG_error("SetupDiGetDeviceRegistryProperty 2nd call --- %d, skipping device", dwError);
                continue;
			}
		}

		// allocate memory for the multi-sz buffer
		pszBuffer = new unsigned char [uHwidSize + uCompatidSize + 2];
		if (!pszBuffer)
		{
			// out of memory
			LOG_error("Out of memory");
			fRetValue = FALSE;
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			goto ErrorReturn;
		}
		
		// initiliaze the buffer
		ZeroMemory(pszBuffer, sizeof(char)*(uHwidSize + uCompatidSize + 2));

		// get the hardware id and compatible id
		if (uHwidSize && !SetupDiGetDeviceRegistryProperty( hDeviceInfoSet, // handle of device info set
											   &DeviceInfoData, // device info data
											   SPDRP_HARDWAREID, // hardware id
											   NULL, // reg data type
											   pszBuffer, // buffer
											   uHwidSize, // buffer size
											   NULL)) // out buffer size
		{
			dwError = GetLastError();
			LOG_error("SetupDiGetDeviceRegistryProperty 3rd call --- %d, skipping device", dwError);
			if (pszBuffer) delete [] pszBuffer;
			pszBuffer = NULL;
            continue;
		}

		
		if (uCompatidSize)
		{
			if (!SetupDiGetDeviceRegistryProperty( hDeviceInfoSet, // handle of device info set
											   &DeviceInfoData, // device info data
											   SPDRP_COMPATIBLEIDS , // compatible ids
											   NULL, // reg data type
											   pszBuffer + uHwidSize -1 , // buffer
											   uCompatidSize, // buffer size
											   NULL)) // out buffer size
			{
				dwError = GetLastError();
				LOG_error("SetupDiGetDeviceRegistryProperty 4th call --- %d, skipping device", dwError);
				if (pszBuffer) delete [] pszBuffer;
				pszBuffer = NULL;
                continue;
			}
		}

		// output first hardware id to log file
		LOG_out("HardwareID detected --- \"%s\"", pszBuffer);
		
		// Test if the hardwareid we got is on the setup CD or not
		if (!IsHardwareIdHasDriversOnCD((char*)pszBuffer))
		{
			// not on CD
			// Add this multi-sz list to our hardware id list
			LOG_out("HardwareID added --- \"%s\"", pszBuffer);
			
			m_arrayHardwareId.Add((char*)pszBuffer);
		}
		else
			LOG_out("HardwareID ignored --- \"%s\"", pszBuffer);


		// re-initialize SP_DEVINFO_DATA structure
		ZeroMemory((PVOID)&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
		DeviceInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
		
		if (pszBuffer) delete [] pszBuffer;
		pszBuffer = NULL;
	} // end of while

	if (ERROR_NO_MORE_ITEMS != GetLastError())
	{
		// Failed other than reach the end of the list
		LOG_error("SetupDiEnumDeviceInfo failed --- %d", GetLastError());
		fRetValue = FALSE;
	}
	
ErrorReturn:
	if ( INVALID_HANDLE_VALUE != hDeviceInfoSet)
		SetupDiDestroyDeviceInfoList(hDeviceInfoSet);

    if (fIsPrinterInfo6Supported)
        DoPrinterDriverDetection();

    return fRetValue;
}




						   
// --------------------------------------------------------------------------------------------
// Function Name: IsHardwareIdHasDriversOnCD()
// Function Description: This function take a multi-sz list and determins if any of the hardware
//		id in the list is on setup CD.  
// Return Code: BOOL
//		TRUE --- if any one hardware id is on CD
//		FALSE --- if all hardware id is not on CD
//
BOOL CDynamicUpdate::IsHardwareIdHasDriversOnCD(LPCSTR pszHardwareIdList)
{
	LOG_block("FilterDriverListFromCD");

	// parameter validation
	if (NULL == pszHardwareIdList)
	{
		LOG_error("NULL parameter");
		// since the pszHardwareIdList is NULL, which means all the hardwareid (zero) contained in the 
		// string is on CD, we will return TRUE here
		return TRUE;
	}

	// call the callback function provided by setup to find out if there is a driver for this 
	// hardware id on CD
	PNPID_INFO PnPInfo;
	// initialize default state --- device supported, but driver not found
	PnPInfo.fHandled = FALSE;
	PnPInfo.fUnSupported = FALSE;

	DWORD dwSizePnPInfo = (DWORD) sizeof(PNPID_INFO);

	if (!(*m_pfnWinNT32Query) ( SETUPQUERYID_PNPID, // query flag
						   		(PVOID)pszHardwareIdList, // multi-SZ list of HardwareId
						   		0, // sizeof pszHardwarIdList, not used
						   		(PVOID)&PnPInfo, 
						   		&dwSizePnPInfo))
	{
		LOG_error("Callback Function Failed --- %d", GetLastError());
		return TRUE; // assume found
	}

	if (PnPInfo.fUnSupported)
		LOG_out("HardwareID unsupported --- \"%s\"", pszHardwareIdList);
	
	if (PnPInfo.fUnSupported || PnPInfo.fHandled)
		return TRUE; // device is not supported or driver is found in CD
	else
		return FALSE; // device is supported and driver is not on CD
}


// ------------------------------------------------------------------------------------------------
// Function Name: DoWindowsUpdateDriverDetection
// Function Description:  This function will take the member variable (multi-sz list) for hardware id
// 		not found in the CD and search for the driver on the site.  If found, the function will add 
//		the file needed to be downloaded into the download list
// Return Code: BOOL
// 		TRUE --- if successful
// 		FALSE --- if failed, call GetLastError() to get extensive error information
//
BOOL CDynamicUpdate::DoWindowsUpdateDriverDetection()
{
	LOG_block("CDynamicUpdate::DoWindowsUpdateDriverDetection");

	BOOL fRetVal = TRUE;

	if (!m_pV3->ReadGuidrvINF()) return FALSE;

	// no driver presents on the catalog
	if (!m_pV3->m_fHasDriver) 
	{
	    // need to ping back the drivers
	    m_arrayHardwareId.ResetIndex();
        CMultiSZString* pSZTemp = NULL;
        while ( NULL != (pSZTemp = m_arrayHardwareId.GetNextMultiSZString()))
        {
            if (pSZTemp->IsFound()) continue; // driver found for this device
            pSZTemp->ResetIndex();
            PingBack(DU_PINGBACK_DRIVERNOTFOUND, 0, pSZTemp->GetNextString(), FALSE);
        }
	    return TRUE;
	}
	
	int nNumOfDevNeedDriver = m_arrayHardwareId.GetCount();
	int nNumOfTotalPnPIds = m_arrayHardwareId.GetTotalStringCount();

	// no driver is needed
	if (!nNumOfDevNeedDriver || !nNumOfTotalPnPIds) return TRUE;

	// download the bitmap file to memory
	PCDM_HASHTABLE pBitMap = NULL;
	DWORD dwLength = 0;
	DWORD dwError = 0;
	UINT *pnHashList = NULL;
	int nIdCount = 0;
	int nCount = 0;
	CMultiSZString* pTemp = NULL;
	PDRIVER_DOWNLOAD_INFO* pPlaceHolder = NULL;
	int nPlaceHolderIndex = 0;
    int	nTempHolderIndex = 0;

	char szBmpRelativeName[MAX_PATH];
	ZeroMemory(szBmpRelativeName, MAX_PATH*sizeof(char));
	wsprintfA(szBmpRelativeName, "%d/inventory.cdm", m_pV3->m_puidConsumerCatalog);
	
	// get the bitmap file name on server
	char szServerBitMapFileName [INTERNET_MAX_URL_LENGTH];
	ZeroMemory(szServerBitMapFileName, INTERNET_MAX_URL_LENGTH*sizeof(char));

	DuUrlCombine(szServerBitMapFileName, m_pV3->m_szV31ContentUrl, szBmpRelativeName);

	// down load bitmap file to pBitMap 
	dwError = DownloadFileToMem( szServerBitMapFileName, // server file name 
								 		   (PBYTE*) &pBitMap, // buffer, OUT
								 		   & dwLength, // buffer length, OUT
								 		   TRUE, // try to decompress
								 		   "inventory.cdm",
								 		   NULL);
	if (ERROR_SUCCESS != dwError)
	{
		// download failed
		LOG_error("Download bitmask.cdm failed --- %d", dwError);
		fRetVal = FALSE;
		goto CleanUp;
	}
	
	// allocate memory for hash list
	pnHashList = new UINT [nNumOfTotalPnPIds];
	if (!pnHashList)
	{
		LOG_error("Out of memory");
		SetLastError(ERROR_OUTOFMEMORY);
		fRetVal = FALSE;
		goto CleanUp;
	}
	ZeroMemory(pnHashList, nNumOfTotalPnPIds*sizeof(UINT));

	// allocate memory for place holder list
	pPlaceHolder = (PDRIVER_DOWNLOAD_INFO*) GlobalAlloc(GMEM_ZEROINIT, nNumOfDevNeedDriver * sizeof (PDRIVER_DOWNLOAD_INFO));

	if (!pPlaceHolder)
	{
		LOG_error("Out of memory");
		SetLastError(ERROR_OUTOFMEMORY);
		fRetVal = FALSE;
		goto CleanUp;
	}



	m_arrayHardwareId.ResetIndex();
	
	// go through every device that has no driver on the CD
	for (nCount = 0; nCount<nNumOfDevNeedDriver; nCount++)
	{
		pTemp = m_arrayHardwareId.GetNextMultiSZString();
		// error!
		if (!pTemp) break;

		// get each string from the multi-sz string
		pTemp->ResetIndex();
		LPCTSTR pTempId = pTemp->GetNextString();

		while (*pTempId)
		{
			// Log
			LOG_out("Searching driver for HardwareID --- %s", pTempId);
			
			// get the hashed id list
			UINT uHashValue = CDM_HwID2Hash(pTempId, pBitMap->hdr.iTableSize);
			if (!uHashValue)
			{
				// uHashValue is 0, could be an error condition, need to call GetLastError() to determine
				dwError = GetLastError();
				if (ERROR_SUCCESS != dwError)
				{
					// Error happened
					LOG_error("Invalid Hash Value --- %d", dwError);
					// try next hardware id
					pTempId = pTemp->GetNextString();
					continue;
				}
			}

			// find out if a hash value exists in the bitmap
			if  (0 != ((pBitMap->pData)[(uHashValue/8)] & (0x80 >> (uHashValue%8))))
			{
				// Log
				LOG_out ("Bucket file %d", uHashValue);
				
				// match found, add to pnHashList
				// check see if the same hash already in the list, if not, add it to the list
				int k;
				for (k = 0; k<nIdCount; k++)
					if (uHashValue == pnHashList[k]) break;
				if (k >= nIdCount) 
					pnHashList[nIdCount++] = uHashValue;
			}
			
			pTempId = pTemp->GetNextString();
		}
	}


	// now we got all the bucket file number we need to download
	for (nCount = 0; nCount < nIdCount; nCount++)
	{

		// read bucket file
		char szBucketFileName[MAX_PATH];
		ZeroMemory(szBucketFileName, MAX_PATH*sizeof(char));

		char szServerBKFFullName [INTERNET_MAX_URL_LENGTH];
		ZeroMemory(szServerBKFFullName, INTERNET_MAX_URL_LENGTH*sizeof(char));

		// get bucket file name without the URL
		wsprintfA(szBucketFileName, "%d/%d.bkf", m_pV3->m_puidConsumerCatalog, pnHashList[nCount]);
		// get bucket file name with URL
		DuUrlCombine(szServerBKFFullName, m_pV3->m_szV31ContentUrl, szBucketFileName);

		// reset szBucketFileName to local bucket file name
		wsprintfA(szBucketFileName,"%d.bkf", pnHashList[nCount]);

		// download bucket file to memory
		LOG_out("Download bucket file %s", szBucketFileName);
		
		PBYTE pBKFFile = NULL;
		dwError = DownloadFileToMem(szServerBKFFullName, // server file name
									&pBKFFile, // buffer
									&dwLength, // buffer length
									TRUE, // try to decompress
									szBucketFileName,
									NULL);
		if (ERROR_SUCCESS != dwError)
		{
			LOG_error("Failed to download %s --- %d", szBucketFileName, dwError);
			if (pBKFFile) GlobalFree(pBKFFile);
			fRetVal = FALSE;
			goto CleanUp;
		}
		// download each bucket file and parse the bucket file to get the correct cabinet file
		UINT uBKFIndex = 0;
		while ( uBKFIndex < dwLength )
		{
			PCDM_RECORD_HEADER pCdmHeader = (PCDM_RECORD_HEADER) (pBKFFile + uBKFIndex);
			if (!m_pV3->IsPUIDExcluded(pCdmHeader->puid))
			{

    			LPCSTR pTempHardwareid = (LPCSTR) ((PBYTE)pCdmHeader + sizeof(CDM_RECORD_HEADER));
    			LPCSTR pRememberedHWID = pTempHardwareid;

    			// parse the bucket file to find a PnPId match
    			// only get the hardware id, we don't care about any other information for DU, thus, we
    			// don't need to parse them
    			PosIndex PI;
    			if (m_arrayHardwareId.PositionIndex (pTempHardwareid, &PI))
    			{
    				LOG_out("HardwareID '%s' found in bucket file '%s'", pTempHardwareid, szBucketFileName);

    				// prune by locale
    				if (!GETBIT(m_pV3->m_pBitMaskCDM, pCdmHeader->nBitmaskIdx))
    				{
    					// masked out
    					LOG_out("HardwareID %s is masked out.", pTempHardwareid);
    				}
    				else
    				{
    					// match found

    					// first get necessary infomation
    					// get DriverVer
        				for (int t=0; t<4; t++)
        				{
        					pTempHardwareid += (lstrlenA(pTempHardwareid) + 1);
        				}
        				// now pTempHardwareid points to szDriverVer
        				// DriverVer is of format mm/dd/yyyy, change it into a number
        				// we set every month to 31 day, every year to 31 *12 days are construct
        				// a number start for 01/01/1998
        				int nTempYear = (pTempHardwareid[6]-'0')*1000 +(pTempHardwareid[7]-'0')*100 +
        								(pTempHardwareid[8]-'0')*10 +(pTempHardwareid[9]-'0');
        				int nTempMonth = (pTempHardwareid[0]-'0')*10+pTempHardwareid[1]-'0';
        				int nTempDay = (pTempHardwareid[3]-'0')*10+pTempHardwareid[4]-'0';
        				// no driver in windows update database has a date earlier than 1999.
        				// set to 1998 as the earliest date.
        				// NOTE: this will still work for drivers before 1998
        				int nTempDriverVer = (nTempYear - 1998)*31*12 + (nTempMonth-1)*31 +(nTempDay-1);
                    	// get the cabinet file name
        				// now pTempHardwareid points to pszCabFileTitle
        				pTempHardwareid += (lstrlenA(pTempHardwareid) + 1);

                        char szAltName[MAX_PATH];
                        ZeroMemory(szAltName, MAX_PATH*sizeof(char));

                        // third see if the driver is excluded by guidrvs.inf
    					if (m_pV3->GetAltName(pTempHardwareid, szAltName, MAX_PATH)
    					    && !m_pV3->IsDriverExcluded(szAltName, pRememberedHWID))
    					{
       				        				
        					// third, determine if a better match is already in the place holder
        					BOOL fFound = FALSE;
        					for (nTempHolderIndex = 0; nTempHolderIndex < nPlaceHolderIndex; nTempHolderIndex++)
        					{
        						if ((pPlaceHolder[nTempHolderIndex]->Position.x == PI.x))
        						{
        							// Driver for same device is found
        							fFound = TRUE;
        							if (pPlaceHolder[nTempHolderIndex]->Position.y < PI.y)
        							{
        								// a better matched driver is already in the place holder list
        								// do nothing
        								LOG_out("A better matched is already found");
        							}
        							else if (pPlaceHolder[nTempHolderIndex]->Position.y > PI.y)
        							{
        								// a worse matched driver is already in the place holder list
        								// replace it
        								pPlaceHolder[nTempHolderIndex]->Position.x = PI.x;
        								pPlaceHolder[nTempHolderIndex]->Position.y = PI.y;
        								pPlaceHolder[nTempHolderIndex]->nDriverVer = nTempDriverVer;
		                                pPlaceHolder[nTempHolderIndex]->puid = pCdmHeader->puid;
        								lstrcpy(pPlaceHolder[nTempHolderIndex]->szCabFile, pTempHardwareid);
        								LOG_out("Replaced an old match");
        							}
        							else
        							{
        								LOG_out("Same match found, need to compare DriverVer");
        								// need to compare DriverVer for the same match
        								if (nTempDriverVer > pPlaceHolder[nTempHolderIndex]->nDriverVer)
        								{
        									// older driver in the list
        									// replace it
        									pPlaceHolder[nTempHolderIndex]->Position.x = PI.x;
        									pPlaceHolder[nTempHolderIndex]->Position.y = PI.y;
        									pPlaceHolder[nTempHolderIndex]->nDriverVer = nTempDriverVer;
			                                pPlaceHolder[nTempHolderIndex]->puid = pCdmHeader->puid;
        									lstrcpy(pPlaceHolder[nTempHolderIndex]->szCabFile, pTempHardwareid);
        									LOG_out("Replaced an old match");
        								}
        								else
        									LOG_out("A better matched is already found");
        							}
        							break;
        						}
        					}

        					if (!fFound)
        					{
        					    m_arrayHardwareId.CheckFound(PI.x); // mark as found
        						// not found, new entry
        						PDRIVER_DOWNLOAD_INFO pNewHolder = new DRIVER_DOWNLOAD_INFO;
        						if (!pNewHolder)
        						{
        							LOG_error("Out of memory");
        							SetLastError(ERROR_OUTOFMEMORY);
        							fRetVal = FALSE;
        							goto CleanUp;
        						}
        						pNewHolder->Position.x = PI.x;
        						pNewHolder->Position.y = PI.y;
        						pNewHolder->nDriverVer = nTempDriverVer;
		                        pNewHolder->puid = pCdmHeader->puid;
        						lstrcpy(pNewHolder->szCabFile, pTempHardwareid);

        						// add to list
        						pPlaceHolder[nPlaceHolderIndex++] = pNewHolder;
        						LOG_out("New match found, add to download list");
        					}
        				}
        			}
    			}
    	    }
			uBKFIndex += pCdmHeader->cnRecordLength; // move to next record 
		}
		
		// free bucket file memory
		SafeGlobalFree(pBKFFile);
		pBKFFile = NULL;


	}

	// now we have a list of driver in pPlaceHolder that are best for this machine
	// add all to download list

	
	for (nTempHolderIndex=0; nTempHolderIndex<nPlaceHolderIndex; nTempHolderIndex++)
	{
		// fill in the download item structure
		DOWNLOADITEM* pDownloadDriver = (DOWNLOADITEM*) GlobalAlloc(GMEM_ZEROINIT, sizeof(DOWNLOADITEM));
		if (!pDownloadDriver)
		{
			LOG_error("Out of memory");
			SetLastError(ERROR_OUTOFMEMORY);
			fRetVal = FALSE;
			goto CleanUp;
		}
		lstrcpyA(pDownloadDriver->mszFileList, pPlaceHolder[nTempHolderIndex]->szCabFile);
		pDownloadDriver->iNumberOfCabs = 1; // always 1 cab 1 driver
        pDownloadDriver->puid = pPlaceHolder[nTempHolderIndex]->puid;

		char pszDownloadUrl [INTERNET_MAX_URL_LENGTH];
		ZeroMemory(pszDownloadUrl, INTERNET_MAX_URL_LENGTH*sizeof(char));
		DuUrlCombine(pszDownloadUrl, m_pV3->m_szCabPoolUrl, pPlaceHolder[nTempHolderIndex]->szCabFile);
				
		dwError = OpenHttpConnection(pszDownloadUrl, FALSE);
		if (ERROR_SUCCESS != dwError)
		{
   			// Log error 
   			LOG_error("Failed to open internet connection --- %d", dwError);
   			pDownloadDriver->dwTotalFileSize = 102400; // default to 100k
    		continue;
		}
					
			// get file size from HTTP header
   		DWORD dwQueryLength = sizeof(DWORD);
   		if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
    				(LPVOID)&pDownloadDriver->dwTotalFileSize , &dwQueryLength, NULL) )
   		{
     		dwError = GetLastError();
   	   		LOG_error("HttpQueryInfo Failed on File %s, Error %d", pszDownloadUrl, dwError);
    		pDownloadDriver->dwTotalFileSize = 102400; // default to 100k
   		}

		SafeInternetCloseHandle(m_hOpenRequest);
				
		// Add the new item into download item list
		EnterDownloadListCriticalSection();
		AddDownloadItemToList(pDownloadDriver);
		LeaveDownloadListCriticalSection();
	}

	// we need to ping the pnpid back for all the devices what does not has a driver found 
	m_arrayHardwareId.ResetIndex();
	CMultiSZString* pSZTemp = NULL;
	while ( NULL != (pSZTemp = m_arrayHardwareId.GetNextMultiSZString()))
	{
	    if (pSZTemp->IsFound()) continue; // driver found for this device
	    pSZTemp->ResetIndex();
        PingBack(DU_PINGBACK_DRIVERNOTFOUND, 0, pSZTemp->GetNextString(), FALSE);
    }

	
CleanUp:
	PlaceHolderCleanUp(pPlaceHolder, nNumOfDevNeedDriver);
	SafeGlobalFree(pPlaceHolder);
	SafeGlobalFree(pBitMap);
	if (pnHashList) delete [] pnHashList;
	return fRetVal;
}

// Utility function starts here

//These functions form a hash lookup for hwIDs.
static ULONG HashFunction(
	IN ULONG seed	//Seed value to use for hashing hwid.
) {
	ULONG	q;
	ULONG	r;
	ULONG	a;
	ULONG	m;
	ULONG	val;

	q = 127773L;
	r = 2836L;
	a = 16807L;
	m = 2147483647;

	val = ((seed % q) * a) - (seed / q) * r;

	if(((long)val) <= 0)
		val = val + m;

	return val;
}


//These functions form a hash lookup for hwIDs.
ULONG CDM_HwID2Hash(
	IN LPCSTR szHwID,	//Hardware id being hashed.
	IN ULONG iTableSize	//Size of downloaded hash table.
) {
	SetLastError(0);
	if (0 == iTableSize)
	{
		SetLastError(ERROR_INVALID_DATA);
		return 0; // error
	}

	ULONG	ulHashIndex = 1;
	while(*szHwID)
	{
		if (*szHwID > 127 || *szHwID < 0)
		{
			// an extended ANSCII value, not valid
			SetLastError(ERROR_INVALID_DATA);
			return 0;
		}
		ulHashIndex = ulHashIndex + HashFunction(ulHashIndex + (ULONG)(INT_PTR)CharUpper((LPSTR)*szHwID));
		szHwID++;
	}

	return (ulHashIndex % iTableSize);
}


// ------------------------------------------------------------------------------------
// Function Name: DoPrinterDriverDetection
// Function Description: This function will detect all locally installed printer and add
//		the printer Hwid into out device list
// Return Value: BOOL
//		TRUE for succeed
//		FALSE for failure
BOOL CDynamicUpdate::DoPrinterDriverDetection()
{
	LOG_block("CDynamicUpdate::DoPrinterDriverDetection()");
	
	// Get Printers' Hwid
	// Note: This method only worked on Win2K / WinME.  If we are at other 9x, printer will not be supported
	// by this function
	DWORD nBytesNeeded;
	DWORD nDriverRetrieved;
	DWORD dwError;

	nBytesNeeded = nDriverRetrieved = dwError = 0;

	BYTE *pBuffer = NULL;
	BOOL fRetValue = FALSE;
	DRIVER_INFO_6 * pPrinterInfo = NULL;

	if (!EnumPrinterDriversA(NULL, // only enum local drivers
							NULL, // use default enviroment
							6, // use DRIVER_INFO_6
							NULL, // no out information
							0, // out buffer is zero
							&nBytesNeeded,
							&nDriverRetrieved ))
	{
		if (ERROR_INSUFFICIENT_BUFFER != (dwError = GetLastError()))
		{
			// Failed
			LOG_error("EnumPrinterDrivers 1st call failed --- %d",dwError);
			goto ErrorReturn;
		}
	}
	
	if (!nBytesNeeded)
		LOG_out("No local printers for this machine");
	else
	{
		pBuffer = new BYTE [nBytesNeeded];
		int nCount = 0;
		if (!pBuffer)
		{
			LOG_error("Insufficient memory when locating printer string");
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			goto ErrorReturn;
		}
		// get printer driver information;
		if (!EnumPrinterDriversA( NULL, // only enum local drivers
							NULL, // use default enviroment
							6, // use DRIVER_INFO_6
							pBuffer, // no out information
							nBytesNeeded, // out buffer is zero
							&nBytesNeeded,
							&nDriverRetrieved ))
		{
			if (ERROR_INSUFFICIENT_BUFFER != (dwError = GetLastError()))
			{
				// Failed
				LOG_error("EnumPrinterDrivers 1st call failed --- %d",dwError);
				goto ErrorReturn;
			}
		}
		// get individual hwid
		for (nCount=0; nCount<(int)nDriverRetrieved; nCount++)
		{
			pPrinterInfo = &((DRIVER_INFO_6*)pBuffer)[nCount];
			// record printer driver information
			// output printer hardware id to log file
			LOG_out("HardwareID detected --- \"%s\"", pPrinterInfo->pszHardwareID);

			// Test if the hardwareid we got is on the setup CD or not
			if (!IsHardwareIdHasDriversOnCD((char*)pPrinterInfo->pszHardwareID))
			{
				// not on CD
				// Add this multi-sz list to our hardware id list
				LOG_out("HardwareID added --- \"%s\"", pPrinterInfo->pszHardwareID);
				// for Windows Update, we need fake the printer id as
				// orignial_id&manufacteur&name&provider to distinguish between monolithic and unidriver
				int nSizeOfFakeId = lstrlenA(pPrinterInfo->pszHardwareID) + 
									lstrlenA(pPrinterInfo->pszMfgName) +
									lstrlenA(pPrinterInfo->pName) +
									lstrlenA(pPrinterInfo->pszProvider) + 3 + 2; // 3 for 3 & sign, 2 for double NULL termination
				char* szFakeId = new char [nSizeOfFakeId];
				if (!szFakeId)
				{
					LOG_error("Out of memory");
					SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					goto ErrorReturn;
				}
				ZeroMemory(szFakeId, nSizeOfFakeId * sizeof(char));
				lstrcpyA(szFakeId,pPrinterInfo->pszHardwareID);
				lstrcatA(szFakeId,"&");
				lstrcatA(szFakeId,pPrinterInfo->pszMfgName);
				lstrcatA(szFakeId,"&");
				lstrcatA(szFakeId,pPrinterInfo->pName);
				lstrcatA(szFakeId,"&");
				lstrcatA(szFakeId,pPrinterInfo->pszProvider);
				// Add to hardware id list
				m_arrayHardwareId.Add(szFakeId);

				delete [] szFakeId;
			}	
		}
			
	}
	
	fRetValue = TRUE;
ErrorReturn:
	if (pBuffer) delete [] pBuffer;
	return fRetValue;

}

void PlaceHolderCleanUp(PDRIVER_DOWNLOAD_INFO* pTemp, int nTotal)
{
    if (NULL == pTemp)
        return;

	for (int i=0; i<nTotal; i++)
	{
		if (pTemp[i]) 
		{
			PDRIVER_DOWNLOAD_INFO pDelete = pTemp[i];
			delete pDelete;
		}
		else
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdu\wsdu.h ===
#include <windows.h>
#include <shlwapi.h>
#include <wininet.h>
#include <stdio.h>
#include <lmcons.h>
#include <fdi.h>
#include <newtrust.h>
#include "log.h"

// helper macros
#define sizeOfArray(a)  (sizeof(a) / sizeof(a[0]))
#define SafeGlobalFree(x)       if (NULL != x) { GlobalFree(x); x = NULL; }
#define SafeFreeLibrary(x)      if (NULL != x) { FreeLibrary(x); x = NULL; }
#define SafeCloseHandle(x) if (INVALID_HANDLE_VALUE != x) { CloseHandle(x); x = INVALID_HANDLE_VALUE; }

// fdi.cpp
BOOL fdi(char *cabinet_fullpath, char *directory);

// Setup Database Query ID's
#define SETUPQUERYID_PNPID      1

// Dynamic Update Custom Error Codes
#define DU_ERROR_MISSING_DLL        12001L
#define DU_NOT_INITIALIZED          12002L
#define DU_ERROR_ASYNC_FAIL         12003L

#define WM_DYNAMIC_UPDATE_COMPLETE WM_APP + 1000 + 1000
// (WPARAM) Completion Status (SUCCESS, ABORTED, FAILED) : (LPARAM) (DWORD) Error Code if Status Failed
#define WM_DYNAMIC_UPDATE_PROGRESS WM_APP + 1000 + 1001
// (WPARAM) (DWORD) TotalDownloadSize : (LPARAM) (DWORD) BytesDownloaded 

#define DU_CONNECTION_RETRY 2
// RogerJ --- Dynamic.H also contains callback function declaration
// Dynamic.H Contains all the internal Function Pointer Declarations for the wsdueng.dll, wininet.dll and shlwapi.dll calls.
#include "dynamic.h"

typedef struct
{
    PFN_InternetOpen                fpnInternetOpen;
    PFN_InternetConnect             fpnInternetConnect;
    PFN_HttpOpenRequest             fpnHttpOpenRequest;
    PFN_HttpSendRequest             fpnHttpSendRequest;
    PFN_HttpQueryInfo               fpnHttpQueryInfo;
    PFN_InternetSetOption           fpnInternetSetOption;
    PFN_HttpAddRequestHeaders       fpnHttpAddRequestHeaders;
    PFN_InternetReadFile            fpnInternetReadFile;
    PFN_InternetCloseHandle         fpnInternetCloseHandle;
    PFN_InternetCrackUrl            fpnInternetCrackUrl;
    PFN_InternetGetConnectedState   fpnInternetGetConnectedState;
    PFN_PathAppend                  fpnPathAppend;
    PFN_PathRemoveFileSpec          fpnPathRemoveFileSpec;
    PFN_InternetAutodial			fpnInternetAutodial;
    PFN_InternetAutodialHangup		fpnInternetAutodialHangup;
    HINTERNET                       hInternet;
    HINTERNET                       hConnect;
    HINTERNET                       hOpenRequest;
    BOOL							fDialed; // mark as TRUE if we triggered an autodial
    BOOL							fUnattended; // TRUE if we are in unattened mode
} GLOBAL_STATEA, *PGLOBAL_STATEA;

// --------------------------------------------------------------------------
// Function Name: DuIsSupported
// Function Description: this method checks whether the required DLL's are on
//      the system to successfully run Dynamic Update. It does NOT attempt to
//      initiate a connection though.
//
// Function Returns:
//      FALSE: Not Supported, Some Required DLL's missing
//      TRUE:  DLL's are OK. Dynamic Update should be possible.
//
//
BOOL DuIsSupported();
BOOL NeedRetry(DWORD dwErrorCode); 

// --------------------------------------------------------------------------
// Function Name: DuInitialize
// Function Description: Initializes the Dynamic Setup Update engine. During
//      initialization this API attempts to establish a connection to the internet
//      and starts a self update process to ensure the latest bits are being used.
//      We also calculate the estimated transfer speed of the connection during this
//      time.
//
// Function Returns:
//      Failure: INVALID_HANDLE_VALUE .. Call GetLastError to retrieve the Error Code
//      Success: Handle of the Dynamic Setup Job
//
//
HANDLE WINAPI DuInitializeA(IN LPCSTR pszBasePath, // base directory used for relative paths for downloaded files
                            IN LPCSTR pszTempPath,
                            IN POSVERSIONINFOEXA posviTargetOS, // target OS platform
                            IN LPCSTR pszTargetArch, // string value identifying the architecture 'i386' and 'ia64'
                            IN LCID lcidTargetLocale, // target OS Locale ID
                            IN BOOL fUnattend, // is this an unattended operation
                            IN BOOL fUpgrade, // is this an upgrade
                            IN PWINNT32QUERY pfnWinnt32QueryCallback);

typedef HANDLE (WINAPI * PFN_DuInitializeA)(IN LPCSTR pszBasePath,
                                            IN LPCSTR pszTempPath,
                                            IN POSVERSIONINFOEXA posviTargetOS,
                                            IN LPCSTR pszTargetArch,
                                            IN LCID lcidTargetLocale,
                                            IN BOOL fUnattend, // is this an unattended operation
                                            IN BOOL fUpgrade,
                                            IN PWINNT32QUERY pfnWinnt32QueryCallback);

#define API_DU_INITIALIZEA "DuInitializeA"


HANDLE WINAPI DuInitializeW(IN LPCWSTR pwszBasePath, // base directory used for relative paths for downloaded files
                            IN LPCWSTR pwszTempPath, 
                            IN POSVERSIONINFOEXW posviTargetOS, // target OS platform
                            IN LPCWSTR pwszTargetArch, // string value identifying the architecture 'i386' and 'ia64'
                            IN LCID lcidTargetLocale, // target OS Locale ID
                            IN BOOL fUnattend, // is this an unattended operation
                            IN BOOL fUpgrade, // is this an upgrade
                            IN PWINNT32QUERY pfnWinnt32QueryCallback);

typedef HANDLE (WINAPI * PFN_DuInitializeW)(IN LPCWSTR pwszBasePath,
                                            IN LPCWSTR pwszTempPath, 
                                            IN POSVERSIONINFOEXW posviTargetOS,
                                            IN LPCWSTR pwszTargetArch,
                                            IN LCID lcidTargetLocale,
                                            IN BOOL fUnattend, // is this an unattended operation
                                            IN BOOL fUpgrade,
                                            IN PWINNT32QUERY pfnWinnt32QueryCallback);

#define API_DU_INITIALIZEW "DuInitializeW"

#ifdef UNICODE
#define DuInitialize DuInitializeW
#define PFN_DuInitialize PFN_DuInitializeW
#define API_DU_INITIALIZE API_DU_INITIALIZEW
#else
#define DuInitialize DuInitializeA
#define PFN_DuInitialize PFN_DuInitializeA
#define API_DU_INITIALIZE API_DU_INITIALIZEA
#endif


// --------------------------------------------------------------------------
// Function Name: DuDoDetection
// Function Description: Does detection of Drivers on the System, compiles an 
//      internal list of items to download and how long it will take to download
//      them.
//
// Function Returns:
//      Failure: FALSE .. Call GetLastError to retrieve the Error Code
//      Success: TRUE
//

BOOL WINAPI DuDoDetection(IN HANDLE hConnection,
                          OUT PDWORD pdwEstimatedTime,
                          OUT PDWORD pdwEstimatedSize);

typedef BOOL (WINAPI * PFN_DuDoDetection)(IN HANDLE hConnection,
                                          OUT PDWORD pdwEstimatedTime,
                                          OUT PDWORD pdwEstimatedSize);

#define API_DU_DODETECTION "DuDoDetection"

// --------------------------------------------------------------------------
// Function Name: DuBeginDownload
// Function Description: Begins Downloading based on the detection done in the DuDoDetection call.
//      Progress callbacks are made to the specified HWND. Function returns immediately, download
//      is asynchronous.
//
// Function Returns:
//      Failure: FALSE .. Call GetLastError to retrieve the Error Code
//      Success: TRUE
//

BOOL WINAPI DuBeginDownload(IN HANDLE hConnection,
                            IN HWND hwndNotify);

typedef BOOL (WINAPI * PFN_DuBeginDownload)(IN HANDLE hConnection,
                                        IN HWND hwndNotify);

#define API_DU_BEGINDOWNLOAD "DuBeginDownload"

// --------------------------------------------------------------------------
// Function Name: DuAbortDownload
// Function Description: Aborts current download.
//
//
// Function Returns:
//      nothing
//

void WINAPI DuAbortDownload(IN HANDLE hConnection);

typedef void (WINAPI * PFN_DuAbortDownload)(IN HANDLE hConnection);

#define API_DU_ABORTDOWNLOAD "DuAbortDownload"

// --------------------------------------------------------------------------
// Function Name: DuUninitialize
// Function Description: Performs internal CleanUp 
//
//
// Function Returns:
//      nothing
//

void WINAPI DuUninitialize(IN HANDLE hConnection);

typedef void (WINAPI * PFN_DuUninitialize)(IN HANDLE hConnection);

#define API_DU_UNINITIALIZE "DuUninitialize"

// RogerJ, Oct 2nd, 2000

// ---------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversA
// Function Description: Called by Win9x setup to get the size of total download
// 		instead of DuDoDetection()
// Function Returns: BOOL
//		TRUE if succeed
//		FALSE if failed, call GetLastError() to get error information
//
BOOL WINAPI DuQueryUnsupportedDriversA( IN HANDLE hConnection, // connection handle
										IN PCSTR* ppszListOfDriversNotOnCD, // list of drivers not on setup CD
										OUT PDWORD pdwTotalEstimateTime, // estimate download time
										OUT PDWORD pdwTotalEstimateSize // estimate size
									  );
									  
typedef BOOL (WINAPI * PFN_DuQueryUnsupportedDriversA)(IN HANDLE hConnection, 
													   IN PCSTR* ppszListOfDriversNotOnCD,
													   OUT PDWORD pdwTotalEstimateTime,
													   OUT PDWORD pdwTotalEstimateSize );
													   
#define API_DU_QUERYUNSUPPORTEDDRIVERSA 	"DuQueryUnsupportedDriversA"

// ---------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversW
// Function Description: Could be called by WinNT setup to get the size of total download
// 		instead of DuDoDetection().  WinNT setup should call DuDoDetection() instead of 
//		this function.  
// Function Returns: BOOL
//		TRUE if succeed
//		FALSE if failed, call GetLastError() to get error information
//
BOOL WINAPI DuQueryUnsupportedDriversW( IN HANDLE hConnection, // connection handle
										IN PCWSTR* ppwszListOfDriversNotOnCD, // list of drivers not on setup CD
										OUT PDWORD pdwTotalEstimateTime, // estimate download time
										OUT PDWORD pdwTotalEstimateSize // estimate size
									  );
									  
typedef BOOL (WINAPI * PFN_DuQueryUnsupportedDriversW)(IN HANDLE hConnection, 
													   IN PCWSTR* ppszListOfDriversNotOnCD,
													   OUT PDWORD pdwTotalEstimateTime,
													   OUT PDWORD pdwTotalEstimateSize );
													   
#define API_DU_QUERYUNSUPPORTEDDRIVERSW 	"DuQueryUnsupportedDriversW"

#ifdef UNICODE
#define DuQueryUnsupportedDrivers DuQueryUnsupportedDriversW
#define PFN_DuQueryUnsupportedDrivers PFN_DuQueryUnsupportedDriversW
#define API_DU_QUERYUNSUPPORTEDDERIVERS API_DU_QUERYUNSUPPORTEDDERIVERSW
#else
#define DuQueryUnsupportedDrivers DuQueryUnsupportedDriversA
#define PFN_DuQueryUnsupportedDrivers PFN_DuQueryUnsupportedDriversA
#define API_DU_QUERYUNSUPPORTEDDERIVERS API_DU_QUERYUNSUPPORTEDDERIVERSA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\download.cpp ===
#include "wsdueng.h"

DWORD WINAPI DownloadThreadProc(LPVOID lpv);

// private helper function forward declaration
// RogerJ --- Use this function to avoid auto disconnection
void IndicateDialmonActivity(void);


DWORD CDynamicUpdate::OpenHttpConnection(LPCSTR pszDownloadUrl, BOOL fGetRequest)
{
    LOG_block("CDynamicUpdate::OpenHttpConnection()");
    URL_COMPONENTSA UrlComponents;
    DWORD dwErr, dwStatus, dwLength;
    LPSTR AcceptTypes[] = {"*/*", NULL};

	LOG_out("Opening HTTP URL %s", pszDownloadUrl);

	dwErr = dwStatus = dwLength = 0;
    // Buffers used to Break the URL into its different components for Internet API calls
    char szServerName[INTERNET_MAX_URL_LENGTH + 1];
    char szObject[INTERNET_MAX_URL_LENGTH + 1];
    char szUserName[UNLEN+1];
    char szPasswd[UNLEN+1];

    // We need to break down the Passed in URL into its various components for the InternetAPI Calls. Specifically we
    // Need the server name, object to download, username and password information.
    ZeroMemory(szServerName, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(szObject, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize = sizeof(UrlComponents);
    UrlComponents.lpszHostName = szServerName;
    UrlComponents.dwHostNameLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUrlPath = szObject;
    UrlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUserName = szUserName;
    UrlComponents.dwUserNameLength = UNLEN + 1;
    UrlComponents.lpszPassword = szPasswd;
    UrlComponents.dwPasswordLength = UNLEN + 1;

    if (! InternetCrackUrlA(pszDownloadUrl, 0, 0, &UrlComponents) )
    {
        dwErr = GetLastError();
        LOG_error("InternetCrackUrl() Failed, Error: %d", dwErr);
        return dwErr;
    }

    // If the connection has already been established re-use it.
    if (NULL == m_hInternet)
    {
        if (! (m_hInternet = InternetOpenA("Dynamic Update", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)) )
        {
            dwErr = GetLastError();
            LOG_error("InternetOpen() Failed, Error: %d", dwErr);
            return dwErr;
        }
    }

    dwStatus = 30 * 1000; // 30 seconds in milliseconds
    dwLength = sizeof(dwStatus);
    InternetSetOptionA(m_hInternet, INTERNET_OPTION_SEND_TIMEOUT, &dwStatus, dwLength);

    if (NULL == m_hConnect || 0 != lstrcmpi(m_szCurrentConnectedServer, szServerName))
    {
        // No connection established yet, or we are connecting to a new server.
        SafeInternetCloseHandle(m_hConnect);
        if (! (m_hConnect = InternetConnectA(m_hInternet, szServerName, INTERNET_DEFAULT_HTTP_PORT, szUserName, szPasswd,
            INTERNET_SERVICE_HTTP, INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD, 0)) )
        {
            dwErr = GetLastError();
            LOG_error("InternetConnect() Failed, Error: %d", dwErr);
            return dwErr;
        }
        lstrcpy(m_szCurrentConnectedServer, szServerName);
    }

    SafeInternetCloseHandle(m_hOpenRequest); // make sure there is no open request before creating the new one.

    if (! (m_hOpenRequest = HttpOpenRequestA(m_hConnect, 
                                             (fGetRequest) ? NULL : "HEAD",
                                             szObject, 
                                             NULL, 
                                             NULL, 
                                             (LPCSTR *)AcceptTypes, 
                                             INTERNET_FLAG_NO_UI, 
                                             0)) )
    {
        dwErr = GetLastError();
        // log result
        return dwErr;
    }

    int nNumOfTrial = 0;
    do
    {
        if (! HttpSendRequestA(m_hOpenRequest, NULL, 0, NULL, 0) )
        {
            dwErr = GetLastError();
            // log result
            return dwErr;
        }

        dwLength = sizeof(dwStatus);
        if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, 
            (LPVOID)&dwStatus, &dwLength, NULL) )
        {
            dwErr = GetLastError();
            // log result
            return dwErr;
        }
        nNumOfTrial ++;
    } while (NeedRetry(dwStatus) && nNumOfTrial < DU_CONNECTION_RETRY);

    // If the Request did not succeed we'll assume we have no internet connection and return the Error Code
    // that Setup will trigger a warning to the user to manually establish a connection.
    if ((HTTP_STATUS_OK != dwStatus) && (HTTP_STATUS_PARTIAL_CONTENT != dwStatus))
    {
        LOG_error("Http Status NOT OK, Status %d", dwStatus);
        if (HTTP_STATUS_NOT_FOUND == dwStatus)
        	return ERROR_INTERNET_INVALID_URL;
        else return ERROR_CONNECTION_UNAVAIL;
    }

    return ERROR_SUCCESS;
}

DWORD CDynamicUpdate::DownloadFilesAsync()
{
    LOG_block("CDynamicUpdate::DownloadFileAsync()");
    DWORD dwThreadID;
    DWORD dwErr;

    SafeCloseHandle(m_hDownloadThreadProc);
    m_hDownloadThreadProc = CreateThread(NULL, 0, DownloadThreadProc, (void *)this, 0, &dwThreadID);
    if (NULL == m_hDownloadThreadProc)
    {
        dwErr = GetLastError();
        LOG_error("Unable to CreateThread for ASynch Download, Error %d", dwErr);
        return dwErr;
    }

    SetThreadPriority(m_hDownloadThreadProc, THREAD_PRIORITY_NORMAL);
    return ERROR_SUCCESS;
}

DWORD CDynamicUpdate::DownloadFile(LPCSTR pszDownloadUrl, LPCSTR pszLocalFile, BOOL fDecompress, BOOL fCheckTrust)
{
    LOG_block("CDynamicUpdate::DownloadFile()");
    DWORD dwErr, dwFileSize, dwLength;
    DWORD dwBytesRead, dwBytesWritten;
	DWORD dwCount1, dwCount2, dwTimeElapsed;
    SYSTEMTIME st;
    FILETIME ft;
    HANDLE hTargetFile;

	SetLastError(0);
	
    dwErr = OpenHttpConnection(pszDownloadUrl, FALSE);
    if (ERROR_SUCCESS != dwErr)
    {
        // log error 
        return dwErr;
    }

    dwLength = sizeof(st);
    if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
        (LPVOID)&st, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        LOG_error("HttpQueryInfo Failed on File %s, Error %d", pszDownloadUrl, dwErr);
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }

    SystemTimeToFileTime(&st, &ft);

    // Now Get the FileSize information from the Server
    dwLength = sizeof(dwFileSize);
    if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
        (LPVOID)&dwFileSize, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        LOG_error("HttpQueryInfo Failed on File %s, Error %d", pszDownloadUrl, dwErr);
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }

    if (IsServerFileNewer(ft, dwFileSize, pszLocalFile))
    {
		dwErr = OpenHttpConnection(pszDownloadUrl, TRUE); // need to download the file, send the GET request this time
		if (ERROR_SUCCESS != dwErr)
		{
			// log error 
			return dwErr;
		}
#define DOWNLOAD_BUFFER_LENGTH 32 * 1024

        PBYTE lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, DOWNLOAD_BUFFER_LENGTH);
        if (NULL == lpBuffer)
        {
            dwErr = GetLastError();
            LOG_error("Failed to Allocate Memory for Download Buffer, Error %d", dwErr);
            SafeInternetCloseHandle(m_hOpenRequest);
            return dwErr;
        }

        hTargetFile = CreateFileA(pszLocalFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hTargetFile)
        {
            dwErr = GetLastError();
            LOG_error("Failed to Open Target File %s, Error %d", pszLocalFile, dwErr);
            SafeGlobalFree(lpBuffer);
            SafeInternetCloseHandle(m_hOpenRequest);
            return dwErr;
        }

        // Download the File
        BOOL fRet;
        while (fRet = InternetReadFile(m_hOpenRequest, lpBuffer, DOWNLOAD_BUFFER_LENGTH, &dwBytesRead))
        {
			if (0 == dwBytesRead)
            {
                // Make one final call to InternetReadFile to commit the file to Cache (download is not complete otherwise)
                BYTE bTemp[32];
                InternetReadFile(m_hOpenRequest, &bTemp, 32, &dwBytesRead);
                // set the file time to match the server file time since we just downloaded it.
                // If we don't do this the file time will be set to the current system time.
                SetFileTime(hTargetFile, &ft, NULL, NULL); 
                break; // done reading.
            }
            if (!WriteFile(hTargetFile, lpBuffer, dwBytesRead, &dwBytesWritten, NULL))
            {
                LOG_error("Failed to Write to File %s, Error %d", pszLocalFile, dwErr);
                dwErr = GetLastError();
                SafeGlobalFree(lpBuffer);
                SafeInternetCloseHandle(m_hOpenRequest);
                SafeCloseHandle(hTargetFile);
                return dwErr;
            }
        }

        if (!fRet)
        {
            dwErr = GetLastError();
            SafeCloseHandle(hTargetFile);
            DeleteFile(pszLocalFile); // delete the file that we just had an error during downloading
            SafeGlobalFree(lpBuffer);
            LOG_error("InternetReadFile Failed, Error %d", dwErr);
            return dwErr;
        }
	
        SafeGlobalFree(lpBuffer);
        SafeCloseHandle(hTargetFile);

		// check for decompress requested
		if (fCheckTrust)
		{
			// Use VerifyFile() to verifty the cert of the downloaded component
			// change made by ROGERJ at Sept. 25th, 2000
			if (FAILED(VerifyFile(pszLocalFile, FALSE)))
			{
				LOG_error("CabFile %s does not have a valid Signature", pszLocalFile);
                DeleteFile(pszLocalFile); // not trusted, nuke it.
			}
		}

		if (fDecompress)
		{
			char szLocalDir[MAX_PATH];
			lstrcpy(szLocalDir, pszLocalFile);
			PathRemoveFileSpec(szLocalDir);
			fdi(const_cast<char *>(pszLocalFile), szLocalDir);
		}
    }

    // Always close the Request when the file is finished.
    // We intentionally leave the connection to the server Open though, seems more
    // efficient when requesting multiple files from the same server.
    SafeInternetCloseHandle(m_hOpenRequest);

    return ERROR_SUCCESS;
}

DWORD CDynamicUpdate::DownloadFileToMem(LPCSTR pszDownloadUrl, PBYTE *lpBuffer, DWORD *pdwAllocatedLength, BOOL fDecompress, LPSTR pszFileName, LPSTR pszDecompresedFileName)
{
	LOG_block("CDynamicUpdate::DownloadFileToMem()");
    DWORD dwErr, dwFileSize, dwLength;
    DWORD dwBytesRead, dwBytesWritten;
	DWORD dwCount1, dwCount2, dwTimeElapsed;
    SYSTEMTIME st;
    FILETIME ft;
    HANDLE hTargetFile;

    dwErr = OpenHttpConnection(pszDownloadUrl, TRUE);
    if (ERROR_SUCCESS != dwErr)
    {
        // log error 
        SetLastError(dwErr);
        return dwErr;
    }

    dwLength = sizeof(st);
    if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
        (LPVOID)&st, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        // log error
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }

    SystemTimeToFileTime(&st, &ft);

    // Now Get the FileSize information from the Server
    dwLength = sizeof(dwFileSize);
    if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
        (LPVOID)&dwFileSize, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        // log error
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }

    *lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, dwFileSize);
    if (NULL == *lpBuffer)
    {
        dwErr = GetLastError();
        // log error
        SafeInternetCloseHandle(m_hOpenRequest);
        return dwErr;
    }
    *pdwAllocatedLength = dwFileSize;

    // Read the whole file
	if (!InternetReadFile(m_hOpenRequest, *lpBuffer, dwFileSize, &dwBytesRead))
	{
		dwErr = GetLastError();
		LOG_error("Internet Read File Failed, Error %d", dwErr);
		SafeInternetCloseHandle(m_hOpenRequest);
		return dwErr;
	}

	if (fDecompress)
	{
		char szLocalFile[MAX_PATH];
		char szLocalFileTmp[MAX_PATH];
		if (NULL != pszDecompresedFileName)
		{
			char szCatalogName[MAX_PATH];
			PathCombine(szLocalFile, m_szTempPath, pszDecompresedFileName);
			wsprintf(szCatalogName, "%s.tmp", pszFileName);
			PathCombine(szLocalFileTmp, m_szTempPath, szCatalogName);
		}
		else
		{
			PathCombine(szLocalFile, m_szTempPath, pszFileName);
			wsprintf(szLocalFileTmp, "%s.tmp", szLocalFile);
		}
		
		HANDLE hFile = CreateFile(szLocalFileTmp, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (INVALID_HANDLE_VALUE == hFile)
		{
			LOG_error("Unable to write temp file for decompress");
			return GetLastError();
		}
		DWORD dwTmp;
		WriteFile(hFile, *lpBuffer, dwFileSize, &dwTmp, NULL);
		FlushFileBuffers(hFile);
		SafeCloseHandle(hFile);
		if (fdi(szLocalFileTmp, m_szTempPath))
		{
			// file was decompressed
			hFile = CreateFile(szLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if (INVALID_HANDLE_VALUE == hFile)
			{
				LOG_error("Unable to Read decompressed file %s", szLocalFile);
                SafeInternetCloseHandle(m_hOpenRequest);
        		DeleteFile(szLocalFileTmp);
				return GetLastError();
			}
			dwFileSize = GetFileSize(hFile, NULL);
			SafeGlobalFree(*lpBuffer);
			*lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, dwFileSize);
			*pdwAllocatedLength = dwFileSize;
			if (!ReadFile(hFile, *lpBuffer, dwFileSize, &dwTmp, NULL))
            {
                dwErr = GetLastError();
                LOG_error("ReadFile %s Failed, Error %d", szLocalFile, dwErr);
			    SafeInternetCloseHandle(m_hOpenRequest);
			    SafeCloseHandle(hFile);
                DeleteFile(szLocalFile);
        		DeleteFile(szLocalFileTmp);
                return dwErr;
            }

			SafeCloseHandle(hFile);
			DeleteFile(szLocalFile);
		}
		DeleteFile(szLocalFileTmp);
	}

    // Make one final call to InternetReadFile to commit the file to Cache (downloaded is not complete otherwise)
    BYTE bTemp[32];
    InternetReadFile(m_hOpenRequest, &bTemp, 32, &dwBytesRead);

    // Always close the Request when the file is finished.
    // We intentionally leave the connection to the server Open though, seems more
    // efficient when requesting multiple files from the same server.
    SafeInternetCloseHandle(m_hOpenRequest);
    return ERROR_SUCCESS;
}

BOOL CDynamicUpdate::IsServerFileNewer(FILETIME ftServerTime, DWORD dwServerFileSize, LPCSTR pszLocalFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
	FILETIME ftCreateTime;
	LONG lTime;
	DWORD dwLocalFileSize;

    hFile = CreateFile(pszLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		dwLocalFileSize = GetFileSize(hFile, NULL);
		if (dwLocalFileSize != dwServerFileSize)
		{
			SafeCloseHandle(hFile);
			return TRUE; // server and local files do not match, download server file.
		}
		
		if (GetFileTime(hFile, &ftCreateTime, NULL, NULL))
		{
			lTime = CompareFileTime(&ftCreateTime, &ftServerTime);
			if (lTime < 0)
			{
				SafeCloseHandle(hFile);
				return TRUE; // local file is 'older' than the server file
			}
			else
			{
				SafeCloseHandle(hFile);
				return FALSE; // local file is either equal or newer, leave it.
			}
		}
	}
	// if we couldn't find the file, or we couldn't get the time, assume the server file is newer
	SafeCloseHandle(hFile);
    return TRUE;
}

DWORD CDynamicUpdate::AsyncDownloadProc()
{
    LOG_block("CDynamicUpdate::AsyncDownloadProc()");
    char szServerFile[INTERNET_MAX_URL_LENGTH];
    char szLocalFile[MAX_PATH];
    DWORD dwErr = 0, dwFileSize = 0, dwLength = 0;
    DWORD dwBytesRead = 0, dwBytesWritten = 0;
    SYSTEMTIME st;
    FILETIME ft;
    HANDLE hTargetFile = INVALID_HANDLE_VALUE;
    BOOL fAbort = FALSE;
    BOOL fRet = TRUE;
  
    // The Download Thread Proc handles downloading all the files from the DownloadItemList in the DynamicUpdate object.
    // It will enumerate the list of items to download, make callbacks to the HWND in the dynamic update object in 1% intervals
    // and a final callback when it is complete. It will also check for cancel requests after downloading each 1k block from the
    // server. We do this in this small of a block to retain some responsiveness to the UI requests.

    EnterCriticalSection(&m_csDownload);

	DOWNLOADITEM *pCurrent = m_pDownloadItemList;
	while (pCurrent)
	{
	    // Update the Cab Size for the Current Item and Recalc the total download size
		// We do this because the Estimated Download Size can be 'less' than the real download size. 
		// When providing progress this causes the progress bar to go beyond 100%, which is wrong.
		LPSTR pszCabFile = pCurrent->mszFileList;
		DWORD dwCurrentItemSize = 0;
		for (int i = 0; i < pCurrent->iNumberOfCabs; i++)
		{
			DuUrlCombine(szServerFile, m_pV3->m_szCabPoolUrl, pszCabFile);
			dwErr = OpenHttpConnection(szServerFile, FALSE);
			if (ERROR_SUCCESS != dwErr)
            {
				LeaveCriticalSection(&m_csDownload);
                LOG_error("Failed to Open Connection for %s, Error Was %d", szServerFile, dwErr);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
	            return dwErr;
            }
            // Now Get the FileSize information from the Server
            dwLength = sizeof(dwFileSize);
            if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
                (LPVOID)&dwFileSize, &dwLength, NULL) )
            {
                dwErr = GetLastError();
                LOG_error("HttpQueryInfo Failed on File %s, Error %d, Skipping Item", szServerFile, dwErr);
                SafeInternetCloseHandle(m_hOpenRequest);
				LeaveCriticalSection(&m_csDownload);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                return dwErr;
            }
			SafeInternetCloseHandle(m_hOpenRequest);
			dwCurrentItemSize += dwFileSize;
			pszCabFile += lstrlen(pszCabFile) + 2; // advance to the next cab.
		}
		pCurrent->dwTotalFileSize = dwCurrentItemSize; // download size in Bytes.
		pCurrent = pCurrent->pNext;
	}

	m_dwCurrentBytesDownloaded = 0;
	UpdateDownloadItemSize();
	// We want to Send a Progress Message Every 1 Percent of the Download.
	DWORD dwBytesPerPercent = m_dwTotalDownloadSize / 100; // in case the 
    if (0 == dwBytesPerPercent)
    {
        dwBytesPerPercent = 1; // must be at least 1 byte, cannot be zero
    }
    DWORD dwCurrentPercentComplete = 0;

    // Now we will start looping through the Items and Download the Files.
    pCurrent = m_pDownloadItemList;
    while (pCurrent)
    {
        EnterCriticalSection(&m_cs);
        fAbort = m_fAbortDownload;
        LeaveCriticalSection(&m_cs);
        if (fAbort)
        {
            // check for abort for each item
			LeaveCriticalSection(&m_csDownload);
            SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM) DU_STATUS_ABORT, (LPARAM) NULL);
            SafeInternetCloseHandle(m_hConnect);
            SafeInternetCloseHandle(m_hInternet);
			m_fAbortDownload = FALSE; // reset
            return ERROR_SUCCESS;
        }
        // RogerJ --- call IndicateDialmonActivity() to avoid auto disconnection
        else
        	IndicateDialmonActivity();


        // Each 'Item' can have more than one Cab. The Setup Item itself will usually have 3 cabs, Drivers will probably only have 1 cab.
        LPSTR pszCabFile = pCurrent->mszFileList;
        for (int i = 0; i < pCurrent->iNumberOfCabs; i++)
        {
            pCurrent->iCurrentCab = i;
            DuUrlCombine(szServerFile, m_pV3->m_szCabPoolUrl, pszCabFile); // current cab is the null terminated cab name in the list

            WUCRC_HASH crc;
            char szShortName[MAX_PATH]; // for trimmed filename
            if (FAILED(SplitCRCName((LPCSTR)pszCabFile, &crc, szShortName)))
            {
                lstrcpy(szShortName, pszCabFile); // probably not a CRC'd file
            }

            PathCombine(szLocalFile, m_szDownloadPath, szShortName);

            // Now open the HttpConnection to get this file
			dwErr = OpenHttpConnection(szServerFile, FALSE);
			if (ERROR_SUCCESS != dwErr)
            {
				LeaveCriticalSection(&m_csDownload);
                LOG_error("Failed to Open Connection for %s, Error Was %d", szServerFile, dwErr);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
	            return dwErr;
            }

            dwLength = sizeof(st);
            if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
                (LPVOID)&st, &dwLength, NULL) )
            {
				LeaveCriticalSection(&m_csDownload);
                dwErr = GetLastError();
                LOG_error("HttpQueryInfo Failed on File %s, Error %d, Skipping Item", szServerFile, dwErr);
                SafeInternetCloseHandle(m_hOpenRequest);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
	            return dwErr;
            }

            SystemTimeToFileTime(&st, &ft);

            // Now Get the FileSize information from the Server
            dwLength = sizeof(dwFileSize);
            if (! HttpQueryInfoA(m_hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
                (LPVOID)&dwFileSize, &dwLength, NULL) )
            {
                dwErr = GetLastError();
                LOG_error("HttpQueryInfo Failed on File %s, Error %d, Skipping Item", szServerFile, dwErr);
                SafeInternetCloseHandle(m_hOpenRequest);
				LeaveCriticalSection(&m_csDownload);
                // Tell Setup that we're Stopping the Download
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                // Send Ping Back Status - Failed Item
                PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                return dwErr;
            }

            if (IsServerFileNewer(ft, dwFileSize, szLocalFile))
            {
				dwErr = OpenHttpConnection(szServerFile, TRUE);
				if (ERROR_SUCCESS != dwErr)
				{
					LeaveCriticalSection(&m_csDownload);
					LOG_error("Failed to Open Connection for %s, Error Was %d", szServerFile, dwErr);
					// Tell Setup that we're Stopping the Download
					SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
					return dwErr;
				}

#define ASYNC_DOWNLOAD_BUFFER_LENGTH 1 * 1024 // download in 1k blocks to maintain UI responsiveness to a cancel request.

                PBYTE lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, ASYNC_DOWNLOAD_BUFFER_LENGTH);
                if (NULL == lpBuffer)
                {
                    dwErr = GetLastError();
                    LOG_error("Failed to Allocate Memory for Download Buffer, Error %d", dwErr);
                    SafeInternetCloseHandle(m_hOpenRequest);
					LeaveCriticalSection(&m_csDownload);
                    // Tell Setup that we're Stopping the Download
                    SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                    return dwErr;
                }

                hTargetFile = CreateFileA(szLocalFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (INVALID_HANDLE_VALUE == hTargetFile)
                {
                    dwErr = GetLastError();
                    LOG_error("Failed to Open Target File %s, Error %d", szLocalFile, dwErr);
                    SafeGlobalFree(lpBuffer);
                    SafeInternetCloseHandle(m_hOpenRequest);
					LeaveCriticalSection(&m_csDownload);
					// Tell Setup that we're Stopping the Download
					SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
					return dwErr;
                }


                // Download the File
                while (fRet = InternetReadFile(m_hOpenRequest, lpBuffer, ASYNC_DOWNLOAD_BUFFER_LENGTH, &dwBytesRead))
                {
					if (0 == dwBytesRead) // done reading
                    {
                        // Make one final call to InternetReadFile to commit the file to Cache (download is not complete otherwise)
                        BYTE bTemp[32];
                        InternetReadFile(m_hOpenRequest, &bTemp, 32, &dwBytesRead);
                        break; // done reading.
                    }

                    EnterCriticalSection(&m_cs);
                    fAbort = m_fAbortDownload;
                    LeaveCriticalSection(&m_cs);
                    if (fAbort)
                    {
                        // Download Abort Requested, Clean Up, Signal the Complete Message and exit the Thread Proc
                        SafeCloseHandle(hTargetFile);
                        DeleteFile(szLocalFile); // file not complete
                        SafeInternetCloseHandle(m_hOpenRequest);
                        SafeInternetCloseHandle(m_hConnect);
                        SafeInternetCloseHandle(m_hInternet);
                        SafeGlobalFree(lpBuffer);
						LeaveCriticalSection(&m_csDownload);
						m_fAbortDownload = FALSE; // reset
                        SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_ABORT , (LPARAM) NULL);
                        return ERROR_SUCCESS; // cancel is not an error

                    }
                    // RogerJ --- call IndicateDialmonActivity() to avoid auto disconnection
                    else
                    	IndicateDialmonActivity();

                    if (!WriteFile(hTargetFile, lpBuffer, dwBytesRead, &dwBytesWritten, NULL))
                    {
                        dwErr = GetLastError();
                        LOG_error("Failed to Write to File %s, Error %d", szLocalFile, dwErr);
                        SafeGlobalFree(lpBuffer);
                        SafeInternetCloseHandle(m_hOpenRequest);
                        SafeCloseHandle(hTargetFile);
						DeleteFile(szLocalFile); // incomplete download
						LeaveCriticalSection(&m_csDownload);
						// Tell Setup that we're Stopping the Download
						SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
						return dwErr;
                    }
                    
                    m_dwCurrentBytesDownloaded += dwBytesRead;
                    dwCurrentPercentComplete = m_dwCurrentBytesDownloaded / dwBytesPerPercent;
                    if (dwCurrentPercentComplete != m_dwLastPercentComplete)
                    {
                        // We've downloaded another percent of the total size.. Send a Progress Message
                        SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_PROGRESS, (WPARAM)m_dwTotalDownloadSize, (LPARAM)m_dwCurrentBytesDownloaded);
						m_dwLastPercentComplete = dwCurrentPercentComplete;
                    }
                }

                // indicates error during InternetReadFile process
                if (!fRet)
                {
                    dwErr = GetLastError();
                    LOG_error("InternetReadFile Failed, Error %d", dwErr);
                    SafeGlobalFree(lpBuffer);
                    SafeInternetCloseHandle(m_hOpenRequest);
                    SafeCloseHandle(hTargetFile);
					DeleteFile(szLocalFile); // incomplete download
               		LeaveCriticalSection(&m_csDownload);
					// Tell Setup that we're Stopping the Download
					SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM)DU_STATUS_FAILED, (LPARAM) dwErr);
                    // Send Ping Back Status - Failed Item
                    PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);
                    return dwErr;
                }

                // set the file time to match the server file time since we just downloaded it.
                // If we don't do this the file time will be set to the current system time.
                SetFileTime(hTargetFile, &ft, NULL, NULL); 
                SafeGlobalFree(lpBuffer);
                SafeCloseHandle(hTargetFile);

                // RogerJ --- Add certificate checking code here
                if (FAILED(VerifyFile(szLocalFile, FALSE)))
    			{
                    // Send Ping Back Status - Failed Item
                    PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, FALSE);

                    LOG_error("CabFile %s does not have a valid Signature, deleted", szLocalFile);
    				if (!DeleteFile(szLocalFile))
    				{
    				    LOG_error("Failed to delete file %s --- %d", szLocalFile, GetLastError());
    				}
    			}
                else
                {
                    // File Successfully Downloaded and CheckTrusted
                    PingBack(DU_PINGBACK_DOWNLOADSTATUS, pCurrent->puid, NULL, TRUE);
                }
            }
            else
            {
                // File Currently on the System is Already Up to Date
                // Send Progress Message with with this file size indicating it was downloaded. This keeps the progress bar
                // accurate, even if we didn't actually have to download the bits.
                m_dwCurrentBytesDownloaded += dwFileSize;
                SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_PROGRESS, (WPARAM) m_dwTotalDownloadSize, (LPARAM) m_dwCurrentBytesDownloaded);
            }

            // Always close the Request when the file is finished.
            // We intentionally leave the connection to the server Open though, seems more
            // efficient when requesting multiple files from the same server.
            SafeInternetCloseHandle(m_hOpenRequest);
			pszCabFile += lstrlen(pszCabFile) + 2; // advance to the next cab.
        } // for ()
		pCurrent = pCurrent->pNext;
    } // while ()

	LeaveCriticalSection(&m_csDownload);
	ClearDownloadItemList();
    SendMessage(m_hwndClientNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM) DU_STATUS_SUCCESS, (LPARAM) NULL);
    SafeInternetCloseHandle(m_hConnect);
    SafeInternetCloseHandle(m_hInternet);
    return ERROR_SUCCESS;
}

DWORD WINAPI DownloadThreadProc(LPVOID lpv)
{
    LOG_block("DownloadThreadProc()");

    if (NULL == lpv)
    {
        return ERROR_INVALID_PARAMETER;
    }

    CDynamicUpdate *pDu = (CDynamicUpdate *)lpv;
    return pDu->AsyncDownloadProc();
}

// RogerJ
// -------------------------------------------------------------------------------------------
// Function Name: IndicateDialmonActivity
// Function Description:  Call this function to avoid auto disconnect
// Function Parameter: None
// Return Value: None
void IndicateDialmonActivity(void)
{
    static HWND hwndDialmon = NULL;
    HWND hwndMonitor;

    // dialmon lives forever - find it once and we're set
    if(NULL == hwndDialmon)
        hwndDialmon = FindWindow(c_szDialmonClass, NULL);
    if(hwndDialmon)
        PostMessage(hwndDialmon, WM_WINSOCK_ACTIVITY, 0, 0);
}

DWORD CDynamicUpdate::PingBack(int iPingBackType, PUID puid, LPCSTR pszPnPID, BOOL fSucceeded)
{
    LOG_block("CDynamicUpdate::PingBack()");
    URL_COMPONENTSA UrlComponents;
    DWORD dwErr, dwStatus, dwLength;
    LPSTR AcceptTypes[] = {"*/*", NULL};

    // Buffers used to Break the URL into its different components for Internet API calls
    char szServerName[INTERNET_MAX_URL_LENGTH + 1];
    char szServerRelPath[INTERNET_MAX_URL_LENGTH + 1];
    char szObject[INTERNET_MAX_URL_LENGTH + 1];
    char szUserName[UNLEN+1];
    char szPasswd[UNLEN+1];

    // We need to break down the Passed in URL into its various components for the InternetAPI Calls. Specifically we
    // Need the server name, object to download, username and password information.
    ZeroMemory(szServerName, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(szObject, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    ZeroMemory(szServerRelPath, INTERNET_MAX_URL_LENGTH + 1);
    
    UrlComponents.dwStructSize = sizeof(UrlComponents);
    UrlComponents.lpszHostName = szServerName;
    UrlComponents.dwHostNameLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUrlPath = szServerRelPath;
    UrlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
    UrlComponents.lpszUserName = szUserName;
    UrlComponents.dwUserNameLength = UNLEN + 1;
    UrlComponents.lpszPassword = szPasswd;
    UrlComponents.dwPasswordLength = UNLEN + 1;

    if (! InternetCrackUrlA(m_pV3->m_szV31RootUrl, 0, 0, &UrlComponents) )
    {
        dwErr = GetLastError();
        LOG_error("InternetCrackUrl() Failed, Error: %d", dwErr);
        return dwErr;
    }

    // If the connection has already been established re-use it.
    if (NULL == m_hInternet)
    {
        if (! (m_hInternet = InternetOpenA("Dynamic Update", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)) )
        {
            dwErr = GetLastError();
            LOG_error("InternetOpen() Failed, Error: %d", dwErr);
            return dwErr;
        }
    }

    dwStatus = 30 * 1000; // 30 seconds in milliseconds
    dwLength = sizeof(dwStatus);
    InternetSetOptionA(m_hInternet, INTERNET_OPTION_SEND_TIMEOUT, &dwStatus, dwLength);

    if (NULL == m_hConnect || 0 != lstrcmpi(m_szCurrentConnectedServer, szServerName))
    {
        // No connection established yet, or we are connecting to a new server.
        SafeInternetCloseHandle(m_hConnect);
        if (! (m_hConnect = InternetConnectA(m_hInternet, szServerName, INTERNET_DEFAULT_HTTP_PORT, szUserName, szPasswd,
            INTERNET_SERVICE_HTTP, INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD, 0)) )
        {
            dwErr = GetLastError();
            LOG_error("InternetConnect() Failed, Error: %d", dwErr);
            return dwErr;
        }
        lstrcpy(m_szCurrentConnectedServer, szServerName);
    }

    SafeInternetCloseHandle(m_hOpenRequest); // make sure there is no open request before creating the new one.

    switch(iPingBackType)
    {
    case DU_PINGBACK_DOWNLOADSTATUS:
        {
            wsprintfA(szObject, "%s/wutrack.bin?PUID=%d&PLAT=%d&LOCALE=0x%08x&STATUS=%s&GUID=&PNPID=",
                szServerRelPath, puid, m_iPlatformID, (long)m_lcidLocaleID, fSucceeded ? "DU_DOWNLOAD_SUCCESS" : "DU_DOWNLOAD_FAILURE");
            break;
        }
    case DU_PINGBACK_DRIVERNOTFOUND:
        {
            // driver not found pingback
            wsprintfA(szObject, "%s/wutrack.bin?PUID=0&PLAT=%d&LOCALE=0x%08x&STATUS=DUNODRIVER&GUID=0&PNPID=%s",
                    szServerRelPath, m_iPlatformID, (long)m_lcidLocaleID, pszPnPID);
            break;
        }
    case DU_PINGBACK_SETUPDETECTIONFAILED:
        {
            // this is a detection failed pingback (no specific item info)
            wsprintfA(szObject, "%s/wutrack.bin?PUID=0&PLAT=%d&LOCALE=0x%08x&STATUS=DUSETUPDETECTIONFAILED&GUID=&PNPID=",
                szServerRelPath, m_iPlatformID, (long)m_lcidLocaleID);
            break;
        }
    case DU_PINGBACK_DRIVERDETECTIONFAILED:
        {
            // this is a detection failed pingback (no specific item info)
            wsprintfA(szObject, "%s/wutrack.bin?PUID=0&PLAT=%d&LOCALE=0x%08x&STATUS=DUDRIVERDETECTIONFAILED&GUID=&PNPID=",
                szServerRelPath, m_iPlatformID, (long)m_lcidLocaleID);
            break;
        }
    }

    LOG_out("contact server %s", szObject);
    if (! (m_hOpenRequest = HttpOpenRequestA(m_hConnect, NULL, szObject, NULL, NULL, (LPCSTR *)AcceptTypes, 
        INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD, 0)) )
    {
        dwErr = GetLastError();
        // log result
        return dwErr;
    }

    if (! HttpSendRequestA(m_hOpenRequest, NULL, 0, NULL, 0) )
    {
        dwErr = GetLastError();
        // log result
        return dwErr;
    }
    
    SafeInternetCloseHandle(m_hOpenRequest);
    return ERROR_SUCCESS;

}

BOOL CDynamicUpdate::NeedRetry(DWORD dwErrCode)
{
    BOOL bRetry = FALSE;
    bRetry =   ((dwErrCode == ERROR_INTERNET_CONNECTION_RESET)      //most common
             || (dwErrCode == HTTP_STATUS_NOT_FOUND)                //404
			 || (dwErrCode == ERROR_HTTP_HEADER_NOT_FOUND)			//seen sometimes
             || (dwErrCode == ERROR_INTERNET_OPERATION_CANCELLED)   //dont know if..
             || (dwErrCode == ERROR_INTERNET_ITEM_NOT_FOUND)        //..these occur..
             || (dwErrCode == ERROR_INTERNET_OUT_OF_HANDLES)        //..but seem most..
             || (dwErrCode == ERROR_INTERNET_TIMEOUT));             //..likely bet
    return bRetry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\log.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   log.h
//
//  Owner:  Yan Leshinsly
//
//  Description:
//
//      Logging support
//
//=======================================================================
#pragma once

#ifndef LOGGING_LEVEL
    #define LOGGING_LEVEL 0
#endif

const char cszLoggingFile[] = "%WinDir%\\wsdu.log";

class CLogger
{
public:
    CLogger(const char* szBlockName = 0, int nLoggingLevel = 0, const char* szFileName = 0, int nLine = 0);
    ~CLogger();
    void __cdecl out(const char *szFormat, ...);
    void __cdecl error(const char *szFormat, ...);
    static void __cdecl out1(const char *szFormat, ...);
    static void __cdecl close(void);

private:
    void v_out( const char* szFormat, va_list va);

    bool m_fOut;
    char m_szBlockName[64];
    DWORD m_dwStartTick;
    
    static FILE* c_pfile;
    static int c_cnIndent;
    static int c_cnLevels;
};

#define THIS_FILE               __FILE__
#define LOG_block(name)         CLogger logger(name, LOGGING_LEVEL, THIS_FILE, __LINE__)
#define LOG_out                 logger.out
#define LOG_out1                CLogger::out1
#define LOG_error               logger.error
#define LOG_close				CLogger::close

#define report_error_if_false(f)    if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); } 
#define return_error_if_false(f)    if (f) {/*OK*/} else { DWORD dwErr = GetLastError(); LOG_error("%s LastError = %d", #f, dwErr); return dwErr;}
#define return_if_error(f)          { DWORD dwErr = f; if (dwErr) { LOG_error("%s LastError = %d", #f, dwErr); return dwErr;} }
#define return_if_false(f)      if (f) {/*OK*/} else { LOG_error("%s LastError = %d", #f, GetLastError()); return FALSE;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\fdi.cpp ===
#include "wsdueng.h"
#include <io.h>
#include <sys/stat.h>
#include <fcntl.h>

/*
 * Function prototypes 
 */
BOOL	fdi(char *cabinet_file, char *dir);
int		get_percentage(unsigned long a, unsigned long b);
char   *return_fdi_error_string(int err);


/*
 * Destination directory for extracted files
 */
char	dest_dir[256];

/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
	return malloc(cb);
}

/*
 * Memory free function
 */
FNFREE(mem_free)
{
	free(pv);
}


FNOPEN(file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
	return _read((int)hf, pv, cb);
}


FNWRITE(file_write)
{
	return _write((int)hf, pv, cb);
}


FNCLOSE(file_close)
{
	return _close((int)hf);
}


FNSEEK(file_seek)
{
	return _lseek((int)hf, dist, seektype);
}


FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
        	INT_PTR		handle;
            int		response;
			char	destination[256];

            wsprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);

            handle = file_open(
					destination,
					_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
					_S_IREAD | _S_IWRITE 
				);

            return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];
            
            wsprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);
			file_close(pfdin->hf);


            handle = CreateFile(
                destination,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime(
                    pfdin->date,
                    pfdin->time,
                    &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime(
                        &datetime,
                        &local_filetime))
                    {
                        (void) SetFileTime(
                            handle,
                            &local_filetime,
                            NULL,
                            &local_filetime
                        );
                     }
                }

                CloseHandle(handle);
            }

            attrs = pfdin->attribs;

            attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

            (void) SetFileAttributes(
                destination,
                attrs
            );

			return TRUE;
        }

		case fdintNEXT_CABINET:	// file continued to next cabinet
			return 0;
        
	}
	return 0;
}


BOOL fdi(char *cabinet_fullpath, char * directory)
{
	LOG_block("fdi()");
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR				hf;
	char			*p;
	char			cabinet_name[256];
	char			cabinet_path[256];

    strcpy(dest_dir, directory);
	if (dest_dir[strlen(dest_dir)] != '\\')
	{
		strcat(dest_dir, "\\");
	}

	hfdi = FDICreate(
		mem_alloc,
		mem_free,
		file_open,
		file_read,
		file_write,
		file_close,
		file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		LOG_error("FDICreate() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
		return FALSE;
	}


	/*
	 * Is this file really a cabinet?
	 */
	hf = file_open(
		cabinet_fullpath,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		LOG_error("Unable to open '%s' for input\n", cabinet_fullpath);
		return FALSE;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		// The file is not compressed, nothing to do. This is not an error, A lot of files on the V3 server use
		// conditional compression depending on whether it benefits the file size. 
		_close((int)hf);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}
	else
	{
		_close((int)hf);
	}

	p = strrchr(cabinet_fullpath, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, cabinet_fullpath);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		strncpy(cabinet_path, cabinet_fullpath, (int) (p-cabinet_fullpath)+1);
		cabinet_path[ (int) (p-cabinet_fullpath)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		notification_function,
		NULL,
		NULL))
	{
		LOG_error("FDICopy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
		LOG_error("FDIDestroy() failed: code %d [%s]\n", erf.erfOper, return_fdi_error_string(erf.erfOper));
		return FALSE;
	}

	return TRUE;
}


char *return_fdi_error_string(int err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return "No error";

		case FDIERROR_CABINET_NOT_FOUND:
			return "Cabinet not found";
			
		case FDIERROR_NOT_A_CABINET:
			return "Not a cabinet";
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return "Unknown cabinet version";
			
		case FDIERROR_CORRUPT_CABINET:
			return "Corrupt cabinet";
			
		case FDIERROR_ALLOC_FAIL:
			return "Memory allocation failed";
			
		case FDIERROR_BAD_COMPR_TYPE:
			return "Unknown compression type";
			
		case FDIERROR_MDI_FAIL:
			return "Failure decompressing data";
			
		case FDIERROR_TARGET_FILE:
			return "Failure writing to target file";
			
		case FDIERROR_RESERVE_MISMATCH:
			return "Cabinets in set have different RESERVE sizes";
			
		case FDIERROR_WRONG_CABINET:
			return "Cabinet returned on fdintNEXT_CABINET is incorrect";
			
		case FDIERROR_USER_ABORT:
			return "User aborted";
			
		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdu\wsdu.cpp ===
#include "wsdu.h"

HINSTANCE g_hinst;
HMODULE g_hwininet = NULL;
HMODULE g_hshlwapi = NULL;
HMODULE g_hwsdueng = NULL;
GLOBAL_STATEA g_stateA;

// defines
// change default site connection to live site from beta site
//#define WU_DEFAULT_URL  "http://content.beta.windowsupdate.com/content"
#define WU_DEFAULT_URL  "http://windowsupdate.microsoft.com"
//#define WU_DEFAULT_SELFUPD_URL "http://content.beta.windowsupdate.com/dynamicupdate"
#define WU_DEFAULT_SELFUPD_URL "http://windowsupdate.microsoft.com/dynamicupdate"

#define REG_WINNT32_DYNAMICUPDATE  "Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Winnt32\\5.1"
#define REG_VALUE_DYNAMICUPDATEURL	"DynamicUpdateUrl"
#define REG_VALUE_DYNAMICUPDATESELFUPDATEURL "DynamicUpdateSelfUpdateUrl"

// private helper function forward declares
DWORD OpenHttpConnection(LPCSTR pszServerUrl, BOOL fGetRequest);
DWORD DownloadFile(LPCSTR pszUrl, LPCSTR pszDestinationFile, BOOL fDecompress, BOOL fCheckTrust, DWORD *pdwDownloadBytesPerSecond);
BOOL IsServerFileNewer(FILETIME ftServerTime, DWORD dwServerFileSize, LPCSTR pszLocalFile);
DWORD DoSelfUpdate(LPCSTR pszTempPath, LPCSTR pszServerUrl, WORD wProcessorArchitecture);
LPSTR DuUrlCombine(LPSTR pszDest, LPCSTR pszBase, LPCSTR pszAdd);
BOOL MyGetFileVersion (LPSTR szFileName, VS_FIXEDFILEINFO& vsVersion);
int CompareFileVersion(VS_FIXEDFILEINFO& vs1, VS_FIXEDFILEINFO& vs2);

// --------------------------------------------------------------------------
//
//
//
//
//                             Main Code Begins
//
//
//
//
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
// Function Name: DllMain
// Function Description: 
//
// Function Returns:
//
//

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        g_hinst = hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ;
    }
    return TRUE;
}

// --------------------------------------------------------------------------
// Function Name: DuIsSupported
// Function Description: this method checks whether the required DLL's are on
//      the system to successfully run Dynamic Update. It does NOT attempt to
//      initiate a connection though.
//
// Function Returns:
//      FALSE: Not Supported, Some Required DLL's missing
//      TRUE:  DLL's are OK. Dynamic Update should be possible.
//
//
BOOL WINAPI DuIsSupported()
{
    LOG_block("DuIsSupported()");
    // There are two dlls we directly need to support dynamic setup.. These are
    // wininet.dll and shlwapi.dll. So this function will try to loadlibrary each 
    // of these dlls to verify they are on the system.
    if (NULL == g_hwininet)
    {
        g_hwininet = LoadLibrary("wininet.dll");
        if (NULL == g_hwininet)
        {
            LOG_error("Unable to Load wininet.dll, Dynamic Setup Not Supported");
            return FALSE;
        }
    }

    if (NULL == g_hshlwapi)
    {
        g_hshlwapi = LoadLibrary("shlwapi.dll");
        if (NULL == g_hshlwapi)
        {
            LOG_error("Unable to Load shlwapi.dll, Dynamic Setup Not Supported");
            return FALSE;
        }
    }

    // Dynamic Update relies on a bunch of API's WinInet and Shlwapi. To try to consolidate where these function pointers
    // Live throughout the code we'll use a global state structure.

    g_stateA.fpnInternetOpen = (PFN_InternetOpen) GetProcAddress(g_hwininet, "InternetOpenA");
    g_stateA.fpnInternetConnect = (PFN_InternetConnect) GetProcAddress(g_hwininet, "InternetConnectA");
    g_stateA.fpnHttpOpenRequest = (PFN_HttpOpenRequest) GetProcAddress(g_hwininet, "HttpOpenRequestA");
    g_stateA.fpnHttpAddRequestHeaders = (PFN_HttpAddRequestHeaders) GetProcAddress(g_hwininet, "HttpAddRequestHeadersA");
    g_stateA.fpnHttpSendRequest = (PFN_HttpSendRequest) GetProcAddress(g_hwininet, "HttpSendRequestA");
    g_stateA.fpnHttpQueryInfo = (PFN_HttpQueryInfo) GetProcAddress(g_hwininet, "HttpQueryInfoA");
    g_stateA.fpnInternetSetOption = (PFN_InternetSetOption) GetProcAddress(g_hwininet, "InternetSetOptionA");
    g_stateA.fpnInternetCrackUrl = (PFN_InternetCrackUrl) GetProcAddress(g_hwininet, "InternetCrackUrlA");
    g_stateA.fpnInternetReadFile = (PFN_InternetReadFile) GetProcAddress(g_hwininet, "InternetReadFile");
    g_stateA.fpnInternetCloseHandle = (PFN_InternetCloseHandle) GetProcAddress(g_hwininet, "InternetCloseHandle");
	g_stateA.fpnInternetGetConnectedState = (PFN_InternetGetConnectedState) GetProcAddress(g_hwininet, "InternetGetConnectedState");
	g_stateA.fpnPathAppend = (PFN_PathAppend) GetProcAddress(g_hshlwapi, "PathAppendA");
	g_stateA.fpnPathRemoveFileSpec = (PFN_PathRemoveFileSpec) GetProcAddress(g_hshlwapi, "PathRemoveFileSpecA");
	g_stateA.fpnInternetAutodial = (PFN_InternetAutodial) GetProcAddress(g_hwininet, "InternetAutodial");
	g_stateA.fpnInternetAutodialHangup = (PFN_InternetAutodialHangup) GetProcAddress(g_hwininet, "InternetAutodialHangup");

	if (!g_stateA.fpnInternetOpen || ! g_stateA.fpnInternetConnect || !g_stateA.fpnHttpOpenRequest ||
		!g_stateA.fpnHttpAddRequestHeaders || !g_stateA.fpnHttpSendRequest || !g_stateA.fpnHttpQueryInfo ||
		!g_stateA.fpnInternetCrackUrl || !g_stateA.fpnInternetReadFile || !g_stateA.fpnInternetCloseHandle ||
		!g_stateA.fpnInternetGetConnectedState || !g_stateA.fpnPathAppend || !g_stateA.fpnPathRemoveFileSpec ||
		!g_stateA.fpnInternetAutodial || !g_stateA.fpnInternetAutodialHangup)
	{
		// fail to get any of the function pointer above
		SafeFreeLibrary(g_hwininet);
		SafeFreeLibrary(g_hshlwapi);
		return FALSE;
	}
	
    return TRUE;
}


// --------------------------------------------------------------------------
// Function Name: DuInitialize
// Function Description: Initializes the Dynamic Setup Update engine. During
//      initialization this API attempts to establish a connection to the internet
//      and starts a self update process to ensure the latest bits are being used.
//      We also calculate the estimated transfer speed of the connection during this
//      time.
//
// Function Returns:
//      Failure: INVALID_HANDLE_VALUE .. Call GetLastError to retrieve the Error Code
//      Success: Handle of the Dynamic Setup Job
//
//
HANDLE WINAPI DuInitializeA(IN LPCSTR pszBasePath, // base directory used for relative paths for downloaded files
		                    IN LPCSTR pszTempPath, // temp directory used to download update dlls, catalog files, etc
				   			IN POSVERSIONINFOEXA posviTargetOS, // target OS platform
							IN LPCSTR pszTargetArch, // string value identifying the architecture 'i386' and 'ia64'
		                    IN LCID lcidTargetLocale, // target OS Locale ID
							IN BOOL fUnattend, // is this an unattended operation
							IN BOOL fUpgrade, // is this an upgrade
		                    IN PWINNT32QUERY pfnWinnt32QueryCallback)
{
    LOG_block("DuInitialize()");
	char szServerUrl[INTERNET_MAX_URL_LENGTH + 1] = {'\0'};
	char szSelfUpdateUrl[INTERNET_MAX_URL_LENGTH + 1] = {'\0'};
	DWORD dwEstimatedDownloadSpeedInBytesPerSecond = 0;

    g_stateA.fUnattended = fUnattend;
    
    // param validation
    if ((NULL == pszBasePath) || (NULL == pszTempPath) || (NULL == posviTargetOS) || (posviTargetOS->dwOSVersionInfoSize != sizeof(OSVERSIONINFOEXA)) 
        || (NULL == pszTargetArch) || (0 == lcidTargetLocale) || (0 == posviTargetOS->dwBuildNumber))
    {
        LOG_error("Invalid Parameter passed to DuInitialize");
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    WORD wProcessorArchitecture;
    if (!lstrcmpiA(pszTargetArch, "i386"))
    	wProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
    else if (!lstrcmpiA(pszTargetArch,"ia64"))
    	wProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
    else 
    {
    	LOG_error("Invalid Processor Type");
    	SetLastError(ERROR_INVALID_PARAMETER);
    	return INVALID_HANDLE_VALUE;
    }

	// ROGERJ, verify the caller is using the correct architecture information
	// because of the pointer size, the 64-bit content can not be seen from 32-bit machine and vice versa
	SYSTEM_INFO sysInfo;
	GetSystemInfo(&sysInfo);
	if (sysInfo.wProcessorArchitecture != wProcessorArchitecture)
	{
    	LOG_error("Invalid Processor Type. Processor is %d.", sysInfo.wProcessorArchitecture);
    	SetLastError(ERROR_INVALID_PARAMETER);
    	return INVALID_HANDLE_VALUE;
	}
	
    // Verify that the Temp and Download Folders Exist are Valid.
	DWORD dwAttr = GetFileAttributes(pszBasePath);
	if ((dwAttr == 0xFFFFFFFF) || ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0))
	{
		LOG_error("Error - Base Path (DownloadDir) Does Not Exist");
		SetLastError(ERROR_INVALID_PARAMETER);
		return INVALID_HANDLE_VALUE;
	}
	dwAttr = GetFileAttributes(pszTempPath);
	if ((dwAttr == 0xFFFFFFFF) || ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0))
	{
		LOG_error("Error - Temp Path Does Not Exist");
		SetLastError(ERROR_INVALID_PARAMETER);
		return INVALID_HANDLE_VALUE;
	}

    if (NULL == g_hwininet || NULL == g_hshlwapi)
    {
        // DuIsSupported was not called, or was called and Failed before calling DuInitialize.
        // try again, if it fails, abort.
        if (!DuIsSupported())
        {
            LOG_error("Dynamic Setup Required DLL's not available, Cannot Continue");
            SetLastError(DU_ERROR_MISSING_DLL);
            return INVALID_HANDLE_VALUE;
        }
    }

    // RogerJ, Ocotber 17th, 2000

	// first check for an existing InternetConnection. If we have an existing InternetConnection, we do not
	// need to do any further check, we will use this connection
	char szCurDir[MAX_PATH];
	ZeroMemory(szCurDir, MAX_PATH*sizeof(char));
	GetCurrentDirectoryA(MAX_PATH, szCurDir);
	
    g_stateA.fDialed = FALSE;
    DWORD dwConnectedState = 0;
    if (!g_stateA.fpnInternetGetConnectedState(&dwConnectedState, 0))
    {
        LOG_out("Not online, status %d", dwConnectedState);
    	// not online, we need to establish a connection.  If we are at an unattended mode, we do not want to
    	// trigger an autodial, thus return FALSE
        if (fUnattend // The machine is not connected to the net, and we are in unattended mode.
        	|| !(dwConnectedState & INTERNET_CONNECTION_MODEM)) // The machine can not be connected via a modem
        {
            
            SetLastError(ERROR_CONNECTION_UNAVAIL);
            return INVALID_HANDLE_VALUE;
        }
        else 
        {
        	if (!g_stateA.fpnInternetAutodial (INTERNET_AUTODIAL_FORCE_ONLINE, // options
        									   NULL))
        	{
        	    SetLastError(ERROR_CONNECTION_UNAVAIL);
        		return INVALID_HANDLE_VALUE;
        	}
        	else
        		g_stateA.fDialed = TRUE;
        }
    }

    SetCurrentDirectoryA(szCurDir);
  
    GetModuleFileNameA(NULL, szCurDir, MAX_PATH);
    // find the last backslash
    char* pLastBackSlash = szCurDir + lstrlenA(szCurDir) -1;
    while (pLastBackSlash > szCurDir && *pLastBackSlash != '\\')
        pLastBackSlash--;

    *(pLastBackSlash+1) = '\0';
    

	// We need to get the Server URL where we will get the ident.cab and SelfUpdateUrl. For this we'll be looking at 
    // the registry path (see DEFINE for REG_WINNT32_DYNAMICUPDATE at the top of this file).
    // If we cannot get the URL we will default to the preset URLs. The most common scenario is to default
    // to the hard coded URL's.. the regkey is in place mainly for testing or emergency changes.
	HKEY hkey;
	if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_WINNT32_DYNAMICUPDATE, &hkey))
	{
		DWORD dwType = 0;
		DWORD dwUrlLength = sizeof(szServerUrl);
		RegQueryValueEx(hkey, REG_VALUE_DYNAMICUPDATEURL, NULL, &dwType, (LPBYTE)szServerUrl, &dwUrlLength);
		dwUrlLength = sizeof(szSelfUpdateUrl);
		RegQueryValueEx(hkey, REG_VALUE_DYNAMICUPDATESELFUPDATEURL, NULL, &dwType, (LPBYTE)szSelfUpdateUrl, &dwUrlLength);
		RegCloseKey(hkey);
	}

	// if we get through the reg lookup and we still don't have a server url, use the default.
	if ('\0' == szServerUrl[0])
	{
		lstrcpy(szServerUrl, WU_DEFAULT_URL);
	}
	if ('\0' == szSelfUpdateUrl[0])
	{
   		lstrcpy(szSelfUpdateUrl, WU_DEFAULT_SELFUPD_URL);
	}


    // Download the Ident.Cab
    char szIdentCab[MAX_PATH];
    lstrcpy(szIdentCab, pszTempPath);
    g_stateA.fpnPathAppend(szIdentCab, "ident.cab");
    char szServerIdentCab[INTERNET_MAX_URL_LENGTH + 1];
	DuUrlCombine(szServerIdentCab, szServerUrl, "ident.cab");

	// Remove any formerly downloaded ident.cab --- solve problem when a untrusted ident.cab is formerly
	// accepted, the system will not ask user to accept again, while it should
	DeleteFile(szIdentCab);
	
    DWORD dwRet = DownloadFile(szServerIdentCab, szIdentCab, TRUE, TRUE, NULL);
    if (ERROR_SUCCESS != dwRet)
    {
        // Most likely the site is down
        LOG_error("Establish Connection Failed, unable to continue");
        SetLastError(ERROR_INTERNET_INVALID_URL);
        return INVALID_HANDLE_VALUE;
    }
    
    SafeFreeLibrary(g_hwsdueng);
	char szEngineDll[MAX_PATH];
	lstrcpy(szEngineDll, pszTempPath);
	g_stateA.fpnPathAppend(szEngineDll, "wsdueng.dll");
	// remove any old wsdueng.dll in that directory, in order to avoid actually load an older engine
	// we don't care if the DeleteFile call is failed.  If it is failed, most likely,  there is no wsdueng.dll
	// to delete.
	DeleteFile(szEngineDll);

    // SelfUpdate is an optional process, which is why we don't check the return result. The selfupdate CAB
    // is also the only file we can download and try to estimate the connection speed. The selfupdate CAB
    // is approximately 60k.. Every other file we download before downloading the updates themselves is less than
    // 1k, which is far to small to estimate speed.
    dwEstimatedDownloadSpeedInBytesPerSecond = DoSelfUpdate(pszTempPath, szSelfUpdateUrl, wProcessorArchitecture);

	// get the fully qualified name of engine DLL in current directory
	// reuse variable szCurDir here
	lstrcat(szCurDir, "wsdueng.dll");
	
	// check file version to decide which dll to load.
	VS_FIXEDFILEINFO vsLocal, vsDownloaded;
	BOOL bCheckLocal = MyGetFileVersion(szCurDir, vsLocal);
	BOOL bCheckServer = MyGetFileVersion(szEngineDll, vsDownloaded);
	if (!bCheckLocal && !bCheckServer)
	{
		LOG_error("Failed to get both file version");
	}

	if (CompareFileVersion(vsLocal, vsDownloaded) >= 0)
	{
		// local file is newer or same
		g_hwsdueng = LoadLibrary(szCurDir);
		LOG_out("Load local engine");
	}
	else
	{
		// Load the self update engine DLL
		g_hwsdueng = LoadLibrary(szEngineDll);
		LOG_out("Load self update engine");
	}
		
	
	if (NULL == g_hwsdueng)
	{
		// if that fails, try to load what ever engine dll the system can find
		g_hwsdueng = LoadLibrary("wsdueng.dll");
		LOG_out("Trying to load any engine");
		if (NULL == g_hwsdueng)
		{
			LOG_error("Unable to load wsdueng.dll, Critical Error: Shouldn't have happened");
			SetLastError(DU_ERROR_MISSING_DLL);
			return INVALID_HANDLE_VALUE;
		}
	}

	PFN_DuInitializeA fpnDuInitialize = (PFN_DuInitializeA) GetProcAddress(g_hwsdueng, "DuInitializeA");
	if (NULL == fpnDuInitialize)
	{
		LOG_error("Unable to find DuInitializeA entrypoint in wsdueng.dll, Critical Error");
		SetLastError(DU_ERROR_MISSING_DLL);
		return INVALID_HANDLE_VALUE;
	}

    HANDLE hRet;
    // Forward the Call to the Engine Dll to complete the initialization.
    hRet = fpnDuInitialize(pszBasePath, pszTempPath, posviTargetOS, pszTargetArch, lcidTargetLocale, fUnattend, fUpgrade, pfnWinnt32QueryCallback);

    // If SelfUpdate happened and we have a valid Estimated Download Speed, Pass the download speed into the Engine Dll for time estimates.
	PFN_SetEstimatedDownloadSpeed fpnSetEstimatedDownloadSpeed = (PFN_SetEstimatedDownloadSpeed) GetProcAddress(g_hwsdueng, "SetEstimatedDownloadSpeed");
	if (NULL != fpnSetEstimatedDownloadSpeed && 0 != dwEstimatedDownloadSpeedInBytesPerSecond)
	{
		fpnSetEstimatedDownloadSpeed(dwEstimatedDownloadSpeedInBytesPerSecond);
	}
	return hRet;
}

HANDLE WINAPI DuInitializeW(IN LPCWSTR pwszBasePath, // base directory used for relative paths for downloaded files
                     IN LPCWSTR pwszTempPath, // temp directory used to download update dlls, catalog files, etc
                     IN POSVERSIONINFOEXW posviTargetOS, // target OS platform
                     IN LPCWSTR pwszTargetArch, // string value identifying the architecture 'i386' and 'ia64'
                     IN LCID lcidTargetLocale, // target OS Locale ID
				     IN BOOL fUnattend, // is this an unattended operation
                     IN BOOL fUpgrade, // is this an upgrade
                     IN PWINNT32QUERY pfnWinnt32QueryCallback)
{
    LOG_block("DuInitialize()");
    // param validation
    if ((NULL == pwszBasePath) || (NULL == pwszTempPath) || (NULL == posviTargetOS) || (posviTargetOS->dwOSVersionInfoSize != sizeof(OSVERSIONINFOEXW)) 
        || (0 == lcidTargetLocale))
    {
        LOG_error("Invalid Parameter passed to DuInitialize");
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

	char szBasePath[MAX_PATH];
	char szTempPath[MAX_PATH];
	char szTargetArch[128];

	OSVERSIONINFOEX osvi;

	WideCharToMultiByte(CP_ACP, 0, pwszBasePath, -1, szBasePath, sizeof(szBasePath), NULL, NULL);
	WideCharToMultiByte(CP_ACP, 0, pwszTempPath, -1, szTempPath, sizeof(szTempPath), NULL, NULL);
	WideCharToMultiByte(CP_ACP, 0, pwszTargetArch, -1, szTargetArch, sizeof(szTargetArch), NULL, NULL);

	osvi.dwOSVersionInfoSize = sizeof(osvi);
	osvi.dwMajorVersion = posviTargetOS->dwMajorVersion;
	osvi.dwMinorVersion = posviTargetOS->dwMinorVersion;
	osvi.dwBuildNumber = posviTargetOS->dwBuildNumber;
	osvi.dwPlatformId = posviTargetOS->dwPlatformId;
	WideCharToMultiByte(CP_ACP, 0, posviTargetOS->szCSDVersion, -1, osvi.szCSDVersion, sizeof(osvi.szCSDVersion), NULL, NULL);
	osvi.wServicePackMajor = posviTargetOS->wServicePackMajor;
	osvi.wServicePackMinor = posviTargetOS->wServicePackMinor;
	osvi.wSuiteMask = posviTargetOS->wSuiteMask;
	osvi.wProductType = posviTargetOS->wProductType;
	osvi.wReserved = posviTargetOS->wReserved;

	return DuInitializeA(szBasePath, szTempPath, &osvi, szTargetArch, lcidTargetLocale, fUnattend, fUpgrade, pfnWinnt32QueryCallback);
}

// --------------------------------------------------------------------------
// Function Name: DuDoDetection
// Function Description: Does detection of Drivers on the System, compiles an 
//      internal list of items to download and how long it will take to download
//      them.
//
// Function Returns:
//      Failure: FALSE .. Call GetLastError to retrieve the Error Code
//      Success: TRUE
//
BOOL WINAPI DuDoDetection(IN HANDLE hConnection, OUT PDWORD pdwEstimatedTime, OUT PDWORD pdwEstimatedSize)
{
    LOG_block("DuDoDetection()");
    // param validation
    if (INVALID_HANDLE_VALUE == hConnection || NULL == pdwEstimatedTime || NULL == pdwEstimatedSize)
    {
        LOG_error("Invalid Parameter passed to DuDoDetection");
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
	// clear any error set by other program
	SetLastError(0);

    if (NULL == g_hwsdueng)
    {
        // DuDoDetection was called without calling DuInitialize, our state is invalid
        LOG_error("Initialization Invalid, Engine is not Initialized");
        SetLastError(DU_NOT_INITIALIZED);
        return FALSE;
    }

    PFN_DuDoDetection fpnDuDoDetection = (PFN_DuDoDetection) GetProcAddress(g_hwsdueng, "DuDoDetection");
    if (NULL == fpnDuDoDetection)
    {
        LOG_error("Unable to find DuDoDetection entrypoint in wsdueng.dll, Critical Error");
        SetLastError(DU_ERROR_MISSING_DLL);
        return FALSE;
    }

    return fpnDuDoDetection(hConnection, pdwEstimatedTime, pdwEstimatedSize);
}


// --------------------------------------------------------------------------
// Function Name: DuBeginDownload
// Function Description: Begins Downloading based on the detection done in the DuDoDetection call.
//      Progress callbacks are made to the specified HWND. Function returns immediately, download
//      is asynchronous.
//
// Function Returns:
//      Failure: FALSE .. Call GetLastError to retrieve the Error Code
//      Success: TRUE
//
BOOL WINAPI DuBeginDownload(IN HANDLE hConnection, IN HWND hwndNotify)
{
    LOG_block("DuBeginDownload()");
    // param validation
    if (INVALID_HANDLE_VALUE == hConnection || NULL == hwndNotify)
    {
        LOG_error("Invalid Parameter passed to DuBeginDownload");
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (NULL == g_hwsdueng)
    {
        // DuDoDetection was called without calling DuInitialize, our state is invalid
        LOG_error("Initialization Invalid, Engine is not Initialized");
        SetLastError(DU_NOT_INITIALIZED);
        return FALSE;
    }

    PFN_DuBeginDownload fpnDuBeginDownload = (PFN_DuBeginDownload) GetProcAddress(g_hwsdueng, "DuBeginDownload");
    if (NULL == fpnDuBeginDownload)
    {
        LOG_error("Unable to find DuBeginDownload entrypoint in wsdueng.dll, Critical Error");
        SetLastError(DU_ERROR_MISSING_DLL);
        return FALSE;
    }

    return fpnDuBeginDownload(hConnection, hwndNotify);
}

// --------------------------------------------------------------------------
// Function Name: DuAbortDownload
// Function Description: Aborts current download.
//
// Function Returns:
//      nothing
//
void WINAPI DuAbortDownload(IN HANDLE hConnection)
{
    LOG_block("DuAbortDownload()");
    if (INVALID_HANDLE_VALUE == hConnection)
    {
        LOG_error("Invalid Parameter passed to DuAbortDownload");
        return;
    }
    
    if (NULL == g_hwsdueng)
    {
        LOG_error("Initialization Invalid, Engine is not Initialized");
        return;
    }

    PFN_DuAbortDownload fpnDuAbortDownload = (PFN_DuAbortDownload) GetProcAddress(g_hwsdueng, "DuAbortDownload");
    if (NULL == fpnDuAbortDownload)
    {
        LOG_error("Unable to find DuBeginDownload entrypoint in wsdueng.dll, Critical Error");
        return;
    }
    
    fpnDuAbortDownload(hConnection);
    return;
}


// --------------------------------------------------------------------------
// Function Name: DuUninitialize
// Function Description: Performs internal CleanUp 
//
//
// Function Returns:
//      nothing
//

void WINAPI DuUninitialize(HANDLE hConnection)
{
    LOG_block("DuUninitialize()");

	// close internet handle
	if (g_stateA.hConnect) 
	{
		if (!g_stateA.fpnInternetCloseHandle (g_stateA.hConnect))
		{
			LOG_error("InternetConnection close handle failed --- %d", GetLastError());
		}
		g_stateA.hConnect = NULL;
	}
	if (g_stateA.hInternet)
	{
		if (!g_stateA.fpnInternetCloseHandle (g_stateA.hInternet))
		{
			LOG_error("InternetOpen close handle failed --- %d", GetLastError());
		}
		g_stateA.hInternet = NULL;
	}

	// disconnect from internet if we dialed
	if (g_stateA.fDialed)
	{
		// we have dialed a connection, now we need to disconnect
		if (!g_stateA.fpnInternetAutodialHangup(0))
		{
			LOG_error("Failed to hang up");
		}
		else
			g_stateA.fDialed = FALSE;
	}
	
    if (INVALID_HANDLE_VALUE == hConnection)
    {
        LOG_error("Invalid Parameter passed to DuUninitialize");
        return;
    }

    if (NULL == g_hwsdueng)
    {
        LOG_error("Initialization Invalid, Engine is not Initialized");
        return;
    }

    PFN_DuUninitialize fpnDuUninitialize = (PFN_DuUninitialize) GetProcAddress(g_hwsdueng, "DuUninitialize");
    if (NULL == fpnDuUninitialize)
    {
        LOG_error("Unable to find DuUninitialize entrypoint in wsdueng.dll, Critical Error");
    }
	else 
		fpnDuUninitialize(hConnection);

	// free libraries
	SafeFreeLibrary(g_hwsdueng);
	SafeFreeLibrary(g_hshlwapi);
	SafeFreeLibrary(g_hwininet);

	// re-initialize the global structure
	ZeroMemory(&g_stateA, sizeof(GLOBAL_STATEA));
	// close log file
	LOG_close();
    return;
}

// --------------------------------------------------------------------------
// Private Helper Functions
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
// Function Name: OpenHttpConnection
// Function Description: Determines whether an Internet Connection is available
//
// Function Returns:
//      ERROR_SUCCESS if conection is available, Error Code otherwise. 
//

DWORD OpenHttpConnection(LPCSTR pszServerUrl, BOOL fGetRequest)
{
    LOG_block("OpenHttpConnection()");
    DWORD dwErr, dwStatus, dwLength;
    LPSTR AcceptTypes[] = {"*/*", NULL};
    URL_COMPONENTSA UrlComponents;
    // Buffers used to Break the URL into its different components for Internet API calls
    char szServerName[INTERNET_MAX_URL_LENGTH + 1];
    char szObject[INTERNET_MAX_URL_LENGTH + 1];
    char szUserName[UNLEN+1];
    char szPasswd[UNLEN+1];

    dwErr = dwStatus = dwLength = 0;
    
    // We need to break down the Passed in URL into its various components for the InternetAPI Calls. Specifically we
    // Need the server name, object to download, username and password information.
	ZeroMemory(szServerName, INTERNET_MAX_URL_LENGTH + 1);
    ZeroMemory(szObject, INTERNET_MAX_URL_LENGTH + 1);
	ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize = sizeof(UrlComponents);
	UrlComponents.lpszHostName = szServerName;
    UrlComponents.dwHostNameLength = INTERNET_MAX_URL_LENGTH + 1;
	UrlComponents.lpszUrlPath = szObject;
    UrlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
	UrlComponents.lpszUserName = szUserName;
	UrlComponents.dwUserNameLength = UNLEN + 1;
	UrlComponents.lpszPassword = szPasswd;
	UrlComponents.dwPasswordLength = UNLEN + 1;

    if (! g_stateA.fpnInternetCrackUrl(pszServerUrl, 0, 0, &UrlComponents) )
    {
        dwErr = GetLastError();
        LOG_error("InternetCrackUrl Failed, Error %d", dwErr);
        return dwErr;
    }
    
    // Initialize the InternetAPI's
    if (!g_stateA.hInternet &&
        !(g_stateA.hInternet = g_stateA.fpnInternetOpen("Dynamic Update", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)) )
    {
        dwErr = GetLastError();
        LOG_error("InternetOpen Failed, Error %d", dwErr);
        return dwErr;
    }

    dwStatus = 30 * 1000; // 30 seconds in milliseconds
    dwLength = sizeof(dwStatus);
    g_stateA.fpnInternetSetOption(g_stateA.hInternet, INTERNET_OPTION_SEND_TIMEOUT, &dwStatus, dwLength);

    // Open a session for the Target Server
    // Open a session only when there is no session opened
    if (!g_stateA.hConnect &&
    	!(g_stateA.hConnect = g_stateA.fpnInternetConnect(g_stateA.hInternet, szServerName, INTERNET_DEFAULT_HTTP_PORT, szUserName, 
        szPasswd, INTERNET_SERVICE_HTTP, INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD, 0)) )
    {
        dwErr = GetLastError();
        LOG_error("InternetConnect Failed, Error %d", dwErr);
        return dwErr;
    }

    // Create a Request for the File we're going to download
    if (! (g_stateA.hOpenRequest = g_stateA.fpnHttpOpenRequest(g_stateA.hConnect, 
							(fGetRequest) ? NULL /*GET*/ : "HEAD", 
                            szObject, 
                            NULL /*HTTP1.0*/, 
                            NULL, 
                            (LPCSTR *)AcceptTypes, 
                            INTERNET_FLAG_NO_UI,
                            0)) )
    {
        dwErr = GetLastError();
        LOG_error("HttpOpenRequest Failed, Error %d", dwErr);
        return dwErr;
    }

    int nNumOfTrial = 0;
    do
    {
        // Send the Request for the File. This will attempt to establish a connection to the internet if one does not 
        // already exist --- As October 17, 2000, an connection is guaranteed to be established at this point (RogerJ)
        if (! g_stateA.fpnHttpSendRequest(g_stateA.hOpenRequest, NULL, 0, NULL, 0) )
        {
            dwErr = GetLastError();
            LOG_error("HttpSendRequest Failed, Error %d", dwErr);
            return dwErr;
        }

        // Determine the HTTP Status Result, did the Request Succeed?
        dwLength = sizeof(dwStatus);
        if (! g_stateA.fpnHttpQueryInfo(g_stateA.hOpenRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, 
            (LPVOID)&dwStatus, &dwLength, NULL) )
        {
            dwErr = GetLastError();
            LOG_error("HttpQueryInfo Failed, Error %d", dwErr);
            return dwErr;
        }
        nNumOfTrial++;
    } while (NeedRetry(dwStatus) && nNumOfTrial < DU_CONNECTION_RETRY);

    // ROGERJ, if the site is found but the URL is not in the site, instead of return connection unavailable,
    // will return the actual error --- 404

    // If the Request did not succeed we'll assume we have no internet connection and return the Error Code
    // that Setup will trigger a warning to the user to manually establish a connection.
    if ((HTTP_STATUS_OK != dwStatus) && (HTTP_STATUS_PARTIAL_CONTENT != dwStatus))
    {
        LOG_error("Http Status NOT OK, Status %d", dwStatus);
        if (HTTP_STATUS_NOT_FOUND == dwStatus)
         	return ERROR_INTERNET_INVALID_URL;
        else return ERROR_CONNECTION_UNAVAIL;
    }
    

    return ERROR_SUCCESS;
}


// --------------------------------------------------------------------------
// Function Name: DoSelfUpdate
// Function Description: Connects to the Internet and Attempts to Selfupdate
//      the dynamic update code.
//
// Function Returns:
//      nothing - failure to selfupdate is not catastrophic
//

DWORD DoSelfUpdate(LPCSTR pszTempPath, LPCSTR pszServerUrl, WORD wProcessorArchitecture)
{
	LOG_block("DoSelfUpdate()");
    if ((NULL == pszTempPath) || (NULL == pszServerUrl) || (lstrlen(pszTempPath) > MAX_PATH))
    {
        return 0;
    }

	char szINIFile[MAX_PATH];
	lstrcpy(szINIFile, pszTempPath);
	g_stateA.fpnPathAppend(szINIFile, "ident.txt");
	DWORD dwRet;
	DWORD dwBytesPerSecond = 0;
	SYSTEM_INFO		sysInfo;	

#define DUHEADER "DuHeader"

	char szSection[MAX_PATH];
	char szValue[MAX_PATH];
	char szKey[MAX_PATH];
	char szUrl[INTERNET_MAX_URL_LENGTH];

	GetPrivateProfileString(DUHEADER, "server", "", szSection, sizeof(szSection), szINIFile);
	if ('\0' == szSection[0])
	{
		lstrcpyA(szUrl, pszServerUrl);
	}
	else
	{
		GetPrivateProfileString(szSection, "server", "", szValue, sizeof(szValue), szINIFile);
		if ('\0' == szValue[0])
		{
			lstrcpyA(szUrl, pszServerUrl);
		}
		else
		{
			lstrcpyA(szUrl, szValue);
		}
	}

	// RogerJ, we find out the processor type based on the parameter passed in
	// find out what type of processor this machine has
	switch ( wProcessorArchitecture )
	{
	case PROCESSOR_ARCHITECTURE_INTEL:
		lstrcpy(szKey, "x86");
		break;
	case PROCESSOR_ARCHITECTURE_IA64:
		lstrcpy(szKey,"ia64");
		break;
	default:
		LOG_error("Failed to Determine Processor Architecture");
		return 0;
	}


	GetPrivateProfileString(DUHEADER, "arch", "", szSection, sizeof(szSection), szINIFile);
	if ('\0' == szSection[0])
	{
		LOG_error("Failed to get Arch Section Name from Ident");
		return 0;
	}

	// Get the Directory Name of the Processor Architecture. 
	GetPrivateProfileString(szSection, szKey, "", szValue, sizeof(szValue), szINIFile);
	if ('\0' == szValue[0])
	{
		LOG_error("Failed to get Directory name for Arch from Ident");
		return 0;
	}
	lstrcat(szUrl, szValue);

	GetPrivateProfileString(DUHEADER, "os", "", szSection, sizeof(szSection), szINIFile);
	if ('\0' == szSection[0])
	{
		LOG_error("Failed to get OS Section Name from Ident");
		return 0;
	}

    // get local os information
	OSVERSIONINFO OsInfo;
	ZeroMemory( (PVOID) &OsInfo, sizeof (OsInfo) );
	OsInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
	if (!GetVersionEx( &OsInfo ))
    {
	    // Function call failed, last error is set by GetVersionEx()
    	return 0;
    }

    #define LOCAL_OS_BUFFER 10
    char szLocalOS[LOCAL_OS_BUFFER];
    ZeroMemory(szLocalOS, LOCAL_OS_BUFFER * sizeof(char));
    
	if ( VER_PLATFORM_WIN32_NT == OsInfo.dwPlatformId )
	{
		// WinNT, DU driver is supported only from W2K and up
		if ( 4 >= OsInfo.dwMajorVersion )
		{
			// NT 3.51 or NT 4.0
			lstrcpy(szLocalOS, "nt4");
			
		}
    	else if ( 5 == OsInfo.dwMajorVersion)
    	{
    		if ( 0 == OsInfo.dwMinorVersion)
    		{
    			// Win2K
    			lstrcpy(szLocalOS, "nt5");
    		}
    		else
    		{
    		    // WinXP
    		    lstrcpy(szLocalOS, "whi");
    		}
    	}
    	else
    	{
    	    // Blackcomb? not supported
    	    LOG_error("OS major version is %d, not supported", OsInfo.dwMajorVersion);
    	    return 0;
    	}
			
	}
	else if ( VER_PLATFORM_WIN32_WINDOWS == OsInfo.dwPlatformId )
	{
		
		if ( 0 == OsInfo.dwMinorVersion )
		{
            // Win 95
            lstrcpy(szLocalOS, "w95");
		}
		else if (90 <= OsInfo.dwMinorVersion)
		{
			// WinME
			lstrcpy(szLocalOS, "mil");
		}
		else 
		{
		    // Win 98 and Win 98SE
		    lstrcpy(szLocalOS, "w98");
		}
	}
	else
	{
		// Win 3.x and below
		LOG_error("Win 3.x and below? not supported");
		return 0;
	}

	GetPrivateProfileString(szSection, szLocalOS, "", szValue, sizeof(szValue), szINIFile);
	if ('\0' != szValue[0])
	{
		lstrcat(szUrl, szValue);
	}
	
	// The self update server name is: DynamicUpdate\x86\"os name"
	// The Locale is not necessary since dynamic update is not localized.

	// potentially the self update URL is not the same server as the site URL,
	// so we need to close the connection handle and internet handle here
	if (g_stateA.hConnect) 
	{
		if (!g_stateA.fpnInternetCloseHandle (g_stateA.hConnect))
		{
			LOG_error("InternetConnection close handle failed --- %d", GetLastError());
		}
		g_stateA.hConnect = NULL;
	}
	if (g_stateA.hInternet)
	{
		if (!g_stateA.fpnInternetCloseHandle (g_stateA.hInternet))
		{
			LOG_error("InternetOpen close handle failed --- %d", GetLastError());
		}
		g_stateA.hInternet = NULL;
	}


	// Now we have the server path, try to download the wsdueng.cab file.
	char szServerFile[INTERNET_MAX_URL_LENGTH];
	char szLocalFile[MAX_PATH];
	DuUrlCombine(szServerFile, szUrl, "wsdueng.cab");
	lstrcpy(szLocalFile, pszTempPath);
	g_stateA.fpnPathAppend(szLocalFile, "wsdueng.cab");
	dwRet = DownloadFile(szServerFile, szLocalFile, TRUE, TRUE, &dwBytesPerSecond);
	
	// potentially the self update URL is not the same server as the site URL,
	// so we need to close the connection handle and internet handle here
	if (g_stateA.hConnect) 
	{
		if (!g_stateA.fpnInternetCloseHandle (g_stateA.hConnect))
		{
			LOG_error("InternetConnection close handle failed --- %d", GetLastError());
		}
		g_stateA.hConnect = NULL;
	}
	if (g_stateA.hInternet)
	{
		if (!g_stateA.fpnInternetCloseHandle (g_stateA.hInternet))
		{
			LOG_error("InternetOpen close handle failed --- %d", GetLastError());
		}
		g_stateA.hInternet = NULL;
	}
	if (ERROR_SUCCESS == dwRet)
	{
		return dwBytesPerSecond;		
	}
	return 0;
}

// --------------------------------------------------------------------------
// Function Name: DownloadFile
// Function Description: Connects to the Internet and Attempts to Selfupdate
//      the dynamic update code.
//
// Function Returns:
//      ERROR_SUCCESS if all is OK, Error Code from GetLastError otherwise
//

DWORD DownloadFile(LPCSTR pszUrl, LPCSTR pszDestinationFile, BOOL fDecompress, BOOL fCheckTrust, DWORD *pdwDownloadBytesPerSecond)
{
    LOG_block("DownloadFile()");
    DWORD dwErr, dwFileSize, dwLength;
    DWORD dwBytesRead, dwBytesWritten;
	DWORD dwCount1, dwCount2, dwElapsedTime;
    SYSTEMTIME st;
    FILETIME ft;
    HANDLE hTargetFile;

	LOG_out("Downloading file URL %s", pszUrl);
	
	if (pdwDownloadBytesPerSecond)
		*pdwDownloadBytesPerSecond = 0; // might be used as an error message in DoSelfUpdate
		
    dwErr = OpenHttpConnection(pszUrl, FALSE);
    if (ERROR_SUCCESS != dwErr)
    {
        LOG_error("OpenHttpConnection Failed, Error %d", dwErr);
        SetLastError(dwErr);
        return dwErr;
    }
 
    // Now Get The System Time information from the Server
    dwLength = sizeof(st);
    if (! g_stateA.fpnHttpQueryInfo(g_stateA.hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
        (LPVOID)&st, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        LOG_error("HttpQueryInfo Failed, Error %d", dwErr);
        g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
        g_stateA.hOpenRequest = NULL;
        return dwErr;
    }

    SystemTimeToFileTime(&st, &ft);
    
    // Now Get the FileSize information from the Server
    dwLength = sizeof(dwFileSize);
    if (! g_stateA.fpnHttpQueryInfo(g_stateA.hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
        (LPVOID)&dwFileSize, &dwLength, NULL) )
    {
        dwErr = GetLastError();
        LOG_error("HttpQueryInfo Failed, Error %d", dwErr);
        g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
        g_stateA.hOpenRequest = NULL;
        return dwErr;
    }

    // Determine if we need to download the Server File
    if (IsServerFileNewer(ft, dwFileSize, pszDestinationFile))
    {
		dwErr = OpenHttpConnection(pszUrl, TRUE);
		if (ERROR_SUCCESS != dwErr)
		{
			LOG_error("OpenHttpConnection Failed, Error %d", dwErr);
			SetLastError(dwErr);
			return dwErr;
		}
#define DOWNLOAD_BUFFER_LENGTH 32 * 1024

        PBYTE lpBuffer = (PBYTE) GlobalAlloc(GMEM_ZEROINIT, DOWNLOAD_BUFFER_LENGTH);
        if (NULL == lpBuffer)
        {
            dwErr = GetLastError();
            LOG_error("GlobalAlloc Failed to Alloc Buffer for FileDownload, Error %d", dwErr);
            g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
            g_stateA.hOpenRequest = NULL;
            return dwErr;
        }

        hTargetFile = CreateFileA(pszDestinationFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hTargetFile)
        {
            dwErr = GetLastError();
            LOG_error("Unable to Open Target File %s for Write, Error %d", pszDestinationFile, dwErr);
            SafeGlobalFree(lpBuffer);
            g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
            g_stateA.hOpenRequest = NULL;
            return dwErr;
        }

        // Download the File
		dwCount1 = GetTickCount();
        while (g_stateA.fpnInternetReadFile(g_stateA.hOpenRequest, lpBuffer, DOWNLOAD_BUFFER_LENGTH, &dwBytesRead))
        {
			if (dwBytesRead == 0)
			{

				// window95 with IE4.01 with finish reading with successful return value but set last error to 126
				if (ERROR_SUCCESS != (dwErr=GetLastError()))
					{
						LOG_error("Error %d setted when finishing InternetReadFile",dwErr);
						SetLastError(0);
					}
				break; // done reading.
			}
            if (!WriteFile(hTargetFile, lpBuffer, dwBytesRead, &dwBytesWritten, NULL))
            {
                dwErr = GetLastError();
                LOG_error("Unable to Write to Target File %s, Error %d", pszDestinationFile, dwErr);
                SafeGlobalFree(lpBuffer);
                g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
                g_stateA.hOpenRequest = NULL;
                return dwErr;
            }
        }
		dwCount2 = GetTickCount();
		dwElapsedTime = dwCount2 - dwCount1;
		dwElapsedTime /= 1000; // number of seconds elapsed
		if (0 == dwElapsedTime)
			dwElapsedTime = 1; // at least one second.

		if (NULL != pdwDownloadBytesPerSecond)
		{
			*pdwDownloadBytesPerSecond = dwFileSize / dwElapsedTime; // number of bytes per second
		}

        dwErr = GetLastError();
        if (ERROR_SUCCESS != dwErr)
        {
            LOG_error("InternetReadFile Failed, Error %d", dwErr);
            SafeGlobalFree(lpBuffer);
            g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
            g_stateA.hOpenRequest = NULL;
            return dwErr;
        }

        // Make one final call to InternetReadFile to commit the file to Cache (downloaded is not complete otherwise)
        BYTE bTemp[32];
        g_stateA.fpnInternetReadFile(g_stateA.hOpenRequest, &bTemp, 32, &dwBytesRead);

		SafeCloseHandle(hTargetFile);
		SafeGlobalFree(lpBuffer);

		// check for CheckTrust requested
		if (fCheckTrust)
		{
			HRESULT hr = S_OK;
			// change to verifyFile() by ROGERJ at Sept. 25th, 2000
			// 2nd parameter set to false to prevent UI from poping up when a bad cert is found
			// change to TRUE for testing purpose on October 12th, 2000

			// add unattended mode at October 17th, 2000
			// if we are in unattended mode, then we do want to pop up an UI
			if (FAILED(hr = VerifyFile(pszDestinationFile, !g_stateA.fUnattended)))
			{
				// On failure of CERT.. fail download.
				LOG_error("CabFile %s does not have a valid Signature", pszDestinationFile);
				
				g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
    			g_stateA.hOpenRequest = NULL;

				return HRESULT_CODE(hr);
			}
		}

		if (fDecompress)
		{
			char szLocalDir[MAX_PATH];
			lstrcpy(szLocalDir, pszDestinationFile);
			g_stateA.fpnPathRemoveFileSpec(szLocalDir);
			fdi(const_cast<char *>(pszDestinationFile), szLocalDir);
		}
    }

    // Always close the Request when the file is finished.
    // We intentionally leave the connection to the server Open though, seems more
    // efficient when requesting multiple files from the same server.
    g_stateA.fpnInternetCloseHandle(g_stateA.hOpenRequest);
    g_stateA.hOpenRequest = NULL;
    return ERROR_SUCCESS;
}

BOOL IsServerFileNewer(FILETIME ftServerTime, DWORD dwServerFileSize, LPCSTR pszLocalFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
	FILETIME ftCreateTime;
	LONG lTime;
	DWORD dwLocalFileSize;

    hFile = CreateFile(pszLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		dwLocalFileSize = GetFileSize(hFile, NULL);
		if (dwLocalFileSize != dwServerFileSize)
		{
			SafeCloseHandle(hFile);
			return TRUE; // server and local files do not match, download server file.
		}

		if (GetFileTime(hFile, &ftCreateTime, NULL, NULL))
		{
			lTime = CompareFileTime(&ftCreateTime, &ftServerTime);
			if (lTime < 0)
			{
				SafeCloseHandle(hFile);
				return TRUE; // local file is 'older' than the server file
			}
			else
			{
				SafeCloseHandle(hFile);
				return FALSE; // local file is either equal or newer, leave it.
			}
		}
	}
	// if we couldn't find the file, or we couldn't get the time, assume the server file is newer
	SafeCloseHandle(hFile);
    return TRUE;
}

LPSTR DuUrlCombine(LPSTR pszDest, LPCSTR pszBase, LPCSTR pszAdd)
{
    if ((NULL == pszDest) || (NULL == pszBase) || (NULL == pszAdd))
    {
        return NULL;
    }

    lstrcpy(pszDest, pszBase);
	int iLen = lstrlen(pszDest);
    if ('/' == pszDest[iLen - 1])
    {
        // already has a trailing slash, check the 'add' string for a preceding slash
        if ('/' == *pszAdd)
        {
            // has a preceding slash, skip it.
            lstrcat(pszDest, pszAdd + 1);
        }
        else
        {
            lstrcat(pszDest, pszAdd);
        }
    }
    else
    {
        // no trailing slash, check the add string for a preceding slash
        if ('/' == *pszAdd)
        {
            // has a preceding slash, Add Normally
            lstrcat(pszDest, pszAdd);
        }
        else
        {
            lstrcat(pszDest, "/");
            lstrcat(pszDest, pszAdd);
        }
    }
    return pszDest;
}


// RogerJ, October 2nd, 2000

// ---------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversA
// Function Description: Called by Win9x setup to get the size of total download
// 		instead of DuDoDetection()
// Function Returns: BOOL
//		TRUE if succeed
//		FALSE if failed, call GetLastError() to get error information
//
BOOL WINAPI DuQueryUnsupportedDriversA( IN HANDLE hConnection, // connection handle
										IN PCSTR* ppszListOfDriversNotOnCD, // list of drivers not on setup CD
										OUT PDWORD pdwTotalEstimateTime, // estimate download time
										OUT PDWORD pdwTotalEstimateSize // estimate size
									  )
{
    LOG_block("DuQueryUnsupportedDriversA()");
    // param validation
    if (INVALID_HANDLE_VALUE == hConnection || 
    	NULL == pdwTotalEstimateTime || 
    	NULL == pdwTotalEstimateSize)
    {
        LOG_error("Invalid Parameter passed to DuDoDetection");
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

	// clear any error set by other program
	SetLastError(0);

	PCSTR* ppTemp = NULL;
	
	// passing in NULL for PLIST means that no driver download is needed
	if (!ppszListOfDriversNotOnCD  // NULL pointer
	    || !(*ppszListOfDriversNotOnCD) // pointer to a NULL
	    || !(**ppszListOfDriversNotOnCD)) // pointer to an empty string
		LOG_out("No driver download is needed");
	else
		ppTemp = ppszListOfDriversNotOnCD;

    if (NULL == g_hwsdueng)
    {
        // DuDoDetection was called without calling DuInitialize, our state is invalid
        LOG_error("Initialization Invalid, Engine is not Initialized");
        SetLastError(DU_NOT_INITIALIZED);
        return FALSE;
    }

    PFN_DuQueryUnsupportedDrivers fpnDuQueryUnsupportedDrivers = 
    	(PFN_DuQueryUnsupportedDrivers) GetProcAddress(g_hwsdueng, "DuQueryUnsupportedDriversA");
    	
    if (NULL == fpnDuQueryUnsupportedDrivers)
    {
        LOG_error("Unable to find DuQueryUnsupporedDrivers entrypoint in wsdueng.dll, Critical Error");
        SetLastError(DU_ERROR_MISSING_DLL);
        return FALSE;
    }

    return fpnDuQueryUnsupportedDrivers(hConnection, ppTemp, pdwTotalEstimateTime, pdwTotalEstimateSize);

}


// ---------------------------------------------------------------------------
// Function Name: DuQueryUnsupportedDriversW
// Function Description: Could be called by WinNT setup to get the size of total download
// 		instead of DuDoDetection()
// Function Returns: BOOL
//		TRUE if succeed
//		FALSE if failed, call GetLastError() to get error information
//
BOOL WINAPI DuQueryUnsupportedDriversW( IN HANDLE hConnection, // connection handle
										IN PCWSTR* ppwszListOfDriversNotOnCD, // list of drivers not on setup CD
										OUT PDWORD pdwTotalEstimateTime, // estimate download time
										OUT PDWORD pdwTotalEstimateSize // estimate size
									  )
{
	// this function will only convert every string in ppwszListOfDriversNotOnCD to ANSI and call the ANSI version
	LOG_block("DuQueryUnsupportedDriversW");

	BOOL fRetValue = TRUE;
	LPSTR* ppszTempList = NULL;

	if (ppwszListOfDriversNotOnCD   // NULL pointer
		&& *ppwszListOfDriversNotOnCD  // pointer points to a NULL value
		&& **ppwszListOfDriversNotOnCD) // pointer points to an empty string
	{
	
		// get the count of the strings in the ppwszListOfDriversNotOnCD array
		PWSTR* ppwszTemp = const_cast<PWSTR*>(ppwszListOfDriversNotOnCD);
		int nCount = 0;

		while (*ppwszTemp)
		{
			ppwszTemp++;
			nCount++;
		}

		ppszTempList = (LPSTR*) new LPSTR [nCount+1];
		
		if (!ppszTempList)
		{
			LOG_error("Out of memory");
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}
		
		ZeroMemory(ppszTempList, (nCount+1)*sizeof(LPSTR));
		
		// reset ppwszTemp to the beginning of the list
		ppwszTemp = const_cast<PWSTR*>(ppwszListOfDriversNotOnCD);
	
		for (int i=0; i<nCount; i++, ppwszTemp++)
		{
			// the ppwszListOfDriversNotOnCD is an array of multi-sz list, we CAN NOT use lstrlenW to 
			// determine the length
			int nSizeSZ = 0;
			wchar_t* pwszTemp = *ppwszTemp;
			while (*pwszTemp)
			{
				int nTempLength = lstrlenW(pwszTemp)+1;
				nSizeSZ += nTempLength;
				pwszTemp += nTempLength;
			}
			nSizeSZ ++; // for trailing NULL

			char* pszTempContent = new char [nSizeSZ];
			if (!pszTempContent)
			{
				LOG_error("Out of memory");
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				fRetValue = FALSE;
				goto CleanUp;
			}
		
			// convert
			if ( 0 == WideCharToMultiByte( CP_ACP, // code page
							 0, // use default flags
							 *ppwszTemp, // wide char string
							 nSizeSZ, // number of characters in wide char string
							 pszTempContent, // ANSI char string
							 nSizeSZ, // length
							 NULL,
							 NULL))
		
			{
				LOG_error("Wide char to ANSI convertion error");
				fRetValue = FALSE;
				goto CleanUp;
			}
	
			// add converted string to list
			ppszTempList[i] = pszTempContent;
		}
	}
	// call ANSI function
	fRetValue = DuQueryUnsupportedDriversA (hConnection,
											(LPCSTR*)ppszTempList,
											pdwTotalEstimateTime,
											pdwTotalEstimateSize);

	// clean up
CleanUp:

	// delete the list
	if (ppszTempList)
	{
		PSTR* ppszCleanUp = ppszTempList;
		while (*ppszCleanUp)
		{
			// delete content
			char* pszTemp = *ppszCleanUp;
			delete [] pszTemp;
			*ppszCleanUp = NULL;

			// move to next one
			ppszCleanUp++;
		}

		delete [] ppszTempList;
	}
	return fRetValue;
							 
}
									  


BOOL MyGetFileVersion (LPSTR szFileName, VS_FIXEDFILEINFO& vsVersion)
{
	LOG_block("WsDu --- GetFileVersion");
	
	DWORD dwDummy = 0;	
	WIN32_FIND_DATA  findData;
	int nSize = 0;
	PBYTE pBuffer = NULL;
	BOOL fRetValue = FALSE;
	VS_FIXEDFILEINFO* pTemp = NULL;

	if (!szFileName || !*szFileName) return FALSE;

    LOG_out("FileName = %s", szFileName);

	// clear the version to 0
	ZeroMemory ((PVOID)&vsVersion, sizeof(VS_FIXEDFILEINFO));

	// Try to find the file first
	HANDLE hFile = FindFirstFile (szFileName, &findData);

	if (INVALID_HANDLE_VALUE == hFile)
	{
		LOG_error("Could not find file %s", szFileName);
		goto ErrorReturn;
	}
	else
		FindClose(hFile);

	// get the file version
	// 1. get the buffer size we need to allocate
	if (!(nSize= GetFileVersionInfoSize (szFileName, &dwDummy)))
	{
		LOG_error("Can not get the file version info size --- %d", GetLastError());
		goto ErrorReturn;
	}

	// 2. allocate the buffer
	pBuffer = (PBYTE) new BYTE [nSize];
	if (!pBuffer)
	{
		LOG_error("Out of memory");
		goto ErrorReturn;
	}

	// 3. get file version info
	if (!GetFileVersionInfo(szFileName, 
						0, // ignored
						nSize, // size
						(PVOID) pBuffer)) // buffer
	{
		LOG_error("Can not get file version --- %d", GetLastError());
		goto ErrorReturn;
	}

	// 4. get the version number
	if (!VerQueryValue( (PVOID) pBuffer, "\\", (LPVOID *)&pTemp, (PUINT) &dwDummy))
	{
		LOG_error("File version info not exist");
		goto ErrorReturn;
	}

	vsVersion.dwFileVersionMS = pTemp->dwFileVersionMS;
	vsVersion.dwFileVersionLS = pTemp->dwFileVersionLS;
	vsVersion.dwProductVersionMS = pTemp->dwProductVersionMS;
	vsVersion.dwProductVersionLS = pTemp->dwProductVersionLS;

	LOG_out("File version for %s is %d.%d.%d.%d", szFileName, 
	    HIWORD(vsVersion.dwFileVersionMS), LOWORD(vsVersion.dwFileVersionMS), 
	    HIWORD(vsVersion.dwFileVersionLS), LOWORD(vsVersion.dwFileVersionLS));
	
	fRetValue = TRUE;
	
ErrorReturn:
	if (pBuffer) delete [] pBuffer;
	return fRetValue;
}
	

int CompareFileVersion(VS_FIXEDFILEINFO& vs1, VS_FIXEDFILEINFO& vs2)
{
	if (vs1.dwFileVersionMS > vs2.dwFileVersionMS)
		return 1;
	else if (vs1.dwFileVersionMS == vs2.dwFileVersionMS)
	{
		if (vs1.dwFileVersionLS > vs2.dwFileVersionLS)
			return 1;
		else if (vs1.dwFileVersionLS == vs2.dwFileVersionLS)
			return 0;
		else return -1;
	}
	else return -1;
		
}
	
	    
BOOL NeedRetry(DWORD dwErrCode)
{
    BOOL bRetry = FALSE;
    bRetry =   ((dwErrCode == ERROR_INTERNET_CONNECTION_RESET)      //most common
             || (dwErrCode == HTTP_STATUS_NOT_FOUND)                //404
			 || (dwErrCode == ERROR_HTTP_HEADER_NOT_FOUND)			//seen sometimes
             || (dwErrCode == ERROR_INTERNET_OPERATION_CANCELLED)   //dont know if..
             || (dwErrCode == ERROR_INTERNET_ITEM_NOT_FOUND)        //..these occur..
             || (dwErrCode == ERROR_INTERNET_OUT_OF_HANDLES)        //..but seem most..
             || (dwErrCode == ERROR_INTERNET_TIMEOUT));             //..likely bet
    return bRetry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\log.cpp ===
#include "wsdueng.h"

#define REGKEY_WUV3TEST     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test"

FILE* CLogger::c_pfile = stdout;
int CLogger::c_cnIndent = 0;
int CLogger::c_cnLevels = -1;

CLogger::CLogger(
    const char* szBlockName /*= 0*/, 
    int nLoggingLevel/*= 0*/, 
    const char* szFileName/*= 0*/, 
    int nLine/*= 0*/
) 
{
    if (-1 == c_cnLevels)
    {
        /*c_cnLevels = 0;
        HKEY hkey;
        if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) 
        {
            DWORD dwSize = sizeof(c_cnLevels);
            RegQueryValueEx(hkey, "LogLevel", 0, 0, (LPBYTE)&c_cnLevels, &dwSize);
            char szLogFile[MAX_PATH] = {0};
            dwSize = sizeof(szLogFile);
            RegQueryValueEx(hkey, "LogFile", 0, 0, (LPBYTE)&szLogFile, &dwSize);
            FILE* pfile = fopen(szLogFile, "at");
            if (pfile)
            {
                c_pfile = pfile;
            }
            RegCloseKey(hkey);
        }*/
        char sz_LogFileName[MAX_PATH];
        c_cnLevels = 4; // default to log level 4
        ExpandEnvironmentStrings(cszLoggingFile, sz_LogFileName, MAX_PATH);
        FILE* pfile = fopen(sz_LogFileName, "at");
        if (pfile)
        {
        	c_pfile = pfile;
        }
    }
    m_szBlockName[0] = 0;
    //m_fOut = nLoggingLevel < c_cnLevels;
    m_fOut = TRUE;
    if (m_fOut && NULL != szBlockName) 
    {
        lstrcpyn(m_szBlockName, szBlockName, sizeOfArray(m_szBlockName));
        //out("%s %s(%d)", szBlockName, szFileName, nLine);
        out("%s", szBlockName);
        m_dwStartTick = GetTickCount();
        c_cnIndent ++;
    }
}

CLogger::~CLogger()
{
    if (c_pfile && m_fOut && NULL != m_szBlockName[0]) 
    {
        c_cnIndent --;
        out("~%s (%d msecs)", m_szBlockName, GetTickCount() - m_dwStartTick);
    }
}

void __cdecl CLogger::out(const char *szFormat, ...)
{
    if (m_fOut) 
    {
        va_list va;
        va_start (va, szFormat);
        v_out(szFormat, va);
        va_end (va);
    }
}

void __cdecl CLogger::error(const char *szFormat, ...)
{
    if (m_fOut) 
    {
        va_list va;
        va_start (va, szFormat);
        char szOut[4 * 1024];
        wvsprintf(szOut, szFormat, va);
        va_end (va);
        out("ERROR - %s", szOut);
    }
}

void __cdecl CLogger::out1(const char *szFormat, ...)
{
    CLogger logger;
    va_list va;
    va_start (va, szFormat);
    logger.v_out(szFormat, va);
    va_end (va);
}

void CLogger::v_out( const char* szFormat, va_list va)
{
    char szOut[5 * 1024];
    char* pszOut = szOut;
    // Indent first
    for(int i = 0; i < c_cnIndent; i ++)
        *(pszOut ++) = '\t';
    wvsprintf(pszOut, szFormat, va);
    // move the file pointer to the end
    if (0 == fseek(c_pfile, 0, SEEK_END))
    {
        fprintf(c_pfile, "%s\n", szOut);
        fflush(c_pfile);
    }
}

void CLogger::close(void)
{
	if (c_pfile) fclose(c_pfile);
	c_pfile = NULL;
	c_cnLevels = -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\v3server.h ===
// ----------------------------------------------------------------------------------
// V3.1 Backend Server Apis
//
//
class CDynamicUpdate; // forward declare the CDynamicUpdate class defined in wsdueng.h

#define CATALOGINIFN "catalog.ini"
#define GUIDRVINF "guidrvs.inf"

typedef enum 
{
    enWhistlerConsumer          = 90934, // VER_SUITE_PERSONAL
    enWhistlerProfessional      = 90935, // 0
    enWhistlerServer            = 90936, // VER_SUITE_SMALLBUSINESS
    enWhistlerAdvancedServer    = 90937, // VER_SUITE_ENTERPRISE
    enWhistlerDataCenter        = 90938, // VER_SUITE_DATACENTER
} enumPlatformSKUs;

class CV31Server
{
public:
    CV31Server(CDynamicUpdate *pDu);
    ~CV31Server();

public:
    BOOL ReadIdentInfo(void);
    BOOL ReadCatalogINI(void);
    BOOL ReadGuidrvINF(void);
    BOOL GetCatalogPUIDs(void);
    BOOL GetCatalogs(void);
    BOOL UpdateDownloadItemList(OSVERSIONINFOEX& VersionInfo);
	void FreeCatalogs(void);
	BOOL MakeDependentList(OSVERSIONINFOEX& VersionInfo, CCRCMapFile *pMapFile);
	BOOL IsDependencyApply(PUID puid);
	BOOL GetBitMask(LPSTR szBitmapServerFileName, PUID nDirectoryPuid, PBYTE* pByte, LPSTR szDecompressedName);
	BOOL IsPUIDExcluded(PUID nPuid);
	BOOL IsDriverExcluded(LPCSTR szWHQLId, LPCSTR szHardwareId);
	BOOL GetAltName(LPCSTR szCabName, LPSTR szAltName, int nSize);

public:
    // Catalog Parsing Functions
    PBYTE GetNextRecord(PBYTE pRecord, int iBitmaskIndex, PINVENTORY_ITEM pItem);
    int GetRecordType(PINVENTORY_ITEM pItem);
    BOOL ReadDescription(PINVENTORY_ITEM pItem, CCRCMapFile *pMapFile);

public:
    PUID                m_puidConsumerCatalog;
    PUID                m_puidSetupCatalog;
    DWORD               m_dwPlatformID;
    enumPlatformSKUs    m_enumPlatformSKU;
    LCID                m_lcidLocaleID;

    DWORD                   m_dwConsumerItemCount;
   	Varray<PINVENTORY_ITEM>	m_pConsumerItems;		//array of consumer catalog items
	PBYTE                   m_pConsumerCatalog;     //in memory view of the Consumer Catalog.
    DWORD                   m_dwSetupItemCount;
    Varray<PINVENTORY_ITEM> m_pSetupItems;          //array of setup catalog items
	PBYTE					m_pSetupCatalog;        //in memory view of the setup catalog
    DWORD                   m_dwGlobalExclusionItemCount;
    Varray<PUID>            m_GlobalExclusionArray; //array of PUID's that are excluded
    PUID*					m_pValidDependentPUIDArray; // array of PUIDs that is valid for dependent item on this version
    int 					m_nNumOfValidDependentPUID;
    PBYTE					m_pBitMaskAS;			// bitmask for Setup 	
    PBYTE 					m_pBitMaskCDM;			// bitmask for Driver

    CDynamicUpdate *m_pDu;
    
    BOOL					m_fHasDriver;
    LPSTR					m_pszExcludedDriver;

    // Server Ident Paths
    char m_szCabPoolUrl[INTERNET_MAX_URL_LENGTH + 1];
    char m_szV31ContentUrl[INTERNET_MAX_URL_LENGTH + 1];
    char m_szV31RootUrl[INTERNET_MAX_URL_LENGTH + 1];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\v3server.cpp ===
#include "wsdueng.h"

#define IDENT_SECTION_CABPOOL "cabpools"
#define IDENT_SECTION_CONTENT31 "content31"
#define IDENT_KEYNAME_DEFAULT "default"
#define IDENT_KEYNAME_ROOT    "root"

CV31Server::CV31Server(CDynamicUpdate *pDu) : m_puidConsumerCatalog(0),
                            m_puidSetupCatalog(0),
                            m_dwPlatformID(0),
                            m_lcidLocaleID(0),
                            m_dwConsumerItemCount(0),
							m_pConsumerCatalog(NULL),
                            m_dwSetupItemCount(0),
							m_pSetupCatalog(NULL),
                            m_dwGlobalExclusionItemCount(0),
                            m_pDu(pDu)
{
	// set the initial state
	m_dwPlatformID = (DWORD)m_pDu->m_iPlatformID;
	m_lcidLocaleID = m_pDu->m_lcidLocaleID;
	
	if (0 == m_pDu->m_wPlatformSKU) // Professional
	{
		m_enumPlatformSKU = enWhistlerProfessional;
	}
	else if (m_pDu->m_wPlatformSKU & VER_SUITE_DATACENTER) // DataCenter
	{
		m_enumPlatformSKU = enWhistlerDataCenter;
	}
	else if (m_pDu->m_wPlatformSKU & VER_SUITE_PERSONAL) // Personal
	{
		m_enumPlatformSKU = enWhistlerConsumer;
	}
    else if (m_pDu->m_wPlatformSKU & VER_SUITE_ENTERPRISE) // Advanced Server
	{
		m_enumPlatformSKU = enWhistlerAdvancedServer;
	}
	else if (m_pDu->m_wPlatformSKU & VER_SUITE_SMALLBUSINESS) // Server
	{
		m_enumPlatformSKU = enWhistlerServer;
	}

	// RogerJ October 25th, 2000
	m_pValidDependentPUIDArray = NULL;
	m_nNumOfValidDependentPUID = 0;
	m_pBitMaskAS = m_pBitMaskCDM = NULL;
	m_fHasDriver = FALSE;
	m_pszExcludedDriver = NULL;

}

CV31Server::~CV31Server()
{
	FreeCatalogs(); // clears the m_pConsumerItems and m_pSetupItems Varrays.

	SafeGlobalFree(m_pConsumerCatalog);
	SafeGlobalFree(m_pSetupCatalog);

	// RogerJ, October 25th, 2000
	SafeGlobalFree(m_pValidDependentPUIDArray);
	SafeGlobalFree(m_pBitMaskAS);
	SafeGlobalFree(m_pBitMaskCDM);
	SafeGlobalFree(m_pszExcludedDriver);
}

// ----------------------------------------------------------------------------------
// V3.1 Backend Server Apis
//
//
BOOL CV31Server::ReadIdentInfo()
{
    // ident.cab should already be downloaded at this point. Get the path to it and read the fields we care about
    char szIdent[MAX_PATH];
    char szValueName[32];
    int iServerNumber;
    char szUrl[INTERNET_MAX_URL_LENGTH + 1];

    PathCombine(szIdent, m_pDu->GetDuTempPath(), "ident.txt");

    // --------------------
    // Get the CABPOOL URL
    // --------------------
    iServerNumber = GetPrivateProfileInt(IDENT_SECTION_CABPOOL, IDENT_KEYNAME_DEFAULT, 1, szIdent);
    wsprintf(szValueName, "Server%d", iServerNumber);

    GetPrivateProfileString(IDENT_SECTION_CABPOOL, szValueName, "", szUrl, sizeof(szUrl), szIdent);
    if ('\0' == szUrl[0])
    {
        // No Server Value was found in the ident. Cannot continue;
		SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }

	// The cabpool URL is the string in the Ident + 'cabpool'
	m_pDu->DuUrlCombine(m_szCabPoolUrl, szUrl, "CabPool");

    // --------------------
    // Get the CONTENT URL
    // --------------------
    iServerNumber = GetPrivateProfileInt(IDENT_SECTION_CONTENT31, IDENT_KEYNAME_DEFAULT, 1, szIdent);
    wsprintf(szValueName, "Server%d", iServerNumber);

    GetPrivateProfileString(IDENT_SECTION_CONTENT31, szValueName, "", szUrl, sizeof(szUrl), szIdent);
    if ('\0' == szUrl[0])
    {
        // No Server Value
		SetLastError(ERROR_FILE_NOT_FOUND);
		return FALSE;
    }

    lstrcpy(m_szV31ContentUrl, szUrl);

    // -------------------------
    // Get the CONTENT ROOT URL
    // -------------------------
    iServerNumber = GetPrivateProfileInt(IDENT_SECTION_CONTENT31, IDENT_KEYNAME_ROOT, 2, szIdent);
    wsprintf(szValueName, "Server%d", iServerNumber);

    GetPrivateProfileString(IDENT_SECTION_CONTENT31, szValueName, "", szUrl, sizeof(szUrl), szIdent);
    if ('\0' == szUrl[0])
    {
        // No Root Server Value
		SetLastError(ERROR_FILE_NOT_FOUND);
		return FALSE;
    }

    lstrcpy(m_szV31RootUrl, szUrl);

    return TRUE;
}

BOOL CV31Server::ReadCatalogINI()
{
	LOG_block("CV31Server::ReadCatalogINI()");
    char szServerFile[INTERNET_MAX_URL_LENGTH + 1];
    char szLocalFile[MAX_PATH];
    char szValue[1024];

    // Now read the Catalog.ini file to find out if any of these items needs to be turned off
    m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, CATALOGINIFN);
    PathCombineA(szLocalFile, m_pDu->GetDuTempPath(), CATALOGINIFN);
    if (ERROR_SUCCESS != m_pDu->DownloadFile(szServerFile, szLocalFile, FALSE, FALSE))
    {
        LOG_out("No catalog.ini found");
        return TRUE;
    }
    

    if (0 != (GetPrivateProfileStringA("exclude", "puids", "", szValue, sizeof(szValue), szLocalFile)))
    {
        LPCSTR pszNext = szValue;
        char szPuid[128];
        while (NULL != pszNext)
        {
            pszNext = strcpystr(pszNext, ",", szPuid);
            if ('\0' != szPuid[0])
            {
                m_GlobalExclusionArray[m_dwGlobalExclusionItemCount] = StrToIntA(szPuid);
                LOG_out("Excluded puid --- %d", m_GlobalExclusionArray[m_dwGlobalExclusionItemCount]);
                m_dwGlobalExclusionItemCount++;
            }
        }
    }
    else
    	LOG_out("No Excluded puid");
    return TRUE;
}


BOOL CV31Server::GetCatalogPUIDs()
{
	LOG_block("CV31Server::GetCatalogPUIDs()");
    // There are two v3 catalogs that we will be looking for the PUID's for.. 
    // One is the Consumer Catalog for the target platform
    // The other is the Setup Catalog for the target platform
    char szServerFile[INTERNET_MAX_URL_LENGTH];
    PBYTE pCatalogList = NULL;
    PBYTE pInventoryList = NULL;
    PBYTE pWalkList = NULL;
    DWORD dwLength;
    m_puidConsumerCatalog = 0;
    m_puidSetupCatalog = 0;

    // Download the Catalog Inventory List
    m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, "inventory.plt");
    m_pDu->DownloadFileToMem(szServerFile, &pInventoryList, &dwLength, TRUE, "inventory.plt", NULL);

    if (NULL == pInventoryList)
    {
        // error out of memory
        return FALSE;
    }

    // Download the CatalogList
    m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, "inventory.cat");
    m_pDu->DownloadFileToMem(szServerFile, &pCatalogList, &dwLength, TRUE, "inventory.cat", NULL);

    if (NULL == pCatalogList)
    {
        // error out of memory
        SafeGlobalFree(pInventoryList);
        return FALSE;
    }

    // Now Parse the Inventory List to Find out how many catalogs there are.
    int i;
    WU_CATALOG_HEADER hdr;

    memcpy(&hdr, pInventoryList, sizeof(hdr));

    pWalkList = pCatalogList;
    CATALOGLIST catListElem;
    for (i = 0; i < hdr.totalItems; i++)
    {
        memcpy(&catListElem, pWalkList, sizeof(catListElem));
        
        if (catListElem.dwPlatform == m_dwPlatformID)
        {
			// standard catalog is 0, thus, standard catalog with driver will have same value as driver only
            if ((CATLIST_DRIVERSPRESENT == catListElem.dwFlags) || (catListElem.dwFlags == (CATLIST_DRIVERSPRESENT | CATLIST_64BIT)))
            {
                // consumer catalog for this platform
                m_puidConsumerCatalog = catListElem.dwCatPuid;
            }
            else if (catListElem.dwFlags & CATLIST_SETUP)
            {
                // setup catalog for this platform
                m_puidSetupCatalog = catListElem.dwCatPuid;
                if (0 == m_puidConsumerCatalog && (catListElem.dwFlags & CATLIST_DRIVERSPRESENT))
                	m_puidConsumerCatalog = catListElem.dwCatPuid;
            }
        }
        pWalkList += sizeof(catListElem);
    }
	if (!m_puidConsumerCatalog && ! m_puidSetupCatalog)
	{
		SetLastError(ERROR_INTERNET_NO_CONTEXT);
		SafeGlobalFree(pInventoryList);
		SafeGlobalFree(pCatalogList);
		return FALSE; // this technically is an error.. wrong server was pointed to? Catalogs weren't on the server
	}
	
	SafeGlobalFree(pInventoryList);
	SafeGlobalFree(pCatalogList);

	LOG_out("Consumer catalog %d, Setup catalog %d", m_puidConsumerCatalog, m_puidSetupCatalog);
    return TRUE;
}

BOOL CV31Server::GetCatalogs()
{
    // This will download the two Catalogs (Setup and Consumer) and the InventoryItem Arrays
    LOG_block("CV31Server::GetCatalogs()");
    DWORD dwRet;
    int i;
    char szServerFile[INTERNET_MAX_URL_LENGTH];
    char szLocalFile[MAX_PATH];
    char szCatalog[MAX_PATH];
    char szInvCRC[64];
    char szBmCRC[64];
    char szLocale[32];
    PBYTE pWalkCatalog = NULL;
    WU_CATALOG_HEADER hdr;
    PINVENTORY_ITEM pItem;
    BOOL fDriversAvailable = FALSE;
    DWORD dwLength;

    wsprintf(szLocale, "0x%8.8x", m_lcidLocaleID);

	FreeCatalogs(); // free any previously allocated catalog lists
	SafeGlobalFree(m_pValidDependentPUIDArray); // free any previously determined dependency list
	m_pValidDependentPUIDArray = NULL;
	m_nNumOfValidDependentPUID = 0;

    // Read the Catalog.INI to get a list of Globally Excluded Items

    if (0 != m_puidConsumerCatalog)
    {
        // Download the Consumer Catalog for this Platform
        // first we need to download the redirect file to get the CRC value of the catalog
        wsprintf(szCatalog, "%d/%s.as", m_puidConsumerCatalog, szLocale);
        m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, szCatalog);
        wsprintf(szCatalog, "%d_%s.as", m_puidConsumerCatalog, szLocale);
        PathCombine(szLocalFile, m_pDu->GetDuTempPath(), szCatalog);
        m_pDu->DownloadFile(szServerFile, szLocalFile, TRUE, FALSE);

        if (GetPrivateProfileString("redir", "invCRC", "", szInvCRC, sizeof(szInvCRC), szLocalFile) == 0)
        {
            LOG_error("Unable to Read Inventory CRC value from Consumer Catalog");
            return FALSE;
        }

		// does not need this for consumer catalog
        /*if (GetPrivateProfileString("redir", "bmCRC", "", szBmCRC, sizeof(szBmCRC), szLocalFile) == 0)
        {
            LOG_error("Unable to Read Bitmask CRC value for Consumer Catalog");
            return FALSE;
        }*/

		
        if (!GetBitMask("bitmask.cdm", m_puidConsumerCatalog, &m_pBitMaskCDM, "bitmask.cdm"))
        {
        	LOG_error("Unable to get bitmask for CDM");
        	return FALSE;
        }

        // now download the real catalog
        wsprintf(szCatalog, "%d/%s.inv", m_puidConsumerCatalog, szInvCRC);
        m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, szCatalog);
        SafeGlobalFree(m_pConsumerCatalog);
		wsprintf(szCatalog, "%s.inv", szInvCRC);
        m_pDu->DownloadFileToMem(szServerFile, &m_pConsumerCatalog, &dwLength, TRUE, szCatalog, "inventory.as");
        if (NULL == m_pConsumerCatalog)
        {
            LOG_error("Failed to download Consumer Catalog, %d", m_puidConsumerCatalog);
            return FALSE;
        }

        pWalkCatalog = m_pConsumerCatalog;

        // Read the Catalog Header
        ZeroMemory(&hdr, sizeof(hdr));
        memcpy(&hdr, pWalkCatalog, sizeof(hdr));

        m_pConsumerItems[hdr.totalItems] = NULL; // just to preinitialize the array.

        pWalkCatalog += sizeof(hdr);

        // walk the list and read the items.
        for (i = 0; i < hdr.totalItems; i++)
        {
            pItem = (PINVENTORY_ITEM) GlobalAlloc(GMEM_ZEROINIT, sizeof(INVENTORY_ITEM));
            if (NULL == pItem)
            {
                dwRet = GetLastError();
                LOG_error("Failed to Alloc Memory for Inventory Item, Error %d", dwRet);
                return FALSE;
            }

            pWalkCatalog = GetNextRecord(pWalkCatalog, i, pItem);
            if (!pWalkCatalog)
           	{
           	    LOG_error("Failed to Alloc Memory for InventoryI Item State, Error %d", GetLastError());
           	    return FALSE;
           	}

            m_pConsumerItems[i] = pItem;
            if ( WU_TYPE_CDM_RECORD_PLACE_HOLDER == pItem->recordType) m_fHasDriver = TRUE;
            m_dwConsumerItemCount++;
        }
    }

    if (0 != m_puidSetupCatalog)
    {
        // Download the Setup Catalog for this Platform
        // first we need to download the redirect file to get the CRC value of the catalog
  		wsprintf(szCatalog, "%d/%s.as", m_puidSetupCatalog, szLocale);
        m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, szCatalog);
        wsprintf(szCatalog, "%d_%s.as", m_puidSetupCatalog, szLocale);
        PathCombine(szLocalFile, m_pDu->GetDuTempPath(), szCatalog);
        dwRet = m_pDu->DownloadFile(szServerFile, szLocalFile, TRUE, FALSE);

        if (ERROR_SUCCESS != dwRet)
        {
        	SetLastError(dwRet);
        	return FALSE;
        }
        
        if (GetPrivateProfileString("redir", "invCRC", "", szInvCRC, sizeof(szInvCRC), szLocalFile) == 0)
        {
            LOG_error("Unable to Read Inventory CRC value from Setup Catalog");
            return FALSE;
        }

        if (GetPrivateProfileString("redir", "bmCRC", "", szBmCRC, sizeof(szBmCRC), szLocalFile) == 0)
        {
            LOG_error("Unable to Read Bitmask CRC value for Setup Catalog");
            return FALSE;
        }

		char szBMCRCFileName[MAX_PATH];
		wsprintf(szBMCRCFileName, "%s.bm", szBmCRC);
		if (!GetBitMask(szBMCRCFileName, m_puidSetupCatalog, &m_pBitMaskAS, "bitmask.as")) 
		{
			LOG_error("Unable to Read Bitmask File for AS");
			return FALSE;
		}
		
        // now download the real catalog
        wsprintf(szCatalog, "%d/%s.inv", m_puidSetupCatalog, szInvCRC);
        m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, szCatalog);
        SafeGlobalFree(m_pSetupCatalog);
		wsprintf(szCatalog, "%s.inv", szInvCRC);
        m_pDu->DownloadFileToMem(szServerFile, &m_pSetupCatalog, &dwLength, TRUE, szCatalog, "inventory.as");
        if (NULL == m_pSetupCatalog)
        {
            LOG_error("Failed to download Consumer Catalog, %d", m_puidSetupCatalog);
            return FALSE;
        }

        pWalkCatalog = m_pSetupCatalog;

        // Read the Catalog Header
        ZeroMemory(&hdr, sizeof(hdr));
        memcpy(&hdr, pWalkCatalog, sizeof(hdr));

		m_pSetupItems[hdr.totalItems] = NULL; // just to preinitialize the array.

        pWalkCatalog += sizeof(hdr);

        // walk the list and read the items.
        for (i = 0; i < hdr.totalItems; i++)
        {
            pItem = (PINVENTORY_ITEM) GlobalAlloc(GMEM_ZEROINIT, sizeof(INVENTORY_ITEM));
            if (NULL == pItem)
            {
                dwRet = GetLastError();
                LOG_error("Failed to Alloc Memory for Inventory Item, Error %d", dwRet);
                return FALSE;
            }

            pWalkCatalog = GetNextRecord(pWalkCatalog, i, pItem);
            if (!pWalkCatalog)
           	{
           	    LOG_error("Failed to Alloc Memory for InventoryI Item State, Error %d", GetLastError());
           	    return FALSE;
           	}

			if (!pItem->ps->bHidden && !GETBIT(m_pBitMaskAS, i))
			{
				// this item is masked out
				LOG_out("Item %d is masked out", i);
				pItem->ps->bHidden = TRUE;
				pItem->ps->state = WU_ITEM_STATE_PRUNED;
				pItem->ps->dwReason = WU_STATE_REASON_BITMASK;
			}
            m_pSetupItems[i] = pItem;
            m_dwSetupItemCount++;
        }
    }


    return TRUE;
}

PBYTE CV31Server::GetNextRecord(PBYTE pRecord, int iBitmaskIndex, PINVENTORY_ITEM pItem)
{
  	//first get the fixed length part of the record
	pItem->pf = (PWU_INV_FIXED)pRecord;

	//process the variable part of the record

	pRecord = pRecord + sizeof(WU_INV_FIXED);

	pItem->pv = (PWU_VARIABLE_FIELD)pRecord;

	//since there is no state information create an empty structure
	pItem->ps = (PWU_INV_STATE)GlobalAlloc(GMEM_ZEROINIT, sizeof(WU_INV_STATE));

	if (!pItem->ps) return NULL;		

	//new item is unknown detection, not selected and shown to user.
	pItem->ps->state	= WU_ITEM_STATE_UNKNOWN;
	pItem->ps->bChecked	= FALSE;
	// RogerJ, to support versioning, we will use the bHidden flag
	pItem->ps->bHidden	= pItem->pf->a.flags & WU_HIDDEN_ITEM_FLAG;
	if (pItem->ps->bHidden) m_nNumOfValidDependentPUID++;
	
	pItem->ps->dwReason	= WU_STATE_REASON_NONE;

	//There is no description yet
	pItem->pd			= (PWU_DESCRIPTION)NULL;

	//we need to store the bitmap index (which is the sequential record index)
	//since this information will be lost when we add the driver records.
	// YanL: is not being used
	//	pItem->bitmaskIndex = iBitmaskIndex;

	//Get record type
	pItem->recordType = (BYTE)GetRecordType(pItem);
	pItem->ndxLinkInstall = (PUID) pItem->pf->a.installLink;
	
	//set record pointer to the beginning of the next record

	pRecord += pItem->pv->GetSize();

	return pRecord;
}

int CV31Server::GetRecordType(PINVENTORY_ITEM pItem)
{
	GUID	driverRecordId = WU_GUID_DRIVER_RECORD;
	int		iRecordType = 0;

	if ( memcmp((void *)&pItem->pf->d.g, (void *)&driverRecordId, sizeof(WU_GUID_DRIVER_RECORD)) )
	{
		//if the GUID field is not 0 then we have an active setup record.

		iRecordType = WU_TYPE_ACTIVE_SETUP_RECORD;//active setup record type
	}
	else
	{
		//else this is either a driver record place holder or a section - sub section
		//record. So we need to check the type field

		if ( pItem->pf->d.type == SECTION_RECORD_TYPE_DEVICE_DRIVER_INSERTION )
		{
			//cdm driver place holder record
			iRecordType = WU_TYPE_CDM_RECORD_PLACE_HOLDER;	//cdm code download manager place holder record
		}
		else if ( pItem->pf->d.type == SECTION_RECORD_TYPE_PRINTER )
		{
			//Note: We may need to use this to support printers on win 98.

			iRecordType = WU_TYPE_RECORD_TYPE_PRINTER;	//printer record
		}
		else if ( pItem->pf->d.type == SECTION_RECORD_TYPE_DRIVER_RECORD )
		{
			iRecordType = WU_TYPE_CDM_RECORD;	//Corporate catalog device driver
		}
		else if ( pItem->pf->s.type == SECTION_RECORD_TYPE_CATALOG_RECORD )
		{
			iRecordType = WU_TYPE_CATALOG_RECORD;
		}
		else
		{
			//we have either a section, sub section or sub sub section record

			switch ( pItem->pf->s.level )
			{
				case 0:
					iRecordType = WU_TYPE_SECTION_RECORD;
					break;
				case 1:
					iRecordType = WU_TYPE_SUBSECTION_RECORD;
					break;
				case 2:
					iRecordType = WU_TYPE_SUBSUBSECTION_RECORD;
					break;
			}
		}
	}

	return iRecordType;
}


// --------------------------------------------------------------------------
//  CV31Server::UpdateDownloadItemList()
//  
//  Parses the Catalogs and gets a list of Items in the Correct Platform SKU 
//    section to download.
//
//
// --------------------------------------------------------------------------
BOOL CV31Server::UpdateDownloadItemList(OSVERSIONINFOEX& VersionInfo)
{
    LOG_block("CV31Server::UpdateDownloadItemList()");
    ULONG ulItem = 0;
    int iRecordType = 0;
    BOOL fFound = FALSE, fRet;
    char szServerFile[INTERNET_MAX_URL_LENGTH + 1];
    char szMapFileName[MAX_PATH];
    char szLocale[32];
    DWORD dwLength;
    PBYTE pMapMem = NULL;
    PWU_VARIABLE_FIELD pvCabs;
    PWU_VARIABLE_FIELD pvCRCs;
    int iCabNum = 0;
    BOOL fRetValue = TRUE;
    
    wsprintf(szLocale, "0x%8.8x", m_lcidLocaleID);

    wsprintf(szMapFileName, "%d_%s.des", m_dwPlatformID, szLocale);
    m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, szMapFileName);
    m_pDu->DownloadFileToMem(szServerFile, &pMapMem, &dwLength, TRUE, szMapFileName, NULL);

    if (NULL == pMapMem)
    {
        LOG_error("Failed to Download CRC Map File %s", szServerFile);
        return FALSE;
    }

    CCRCMapFile DescMap(pMapMem, dwLength);

    // Before we add any items to the download list we need to clear the download list
	// from any previous calls to DoDetection.

	m_pDu->EnterDownloadListCriticalSection(); // if we're downloading we don't want to allow the download list to change
	m_pDu->ClearDownloadItemList();

	
    if (0 != m_dwSetupItemCount)
    {
		// We have a valid Setup Catalog, find the Correct Section based on SKU

		// ROGERJ, october 24, 2000
 		// we need to make a list of valid dependency item first
		if (!MakeDependentList(VersionInfo, &DescMap))
		{
			// last error will be set by MakeDependentList() function
			fRetValue = FALSE;
			goto ReturnPoint;
		}
       
        // We want to walk the Catalog Looking for the Section PUID that matches our requested Platform SKU
        for (ulItem = 0; ulItem < m_dwSetupItemCount; ulItem++)
        {
            if (WU_TYPE_SECTION_RECORD == m_pSetupItems[ulItem]->recordType)
            {
                if (m_pSetupItems[ulItem]->pf->s.puid == m_enumPlatformSKU)
                {
                    // found the correct section
                    fFound = TRUE;
                    break;
                }
            }
        }

        if (fFound)
        {
            ulItem++; // advance to the next item
            // until we find the next section, or the end of the catalog
			while ((ulItem < m_dwSetupItemCount) && (WU_TYPE_SECTION_RECORD != GetRecordType(m_pSetupItems[ulItem])))
            {
                PINVENTORY_ITEM pItem = m_pSetupItems[ulItem];

				// ROGERJ, October 24th, 2000 --- determine if the item is applied to this version
				// skip hidden item
				if (pItem->ps->bHidden) 
				{
					ulItem++;
					continue;
				}
                // determine if this item valid on this build
                if ( 0 != pItem->pf->a.installLink && // has dependency
                	!IsDependencyApply(pItem->pf->a.installLink)) // dependency not apply to this version
                	{
                		// if the dependency item is not valid in this version, skip
                		ulItem++;
                		continue;
                	}
                	
                char szServerCab[128];
                char szLocalCab[128];
                // The next section record marks the end of the items valid for this SKU
                fRet = ReadDescription(pItem, &DescMap);
                if (!fRet)
                {
                    // failed to read description file for this item, skip it.
                    ulItem++;
                    continue;
                }

                pvCabs = pItem->pd->pv->Find(WU_DESCRIPTION_CABFILENAME);
                pvCRCs = pItem->pd->pv->Find(WU_DESC_CRC_ARRAY);

                if ((NULL == pvCabs) || (NULL == pvCRCs))
                {
                    // no cab list or CRC list in the description file
                    ulItem++;
                    continue;
                }

                DOWNLOADITEM *pDownloadItem = (DOWNLOADITEM *)GlobalAlloc(GMEM_ZEROINIT, sizeof(DOWNLOADITEM));
                if (NULL == pDownloadItem)
                {
                    LOG_error("Error Allocating Memory for new Download Item");
					fRetValue = FALSE;
					goto ReturnPoint;
                }
                pDownloadItem->dwTotalFileSize = pItem->pd->size * 1024; // Estimated Size in Bytes
                pDownloadItem->puid = pItem->pf->a.puid;

                LPSTR pszCabName = pDownloadItem->mszFileList;

				iCabNum = 0;
                for (;;)
                {
                    if (FAILED(GetCRCNameFromList(iCabNum, pvCabs->pData, pvCRCs->pData, szServerCab, sizeof(szServerCab), szLocalCab)))
                    {
                        break; // no more cabs
                    }

                    pDownloadItem->iNumberOfCabs++;

                    lstrcpy(pszCabName, szServerCab);
                    pszCabName += lstrlen(pszCabName) + 1;
                    *pszCabName = '\0'; // double null terminate
                    pszCabName++; // next cab

                    iCabNum++;
                }

				// don't add the item unless there are cabs for it.
				if (pDownloadItem->iNumberOfCabs > 0 && !IsPUIDExcluded(pItem->pf->a.puid))
                    // before adding this item to the list, check to see if it should be excluded based
                    // on the Catalog.INI
                    m_pDu->AddDownloadItemToList(pDownloadItem);

				
				SafeGlobalFree(pItem->pd);
				ulItem++;
            }
        }
    }
    
ReturnPoint:
	m_pDu->LeaveDownloadListCriticalSection();
	SafeGlobalFree(pMapMem);
    return fRetValue;
}

BOOL CV31Server::ReadDescription(PINVENTORY_ITEM pItem, CCRCMapFile *pMapFile)
{
    if ((NULL == pItem) || (NULL == pMapFile))
    {
        return FALSE;
    }

    LOG_block("CV31Server::ReadDescription()");

    char szServerFile[INTERNET_MAX_URL_LENGTH + 1];
    char szDownloadFile[MAX_PATH];
    PWU_DESCRIPTION pd;
    DWORD dwLength;
    char szBase[64];
    char szCRCName[64];
    HRESULT hr = S_OK;

    wsprintf(szBase, "%d.des", pItem->GetPuid());
    hr = pMapFile->GetCRCName((DWORD)pItem->GetPuid(), szBase, szCRCName, sizeof(szCRCName));
    if (FAILED(hr))
    {
        LOG_error("Failed to get CRC Description Value for Item %d", pItem->GetPuid());
        return FALSE;
    }

    wsprintf(szDownloadFile, "CRCDesc/%s", szCRCName);
 
    m_pDu->DuUrlCombine(szServerFile, m_szV31RootUrl, szDownloadFile);
    m_pDu->DownloadFileToMem(szServerFile, (PBYTE *)&pd, &dwLength, TRUE, szCRCName, "desc.as");

    if (NULL == pd)
    {
        LOG_error("Failed to download Description File %s", szServerFile);
        return FALSE;
    }

    // for 64 bit, the description is off by size of DWORD
    //if (19 == m_pDu->m_iPlatformID)
     	// 64 bit
    //	pd->pv = (PWU_VARIABLE_FIELD)(((PBYTE)pd) + sizeof(WU_DESCRIPTION) + sizeof(DWORD));
   	//else
   		// 32 bit
   		pd->pv = (PWU_VARIABLE_FIELD)(((PBYTE)pd) + sizeof(WU_DESCRIPTION));
    pItem->pd = pd;
    
    return TRUE;
}

void CV31Server::FreeCatalogs()
{
	for (DWORD dwcnt = 0; dwcnt < m_dwSetupItemCount; dwcnt++)
	{
		if (m_pSetupItems[dwcnt])
		{
			SafeGlobalFree(m_pSetupItems[dwcnt]->ps);
			SafeGlobalFree(m_pSetupItems[dwcnt]->pd);
			SafeGlobalFree(m_pSetupItems[dwcnt]);
		}
	}

	for (dwcnt = 0; dwcnt < m_dwConsumerItemCount; dwcnt++)
	{
		if (m_pConsumerItems[dwcnt])
		{
			SafeGlobalFree(m_pConsumerItems[dwcnt]->ps);
			SafeGlobalFree(m_pConsumerItems[dwcnt]->pd);
			SafeGlobalFree(m_pConsumerItems[dwcnt]);
		}
	}

	m_dwSetupItemCount = 0;
	m_dwConsumerItemCount = 0;
}

BOOL CV31Server::MakeDependentList(OSVERSIONINFOEX &VersionInfo, CCRCMapFile *pMapFile)
{
	// Log
	LOG_block("CV31Server::MakeDependentList()");

	// make sure the array is empty
	SafeGlobalFree(m_pValidDependentPUIDArray);
	// no dependency item
	if (!m_nNumOfValidDependentPUID) return TRUE;

	int nPUIDIndex = 0;
	// allocate the memory
	m_pValidDependentPUIDArray = (PUID*) GlobalAlloc(GMEM_ZEROINIT, sizeof(PUID)*m_nNumOfValidDependentPUID);
	if (!m_pValidDependentPUIDArray)
	{
		LOG_error("Out of