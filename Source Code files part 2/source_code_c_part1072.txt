,512
        jz      @f
        Debug_Out "Odd sector size = #CX"
@@:

endif   ;DEBUG  --------------------------------------------------------

; CX now has the drive's sector size.  Determine how many sectors we can
; transfer at a time

rws_have_size:

        mov     cbSectorSize,cx         ;save sector size for later

        xor     dx,dx
        mov     ax,CB_XFRBUF1           ;buf size / sector size = sectors per
        div     cx                      ;  transfer

if DEBUG   ;------------------------------------------------------------
        or      ax,ax
        jnz     @f
        Debug_Out "Sectors per transfer = 0!"
@@:
endif   ;DEBUG  --------------------------------------------------------

        mov     cSectorsPerTransfer,ax

        xor     ax,ax
        mov     cSectorsTransfered,ax   ;sectors transfered so far = 0
        mov     cSectorsThisTransfer,ax ;sectors transfered last time = 0

; Get/init a selector that we'll use to reference the caller's buffer.

        mov     ax,word ptr [lpSectorData+2]    ;get lma of caller's buffer
        call    GetSegmentAddress
        add     dx,word ptr lpSectorData
        adc     bx,0

        call    AllocateSelector                ;build a sel/dscr pointing
        mov     cx,0FFFFh
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        xor     bx,bx
        mov     word ptr lpSectorData,bx        ;use that as the buffer ptr
        mov     word ptr [lpSectorData+2],ax


; ======================================================================
; Main sector read/write loop ------------------------------------------
; ======================================================================

rws_do_it_loop:

; Calculate how many sectors to transfer this time around, set starting
; sector number based on how many transfered last time.

;       int     3                       ;------ 90/11/08 debug ------

        mov     ax,cSectorsToTransfer                   ;total sector
        sub     ax,cSectorsTransfered                   ;total sector - transferred sector = remain
        jnz     @f
        jmp     rws_done
@@:
        cmp     ax,cSectorsPerTransfer                  ;buffer size / sector len = sectors in buffer
        jna     @f                                      ;sectors in buffer > remain sectors = remain
        mov     ax,cSectorsPerTransfer                  ;sectors in buffer < remain = sectors in buffer
@@:
        mov     bx,cSectorsThisTransfer         ;still # R/W from last loop


        push    [bp].pmUserAX                   ;the BIOS does not save
        pop     [bp].intUserAX                  ;  registers across calls to
        push    [bp].pmUserCX                   ;  it so if we're doing
        pop     [bp].intUserCX                  ;  multiple calls to buffer
;       push    [bp].pmUserDX                   ;  data, restore the initial
;       pop     [bp].intUserDX                  ;  register values

;       Previous two lines include bug. '93 1/15 Debugged by S.Kurokawa.

;in  data transmits with a byte, so mov AX to BX 90/07/18 
;;;;    mov     byte ptr [bp].intUserAX,al      ;# sectors in AL = sectors
        push    ax      ;90/11/08 
        xor     ah,ah                           ;for calc a data len, ah=0 90/07/25
        mov     cx,cbSectorSize
        mul     cx                              ;sector num * sector len                90/07/25
        mov     [bp].intUserBX,ax       ;# sectors in BX = data len
        pop     ax      ;90/11/08 
;;;;    add     byte ptr [bp].intUserCX,bl      ;update new start sector in CL
        add     byte ptr [bp].intUserDX,bl      ;update new start sector in DL = sector num@90/07/13 


rws_size_start_set:

; At this point, AX has the number of sectors to transfer.  If this is a
; write, copy a buffer of data from the caller's buffer.

        mov     cSectorsThisTransfer,ax         ;in case it's a read
        ;cSectorsThisTransfer = sectors in buffer or remained sectors

;----------------90/11/08 debug -------------------------------------
        push    ax
        mov     ax,[bp].wParam1         ;BIOS write? 
        and     ax,0ff0fh
        cmp     ax,1B05h                ;BIOS write? 
        pop     ax
;----------------90/11/08 debug -------------------------------------
        
        jnz     rws_not_write
;       call    DBIOS_DEVICE

rws_buf_write:

        mul     cbSectorSize            ;AX now = # bytes to transfer
        mov     cx,ax                   ;can safely assume < 64k
        shr     cx,1                    ;# words to move
;       lds     si,lpSectorData
;       assume  ds:NOTHING
        push    ds
        mov     si,[bp].pmUserBP        ;90/11/09 
        mov     ds,[bp].pmUserES        ;90/11/09 

;       mov     di,offset rgbXfrBuf1
        mov     di,offset DGROUP:rgbXfrBuf1
        cld
        rep movsw
        pop     ds
        
        push    es
        pop     ds
        assume  ds:DGROUP

        mov     word ptr [bp].pmUserBP,si       ;update src ptr for next time
;       mov     word ptr lpSectorData,si        ;update src ptr for next time
;       call    NormalizeBufPtr                 ;  and normalize it


rws_not_write:

;------------------------------------------------------------
        push    ax                      ;90/11/09 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov     ax,segDXDataPM
;       mov     ax,[bp].pmUserES        ;debug
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov     [bp].intUserES,ax       ;segment address
        pop     ax
        mov     [bp].intUserBP,offset DGROUP:rgbXfrBuf1
;------------------------------------------------------------

; Switch to real mode, do the transfer.

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        push    word ptr [bp].lParam
        pop     word ptr lpRmISR
        push    word ptr [bp].lParam+2
        pop     word ptr lpRmISR+2

        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        call    lpRmISR
        pushf
        FCLI

rws_save_regs:

        pusha
        push    ds
        push    es
        mov     bp,sp                   ;restore stack frame pointer

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI                             ;allow HW interrupts


; If the call failed, then cut out now without further processing...

        test    byte ptr [bp].intUserFL,1       ;CY set?
        jnz     rws_done

; If this was a successful read, copy the data back to the caller.

;----------------90/11/08 debug -------------------------------------
        push    ax
        mov     ax,[bp].wParam1         ;BIOS write? 
        and     ax,0ff0fh
        cmp     ax,1B06h                ;BIOS write? 
        pop     ax
;----------------90/11/08 debug -------------------------------------
        jnz     rws_not_read
;       call    DBIOS_DEVICE

rws_buf_read:
        mov     ax,cSectorsThisTransfer         ;calc size of data to move
        mul     cbSectorSize
        mov     cx,ax
        shr     cx,1                            ;in words
;;;;;;;;        les     di,lpSectorData                 ;caller's buffer pointer
;;;;;;;;        assume  es:NOTHING
        push    es
        mov     di,[bp].pmUserBP
        mov     es,[bp].pmUserES
        mov     si,offset DGROUP:rgbXfrBuf1
        cld
        rep movsw
        pop     es
        
        push    ds
        pop     es
        assume  es:DGROUP

        mov     word ptr [bp].pmUserBP,di       ;update dest ptr for next time
;       mov     word ptr lpSectorData,di        ;update dest ptr for next time
;       call    NormalizeBufPtr                 ;  and normailize it

rws_not_read:

        mov     ax,cSectorsThisTransfer         ;count total sectors transfered
        add     cSectorsTransfered,ax           ;add sectors transmitted
                                                ;to previous sectors
;----------- 90/11/09 copy the segment address -------
        push    ax
        mov     ax,[bp].pmUserES        ;90/09/19 BX regster restor
        mov     [bp].intUserES,ax
        mov     ax,[bp].pmUserBP
        mov     [bp].intUserBP,ax
        pop     ax
;------------------------------------------------------------


        jmp     rws_do_it_loop          ;go do another buffer full

rws_done:

        mov     ax,word ptr [lpSectorData+2]    ;release our temp buffer sel
        call    FreeSelector

        jmp     [bp].wParam2
else    ;NEC_98   ;
        pop     [bp].wParam2            ;save return addr higher on stack

; Setup the global data items for the read/write--pointer to caller's
; buffer, # sectors to read/write, and sector size.

        cmp     byte ptr [bp].wParam1+1,13h     ;Int 13h?
        jnz     rws_dos_size

        mov     ax,[bp].pmUserBX                ;ES:BX points to caller's buf
        mov     word ptr lpSectorData,ax
        mov     ax,[bp].pmUserES
        mov     word ptr [lpSectorData+2],ax

        mov     al,byte ptr [bp].intUserAX      ;# sectors caller wants to
        xor     ah,ah                           ;  read or write
        mov     cSectorsToTransfer,ax

        mov     ah,08h                  ;get drive parameters
        mov     dx,[bp].intUserDX       ;  for drive in DL

        push    ax
        SwitchToRealMode
        pop     ax

        pushf                           ;have BIOS get the drive data
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset rws_10)
        mov     ax,es:[13h*4]
        mov     [bp + 2],ax
        mov     ax,es:[13h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf
rws_10: jnc     @f

        mov     cx,512                  ;according to PS/2 tech ref, some
        jmp     short rws_to_pm         ;  old bios versions may fail this,
@@:                                     ;  just use 512 in that case

        mov     cl,es:[di+3]            ;sector size shift factor (0,1,2,3)
        mov     ax,128
        shl     ax,cl                   ;ax now = sector size
        mov     cx,ax

rws_to_pm:
        SwitchToProtectedMode

        FSTI                             ;don't need them disabled

if DEBUG   ;------------------------------------------------------------

        cmp     cx,512
        jz      @f
        Debug_Out "Odd sector size = #CX"
@@:

endif   ;DEBUG  --------------------------------------------------------

        jmp     short rws_have_size

; Before DOS 4.0, CX was the # sectors to read/write.  Starting with 4.0,
; if CX == -1, DS:BX points to a parameter block which contains the
; sector size at offset 4.

rws_dos_size:

        mov     cx,[bp].intUserCX       ;caller's cs == -1?
        inc     cx
        jcxz    rws_dos_4
        dec     cx                      ;  no, then cx has sector count

        mov     ax,[bp].pmUserBX        ;    and DS:BX points to buffer
        mov     word ptr lpSectorData,ax
        mov     ax,[bp].pmUserDS
        mov     word ptr [lpSectorData+2],ax

        jmp     short rws_dos_num_secs

rws_dos_4:

        mov     cx,word ptr rgbXfrBuf0+4 ; yes, get count from low param block

        push    ds                       ;   and DS:BX points to param block
        mov     ds,[bp].pmUserDS         ;     which contains pointer to buffer
        assume  ds:NOTHING
        mov     bx,[bp].pmUserBX
        mov     ax,word ptr ds:[bx+6]
        mov     word ptr lpSectorData,ax
        mov     ax,word ptr ds:[bx+8]
        mov     word ptr [lpSectorData+2],ax
        pop     ds
        assume  DS:DGROUP

rws_dos_num_secs:
        mov     cSectorsToTransfer,cx   ;number sectors to read/write

        mov     cx,512          ;I've been assured by a WINFILE developer
                                ;  that the Int 25/26 sector size will always
                                ;  be 512 bytes.

; CX now has the drive's sector size.  Determine how many sectors we can
; transfer at a time

rws_have_size:

        mov     cbSectorSize,cx         ;save sector size for later

        xor     dx,dx
        mov     ax,CB_XFRBUF1           ;buf size / sector size = sectors per
        div     cx                      ;  transfer

if DEBUG   ;------------------------------------------------------------
        or      ax,ax
        jnz     @f
        Debug_Out "Sectors per transfer = 0!"
@@:
endif   ;DEBUG  --------------------------------------------------------

        mov     cSectorsPerTransfer,ax

        xor     ax,ax
        mov     cSectorsTransfered,ax   ;sectors transfered so far = 0
        mov     cSectorsThisTransfer,ax ;sectors transfered last time = 0

; Get/init a selector that we'll use to reference the caller's buffer.

        mov     ax,word ptr [lpSectorData+2]    ;get lma of caller's buffer
        call    GetSegmentAddress
        add     dx,word ptr lpSectorData
        adc     bx,0

        call    AllocateSelector                ;build a sel/dscr pointing
        mov     cx,0FFFFh
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        xor     bx,bx
        mov     word ptr lpSectorData,bx        ;use that as the buffer ptr
        mov     word ptr [lpSectorData+2],ax


; ======================================================================
; Main sector read/write loop ------------------------------------------
; ======================================================================

rws_do_it_loop:

; Calculate how many sectors to transfer this time around, set starting
; sector number based on how many transfered last time.

        mov     ax,cSectorsToTransfer
        sub     ax,cSectorsTransfered
        jnz     @f
        jmp     rws_done
@@:
        cmp     ax,cSectorsPerTransfer
        jna     @f
        mov     ax,cSectorsPerTransfer
@@:
        mov     bx,cSectorsThisTransfer         ;STIll # R/W from last loop

        cmp     byte ptr [bp].wParam1+1,13h     ;BIOS read/write?
        jnz     rws_use_dos_size

        push    [bp].pmUserAX                   ;the BIOS does not save
        pop     [bp].intUserAX                  ;  registers across calls to
        push    [bp].pmUserCX                   ;  it so if we're doing
        pop     [bp].intUserCX                  ;  multiple calls to buffer
        push    [bp].pmUserDX                   ;  data, restore the initial
        pop     [bp].intUserDX                  ;  register values

        mov     byte ptr [bp].intUserAX,al      ;# sectors in AL

        add     byte ptr [bp].intUserCX,bl      ;update new start sector in CL

        jmp     short rws_size_start_set

rws_use_dos_size:

        cmp     [bp].intUserCX,0FFFFh           ;normal or extended DOS?
        jz      rws_dos4_size
        mov     [bp].intUserCX,ax               ; normal, # sectors in CX

        add     [bp].intUserDX,bx               ; new start sector in DX

        jmp     short rws_size_start_set

rws_dos4_size:

        mov     word ptr rgbXfrBuf0+4,ax        ; extended, # sectors & 32 bit
        add     word ptr rgbXfrBuf0,bx          ;   start sector in parameter
        adc     word ptr rgbXfrBuf0+2,0         ;   block

rws_size_start_set:

; At this point, AX has the number of sectors to transfer.  If this is a
; write, copy a buffer of data from the caller's buffer.

        mov     cSectorsThisTransfer,ax         ;in case it's a read

        cmp     [bp].wParam1,1303h              ;BIOS write?
        jz      rws_buf_write
        cmp     byte ptr [bp].wParam1+1,26h     ;DOS write?
        jnz     rws_not_write

rws_buf_write:

        mul     cbSectorSize            ;AX now = # bytes to transfer
        mov     cx,ax                   ;can safely assume < 64k
        shr     cx,1                    ;# words to move
        lds     si,lpSectorData
        assume  ds:NOTHING
        mov     di,offset rgbXfrBuf1
        cld
        rep movsw

        push    es
        pop     ds
        assume  ds:DGROUP

        mov     word ptr lpSectorData,si        ;update src ptr for next time
        call    NormalizeBufPtr                 ;  and normalize it

rws_not_write:


; Switch to real mode, do the transfer.

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        push    word ptr [bp].lParam
        pop     word ptr lpRmISR
        push    word ptr [bp].lParam+2
        pop     word ptr lpRmISR+2

        cmp     byte ptr [bp].wParam1+1,13h
        jnz     rws_call_dos

        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        call    lpRmISR
        pushf
        FCLI
        jmp     short rws_save_regs

rws_call_dos:
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        call    lpRmISR
        pop     word ptr lpRmISR        ;int 25/26 leave flags on stack,
        pushf                           ;  pop them to nowhere
        FCLI

rws_save_regs:
        pusha
        push    ds
        push    es
        mov     bp,sp                   ;restore stack frame pointer

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI                             ;allow HW interrupts

; If the call failed, then cut out now without further processing...

        test    byte ptr [bp].intUserFL,1       ;CY set?
        jnz     rws_done

; If this was a successful read, copy the data back to the caller.

        cmp     [bp].wParam1,1302h              ;BIOS read?
        jz      rws_buf_read
        cmp     byte ptr [bp].wParam1+1,25h     ;DOS read?
        jnz     rws_not_read

rws_buf_read:
        mov     ax,cSectorsThisTransfer         ;calc size of data to move
        mul     cbSectorSize
        mov     cx,ax
        shr     cx,1                            ;in words
        les     di,lpSectorData                 ;caller's buffer pointer
        assume  es:NOTHING
        mov     si,offset rgbXfrBuf1
        cld
        rep movsw

        push    ds
        pop     es
        assume  es:DGROUP

        mov     word ptr lpSectorData,di        ;update dest ptr for next time
        call    NormalizeBufPtr                 ;  and normailize it

rws_not_read:

        mov     ax,cSectorsThisTransfer         ;count total sectors transfered
        add     cSectorsTransfered,ax

        jmp     rws_do_it_loop          ;go do another buffer full

rws_done:

        mov     ax,word ptr [lpSectorData+2]    ;release our temp buffer sel
        call    FreeSelector

        jmp     [bp].wParam2
endif   ;NEC_98   ;

ReadWriteSectors  endp


ifdef      NEC_98    ;
; -------------------------------------------------------
        subttl  Disk Utility Routines
        page
; -------------------------------------------------------
;               DISK UTILITY ROUTINES
; -------------------------------------------------------
;  DOSReadWriteSectors -- Common code to read/write disk sectors for
;       Int 13h/25h/26h.
;
;       In:     lParam  - seg:off of real mode interrupt handler
;               wParam1 - int #, and possible subfunction
;               regs on stack


        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  DOSReadWriteSectors

DOSReadWriteSectors  proc       near

;       int     3                       ;------ 90/11/08 debug ------

;       pop     [bp].wParam3            ;save return addr higher on stack

; Setup the global data items for the read/write--pointer to caller's
; buffer, # sectors to read/write, and sector size.


; Before DOS 4.0, CX was the # sectors to read/write.  Starting with 4.0,
; if CX == -1, DS:BX points to a parameter block which contains the
; sector size at offset 4.

rws_dos_size:

        mov     cx,[bp].intUserCX       ;caller's cs == -1?
        inc     cx
        jcxz    rws_dos_4
        dec     cx                      ;  no, then cx has sector count

        mov     ax,[bp].pmUserBX        ;    and DS:BX points to buffer 
        mov     word ptr lpSectorData,ax
        mov     ax,[bp].pmUserDS
        mov     word ptr [lpSectorData+2],ax

        jmp     short rws_dos_num_secs

rws_dos_4:

        mov     cx,word ptr rgbXfrBuf0+4 ; yes, get count from low param block

        push    ds                       ;   and DS:BX points to param block
        mov     ds,[bp].pmUserDS         ;     which contains pointer to buffer
        assume  ds:NOTHING
        mov     bx,[bp].pmUserBX
        mov     ax,word ptr ds:[bx+6]
        mov     word ptr lpSectorData,ax
        mov     ax,word ptr ds:[bx+8]
        mov     word ptr [lpSectorData+2],ax
        pop     ds
        assume  DS:DGROUP

rws_dos_num_secs:
        mov     cSectorsToTransfer,cx   ;number sectors to read/write

;
; We will need the sector size if we have to break up the transfer.
;
if 0
        push    ds
        push    bx
        mov     dl,byte ptr [bp].pmUserAX
        inc     dl
        mov     ah,1ch
        assume  DS:NOTHING
        int     21h
        pop     bx
        pop     ds
        assume  DS:DGROUP
        cmp     al,0ffh
        jne     rws_have_size
;
; Call to DOS to get drive data failed, probably due to invalid
; drive number.  Assume 512, let INT 25h/26h return the failure.
;
rws_use_default:
@@    mov     cx,512

else
        push    bx
        mov     bl, byte ptr [bp].pmUserAX
        inc     bl
        call    GetSectorSize
        pop     bx
endif

; CX now has the drive's sector size.  Determine how many sectors we can
; transfer at a time

DOS_rws_have_size:

        mov     cbSectorSize,cx         ;save sector size for later

        xor     dx,dx
        mov     ax,CB_XFRBUF1           ;buf size / sector size = sectors per
        div     cx                      ;  transfer

if DEBUG   ;------------------------------------------------------------
        or      ax,ax
        jnz     @f
        Debug_Out "Sectors per transfer = 0!"
@@:
endif   ;DEBUG  --------------------------------------------------------

        mov     cSectorsPerTransfer,ax

        xor     ax,ax
        mov     cSectorsTransfered,ax   ;sectors transfered so far = 0
        mov     cSectorsThisTransfer,ax ;sectors transfered last time = 0

; Get/init a selector that we'll use to reference the caller's buffer.

        mov     ax,word ptr [lpSectorData+2]    ;get lma of caller's buffer
        call    GetSegmentAddress
        add     dx,word ptr lpSectorData
        adc     bx,0

        call    AllocateSelector                ;build a sel/dscr pointing
        mov     cx,0FFFFh
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        xor     bx,bx
        mov     word ptr lpSectorData,bx        ;use that as the buffer ptr
        mov     word ptr [lpSectorData+2],ax


; ======================================================================
; Main sector read/write loop ------------------------------------------
; ======================================================================

DOS_rws_do_it_loop:

; Calculate how many sectors to transfer this time around, set starting
; sector number based on how many transfered last time.

;       int     3                       ;------ 90/11/08 debug ------

        mov     ax,cSectorsToTransfer                   ;totak sectors
        sub     ax,cSectorsTransfered                   ;total sectors - sectors transmitted = remaine sectors
        jnz     @f
        jmp     DOS_rws_done
@@:
        cmp     ax,cSectorsPerTransfer                  ;buffer size / sector len = sectors in buffer
        jna     @f                                      ;sectors in buffer > remain = remain
        mov     ax,cSectorsPerTransfer                  ;sectors in buf < remain = sectors in buffer
@@:
        mov     bx,cSectorsThisTransfer         ;still # R/W from last loop

rws_use_dos_size:

        cmp     [bp].intUserCX,0FFFFh           ;normal or extended DOS?
        jz      rws_dos4_size
        mov     [bp].intUserCX,ax               ; normal, # sectors in CX

        add     [bp].intUserDX,bx               ; new start sector in DX

        jmp     short DOS_rws_size_start_set

rws_dos4_size:

        mov     word ptr rgbXfrBuf0+4,ax        ; extended, # sectors & 32 bit
        add     word ptr rgbXfrBuf0,bx          ;   start sector in parameter
        adc     word ptr rgbXfrBuf0+2,0         ;   block

DOS_rws_size_start_set:

; At this point, AX has the number of sectors to transfer.  If this is a
; write, copy a buffer of data from the caller's buffer.

        mov     cSectorsThisTransfer,ax         ;in case it's a read
        ;cSectorsThisTransfer = sectors in buffer or remain sectors 


;----------------- 90/07/24 -----------------------------------------
        cmp     byte ptr [bp].wParam1+1,26h     ;DOS write?
        jz      DOS_rws_buf_write
        jmp     DOS_rws_not_write

DOS_rws_buf_write:

        mul     cbSectorSize            ;AX now = # bytes to transfer
        mov     cx,ax                   ;can safely assume < 64k
        shr     cx,1                    ;# words to move
        lds     si,lpSectorData
        assume  ds:NOTHING
        mov     di,offset rgbXfrBuf1
        cld
        rep movsw

        push    es
        pop     ds
        assume  ds:DGROUP

        mov     word ptr lpSectorData,si        ;update src ptr for next time
        call    NormalizeBufPtr                 ;  and normalize it

DOS_rws_not_write:


; Switch to real mode, do the transfer.

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        push    word ptr [bp].lParam
        pop     word ptr lpRmISR
        push    word ptr [bp].lParam+2
        pop     word ptr lpRmISR+2

rws_call_dos:
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        pusha                           ; This trashes all registers
        call    lpRmISR
        mov     bp,sp
        jnc     @F                      ; If carry, AX = error code
        mov     [bp+14],ax
@@:
        popa
        pop     word ptr lpRmISR        ; int 25/26 leave flags on stack,
                                        ;  pop them to nowhere
        pushf
        FCLI

DOS_rws_save_regs:

;       int     3

        pusha
        push    ds
        push    es
        mov     bp,sp                   ;restore stack frame pointer

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI                             ;allow HW interrupts

; If the call failed, then cut out now without further processing...

        test    byte ptr [bp].intUserFL,1       ;CY set?
        jnz     DOS_rws_done

; If this was a successful read, copy the data back to the caller.

;----------------- 90/07/23 -----------------------------------------
        cmp     byte ptr [bp].wParam1+1,25h     ;DOS read?
        jz      DOS_rws_buf_read
        jmp     DOS_rws_not_read

DOS_rws_buf_read:
        mov     ax,cSectorsThisTransfer         ;calc size of data to move
        mul     cbSectorSize
        mov     cx,ax
        shr     cx,1                            ;in words
        les     di,lpSectorData                 ;caller's buffer pointer
        assume  es:NOTHING
        mov     si,offset rgbXfrBuf1
        cld
        rep movsw

        push    ds
        pop     es
        assume  es:DGROUP

        mov     word ptr lpSectorData,di        ;update dest ptr for next time
        call    NormalizeBufPtr                 ;  and normailize it

DOS_rws_not_read:

        mov     ax,cSectorsThisTransfer         ;count total sectors transfered
        add     cSectorsTransfered,ax           ;add sectors transmitted
                                                ;to previous sectors

        jmp     DOS_rws_do_it_loop              ;go do another buffer full

DOS_rws_done:

        mov     ax,word ptr [lpSectorData+2]    ;release our temp buffer sel
        call    FreeSelector

        jmp     [bp].wParam2

DOSReadWriteSectors  endp
endif   ;NEC_98   ;

; -------------------------------------------------------


; This routine 'normalizes' the far pointer in lpSectorData such that
; the selector/descriptor points to where the selector:offset currently
; points

        assume  ds:DGROUP,es:NOTHING

NormalizeBufPtr proc    near

        mov     ax,word ptr [lpSectorData+2]    ;get segment base address
        call    GetSegmentAddress
        add     dx,word ptr lpSectorData        ;add in current offset
        adc     bx,0
        call    SetSegmentAddress               ;make that the new seg base
        xor     bx,bx
        mov     word ptr lpSectorData,bx        ;  with a zero offset

        ret

NormalizeBufPtr endp

ifdef      NEC_98    ;
public GetSectorSize
GetSectorSize   proc    near

    push    ax
    push    bx
    push    dx
    push    ds
    sub     sp, 40h
    mov     dx, sp
    push    ss
    pop     ds
    mov     ax, 440Dh
    mov     cx, 0860h
    int     21h
ifdef      NEC_98
    mov     cx, 1024                 ; if 440D doesn't work, 512 bytes!
else  ;NEC_98
    mov     cx, 512                  ; if 440D doesn't work, 512 bytes!
endif ;NEC_98
    jc            @F
    mov     bx, dx
    mov     cx, word ptr ds:[bx+7]   ; bytes per sector first field
@@: add     sp, 40h
    pop     ds                       ; in BPB at offset 7.
    pop     dx
    pop     bx
    pop     ax
    ret

GetSectorSize        endp

;-------------------------- DBIOS_DEVICE --------------------------------
;       for difference of cylinders, heads, sectors between all devices
;       if reached at each max value, we change the cylinders, heads
;       to have a READ/WRITE process
;------------------------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  DBIOS_DEVICE

DBIOS_DEVICE    proc    near

        mov     ax,[bp].intUserDX       ;DH = head numCDL = sector num
        cmp     byte ptr sensedata4,al  ;maximum sector num ?
        jnz     DBIOS_RET               ;NO = JMP
        cmp     byte ptr sensedata3,ah  ;maximum head num ?
        jnz     HEADINC                 ;NO = JMP
        mov     [bp].intUserDX,0        ;DH = head numCDL = sector num 0
        mov     ax,[bp].intUserCX       ;set the next cylinder
        add     al,1                    ;
        mov     [bp].intUserCX,ax       ;
DBIOS_RET:
        ret                             ;
        
HEADINC:
        add     ah,1                    ;increase head num
        mov     al,0                    ;sector num 0
        mov     [bp].intUserDX,ax       ;set
        ret
        
DBIOS_DEVICE    endp
endif   ;NEC_98   ;
DXPMCODE    ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxdma.asm ===
PAGE    ,132
        TITLE   DXDMA.ASM  -- Dos Extender DMA Services

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXDMA.ASM       -- Dos Extender DMA Services
;
;-----------------------------------------------------------------------
;
; This module provides the protect mode DMA services for the 286 DOS
; Extender.  It supports a subset of the services documented in
; "DMA Services for DOS Virtual 8086 and Protected Mode Environments"
; by Microsoft Corporation.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Minor changes to reflect updates in DMA Service Spec.
;  11/01/89 jimmat  Started.
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
include     pmdefs.inc
include     interupt.inc
if VCPI
include     dxvcpi.inc
endif
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

PhysicalPageSize equ    4096            ;size of 80386 physical page
PageShift        equ    12

DMAServiceByte  equ     7Bh

ChainReserved   equ     08h             ;set if unsupported services chained

DMAServiceID    equ     81h             ;Int 4Bh/AH=81h are the DMA services
FirstValidSvc   equ     02h             ;First valid DMA service #
LastValidSvc    equ     0Ch             ;Last  valid DMA service #

; Get Version information

MajorVersion    equ     01h             ;Major specification version
MinorVersion    equ     00h             ;Minor specification version

DOSXProductNumber equ   02h             ;286 DOS Extender product number
DOSXProductRevision equ 01h             ;286 DOS Extender revision number

MemoryContiguous equ    08h             ;All memory physically contigious flag
AutoRemapSupported equ  04h             ;Automatic remap supported

; DX flags on calls to DMA services

AutoBufferCopy  equ     02h             ;set if data to be copied into DMA buf
NoAutoBufferAlloc equ   04h             ;set if NO automatic buff allocation
NoAutoRemap     equ     08h             ;set if NO automatic remap attempted
Align64k        equ     10h             ;set if region can't cross 64k boundry
Align128k       equ     20h             ;set if region can't cross 128k boundry
PageTableFmt    equ     40h             ;set for page table Scatter/Gather lock

ValidDXFlags    equ     007Eh           ;valid DX register flag bits (above)

; Error return codes

ErrRegionCrossedBoundry equ     02h
ErrNoBufferAvail        equ     04h
ErrTooManyRegions       equ     09h
ErrInvalidBufferID      equ     0Ah
ErrFuncNotSupported     equ     0Fh
ErrReservedFlagBits     equ     10h

; DMA Descriptor Structure(s)

DDS     STRUC                           ;normal DDS
DDS_RegionSize  dd      ?
DDS_Offset      dd      ?
DDS_Selector    dw      ?
DDS_BufferID    dw      ?
DDS_PhyAddress  dd      ?
DDS     ENDS

SGDDS1  STRUC                           ;Extended DDS for Scatter/Gather
                dd      3 dup (?)       ;  Region format
DDS_NumAvail    dw      ?
DDS_NumUsed     dw      ?
DDS_Region0Addr dd      ?
DDS_Region0Size dd      ?
SGDDS1  ENDS

SGDDS2  STRUC                           ;Extended DDS for Scatter/Gather
                dd      4 dup (?)       ;  Page Table format
DDS_PageTblEnt0 dd      ?
SGDDS2  ENDS


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterIntHandler:NEAR
        extrn   LeaveIntHandler:NEAR
        extrn   GetSegmentAddress:NEAR
        extrn   PMIntrEntryVector:NEAR


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment
ifdef      NEC_98   
        extrn   fPCH98:BYTE
else    ;!NEC_98  
ifdef NOT_NTVDM_NOT
        extrn   fMicroChannel:BYTE
endif
endif   ;!NEC_98

if VCPI
	extrn	fVCPI:BYTE
endif
;
; Contains a copy of bit 5 of the byte at 40:7b, that indicates
; whether VDS should be used.
;
	public	bDMAServiceBit
bDMAServiceBit	db	0

DXDATA	ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

DXCODE  ends

DXPMCODE segment

        extrn   selDgroupPM:WORD

DMASvcTbl label   word

        dw      offset DXPMCODE:GetVersion
        dw      offset DXPMCODE:LockDMARegion
        dw      offset DXPMCODE:DoNothing               ;UnlockDMARegion
        dw      offset DXPMCODE:ScatterGatherLock
        dw      offset DXPMCODE:DoNothing               ;ScatterGatherUnlock
        dw      offset DXPMCODE:Fail4NoBuffer           ;RequestDMABuffer
        dw      offset DXPMCODE:DoNothing               ;ReleaseDMABuffer
        dw      offset DXPMCODE:Fail4BufferID           ;CopyIntoDMABuffer
        dw      offset DXPMCODE:Fail4BufferID           ;CopyOutOfDMABuffer
        dw      offset DXPMCODE:DoNothing               ;DisableDMATranslation
        dw      offset DXPMCODE:DoNothing               ;EnableDMATranalation

DXPMCODE ends

; -------------------------------------------------------
        subttl  DMA Service Dispatcher
        page
; -------------------------------------------------------
;                 DMA SERVICE DISPATCHER
; -------------------------------------------------------

DXPMCODE segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr4B -- Entry routine/dispatcher for protected mode DMA
;       services.  The DMA services are invoked with an Int 4Bh
;       interrupt.  The 286 DOS Extender only supports the DMA
;       services in protected mode.  Other systems that use Virtual
;       8086 mode on 386 processors will most likely need to support
;       the services in virtual mode also.
;
;       The following services are supported (Int 4Bh/AH = 81h):
;
;               AL = 00 Reserved
;                    01 Reserved
;                    02 Get Version
;                    03 Lock DMA Region
;                    04 Unlock DMA Region
;                    05 Scatter/Gather Lock Region
;                    06 Scatter/Gather Unlock Region
;                    07 Request DMA Buffer
;                    08 Release DMA Buffer
;                    09 Copy Into DMA Buffer
;                    0A Copy Out Of DMA Buffer
;                    0B Disable DMA Translation
;                    0C Enable DMA Translation
;                    0D Reserved
;                    ...
;                    FF Reserved

        public  PMIntr4B
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

PMIntr4B        proc    near

; Is this one of the supported DMA services?

        cmp     ah,DMAServiceID         ;is this a DMA service request?
        jz      @f
        jmp     short i4b_other_service ;  no, see if it should be chained
@@:
        call    EnterIntHandler         ;saves regs, switches stacks, etc.
        assume  ds:DGROUP               ;sets DS/ES = DGROUP
        mov     es,[bp].pmUserES        ;  but we want caller's ES

        cld                             ;cya...

        cmp     al,FirstValidSvc
        jb      i4b_reserved

        cmp     al,LastValidSvc
        ja      i4b_reserved

        test    dx,NOT ValidDXFlags     ;any reserved flags set?
        jnz     i4b_bad_flags

; -------------------------------------------------------

; Setup local environment and dispatch the service

i4b_valid_svc:

        push    offset DXPMCODE:i4b_svc_ret     ;save dispatch return address

        sub     al,FirstValidSvc        ;get address of service routine
        cbw
        shl     ax,1
        add     ax,offset DXPMCODE:DMASvcTbl

        xchg    ax,bx
        mov     bx,cs:[bx]
        xchg    ax,bx

        push    ax                      ;save routine address on stack
        mov     ax,[bp].pmUserAX        ;restore entry AX

        ret                             ;invoke service routine

i4b_svc_ret:                            ;service routines return here

        jnc     i4b_good_return         ;CY set if service failed

i4b_error_return:

        or      byte ptr [bp].intUserFL,1       ;set CY in caller's flags
        jmp     short i4b_exit

i4b_good_return:

        and     byte ptr [bp].intUserFL,not 1   ;clear CY in caller's flags

i4b_exit:

        call    LeaveIntHandler         ;resotre stack, regs, etc.
        iret

; -------------------------------------------------------

; Reserved DMA service 00, 01, 0D-FF;  return with CY set and
; AL = ErrFuncNotSupported

i4b_reserved:

        mov     byte ptr [bp].intUserAX,ErrFuncNotSupported
        jmp     short i4b_error_return

; -------------------------------------------------------

; User made a DMA service call with a reserved flag bit set.  Fail the
; call with AL = ErrReservedFlagBits

i4b_bad_flags:

        mov     byte ptr [bp].intUserAX,ErrReservedFlagBits
        jmp     short i4b_error_return

; -------------------------------------------------------

; This is a non-DMA Int 4B call.  On Micro Channel systems, bit 3
; in location 40:007B indicates if we should chain the call along
; or not.  If the bit is set, we chain.  If not Micro Channel, or the
; bit is not set, we check the real mode Int 4Bh vector to see if someone
; other than the BIOS has it hooked--if so, we chain anyway.  If not,
; return without changing any regs or flags.

i4b_other_service:

        push    ds

        mov     ds,selDgroupPM
        assume  ds:DGROUP

ifdef NOT_NTVDM_NOT
ifdef      NEC_98
        test    fPCH98,0FFh
else   ;!NEC_98
        test    fMicroChannel,0FFh              ;if micro channel system
endif  ;!NEC_98
        jz      i4b_check_vector                ;  and 40:7B bit 3 set,
                                                ;  chain the call to real mode
        push    SEL_BIOSDATA or STD_RING
        pop     ds
        assume  ds:NOTHING

        test    byte ptr ds:DMAServiceByte,ChainReserved
        jnz     i4b_chain
endif

i4b_check_vector:                       ;not micro channel, or bit 3 not set

        push    ax                              ;check if the real mode Int 4Bh
        mov     ax,SEL_RMIVT or STD_RING        ;  points somewhere and not
        mov     ds,ax                           ;  at the BIOS--if so, chain
        mov     ax,word ptr ds:[4Bh*4]          ;  anyway.
        or      ax,word ptr ds:[4Bh*4+2]
        pop     ax
        jz      i4b_dont_chain

        cmp     word ptr ds:[4bh*4+2],0E000h
        jz      i4b_dont_chain

        cmp     word ptr ds:[4bh*4+2],0F000h
        jz      i4b_dont_chain

i4b_chain:

        pop     ds                              ;chain the request to real mode
        jmp     PMIntrEntryVector + 5*4Bh       ;  (no one can have pMode
                                                ;   hooked before us)

i4b_dont_chain:                         ;don't chain the interrupt,
                                        ;  just return quietly
        pop     ds
        iret

PMIntr4B        endp

; -------------------------------------------------------
        subttl  DMA Service Routines
        page
; -------------------------------------------------------
;                 DMA SERVICE ROUTINES
; -------------------------------------------------------


; -------------------------------------------------------
;   RM4B  -- Call the real mode INT 4Bh handler to
;       perform a DMA service, most likely something to
;       do with the VCPI provider's buffer when we are
;       running under VCPI.
;
;   Input:      depends on call
;   Output:     Flags, registers from real mode call
;
;   Notes:      This is strictly an internal DOSX call,
;               so if a long pointer is used, then it
;               is assumed to point into DOSX's data
;               segment.
;
cProc RM4B,<NEAR,PUBLIC>
cBegin
        pushf
        push    cs
        call  near ptr PMIntrEntryVector + 3*4Bh
cEnd

; -------------------------------------------------------
;   DoNothing  -- This routine does nothing other than return
;       indicating that the DMA service succeeded.
;
;   Input:      none
;   Output:     AL = 0, CY clear

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

DoNothing       proc    near

        clc             ;indicate success
        ret

DoNothing       endp


; -------------------------------------------------------
;   Fail4BufferID  -- This routine does nothing other than return
;       indicating that the DMA service failed with 'Invalid Buffer ID'
;
;   Input:      none
;   Output:     AL = 0Ah, CY set

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

Fail4BufferID   proc    near

        mov     byte ptr [bp].intUserAX,ErrInvalidBufferID
        stc
        ret

Fail4BufferID   endp


; -------------------------------------------------------
;   Fail4NoBuffer  -- This routine does nothing other than return
;       indicating that the DMA service failed with 'No Buffer Available'
;
;   Input:      none
;   Output:     AL = 04h, CY set

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

Fail4NoBuffer   proc    near

        mov     byte ptr [bp].intUserAX,ErrNoBufferAvail
        stc
        ret

Fail4NoBuffer   endp


; -------------------------------------------------------
;   GetVersion -- This routine processes the DMA Get Version
;       service (AL = 02).
;
;   Input:      none
;   Output:     AH/AL - Major/Minor specification level
;               BX    - Product number
;               CX    - Product revision number
;               DX    - flags
;               SI:DI - 32 bit max buffer size available

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

GetVersion      proc    near

        mov     [bp].intUserAX,(MajorVersion shl 8) or MinorVersion
        mov     [bp].intUserBX,DOSXProductNumber
        mov     [bp].intUserCX,DOSXProductRevision
        mov     [bp].intUserDX,MemoryContiguous


        xor     ax,ax                   ;0 buffer size supported, also clears
        mov     [bp].intUserSI,ax       ;  carry flag
        mov     [bp].intUserDI,ax

if VCPI
        cmp     fVCPI,0
        je      gv_x
	mov	ax,8102h
	xor	dx,dx			;DX = 0
	cmp	bDMAServiceBit,0	;VCPI provider supports VDS?
	je	gv_e
        call    RM4B
        jc      gv_x
        mov     [bp].intUserSI,si
        mov     [bp].intUserDI,di
	and	dx,NOT (AutoRemapSupported or MemoryContiguous)
gv_e:
        mov     [bp].intUserDX,dx
gv_x:
endif
        ret

GetVersion      endp


; -------------------------------------------------------
;   LockDMARegion -- This routine processes the Lock DMA Region
;       service (AL = 03).
;
;   Input:      DX    - flags
;               ES:DI - ptr to DDS
;   Output:     if successful, CY clear;  else CY set and AL = error code
;               DDS updated

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

LockDMARegion   proc    near

; Since we don't support paging or anything interesting like that, the only
; thing that can fail us is an alignment problem--check for that.

        test    dl,Align64k or Align128k        ;if they don't care,
        jz      lock_ok                         ;  we don't care

        mov     si,dx                   ;save flags in SI

        call    CalcDDSPhyAddress       ;see where the region is

        push    dx                      ;save start address
        push    ax

        mov     bx,dx                   ;bx = hi word start addr

        add     ax,word ptr es:[di].DDS_RegionSize      ;see where it ends
        adc     dx,word ptr es:[di].DDS_RegionSize+2

        sub     ax,1                    ;less 1 to point at
        sbb     dx,0                    ;  last byte, not next

        mov     cx,dx                   ;cx = hi word end addr

        test    si,Align128k            ;64k or 128k alignment wanted?
        jz      @f                      ;  already setup for 64k
        and     bl,not 1                ;mask to 128k alignment
        and     cl,not 1
@@:
        cmp     bx,cx                   ;within the boundry?
        jz      lock_ok_clr_stk         ;  yes, 'lock' it

; The region crosses an alignment boundary, we need to update the allowed
; region size in the DDS, and fail the call.

        pop     cx
        pop     dx                      ;dx:cx = region start address

        neg     cx                      ;cx = len to next 64k boundry
        xor     bx,bx
        test    si,Align128k
        jz      @f
        mov     bl,dl
        and     bl,1
        xor     bl,1                    ;bx:cx = len to next alignment boundry
@@:
        mov     word ptr es:[di].DDS_RegionSize,cx      ;update size in DDS
        mov     word ptr es:[di].DDS_RegionSize+2,bx

        mov     byte ptr [bp].intUserAX,ErrRegionCrossedBoundry ;flag failure
        stc
        ret


lock_ok_clr_stk:

        add     sp,4                    ;clear start address from stack

; No alignment problem, we can 'lock' the region.

lock_ok:

        call    CalcDDSPhyAddress       ;get physical address of region DX:AX
        mov     word ptr es:[di].DDS_PhyAddress,ax
        mov     word ptr es:[di].DDS_PhyAddress+2,dx

        xor     ax,ax                       ;*** also clears CY! ***
        mov     es:[di].DDS_BufferID,ax     ;no buffer used

        ret

LockDMARegion   endp


; -------------------------------------------------------
;   ScatterGatterLock -- This routine implements the Scatter/Gather
;       Lock Region DMA service (AL = 05h).
;
;   Input:      DX    - flags
;               ES:DI - ptr to extended DDS
;   Output:     if successful, CY clear;  else CY set & AL = error code
;               DDS updated

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

ScatterGatherLock       proc    near

        test    dl,PageTableFmt         ;Scatter/Gather page table form?
        jnz     do_page_tbl_lock

; This is the region form of Scatter/Gather Lock Region -- for us this
; is easy, since memory is contiguous -- one region covers the entire area.

        mov     ax,1                    ;we need one region entry
        mov     es:[di].DDS_NumUsed,ax

        cmp     es:[di].DDS_NumAvail,ax ;  is it available?
        jb      not_enough_entries

        call    CalcDDSPhyAddress       ;get physical address

        mov     word ptr es:[di].DDS_Region0Addr,ax     ;store in extended DDS
        mov     word ptr es:[di].DDS_Region0Addr+2,dx

        mov     ax,word ptr es:[di].DDS_RegionSize      ;copy over the size
        mov     word ptr es:[di].DDS_Region0Size,ax
        mov     ax,word ptr es:[di].DDS_RegionSize+2
        mov     word ptr es:[di].DDS_Region0Size+2,ax

        clc                             ;indicate success
        ret

; This is the page table form of Scatter/Gather Lock Region -- we need to
; build a fake page table (even though we may be on an 80286!?) to return
; in the extended DDS.

do_page_tbl_lock:

        call    CalcDDSPhyAddress       ;get region start address

        mov     cx,word ptr es:[di].DDS_RegionSize      ;calc # pages needed
        mov     bx,word ptr es:[di].DDS_RegionSize+2    ;  for region of this
        add     cx,PhysicalPageSize-1                   ;  size
        adc     bx,0
        shr     cx,PageShift
        shl     bx,16-PageShift
        or      cx,bx                                   ;cx = # pages

        test    ax,PhysicalPageSize-1   ;if region doesn't start on a page
        jz      @f                      ;  boundry, add another page to
        inc     cx                      ;  the region size
@@:
        mov     es:[di].DDS_NumUsed,cx  ;tell caller how many used/needed
        cmp     es:[di].DDS_NumAvail,cx ;did caller supply enough page entries?
        jb      not_enough_entries      ;  no!

        push    ax                      ;save low word of region start address

        and     ax,NOT PhysicalPageSize-1   ;round down to page boundry
        or      al,1                        ;set page present/locked bit
        mov     bx,di                       ;es:bx -> page table entries

        jcxz    page_ents_done          ;better safe than sorry
@@:
        mov     word ptr es:[bx].DDS_PageTblEnt0,ax     ;build fake page
        mov     word ptr es:[bx].DDS_PageTblEnt0+2,dx   ;  table entries...
        add     ax,PhysicalPageSize
        adc     dx,0
        add     bx,4
        loop    @b

page_ents_done:

        pop     ax                      ;recover low word of start address
        and     ax,PhysicalPageSize-1   ;  and get offset into first page
        mov     [bp].intUserBX,ax       ;  return to caller in BX

        clc                             ;indicate success
        ret

; Fail the request for insufficient # of region/page tbl entries

not_enough_entries:

        mov     byte ptr [bp].intUserAX,ErrTooManyRegions       ;AL = error code

        mov     ax,es:[di].DDS_NumAvail                 ;store max lockable
        mov     dx,ax                                   ;  size (bytes) in
        shl     ax,PageShift                            ;  DDS region size
        shr     dx,16-PageShift
        mov     word ptr es:[di].DDS_RegionSize,ax
        mov     word ptr es:[di].DDS_RegionSize+2,dx

        stc                             ;indicate failure
        ret


ScatterGatherLock       endp


; -------------------------------------------------------
        subttl  DMA Service Utility Routines
        page
; -------------------------------------------------------
;              DMA SERVICE UTILITY ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
;   CalcDDSPhyAddress -- This routine calculates the physical
;       address of the region specified in a DDS.
;
;   Input:      ES:DI - ptr to DDS
;   Output:     DX:AX - 32 bit physical address
;   Uses:       none.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

CalcDDSPhyAddress       proc    near

        push    bx
        xor     bx,bx
        mov     dx,bx

        mov     ax,es:[di.DDS_Selector]         ;if a selector is given,
        or      ax,ax                           ;  get it's base address
        jz      @f

        call    GetSegmentAddress               ;bx:dx = segment base
@@:
        add     dx,word ptr es:[di.DDS_Offset]          ;add 32 bit offset
        adc     bx,word ptr es:[di.DDS_Offset+2]

        mov     ax,dx                           ;32 bit address to dx:ax
        mov     dx,bx
        pop     bx

        ret

CalcDDSPhyAddress       endp


DXPMCODE ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxemm.asm ===
PAGE	,132
	TITLE	DXEMM.ASM  -- Dos Extender MEMM Disable Code

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	DXEMM.ASM      -- Dos Extender MEMM Disable Code
;
;-----------------------------------------------------------------------
;
; This module provides routines that attempt to disable MEMM/CEMM/EMM386
; drivers.  DOSX tries to disable MEMM when starting up, and enables MEMM
; when terminating.
;
; NOTE: All the code in this module is consider initialization, and
;	is discarded before going operational.	This includes code
;	segment variables.  The MEMM enable code is not in this file
;	since that cannot be discarded.
;
;-----------------------------------------------------------------------
;
;  12/08/89 jimmat  Minor changes so enable code could be finished.
;  07/14/89 jimmat  Original version - but largely taken from Windows/386
;		    code from ArronR
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include segdefs.inc
include gendefs.inc
IFDEF	ROM
include dxrom.inc
ENDIF
	.list

if NOT VCPI
; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

EMM_OK	equ	0

; Device driver header for Microsoft 386 EMM drivers
;
emm_hdr 	STRUC
;
	DW		?			;Null segment address
	DW		?			;Null offset address
	DW		?			;Attribute - Char
	DW		?			;Strategy routine entry
	DW		?			;Interrupt routine entry
	DB		'EMMXXXX0'		;Character device name
;
; GENERAL FUNCTIONS ENTRY POINT
; ELIM_Entry is a entry point for executing general MEMM
; functions. (e.g. ON, OFF function).
;
ELIM_Entry_off	dw	?		; general entry point

;
;	       MEMM signature
;
emmsig db	?			; MEMM signature

emm_hdr 	ENDS


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA	segment

	extrn	MEMM_State:BYTE 	; initial on/off/auto state
	extrn	MEMM_Call:DWORD 	; far call address into MEMM driver
	extrn	fMEMM_Disabled:BYTE	; NZ if MEMM was disabled

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE	segment

IFNDEF	ROM
		extrn	segDXData:WORD
ENDIF

EMMDevNameRM    DB      "EMMXXXX0"      ;Character device name

MEMMsig         db      'MICROSOFT EXPANDED MEMORY MANAGER 386'
MEMMsiglen      equ     $ - MEMMsig

CEMMsig         db      'COMPAQ EXPANDED MEMORY MANAGER 386'
CEMMsiglen      equ     $ - CEMMsig

DXCODE	ends


DXPMCODE segment

DXPMCODE ends


; -------------------------------------------------------
	subttl	MEMM/CEMM/EMM386 Disable Routines
        page
; -------------------------------------------------------
;	    MEMM/CEMM/EMM386 DISABLE ROUTINES
; -------------------------------------------------------

DXCODE	segment
	assume	cs:DXCODE

; -------------------------------------------------------
;   EMMDisable -- This routine attempts to disable any installed
;	MEMM/CEMM/EMM386 driver.
;
;   Input:  none
;   Output: CY off - EMM driver disabled (or not installed)
;	    CY set - EMM installed, and can't disable
;   Errors:
;   Uses:   All registers preserved

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	EMMDisable

EMMDisable	proc	near

	pusha
	push	ds
	push	es

	call	Check_for_EMM_Driver	;is there and EMM driver?
	jc	emmd_ok 		;  no, then we're already done

	call	MEMM_Inst_chk		;is it one we know about?
	jc	emmd_bad		;  no, then we can't disable it

; Get the current EMM driver state before checking for open handles.  The
; process of checking for handles may change the driver from AUTO to ON.

	xor	ax,ax			; get & save current emm state
	call	[MEMM_Call]		; returns ah = 0 - on, 1 - off,
	mov	MEMM_state,ah		;   2 - auto & off, 3 - auto & on

	call	AnyMEMMHandles		;does it have any handles allocated?
	jc	emmd_bad		;  yes, then we can't disable it

	call	TurnMEMMOff		;try to disable it
	jc	emmd_bad

	mov	fMEMM_Disabled,1	;remember that we disabled MEMM

emmd_ok:
	clc			;indicate disabled (or not installed)

emmd_ret:
	pop	es
	pop	ds
	popa

	ret

emmd_bad:
	stc				;can't disable!
	jmp	short emmd_ret

EMMDisable	endp


; -------------------------------------------------------
;	Windows/386 EMM Disable Code
; -------------------------------------------------------

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING

BeginProc macro name
name	proc	near
	endm

EndProc macro	name
name	endp
	endm

;--------------------------------------------------------

;******************************************************************************
;
;       MEMM_Inst_chk - Check to see if MEMM/CEMM is already installed
;
;       ENTRY:
;           Know there is an EMM driver so INT 67 vector points to something
;
;       EXIT:
;           Carry set
;             No MEMM/CEMM driver
;           Carry Clear
;               [entry_seg] = segment of driver header
;               [entry_off] = offset of status routine in MEMM
;
;	USES: AX,CX,SI,DI,FLAGS
;
;******************************************************************************

	assume	ds:NOTHING, es:NOTHING

BeginProc MEMM_Inst_chk

	push	ds
	push	es

        xor     ax,ax
        mov     ds,ax
        mov     ax,word ptr ds:[(67h * 4)+2]   ; get segment pointed to by int 67
        mov     ds,ax
        mov     si,emmsig
        cld                             ; strings foward
        mov     di,offset MEMMsig
        push    cs
        pop     es
        mov     cx,MEMMsiglen
        cld
        repe    cmpsb                   ; q: is the MEMM signature out there?
        je      short found_sig         ; y: return one
        mov     si,emmsig
        mov     di,offset CEMMsig
        mov     cx,CEMMsiglen
        cld
        repe    cmpsb                   ; q: is the CEMM signature out there?
        jne     short Not_Found         ; n: done, not found

found_sig:
IFDEF	ROM
	GetRMDataSeg
	mov	es,ax
ELSE
	mov	es,segDXData
ENDIF
	xor	si,si
	mov	word ptr es:[MEMM_Call+2],ds	; save segment for far call
	mov	cx,ds:[si.ELIM_Entry_off]
	mov	word ptr es:[MEMM_Call],cx	; Offset for far call

        clc

MEMM_Inst_Done:
	pop	es
	pop	ds
        ret

Not_Found:
        stc
        jmp     short MEMM_Inst_Done

EndProc MEMM_Inst_chk

;******************************************************************************
;
;   TurnMEMMOff
;
;       Turn MEMM off (CEMM, IEFF, MEMM)
;
;       ENTRY:
;           entry_seg entry_off set to CEMM/MEMM enable disable routine
;
;       EXIT:
;           Carry Set
;               Could not disable EMM
;           Carry Clear
;               MEMM CEMM EMM turned off
;
;       USES: EAX,FLAGS
;
;******************************************************************************

	assume	ds:DGROUP, es:NOTHING

BeginProc TurnMEMMOff

	cmp	MEMM_state,1		; MEMM already off?
	jz	short memm_off		; yes, nothing to do

	mov	AX,0101h		; no, turn it OFF
	call	[MEMM_Call]
	jc	short memm_err
memm_off:
        clc
memm_done:
        ret

memm_err:
        stc                             ; Error, set carry
        jmp     short memm_done

EndProc TurnMEMMOff

;******************************************************************************
;
;   AnyMEMMHandles/Check_For_EMM_Handles
;
;       Are there any open MEMM handles
;
;       ENTRY:
;           entry_seg entry_off set to CEMM/MEMM enable disable routine
;
;       EXIT:
;           Carry Set
;               There are open handles
;           Carry Clear
;               There are no open handles
;
;       USES: EAX,EBX,ECX,FLAGS
;
;******************************************************************************

	assume	ds:DGROUP, es:NOTHING

BeginProc AnyMEMMHandles

        mov     ax,4600h
        int     67h
        cmp     ah,EMM_OK
        jne     short memm_is_off
        mov     cx,ax
        mov     ax,4B00h
        int     67h
        cmp     ah,EMM_OK
        jne     short memm_is_off
        cmp     cl,40h
        jb      short Check_Cnt
        or      bx,bx                   ; Don't dec through 0!!!
        jz      short Check_Cnt
        dec     bx                      ; Do not include handle 0 on 4.0 drivers
Check_Cnt:
        cmp     bx,0
        stc
        jne     short HaveHandles
memm_is_off:
        clc
HaveHandles:
        ret

EndProc AnyMEMMHandles

;******************************************************************************
;
;   Check_For_EMM_Driver
;
;       See if an EMM driver is around
;
;       ENTRY:
;           None
;
;       EXIT:
;           Carry Set
;               No EMM driver around
;           Carry Clear
;               EMM driver is around
;
;	USES: AX,CX,SI,DI,FLAGS
;
;******************************************************************************

	assume	ds:NOTHING,es:NOTHING

BeginProc Check_For_EMM_Driver

	push	ds
	push	es

; Note, DS:SI & ES:DI used to be swapped, but on at least one system where
; Int 67h pointed to F000 and there was not ram or rom at F000:000A (rom
; started at F0000:8000), bus noise made the compare work when it shouldn't
; have.  Swapping ES:DI / DS:SI corrected this.

        xor     ax,ax
	mov	es,ax
	mov	ax,word ptr es:[(67h * 4)+2]	; get segment pointed to by int 67
	mov	es,ax
	mov	di,000Ah			; Offset of device name
	mov	si,offset EMMDevNameRM
        push    cs
	pop	ds
        mov     cx,8
        cld
        repe    cmpsb
        jne     short NoEMM_Seen
        clc

EMMTstDone:
	pop	es
	pop	ds
        ret

NoEMM_Seen:
        stc
        jmp     short EMMTstDone

EndProc Check_For_EMM_Driver


; -------------------------------------------------------

DXCODE	ends

;****************************************************************

endif		; NOT VCPI

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
if ?uf
?pas = ?pas and (not (?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxbug.asm ===
PAGE    ,132
        TITLE   DXBUG.ASM -- Dos Extender Debug Services

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXBUG.ASM      -   Dos Extender Debug Services          *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains protect mode debug services for the    *
;*  DOS extender.                                               *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  11/17/89 Jimmat     Added TraceBug stuff for debugging on   *
;*                      286 machines.                           *
;*  03/09/89 JimMat     Initial version.                        *
;*                                                              *
;****************************************************************

.286p
.287

ifndef DEBUG
DEBUG   =       0
endif


; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include     segdefs.inc
include     gendefs.inc
include     pmdefs.inc

if DEBUG   ;********** ENTIRE FILE IS DEBUG CODE ***********


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   fDebug:BYTE
        extrn   fTraceBug:WORD


;******************************************************************************
;
;   DXOutputDebugStr
;
;   Basically stolen from Windows/386 code by Ralph Lipe -- hacked up for
;   286 instead of 386.  Here in RalphL's own words is the description:
;
;   DESCRIPTION:
;       The following code is not pretty but it does what it needs to.  It will
;       only be included in DEBUG versions of Win386.  It accepts an ASCIIZ
;       string which it will output to the COM1 serial port.  If the string
;       contains #(Register) (for example #AX) then the value of that register
;       will be output.  It will not work for segment registers.
;
;       If the string contains ?(Register)[:(Register)] (for example ?AX or
;       ?AX:BX) then the value of the register(s) is passed to the debugger
;       to display the label nearest to the given address.  (It, also, will
;       not work with segment registers.  If ?AX is given, then the segment is
;       assumed to be the DX code segment.
;
;   ENTRY:
;       DS:SI -> ASCIIZ string
;
;   EXIT:
;       All registers and flags trashed
;
;   ASSUMES:
;       This procedure was called by the Trace_Out macro.  It assumes that
;       the stack is a pushad followed by a FAR call to this procedure.
;
;------------------------------------------------------------------------------

Reg_Offset_Table LABEL WORD                     ; Order of PUSHA
        dw      "DI"
        dw      "SI"
        dw      "BP"
        dw      "SP"
        dw      "BX"
        dw      "DX"
        dw      "CX"
        dw      "AX"

DXDATA  ends

DXCODE segment
        assume  cs:DXCODE

        public  DXOutDebugStr

DXOutDebugStr   proc    far

        push    bp
        mov     bp, sp                      ; Assumes BP+6 = Pusha
        pushf
        push    es

        push    SEL_DXDATA                  ; Address our own data seg
        pop     es
        assume  ds:NOTHING,es:DGROUP

        cld
        cli

OSC1_Loop:
        lodsb                               ; Get the next character
        test    al, al                      ; Q: End of string?
        jz      short OSC1_Done             ;    Y: Return
        cmp     al, "#"                     ;    N: Q: Special register out?
        je      SHORT OSC1_Hex              ;          Y: Find out which one
        cmp     al, "?"                     ;       Q: special lable out?
        je      short OSC1_Label            ;          Y: find out which one
        cmp     al, "@"                     ;       Q: special string out?
        je      short OSC1_Str
OSC1_out:
        xor     ah, ah                      ;          N: Send char to COM
        call    Out_Debug_Chr
        jmp     OSC1_Loop                   ; Loop until done

OSC1_Hex:
        call    Get_Register
        jnc     short OSC1_not_special

        cmp     bl, 2                       ; Q: Word output?
        jb      SHORT OSC1_Out_Byte         ;    N: display byte
OSC1_Out_Word:
        call    Out_Hex_Word                ; Display AX in hex
        jmp     OSC1_Loop                   ; Output next char

OSC1_Out_Byte:
        xchg    al, ah                      ; swap bytes to print just
        call    Out_Hex_Byte                ; the low one!
        jmp     OSC1_Loop                   ; Output next char

OSC1_Label:
        call    Get_Register
        jc      short show_label
OSC1_not_special:
        lodsb                               ; Get special char again
        jmp     OSC1_out                    ; display it, and continue

show_label:
        mov     cx, ax                      ; save first value
        cmp     byte ptr [si], ':'          ;Q: selector separator?
        jne     short flat_offset           ;  N:
        lodsb                               ;  Y: eat the ':'
        call    Get_Register                ;   and attempt to get the selector
        jc      short sel_offset
flat_offset:
        mov     ax, cs                      ; default selector value
sel_offset:
        call    Show_Near_Label
        jmp     OSC1_Loop

OSC1_Str:
        call    Get_Register
        jnc     short OSC1_not_special
        mov     cx,ax
        cmp     byte ptr [si],':'
        jne     short no_selector
        lodsb
        push    cx
        call    Get_Register
        pop     cx
        xchg    ax,cx
        jc      short got_sel_off
        mov     cx,ax
no_selector:
        mov     ax,ds                       ; default selector for strings
got_sel_off:
        call    Show_String
        jmp     OSC1_Loop

OSC1_Done:                                  ; The end

        pop     es
        npopf
        pop     bp
        ret     10h

DXOutDebugStr   endp


;******************************************************************************
;
;   Get_Register
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:           Carry set if register value found
;                       AX = register value
;                       BL = value size   (1, 2, 4)
;
;   USES:
;
;==============================================================================


Get_Register    proc    near

        push    si                          ; Save string pointer
        xor     ax, ax                      ; Zero AX
        mov     bl, 2                       ; BL = 2 (assume word output)
        call    Load_Up_Char                ; Get 1st char
        mov     ah, al                      ; Move 1st char to AH
        call    Load_Up_Char                ; Get second char
        cmp     al, 'L'                     ; Q: "L" (ie AL, BL, etc)?
        jne     short OSC1_WORD             ;    N: word reg
        mov     al, 'X'                     ;    Y: change to X for pos match
        mov     bl, 1                       ;       BL = 1 -- byte output
OSC1_WORD:
        xor     di, di                      ; DI = 0
        mov     cx, 8                       ; Size of a pusha
OSC1_Special_Loop:
        push    di
        shl     di,1
        cmp     ax, Reg_Offset_Table[di]    ; Q: Is this the register?
        pop     di
        je      SHORT OSC1_Out_Reg          ;    Y: Output it
        inc     di                          ;    N: Try the next one
        loop    OSC1_Special_Loop           ;       until CX = 0

OSC1_Ignore_Special:                        ; OOPS!  backup and ignore special
        pop     si                          ; Restore original string ptr
        dec     si                          ; back up to special char
        clc
        jmp     short gr_exit

OSC1_Out_Reg:
        push    di
        shl     di,1
        mov     ax, SS:[bp.6][di]           ; AX = Value to output
        pop     di
        add     sp, 2                       ; Trash pushed SI
        cmp     bl, 2                       ;Q: byte or word value?
        je      short value_fnd             ;      jump if word value
        xor     ah, ah                      ;      clear ah, if byte value
value_fnd:
        stc

gr_exit:
        ret

Get_Register    endp


;******************************************************************************
;
;   Load_Up_Char
;
;   Moves the character at DS:SI into AL and converts it to an upper case
;   character.  SI is incremented.
;
;------------------------------------------------------------------------------

Load_Up_Char    proc    near

        lodsb
        cmp     al, "Z"
        jb      SHORT LUC_Done
        sub     al, "a" - "A"
LUC_Done:
        ret

Load_Up_Char    endp


;******************************************************************************
;
;   Out_Hex_Word
;
;   Outputs the value in AX to the COM port in hexadecimal.
;
;------------------------------------------------------------------------------

Out_Hex_Word    proc    near

        rol     ax, 4
        call    Out_Hex_Char
        rol     ax, 4
        call    Out_Hex_Char
Out_Hex_Byte:
        rol     ax, 4
        call    Out_Hex_Char
        rol     ax, 4
        call    Out_Hex_Char

        ret

Out_Hex_Word    endp


;******************************************************************************
;
;   Out_Hex_Char
;
;   Outputs the low nibble in AL to the COM port.
;
;------------------------------------------------------------------------------

DXDATA  segment

Hex_Char_Tab LABEL BYTE
        db      "0123456789ABCDEF"

DXDATA  ends

Out_Hex_Char    proc    near

        push    ax
        push    bx
        mov     bx, ax
        and     bx, 1111b
        mov     al, Hex_Char_Tab[bx]
        call    Out_Debug_Chr
        pop     bx
        pop     ax
        ret

Out_Hex_Char    endp


;******************************************************************************
;
;   Out_Debug_Chr
;
;   DESCRIPTION:
;
;   ENTRY:
;       AL contains character to output
;
;   EXIT:
;
;   USES:
;       Nothing
;
;==============================================================================

Out_Debug_Chr   proc    near
        assume ds:nothing,es:DGROUP

if 0
        push    ax
        mov     ax,cs
        cmp     ax,SEL_DXCODE0          ; Are we in real mode?
        pop     ax
        jne     out_com

        cmp     fDebug,0                ; debugger installed?
        je      out_com                 ; N: go output it ourselves

        push    ax
        push    dx
        mov     dl, al
        mov     ax, DS_Out_Char
        int     Debug_Serv_Int
        pop     dx
        pop     ax
endif
        ret

Out_Debug_Chr   endp

;******************************************************************************
;
;   Show_Near_Label
;
;   DESCRIPTION:    call the debugger to display a label less than or equal
;                   to the given address
;
;   ENTRY:          AX is selector, CX is offset of address to try to find
;                   a symbol for
;                   ES selector to DOSX data segment
;   EXIT:
;
;   USES:
;
;==============================================================================

Show_Near_Label proc    near

if 0
        push    ax
        mov     ax,cs
        cmp     ax,SEL_DXCODE0          ; Are we in real mode?
        pop     ax
        jne     Show_Near_Label_ret

        cmp     es:idCpuType,3                  ;use 32 bit regs?
        jae     debug_386

        push    ax                              ;on a 286, use 16 bit regs
        push    bx
        push    cx
        mov     bx,cx
        mov     cx,ax
        mov     ax,DS_Out_Symbol
        int     Debug_Serv_Int
        pop     cx
        pop     bx
        pop     ax
endif
        ret

if 0
debug_386:
        .386p
        push    eax
        push    ebx
        push    ecx

        mov     bx, cx

        movzx   ecx, ax                         ;WDEB386 wants a 32 bit offset

        mov     ax, DS_Out_Symbol
        int     Debug_Serv_Int

        pop     ecx
        pop     ebx
        pop     eax
        ret

        .286p

Show_Near_Label_ret:
endif

Show_Near_Label endp


;******************************************************************************
;
;   Show_String
;
;   DESCRIPTION:    Display an asciiz string
;
;   ENTRY:          AX is selector, CX is offset of address to find string
;
;   EXIT:
;
;   USES:
;
;==============================================================================

Show_String     proc    near

if 0
        push    ax
        push    ds
        push    si

        mov     ds,ax
        mov     si,cx
        xor     ax,ax
@@:
        lodsb
        or      al,al
        jz      @f
        call    Out_Debug_Chr
        jmp     short @b
@@:
        pop     si
        pop     ds
        pop     ax
endif

        ret

Show_String     endp


DXCODE  ends

endif   ; DEBUG

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxemm2.asm ===
PAGE	,132
	TITLE	DXEMM2.ASM  -- Dos Extender MEMM Enable Code

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	DXEMM2.ASM     -- Dos Extender MEMM Enable Code
;
;-----------------------------------------------------------------------
;
; This module provides routines that attempt to enable MEMM/CEMM/EMM386
; drivers.  DOSX tries to disable MEMM when starting up, and enables MEMM
; when terminating.
;
; NOTE: This code is in a seperate file from the disable logic because
;	the disable code is discarded after initialization.
;
;-----------------------------------------------------------------------
;
;  12/08/89 jimmat  Finally got around to implementing this.
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

if NOT VCPI

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA	segment

		public	fMEMM_Disabled, MEMM_State, MEMM_Call

fMEMM_Disabled	db	0		; NZ if MEMM disabled
MEMM_state	db	0		; Initial MEMM state

MEMM_Call	dd	0		; far call address into EMM driver

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

DXCODE	ends


DXPMCODE segment

DXPMCODE ends


; -------------------------------------------------------
	subttl	MEMM/CEMM/EMM386 Enable Routines
        page
; -------------------------------------------------------
;	    MEMM/CEMM/EMM386 ENABLE ROUTINES
; -------------------------------------------------------

DXCODE	segment
	assume	cs:DXCODE

; -------------------------------------------------------
;   EMMEnable -- This routine attempts to re-enable any installed
;	MEMM/CEMM/EMM386 driver.
;
;   Input:  none
;   Output: CY off - EMM driver enabled (or never disabled)
;	    CY set - EMM installed, and can't disable
;   Errors:
;   Uses:   All registers preserved

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	EMMEnable

EMMEnable	proc	near

	push	ax

	cmp	fMEMM_Disabled,0	; Did we disable MEMM before?
	jz	enable_exit		;   no, don't need to enable then

	mov	ah,01			; Set state command
	mov	al,MEMM_state		; Get initial state
	cmp	al,2			; They return 0 (on), 1 (off),
	jbe	@f			;   2 (auto on), 3 (auto off) -- but
	mov	al,2			;   we can only set 1 - 2
@@:
	call	[MEMM_Call]		;   and restore it
	jc	not_enabled

	mov	fMEMM_Disabled,0	; no longer disabled

	clc
	jmp	short enable_exit

not_enabled:
	stc

enable_exit:
	pop	ax

	ret

EMMEnable	endp

; -------------------------------------------------------

DXCODE	ends

;****************************************************************

endif			; NOT VCPI

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxend.asm ===
PAGE	,132
        TITLE   DXEND.ASM  -- Special End Module for Dos Extender

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXEND.ASM       -   Dos Extender End Module             *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains the definition for special symbols     *
;*  which define the end of the Dos Extender code and data      *
;*  segments.  It must be the last module linked in the         *
;*  Dos Extender.                                               *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*								*
;*  01/09/90 jimmat   Remove DataEnd symbol since it wasn't     *
;*		      really useful.				*
;*  08/20/89 jimmat   Removed A20 space since HIMEM 2.07 works	*
;*		      properly across processor resets		*
;*  08/02/89 jimmat   Moved CodeEndPM to DXENDPM.ASM		*
;*  07/21/89 jimmat:  Added space for A20 handler		*
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*      medium model                                            *
;*  09/20/88 (GeneA):   created                                 *
;*                                                              *
;****************************************************************
;
; -------------------------------------------------------
;               INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include segdefs.inc
include gendefs.inc
include pmdefs.inc
if VCPI
include dxvcpi.inc
endif

; -------------------------------------------------------
;               CODE SEGMENT DEFINITIONS
; -------------------------------------------------------
;
DXCODE  segment
        assume  cs:DXCODE

        public  CodeEnd


if VCPI

if1
%OUT VCPI option not ROMable.
endif

CodeEnd	db ( LDTOFF + CBPAGE386 ) dup (0)

else

CodeEnd:

endif ; VCPI

DXCODE  ends


;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxfind.asm ===
PAGE	,132
	TITLE	DXFIND.ASM  -- Dos Extender Find File Routine

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;***********************************************************************
;
;	DXFIND.ASM	-- Dos Extender Find File Routine
;
;-----------------------------------------------------------------------
;
; This module provides the locate file logic for the 286 DOS Extender.
;
;-----------------------------------------------------------------------
;
;  09/27/89 jimmat  Original version -- considerable code taken from
;		    old GetChildName routine in dxinit.asm.
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

	extrn	strcpy:NEAR
	extrn	toupper:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

	extrn	segPSP:WORD
	extrn	rgbXfrBuf1:BYTE

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE	segment

szPath	  db	'PATH',0
szWindir  db	'WINDIR',0

DXCODE	ends


; -------------------------------------------------------
	subttl	Find File Routine
        page
; -------------------------------------------------------
;		  FIND FILE ROUTINE
; -------------------------------------------------------

DXCODE	segment
	assume	cs:DXCODE

; -------------------------------------------------------
;   FindFile -- This routine is used to locate a particular file.
;	If successful, this routine will setup the buffer in rgbXfrBuf1
;	at offset EXEC_PROGNAME with the string for the file name that
;	can be used in a DOS open call.
;
;	This routine searches for the file in the following sequence:
;
;	     1) If the file name contains a relative or complete path
;		component, only look for that particular file,
;
;	     otherwise:
;
;	     1) Look int the environment for a WINDIR= variable, and if
;		found, check that directory first.
;	     2) Look in the directory the dos extender was loaded from
;	     3) Look in the current directory
;	     4) Look in all directories in the PATH environment variable
;
;	NOTE: This routine must be called in real mode!
;
;   Input:  RELOC_BUFFER has the file name to search for.
;	    EXEC_DXNAME has the complete path the dos extender
;   Output: EXEC_PROGNAME has complete path to child program.
;   Errors: returns CY set if unable to find child
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
	public	FindFile

FindFile proc  near

	pusha
	push	ds
	push	es

        push    ds
        pop     es
        assume  es:DGROUP

; If the base file name contains a ':' '\' or '/', then we'll see if the
; file can be found with that name.  This isn't exactly the way Windows wants
; us to search for kernel, but allows a user to specify a relative or complete
; path on the command line.  If we get run for Windows/286 pMode, the base
; child name will not include any of these characters, so we will not make
; this check.

	mov	si,offset RELOC_BUFFER
@@:	lodsb
	or	al,al
	jz	fndf20		;no path characters, go do other search
	cmp	al,':'
	jz	fndf10
	cmp	al,'\'
	jz	fndf10
	cmp	al,'/'
	jnz	@b

; The name seems to include a path component.  We just want to look for that
; file, and only that file.

fndf10: mov	si,offset RELOC_BUFFER
        mov     di,offset EXEC_PROGNAME
        mov     dx,di
	call	strcpy

	mov	ax,4300h		;use get file attributes to check
	int	21h
	jmp	fndf90			;found it or not, either way we're done

; The file name doesn't include a path component.  If we were run for pMode
; Windows, the environment should include a WINDIR= entry that points to
; the Windows directory.  Look for this env variable, and check that directory
; first.

fndf20:
	push	es				;look for the
	push	cs				;WINDIR= env variable
	pop	es
	assume	es:NOTHING
	mov	di,offset DXCODE:szWindir
	call	GetEnv
	pop	es
	assume	ds:NOTHING,es:DGROUP

	jnz	fndf_dosx_dir

; Found WINDIR, copy over the path name, add child name and search

	mov	di,offset EXEC_PROGNAME ;copy WINDIR path
	mov	dx,di
	call	strcpy

	cmp	byte ptr es:[di-1],'\'  ;add trailing \ if necessary
	jz	@f
	mov	byte ptr es:[di],'\'
	inc	di
@@:
	push	es			;ds back to DGROUP
	pop	ds
	assume	ds:DGROUP

	mov	si,offset RELOC_BUFFER	;add child name
	call	strcpy

	mov	ax,4300h		;use get file attributes to check
	int	21h
	jc	fndf_dosx_dir		;no there, go do next check
	jmp	fndf90			;found it!

; Next, we try looking in the directory that the Dos Extender was loaded
; from.  Start with the complete path to the Dos Extender program file.

fndf_dosx_dir:

	push	es
	pop	ds
	assume	ds:DGROUP

	mov	si,offset EXEC_DXNAME
        mov     di,offset EXEC_PROGNAME
        mov     dx,di
	call	strcpy

; Now, search backward from the end of the string until we find the
; first backslash or colon.  This will take us back past the file name
; and leave us with the raw path.

fndf24: dec	di
        cmp     di,dx           ;check if we have gone back past the start
                                ; of the string.  (DX still has the address
                                ; of the start of the buffer from above)
	jb	fndf_cd 	;and if so skip this part as the path is null.
        mov     al,es:[di]
        cmp     al,':'
	jz	fndf26
        cmp     al,'\'
	jnz	fndf24

; Add the file name string onto the raw path and see if the file exists.

fndf26: inc	di
        mov     si,offset RELOC_BUFFER
	call	strcpy

	mov	ax,4300h		;use get file attributes to check
	int	21h
	jc	fndf_cd
        jmp     fndf90

; We didn't find the file in the same directory as the Extender itself.
; Now, try looking for the file in the current directory!

fndf_cd:
	mov	di,offset EXEC_PROGNAME ;build current directory path string
	dossvc	19h
	add	al,'A'
	stosb				;drive letter

	mov	ax,'\:'
	stosw

	xor	dl,dl
	mov	si,di
	dossvc	47h			;current directory

        mov     al,es:[di]              ;check if it's the root
        or      al,al                   ;empty string?
        jz      short fndf_cd_cpy       ;yes, don't add another '\'

@@:	lodsb				;find end of string
	or	al,al
	jnz	@b

	mov	byte ptr [si-1],'\'     ;add ending \

fndf_cd_cpy:
	mov	di,si			;add base child name
	mov	si,offset RELOC_BUFFER
	call	strcpy

	mov	dx,offset EXEC_PROGNAME ;use get file attributes to check
	mov	ax,4300h
	int	21h

	jc	fndf30
	jmp	short fndf90

; We didn't find it in the current directory, look at the PATH
; environment variable and see if the file can be found in any of
; its directories.  First off, search for the PATH environment
; string.

fndf30:
	push	es
	mov	di,offset DXCODE:szPath 	;point ES:DI to path str
	push	cs
	pop	es
	assume	es:NOTHING

	call	GetEnv				;find the path env var
	assume	ds:NOTHING

	pop	es
	assume	es:DGROUP

	jnz	fndf80				;Z flag set if FOUND

; We are pointing at the beginning of the path environment variable.  We need
; to loop for each directory specified to see if we can find the file in
; that directory.

	mov	bx,ds		;keep env segment in BX

fndf40: mov	ds,bx		;environment segment to DS
	assume	ds:NOTHING
	mov	al,ds:[si]
	or	al,al		;check for end of path variable.
	jz	fndf80		;if so, we didn't find any directory with
				; the desired file in it.

        mov     di,offset EXEC_PROGNAME
fndf42: lods	byte ptr [si]
	cmp	al,';'		;is it the separator between strings in
	jz	fndf52		; the environment variable?
	or	al,al		;is it the 0 at the end of the environment
	jz	fndf50		; string?
        stos    byte ptr [di]
	jmp	fndf42

fndf50: dec	si
fndf52: push	si		;save pointer to start of next string
	mov	al,'\'
	cmp	al,byte ptr es:[di-1]  ;dir name already end with \ (root dir?)
	jnz	fndf54
	dec	di		       ;  yes, don't make it two \'s
fndf54: stos	byte ptr [di]
	mov	si,offset RELOC_BUFFER ;pointer to file base name
	mov	ax,es		       ;put our data segment address in DS
	mov	ds,ax
	assume	ds:DGROUP
	call	strcpy		;append file base name to path

	mov	ax,4300h	;use get file attributes to check
	int	21h

	pop	si		;restore pointer to start of next string
	jc	fndf40
	jmp	short fndf90

; Unable to find the file

fndf80: stc

; Finished, successful or not

fndf90:
	pop	es
	pop	ds
	popa
	ret

FindFile  endp


; -------------------------------------------------------
;   GetEnv -- This routine searches the environment for a
;	specific variable.
;
;   Input:  ES:DI   - far pointer to wanted variable name
;   Output: DS:SI   - far pointer to variable value string
;   Errors: return Z true if variable located
;   Uses:   DS:SI modified, all else preserved

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	GetEnv

GetEnv	proc	near

	push	ax
	push	dx
	push	di

; Point DS:SI to our environment block

	mov	ds,segPSP
        assume  ds:PSPSEG
	mov	ds,segEnviron
	xor	si,si
        assume  ds:NOTHING

; See if DS:SI is pointing at desired environment variable

	mov	dx,di			;keep var name offset in dx

gete10:
	cmp	byte ptr es:[di],0	;at end of variable name?
	jz	gete50			;  yes, go check '=' & optional blanks

gete20:
	lodsb				;get variable char
	call	toupper 		;just in case...
	cmp	al,es:[di]		;match desired name so far?
	jnz	gete30			;  no, go find the next var name

	inc	di			;bump var pointer
	jmp	short gete10		;  and keep on checking

gete30:
	mov	di,dx			;reset source name pointer

	or	al,al			;already at end of this env var?!
	jz	gete35

@@:	lodsb
	or	al,al			;find next environment var name
	jnz	@b
gete35:
	cmp	byte ptr ds:[si],0	;at end of environment?
	jz	gete80			;  yes, go fail the call
	jmp	short gete10		;  no, try try again

; Found the env variable, now skip the '=' and any spaces

gete50:
	cmp	byte ptr ds:[si],'='	;when we get here, better be pointing
	jnz	gete30			;  at an '='
	inc	si

@@:	cmp	byte ptr ds:[si],' '	;skip any optional blanks
	jnz	@f
	inc	si
	jmp	short @b
@@:
	xor	ax,ax			;set the Z flag
	jmp	short @f

gete80:
	or	ax,si			;pretty sure this clears Z
@@:
	pop	di
	pop	dx
	pop	ax

	ret

GetEnv	endp

; -------------------------------------------------------

DXCODE	ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxendpm.asm ===
PAGE	,132
	TITLE	DXENDPM.ASM  -- Special End Module for Dos Extender

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*	DXENDPM.ASM	  -   Dos Extender End Module		*
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*								*
;*  This module contains the end symbol for the DOS Extender's  *
;*  protected mode code segment.				*
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*								*
;*  08/02/89 jimmat   Split out from dxend.asm			*
;*  09/20/88 (GeneA):   created                                 *
;*                                                              *
;****************************************************************
;
; -------------------------------------------------------
;               INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include     segdefs.inc

; -------------------------------------------------------
;               CODE SEGMENT DEFINITIONS
; -------------------------------------------------------


DXPMCODE    segment
        assume  cs:DXPMCODE

        public  CodeEndPM
CodeEndPM:

DXPMCODE    ends

;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxhpbios.asm ===
PAGE	,132
	TITLE	DXHPBIOS.ASM  -- Dos Extender HP Extended BIOS Mapping

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;***********************************************************************
;
;	DXHPBIOS.ASM	-- Dos Extender HP Extended BIOS Mapping
;
;-----------------------------------------------------------------------
;
; This module provides the 286 DOS extender's protected-to-real mode
; mapping of selected HP Vectra Extended BIOS services.
;
;-----------------------------------------------------------------------
;
;  08/25/89 jimmat  Original version
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include interupt.inc
IFDEF	ROM
include dxrom.inc
ENDIF
include intmac.inc
include stackchk.inc
include bop.inc

	.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

F_INS_XCHGFIX	equ	06h


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

	extrn	EnterIntHandler:NEAR
	extrn	LeaveIntHandler:NEAR
        extrn   EnterRealMode:NEAR
	extrn	EnterProtectedMode:NEAR
	extrn	ParaToLDTSelector:NEAR
	extrn	PMIntrEntryVector:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA	segment

	extrn	regUserSS:WORD
	extrn	regUserSP:WORD
	extrn	pbReflStack:WORD
        extrn   bReflStack:WORD
	extrn	fHardwareIntMoved:BYTE

	public	HPxBiosVectorRM

HPxBiosVectorRM dd	?	;offset to RM HP Int handler

PMCallBack	dd	0	;protected mode call back CS:IP

HPDriverHeader	dw	?	;segment of HP driver header block

HPDriverSegSel	dw	0,0	;segment/selector pairs
		dw	0,0
		dw	0,0
		dw	-1
DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

IFNDEF	ROM
	extrn	segDXData:WORD
	extrn	selDgroup:WORD
	extrn	PrevInt69Handler:DWORD
ENDIF

DXCODE	ends

; -------------------------------------------------------
	subttl	HP Extended BIOS Mapping Interface
        page
; -------------------------------------------------------
;	     HP EXTENDED BIOS MAPPING INTERFACE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   HPxBIOS  -- Interrupt routine for the HP Vectra Extended
;	BIOS service calls.  Currently, on the F_INS_XCHGFIX
;	service is supported, and this is not mapped transparently!
;	This support was added for the Windows HP mouse driver.
;
;   Input:  Various registers
;   Output: Various registers
;   Errors:
;   Uses:   All registers preserved, other than return values
;
;   The following services are supported:
;
;   AH=06 - F_INS_XCHGFIX		(non transparent pm->rm mapping)
;

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
	public	HPxBIOS

HPxBIOS proc	near

	cmp	ah,F_INS_XCHGFIX	;is this F_INS_XCHGFIX?
	jz	@f

	jmp	PMIntrEntryVector + 3*6Fh  ;if not, just pass it on
@@:
	call	EnterIntHandler 	;build an interrupt stack frame
	assume	ds:DGROUP,es:DGROUP	;  also sets up addressability

	cld				;cya...

; Save the protected mode CS:IP.  NOTE: we only support one call back
; address (the last one)!  This works for the current mouse driver, but
; may not work for other drivers.

	mov	ax,[bp].pmUserDI
	mov	word ptr PMCallBack,ax
	mov	ax,[bp].pmUserES
	mov	word ptr [PMCallBack+2],ax

; Execute the real mode HP Extended BIOS service

	SwitchToRealMode
	assume	ds:DGROUP,es:DGROUP

	xor	ax,ax
	mov	es,ax
	assume	es:NOTHING
	mov	ax,es:[6Fh*4]
	mov	word ptr [HPxBiosVectorRM],ax
	mov	ax,es:[6Fh*4+2]
	mov	word ptr [HPxBiosVectorRM+2],ax

	test	byte ptr [bp].pmUserFL+1,02h	;enable interrupts if
	jz	@f				;  caller had them enabled
	FSTI
@@:
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
	popa

	push	ax			;set our own call back routine,
	mov	ax,cs			;  which will invoke the PM one
	mov	es,ax
	pop	ax
	mov	di,offset RMCallBack

	FCLI
	call	ss:[HPxBiosVectorRM]

        pushf
	FCLI
        pusha
        push    ds
        push    es
	mov	bp,sp			;restore stack frame pointer

IFDEF	ROM
	push	ss
	pop	ds
ELSE
	mov	ds,selDgroup		;HP BIOS seems to change DS on us
ENDIF
	assume	ds:DGROUP

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP

; Perform fixups on the return values.

	mov	ax,[bp].intUserES	;we return real mode ES in BP!
	mov	[bp].intUserBP,ax

	call	LeaveIntHandler 	;restore caller's registers, stack
	assume	ds:NOTHING,es:NOTHING

	iret

HPxBIOS endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
	subttl	HP Pointing Device Handler
        page
; -------------------------------------------------------
;	    HP POINTING DEVICE HANDLER
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

; -------------------------------------------------------
;   RMCallBack -- This routine is the RM entry point for
;	the HP Pointing Device Handler.  It switches the
;	processor to protected mode and transfers control to the
;	user pointing device handler.  When that completes,
;	it switches back to real mode and returns control to
;	the HP BIOS.
;
;   Input:  none
;   Output: none
;   Errors: none

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
	public	RMCallBack

RMCallBack	proc	near

	cld
	push	es		;save BIOS ds/es on it's stack
        push    ds

IFDEF	ROM
	SetRMDataSeg
ELSE
	mov	ds,selDgroup	;setup addressability to DOSX DGROUP
ENDIF
	assume	ds:DGROUP

	mov	HPDriverHeader,es	;save ES driver header block segment

; Allocate a new stack frame, and then switch to the local stack
; frame.

	FCLI			;protect global regUserXX vars

	mov	regUserSP,sp	;save entry stack pointer so we can restore it
	mov	regUSerSS,ss	;save segment too
IFDEF	ROM
	push	ds
	pop	ss
ELSE
	mov	ss,selDgroup	;switch to our own stack frame
ENDIF
        mov     sp,pbReflStack
	sub	pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame

        FIX_STACK
	push	regUserSS	;save HP BIOS stack address
	push	regUserSP	;  so we can restore it later

	push	SEL_DXDATA or STD_RING	;DOSX DS to be poped in PM

	pusha			;save general registers

; We are now running on our own stack, so we can switch into protected mode.

	SwitchToProtectedMode
	assume	ds:DGROUP,es:DGROUP

; See if we've already mapped a selector to the HPDriverHeader segment.  We
; have a table of 3 segment/selector pairs because the current Windows
; mouse driver support up to 3 pointing devices (all with the same call
; back address).

	mov	ax,HPDriverHeader	;get segment to map

	FSTI				;don't need ints disabled now

	mov	bx,offset DGROUP:HPDriverSegSel-4
rmcb_cmp_seg:
	add	bx,4
	cmp	word ptr [bx],ax	;same segment?
	jne	@f
	mov	es,word ptr [bx+2]	;  yes, get selector to ES
	jmp	short rmcb_sel_set
@@:
	cmp	word ptr [bx],0 	;empty table slot?
	je	rmcb_new_seg
	cmp	word ptr [bx],-1	;end of table?
	jne	rmcb_cmp_seg

; Haven't seen this segment before, map a selector for it

rmcb_new_seg:
	mov	cx,ax			;save segment in cx
	mov	dx,bx			;save table offset in dx
	mov	bx,STD_DATA		;want a data selector
	call	ParaToLDTSelector
	jnc	@f			;BIG TROUBLE if can't create selector!
	popa				;  don't even call users routine
	jmp	short rmcb50
@@:
	mov	es,ax
	assume	es:NOTHING

	mov	bx,dx			;save this seg/sel pair if not
	cmp	word ptr [bx],-1	;  at the end of the table
	je	rmcb_sel_set

	mov	word ptr [bx],cx
	mov	word ptr [bx+2],ax

rmcb_sel_set:

	popa				;restore general registers

; Build an iret frame on the stack so that the user's
; routine will return to us when it is finished.

	pushf
        push    cs
	push	offset rmcb50

; Build a far return frame on the stack to use to transfer control to the
; user's protected mode routine

	push	word ptr [PMCallBack+2]
	push	word ptr [PMCallBack]

; At this point the stack looks like this:
;
;   [14]    stack segment of original stack
;   [12]    stack pointer of original stack
;   [10]    protect mode dos extender data segment
;   [8]     flags
;   [6]     segment of return address back to here
;   [4]     offset of return address back here
;   [2]     segment of user routine
;   [0]     offset of user routine

; Execute the user's pointing device handler

	retf

; The users handler will return here after it is finsished.

rmcb50:
	cld
	pop	ds			;restore DOSX DS
	assume	ds:DGROUP,es:NOTHING

	FCLI				;protect global regUserXX vars
        pop     regUserSP
        pop     regUserSS

; Switch back to real mode.

	push	ax			;preserve AX
	SwitchToRealMode
	assume	ds:DGROUP,es:DGROUP
        pop     ax

; Switch back to the original stack.

        CHECK_STACK
        mov     ss,regUserSS
        mov     sp,regUserSP

; Deallocate the stack frame that we are using.

        add     pbReflStack,CB_STKFRAME

; And return to the HP BIOS

        pop     ds
	pop	es

	iret

RMCallBack	endp

; -------------------------------------------------------
	subttl	Classic HP Vectra Keyboard Hook
        page
; -------------------------------------------------------
;	    CLASSIC HP VECTRA KEYBOARD HOOK
; -------------------------------------------------------

IFNDEF	ROM

	public	RMVectraKbdHook
	assume	ds:NOTHING,es:NOTHING,ss:NOTHING

; If the master PIC has been remapped, we process the interrupt ourselves,
; otherwise, we just pass it on to the previous Int 69h handler (which
; is most likely the HP Vectra BIOS).

RMVectraKbdHook proc	near

	push	ds
	mov	ds,segDXData
	assume	ds:DGROUP

	test	fHardwareIntMoved,0FFh	;PIC been remapped?

	pop	ds
	assume	ds:NOTHING

	jnz	@f

	jmp	[PrevInt69Handler]	;  no, get out of the way
@@:
	push	ax

	mov	al,61h			;  yes, EOI the third slave PIC
	out	7Ch,al

	pop	ax

	int	51h			;  and simulate an IRQ 1 interrupt
	iret

RMVectraKbdHook endp

ENDIF

DXCODE	ends

; -------------------------------------------------------

DXPMCODE segment
	 assume cs:DXPMCODE

; -------------------------------------------------------

IFNDEF	ROM

	public	PMVectraKbdHook
	assume	ds:NOTHING,es:NOTHING,ss:NOTHING

PMVectraKbdHook proc	near

	push	ax			;EOI the third slave PIC

	mov	al,61h
	out	7Ch,al

	pop	ax

	int	51h			;simulate an IRQ 1 interrupt

	iret				;back we go

PMVectraKbdHook endp

ENDIF

; -------------------------------------------------------

DXPMCODE  ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxini.asm ===
PAGE    ,132
        TITLE   DXINI.ASM  -- Dos Extender INI File Processing

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXINI.ASM      -- Dos Extender INI FIle Processing
;
;-----------------------------------------------------------------------
;
; This module provides the 286 DOS extender's ...
;
;-----------------------------------------------------------------------
;
;  09/27/89 jimmat    Modified to use FindFile instead of using its
;                     own file search logic
;  05/24/89 w-glenns  Original (UNCUT, UNCENSORED!) version
;
;***********************************************************************

        .286

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
include     intmac.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

CR      equ     13
LF      equ     10
TAB     equ     9
EOF     equ     26


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   strcpy:NEAR
        extrn   FindFile:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   rgbXfrBuf1:BYTE

DXDATA  ends

; -------------------------------------------------------
        subttl  Read INI File Routine
        page
; -------------------------------------------------------
;           READ INI FILE ROUTINE
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

;******************************************************************************
;
;   ReadIniFile
;
;   DESCRIPTION:    read and parse a .INI file for the 286 DOS Extender
;                   initialization.
;
;   ENTRY:          dx points to the file name
;                   bx points to structure to fill with ini fields
;
;   EXIT:           Carry set, if file not found, or not enough memory
;
;   USES:           ax, cx
;
;==============================================================================

        assume  ds:DGROUP
        public  ReadIniFile

ReadIniFile PROC NEAR

        push    es
        push    bx
        push    si
        push    di

        push    ds
        pop     es
        assume  es:DGROUP

        push    bx                      ; ptr to ini structure to fill

        mov     si,dx
        mov     di,offset RELOC_BUFFER  ; FindFile wants the name here
        call    strcpy

        call    FindFile                ; locate the .INI file
        jc      ri_error

        mov     ax,3D00h                ; open the .INI file
        mov     dx,offset EXEC_PROGNAME ; FindFile puts path name here
        int     21h
        jc      ri_error                ; shouldn't happen, but...

        mov     si, ax                  ; file handle

        mov     ah, 48h                 ; alloc DOS conventional memory
        mov     bx, 4096d               ; want 64k block
        int     21h
        jc      ri_error

        pop     dx                      ; ptr to ini structure to fill

        call    parse_ini               ; do the work, and come back
        assume  es:NOTHING

        pushf                           ; save parse_ini flags

        mov     ah, 49h                 ; dealloc DOS conventional memory
        int     21h                     ; es already points to block

        npopf                           ; carry set = problem
ri_end:
        pop     di
        pop     si
        pop     bx
        pop     es
        ret

ri_error:                               ; error exit
        pop     bx                      ; clear stack
        stc                             ; force carry on
        jmp     short ri_end            ; split

ReadIniFile ENDP


;******************************************************************************
;
;   Parse_Ini
;
;   DESCRIPTION:    Read in, and parse the ini file opened
;                   and find the variable values specified
;
;   ENTRY:          ax points to the memory block for the file image buffer
;                   dx points to structure to fill with ini fields
;                   si has the handle to the file opened
;
;   EXIT:           Carry set, if file not found, or not enough memory
;
;   USES:           ax, bx, cx, es
;
;==============================================================================

Parse_Ini PROC NEAR

        push    bp
        push    dx
        mov     bp,dx                   ; bp = index into structure (es:)

        assume  ds:NOTHING
        push    ds

        mov     ds, ax                  ; ptr to mem block

        mov     ah, 3Fh
        mov     bx, si
        mov     cx, 0FFFFh              ; guess extremely high
        xor     dx, dx                  ; offset 0
        int     21h

        pop     es
        assume  es:DGROUP               ; NOTE:!!! es is now data segment !!!

        pushf                           ; save flags from read
        push    ax                      ; save # bytes read

        mov     ah, 3Eh                 ; close file
        mov     bx, si
        int     21h

        pop     di                      ; number bytes read
        npopf                           ; CY flag

        jnc     @f
        jmp     parse_done_jump   ; if couldn't read, return bad
@@:

        mov     byte ptr ds:[di], EOF   ; write EOF char'r in case none present

        ; ds:si    points to the file image buffer
        ; es:di/bx structure to fill with ini stuff
        xor     si,si

        ; search until section found
find_section:
        call    Get_Char
        jc      short parse_done_jump   ; end of file, and section not found
        cmp     al, '['                 ; a section ?
        jne     short find_section

        mov     di, bp                  ; point to ini structure
        ; a section has been found, but is it the right one ?
        xor     bx, bx                  ; use as secondary index
cmp_section:
        mov     al, byte ptr ds:[si+bx] ; char'r from section name in file

        inc     bx                      ; bx starts at zero for file pointer
                                        ; index, and starts at one for
                                        ; structure index
        mov     ah, byte ptr es:[di+bx]
        or      ah, ah
        jz      short find_keyword_start ; yes: found the right section !

        call    Conv_Char_Lower         ; convert char'r in AL to lower case
        cmp     al, ah                  ; same so far ?
        jne     short find_section
        jmp     short cmp_section

find_keyword_start:
        add     si,bx                   ; update file pointer past section name

        add     bp,bx                   ; update structure ptr past section name

        ; now that section is found, want to find keywords
find_keyword:
        call    Get_Char                ; points to 1st char'r of next keyword
        jc      short parse_done_jump   ; end of file, and keyword not found

        cmp     al, '['                 ; new section ?
        je      short parse_done_jump   ; hit a new section, so we're done

search_keyword:
        xor     di,di
        ; use beginning of file image buffer for temporary storage of the
        ; keyword name currently being checked

find_keyword_loop:
        mov     byte ptr ds:[di], al    ; copy the char'r
        inc     di

        mov     dx,si                   ; save position in file image buffer
        call    Get_Char                ; points to 1st char'r of next keyword
        jc      short parse_done_jump   ; end of file, and keyword not found
        pushf
        cmp     al, '='
        je      short compare_keyword
        ; yes: found a keyword, lets do some comparisons

        npopf
        jz      short find_keyword_loop ; no white space yet...copy keyword

skip_keyword:
        ; white space has been skipped, yet there is no '='
        ; must be an error...ignore, and get next keyword
        mov     si,dx                   ; point to last char'r in keyword
        mov     byte ptr ds:[si], ';'
        ; fake a comment, so that the rest of the
        ; line is ignored in the next Get_Char call
        ; and the next keyword is pointed to
        jmp     short find_keyword


parse_done_jump:
        jmp     parse_done

        ; char'r is an equals, so compare this keyword to the list
compare_keyword:
        npopf                           ; clean top-of-stack
        mov     byte ptr ds:[di], 0     ; NULL at end of keyword for compare
        mov     bx,bp                   ; get index into INI structure in
                                        ; data segment DGROUP (where es points)

cmp_keyword1:
        xor     di,di                   ; point to start of keyword found

cmp_keyword:
        inc     bx
        mov     ah, byte ptr es:[bx]    ; next char'r in ini struct keyword
        mov     al, byte ptr ds:[di]    ; next char'r of found keyword
        inc     di
        or      al, ah
        jz      short convert_number    ; yes: found the right keyword

        call    Conv_Char_Lower         ; convert char'r in AL to lower case
        cmp     al, ah                  ; same so far ?
        je      short cmp_keyword

        xor     al,al
        dec     bx
cmp_keyword_loop:
        inc     bx
        cmp     byte ptr es:[bx], al    ; next keyword yet?
        jne     cmp_keyword_loop        ; nope: go back until done

        ; keywords don't match..try next key word in ini structure
        inc     bx
        inc     bx                      ; jump over variable space (1 word)
        cmp     byte ptr es:[bx+1], al  ; more keywords to compare with ?
        jne     short cmp_keyword1      ; yes: compare the next one
        jmp     short skip_keyword
        ; no: search file for next keyword

convert_number:
        push    si      ; save current file pointer
        call    Get_Char
        dec     si      ; point to first char'r position in number to convert

        xor     di,di
        mov     ax,di
        mov     cx,ax

        cmp     byte ptr ds:[si], '+'   ; positive number ? (default)
        jne     short cn_1

        inc     si      ; just skip the char'r - positive is default anyway

cn_1:   cmp     byte ptr ds:[si], '-'   ; negative number ?
        jne     short cn_2

        inc     si
        inc     cl      ; negative number - flag so we can negate it later

cn_2:   push    bx
        mov     bx,si   ; save ptr in file buffer - check later if it changed
        push    cx      ; save flag

convert_get_loop:
        mov     cl, byte ptr ds:[si]
        cmp     cl, '0'
        jb      short convert_done
        cmp     cl, '9'
        ja      short convert_done

        sub     cx,'0'                  ; de-ascii'ize cx ==> 0h - 09h

        inc     si                      ; increment pointer
        mov     dx,010d
        mul     dx                      ; multiply ax by 10 : dx is set to zero
        add     ax,cx                   ; add number in
        jmp     short convert_get_loop

convert_done:
        pop     cx                      ; restore -ve/+ve flag
        jcxz    convert_done_1          ; Q: -ve number ?

        neg     ax                      ; negate the number

convert_done_1:
        cmp     si,bx                   ; Q: has index changed, i.e.
                                        ; is the first char'r invalid ?
        pop     bx
        je      short convert_done_2    ; Y: don't save number

        inc     bx                      ; N: point to number in structure
        mov     word ptr es:[bx], ax    ; save value into ini structure

convert_done_2:
        pop     si                      ; get old file pointer
        mov     byte ptr ds:[si], ';'
        ; fake a comment, so that the rest of the
        ; line is ignored in the next Get_Char call
        ; and the next keyword is pointed to
        jmp     find_keyword            ; go back & get another


        ; *** single exit point for parsing code
parse_done:
        mov     ax,es                   ; swap extended and data segment ptrs
        mov     bx,ds
        mov     es,bx
        mov     ds,ax

        pop     dx
        pop     bp
        ret

Parse_Ini ENDP

;******************************************************************************
;
;   Get_Char
;
;   DESCRIPTION:    Local routine which gets the next valid ascii
;                   character from the file image, while skipping white
;                   space.
;
;   ENTRY:          ds:si -> buffer pointer
;
;   EXIT:         ds:si -> new buffer pointer
;                 al   --> character
;               Z flag --> set = no white space between last char'r and current
;               C flag --> set = reached end of file
;
;   USES:           cx
;
;==============================================================================

Get_Char PROC NEAR

        mov     cx,si
        inc     cx

get_char_loop:
        lodsb                           ; get char from file image
        cmp     al,EOF
        je      short get_char_EOF
        cmp     al,CR
        je      short get_char_loop
        cmp     al,LF
        je      short get_char_loop
        cmp     al,TAB
        je      short get_char_loop
        cmp     al,' '
        je      short get_char_loop
        cmp     al,';'
        je      short get_char_skip_comment

        ; must have got a good character finally...
        call    Conv_Char_Lower
        cmp     cx,si                   ; skipped a white space ?
        clc                             ; continue
        ret

get_char_EOF:
        stc                             ; flag end of the file
        ret

get_char_skip_comment:
        lodsb                           ; get char from file image
        cmp     al,EOF
        je      short get_char_EOF
        cmp     al,CR
        jne     short get_char_skip_comment
        jmp     short get_char_loop

Get_Char ENDP

Conv_Char_Lower PROC NEAR

        cmp     al, 'A'                 ; want char'r 'A'-'Z' to be
        jb      short lower_done        ; converted to 'a'-'z'
        cmp     al, 'Z'
        ja      short lower_done
        or      al, 020h                ; convert to lower case
lower_done:
        ret

Conv_Char_Lower ENDP

; -------------------------------------------------------

DXCODE    ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxfunc.asm ===
PAGE    ,132
        TITLE   DXFUNC.ASM  --  Dos Extender Function Handlers

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXFUNC.ASM      - Dos Extender Function Handlers        *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains the functions for handling the Dos     *
;*  Extender user functions.  These are functions called by     *
;*  the client application to request special Dos Extender      *
;*  services.                                                   *
;*                                                              *
;*  Any INT 2Fh requests that aren't Dos Extender functions     *
;*  are handled by switching to real mode and passing control   *
;*  on to the previous owner of the real mode INT 2Fh vector.   *
;*  This is accomplished by jumping into the interrupt          *
;*  reflector entry vector at the location for int 2fh.         *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*   01/09/91 amitc  At switch out time Co-Processor being reset*
;*   11/29/90 amitc  Replaced FnSuspend/FnResume by FnObsolete  *
;*                   These are not needed anymore for 3.1       *
;*   11/29/90 amitc  Modified RMInt2FHandler to respond to the  *
;*                   BuildChain SWAPI call.                     *
;*   11/29/90 amitc  Added a SWAPI CallIn function to be called *
;*                   by the task switcher.                      *
;*   11/16/90 jimmat Added DPMI MS-DOS Extension support        *
;*   08/08/90 earleh Started changes to make DOSX a DPMI server *
;*   8/29/89 jimmat Added real mode Int 2Fh hook                *
;*   6/23/89 jimmat Added DOSX Info Int 2Fh                     *
;*   6/16/89 jimmat Ifdef'd out most DOSX Int 2Fh services      *
;*   6/15/89 jimmat Added suspend/resume Int 2Fh hooks, and     *
;*                  Win/386 compatible Int 31h check            *
;*   6/14/89 jimmat Removed PTRACE hooks & unused DynaLink code *
;*   5/19/89 jimmat Reduce # mode switches by ignoring Win/386  *
;*                  Int 2Fh/1680h idle calls                    *
;*   5/07/89 jimmat Added Int 2Fh protected mode hook to XMS    *
;*                  driver                                      *
;*   3/21/89 jimmat Corrected problem with jmping to wrong int  *
;*                  2Fh handler if not for the DOS extender     *
;*   3/09/89 jimmat Added FNDynaLink function                   *
;*  02/10/89 (GeneA): change Dos Extender from small model to   *
;*          medium model                                        *
;*  01/24/89 (GeneA):   removed all real mode dos extender      *
;*          function handlers.                                  *
;*  09/29/88 (GeneA):   created                                 *
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;*                                                              *
;****************************************************************

        .286p
        .287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include segdefs.inc
include gendefs.inc
include pmdefs.inc
include dosx.inc
include hostdata.inc
include intmac.inc
include dpmi.inc
include stackchk.inc
include bop.inc

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

XMS_INS_CHK     equ     00h     ;Installition check function

WIN386_FUNC     equ     16h     ;Windows Enhanced mode Int 2Fh ID

WIN386_VER      equ     00h     ;Windows 386 version

WIN386_INIT     equ     05h     ;Windows/386 & DOSX startup call

W386_Get_Device_API equ 84h     ;es:di -> device API

DPMI_DETECT     equ     87h     ;WIN386/DPMI detection call


DPMI_VER        equ     005ah   ;version 0.90 served here
DPMI_SUCCESS    equ     0000h   ;zero to indicate success
DPMI_FLAGS      equ     0001h   ;32 bit support
                                ;DPMI client requesting 32-bit support

DPMI_MSDOS_VER  equ     0100h   ;WIN386/DPMI MS-DOS Extensions version 01.00

DPMI_MSDOS_API_GET_VER  equ     0000h   ;Get MS-DOS Extension version call
DPMI_MSDOS_API_GET_LDT  equ     0100h   ;Get LDT Base selector call


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   AllocateSelector:NEAR
        extrn   FreeSelector:NEAR
        extrn   ParaToLinear:NEAR
externFP        NSetSegmentDscr
externNP        NSetSegmentAccess
        extrn   DupSegmentDscr:NEAR
        extrn   XMScontrol:NEAR
IFDEF WOW
        extrn   Wow32IntrRefl:near
ENDIF
        extrn   HookNetBiosHwInt:NEAR

        extrn   AllocateExceptionStack:NEAR

DXSTACK segment

        extrn   rgw2FStack:WORD

DXSTACK ends

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   selPSPChild:WORD
        extrn   segPSPChild:WORD
        extrn   idCpuType:WORD

        extrn   DtaSegment:WORD
        extrn   DtaSelector:WORD
        extrn   DtaOffset:WORD

IFDEF WOW
        extrn   Wow16BitHandlers:WORD
        extrn   selEHStack:WORD
ENDIF
IFDEF WOW_x86
        extrn   FastBop:FWORD
ENDIF

;
; Count of DPMI clients active (that have entered protected mode).
;

        public  cDPMIClients
cDPMIClients    dw      0

        public selCurrentHostData, segCurrentHostData, DpmiFlags, DpmiSegAttr
selCurrentHostData dw 0
segCurrentHostData dw 0
DpmiSegAttr        dw 0
DpmiFlags          dw 0

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   segDXData:WORD
        extrn   PrevInt2FHandler:DWORD

DXCODE  ends


DXPMCODE  segment

        extrn   selDgroupPM:WORD


        EXTRN   MakeLowSegment:PROC

DXPMCODE  ends

; -------------------------------------------------------

DXPMCODE  segment
        assume  cs:DXPMCODE


; WOW
; -------------------------------------------------------
;
; Simulate VCD API's. DX contains function number.
;
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  VCD_PM_Svc_Call

VCD_PM_Svc_Call:
        DPMIBOP VcdPmSvcCall32
        retf


; -------------------------------------------------------
;   XMSfunc - The following routine provides a protected mode
;       service for XMS Int 2Fh services.  Two services are
;       implemented:  XMS driver installation check, and obtain
;       XMS driver control function address.
;
;   Input:  UserAL      - function request
;   Output: UserAL      - XMS driver installed flag, or
;           UserES:BX   - XMS driver control function address
;   Errors: none
;   Uses:   all registers may be used

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  XMSfunc

XMSfunc proc    near

        cmp     al,XMS_INS_CHK          ;XMS driver installation check?
        jnz     @f

        mov     byte ptr [bp].fnsUserAX,80h     ;indicate driver is installed
        ret

@@:

; It must be an obtain XMS driver control function address request

        mov     [bp].fnsUserBX,offset DXPMCODE:XMScontrol
        mov     [bp].fnsUserES,cs

        ret

XMSfunc endp

; -------------------------------------------------------
        subttl  DPMI MS-DOS Extension API
        page
; -------------------------------------------------------
;           DPMI MS-DOS EXTENSION API
; -------------------------------------------------------
;
; The following routine implements the DPMI MS-DOS Extensions
; API.  This API must be 'detected' by the use of the
; DMPI_MSDOS_EXT Int 2F function (above).

        public  DPMI_MsDos_API
DPMI_MsDos_API  proc    far

        cmp     ax, DPMI_MSDOS_API_GET_VER      ;Get version call?
        jne     DPMI_MsDos_API_Not_Ver

        mov     ax,DPMI_MSDOS_VER
        jmp     short DPMI_MsDos_API_Exit

DPMI_MsDos_API_Not_Ver:

        cmp     ax, DPMI_MSDOS_API_GET_LDT      ;Get LDT Base call?
        jne     DPMI_MsDos_Api_Failed
ifdef WOW_x86
        mov     ax,SEL_WOW_LDT or STD_RING      ;  yup, give it to 'em
else
        mov     ax,SEL_LDT_ALIAS or STD_RING    ;  yup, give it to 'em
endif

DPMI_MsDos_API_Exit:

        clc                                     ;Succss
        ret

DPMI_MsDos_API_Failed:

        stc                                     ;Unsupported function
        ret

DPMI_MsDos_API  endp


DXPMCODE  ends

; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE
; -------------------------------------------------------
;
; -------------------------------------------------------
;
;  DPMI_Client_Pmode_Entry -- This routine is the entry
;       point for a DPMI client to switch to protected mode.
;       Reference: DOS Protected Mode Interface Specification 0.9
;                  Section 5.2: Calling the Real to Protected
;                  Mode Switch Entry Point
;
;  Entry: AX = Flags
;               Bit 0 = 1 if program is a 32-bit application
;         ES = Real mode segment of DPMI host data area.  This is the
;               size of the data area we specified in RMInt2FHandler,
;               below.
;
;  Returns:
;       Success: Carry clear.
;                Program is in protected mode.
;                CS = 16-bit selector with base of real mode
;                       CS and a 64k limit.
;                SS = 16-bit selector with base of real mode
;                       SS and a 64k limit.
;                DS = 16-bit selector with base of real mode
;                       DS and a 64k limit.
;                ES = Selector to program's PSP with a 100h
;                       byte limit.
;                80386, 80486:
;                        FS, GS = 0
;                All other registers preserved.
;
;       Failure: Carry flag set.
;                Program is in real mode.
;
;  Exceptions:
;       32-bit programs not (yet) supported.  Any attempt to load
;       a 32-bit program by this mechanism returns failure.
;
;       The only error that can occur here is a failure to allocate
;       sufficient selectors.
;

;
; Structure of the stack frame used to store the client's registers
; while implementing the DPMI protected mode entry.
;

DPMI_Client_Frame STRUC
        Client_ES       dw      ?       ; Client's ES
        Client_DS       dw      ?       ; Client's DS
        Client_DI       dw      ?       ; Client's DI
        Client_SI       dw      ?       ; Client's SI
        Client_Pusha_BP dw      ?       ; BP at pusha
        Client_Pusha_SP dw      ?       ; SP at pusha
        Client_BX       dw      ?       ; Client's BX
        Client_DX       dw      ?       ; Client's DX
        Client_CX       dw      ?       ; Client's CX
        Client_AX       dw      ?       ; Client's AX
        Client_Flags    dw      ?       ; Client's flags
        Client_IP       dw      ?       ; Client's IP, lsw of return
        Client_CS       dw      ?       ; Client's CS, msw of return
DPMI_Client_Frame ENDS

        public  DPMI_Client_Pmode_Entry
DPMI_Client_Pmode_Entry proc    far
;
; Reject any 32-bit program requests.
;

IFNDEF WOW
        test    ax, DPMI_32BIT          ; 32-bit application?
        stc                             ; yep, refuse to do it
        jz      dcpe_flags_ok           ; no, try to get into Pmode
        jmp     dcpe_x
dcpe_flags_ok:
ENDIF

IFDEF WOW
        stc
ENDIF
        pushf                           ;save client's flags (with carry set)
        pusha                           ;save caller's general registers
        push    ds                      ;save caller's DS
        push    es                      ;save caller's ES
        mov     bp, sp                  ;create the stack frame
        dossvc  62h                     ;now get caller's PSP address
        mov     di, bx                  ;and store it here for a while
        push    es
        dossvc  2fh                     ;get caller's dta address

        mov     ax, segDXData           ;get our DGROUP
        mov     ds, ax                  ;point to it

        mov     DtaSegment,es
        mov     DtaOffset,bx
        pop     es

;
; For now, we only support one DPMI client application at a time.
;
;;        cmp     cDPMIClients,0          ;Any active?
;;        je      @F
;;        jmp     dcpe_return

@@:     mov     ax,[segCurrentHostData]
        mov     es:[HdSegParent],ax     ; save rm link
        mov     ax,es
        mov     [segCurrentHostData],ax
        mov     ax,[bp].Client_AX       ; get dpmi flags
        mov     es:[HdFlags],ax         ; save for future reference
        mov     DpmiFlags,ax
        test    ax,DPMI_32BIT
        jne     cpe10

        mov     DpmiSegAttr,0
        jmp     cpe20

cpe10:  mov     DpmiSegAttr,AB_BIG

cpe20:  mov     si, ss                  ;SI = caller SS

        mov     ax, ds                  ;use a DOSX stack during the mode
                                        ;switch
        FCLI
        mov     ss, ax
        mov     sp, offset DGROUP:rgw2FStack

        SwitchToProtectedMode

        mov     ax, si                  ;make a selector for client's stack
        mov     bx, STD_DATA
        or      bx, DpmiSegAttr
        call    MakeLowSegment
        jnc     got_client_stack_selector
        jmp     dcpe_error_exit         ;back out if error
got_client_stack_selector:

        or      al,STD_TBL_RING

        mov     ss, ax                  ;back to client's stack
.386p
        movzx   esp,bp
.286p

;        push    [bp.Client_Flags]       ;enable interupts if client had
;        npopf                           ;them enabled

;
; After DOSX enters protected mode, convert the caller's segment registers
; to PMODE selectors, replacing the values in the client's register image
; on the stack.  First, allocate the three or four selectors we will need.
;
        xor     ax,ax                   ;an invalid selector
        push    ax                      ;marker

        mov     cx,4                    ;CS, PSP, Environ, Host data
        cmp     si,[bp.Client_DS]       ;Client SS == Client DS ?
        je      dcpe_allocate_loop
        inc     cx
dcpe_allocate_loop:
        call    AllocateSelector
        jnc     @F
        jmp     dcpe_pfail
@@:
        or      al,STD_TBL_RING
        push    ax
        loop    dcpe_allocate_loop

        mov     dx,[bp.Client_CS]       ;get client CS paragraph
        call    ParaToLinear            ;convert to linear address in BX:DX
        mov     cx,0ffffh               ;limit = 64k
        pop     ax                      ;get one of the selectors allocated
        mov     [bp.Client_CS],ax       ;save value for client
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_CODE>


        mov     dx, [bp.Client_DS]
        mov     [bp.Client_DS],ss       ;DS = SS for now
        cmp     dx, si                  ;need separate DS selector?
        je      dcpe_do_child_PSP

        call    ParaToLinear            ;convert to linear address in BL:DX
        mov     cx,0ffffh               ;limit = 64k
        pop     ax                      ;get another selector
        mov     [bp.Client_DS],ax       ;save value for client
        push    di
        mov     di,STD_DATA
        or      di,DpmiSegAttr
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,di>
        pop     di

dcpe_do_child_PSP:
        mov     dx,[bp.Client_ES]       ; get HostData selector
        call    ParaToLinear
        mov     cx,HOST_DATA_SIZE       ; limit = size of HostData
        pop     ax                      ; get another selector
        push    [selCurrentHostData]
        mov     [selCurrentHostData],ax ; save for us
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        mov     es,ax
        pop     ax
        mov     es:[HdSelParent],ax
        mov     ax,SelPSPChild
        mov     es:[HdPSPParent],ax

        mov     dx, di                  ;get client PSP paragraph
        mov     segPSPChild, di
        call    ParaToLinear            ;convert to linear address in BL:DX
        mov     cx,100h                 ;limit = 100h
        pop     ax                      ;get another selector
        mov     [bp.Client_ES],ax       ;save value for client
        mov     selPSPChild, ax         ;save a copy for DOSX
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

        mov     es:[HdSelPSP],ax
        mov     es,ax                   ;point to client's PSP
        mov     dx,es:segEnviron        ;fetch client's environment pointer
        call    ParaToLinear            ;convert to linear address in BL:DX
        mov     cx,0ffffh               ;limit = 32k
        pop     ax                      ;get another selector
        mov     es:segEnviron,ax        ;save client's environment selector
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

; We need to set up the DTA selector
        mov     dx,DtaSegment
        cmp     dx,segPSPChild
        jne     dcpe_50

        mov     dx,selPSPChild
        mov     DtaSelector,dx
        jmp     dcpe_60

dcpe_50:
        mov     cx,1
        call    AllocateSelector
        jnc     @f

        jmp     dcpe_free_client_stack

@@:     or      al,STD_TBL_RING
        mov     DtaSelector,ax
        call    ParaToLinear
        cCall   NSetSegmentDscr,<ax,bx,dx,0,0ffffh,STD_DATA>

dcpe_60:

        inc     cDPMIClients            ;increment count of Pmode clients
        cmp     cDPMIClients, 1         ; first client?
        jne     @f                      ; already taken care of

        call    AllocateExceptionStack

        call    DpmiStackSizeInit
        call    DpmiSizeInit
        FBOP    BOP_DPMI,DpmiInUse,FastBop
;
@@:
;
; Everything OK.  Clear error flag, and return to caller.
;
        not     byte ptr [bp.Client_Flags]
                                        ;reverse status flags, clearing carry


;       Let 32 bit code know if this is a 32 or 16 bit application
        mov     ax,DpmiFlags
        push    selPSPChild
        push    DtaSelector
        push    DtaOffset
        FBOP    BOP_DPMI,InitApp,FastBop
        add     sp,4

        cmp     cDPMIClients, 1         ; first client?
        jne     @f                      ; already taken care of
        ; Note:  We have to do InitApp before we try to hook the netbios
        ; interrupt.  If we don't, we will fault in the dos extender.
        ; (HookNetBiosHwInt calls int 21, enabling interrupts)
        call    HookNetBiosHwInt
@@:

;       jmp     far ptr dcpe_return     ;avoid need for fix ups
        db      0EAh
        dw      offset DXCODE:dcpe_return
        dw      SEL_DXCODE OR STD_RING
;
; If we get here, it means DOSX failed to allocate enough selectors for the
; client.  Deallocate those which have been allocated, switch back to
; real mode, and return an error to the caller.  Selectors to deallocate
; are on the stack, pushed after a zero word.  Then switch to a DOSX stack,
; deallocate the client stack selector, and switch to real mode.
;
dcpe_pfail:
        pop     ax                      ;any selectors allocated?
        or      ax,ax                   ; (we pushed a zero before allocating)
        jz      dcpe_free_client_stack  ;done
        call    FreeSelector            ;free the selector
        jnc     dcpe_pfail              ;free any more
dcpe_free_client_stack:
        mov     di, ss                  ;make copy of client stack selector
        mov     ax, ds                  ;have to be on a DOSX stack to do this
        FCLI
        mov     ss, ax
        mov     sp, offset DGROUP:rgw2FStack
        mov     ax, di                  ;free client stack selector
        call    FreeSelector
dcpe_error_exit:
;
; Error exit from protected mode.  Any allocated selectors have already
; been freed.  Switch to real mode, restore client stack, pop off client's
; registers, return with the carry flag set.
;
        SwitchToRealMode
        mov     ss, si                  ;restore client stack

        errnz  <dcpe_return-$>

dcpe_return:    ; The next line must restore the stack.

        mov     sp, bp

        jc      dcpe_return_1           ; error return
;
; Pop the client's registers off the stack frame, switch back to the
; client's stack, and return.
;
dcpe_return_1:
        pop     es                      ;pop copy of PSP selector/segment
        pop     ds                      ;pop client DS selector/segment
        popa                            ;pop client's general registers
        npopf                           ;restore interrupt flag, return status
dcpe_x:
        retf                            ;and out of here
DPMI_Client_Pmode_Entry endp

; -------------------------------------------------------
;              REAL MODE FUNCTION HANDLER
; -------------------------------------------------------
;
; RMInt2FHandler -- This routine hooks the real mode Int 2Fh chain
;       and watches for 'interesting' Int 2Fh calls.
;
;       WIN386/DOSX startup broadcast
;       DPMI server detection
;       Switcher API functions
;
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  RMInt2FHandler

RMInt2FHandler  proc    near


        cmp     ah,WIN386_FUNC          ;WIN386/DOSX/DPMI call?
        jz      rm2f_0

rm2f_chain:
        jmp     [PrevInt2FHandler]      ;no, just chain it on...

rm2f_0:

if 0    ; don't claim to be win 3.1 in enhanced mode
        cmp     al,WIN386_INIT          ;WIN386/DOSX startup attempt?
        jnz     rm2f_1                  ;no
        mov     cx,-1                   ;yes, don't let'm load
        jmp     rm2f_x
endif
        cmp     al,W386_Get_Device_API  ;not supported
        jne     rm2f_1

        xor     di,di
        mov     es,di
        jmp     rm2f_x

rm2f_1:
        cmp     al,DPMI_DETECT          ;DPMI detection?
        jnz     rm2f_2                  ;no

        mov     ax,DPMI_SUCCESS         ;yes, return Pmode switch entry
        mov     bx,DPMI_FLAGS           ;flags

        push    segDXData
        pop     es
        assume  es:DXDATA
        mov     cl,byte ptr es:[idCpuType]      ;CPU type
        assume  es:nothing

        mov     dx,DPMI_VER             ;DPMI server version
        mov     si,(HOST_DATA_SIZE + 15) / 16
        push    cs                      ;entry point is in this segment
        pop     es                              ;prospective client wants
        lea     di,DPMI_Client_Pmode_Entry      ;switch entry point in ES:DI
        jmp     rm2f_x                  ;done
rm2f_2:
if 0    ; don't claim to be windows
        cmp     al,WIN386_VER           ;Windows 386 version check?
        jnz     rm2f_chain              ;no, chain the interrupt

        mov     ax, 0a03h
else
        jmp     rm2f_chain
endif
rm2f_x:
        iret

RMInt2FHandler  endp

;--------------------------------------------------------------------------------

DXCODE  ends

IFDEF WOW
DXPMCODE segment
        assume cs:DXPMCODE

;----------------------------------------------------------------------
;
;   DpmiSizeInit -- This routine insures that the appropriately sized
;       interrupt handlers will be called
;
;   Inputs: None
;   Outputs: None
;
        public DpmiSizeInit
        assume ds:dgroup,es:nothing,ss:nothing
DpmiSizeInit proc

        push    ax
        push    bx
        push    cx
        push    si
        push    di
        push    es
        rpushf
        FCLI
        test    DpmiFlags,DPMI_32BIT
        jnz     dsi20

        cCall NSetSegmentAccess,<selDgroupPM,STD_DATA>
        cCall NSetSegmentAccess,<selEHStack,STD_DATA>

        jmp     dsi90
dsi20:
;
; Copy 16 bit handler addresses
;
.386p
        lea     di,Wow16BitHandlers

        mov     ax,ds
        mov     es,ax
        assume es:DGROUP

        push    ds
        mov     ax,SEL_IDT OR STD_RING
        mov     ds,ax
        assume ds:nothing

        mov     si,0
        mov     cx,256
dsi40:  movsd
        add     si,4
        loop    dsi40
        pop     ds
;
; Put 32 bit handlers into IDT
;

        mov     ax,SEL_IDT OR STD_RING
        mov     es,ax

        mov     es:[1h*8].offDest,offset DXPMCODE:Wow32IntrRefl+1h*6
        mov     es:[3h*8].offDest,offset DXPMCODE:Wow32IntrRefl+3h*6
        mov     es:[10h*8].offDest,offset DXPMCODE:Wow32IntrRefl+10h*6
        mov     es:[13h*8].offDest,offset DXPMCODE:Wow32IntrRefl+13h*6
        mov     es:[15h*8].offDest,offset DXPMCODE:Wow32IntrRefl+15h*6
        mov     es:[19h*8].offDest,offset DXPMCODE:Wow32IntrRefl+19h*6

        mov     es:[21h*8].offDest,offset DXPMCODE:Wow32IntrRefl+21h*6
        mov     es:[25h*8].offDest,offset DXPMCODE:Wow32IntrRefl+25h*6
        mov     es:[26h*8].offDest,offset DXPMCODE:Wow32IntrRefl+26h*6
        mov     es:[28h*8].offDest,offset DXPMCODE:Wow32IntrRefl+28h*6
        mov     es:[30h*8].offDest,offset DXPMCODE:Wow32IntrRefl+30h*6
        mov     es:[33h*8].offDest,offset DXPMCODE:Wow32IntrRefl+33h*6
        mov     es:[41h*8].offDest,offset DXPMCODE:Wow32IntrRefl+41h*6

;
; Set up the IDT, and dpmi32 state
;
        mov     ax,es                   ; Idt selector
        mov     bx,VDM_INT_32
        DPMIBOP InitIDT

        assume ds:DGROUP

dsi90:  rpopf
        pop     es
        pop     di
        pop     si
        pop     cx
        pop     bx
        pop     ax
        ret
DpmiSizeInit endp

        assume ds:DGROUP, es:NOTHING, ss:NOTHING
DpmiStackSizeInit proc

        push    ax
        test    DpmiFlags,DPMI_32BIT
        jz      @f
;
; Make the dgroup selector 32 bit
;
; NOTE: The following equ is only necessary to get the cmacro package
;       to pass the correct value to NSetSegmentAccess

NEW_DX_DATA equ STD_DATA OR AB_BIG
        cCall NSetSegmentAccess,<selDgroupPM,NEW_DX_DATA>
        cCall NSetSegmentAccess,<selEHStack,NEW_DX_DATA>
.286p

@@:
        pop     ax
        ret

DpmiStackSizeInit endp

DXPMCODE ends
ENDIF
;
;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxint31.asm ===
PAGE    ,132
        TITLE   DXINT31.ASM  -- Dos Extender Int 31h Handler

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXINT31.ASM     --  DOS Extender Int 31h Handler
;
;-----------------------------------------------------------------------
;
; This module provides the Int 31h services to the protected mode
; application running under the DOS Extender.
;
;-----------------------------------------------------------------------
;
;  12/03/90 amitc   'i31_GetSetRMInt' will map vectors in the range 50-57h
;                   to the range 8-fh if 'Win30CommDriver' switch is set in
;                   system.ini
;  12/18/89 jimmat  Service 0003 changed from Get LDT Base to Get Sel Incr,
;                   and added Virtual Interrupt State services.
;  09/18/89 jimmat  Added Allocate/Free Real Mode Call-Back services
;  08/20/89 jimmat  Changed A20 diddling to use XMS local enable/disable
;  06/14/89 jimmat  Added a few missing and new services.
;  05/17/89 jimmat  Added protected to real mode call/int services.
;  05/12/89 jimmat  Original version (split out from DXINTR.ASM)
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include interupt.inc
include int31.inc
include dpmi.inc

    Int_Get_PMode_Vec   EQU     04h
    Int_Set_PMode_Vec   EQU     05h

include intmac.inc
include stackchk.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

RealMode_SaveBP equ     word ptr RealMode_EBP+4
RealMode_SaveSP equ     word ptr RealMode_EBP+6

SelectorIncrement equ   8       ;DOSX increments consecutive selectors by 8

Trans_Reset_HW  equ     01h     ;Reset PIC/A20 line on PM->Call services

I31VERSION      equ     0090d   ;Int 31 services major/minor version #'s
                                ;  version 00.90 (not quite ready for DPMI)
I31FLAGS        equ     000Dh   ; 386 extender, pMode NetBIOS
I31MasterPIC    equ     08h     ;Master PIC Interrupts start at 08h
ifdef      NEC_98
I31SlavePIC     equ     10h     
else    ;NEC_98
I31SlavePIC     equ     70h     ;Slave PIC Interrupts start at 70h
endif   ;NEC_98

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterIntHandler:NEAR
        extrn   LeaveIntHandler:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   GetSegmentAddress:NEAR
        extrn   SetSegmentAddress:NEAR
        extrn   FreeSelector:NEAR
        extrn   FreeSelectorBlock:NEAR
        extrn   AllocateSelector:NEAR
        extrn   AllocateSelectorBlock:NEAR
        extrn   ParaToLDTSelector:NEAR
        extrn   DupSegmentDscr:NEAR
        extrn   GetFaultVector:NEAR
        extrn   PutFaultVector:NEAR
        extrn   AllocateXmemBlock:NEAR
        extrn   FreeXmemBlock:NEAR
        extrn   ModifyXmemBlock:NEAR
        extrn   FreeLowBlock:NEAR
        extrn   AllocateLowBlock:NEAR
        extrn   AllocateLDTSelector:NEAR
        extrn   ParaToLinear:NEAR
        extrn   GetIntrVector:NEAR, PutIntrVector:NEAR
        extrn   NSetSegmentLimit:near
        extrn   NMoveDescriptor:near
        extrn   NWOWSetDescriptor:near
        extrn   DFSetIntrVector:near
        extrn   RmSaveRestoreState:far
        extrn   PmSaveRestoreState:far
        extrn   RmRawModeSwitch:far
        extrn   PmRawModeSwitch:far
        extrn   IsSelectorFree:near
        extrn   gtpara:near

externNP NSetSegmentAccess
externFP NSetSegmentDscr
externNP FreeSpace

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   selGDT:WORD
        extrn   segPSP:WORD
        extrn   idCpuType:WORD
        extrn   npXfrBuf1:WORD
        extrn   rgbXfrBuf1:BYTE
        extrn   pbReflStack:WORD
        extrn   bReflStack:WORD
        extrn   lpfnXMSFunc:DWORD
        extrn   A20EnableCount:WORD
        extrn   regUserAX:WORD, regUserFL:WORD, regUserSS:WORD
        extrn   regUserSP:WORD, regUserDS:WORD, regUserES:WORD
        extrn   PMInt24Handler:DWORD
        extrn   DpmiFlags:WORD
IFDEF WOW_x86
        extrn   FastBop:fword
ENDIF

        extrn   selPspChild:WORD
        extrn   LowMemAllocFn:DWORD
        extrn   LowMemFreeFn:DWORD

        public  i31HWReset

i31HWReset      db      0               ;NZ if in 'standard' real mode state

i31_dsp_rtn     dw      0               ;Int 31h service routine to dispatch

ifdef DEBUG
debugsavess      dw      0               ; Usefull when debugging WOW KERNEL
debugsavesp      dw      0               ;
debugsavebp      dw      0               ;
debugsavecx      dw      0               ;
endif

        public  i31_selectorbitmap
i31_selectorbitmap      dw      0000000000000000b
                                        ;Reserved LDT Selectors
ifdef JAPAN
justw_flag	dw	0               ; for Just Window
endif ; JAPAN
DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

        extrn   segDXData:WORD
        extrn   selDgroup:WORD
        extrn   segDXCode:word

        assume  cs:NOTHING

DXCODE  ends

DXPMCODE segment

        extrn   selDgroupPM:WORD
        extrn   segDXCodePM:WORD

i31_dispatch    label   word

        dw      0000h,  offset i31_AllocSel
        dw      0001h,  offset i31_FreeSel
        dw      0002h,  offset i31_MapSeg2Sel
        dw      0003h,  offset i31_GetSelIncr
        dw      0004h,  offset i31_Success              ;lock selector memory
        dw      0005h,  offset i31_Success              ;unlock selector mem
        dw      0006h,  offset i31_GetSegAddr
        dw      0007h,  offset i31_SetSegAddr
        dw      0008h,  offset i31_SetLimit
        dw      0009h,  offset i31_SetAccess
        dw      000Ah,  offset i31_CreateDataAlias
        dw      000Bh,  offset i31_GetSetDescriptor
        dw      000Ch,  offset i31_GetSetDescriptor
        dw      000Dh,  offset i31_SpecificSel   ; Allocate specific descriptor
        dw      0100h,  offset i31_AllocDOSMem
        dw      0101h,  offset i31_FreeDOSMem
        dw      0102h,  offset i31_SizeDOSMem

        dw      0200h,  offset i31_GetSetRMInt
        dw      0201h,  offset i31_GetSetRMInt
        dw      0202h,  offset i31_GetSetFaultVector
        dw      0203h,  offset i31_GetSetFaultVector
        dw      0204h,  offset i31_GetSetPMInt
        dw      0205h,  offset i31_GetSetPMInt
        dw      0300h,  offset i31_RMCall
        dw      0301h,  offset i31_RMCall
        dw      0302h,  offset i31_RMCall
        dw      0303h,  offset i31_AllocCallBack
        dw      0304h,  offset i31_FreeCallBack
        dw      0305h,  offset i31_GetStateSaveRestore
        dw      0306h,  offset i31_GetRawModeSwitch
        dw      0400h,  offset i31_Version

        dw      04f1h,  offset i31_WOW_AllocSel
        dw      04f2h,  offset i31_WOW_SetDescriptor
        dw      04f3h,  offset i31_WOW_SetAllocFunctions

;
; INCOMPLETE !!!!!!!!!!!
; Needed by kernel.
;
        dw      0500h,  offset i31_GetFreeMem
        dw      0501h,  offset i31_AllocMem
        dw      0502h,  offset i31_FreeMem
;
; Fails by design if block is to be extended and this cannot be done
; in place.
;
        dw      0503h,  offset i31_SizeMem

        dw      0600h,  offset i31_Success      ;lock linear region
        dw      0601h,  offset i31_Success      ;unlock linear region
        dw      0602h,  offset i31_Success      ;mark real mode rgn pageable
        dw      0603h,  offset i31_Success      ;relock real mode region
        dw      0604h,  offset i31_PageSize     ;get page size

        dw      0700h,  offset i31_fail         ;reserved
        dw      0701h,  offset i31_fail         ;reserved
        dw      0702h,  offset i31_Success      ;demand page candidate
        dw      0703h,  offset i31_Success      ;discard page contents

        dw      0800h,  offset i31_fail         ;physical addr mapping

        dw      0900h,  offset i31_VirtualInt   ;get & disable Int state
        dw      0901h,  offset i31_VirtualInt   ;get & enable Int state
        dw      0902h,  offset i31_VirtualInt   ;get Int state
;
; UNIMPLEMENTED !!!!!!!!!!!
; To be used for MSDOS protected mode API?
;
        dw      0A00h,  offset i31_unimplemented         ;get vendor specific API

IFDEF WOW_x86
        NO386 = 0
else
        NO386 = 1
ENDIF
ife     NO386
;
; 386 Debug Register access routines.
;
        dw      0B00h,  offset i31_Debug_Register_Access
                                                ;set debug watchpoint
        dw      0B01h,  offset i31_Debug_Register_Access
                                                ;clear debug watchpoint
        dw      0B02h,  offset i31_Debug_Register_Access
                                                ;get debug watchpoint state
        dw      0B03h,  offset i31_Debug_Register_Access
                                                ;reset debug watchpoint
endif   ; NO386

        dw      -1, offset i31_unimplemented


DXPMCODE ends

; -------------------------------------------------------
        subttl  INT 31h Entry Point
        page
; -------------------------------------------------------
;             INT 31h SERVICE ENTRY POINT
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr31 -- Service routine for the Protect Mode INT 31h
;               services.  These functions duplicate the
;               Windows/386 VMM INT 31h services for protected
;               mode applications.  They were implemented to
;               support a protect mode version of Windows/286.
;
;   Input:  Various registers
;   Output: Various registers
;   Errors:
;   Uses:   All registers preserved, other than return values

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr31

PMIntr31        proc    near

        cld                     ;practice 'safe programming'

;  Determine if this one of the services we support.

        push    bx
        mov     bx,offset i31_dispatch          ;cs:bx -> dispatch table

@@:
        cmp     ax,cs:[bx]                      ;scan dispatch table for
        jz      i31_do_it                       ;  service code in AH/AL

        cmp     word ptr cs:[bx],-1             ;end of table is -1
        jz      i31_do_it

        add     bx,4
        jmp     short @b

; BX contains the offset of the routine to service this request!

i31_do_it:
        push    ds                      ;save the service routine address
        mov     ds,selDgroupPM          ;  in our DGROUP for now
        assume  ds:DGROUP

        mov     bx,cs:[bx+2]
        FCLI                    ;needed for [i31_dsp_rtn]
        mov     i31_dsp_rtn,bx

ifdef DEBUG
        mov     debugsavess,ss          ; usefule when debugging WOW kernel
        mov     debugsavesp,sp
        mov     debugsavebp,bp
        mov     debugsavecx,cx
endif

        pop     ds
        pop     bx

i31_doit:
        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        push    i31_dsp_rtn             ;routine address on stack

        FSTI                             ;no need to keep interrupts disabled

        retn                            ;go perform the service

i31_unimplemented:                      ;not implemented or undefined

        Debug_Out "Unsupported Int 31h requested (AX = #AX)"

; Int 31h service routines return (jmp) here to indicate failure.  The
; standard failure return sets the carry flag, and sets ax = 0.

i31_fail:

        mov     [bp].intUserAX,0

i31_fail_CY:

        or      byte ptr [bp].intUserFL,1
        jmp     short i31_exit

; Int 31h service routines return (jmp) here -- they jump back instead
; of returning because they expect the stack to be setup by EnterIntHandler,
; no extra items should be pushed.

i31_done:

        and     byte ptr [bp].intUserFL,not 1   ;clear carry flag

i31_exit:
        assume  ds:NOTHING,es:NOTHING

        FCLI                             ;LeaveIntHandler needs them off
        call    LeaveIntHandler         ;restore caller's registers, and
        riret                           ;  get on down the road

PMIntr31        endp


; -------------------------------------------------------
;  This routine is for Int 31h services that the 286 DOS extender
;  allows, but doesn't actually perform any work.  Most of these
;  services are related to demand paging under Windows/386.

        assume  ds:DGROUP,es:DGROUP
        public  i31_Success

i31_Success     proc    near

        jmp     i31_done                        ;nothing to do currently

i31_Success     endp

; -------------------------------------------------------
; Page Size.  Gotta be 1000h, even if we don't do anything
; with it.
;

        assume  ds:DGROUP,es:DGROUP
        public  i31_PageSize

i31_PageSize    proc    near

        mov     [bp].intUserBX,0
        mov     [bp].intUserCX,1000h
        jmp     i31_done                        ;nothing to do currently

i31_pageSize    endp

; -------------------------------------------------------
        subttl  INT 31h LDT/Heap Services
        page
; -------------------------------------------------------
;      LDT/HEAP INTERRUPT (INT 31h) SERVICE ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
;  Service 00/00 - Allocate Space in LDT for Selector
;              in: cx - # selectors required
;             out: ax - *index* of first selector

        assume  ds:DGROUP,es:DGROUP
        public  i31_AllocSel

i31_AllocSel    proc    near

        jcxz    short i31_15
        cmp     cx,1                    ;1 selector or more?
        ja      @f

        call    AllocateSelector        ;allocate 1 selector
        jc      i31_15
        jmp     short i31_10

@@:     mov     ax,cx
        push    cx                      ; save # of selector to be allocated
        xor     cx,cx                   ; allocate from lower range
        call    AllocateSelectorBlock   ;allocate a block of selectors
        pop     cx
        jc      i31_15

i31_10:
        or      al,STD_TBL_RING         ;add standard table/ring bits
        mov     [bp].intUserAX,ax       ;return 1st/only selector in AX

setsel: mov     bx,STD_DATA             ;all the selectors we allocate
;       xor     bl,bl                   ;  get initialized to data/ring ?
        xor     dx,dx                   ;  0 base, 0 limit
@@:
        cCall   NSetSegmentDscr,<ax,dx,dx,dx,dx,bx>
        add     ax,SelectorIncrement
        loop    @b

        jmp     i31_done

i31_15:
        jmp     i31_fail          ;fail the request

i31_AllocSel    endp


; -------------------------------------------------------
;  Service 00/01 - Free LDT Selector
;              in: bx - selector to free
;             out: none

        assume  ds:DGROUP,es:DGROUP
        public  i31_FreeSel

i31_FreeSel     proc    near

        mov     ax,bx                   ;release the selector
        cmp     ax,SEL_DPMI_LAST        ; reserved selector?
        ja      i31_Free_Regular_LDT_Selector   ; No.
        mov     cx,ax
        shr     cl,3                    ; Selector to selector index in LDT
        mov     ax,1
        shl     ax,cl                   ; AX = bit in i31_selectorbitmap
        test    i31_selectorbitmap,ax   ; test for already allocated
        jz      i31_FreeSel_Fail        ; already free!
        not     ax
        and     i31_selectorbitmap,ax   ; mark as free
        jmp     i31_done

i31_Free_Regular_LDT_Selector:

        and     ax,SELECTOR_INDEX       ;  only pass it the index
        or      ax,SELECTOR_TI          ;only allow LDT selectors
        jz      i31_Check_DS_ES
        call    FreeSelector
        jnc     i31_Check_DS_ES
i31_FreeSel_Fail:
        jmp     i31_fail_CY

i31_Check_DS_ES:

        ; check in case user frees the selector in DS or ES - we
        ;   don't want to fault when popping his regs

        and     bl,NOT SELECTOR_RPL     ;compare without ring bits

        mov     ax,[bp].pmUserDS
        and     al,NOT SELECTOR_RPL
        cmp     ax,bx
        jnz     @f

        mov     [bp].pmUserDS,0

@@:     mov     ax,[bp].pmUserES
        and     al,NOT SELECTOR_RPL
        cmp     ax,bx
        jnz     @f

        mov     [bp].pmUserES,0
@@:
        jmp     i31_done

i31_FreeSel     endp


; -------------------------------------------------------
;  Service 00/02 - Map Segment to Selector
;              in: bx - real mode segment value
;             out: ax - selector which maps area

        assume  ds:DGROUP,es:DGROUP
        public  i31_MapSeg2Sel

i31_MapSeg2Sel  proc    near

        mov     ax,bx                   ;find/make selector for real memory
        mov     bx,STD_DATA             ;assume it's a data selector
        call    ParaToLDTSelector
        jnc     @f

        jmp     i31_fail_CY             ;Falied!?
@@:
        mov     [bp].intUserAX,ax
        jmp     i31_done

i31_MapSeg2Sel  endp


; -------------------------------------------------------
;  Service 00/03 - Get Next Selector Increment Value
;              in: none
;             out: ax - Next Selector Increment Value

        assume  ds:DGROUP,es:DGROUP
        public  i31_GetSelIncr

i31_GetSelIncr  proc    near

        mov     [bp].intUserAX,SelectorIncrement        ;DOSX incr value
        jmp     i31_done

i31_GetSelIncr  endp


; -------------------------------------------------------
;  Service 00/06 - Get Segment Base address.
;               in: bx - selector
;              out: cx:dx - 32 bit lma of segment

        assume  ds:DGROUP,es:DGROUP
        public  i31_GetSegAddr

i31_GetSegAddr  proc    near

        mov     ax,selGDT
        assume es:nothing
        lsl     ax,ax

        push    bx
        and     bx,SELECTOR_INDEX

        cmp     bx,ax
        jnc     gsa10                            ; not in ldt

        call    IsSelectorFree
        jc      gsa20

gsa10:  pop     bx
        jmp     i31_fail_CY

gsa20:  pop     bx

        mov     ax,bx
        call    GetSegmentAddress

        mov     [bp].intUserCX,bx
        mov     [bp].intUserDX,dx

        jmp     i31_done

i31_GetSegAddr  endp


; -------------------------------------------------------
;  Service 00/07 - Set Segment Base address.
;               in: bx - selector
;                   cx:dx - 32 bit lma of segment
;              out: none

        assume  ds:DGROUP,es:DGROUP
        public  i31_SetSegAddr

i31_SetSegAddr  proc    near

        mov     ax,selGDT
        assume es:nothing
        lsl     ax,ax

        push    bx
        and     bx,SELECTOR_INDEX

        cmp     bx,ax
        jnc     ssa10                            ; not in ldt

        call    IsSelectorFree
        jc      ssa20

ssa10:  pop     bx
        jmp     i31_fail_CY

ssa20:  pop     bx
        mov     ax,bx
        mov     bx,cx
        call    SetSegmentAddress

        jmp     i31_done

i31_SetSegAddr  endp


; -------------------------------------------------------
;  Service 00/08 - Set Segment Limit.
;               in: bx - selector
;                   cx:dx - 32 bit limit of segment
;              out: none

        assume  ds:DGROUP,es:DGROUP
        public  i31_SetLimit

i31_SetLimit    proc    near

        mov     ax,selGDT
        assume es:nothing
        lsl     ax,ax

        push    bx
        and     bx,SELECTOR_INDEX

        cmp     bx,ax
        jnc     sl10                            ; not in ldt

        call    IsSelectorFree
        jc      sl20

sl10:   pop     bx
        jmp     i31_fail_CY

sl20:   pop     bx
        mov     es,selGDT
        and     bx,SELECTOR_INDEX
        and     es:[bx].cbLimitHi386,070h       ; clear 'G' bit and old
                                                ; extended limit bits
        test    cx,0fff0h                       ; bits 20-31 set?
        jz      i31_SetLimit_0                  ; No
        shr     dx,12d                          ; Yes
        mov     ax,cx
        shl     ax,4d
        or      dx,ax
        shr     cx,12d
        or      es:[bx].cbLimitHi386,080h       ; set 'G' bit
i31_SetLimit_0:
        mov     es:[bx].cbLimit,dx
        or      es:[bx].cbLimitHi386,cl
        cCall   NSetSegmentLimit,<bx>
        jmp     i31_done

i31_SetLimit    endp


; -------------------------------------------------------
;  Service 00/09 - Set Segment Access Rights
;               in: bx - selector
;                   cl - segment access rights byte

        assume  ds:DGROUP,es:DGROUP
        public  i31_SetAccess

i31_SetAccess   proc    near

        mov     ax,selGDT
        assume es:nothing
        lsl     ax,ax

        push    bx
        and     bx,SELECTOR_INDEX

        cmp     bx,ax
        jnc     sa10                            ; not in ldt

        call    IsSelectorFree
        jc      sa20

sa10:   pop     bx
sa11:
        jmp     i31_fail_CY

sa20:   pop     bx

        test    cl,010000b              ; system segment?
        jz      sa11                    ; y: error
        push    cx
        and     cl,AB_DPL               ; mask off all but DPL bits
        cmp     cl,STD_DPL              ; is this the correct DPL?
        pop     cx
        jnz     sa11                    ; n: error

        cCall   NSetSegmentAccess,<bx,cx>
        jmp     i31_done

i31_SetAccess   endp


; -------------------------------------------------------
;  Service 00/0A - Create Data Segment Alias (for a code seg)
;               in: bx - selector
;              out: ax - new data selector

        assume  ds:DGROUP,es:DGROUP
        public  i31_CreateDataAlias

i31_CreateDataAlias  proc    near

        mov     ax,bx                   ;make sure it's a vaild selector
        verr    ax
        jnz     cda_failed

        mov     bx,ax                   ;get a new selector for the alias
ifdef JAPAN
justw_check:
endif ; JAPAN
        call    AllocateSelector
        jc      cda_failed

ifdef JAPAN
	cmp	[justw_flag],0
	jne	not_justw
	mov	[justw_flag],1
	jmp	justw_check
not_justw:
endif ; JAPAN
        xchg    ax,bx                   ;copy old to new
        call    DupSegmentDscr

        mov     es,selGDT
        and     bx,SELECTOR_INDEX
        mov     al,es:[bx].arbSegAccess
        and     al,11100000b            ;mask off all but present and DPL bits
        or      al,AB_DATA or AB_WRITE
        mov     ah, es:[bx].cbLimitHi386
        cCall   NSetSegmentAccess,<bx,ax>
        or      bl,STD_TBL_RING         ;set standard table/ring bits
        mov     [bp].intUserAX,bx

        jmp     i31_done

cda_failed:
        jmp     i31_fail_CY

i31_CreateDataAlias  endp


; -------------------------------------------------------
;  Service 00/0B - Get Descriptor
;  Service 00/0C - Set Descriptor
;               in: bx - selector
;                   es:di -> buffer to hold copy of descriptor

        assume  ds:DGROUP,es:DGROUP
        public  i31_GetSetDescriptor

i31_GetSetDescriptor  proc    near

        .386p
        push    esi
        push    edi
        .286p
        mov     ax,selGDT
        mov     es,ax
        assume  es:NOTHING
        lsl     ax,ax

        and     bx,SELECTOR_INDEX

        cmp     bx,ax                   ; range-test selector against
        jc      @f                      ;  the limit of the GDT/LDT

.386p
        pop     edi
        pop     esi
.286p
        jmp     i31_fail_CY             ;fail if invalid selector specified
@@:
        call    IsSelectorFree
        jc      @f

.386p
        pop     edi
        pop     esi
.286p
        jmp     i31_fail_CY
@@:

        cmp     byte ptr [bp].intUserAX,SelMgt_Get_Desc         ;Get or Set?
        jz      i31_GetDscr

;
; Set Descriptor
;
        test    DpmiFlags,DPMI_32BIT
        jnz     gsd10
.386p
        mov     esi,0                   ; zero high half
        mov     edi,0
        jmp     gsd20

gsd10:  mov     esi,edi                 ; get high half of edi
        mov     edi,0                   ; zero high half
.286p
gsd20:
        push    ds                      ;Set -
        mov     ds,[bp].pmUserES
        assume  ds:nothing

        mov     si,[bp].pmUserDI        ;  ds:si -> caller's buffer
        mov     di,bx                   ;  es:di -> dscr slot in GDT/LDT

        .386p
        mov     cl,ds:[esi].arbSegAccess386
        .286p
        test    cl,010000b              ; system segment?
        jz      gsd25                   ; y: error
        and     cl,AB_DPL               ; mask off all but DPL bits
        cmp     cl,STD_DPL              ; is this the correct DPL?
        jnz     gsd25                   ; n: error
        jmp     short i31_MovDscr

gsd25:                                  ; set ldt format error
        pop     ds
.386p
        pop     edi
        pop     esi
.286p
        jmp     i31_fail_CY

i31_GetDscr:
        assume  ds:DGROUP
;
; Get Descriptor
;
        test    DpmiFlags,DPMI_32BIT
        jnz     gsd30
.386p
        mov     edi,0                   ; zero high half of edi
gsd30:  mov	esi,0                   ; zero high half of esi

.286p
        push    ds                      ;Get -
        push    es
        pop     ds
        assume  ds:nothing
        mov     si,bx                   ;  ds:si -> dscr slot in GDT/LDT
        mov     es,[bp].pmUserES
        mov     di,[bp].pmUserDI        ;  es:di -> caller's buffer

i31_MovDscr:
        .386p
        cCall   NMoveDescriptor,<ds,esi,es,edi>
        .286p
i31_gs25:
        pop     ds
        assume ds:DGROUP

.386p
        pop     edi
        pop     esi
.286p
        jmp     i31_done

i31_GetSetDescriptor  endp

; -------------------------------------------------------
;  Service 00/0D - Allocate Specific LDT Selector
;               in: bx - selector
;               out: carry clear if selector was allocated
;                    carry set if selector was not allocated
        assume  ds:DGROUP,es:DGROUP
        public  i31_SpecificSel

i31_SpecificSel proc    near

        and     bx,SELECTOR_INDEX
        cmp     bx,SEL_DPMI_LAST
        ja      i31_SpecificSel_Fail
        mov     cx,bx
        shr     cl,3                    ; Selector to selector index in LDT
        mov     ax,1
        shl     ax,cl                   ; AX = bit in i31_selectorbitmap
        test    i31_selectorbitmap,ax   ; test for already allocated
        jnz     i31_SpecificSel_Fail    ; allocated, fail
        or      i31_selectorbitmap,ax   ; mark as allocated

        ;
        ; Set up the DPL and size
        ;
        mov     ax,bx
        mov     cx,1

        jmp     setsel

i31_SpecificSel_Fail:                   ; couldn't get that one
        jmp     i31_fail_CY

i31_SpecificSel  endp

; -------------------------------------------------------
        subttl  INT 31h DOS Memory Services
        page
; -------------------------------------------------------
;         INT 31h DOS MEMORY SERVICE ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
;  Service 01/00 - Allocate DOS Memory Block
;
;       In:     BX - # paragraphs to allocate
;       Out:    If successful: Carry Clear
;               AX - segment address of block
;               DX - selector to access block
;
;               If unsuccessful: Carry Set
;               AX - DOS error code
;               BX - size of largest available block in paragraphs
;
;  13-Feb-1991 -- ERH This call is not supported under Windows 3.1,
;                     but try to find a block in our net heap to
;                     satisfy the request, anyway.
;


        assume  ds:DGROUP,es:DGROUP
        public  i31_AllocDOSMem

i31_AllocDOSMem proc    near
        and     [bp].intUserFL,NOT 1            ; clear carry in status
        mov     cx,[bp].intUserBX
        mov     dx,[bp].intUserBX
        shr     dx,12                           ; high half of byte count
        shl     cx,4                            ; low half of byte count

        call    AllocateLowBlock

        jc      adm30

        mov     [bp].intUserDX,ax
        mov     si,ax

        call    GTPARA                          ; get paragraph address

        mov     [bp].intUserAX,ax
        jmp     i31_done

adm30:  shr     cx,4
        shl     dx,12
        or      cx,dx                           ; paragraph size of largest
ifdef JAPAN
	or	cx,cx
	jz	notdec
	dec	cx
notdec:
endif ; JAPAN
        mov     [bp].intUserBX,cx
        mov     [bp].intUserAX,ax               ; error code
        jmp     i31_fail_CY

i31_AllocDOSMem endp


; -------------------------------------------------------
;  Service 01/01 - Release DOS Memory Block
;
;       In:     DX - SELECTOR of block to release
;       Out:    If successful: Carry Clear
;
;               If unsuccessful: Carry Set
;               AX - DOS error code

        assume  ds:DGROUP,es:DGROUP
        public  i31_FreeDOSMem

i31_FreeDOSMem  proc    near

        mov     ax,[bp].intUserDX
        verw    ax
        jnz     fdm60

        push    bx
        mov     bx, ax                          ; selector
        and     bx,SELECTOR_INDEX               ; make it index into ldt

        call    IsSelectorFree
        pop     bx
        jnc     fdm60

        mov     ax,[bp].intUserDX
        call    FreeLowBlock

        jc      fdm60
        jmp     i31_Success

fdm60:  mov     [bp].intUserAX,ax
        jmp     i31_fail_CY

i31_FreeDOSMem  endp


; -------------------------------------------------------
;  Service 01/02 - Resize DOS Memory Block
;
;       In:     BX - new block size in paragraphs
;               DX - SELECTOR of block to release
;       Out:    If successful: Carry Clear
;
;               If unsuccessful: Carry Set
;               AX - DOS error code

        assume  ds:DGROUP,es:DGROUP
        public  i31_SizeDOSMem

i31_SizeDOSMem  proc    near

        mov     [bp].intUserBX,0
        mov     [bp].intUserAX,08h              ; insufficient mem. available
        jmp     i31_fail_CY

i31_SizeDOSMem  endp


; -------------------------------------------------------
        subttl  INT 31h Real Mode Int Vector Routines
        page
; -------------------------------------------------------
;             INT 31h INTERRUPT SERVICES
; -------------------------------------------------------

; -------------------------------------------------------
;  i31_GetSetRMInt -- Get/Set Real Mode Interrupt Vector
;
;       In:     bl    - Interrupt #
;               cx:dx - SEG:Offset of real mode int vector (if set)
;       Out:    cx:dx - SEG:Offset of real mode int vector (if get)

        assume  ds:DGROUP,es:DGROUP
        public  i31_GetSetRMInt

i31_GetSetRMInt proc    near

        push    SEL_RMIVT or STD_RING   ;address the real mode IVT
        pop     es
        assume  es:NOTHING

        xor     bh,bh                   ;convert int # to offset
        shl     bx,2

        FCLI                             ;play it safe

        cmp     al,Int_Get_Real_Vec     ;Get or Set?
        jnz     i31_gs_set

        mov     cx,word ptr es:[bx+2] ;get segment:offset
        mov     dx,word ptr es:[bx]

        mov     [bp].intUserCX,cx       ;return them to caller
        mov     [bp].intUserDX,dx

        jmp     short i31_gs_ret

i31_gs_set:                             ;setting the vector...

        mov     es:[bx],dx              ;set the real mode IDT vector
        mov     es:[bx+2],cx

i31_gs_ret:

        FSTI
        jmp     i31_done

i31_GetSetRMInt endp


; -------------------------------------------------------
;  i31_GetSetFaultVector -- Get/Set Protected Mode Fault Vector (0h-1Fh)
;
;       In:     bl    - Interrupt #
;               cx:dx - Sel:Offset of pMode int vector (if set)
;       Out:    cx:dx - Sel:Offset of pMode int vector (if get)

        assume  ds:DGROUP,es:DGROUP
        public  i31_GetSetFaultVector

i31_GetSetFaultVector proc    near

        cmp     bl,10h                  ; zero to 10h are defined for 80386
        jbe     @f
        jmp     i31_fail_CY             ;must be <= 10h or fail it
@@:
        xor     bh,bh
        mov     ax,bx                   ;interrupt # to AX

        cmp     byte ptr [bp].intUserAX,Int_Get_Excep_Vec       ;Get or Set?
        jne     i31_gfv_set

        call    GetFaultVector          ;wants to get the vector
        mov     [bp].intUserCX,cx
        mov     [bp].intUserDX,dx

        jmp     short i31_gfv_ret

i31_gfv_set:
.386p
        test    DpmiFlags,DPMI_32BIT
        jnz     sfv10

        movzx   edx,dx                  ; zero high half
.286p
sfv10:  call    PutFaultVector          ;doing a set (args already set)

i31_gfv_ret:
        jmp     i31_done

i31_GetSetFaultVector endp

; -------------------------------------------------------
;  i31_GetSetPMInt -- Get/Set Protected Mode Interrupt Vector
;
;       In:     bl    - Interrupt #
;               cx:dx - SEL:Offset of protected mode int vector (if set)
;       Out:    cx:dx - SEL:Offset of protected mode int vector (if get)

        assume  ds:DGROUP,es:DGROUP
        public  i31_GetSetPMInt

i31_GetSetPMInt proc    near

        xchg    al,bl
        xor     ah,ah

        cmp     bl,Int_Get_PMode_Vec    ;Get or Set?
        jnz     i31_gsp_set

; NOTE: we don't call DFGetIntrVector here, because all it does is a call to
;       the following routine

        call    GetIntrVector
        mov     [bp].intUserCX,cx
        mov     [bp].intUserDX,dx

        jmp     i31_gsp_done

i31_gsp_set:

        ; set up the appropriate real mode reflector, and hook the int.
        call    DFSetIntrVector

i31_gsp_done:
        FSTI
        jmp     i31_done

i31_GetSetPMInt endp

; -------------------------------------------------------
        subttl  INT 31h Protected-to-Real Mode Call/Int
        page
; -------------------------------------------------------
;     INT 31h PROTECTED-TO-REAL MODE CALL/INT SERVICES
; -------------------------------------------------------

; -------------------------------------------------------
;  Service 03/00 -- Simulate real mode interrupt
;  Service 03/01 -- Call real mode procedure with far return frame
;  Service 03/02 -- Call real mode procedure with iret return frame
;
;       In:     es:di -> client register structure for real mode
;               bl    =  interrupt number (03/00 only)
;               cx    =  # words to copy from protected mode stack
;       Out:    es:di -> updated client register structure

        assume  ds:DGROUP,es:DGROUP
        public  i31_RMCall

i31_RMCall      proc  near

; First off, we need to copy the client register structure down to
; real mode addressable memory...  Lets use rgbXfrBuf1 for now...
; Changed to use the interrupt reflector stack because these routines
; need to be reentrant.  This also lets us leave interrupts enabled
; longer.
;       Earleh - 27-Jun-1990.

        mov     di,sp                           ; DI = SP = client regs. buffer

        sub     di,size Real_Mode_Call_Struc+2  ; Make room for client
        sub     di,[bp].intUserCX               ;   call structure plus
        sub     di,[bp].intUserCX               ;     any optional stack params
        sub     di,32                           ; pushad
        push    di                              ;       plus copy of di.
.386p
        pushad                                  ; have to save high 16 bits
.286p

        mov     sp,di

; --------------------------------------------------------------
;
; The interrupt reflector stack frame now looks like this...
;
;  pbReflStack + CB_STKFRAME->  ---------------------------
;       (old pbReflStack)       |                         |
;                               |     INTRSTACK Struc     |
;                               |  from EnterIntHandler   |
;                               |                         |
;                               ---------------------------
;  pbReflStack + CB_STKFRAME    |      word pointer       |>>--\
;   - (SIZE INTRSTACK) - 2   -> ---------------------------    |
IFDEF WOW_x86
;                               |                         |    |
;                               |  Pushad frame           |    |
;                               |                         |    |
;                               ---------------------------    |
ENDIF
;                               |                         |    |
;                               |  optional stack params  |    |
;                               |                         |    |
;                               ---------------------------    |
;                               |                         |    |
;                               |                         |    |
;                               |  Real_Mode_Call_Struc   |    |
;                               |                         |    |
;                               |                         |    |
;                               ---------------------------<<--/
;                               |                         |
;                               |  Available stack space  |
;                               |                         |
;         pbReflStack---------->---------------------------
;
; After returning from the real mode procedure, we will need
; to fetch the word pointer stored just below the EnterIntHandler
; frame, and use it to access our temporary Real_Mode_Call_Struc.
; In addition to holding the client register values, this also
; holds the SP and BP values we will need to switch back to our
; stack when we return from the real mode procedure.
;
; !!! -- Storing the optional stack parameters on top of our
; Real_Mode_Call_Struc has several problems.  It eats up stack
; space if we call the real mode procedure on our stack, because
; we then have to make another copy of these.   It also means we have to
; carry around a pointer to where the Real_Mode_Call_Struc lives.
; If we didn't have the stack parameters on top of the Real_Mode_Call_Struc,
; then we could find things strictly by offset from the value in
; pbReflStack.  The picture above should be rearranged to make optimal
; use of space.  I basically did it this way so I could have a minimum-
; change fix for a bug in Windows 3.0.
; !!!
; --------------------------------------------------------------
;
;

        cld
        .386p
        xor     ecx,ecx
        .286p
        mov     cx,(size Real_Mode_Call_Struc) / 2

        mov     bx,di                   ;bx used to reference client regs below
.386p
        test    DpmiFlags,DPMI_32BIT
        jz      rmc10

        mov     esi,edi                 ; copy over high 16 bits
        jmp     rmc20

rmc10:  xor     esi,esi                 ; clear high 16 bits esi
rmc20:  xor     edi,edi                 ; clear high 16 bits edi
        mov     di,bx
.286p
        mov     si,[bp].pmUserDI
        mov     ds,[bp].pmUserES
        assume  ds:NOTHING
.386p
        rep movs word ptr [esi],word ptr [edi]
.286p


; Copy stack parameters from PM to RM stack if requested by caller.  To
; avoid excessive selector munging, we do this in two steps (under the
; assumption the # words to copy will be small).  First the PM stack args
; are copied to a buffer in DXDATA, then after switching to real mode,
; to the real mode stack.  If the caller has more stack words than will
; fit in our buffer, or the real mode stack, bad things will happen...

        .386p
        xor     ecx,ecx
        .286p
        mov     cx,[bp].intUserCX       ;caller's CX has # stack words to copy
        jcxz    @f

        Trace_Out "Int 31h PM-to-RM int/call copying #CX stack words"

.386p
        xor     esi,esi
.286p
        mov     ds,[bp].pmUserSS
        mov     si,[bp].pmUserSP
.386p
        test    DpmiFlags,DPMI_32BIT
        jz      rmc30
;
; Have to go groping for user stack, since we switched stacks to get
; here.
;
;               |                |
;               +----------------+
;               |                |
;               +---- SS    -----+
;               |                |
;               +----------------+
;               |                |
;               +---- ESP   -----+
;               |                |
;               +----------------+
;               |     Flags      |
;               +----------------+
;               |     CS         |
;               +----------------+
;               |     IP         |
;      ds:si -> +----------------+

        push    dword ptr ds:[si + 6]
        push    word ptr ds:[si + 10]
        pop     ds
        pop     esi
        add     esi,6                   ; other half of 32 bit stack frame

rmc30:  add     esi,6                   ;ds:si -> PM stack args
        rep movs word ptr [esi],word ptr [edi]
.286p
                                        ;es:di already points to buffer
@@:
        push    es                      ;restore ds -> DGROUP
        pop     ds
        assume  ds:DGROUP

; Switch to real mode, set up the real mode stack

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

i31_rmcall_hw_ok:
        FSTI                             ;RestoreHardwareIntr disables ints
                                        ;don't need them disabled now

        mov     [bx].RealMode_SaveBP,bp ;save our stack in reserved area of
        mov     [bx].RealMode_SaveSP,sp ;  real mode register frame

        mov     cx,[bp].pmUserCX                ;cx = caller's CX (# stk words)
        mov     dh,byte ptr [bp].pmUserAX       ;dh = caller's AL (subfunction)
        mov     dl,byte ptr [bp].pmUserBX       ;dl = caller's BL (RM int #)

        mov     ax,[bx].RealMode_SS     ;did caller specify his own stack?
        or      ax,[bx].RealMode_SP

        jz      @f

        ; NOTE: can't reference [bp].xxUserXX varaibles after switching stacks

        mov     ss,[bx].RealMode_SS     ;switch to caller's real mode stack
        mov     sp,[bx].RealMode_SP

        assume  ss:NOTHING
@@:

; Copy stack args to real mode stack if there are any

        jcxz    @f

        sub     sp,cx
        sub     sp,cx                   ;make space on stack for args

        mov     di,sp
        mov     ax,ss
        mov     es,ax                   ;es:di -> real mode stack
        assume  es:NOTHING

        lea     si,[bx + size Real_Mode_Call_Struc]

        cld
        rep movsw

        push    ds
        pop     es
        assume  es:DGROUP
@@:

; Put a far ret or iret frame on stack to return to us

        cmp     dh,Trans_Far_Call       ;Does this service use a far ret or
        jz      i31_rmcall_retf         ;  an iret frame?

        mov     ax, [bx].RealMode_Flags ;real mode routine thinks these were
        and     ax, NOT 100h            ;remove TF
        push    ax
        push    cs                      ;  the prior flags and CS:IP
        push    offset i31_rmcall_ret

        FCLI                             ;flags with interrupts disabled -- real
        pushf                           ;  mode rtn entered with these flags
        FSTI
        jmp     short @f

i31_rmcall_retf:

        push    cs                      ;push a far ret frame so the
        push    offset i31_rmcall_ret   ;  real mode routine returns to us

        mov     ax, [bx].RealMode_Flags ;real mode rtn entered with these flags
        and     ax, NOT 100h            ;remove TF
        push    ax
@@:
        cmp     dh,Trans_Sim_Int        ;use an int vector, or caller's spec'd
        jnz     i31_rmcall_csip         ;  cs:ip?

        mov     al,dl                   ;push CS:IP for interrupt
        xor     ah,ah                   ;  number in caller's BL
        mov     si,ax
        shl     si,2

        xor     ax,ax                   ;address real mode IDT
        mov     es,ax
        assume  es:NOTHING

        push    word ptr es:[si+2]
        push    word ptr es:[si]

        jmp     short @f

i31_rmcall_csip:

        push    [bx].RealMode_CS        ;execute the real mode routine at
        push    [bx].RealMode_IP        ;  specified CS:IP
@@:

; Load the clients registers, and pass control to the real mode routine
.386p
        mov     edi,dword ptr [bx].RealMode_DI
        mov     esi,dword ptr [bx].RealMode_SI
        mov     ebp,dword ptr [bx].RealMode_BP
        mov     edx,dword ptr [bx].RealMode_DX
        mov     ecx,dword ptr [bx].RealMode_CX
        mov     eax,dword ptr [bx].RealMode_AX
        mov     es,[bx].RealMode_ES
        assume  es:NOTHING

        push    [bx].RealMode_DS
        push    dword ptr [bx].RealMode_BX

        pop     ebx
        pop     ds
        assume  ds:NOTHING
.286p
        iret


; The real mode routine returns here when finished

i31_rmcall_ret:

        pushf                           ;save returned flags, ds, bx on stack
        FSTI                             ;don't need ints disabled
        push    ds
.386p
        push    ebx
.286p

        mov     ds,segDXData            ;address our DGROUP
        assume  ds:DGROUP
;
; Fetch word pointer to temporary client register save area, that we
; saved before switching stacks.
;
        mov     bx,[pbReflStack]
        mov     bx,[bx + CB_STKFRAME - (SIZE INTRSTACK) - 2]

; Save the real mode registers in client frame

.386p
        mov     dword ptr [bx].RealMode_DI,edi
        mov     dword ptr [bx].RealMode_SI,esi
        mov     dword ptr [bx].RealMode_BP,ebp
        mov     dword ptr [bx].RealMode_DX,edx
        mov     dword ptr [bx].RealMode_CX,ecx
        mov     dword ptr [bx].RealMode_AX,eax
        mov     [bx].RealMode_ES,es

        pop     dword ptr [bx].RealMode_BX
.286p
        pop     [bx].RealMode_DS
        pop     [bx].RealMode_Flags
        or      [bx].RealMode_Flags,03000h       ; IOPL always has to be 3


; Restore our stack and return to protected mode
; SP will now point to base of temporary client register save area
; on our stack.  BP points to stack frame set up for us by EnterIntHandler.
; SP must be restored to value in BP before calling LeaveIntHandler.

        mov     ss,segDXData            ;address our DGROUP
        mov     sp,[bx].RealMode_SaveSP
        mov     bp,[bx].RealMode_SaveBP

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP

        FSTI                             ;still don't need ints disabled

; Apparently in win31 standard mode, the pm caller's flags are set to the
; value of the rm flags at the handler's iret. On win31 enhanced mode, this
; was *not* done, and the pm flags are, except for carry, basically
; preserved. Since setting the flags kills some apps (winfax deltest),
; we should adhere to the enhanced mode convention. Thus, the following
; code is if'd out.
if 0
       mov     ax,[bx].RealMode_Flags
       mov     [bp].intUserFL,ax
endif

; Copy the updated client register frame to the caller, and we're finished

        cld
        .386p
        xor     ecx,ecx
        .286p
        mov     cx,(size Real_Mode_Call_Struc) / 2
.386p
        xor     esi,esi
        xor     edi,edi

        mov     si,bx
        add     si,[bp].pmUserCX
        add     si,[bp].pmUserCX
        add     si,size Real_Mode_Call_Struc
;
; Si now points at pushad frame
;
        push    si

        test    DpmiFlags,DPMI_32BIT
        jz      rmc80
        mov     edi,[si]
rmc80:
.286p
        mov     si,bx
        mov     di,[bp].pmUserDI
        mov     es,[bp].pmUserES
        assume  es:NOTHING
.386p
        rep movs word ptr [esi],word ptr [edi]

        pop     sp                      ; value calculated above
        popad
        mov     sp,bp
.286p

        jmp     i31_done                ;finished!

i31_RMCall      endp


; -------------------------------------------------------
;  Service 03/03 -- Allocate Real Mode Call-Back Address
;
;       In:     ds:si -> pMode CS:IP to be called when rMode
;                        call-back address executed
;               es:di -> client register structure to be updated
;                        when call-back address executed
;       Out:    cx:dx -> SEGMENT:offset of real mode call-back hook
;               CY clear if successful, CY set if can't allocate
;               call back

        assume  ds:DGROUP,es:DGROUP
        public  i31_AllocCallBack

i31_AllocCallBack       proc    near

        push    ax

        call    AllocateLDTSelector
        jc      acb_nosel
        push    [bp].pmUserDS           ;pass in user's ds on stack
        push    [bp].pmUserES           ;pass in user's es on stack
        DPMIBOP AllocateRMCallBack
        add     sp, 4
        jc      acb_nocb

        mov     [bp].intUserCX,cx       ;callback segment
        mov     [bp].intUserDX,dx       ;callback offset
        mov     cx,-1
        cCall   NSetSegmentDscr,<ax,0,0,0,cx,STD_DATA>
        pop     ax
        jmp     i31_done

acb_nocb:
        call    FreeSelector
acb_nosel:
        pop     ax
        jmp     i31_fail_CY             ;no call-backs available, fail

i31_AllocCallBack       endp


; -------------------------------------------------------
;  Service 03/04 -- Free Real Mode Call-Back Address
;
;       In:     cx:dx -> SEGMENT:offset of rMode call-back to free
;       Out:    CY clear if successful, CY set if failure

        assume  ds:DGROUP,es:DGROUP
        public  i31_FreeCallBack

i31_FreeCallBack        proc    near

        push    ax
        DPMIBOP FreeRMCallBack
        jc      @f
        call    FreeSelector
        pop     ax
        jmp     i31_done
@@:
        pop     ax
        jmp     i31_fail_CY             ;no call-backs available, fail

i31_FreeCallBack        endp


; -------------------------------------------------------

DXPMCODE ends

; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

;
; RMCallBackBop
;
; Originally, the real mode call back hook was implemented here in
; the 16-bit client dosx. What it did was allocate a stacklet on
; its own stack and run the PM code on that stack. So the basic
; stack layout was that the RM stack pointer was followed by approx.
; 100 bytes or so of space, and then you started on the PM stack
; (corresponding to the start of the next stacklet).
;
; This whole approach was basically broken, since apps don't expect
; this. For example, the DOS4GW dos extender, which is used by a
; lot of games, switches stacks immediately in the PM callback proc
; from the protect mode stack to the real mode stack. That is, they
; use the same contiguous stack for both real mode and protect mode.
; What happens then with the original design is that the protect mode
; code, depending on how deep it goes on the stack, ends up overwriting
; the new stacklet further down, so we lose the return information
; needed to get back from the PM callback proc.
;
; The new design is just to do it in the unobtrusive dpmi32 host,
; including switching to a real PM stack. So here we just bop out
; to perform the switch and PM call.
;

        public  RMCallBackBop
RMCallBackBop proc far
        DPMIBOP RMCallBackCall
        ret                             ;finished!
RMCallBackBop endp

; -------------------------------------------------------

DXCODE  ends

; -------------------------------------------------------

DXPMCODE segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
        subttl  INT 31h Memory Management Services
        page
; -------------------------------------------------------
;          INT 31h MEMORY MANAGEMENT SERVICES
; -------------------------------------------------------

; -------------------------------------------------------
;  Service 05/00 -- Get Free Memory Information
;
;       In:     es:di -> 30h byte buffer
;       Out:    es:di -> Largest free block (in bytes) placed at
;                        start of caller's buffer
;                        Rest of buffer filled in with -1.

        assume  ds:DGROUP,es:DGROUP
        public  i31_GetFreeMem

i31_GetFreeMem  proc  near
        mov     es,[bp].pmUserES        ; Point to user buffer
        mov     di,[bp].pmUserDI
        assume  es:NOTHING


        FBOP    BOP_DPMI, GetMemoryInformation, FastBop
        jmp     i31_done

i31_GetFreeMem  endp



; -------------------------------------------------------
;  Service 05/01 -- Allocate Memory Block
;
;       In:     bx:cx - size of block to allocate in bytes
;       Out:    successful, carry clear &
;                       bx:cx = linear memory address of block
;                       si:di = handle to block
;               failed, carry set

        assume  ds:DGROUP,es:DGROUP
        public  i31_AllocMem

i31_AllocMem    proc    near

        mov     bx,[bp].pmUserBX
        mov     cx,[bp].pmUserCX
        mov     dx, selPSPChild

        FBOP    BOP_DPMI, AllocXmem, FastBop

        jnc     @f

        jmp     i31_fail_CY

@@:     mov     [bp].intUserBX,bx
        mov     [bp].intUserCX,cx
        mov     [bp].intUserSI,si
        mov     [bp].intUserDI,di
        jmp     i31_Done

i31_AllocMem    endp


; -------------------------------------------------------
;  Service 05/02 -- Free Memory Block
;
;       In:     si:di - 'handle' of block to free
;       Out:    successful, carry clear
;               failed, carry set

        assume  ds:DGROUP,es:DGROUP
        public  i31_FreeMem

i31_FreeMem     proc    near

        mov     si,[bp].pmUserSI
        mov     di,[bp].pmUserDI

        FBOP    BOP_DPMI, FreeXmem, FastBop

        jnc     @f

        jmp     i31_fail_CY

@@:     jmp     i31_Done

i31_FreeMem     endp


; -------------------------------------------------------
;  Service 05/03 -- Resize Memory Block
;
;       In:     bx:cx - new size of block to allocate in bytes
;               si:di - 'handle' of block to free
;       Out:    successful, carry clear &
;                       bx:cx = linear memory address of block
;                       si:di = handle to block
;               failed, carry set

        assume  ds:DGROUP,es:DGROUP
        public  i31_SizeMem

i31_SizeMem     proc    near

        mov     bx,[bp].pmUserBX
        mov     cx,[bp].pmUserCX
        mov     si,[bp].pmUserSI
        mov     di,[bp].pmUserDI

        FBOP    BOP_DPMI, ReallocXmem, FastBop

        jnc     @f

        jmp     i31_fail_CY

@@:     mov     [bp].intUserBX,bx
        mov     [bp].intUserCX,cx
        mov     [bp].intUserSI,si
        mov     [bp].intUserDI,di
        jmp     i31_Done

i31_SizeMem     endp


; -------------------------------------------------------
;  Service 09/00 -- Get and Disable Virtual Interrupt State
;          09/01 -- Get and Enable Virtual Interrupt State
;          09/02 -- Get Virtual Interrupt State
;
;       In:     none
;       Out:    AL = previous interrupt state

        assume  ds:DGROUP,es:DGROUP
        public  i31_VirtualInt

i31_VirtualInt  proc    near

        mov     ah,byte ptr [bp].intUserFL+1    ;get/isolate user's IF in AH
        shr     ah,1
        and     ah,1

        cmp     byte ptr [bp].intUserAX,Get_Int_State   ;only getting state?
        jz      @f                                      ;  yes, skip set

        mov     al,byte ptr [bp].intUserAX      ;get desired state
        shl     al,1                            ;  move into IF position

        and     byte ptr [bp].intUserFL+1,not 02h       ;clr old IF bit
        or      byte ptr [bp].intUserFL+1,al            ;  set desired
@@:
        mov     byte ptr [bp].intUserAX,ah      ;return old state in user's AL

        jmp     i31_done

i31_VirtualInt  endp

; -------------------------------------------------------
        subttl  INT 31h Utility Routines
        page
; -------------------------------------------------------
;               INT 31h UTILITY ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
;  i31_Version -- Return Int 31h version information.
;
;       In:     none
;       Out:    ah - major version
;               al - minor version
;               bx - flags
;               cl - processor type
;               dh - master PIC base interrupt
;               dl - slave PIC bas interrupt
;

        public  i31_Version
        assume  ds:DGROUP,es:DGROUP

i31_Version     proc    near

        mov     [bp].intUserAX,I31VERSION
        mov     [bp].intUserBX,I31FLAGS
        mov     al,byte ptr idCpuType
        mov     byte ptr [bp].intUserCX,al
        mov     [bp].intUserDX,(I31MasterPIC SHL 8) OR I31SlavePIC

        jmp     i31_done

i31_Version     endp

; -------------------------------------------------------
;  i31_MemGetHeader -- Get selector to our header on a Int 31h allocated
;       DOS memory block.
;
;       In:     DX - SELECTOR of block to get header of
;       Out:    ES - selector pointing to our header for block
;       Uses:   none

        public  i31_MemGetHeader
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

i31_MemGetHeader  proc  near

; User wants to release block pointed to by selector in DX.  Use a scratch
; selector to point 1 paragraph before that to make sure this is a block
; we allocated, and get some misc info

        push    ax
        push    bx
        push    cx
        push    dx

        mov     ax,dx
        call    GetSegmentAddress       ;BX:DX -> user's data area

        sub     dx,10h                  ;backup one paragraph
        sbb     bx,0

        mov     cx,0fh
        mov     ax,SEL_SCR0 or STD_TBL_RING
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

        mov     es,ax

        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

i31_MemGetHeader  endp

; -------------------------------------------------------
;   RZCall -- Utility routine to call a Ring
;       Zero procedure.  Stack parameter is the NEAR
;       address of the routine in the DXPMCODE segment to
;       call.  The called routine must be declared FAR
;       and take no stack parameters.
;
;   USES:       Whatever Ring 0 routine uses
;               +Flags
;   RETURNS:    Whatever Ring 0 routine returns
;
;   NOTE:       Assumes that interrupts must be disabled
;               for the Ring 0 routine.
;
;   History:
;       12-Feb-1991 -- ERH wrote it!!!
; -------------------------------------------------------

My_Call_Gate    dd      (SEL_SCR0 or STD_TBL_RING) shl 10h

        public  RZCall
RZCall proc near

        pushf
        FCLI
        push    bp
        mov     bp,sp
        cCall   NSetSegmentDscr,<SEL_SCR0,0,SEL_EH,0,[bp+6],STD_CALL>
        pop     bp

        call    dword ptr My_Call_Gate

        cCall   NSetSegmentDscr,<SEL_SCR0,0,0,0,-1,STD_DATA>

        npopf

        retn    2

RZCall endp

ife     NO386

i31_Debug_Register_Access proc near

        or      byte ptr [bp].intUserFL,1       ;set carry flag
        cmp     idCpuType,3                     ;at least 386?
        jb      i31_Debug_Register_Access_Done  ;No.

IFNDEF WOW_x86
        push    offset DXPMCODE:I31_Win386_Call
        call    RZCall
ELSE
        call    far ptr I31_Win386_Call
ENDIF
i31_Debug_Register_Access_Done:
        jmp     i31_exit

i31_Debug_Register_Access endp

        .386

;******************************************************************************
;
; I31_Win386_Call
;
; The routine to implement the INT 31h debug register functions is copied
; directly from the WIN386 routine in vmm/int31.asm.  This routine sets
; up the 386 registers so that the actual API is callable from the 16-bit
; DOS Extender.
;
;******************************************************************************
I31_Win386_Call proc far        ; Called via ring-transition call gate
;
; Save 386 extended registers that are used by the WIN386 code.
;
        pushad
;
; Call the actual routine
;
        movzx   ebp,bp

        call    I31_Debug_Register_Support
;
; Restore 386 extended registers that are used by the WIN386 code.
;
        popad
        ret

I31_Win386_Call endp

DXPMCODE        ends

;******************************************************************************
;                                R E C O R D S
;******************************************************************************

;
; The following record defines the debug status register.
;
DBG6 RECORD     d6_r1:16,d6_bt:1,d6_bs:1,d6_bd:1,d6_r2:9,d6_b3:1,d6_b2:1,d6_b1:1,d6_b0:1
DBG6_RESERVED   EQU     (MASK d6_r1) OR (MASK D6_r2)

;
; The following record defines the debug control register.
;
DBG7 RECORD     d7_ln3:2,d7_rw3:2,d7_ln2:2,d7_rw2:2,d7_ln1:2,d7_rw1:2,d7_ln0:2,d7_rw0:2,d7_rs:6,d7_ge:1,d7_le:1,d7_g3:1,d7_l3:1,d7_g2:1,d7_l2:1,d7_g1:1,d7_l1:1,d7_g0:1,d7_l0:1
DBG7_RESERVED   EQU     (MASK d7_rs)

Num_Watchpoints EQU 4       ; Only 4 live watchpoints in 386, 486.

;******************************************************************************
;                                m a c r o s
;******************************************************************************

;******************************************************************************
;
; The following set of macros allows us to copy WIN386 code directly
;
;******************************************************************************

BeginProc       macro   fname
        fname   proc    near
endm

EndProc         macro   fname
        fname   endp
endm

Assert_Client_Ptr       macro   dummy
endm

Client_Flags    equ     intUserFL
Client_EAX      equ     intUserAX
Client_AX       equ     intUserAX
Client_BX       equ     intUserBX
Client_CX       equ     intUserCX
Client_DX       equ     intUserDX

CF_MASK         equ     1

OFFSET32        equ     <OFFSET>



;******************************************************************************
;                                   d a t a
;******************************************************************************

DXDATA          segment

PUBLIC Debug_Regs
;
; A memory image of the debug registers.  The first version assumes
; that we have complete control over the debug registers, so only
; one copy is needed.
;
        ALIGN   DWORD
Debug_Regs      LABEL   DWORD
DD_DR0          dd      0
DD_DR1          dd      0
DD_DR2          dd      0
DD_DR3          dd      0

DD_DR6          dd      0
DD_DR7          dd      0

DXDATA          ends

        .386p

DXPMCODE        segment

;******************************************************************************
;
; I31_Debug_Register_Support
;
; ENTRY: AL = Function code
;           01 -- Set debug watchpoint
;               BX:CX = linear address of watchpoint
;               DL    = size of watchpoint (1, 2, or 4)
;               DH    = type of watchpoint
;                       0 = Execute
;                       1 = Write
;                       2 = Read/Write
;
;               Returns
;                       BX = debug watchpoint handle
;
;           02 -- Clear debug watchpoint
;
;           03 -- Get state of debug watchpoint
;               Returns
;               AX    = bit 0 set if watch point has been executed
;
;           04 -- Reset debug watchpoint
;
; EXIT: Carry clear in client flags if successful
;       Carry set in client flags if not
;
; USES: EDI, EAX, ECX, EDX, ESI
;
; History:
;   08-Feb-1991 -- ERH wrote it.
;
;******************************************************************************
BeginProc   I31_Debug_Register_Support

IFNDEF WOW_x86
        call    Store_DBG_Regs                  ; make copy of debug regs.
ENDIF

        test    [DD_DR6],MASK d6_bd
        jnz     DD_I31_Error                    ; ICE-386 is active!
        and     [ebp.Client_Flags],NOT CF_MASK

        mov     eax, dword ptr [ebp.Client_EAX]
        cmp     al, 03h
        ja      DD_I31_Error
        je      DD_I31_Reset_Watchpoint
        cmp     al, 01h
        ja      DD_I31_Get_Status
        je      DD_I31_Clear_Watchpoint

;
;   Function AX = 0A00h -- Set Debug Watchpoint
;
PUBLIC DD_I31_Set_Watchpoint
DD_I31_Set_Watchpoint:
        xor     ecx, ecx
        mov     edx,(MASK d7_l0) OR (MASK d7_g0); EDX = DR0 enable bits
DD_I31_Search_Loop:
;
; Look for an unused breakpoint.  In order for a breakpoint to be
; unused, the corresponding global and local enable bits must be clear.
;
        test    [DD_DR7],edx
        jz      SHORT DD_I31_SW_Found_One
DD_I31_SkipIt:
        shl     edx,2                   ; EDX = next BP's enable bits
        inc     ecx
        cmp     ecx, Num_Watchpoints
        jb      DD_I31_Search_Loop
        jmp     DD_I31_Error

DD_I31_SW_Found_One:
        mov     esi, OFFSET32 Debug_Regs
        mov     eax,ecx
        shl     eax,2
        add     esi,eax                         ; ESI -> BP address buffer
        mov     ax, [ebp.Client_BX]
        shl     eax, 16
        mov     ax, [ebp.Client_CX]             ; EAX = linear address
        mov     dword ptr [esi],eax             ; record address
        or      [DD_DR7],edx                    ; enable the break point

        mov     edx,NOT((MASK d7_ln0) OR (MASK d7_rw0))
        shl     cl,2
        rol     edx,cl
        shr     cl,2
        and     [DD_DR7],edx                    ; clear type and size bits
;
; Client_DX =
;       DH = 0 : execute
;       DH = 1 : write
;       DH = 2 : read/write
;
;       DL = 1 : byte
;       DL = 2 : word
;       DL = 4 : dword
;
        movzx   edx,[ebp.Client_DX]             ; load BP size and type
        cmp     dh,0                            ; execute?
        jne     SHORT @F                        ; no
        mov     dl,1                            ; yes, force size zero
@@:

        cmp     dl,4                            ; check for valid values
        ja      DD_I31_Error                    ; size in dl is 1, 2, or 4
        cmp     dl,3
        je      DD_I31_Error
        dec     dl                              ; DL = 0, 1, or 3 for DR7
        js      DD_I31_Error                    ; len field

        cmp     dh,2                            ; type in dh is 0, 1, or 2
        ja      DD_I31_Error

        jne     SHORT @F
        inc     dh                              ; 386 wants 3, not 2
@@:                                             ; DH = RWn field
        shl     dl,2
        or      dl,dh
        xor     dh,dh
        shl     edx,d7_rw0
        shl     cl,2
        shl     edx,cl
        or      [DD_DR7],edx                    ; set size, type
        shr     cl,2

        mov     edx,NOT (MASK d6_b0)            ; clear triggered bit
        rol     edx,cl                          ; EDX = mask to clear hit
        and     [DD_DR6],edx                    ; clear triggered bit
        mov     [ebp.Client_BX],cx              ; return address register
                                                ; number as BP handle
        or      [DD_DR7],(MASK d7_ge) OR (MASK d7_le)
                                                ; enable debugging
        call    Load_DBG_Regs           ; load changes into debug registers
        ret
;
;   Function AX = 0A01h -- Clear Debug Watchpoint
;
;   Error if Watchpoint not previously set.  In that case, do nothing.
;   If Watchpoint was set, then clear enable bits, triggered bit, and
;   breakpoint address.
;
PUBLIC DD_I31_Clear_Watchpoint
DD_I31_Clear_Watchpoint:
        movzx   ecx,[ebp.Client_BX]
        cmp     ecx, Num_Watchpoints
        jnb     DD_I31_Error

        mov     edx,(MASK d7_l0) OR (MASK d7_g0); EDX = enable DR0 mask
        shl     edx,cl
        shl     edx,cl                          ; EDX = enable DRn mask
        test    [DD_DR7],edx                    ; BP set?
        jz      DD_I31_Error                    ; No, error.
        not     edx
        and     [DD_DR7],edx                    ; disable the BP
        mov     edx,NOT (MASK d6_b0)            ; EDX = DR0 not hit
        rol     edx,cl                          ; EDX = DRn not hit
        and     [DD_DR6],edx                    ; clear triggered bit
        mov     esi, OFFSET32 Debug_Regs        ; ESI -> DRn table
        shl     ecx,2                           ; ECX = DWORD offset
        add     esi,ecx                         ; ESI -> DRn
        mov     dword ptr [esi],0               ; clear address
        mov     edx,NOT((MASK d7_ln0) OR (MASK d7_rw0))
        rol     edx,cl
        and     [DD_DR7],edx
;
; Test whether this leaves any breakpoints active.  If not, disable
; the exact match condition.  Note: the following is a long line.
;
        test    [DD_DR7],(MASK d7_g3) OR (MASK d7_l3) OR (MASK d7_g2) OR (MASK d7_l2) OR (MASK d7_g1) OR (MASK d7_l1) OR (MASK d7_g0) OR (MASK d7_l0)
        jne     SHORT @F
        and     [DD_DR7],NOT ((MASK d7_ge) OR (MASK d7_le))
@@:
        call    Load_DBG_Regs           ; load changes into debug registers
        ret
;
;   Function AX = 0A02h -- Get Status of Debug Watchpoint
;
PUBLIC DD_I31_Get_Status
DD_I31_Get_Status:
        movzx   ecx,[ebp.Client_BX]
        cmp     ecx, Num_Watchpoints
        jnb     SHORT DD_I31_Error

        mov     edx,(MASK d7_g0) OR (MASK d7_l0); EDX = DR0 enable bits
        shl     edx,cl
        shl     edx,cl                          ; EDX = DRn enable bits
        test    [DD_DR7],edx                    ; DRn enabled?
        jz      SHORT DD_I31_Error              ; No, error.
        mov     edx,MASK d6_b0                  ; EDX = DR0 hit mask
        shl     edx,cl                          ; EDX = DRn hit mask
        xor     eax,eax
        test    [DD_DR6],edx                    ; DRn hit?
        jne     SHORT @F                        ; no
        inc     al                              ; yes, store result
@@:
        mov     [ebp.Client_AX],ax
        ret
;
;   Function AX = 0A03h -- Reset Debug Watchpoint
;
PUBLIC DD_I31_Reset_Watchpoint
DD_I31_Reset_Watchpoint:
        movzx   ecx,[ebp.Client_BX]
        cmp     ecx, Num_Watchpoints
        jnb     SHORT DD_I31_Error

        mov     edx,(MASK d7_g0) OR (MASK d7_l0); EDX = DR0 enable bits
        shl     edx,cl
        shl     edx,cl                          ; EDX = DRn enable bits
        test    [DD_DR7],edx                    ; DRn enabled?
        jz      SHORT DD_I31_Error              ; No, error.
        mov     edx,NOT (MASK d6_b0)            ; EDX = DR0 hit mask
        rol     edx,cl                          ; EDX = DRn hit mask
        and     [DD_DR6],edx                    ; clear triggered bit
        call    Load_DBG_Regs           ; load changes into debug registers
        ret

DD_I31_Error:
        Assert_Client_Ptr ebp
        or      [ebp.Client_Flags], CF_Mask
        ret

EndProc  I31_Debug_Register_Support


;******************************************************************************
;
; Load_DBG_Regs - Load debug registers from memory.
;                 Do not change undefined bits.
;
; ENTRY: NONE
; EXIT: Memory image copied to debug registers, undefined bits unchanged.
; USES: eax, ecx, edi, esi
;
;******************************************************************************

BeginProc Load_DBG_Regs

        mov     esi,OFFSET32 Debug_Regs
        DPMIBOP SetDebugRegisters
        jnc     short ldr_exit

        cld
        xor     eax, eax
        mov     ecx, 6
        mov     edi, OFFSET32 Debug_Regs
        rep     stosd                       ;clear local copy
ldr_exit:
        ret

EndProc Load_DBG_Regs

; -------------------------------------------------------

IFNDEF WOW_x86
;******************************************************************************
;
; Load_DBG_Regs - Load debug registers from memory.
;                 Do not change undefined bits.
;
; ENTRY: NONE
; EXIT: Memory image copied to debug registers, undefined bits unchanged.
; USES: NONE
;
;******************************************************************************

BeginProc Load_DBG_Regs

        push    esi
        push    edx
        push    eax

        cld

        mov     esi,OFFSET32 Debug_Regs
        lods    dword ptr ds:[esi]
        mov     dr0, eax
        lods    dword ptr ds:[esi]
        mov     dr1, eax
        lods    dword ptr ds:[esi]
        mov     dr2, eax
        lods    dword ptr ds:[esi]
        mov     dr3, eax
        lods    dword ptr ds:[esi]
        and     eax,NOT DBG6_RESERVED
        mov     edx,dr6
        and     edx,DBG6_RESERVED
        or      eax,edx
        mov     dr6, eax
.ERRNZ  dd_dr6 - dd_dr3 - 4
        lods    dword ptr ds:[esi]
        and     eax,NOT DBG7_RESERVED
        mov     edx,dr7
        and     edx,DBG7_RESERVED
        or      eax,edx
        mov     dr7, eax

        pop     eax
        pop     edx
        pop     esi

        ret

EndProc Load_DBG_Regs

;******************************************************************************
;
; Store_DBG_Regs - Copy debug registers to memory.
;
; ENTRY: NONE
; EXIT: Debug registers copied to memory image.
;       Undefined bits = don't care.
; USES: NONE
;
;******************************************************************************

BeginProc Store_DBG_Regs

        push    eax
        push    edi

        cld

        mov     edi,OFFSET32 Debug_Regs
        mov     eax, dr0
        stos    dword ptr es:[edi]
        mov     eax, dr1
        stos    dword ptr es:[edi]
        mov     eax, dr2
        stos    dword ptr es:[edi]
        mov     eax, dr3
        stos    dword ptr es:[edi]
        mov     eax, dr6
.ERRNZ  dd_dr6 - dd_dr3 - 4
        stos    dword ptr es:[edi]
        mov     eax, dr7
        stos    dword ptr es:[edi]

        pop     edi
        pop     eax

        ret

EndProc Store_DBG_Regs
ENDIF   ; WOW_x86

; -------------------------------------------------------
endif   ; NO386


; -------------------------------------------------------
        subttl  INT 31h Raw Modeswitch Routines
        page
; -------------------------------------------------------
;               INT 31h Raw Modeswitch Routines
; -------------------------------------------------------

; -------------------------------------------------------
;  i31_GetSaveRestoreState -- Return Int 31h Save/Restore State addresses.
;
;       In:     none
;       Out:    ax - size of buffer required to save state
;               bx:cx - real mode address used to save/restore state
;               si:di - protected mode address used to save/restore state
;

        public  i31_GetStateSaveRestore
        assume  ds:DGROUP,es:DGROUP

i31_GetStateSaveRestore proc    near

        mov     [bp].intUserAX,0
        push    es
        push    SEL_DXCODE OR STD_RING
        pop     es
        assume  es:DXCODE
        mov     ax,segDXCode
        pop     es
        assume  es:DGROUP
        mov     [bp].intUserBX,ax
        mov     [bp].intUserCX,offset DXCODE:RmSaveRestoreState
        mov     [bp].intUserSI,SEL_DXPMCODE OR STD_RING
        test    DpmiFlags,DPMI_32BIT
        jz      gssr10

        mov     edi,dword ptr (offset DXPMCODE:PmSaveRestoreState)
gssr10: mov     [bp].intUserDI,offset DXPMCODE:PmSaveRestoreState

        jmp     i31_done

i31_GetStateSaveRestore endp

; -------------------------------------------------------
;  i31_GetRawModeSwitch -- Return Int 31h Save/Restore State addresses.
;
;       In:     none
;       Out:    bx:cx - real -> protected mode switch address
;               si:di - protected -> real mode switch address
;

        public  i31_GetRawModeSwitch
        assume  ds:DGROUP,es:DGROUP

i31_GetRawModeSwitch    proc    near

        push    es
        push    SEL_DXCODE OR STD_RING
        pop     es
        assume  es:DXCODE
        mov     ax,segDXCode
        pop     es
        assume  es:DGROUP
        mov     [bp].intUserBX,ax
        mov     [bp].intUserCX,offset DXCODE:RmRawModeSwitch
        mov     [bp].intUserSI,SEL_DXPMCODE OR STD_RING
        test    DpmiFlags,DPMI_32BIT
        jz      grms10

        mov     edi,dword ptr (offset DXPMCODE:PmRawModeSwitch)
grms10: mov     [bp].intUserDI,offset DXPMCODE:PmRawModeSwitch

        jmp     i31_done

i31_GetRawModeSwitch endp


;
; make sure 286 protect mode else code generated for mips will be wrong.
;
       .286p

; -------------------------------------------------------
;  Service 04/f1 - Allocate Space in LDT for Selector (WOW only)
;                Don't initialize the descriptor to Zero.
;              in: cx - # selectors required
;             out: ax - *index* of first selector

        assume  ds:DGROUP,es:DGROUP
        public  i31_WOW_AllocSel

i31_WOW_AllocSel    proc    near

        cmp     cx,1                    ;1 selector or more?
        ja      @f

        call    AllocateSelector        ;allocate 1 selector
        jc      i31_WOW_15
        jmp     short i31_WOW_10

@@:     mov     ax,cx                   ;WOW, cx != 0, allocate from higher range
        call    AllocateSelectorBlock   ;allocate a block of selectors
        jc      i31_WOW_15

i31_WOW_10:
        or      al,STD_TBL_RING         ;add standard table/ring bits
        mov     [bp].intUserAX,ax       ;return 1st/only selector in AX

        jmp     i31_done

i31_WOW_15:
        jmp     i31_fail          ;fail the request

i31_WOW_AllocSel    endp


; -------------------------------------------------------
;  Service 04/f2 - Set Descriptor (WOW only)
;               in: bx - selector
;                   cx - number of contiguous selectors

        assume  ds:DGROUP,es:DGROUP
        public  i31_WOW_SetDescriptor

i31_WOW_SetDescriptor  proc    near

        mov     ax,selGDT
        mov     es,ax
        assume  es:NOTHING
        lsl     ax,ax

        and     bx,SELECTOR_INDEX      ; input selector
        cmp     bx,ax                  ; range-test selector against
        jc      @F                     ;  the limit of the GDT/LDT
        jmp     i31_fail_CY

@@:
        cCall   NWOWSetDescriptor,<cx,es,bx>
        jmp     i31_done

i31_WOW_SetDescriptor  endp

; -------------------------------------------------------
;  Service 04/f3 - Set Descriptor (WOW only)
;               in: bx:dx -- pointer to low memory allocation routine
;                   si:di -- pointer to low memory free routine

        assume  ds:DGROUP,es:DGROUP
        public  i31_WOW_SetAllocFunctions

i31_WOW_SetAllocFunctions  proc    near

        mov     word ptr [LowMemAllocFn],dx
        mov     word ptr [LowMemAllocFn + 2],bx
        mov     word ptr [LowMemFreeFn],di
        mov     word ptr [LowMemFreeFn + 2], si
        jmp     i31_done

i31_WOW_SetAllocFunctions endp

DXPMCODE    ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxintr.asm ===
PAGE    ,132
        TITLE   DXINTR.ASM  -- Dos Extender Interrupt Reflector

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXINTR.ASM      -   Dos Extender Interrupt Reflector    *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Revision History:                                           *
;*                                                              *
;*                                                              *
;*  09/13/90 earleh  Fault handlers Ring 0                      *
;*  09/06/90 earleh  Fault handlers DPMI compliant              *
;*                   PIC remapping no longer required           *
;*  08/08/90 earleh  DOSX and client privilege ring determined  *
;*      by equate in pmdefs.inc                                 *
;*  05/09/90 jimmat  Started VCPI changes.                      *
;*  04/02/90 jimmat  Added PM Int 70h handler.                  *
;*  01/08/90 jimmat  Don't allow nested PS/2 mouse interrupts   *
;*                   (later removed!)                           *
;*  09/15/89 jimmat  Support for 'Classic' HP Vectras which     *
;*                   have 3 8259 interrupt controllers          *
;*  07/28/89 jimmat  Save A20 state when reflecting an int to   *
;*                   protected mode, removed Int 30h handler    *
;*                   that did code patch-ups, point debugger    *
;*                   to faulting instruction, not Int 3.        *
;*  07/13/89 jimmat  Improved termination due to faults when    *
;*                   not running under a debugger--also ifdef'd *
;*                   out code to dynamically fixup code seg     *
;*                   references on GP faults                    *
;*  06/05/89 jimmat  Ints 0h-1Fh are now vectored through a 2nd *
;*                   table.  This allows Wdeb386 interaction    *
;*                   more like Windows/386.                     *
;*  05/23/89 jimmat  Added wParam & lParam to interrupt frame.  *
;*  05/07/89 jimmat  Added XMScontrol function to map protected *
;*                   mode XMS requests to real mode driver.     *
;*  05/02/89 jimmat  8259 interrupt mask saved around changing  *
;*                   of hardware interrupt base                 *
;*  04/24/89 jimmat  Added support for PS/2 Int 15h/C2h/07 Set  *
;*                   Pointing Device Handler Address function   *
;*  04/12/89 jimmat  Added PMIntr24 routine to support PM       *
;*                   Critical Error Handlers                    *
;*  03/15/89 jimmat  Added INT 31h LDT/heap interface a la      *
;*                   Windows/386                                *
;*  03/14/89 jimmat  Changes to run child in ring 1 with LDT    *
;*  02/24/89 (GeneA): fixed problem in IntEntryVideo and        *
;*      IntExitVideo for processing function 10h subfunction    *
;*      for reading and writing the VGA palette.                *
;*  02/22/89 (GeneA): added handlers for Int 10h, Int 15h, and  *
;*      Int 33h.  Added support for more general mechanism for  *
;*      handling interrupts require special servicing and       *
;*      allowing nesting of these interrupts.  Allocation and   *
;*      deallocation of stack frames is supported to allow      *
;*      nested paths through the interrupt reflection code to   *
;*      a depth of 8.                                           *
;*      There is still a problem that if an interrupt handler   *
;*      is using a static buffer to transfer data, another      *
;*      interrupt that uses the same static buffer could come   *
;*      in and trash it.  Solving the problem in a completely   *
;*      general way would require having a buffer allocation    *
;*      deallocation scheme for doing the transfers between     *
;*      real mode memory and protected mode memory.             *
;*  02/14/89 (GeneA): added code in TrapGP to print error msg   *
;*      and quit when running a non-debugging version.          *
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*      medium model.  Added function LoaderTrap to handle      *
;*      loader interrupts when the program contains overlays.   *
;*  11/20/88 (GeneA): changed both RM and PM interrupt reflector*
;*      routines to pass the flags returned by the ISR back to  *
;*      the originator of the interrupt, rather than returning  *
;*      the original flags.                                     *
;*  10/28/88 (GeneA): created                                   *
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;*                                                              *
;****************************************************************

        .286p
        .287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include interupt.inc
ifdef WOW_x86
include vdmtib.inc
endif
        .list
include intmac.inc
include stackchk.inc
include bop.inc
include dpmi.inc

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   ParaToLinear:NEAR
externFP        NSetSegmentDscr
ifdef   NEC_98
        extrn   GetSegmentAddress:NEAR
endif   ;NEC_98
        extrn   ParaToLDTSelector:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   pmusrss:WORD
        extrn   pmusrsp:WORD
        extrn   npXfrBuf1:WORD
        extrn   rgbXfrBuf0:BYTE
        extrn   rgbXfrBuf1:BYTE
        extrn   lpfnXMSFunc:DWORD
        extrn   Int28Filter:WORD
        extrn   DpmiFlags:WORD
IFDEF WOW_x86
        extrn   FastBop:fword
ENDIF

;
; Variables used to store register values while mode switching.

        public  regUserSS, regUserSP, regUserFL, regUserAX, regUserDS
        public  regUserES

regUserSS       dw      ?
regUserSP       dw      ?
regUserCS       dw      ?
regUserIP       dw      ?
regUserFL       dw      ?
regUserAX       dw      ?
regUserDS       dw      ?
regUserES       dw      ?
pfnReturnAddr   dw      ?

Int28Count      dw      -1      ;Count of idle Int 28h's not reflected to RM

;
; Far pointer to the user's mouse callback function.

        public  lpfnUserMouseHandler

lpfnUserMouseHandler dd 0       ;Entry point to the users mouse handler
cbMouseState    dw      0       ;size of mouse state buffer in bytes


; Far pointer to PS/2 Pointing device handler address

        public  lpfnUserPointingHandler

lpfnUserPointingHandler dd      0       ;Sel:Off to user's handler

        align   2

if DEBUG
        extrn   StackGuard:WORD
endif
        extrn   pbReflStack:WORD
        extrn   bReflStack:WORD
;
; This buffer contains the original real mode interrupt vectors.
ifdef   NEC_98
        public  rglpfnRmISR
endif   ;NEC_98

        align   2
rglpfnRmISR     dd  256 dup (?)

; PMFaultVector is a table of selector:offsets for routines to process
; protected mode processor faults/traps/exceptions.  If we don't handle
; the exception as an exception, we vector it through PMReservedEntryVector.

FltRtn  macro  off
        dw      DXPMCODE:off
        dw      0
        dw      SEL_DXPMCODE or STD_RING
        dw      0
        endm
        public  PMFaultVector

        align   4

PMFaultVector   label   DWORD
        FltRtn  PMFaultEntryVector+5*0h      ; int 0
        FltRtn  PMFaultEntryVector+5*1h      ; int 1
        FltRtn  PMFaultEntryVector+5*2h      ; int 2
        FltRtn  PMFaultEntryVector+5*3h      ; int 3
        FltRtn  PMFaultEntryVector+5*4h      ; int 4
        FltRtn  PMFaultEntryVector+5*5h      ; int 5
        FltRtn  PMFaultEntryVector+5*6h      ; int 6
        FltRtn  PMFaultEntryVector+5*7h      ; int 7
        FltRtn  PMFaultEntryVector+5*8h      ; int 8
        FltRtn  PMFaultEntryVector+5*9h      ; int 9
        FltRtn  PMFaultEntryVector+5*0Ah     ; int a
        FltRtn  PMFaultEntryVector+5*0Bh     ; int b
        FltRtn  PMFaultEntryVector+5*0Ch     ; int c
        FltRtn  PMFaultEntryVector+5*0Dh     ; int d
        FltRtn  PMFaultEntryVector+5*0Eh     ; int e
        FltRtn  PMFaultEntryVector+5*0Fh     ; int f
        FltRtn  PMFaultEntryVector+5*10h     ; int 10h
        FltRtn  PMFaultEntryVector+5*11h     ; int 11h
        FltRtn  PMFaultEntryVector+5*12h     ; int 12h
        FltRtn  PMFaultEntryVector+5*13h     ; int 13h
        FltRtn  PMFaultEntryVector+5*14h     ; int 14h
        FltRtn  PMFaultEntryVector+5*15h     ; int 15h
        FltRtn  PMFaultEntryVector+5*16h     ; int 16h
        FltRtn  PMFaultEntryVector+5*17h     ; int 17h
        FltRtn  PMFaultEntryVector+5*18h     ; int 18h
        FltRtn  PMFaultEntryVector+5*19h     ; int 19h
        FltRtn  PMFaultEntryVector+5*1Ah     ; int 1ah
        FltRtn  PMFaultEntryVector+5*1Bh     ; int 1bh
        FltRtn  PMFaultEntryVector+5*1Ch     ; int 1ch
        FltRtn  PMFaultEntryVector+5*1Dh     ; int 1Dh
        FltRtn  PMFaultEntryVector+5*1Eh     ; int 1Eh
        FltRtn  PMFaultEntryVector+5*1Fh     ; int 1Fh


        extrn   npEHStackLimit:word
        extrn   npEHStacklet:word
ifdef      NEC_98
        extrn   fPCH98:BYTE
endif   ;NEC_98
IFDEF WOW
        public Wow16BitHandlers
Wow16BitHandlers        dw      256 dup (0,0)

ENDIF

DXDATA  ends


DXSTACK segment

        public      rgw0Stack, rgw2FStack

            dw      64 dup (?)          ; INT 2Fh handler stack

rgw2FStack  label   word

            dw      64 dup (?)          ; DOSX Ring -> Ring 0 transition stack
;
; Interrupts in the range 0-1fh cause a ring transition and leave
; an outer ring IRET frame right here.
;
Ring0_EH_DS             dw      ?       ; place to put user DS
Ring0_EH_AX             dw      ?       ; place to put user AX
Ring0_EH_BX             dw      ?       ; place to put user BX
Ring0_EH_CX             dw      ?       ; place to put user CX
Ring0_EH_BP             dw      ?       ; place to put user BP
Ring0_EH_PEC            dw      ?       ; lsw of error code for 386 page fault
                                ; also near return to PMFaultEntryVector
Ring0_EH_EC             dw      ?       ; error code passed to EH
Ring0_EH_IP             dw      ?       ; interrupted code IP
Ring0_EH_EIP            dw      ?       ; high half eip
Ring0_EH_CS             dw      ?       ; interrupted code CS
                        dw      ?       ; high half of cs
Ring0_EH_Flags  dw      ?       ; interrupted code flags
Ring0_EH_EFlags         dw      ?       ; high half of flags
Ring0_EH_SP             dw      ?       ; interrupted code SP
Rin0_EH_ESP             dw      ?       ; high half of esp
Ring0_EH_SS             dw      ?       ; interrupted code SS
                        dw      ?       ; high half of ss
rgw0Stack   label   word

                dw      64 dup (?)      ; stack for switching to ring0
        public ResetStack
ResetStack     label word
ifdef WOW_x86
                dw      64 dup (?)      ; wow stack for initial int field
        public rgwWowStack
rgwWowStack     label word
endif

DXSTACK ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   selDgroup:WORD

DXCODE  ends

DXPMCODE    segment

        extrn   selDgroupPM:WORD
        extrn   segDXCodePM:WORD
        extrn   RZCall:NEAR
        extrn   segDXDataPM:WORD

DXPMCODE    ends

; -------------------------------------------------------
        page
        subttl  Protected Mode Interrupt Reflector
; -------------------------------------------------------
;       PROTECTED MODE INTERRUPT REFLECTOR
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE
; -------------------------------------------------------
;   PMIntrEntryVector   -- This table contains a vector of
;       near jump instructions to the protected mode interrupt
;       reflector.  The protected mode interrupt descriptor
;       table is initialized so that all interrupts jump to
;       locations in this table, which transfers control to
;       the interrupt reflection code for reflecting the
;       interrupt to real mode.

StartBopTable macro
        ?intr = 0
        endm

PMIntrBop  macro
        DPMIBOP ReflectIntrToV86
        db      ?intr
        ?intr = ?intr+1
        endm

        public      PMIntrEntryVector

PMIntrEntryVector:

        StartBopTable
        rept    256
        PMIntrBop
        endm


FaultBop  macro
        DPMIBOP DpmiUnhandledException
        db      ?intr
        ?intr = ?intr+1
        endm

        public  PMFaultEntryVector

; -------------------------------------------------------
;   PMFaultEntryVector   -- This table contains a vector of
;       near jump instructions to the protected mode fault
;       analyzer.
;
PMFaultEntryVector:

        StartBopTable
        rept    32
        FaultBop
        endm

        assume ds:nothing,es:nothing,ss:nothing

        public  PMFaultHandlerIRET
PMFaultHandlerIRET:
        DPMIBOP FaultHandlerIret

        public  PMFaultHandlerIRETD
PMFaultHandlerIRETD:
        DPMIBOP FaultHandlerIretd

        public  PMIntHandlerIRET
PMIntHandlerIRET:
        DPMIBOP IntHandlerIret

        public  PMIntHandlerIRETD
PMIntHandlerIRETD:
        DPMIBOP IntHandlerIretd

        public  PMDosxIret
PMDosxIret:
        iret

        public  PMDosxIretd
PMDosxIretd:
        db      66h
        iret

        public  HungAppExit
HungAppExit:
        mov     ax,4CFFh
        int     21h

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Real Mode Interrupt Reflector
        page
; -------------------------------------------------------
;           REAL MODE INTERRUPT REFLECTOR
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE
; -------------------------------------------------------
;   RMIntrEntryVector   -- This table contains a vector of
;       near jump instructions to the real mode interrupt
;       reflector.  Real mode interrupts that have been hooked
;       by the protected mode application have their vector
;       set to entry the real mode reflector through this table.

        public RMtoPMReflector
RMtoPMReflector:
        DPMIBOP ReflectIntrToPM

        public  RMCallBackBop
RMCallBackBop proc far
        DPMIBOP RMCallBackCall
        ret                             ;finished!

RMCallBackBop endp
DXCODE  ends

; -------------------------------------------------------
        subttl  INT 24h Critical Error Mapper
        page
; -------------------------------------------------------
;               DOS CRITICAL ERROR MAPPER
; -------------------------------------------------------

DXCODE segment

; -------------------------------------------------------
; RMDefaultInt24Handler -- Default action for a DOS critical
;                          error is to fail the call.
;
        public  RMDefaultInt24Handler
RMDefaultInt24Handler   proc far
        mov     al,3
        iret
RMDefaultInt24Handler   endp

DXCODE ends

; -------------------------------------------------------
        subttl  INT 28h Idle Handler
        page
; -------------------------------------------------------
;                INT 28H IDLE HANDLER
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr28 -- Protected mode handler for Idle Int 28h calls.
;       The purpose of this routine is simply to cut down on the
;       number of protected mode to real mode switches by ignoring
;       many of the Int 28h idle calls made by the Windows PM
;       kernel.

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr28

PMIntr28        proc    near


        cld
        push    ds                              ;address our DGROUP
        mov     ds,selDgroupPM
        assume  ds:DGROUP

        cmp     Int28Filter,0                   ;are we passing any through?
        jz      @f

        inc     Int28Count                      ;should this one be reflected?
        jz      i28_reflect
@@:
        pop     ds
        iret                                    ;  no, just ignore it

i28_reflect:                                    ;  yes, reset count and
        push    ax                              ;    reflecto to real mode
        mov     ax,Int28Filter
        neg     ax
        mov     Int28Count,ax
        pop     ax
        pop     ds
        assume  ds:NOTHING

        jmp     PMIntrEntryVector + 5*28h

PMIntr28        endp

; -------------------------------------------------------
;   PMIntr31 -- Service routine for the Protect Mode INT 31h
;               services.  These functions duplicate the
;               Windows/386 VMM INT 31h services for protected
;               mode applications.  They were implemented to
;               support a protect mode version of Windows/286.
;
;   Input:  Various registers
;   Output: Various registers
;   Errors:
;   Uses:   All registers preserved, other than return values

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr31

PMIntr31        proc    near

        push    ds
        push    ax
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        assume  ds:DGROUP
        pop     ax

        FBOP    BOP_DPMI,Int31Entry,FastBop
        int     3
;       This BOP does an implicit IRET

PMIntr31        endp


; -------------------------------------------------------
        subttl  Ignore Interrupt Handlers
        page
; -------------------------------------------------------
;             IGNORE INTERRUPT HANDLER
; -------------------------------------------------------

;   PMIntrIgnore -- Service routine for protected mode interrupts
;       that should be ignored, and not reflected to real mode.
;       Currently used for:
;
;                   Int 30h - used to be Win/386 Virtualize I/O, now
;                             unused but no int handler in real mode
;                   Int 41h - Wdeb386 interface, no int handler in
;                             real mode

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrIgnore

PMIntrIgnore    proc    near

        iret

PMIntrIgnore    endp

; -------------------------------------------------------

        public PMIntr19
PMIntr19        proc    near

        push    offset DXPMCODE:Reboot
        call    RZCall

bpRebootIDT     df      0

Reboot:
        mov     ax,40h
        mov     es,ax
        mov     word ptr es:[0072h],1234h
        lidt    bpRebootIDT
        int     3

PMIntr19        endp

DXPMCODE ends

; -------------------------------------------------------
        subttl  XMS Driver Interface
        page
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   XMScontrol - This function implements a protected mode
;       interface to a real mode XMS driver.  Unlike other
;       routines in this module, this routine is called by
;       the user, not invoked via an INT instruction.
;
;   Input:  User's regs for XMS driver
;   Output: regs from XMS driver
;   Uses:   none

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  XMScontrol

XMScontrol  proc  far

        jmp     short XMSentry          ;'standard' XMS control function
        nop                             ;  just to be consistant
        nop
        nop

XMSentry:

; Modify the stack so it looks like we got here via an INT (except that
; we may still have interrupts enabled)

        pushf
        cld

        push    bp
        mov     bp,sp                   ;bp -> [BP] [FL] [IP] [CS]
        push    ax
        push    bx

        mov     ax,[bp+4]
        mov     bx,[bp+6]
        xchg    ax,[bp+2]
        mov     [bp+4],bx
        mov     [bp+6],ax               ;bp -> [BP] [IP] [CS] [FL]
        pop     bx
        pop     ax
        pop     bp

; We don't support XMS function 0Bh (Move Extended Memory Block) because
; it requires mapping of data between hi/low memory.  Maybe someday...

        cmp     ah,0Bh
        jnz     xms_2
xms_deny:
        xor     ax,ax                   ;if function 0Bh, return failure
        mov     bl,80h                  ;  (ax = 0, bl = 80h-not implemented)
        jmp     short XMSret
xms_2:

; We are not really an Int handler, but close enough...

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:DGROUP     ;  also sets up addressability

        SwitchToRealMode

        pop     es                              ;load regs for driver
        pop     ds
        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        popa
        npopf

        call    lpfnXMSFunc                     ;call real mode driver

        pushf                                  ;rebuild stack frame
        FCLI
        cld
        pusha
        push    ds
        push    es

        mov     bp,sp                           ;restore stack frame pointer

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP

        call    LeaveIntHandler
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

XMSret:
        riret

XMScontrol  endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Special Interrupt Handler Routines
        page
; -------------------------------------------------------
;
;   The following sets of routines handle interrupts that
;   are function call interfaces and require special servicing
;   by the Dos Extender.  These interrupts are such things as
;   the mouse driver function call interrupt, various PC BIOS
;   function call interrupts, etc.  Note that INT 21h (the Dos
;   function call interrupt) is not handled here.  These
;   interrupts typically require that register values be modified
;   and parameter data be copied between real mode memory and
;   extended memory.  The following conventions are used for these
;   interrupt function handler routines.
;
;   A stack is allocated from the interrupt reflector stack for these
;   routines to use.  This allows nested servicing of interrupts.
;   A stack frame is built in the allocated stack which contains the
;   following information:
;           original caller's stack address
;           caller's original flags and general registers (in pusha form)
;           caller's original segment registers (DS & ES)
;           flags and general registers to be passed to interrupt routine
;               (initially the same as caller's original values)
;           segment registers (DS & ES) to be passed to interrupt routine
;               (initially set to the Dos Extender data segment address)
;   This stack frame is built by the routine EnterIntHandler, and its
;   format is defined by the structure INTRSTACK.  The stack frame is
;   destroyed and the processor registers set up for return to the user
;   by the function LeaveIntHandler.
;
;   For each interrupt, there is an entry function and an exit function.
;   The entry function performs any modifications to parameter values and
;   data buffering necessary before the interrupt service routine is called.
;   The exit function performs any data buffering and register value
;   modifications after return from the interrupt service routine.
;
;   There are two sets of general registers and two sets of segment
;   registers (DS & ES) on the stack frame.  One set of register values
;   has member names of the form intUserXX.  The values in these stack
;   frame members will be passed to the interrupt service routine when
;   it is called, and will be loaded with the register values returned
;   by the interrupt service routine.  The other set of registers values
;   has member names of the form pmUserXX.  These stack frame members
;   contain the original values in the registers on entry from the
;   user program that called the interrupt.
;
;   When we return to the original caller, we want to pass back the
;   general registers as returned by the interrupt routine (and possibly
;   modified by the exit handler), and the same segment registers as
;   on entry, unless the interrupt routine returns a value in a segment
;   register. (in this case, there must be some code in the exit routine
;   to handle this).  This means that when we return to the caller, we
;   return the general register values from the intUserXX set of stack
;   frame members, but we return the segment registers from the pmUserXX
;   set of frame members.  By doing it this way, we don't have to do
;   any work for the case where the interrupt subfuntion doesn't require
;   any parameter manipulation.  NOTE however, this means that when
;   manipulating register values to be returned to the user, the segment
;   registers are treated opposite to the way the general registers are
;   treated.  For general registers, to return a value to the user,
;   store it in a intUserXX stack frame member.  To return a segment
;   value to the user, store it in a pmUserXX stack frame member.
;
; -------------------------------------------------------
        subttl  BIOS Video Interrupt (Int 10h) Service Routine
        page
; -------------------------------------------------------
;       BIOS VIDEO INTERRUPT (INT 10h) SERVICE ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntrVideo - Entry point into interrupt reflector code
;       for IBM PC Bios video (int 10h) calls.
;
;   Input:  normal registers for Bios calls
;   Output: normal register returns for Bios calls
;   Errors: normal Bios errors
;   Uses:   as per Bios calls

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrVideo

PMIntrVideo:

ifdef      NEC_98
        cmp     ah,40h
        jb      CRT_bios
        cmp     ah,4Fh                  ;4Bh-4Fh = Reserve
        ja      CRT_bios
        jmp     PMIntrGBIO

CRT_bios:
        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values

        call    IntEntryVideo
@@:
; Execute the interrupt service routine
        SwitchToRealMode
        assume  ss:DGROUP
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa
        call    rglpfnRmISR[4*18h]  ;execute the real mode interrupt routine
        pushf
        cli
        cld
        pusha
        push    ds
        push    es
        mov     bp,sp               ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP
;
; Perform fixups on the return register values.
        mov     ax,[bp].pmUserAX    ;get original function code

;;      test    fPCH98,0FFh             
;;      jz      NotNPCVideoExit         ;for PC-H98 modelxx
;;      call    IntExitVideoNPC         ;       "        
;;      jmp     @f                      ;       "        
;;NotNPCVideoExit:                      ;       "       
        call    IntExitVideo
@@:
;
; And return to the original caller.
        call    LeaveIntHandler

        iret

;/////////////////////////////////////////////////////////////////////////
;       Nmode GRAPH BIOS
;/////////////////////////////////////////////////////////////////////////
; -------------------------------------------------------
;       PMIntrGBIO
;--------------------------------------------------------


        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrGBIO

PMIntrGBIO:

        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values            

        push    ax                      
        mov     ax,[bp].pmUserDS        
        call    GetSegmentAddress       
        shr     dx,4                    
        shl     bx,12                   
        or      bx,dx                   ;bx now = seg of parent psp
        mov     [bp].intUserDS,bx       
        pop     ax                      
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*18h]  ;execute the real mode interrupt routine 
        pushf                                           
        cli
        cld
        pusha
        push    ds
        push    es
        
        mov     ax,ss
        mov     ds,ax
        mov     es,ax
        
        mov     bp,sp               ;restore stack frame pointer        
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code         
        push    ax                                      
        mov     ax,[bp].pmUserDS                        
        mov     [bp].intUserDS,ax                       
        pop     ax                                      
;
; And return to the original caller.                     
        call    LeaveIntHandler                         
        iret                                            
else    ;!NEC_98
        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values
        call    IntEntryVideo
;
; Execute the interrupt service routine
        SwitchToRealMode
        assume  ss:DGROUP
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     word ptr [bp + 6],offset piv_10
        mov     ax,es:[10h*4]
        mov     [bp + 2],ax
        mov     ax,es:[10h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

piv_10: pushf
        FCLI
        cld
        pusha
        push    ds
        push    es
        mov     bp,sp               ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP
;
; Perform fixups on the return register values.
        mov     ax,[bp].pmUserAX    ;get original function code
        call    IntExitVideo
;
; And return to the original caller.
        call    LeaveIntHandler

        riret
endif   ;!NEC_98

; -------------------------------------------------------
;   IntEntryVideo   -- This routine performs any register
;       fixups and data copying needed on entry to the
;       PC BIOS video interrupt (Int 10h)
;
;   Input:  register values on stack frame
;   Output: register values on stack frame
;   Errors: none
;   Uses:   any registers modified,
;           possibly modifies buffers rgbXfrBuf0 or rgbXfrBuf1

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntryVideo

IntEntryVideo:

ifdef      NEC_98
;video mode

        cmp     ah,0Fh                                  
        jnz     ienv10                                  
        mov     cx,16                                   
        jmp     ienv70                                  
ienv10:                                                 
        cmp     ah,14h                                  
        jnz     ienv20                                  
        jmp     ienv80                                  
ienv20:                                                 
        cmp     ah,1Fh                                  
        jnz     ienv30                                  
        jmp     ienv110                 
ienv30:                                 
        cmp     ah,1Ah                  
        jnz     ienv40                  
        test    fPCH98,0FFh             
        jnz     H98_FontWrite_N         
        mov     cx,34                   
        jmp     ienv70                  
ienv40:                                 
        cmp     ah,20h                  
        jnz     ienv90                  
        test    fPCH98,0FFh             
        jnz     @f                      
        mov     cx,72                   
        jmp     ienv100                 

@@:
        jmp     H98_FontWrite_H 

ienv70:
        push    ds 
        mov     si,[bp].pmUserCX        ;offset address  
        mov     ds,[bp].pmUserBX        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
ienv80:                                                 

        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserBX,ax       ;segment address
        pop     ax                                      

        mov     [bp].intUserCX,offset DGROUP:rgbXfrBuf1 
ienv90:                                                 
        ret                                             

ienv100:                                                
        push    ds                                      
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserDS        ;segment address
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
ienv110:                                                

        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserDS,ax       ;segment address

        pop     ax                                      

        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
ienv120:                                                
        ret                                             

H98_FontWrite_N:                                        

        cmp     dx,7601h                                
        jb      @f                                      
        cmp     dx,767Fh                                
        jna     WUSKZEN                                 
        cmp     dx,7701h                                
        jb      @f                                      
        cmp     dx,777Fh                                
        jna     WUSKZEN                                 
        cmp     dx,7801h                                
        jb      @f                                      
        cmp     dx,783Fh                                
;;;;;;;;        ja      ienv35                          
        jna     WUSKZEN                 
        jmp     ienv35                  
        
WUSKZEN:
        mov     cx,34                                  
        jmp     ienv70                                 

@@: 
        jmp     ienv40 

ienv35:
        cmp     dx,7840h  
        jb      @b        
        cmp     dx,787Fh  
        jna     WUSKHAN   
        cmp     dx,7D01h  
        jb      @b        
        cmp     dx,7D7Fh  
        jna     WUSKHAN   
        cmp     dx,7E01h  
        jb      @b        
        cmp     dx,7E7Fh  
;;;;;;;;        ja      @b
        jna     WUSKHAN   
        jmp     @b        
WUSKHAN:                  
        mov     cx,18     
        jmp     ienv70    

H98_FontWrite_H:      

        cmp     dx,7601h    
        jb      @f          
        cmp     dx,767Fh    
        jna     HWUSKZEN    
        cmp     dx,7701h    
        jb      @f          
        cmp     dx,777Fh    
        jna     HWUSKZEN    
        cmp     dx,7801h    
        jb      @f          
        cmp     dx,783Fh    
;;;;;;;;        ja      @f  
        jna     HWUSKZEN    
        jmp     ienv45      
HWUSKZEN:                   
;;;;;;;;        mov     cx,74 
        mov     cx,72         
        jmp     ienv100       

@@: 
        jmp     ienv90  

ienv45: 
        cmp     dx,7840h  
        jb      @f        
        cmp     dx,787Fh  
        jna     HWUSKHAN  
        cmp     dx,7D01h  
        jb      @f        
        cmp     dx,7D7Fh  
        jna     HWUSKHAN  
        cmp     dx,7E01h  
        jb      @f        
        cmp     dx,7E7Fh  
;;;;;;;;        ja      @f
        jna     HWUSKHAN  
        jmp     @f        
HWUSKHAN:
;;;;;;;;        mov     cx,50                           
        mov     cx,48                                   
        jmp     ienv100                 
@@:                                     
        ret                             
else    ;!NEC_98
        cmp     ah,10h
        jnz     ienv20
;
; Video palette control function.  Check for subfunctions that require
; special actions.
ienv10: cmp     al,2            ;update all palette registers?
        jnz     @F
        mov     cx,17           ;palette data is 17 bytes long
        jmp     short ienv70    ;go copy the data
;
@@:     cmp     al,9            ;read all palette registers
        jz      ienv72
;
        cmp     al,12h          ;update video DAC color registers
        jnz     @F
        mov     cx,[bp].pmUserCX    ;count of table entries is in caller CX
        add     cx,cx               ;each entry is 3 bytes long
        add     cx,[bp].pmUserCX
        jmp     short ienv70        ;go copy the data down

@@:     cmp     al,17h          ;read a block of video DAC registers
        jz      ienv72
;
        jmp     short ienv90
;
;
ienv20: cmp     ah,11h
        jnz     ienv30
;
; Character generator interface function.
;   NOTE: a number of subfunctions of function 11h need to have munging
;       and data buffering performed.  However, function 30h is the only
;       one used by Codeview, so this is the only one currently implemented.
;       For this one, nothing needs to be done on entry, only on exit.
        jmp     short ienv90
;
;
ienv30: cmp     ah,1Bh
        jnz     ienv40
;
; Video BIOS functionality/state information.
; On entry, we need to fix up ES:DI to point to our buffer.
        mov     [bp].intUserDI,offset DGROUP:rgbXfrBuf0
        jmp     short ienv90
;
;
ienv40:
        jmp     short ienv90
;
; Copy the buffer from the user ES:DX to our transfer buffer and set
; the value to DX passed to the interrupt routine to point to our buffer.
ienv70: cld
        jcxz    ienv90
        push    ds
        mov     si,[bp].pmUserDX
        mov     ds,[bp].pmUserES
        mov     di,offset DGROUP:rgbXfrBuf1
        cld
        rep     movsb
        pop     ds
;
ienv72: mov     [bp].intUserDX,offset DGROUP:rgbXfrBuf1
        jmp     short ienv90

;
; All done
ienv90:
        ret
endif   ;!NEC_98

; -------------------------------------------------------
;   IntExitVideo:   This routine performs any register
;       fixups and data copying needed on exit from the
;       PC BIOS video interrupt (Int 10h).
;
;   Input:  register values on stack frame
;   Output: register values on stack frame
;   Errors: none
;   Uses:   any registers modified
;           possibly modifies buffers rgbXfrBuf0 or rgbXfrBuf1

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExitVideo

IntExitVideo:

ifdef      NEC_98
;video mode

        cmp     ah,0Fh                                  
        jnz     iexv10                                  
        jmp     iexv80                                  
iexv10:                                                 
        cmp     ah,14h                                  
        jnz     iexv20                                  
        cmp     dh,00h                                  
        jnz     iexv11                                  
        mov     cx,10                                   
        jmp     iexv70                                  
iexv11:                                                 
        cmp     dh,80h          ;ANK(7*13)              
        jnz     iexv12                                  
        mov     cx,18                                   
        jmp     iexv70                                  
iexv12:                                                 
        test    fPCH98,0FFh             
        jnz     @f                      
        cmp     dx,2920h                
        jb      iexv13                  
        cmp     dx,297dh                
        ja      iexvhan1                
        mov     cx,18                   
        jmp     iexv70                  

iexvhan1:                                               
        cmp     dx,2a20h                                
        jb      iexv13                                  
        cmp     dx,2a5fh                                
        ja      iexv13                                  
        mov     cx,18                                   
        jmp     iexv70                                  

@@:                                                     
        jmp     H98_FontRead_N                          

iexv13:                                                 
        mov     cx,34                                   
        jmp     iexv70                                  

iexv20:                                                 
        cmp     ah,1Fh                                  
        jnz     iexv30                                  
        cmp     dh,00h                                  
        jnz     iexv21                                  
        mov     cx,48                                   
        jmp     iexv100         
iexv21:                         
        test    fPCH98,0FFh     
        jnz     @f              
        cmp     dx,2920h        
        jb      Hmode_han1      
        cmp     dx,297dh        
        ja      Hmode_han1                              
        mov     cx,48                                   
        jmp     iexv100         

Hmode_han1:
        cmp     dx,2a20h                                
        jb      iexv22                                  
        cmp     dx,2a5fh                                
        ja      iexv22                                  
        mov     cx,48                                   
        jmp     iexv100         

@@:                                                     
        jmp     H98_FontRead_H                          

iexv22:                                                 
        mov     cx,72           
        jmp     iexv100         
        
iexv30: 
        cmp     ah,1Ah          
        jnz     iexv40          
        jmp     iexv80          
        
iexv40: 
        cmp     ah,20h          
        jnz     iexv90          
        jmp     iexv110         

iexv70: 

        cld         
        push    es  
        mov     di,[bp].pmUserCX  
        mov     es,[bp].pmUserBX  
        mov     si,offset DGROUP:rgbXfrBuf1  
        rep     movsb                        
        pop     es                           
;
; Restore the caller's CX 
iexv80:                   
        push    ax        
        mov     ax,[bp].pmUserBX        ;BX regster restor
        mov     [bp].intUserBX,ax        
;------------------------------------------------------------
        mov     ax,[bp].pmUserCX         
        mov     [bp].intUserCX,ax        
        pop     ax                       
iexv90:                                  
        ret                              

iexv100: 

        cld     
        push    es   
        mov     di,[bp].pmUserBX  
        mov     es,[bp].pmUserDS  
        mov     si,offset DGROUP:rgbXfrBuf1   
        rep     movsb                         
        pop     es                            
;
; Restore the caller's CX  
iexv110:                   
        push    ax         
        mov     ax,[bp].pmUserDS        ;BX regster restor
        mov     [bp].intUserDS,ax        
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX                        
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
iexv120:                                                
        ret                                             

H98_FontRead_N:                                         

        cmp     dx,2920h                
        jb      iexvN15         
        cmp     dx,297fh        
        jna     iexvNhan        
        cmp     dx,2a20h        
        jb      iexvN15         
        cmp     dx,2a7fh        
        jna     iexvNhan        
        cmp     dx,2b20h        
        jb      iexvN15         
        cmp     dx,2b7fh        
        jna     iexvNhan        
        cmp     dx,7840h        
        jb      iexvN15         
        cmp     dx,787fh        
        jna     iexvNhan        
        cmp     dx,7d01h        
        jb      iexvN15         
        cmp     dx,7d7fh        
        jna     iexvNhan        
        cmp     dx,7e01h        
        jb      iexvN15         
        cmp     dx,7e7fh        
        ja      iexvN15         
iexvNhan:                       
        mov     cx,18           ;16byte+2=18 ;        jmp     iexv70

iexvN15:                                                
        mov     cx,34           ;32byte+2=34            
        jmp     iexv70           

H98_FontRead_H:                                         

        cmp     dx,2920h                
        jb      iexvN25         
        cmp     dx,297fh        
        jna     HiexvNhan       
        cmp     dx,2a20h        
        jb      iexvN25         
        cmp     dx,2a7fh        
        jna     HiexvNhan       
        cmp     dx,2b20h        
        jb      iexvN25         
        cmp     dx,2b7fh        
        jna     HiexvNhan       
        cmp     dx,7840h        
        jb      iexvN25         
        cmp     dx,787fh        
        jna     HiexvNhan       
        cmp     dx,7d01h        
        jb      iexvN25         
        cmp     dx,7d7fh        
        jna     HiexvNhan       
        cmp     dx,7e01h        
        jb      iexvN25         
        cmp     dx,7e7fh        
        ja      iexvN25         
HiexvNhan:                      
;;;;;;;;        mov     cx,50           ;48byte+2=50 
        mov     cx,48           ;48byte 
;;;;;;;;        jmp     iexv70   
        jmp     iexv100          

iexvN25:
;;;;;;;;        mov     cx,74           ;72byte+2=74 
        mov     cx,72           ;72byte
;;;;;;;;        jmp     iexv70                          
        jmp     iexv100                                 
else    ;!NEC_98
        cmp     ah,10h
        jnz     iexv20
;
; Palette control function.
        cmp     al,9            ;read palette data function
        jnz     @F
        mov     cx,17
        jmp     short iexv70
;
@@:     cmp     al,17h          ;read video DAC registers
        jnz     @F
        mov     cx,[bp].pmUserCX    ;each entry in table is 3 bytes long
        add     cx,cx
        add     cx,[bp].pmUserCX
        jmp     short iexv70
;
@@:     jmp     short iexv72
;
;
iexv20: cmp     ah,11h
        jnz     iexv30
;
; Character generator interface function.
;   NOTE: a number of subfunctions of function 11h need to have munging
;       and data buffering performed.  However, function 30h is the only
;       one used by Codeview, so this is the only one currently implemented
        cmp     al,30h
        jnz     @F
        mov     ax,[bp].intUserES   ;get the paragraph address returned by BIOS
        mov     bx,STD_DATA
        call    ParaToLDTSelector   ;get a selector for that address
        mov     [bp].pmUserES,ax    ;store the selector so that it will be
                                    ; returned to the caller
@@:     jmp     short iexv90
;
;
iexv30: cmp     ah,1Bh
        jnz     iexv40
;
; Video BIOS functionality/state information.
; On exit, we need to fix up the pointer at the beginning of the
; data put in our buffer by the BIOS, and then transfer the buffer up
; to the user.
        mov     ax,word ptr rgbXfrBuf0[2]   ;get segment of pointer to
                                            ; 'static functionallity table'
        mov     bx,STD_DATA
        call    ParaToLDTSelector           ;convert paragraph to selector
        mov     word ptr rgbXfrBuf0[2],ax   ;store back into table
        push    es
        mov     si,offset rgbXfrBuf0    ;pointer to our copy of the table
        mov     di,[bp].pmUserDI        ;where the user wants it
        mov     [bp].intUserDi,di       ;restore the DI returned to the user
        mov     es,[bp].pmUserES
        mov     cx,64                   ;the table is 64 bytes long
        cld
        rep     movsb                   ;copy the table to the user's buffer
        pop     es

        jmp     short iexv90
;
;
iexv40:
        jmp     short iexv90

;
; Copy data from our buffer to the caller's buffer pointed to by ES:DX
iexv70: cld
        push    es
        mov     di,[bp].pmUserDX
        mov     es,[bp].pmUserES
        mov     si,offset DGROUP:rgbXfrBuf1
        rep     movsb
        pop     es
;
; Restore the caller's DX
iexv72: mov     ax,[bp].pmUserDX
        mov     [bp].intUserDX,ax
;
; All done
iexv90:
        ret
endif   ;!NEC_98

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  BIOS Misc. Interrupt (Int 15h) Service Routine
        page
; -------------------------------------------------------
;       BIOS MISC. INTERRUPT (INT 15h) SERVICE ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntrMisc  -- Entry point into the interrupt processing code
;       for the BIOS misc functions interrupt (INT 15h).
;
;   Input:  normal registers for Bios calls
;   Output: normal register returns for Bios calls
;   Errors: normal Bios errors
;   Uses:   as per Bios calls

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrMisc

PMIntrMisc:
;
        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values
        call    IntEntryMisc
;
; Execute the interrupt service routine
        SwitchToRealMode
        assume  ss:DGROUP
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     word ptr [bp + 6],offset pim_10
        mov     ax,es:[15h*4]
        mov     [bp + 2],ax
        mov     ax,es:[15h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

pim_10: pushf
        FCLI
        cld
        pusha
        push    ds
        push    es
        mov     bp,sp               ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP
;
; Perform fixups on the return register values.
        mov     ax,[bp].pmUserAX    ;get original function code
        call    IntExitMisc
;
; And return to the original caller.
        call    LeaveIntHandler
        riret

; -------------------------------------------------------
;           MISC INTERRUPT SUPPORT ROUTINES
; -------------------------------------------------------
;
;   IntEntryMisc    -- This function performs data transfer
;       and register translation on entry to the BIOS Misc.
;       functions interrupt. (INT 15h).
;
;   Input:  AX      - BIOS function being performed
;   Output:
;   Errors:
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntryMisc

IntEntryMisc:

ifdef      NEC_98
        push    cx    
        cmp     ah,90h                          ;SYSTEM BIOS  BLOCK MOVE 
        jnz     iemDMA1                         ;yes = jmp 
        jmp     iem70                                   
iemDMA1:                                                
        cmp     ah,0D5h                         ;DMA BIOS  DMA 
        jnz     iemDMA2                         ;yes = jmp 
        mov     cx,8                            ;DMA_CBIOS 
        jmp     iem70                                   
iemDMA2:                                                
        cmp     ah,0D6h                         ;DMA BIOS  DMA 
        jnz     iemROM1                         ;yes = jmp 
        jmp     iem80                           ;Read JMP 
iemROM1:                                                
        cmp     ah,0D8h                         ;ROM 
        jnz     iemROM2                         ;yes = jmp 
        mov     cx,4                            
        jmp     iem70                           

iemROM2:                                                
        cmp     ah,0D9h                         ;ROM
        jnz     iem90                           ;yes = jmp 
        mov     cx,8                            ;ROM BIOS
iem70:                                           
        push    ds                               
        mov     si,[bp].pmUserBX        ;offset address
        mov     ds,[bp].pmUserES        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
iem80:                                                  
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
iem90:                                                  
        pop     cx                                      
        ret                                             
else    ;!NEC_98
; Map requests to set the PS/2 Pointing Device Handler Address

        cmp     ax,0C207h               ;PS/2 Set Pointing Device Handler adr?
        jnz     iem90

        mov     ax,[bp].pmUserBX                    ;User's ES:BX -> handler
        mov     word ptr lpfnUserPointingHandler,ax
        mov     ax,[bp].pmUserES
        mov     word ptr [lpfnUserPointingHandler+2],ax

        mov     ax,segDXCodePM          ;pass BIOS address of our handler
        mov     [bp].intUserES,ax
        mov     ax,offset PointDeviceHandler
        mov     [bp].intUserBX,ax

iem90:
        ret
endif   ;!NEC_98

; -------------------------------------------------------
;   IntExitMisc     -- This function performs data transfer
;       and register translation on exit from the BIOS Misc.
;       Functions interrupt (INT 15h).
;
;   Input:  AX      - BIOS function being performed
;   Output:
;   Errors:
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExitMisc

IntExitMisc:
ifdef      NEC_98                                           
        push    cx                                      
        cmp     ah,90h                          ;SYSTEM BIOS  BLOCK MOVE 
        jnz     ixmDMA1                         ;yes = jmp 
        jmp     ixm70                                   
ixmDMA1:                                                
        cmp     ah,0D5h                         ;DMA BIOS
        jnz     ixmDMA2                         ;yes = jmp
        jmp     ixm70                                   
ixmDMA2:                                                
        cmp     ah,0D6h                         ;DMA BIOS  DMA
        jnz     ixmROM1                         ;yes = jmp 
        mov     cx,16                                   
        jmp     ixm80                                   
ixmROM1:                                                
        cmp     ah,0D8h                         ;    ROM
        jnz     ixmROM2                         ;yes = jmp
        jmp     ixm70                                   
ixmROM2:                                                
        cmp     ah,0D9h                         ;    ROM
        jnz     ixm90                                   
ixm70:                                                  
        cld                                             
        push    es                                      
        mov     di,[bp].pmUserBX                        
        mov     es,[bp].pmUserES                        
        mov     si,offset DGROUP:rgbXfrBuf1             
        rep     movsb                                   
        pop     es                                      
;
; Restore the caller's ES,BX                             
ixm80:                                                  
        push    ax                                      
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
        mov     ax,[bp].pmUserBX                        
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
ixm90:                                                  
        pop     cx                                      
        ret                                             
else    ;!NEC_98
        push    ax
        push    bx
        push    cx
        push    dx
;
; Check for function 0C0h - Return System Configuration Parameters
        cmp     ah,0C0h
        jnz     ixmi30
        test    [bp].intUserFL,1    ;check if the bios call returned an error
        jnz     ixmi90          ;(carry flag set in returned flags)
;
; The BIOS call succeeded.  This means that ES:BX points to a configuration
; vector.  We need to fix up the segment to be a selector.
        mov     dx,[bp].intUserES
        cmp     dx,0F000h       ;does it point to normal BIOS segment
        jnz     ixmi22
        mov     ax,SEL_BIOSCODE or STD_RING
        jmp     short ixmi24

ixmi22: call    ParaToLinear
        mov     cx,0FFFFh
        mov     ax,SEL_USERSCR or STD_TBL_RING
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
ixmi24: mov     [bp].pmUserES,ax
        jmp     short ixmi90

; Chack for function 0C207h - PS/2 Set Pointing Device Handler Address

ixmi30:
        cmp     ax,0C207h
        jne     ixmi90

        mov     ax,[bp].pmUserBX        ;restore user's BX
        mov     [bp].intUserBX,ax

; All done
ixmi90:
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret
endif   ;!NEC_98

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Mouse Function Interrupt (Int 33h) Service Routine
        page
; -------------------------------------------------------
;       MOUSE FUNCTION INTERRUPT (INT 33h) SERVICE ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntrMouse - Entry point into interrupt reflector code
;       for mouse driver (int 33h) calls.
;
;   Input:  normal registers for mouse calls
;   Output: normal register returns for mouse calls
;   Errors: normal mouse errors
;   Uses:   as per mouse calls

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrMouse

PMIntrMouse:
;
        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values
        call    IntEntryMouse
;
; Execute the interrupt service routine
        SwitchToRealMode
        assume  ss:DGROUP
        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     word ptr [bp + 6],offset pimo_10
        mov     ax,es:[33h*4]
        mov     [bp + 2],ax
        mov     ax,es:[33h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

pimo_10: pushf
        FCLI
        cld
        pusha
        push    ds
        push    es
        mov     bp,sp           ;restore stack frame pointer
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP
;
; Perform fixups on the return register values.
        mov     ax,[bp].pmUserAX    ;get original function code
        call    IntExitMouse
;
; And return to the original caller.
        call    LeaveIntHandler
        riret

; -------------------------------------------------------
;               MOUSE SUPPORT ROUTINES
; -------------------------------------------------------

;   IntEntryMouse   -- This function performs data transfer and
;       register translation on entry to mouse driver functions.
;       (INT 33h)
;
;   Input:  AX      - mouse function being performed
;   Output:
;   Errors:
;   Uses: NOTHING

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntEntryMouse

IntEntryMouse:
        cld
        push    ax
        push    cx
        push    si
        push    di
;
        cmp     al,9    ;Set graphics cursor block?
        jnz     ment10
;
; The user is setting a graphics cursor.  We need to copy the masks
; down to low memory so that the mouse driver can get at them and then
; fix up the pointer in DX.
        mov     cx,32
        jmp     short ment92
;
; Mouse interrupt handler establishment
ment10: cmp     al,12   ;Set user defined interrupt subroutine ?
        jnz     ment20
;
; This command has the effect of causing a call to the address es:ds
; Whenever an event of one of the types specified by the mask in cx.
; The address es:dx must be saved in lpfnUserMouseHandler and the
; real mode address of MouseInterruptHandler substituted.
        mov     ax,[bp].pmUserDX    ; Load users handler offset
        mov     word ptr lpfnUserMouseHandler,ax ; Store for future use
        mov     ax,[bp].pmUserES    ; Load users handler segment value
        mov     word ptr lpfnUserMouseHandler + 2,ax ; Store for future use
        mov     ax,segDXCodePM      ; Load real mode code segment value
        mov     [bp].intUserES,ax   ; Store in real mode es register image
        mov     ax,offset MouseInterruptHandler ; Load handler offset
        mov     [bp].intUserDX,ax   ; Store in real mode dx register image
        jmp     short ment99    ;Return
 ;
ment20: cmp     al,20
        jc      ment99
        jnz     ment30
;
; This is the swap interrupt subroutine function.  Not currently implemented
        jmp     short ment99
;
ment30: cmp     al,22   ;Save mouse driver state?
        jnz     ment40
;
; This is the save mouse driver state function.  We need to pass a pointer
; to the transer buffer down to the mouse driver.
        mov     ax,npXfrBuf1
        mov     [bp].intUserDX,ax
        jmp     short ment99

ment40: cmp     al,23   ;Restore mouse driver state?
        jnz     ment99
;
; This is the restore mouse driver state function.  We need to copy the
; mouse state buffer from the pm user location to the transfer buffer,
; and then pass the pointer to the transfer buffer on to the mouse driver.
        mov     cx,cbMouseState
        jcxz    ment99
;
; Transfer the data pointed to by the user ES:DX to the scratch buffer, and
; fix up the pointer that is passed on to the mouse driver.
ment92: mov     si,[bp].pmUserDX
        mov     di,npXfrBuf1
        mov     [bp].intUserDX,di
        push    ds
        mov     ds,[bp].pmUserES
        cld
        rep     movs word ptr [di],word ptr [si]
        pop     ds
;
ment99: pop     di
        pop     si
        pop     cx
        pop     ax
        ret

; -------------------------------------------------------
;   IntExitMouse    -- This function performs data transfer and
;       register translation on exit from mouse driver functions.
;       (INT 33h)
;
;   Input:  AX      - mouse function being performed
;   Output:
;   Errors:
;   Uses:

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  IntExitMouse

IntExitMouse:
        cld
        cmp     al,21       ;get state buffer size?
        jnz     mxit20
;
; We need to remember the state buffer size, so that later we will know
; how many bytes to transfer when we do the save/restore state fucntions.
        mov     ax,[bp].intUserBX
        mov     cbMouseState,ax
        return
;
mxit20: cmp     al,22   ;Save mouse driver state?
        jnz     mxit30
;
; We need to restore the original values of ES:DX and transfer the mouse
; state data from the real mode buffer to the user's protected mode buffer.
        mov     cx,cbMouseState
        jcxz    mxit28
        push    es
        mov     si,npXfrBuf1
        mov     di,[bp].pmUserDX
        mov     [bp].intUserDX,di
        mov     es,[bp].pmUserES
        rep     movs byte ptr [di],byte ptr [si]
        pop     es
mxit28: return
;
mxit30: cmp     al,23   ;Restore mouse driver state?
        jnz     mxit99
        mov     ax,[bp].pmUserDX
        mov     [bp].intUserDX,ax
;
mxit99: ret

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  PM Interrupt Support Routines
        page
; -------------------------------------------------------
;           PM INTERRUPT SUPPORT ROUTINES
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   EnterIntHandler     -- This routine will allocate a stack
;       frame on the interrupt reflector stack and make
;       a copy of the registers on the allocated stack.
;
; Note: This routine expects the current stack to contain a near
;       return address and a normal [IP] [CS] [FL] interrupt stack
;       frame.  Don't have anything else on the stack before calling
;       this routine!
;
; Note: This routine disables interrupts, and leaves them disabled.
;       Most callers already have them disabled, so it doesn't
;       really make a difference, except that this routine
;       requires that they be disabled.
;
;   Input:  none
;   Output: stack frame set up
;   Errors: none
;   Uses:   all registers preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  EnterIntHandler

EnterIntHandler proc    near

        FCLI                             ;we really want int's disabled (and
                                        ;  XMScontrol doesn't do that)
        push    ds
        mov     ds,selDgroupPM          ;save user's DS and address our DGROUP
        assume  ds:DGROUP
        pop     regUserDS

        push    bp
        mov     bp,sp                   ;bp -> [BP] [IP] [IP] [CS] [FL]
        push    word ptr [bp+8]
        pop     regUserFL               ;user's flags before doing INT
        pop     bp

        pop     pfnReturnAddr           ;near return to our immediate caller

        mov     regUserSS,ss            ;save caller's stack address
        mov     regUserSP,sp
        ASSERT_REFLSTK_OK
        mov     ss,selDgroupPM          ;switch to interrupt reflector stack
        mov     sp,pbReflStack
        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame
        FIX_STACK

; Build the stack frame.  The stack frame contains the following:
;   dword & word parameter locations
;   original caller's stack address
;   caller's original flags and general registers (in pusha form)
;   caller's original segment registers (DS & ES)
;   flags and general registers to be passed to interrupt routine
;       (initially the same as caller's original values)
;   segment registers (DS & ES) to be passed to interrupt routine
;       (initially set to the Dos Extender data segment address)
;
; The parameter words and then the caller's original register values go on top.

        sub     sp,8                    ;space for a dd & 2 dw's

        push    regUserSP
        push    regUserSS
        push    regUserFL
        pusha
        push    regUserDS
        push    es

; Now, put all of the general registers, and values for the segment
; registers to be passed to the interrupt service routine.  We pass
; the Dos Extender data segment address to the interrupt routine.

        push    regUserFL
        pusha
        push    segDXDataPM
        push    segDXDataPM

; And we are done.

        mov     bp,sp                   ;set up frame pointer
        mov     es,selDgroupPM
        jmp     pfnReturnAddr           ;return to the caller.

EnterIntHandler endp


; -------------------------------------------------------
;   LeaveIntHandler     -- This routine will restore the user registers,
;       release the stack frame, and restore the original user's stack
;       for exit from an interrupt reflector routine.
;
; Note: Interrupts must be off when this routine is called.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   All registers modified

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  LeaveIntHandler

LeaveIntHandler proc    near

        FCLI
        pop     pfnReturnAddr

; The copy of the register values returned from the interrupt routine
; (and then possibly modified by the exit handler for the particular
; interrupt) are what gets returned to the caller.  We discard the original
; register values saved on entry.  (They were there so that the exit
; routine could refer to them if necessary)

        add     sp,4                ;skip over interrupt service routine's
                                    ; segment register values
        popa                        ;restore general register values
        pop     regUserFL           ;flags returned by interrupt routine
        pop     es                  ;get segment registers from pmUserES
        pop     regUserDS           ; and pmUserDS
        add     sp,18               ;skip over the original user registers
                                    ; and flags
        pop     regUserSS           ;original interrupted routine's stack
        pop     regUserSP
        mov     regUserAX,ax

; Switch back to the original user's stack.

        ASSERT_REFLSTK_OK
        ASSERT_CLI
        CHECK_STACK
        mov     ss,regUserSS
        mov     sp,regUserSP
        add     pbReflStack,CB_STKFRAME
        ASSERT_REFLSTK_OK

; We need to replace the image of the flags in the original int return
; address on the user's stack with the new flags returned from the interrupt
; service routine.

        push    bp
        mov     bp,sp           ;stack -> BP IP CS FL
        mov     ax,regUserFL    ;flags returned by interrupt service routine
        and     ax,0BFFFh       ;clear the nested task flag
        and     [bp+6],0300h    ;clear all but the interrupt and trace flags
                                ; in the caller's original flags
        or      [bp+6],ax       ;combine in the flags returned by the
                                ; interrupt service routine.  This will cause
                                ; us to return to the original routine with
                                ; interrupts on if they were on when the
                                ; interrupt occured, or if the ISR returned
                                ; with them on.
        pop     bp

; And now, return to the caller.

        push    pfnReturnAddr
        mov     ax,regUserAX
        mov     ds,regUserDS
        assume  ds:NOTHING
        ret

LeaveIntHandler endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Mouse Interrupt Callback Function Handler
        page
; -------------------------------------------------------
;       MOUSE INTERRUPT CALLBACK FUNCTION HANDLER
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

; -------------------------------------------------------
;   MouseInterruptHandler -- This routine is the entry point for
;       user requested mouse event interrupts. It switches the
;       processor to protected mode and transfers control to the
;       user protected mode mouse handling routine. When that
;       completes, it switches back to real mode and returns control
;       to the mouse driver.
;       Entry to this routine will have been requested by an
;       INT 33H code 12 with the real address of this routine
;       substituted for the users entry point.
;       The address of the user specified mouse handler as specified
;       in the original INT 33H is stored in the variable
;       lpfnUserMouseHandler.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   The segment registers are explicitly preserved by
;           this routine.  Other registers are as preserved or
;           modified by the users mouse handler.

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  MouseInterruptHandler

MouseInterruptHandler    proc    far
;
; On entry, the stack layout is:
;   [2] CS      - System mouse handler code segment
;   [0] IP      - System mouse handler return offset
;

        push    es
        push    ds
        pushf
        FCLI
        cld
        mov     ds,selDgroup
        assume  ds:DGROUP
        pop     regUserFL
;
; Allocate a new stack frame, and then switch to the local stack
; frame.
        mov     regUserSP,sp    ;save entry stack pointer so we can restore it
        mov     regUSerSS,ss    ;save segment too
        mov     ss,selDgroup    ;switch to our own stack frame
        ASSERT_REFLSTK_OK
        mov     sp,pbReflStack
        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame
        FIX_STACK
;
; We are now running on our own stack, so we can switch into protected mode.
        push    ax              ;preserve caller's AX
        SwitchToProtectedMode
        pop     ax
;
; Build a far return frame on the stack so that the user's
; routine will return to us when it is finished.
        push    regUserSS       ; save system mouse handler stack address
        push    regUserSP       ; so we can restore it later
        push    ds
        push    cs
        push    offset mih50
;
; Build an IRET frame on the stack to use to transfer control to the
; user's protected mode routine
        push    regUserFL
        push    word ptr lpfnUserMouseHandler+2 ;push segment of user routine
        push    word ptr lpfnUserMouseHandler   ;push offset of user routine
;
; At this point the interrupt reflector stack looks like this:
;
;   [14]    stack segment of original stack
;   [12]    stack pointer of original stack
;   [10]    real mode dos extender data segment
;   [8]     segment of return address back to here
;   [6]     offset of return address back here
;   [4]     Users flags
;   [2]     segment of user routine
;   [0]     offset of user routine
;
; Execute the users mouse handler
        iret
;
; The users handler will return here after it is finsished.
mih50:  FCLI
        cld
        pop     ds
        pop     regUserSP
        pop     regUserSS
;
; Switch back to real mode.
        push    ax              ;preserve AX
        SwitchToRealMode
        pop     ax
        CHECK_STACK
;
; Switch back to the original stack.
        mov     ss,regUserSS
        mov     sp,regUserSP
        ASSERT_REFLSTK_OK
;
; Deallocate the stack frame that we are using.
        add     pbReflStack,CB_STKFRAME
        ASSERT_REFLSTK_OK
;
; And return to the original interrupted program.
        pop     ds
        pop     es

        ret

MouseInterruptHandler    endp

; -------------------------------------------------------

DXCODE  ends

; -------------------------------------------------------
        subttl  PS/2 Pointing Device Handler
        page
; -------------------------------------------------------
;           PS/2 POINTING DEVICE HANDLER
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

ifndef      NEC_98
; -------------------------------------------------------
;   PointDeviceHandler -- This routine is the entry point for
;       the PS/2 Pointing Device Handler.  It switches the
;       processor to protected mode and transfers control to the
;       user pointing device handler.  When that completes,
;       it switches back to real mode and returns control to
;       the PS/2 BIOS.
;
;       Note: The BIOS calls us with interrutps enabled!

;   Input:  none
;   Output: none
;   Errors: none

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PointDeviceHandler

PointDeviceHandler      proc    far

; On entry, the stack layout is:
;
;  [10] status
;   [8] X coordinate
;   [6] Y coordinate
;   [4] Z coordinate
;   [2] CS              - PS/2 BIOS code segment
;   [0] IP              - PS/2 BIOS return offset

        cld
        push    es              ;save PS/2 BIOS ds/es on it's stack
        push    ds

        mov     ds,selDgroup    ;addressability to DOSX DGROUP
        push    ds
        pop     es
        assume  ds:DGROUP,es:DGROUP

        FCLI                     ;protect global regUserXX vars

; Allocate a new stack frame, and then switch to the local stack
; frame.

        mov     regUserSP,sp    ;save entry stack pointer so we can restore it
        mov     regUSerSS,ss    ;save segment too
        ASSERT_REFLSTK_OK
        mov     ss,selDgroup    ;switch to our own stack frame
        mov     sp,pbReflStack
        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame
        FIX_STACK

        push    regUserSS       ;save PS/2 BIOS stack address
        push    regUserSP       ;  so we can restore it later

        push    SEL_DXDATA or STD_RING  ;DOSX DS to be poped in PM

        sub     sp,4*2          ;temp save the general regs further down the
        pusha                   ;  stack, they'll get poped in a little while

; Copy PS/2 pointing device stack info to our (soon to be) protected mode stack

        mov     si,regUserSP    ;PS/2 stack pointer
        mov     ds,regUserSS    ;PS/2 stack segment
        assume  ds:NOTHING

        FSTI                     ;no more references to global regUserXX vars

        add     si,4*2          ;skip over es,ds,cs,ip
        mov     di,sp           ;loc for pointing device
        add     di,8*2          ;  data on our stack
        mov     cx,4
        cld
        rep movsw

        push    es              ;restore ds = DGROUP
        pop     ds
        assume  ds:DGROUP

; We are now running on our own stack, so we can switch into protected mode.

        SwitchToProtectedMode   ;disables interrupts again
        FSTI                     ;   but we don't want them disabled

        popa                    ;restore general registers

; At this point the stack looks like this:
;
;   [12]   stack segment of original stack
;   [10]   stack pointer of original stack
;   [8]    protect mode dos extender data segment
;   [6]    status
;   [4]    X coordinate
;   [2]    Y coordinate
;   [0]    Z coordinate

; Execute the user's pointing device handler

        call    [lpfnUserPointingHandler]

; The users handler will return here after it is finsished.

pdh50:
        cld
        add     sp,4*2                  ;discard pointing device info
        pop     ds

        FCLI                             ;protect global regUserXX vars
        pop     regUserSP
        pop     regUserSS

; Switch back to real mode.

        push    ax                      ;preserve AX
        SwitchToRealMode
        pop     ax

; Switch back to the original stack.

        CHECK_STACK
        mov     ss,regUserSS
        mov     sp,regUserSP

; Deallocate the stack frame that we are using.

        ASSERT_REFLSTK_OK
        add     pbReflStack,CB_STKFRAME
        ASSERT_REFLSTK_OK

; And return to the PS/2 BIOS

        FSTI                             ;we came in with ints enabled

        pop     ds
        pop     es

        ret

PointDeviceHandler      endp

; -------------------------------------------------------
endif   ;!NEC_98
;
; -------------------------------------------------------
        subttl  Utility Function Definitions
        page
; -------------------------------------------------------
;           UTILITY FUNCTION DEFINITIONS
; -------------------------------------------------------
;
;   SaveRMIntrVectors   -- This routine copies the current
;       real mode interrupt vector table to the shadow
;       vector table used by the interrupt reflector.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses;   all registers preserved
;
;   NOTE:   This routine can only be called in REAL MODE.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  SaveRMIntrVectors

SaveRMIntrVectors:
        push    cx
        push    si
        push    di
        push    ds
        push    es
;
        cld
        push    ds
        pop     es
        xor     cx,cx
        mov     si,cx
        mov     ds,cx
        mov     di,offset DGROUP:rglpfnRmISR
        mov     cx,2*256
        rep     movs word ptr [di],word ptr [si]
;
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     cx
        ret

; -------------------------------------------------------
;   RestoreRMIntrVectors    -- This routine copies the
;       interrupt vectors from the real mode interrupt
;       vector shadow table back down to the real interrupt
;       vectors.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses;   all registers preserved
;
;   NOTE:   This routine can only be called in REAL MODE.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  RestoreRMIntrVectors

RestoreRMIntrVectors:
        push    cx
        push    si
        push    di
        push    ds
        push    es
;
        FCLI
        cld
        xor     cx,cx
        mov     di,cx
        mov     es,cx
        mov     si,offset DGROUP:rglpfnRmISR
        mov     cx,2*256
        rep     movs word ptr [di],word ptr [si]
        FSTI
;
        pop     es
        pop     ds
        pop     di
        pop     si
        pop     cx
        ret

; -------------------------------------------------------

DXCODE  ends

ifdef      NEC_98                                           
;
; -------------------------------------------------------
        subttl  INT D2h SOUND BIOS HANDRER              
        page                                            
; -------------------------------------------------------
;       PMIntrSound
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrSound                             

PMIntrSound:                                            

        call    EnterIntHandler     ;build a stack frame and fix up the         
        cld                         ; return address so that the interrupt      
                                    ;service routine will return to us.         
;
; Perform fixups on the entry register values            
        call    IntEntrySD                              
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*0D2h]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code 
        call    IntExitSD                               
;
; And return to the original caller.                     
        call    LeaveIntHandler                         

        iret                                            

;--------------------------------------------------------
;       IntEntrySD
;--------------------------------------------------------

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntEntrySD                              

IntEntrySD:                                             

        cmp     ah,0                    ;BIOS(INITIALIZE)
        jnz     ienSD10                                 
        mov     bx,0                    ;BIOS      
        mov     si,bx                    
        mov     cx,2FFh                 ;(256) (512)
        jmp     ienSD50                             
ienSD10:                                            
        cmp     ah,1                    ;(PLAY)
        jnz     ienSD20                        
        mov     si,[bp].pmUserBX               
        mov     cx,28                          
        jmp     ienSD50                        
ienSD20:                                       
        cmp     ah,16h                  ;(SET PARA BLOCK)
        jnz     ienSD90                                 
        mov     si,[bp].pmUserBX                        
        cmp     dl,0                    ;00=WORD/01=BYTE? 
        jnz     ienSD21                 ;not 0 = JMP
        mov     cx,100                  ;100        
        jmp     ienSD50                             
ienSD21:                                            
        mov     cx,51                   ;51         
ienSD50:                                            
        push    ds                                  
;;;;    mov     si,[bp].pmUserBX        ;           
        mov     ds,[bp].pmUserES        ;           
        mov     di,offset DGROUP:rgbXfrBuf1         
        rep     movsb                               
        pop     ds                                  

        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
ienSD90:                                                
        ret                                             

;--------------------------------------------------------
;       IntExitSD
;--------------------------------------------------------

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitSD                               

IntExitSD:                                              

        cmp     ah,0                    ;BIOS (INITIALIZE) 
        jnz     iexSD10                                 
        jmp     iexSD50                                 
iexSD10:                                                
        cmp     ah,1                    ;(PLAY)
        jnz     iexSD20                        
        jmp     iexSD50                        
iexSD20:                                       
        cmp     ah,16h                  ;(SET PARA BLOCK)
        jnz     iexSD90                                 
iexSD50:                                                
        push    ax                                      
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX                        
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
iexSD90:                                                
        ret                                             

DXPMCODE    ends                                        

; -------------------------------------------------------
        subttl  INT 1Ah PRINTER BIOS HANDRER            
        page                                            

;       30h(            )  2K                           
; -------------------------------------------------------
;       PMIntrPrinter
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrPrinter                           

PMIntrPrinter:                                          


        call    EnterIntHandler     ;build a stack frame and fix up the         
        cld                         ; return address so that the interrupt      
                                    ;service routine will return to us.         
;
; Perform fixups on the entry register values            
        call    IntEntryPR                              
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*1Ah]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code 
        call    IntExitPR                               
;
; And return to the original caller.                    
        call    LeaveIntHandler                         

        iret                                            

;--------------------------------------------------------
;       IntEntryPR
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntEntryPR                              

IntEntryPR:                                             

        cmp     ah,30h                  ;                
        jnz     ienPR20                 ;90/08/24        
        mov     cx,[bp].pmUserCX        ;                
        cmp     cx,2048                 ;2K      
        jbe     ienPR10                 ;NO = jmp
        mov     cx,2048                 
        mov     [bp].intUserCX,cx       
ienPR10:                                
        push    ds                      
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserES        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 

ienPR20:                                                
        ret                                             

;--------------------------------------------------------
;       IntExitPR
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitPR                               

IntExitPR:                                              

        cmp     ah,30h                  
        jnz     iexPR20                 
        mov     cx,[bp].pmUserCX        
        cmp     cx,2048                 
        ja      iexPR10                 ;YES = jmp
        push    ax                                
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX        ;offset address 
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
        ret                                             

iexPR10:                                                
        push    ax                                      
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     cx,2048                 
        sub     [bp].pmUserCX,cx        
        mov     ax,[bp].pmUserCX        
        mov     [bp].intUserCX,ax       
        pop     ax                      
        
        push    bx 
        add     [bp].pmUserBX,cx                        
        mov     bx,[bp].pmUserBX                        
        mov     [bp].intUserBX,bx       
        pop     bx                      
iexPR20:                                
        ret                             
        
;////////////////////////////////////////////////////////////
if 0                    
;////////////////////////////////////////////////////////////
IntEntryPR:             

        cmp     ah,30h                  
        jnz     ienPR10                 
        mov     cx,[bp].pmUserCX        
        cmp     cx,2048                 
        ja      ienPR10                 ;YES = jmp
        push    ds                                
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserES        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1            
        cld                                            
        rep     movsb                                  
        pop     ds                                     
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
        ret                                             

ienPR10:                                                
        push    ds                                      
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserES        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        push    bx                                      
        mov     bx,offset DGROUP:rgbXfrBuf1     ;
        add     bx,cx                           ;DGROUP:rgbXfrBuf1
        mov     [bp].intUserBX,bx               ;
        pop     bx                               
        ret                                      

;       push    ds                                      
;       mov     [bp].intUserES,ds       ;segment address
;       pop     ds                                      
;;------------------------------------------------------------
;       mov     bx,offset DGROUP:rgbXfrBuf1     ;
;       add     bx,cx                           ;
;       mov     [bp].intUserBX,bx               ;
;       ret                                      
;
;--------------------------------------------------------
;       IntExitPR
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitPR                               

IntExitPR:                                              

        cmp     ah,30h                  
        jnz     iexPR10                 
        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX        ;      
        mov     [bp].intUserBX,ax                       
iexPR10:                                                
        ret                                             
;////////////////////////////////////////////////////////////
endif                   
;////////////////////////////////////////////////////////////

DXPMCODE    ends                                        


; -------------------------------------------------------
        subttl  INT 1Ch CALENDER/TIMER HANDRER
        page

; -------------------------------------------------------
;       PMIntrCalTi
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrCalTi                             


PMIntrCalTi:                                            

        call    EnterIntHandler     ;build a stack frame and fix up the         
        cld                         ; return address so that the interrupt      
                                    ;service routine will return to us.         
;
; Perform fixups on the entry register values            
        call    IntEntryCT                              
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*1Ch]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code 
        call    IntExitCT                               
;
; And return to the original caller.                     
        call    LeaveIntHandler                         

        iret                                            
        


;--------------------------------------------------------
;       IntEntryCT
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntEntryCT                              

IntEntryCT:                                             

        cmp     ah,0                    ;
        jnz     ienCT10                                 
        jmp     ienCT80                                 
ienCT10:                                                
        cmp     ah,1                    ;
        jnz     ienCT20                  
        mov     cx,6                    ;
        jmp     ienCT70                  
ienCT20:                                 
ienCT50:                                 

        push    es                                      
        push    ax                                      
        mov     ax,40h                                  
        mov     es,ax                                   
;       test    byte ptr es:[501h],8h   ;if Hmode 
        test    byte ptr es:[101h],8h   ;if Hmode 
        jz      ienCT90                           
        
;;      test    fNHmode,0FFh                            
;;      jz      ienCT90         ;0=Nmode --->jmp        

;--------------------- Hmode ----------------------
        cmp     ah,3                    
        jnz     ienCT30                                 
        mov     cx,4                    
        jmp     ienCT70                 
ienCT30:                                
        cmp     ah,4                    
        jnz     ienCT40                 
        mov     cx,12                   
        jmp     ienCT70                 
ienCT40:                                
        cmp     ah,5                    
        jnz     ienCT90                 
        mov     cx,12                   
;--------------------- Hmode ----------------------


ienCT70:                                                
        push    ds                                      
        mov     si,[bp].pmUserBX        ;offset address 
        mov     ds,[bp].pmUserES        ;segment address
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
ienCT80:                                                
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserBX,offset DGROUP:rgbXfrBuf1 
ienCT90:                                                
        ret                                             

;--------------------------------------------------------
;       IntExitCT
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitCT                               

IntExitCT:                                              

        cmp     ah,0                    
        jnz     iexCT10                                 
        mov     cx,6                                    
        jmp     iexCT70                                 
iexCT10:                                                
        cmp     ah,1                    
        jnz     iexCT20                 
        jmp     iexCT80                 
iexCT20:                                

iexCT50:                                                

        push    es                                      
        push    ax                                      
        mov     ax,40h                                  
        mov     es,ax                                   
;       test    byte ptr es:[501h],8h   ;if Hmode 
        test    byte ptr es:[101h],8h   ;if Hmode 
        jz      iexCT90                           
        
;;      test    fNHmode,0FFh                            
;;      jz      iexCT90         ;0=Nmode --->jmp        

;--------------------- Hmode ----------------------
        cmp     ah,3                    
        jnz     iexCT30                                 
        jmp     iexCT80                                 
iexCT30:                                                
        cmp     ah,4                    
        jnz     iexCT40                 
        jmp     iexCT80                 
iexCT40:                                
        cmp     ah,5                    
        jnz     iexCT90                 
        jmp     iexCT80                 
;--------------------- Hmode ----------------------

iexCT70:                                                
        push    es                                      
        mov     di,[bp].pmUserBX        ;offset address 
        mov     es,[bp].pmUserES        ;segment address
        mov     si,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     es                                      
iexCT80:                                                
        push    ax                                      

        mov     ax,[bp].pmUserES                        
        mov     [bp].intUserES,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserBX                        
        mov     [bp].intUserBX,ax                       
        pop     ax                                      
iexCT90:                                                
        ret                                             


DXPMCODE    ends                                        

; -------------------------------------------------------
        subttl  INT DCh extended DOS HANDRER
        page                     

; -------------------------------------------------------
;       PMIntrExDos
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrExDos                             

PMIntrExDos:                                            

        call    EnterIntHandler     ;build a stack frame and fix up the
        cld                         ; return address so that the interrupt
                                    ;service routine will return to us.
;
; Perform fixups on the entry register values            
        call    IntEntryED                              
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*0DCh]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
;       mov     ax,[bp].pmUserAX    ;get original function code 
        mov     cx,[bp].pmUserCX    ;get original function code 
        call    IntExitED                               
;
; And return to the original caller.                     
        call    LeaveIntHandler                         

        iret                                            

;--------------------------------------------------------
;       IntEntryED
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntEntryED                              

IntEntryED:                                             

        cmp     cl,0Ch                  
        jnz     ienED10                                 
        jmp     ienED80                                 
ienED10:                                                
;;;     push    cx                      
        cmp     cl,0Dh                  
        jz      ienED                                   
        jmp     ienED20                                 
ienED:                                                  
        push    cx                      
        cmp     ax,0                    
        jnz     ienED11                 
        mov     cx,386                  ;386byte         
        jmp     ienED70                                 
ienED11:                                                
        cmp     ax,0FFh                 
        jnz     ienED12                 
        mov     cx,786                  ;786byte         
        jmp     ienED70                                 
ienED12:                                                
        cmp     ax,1                    
        jb      ienED13                 
        cmp     ax,0Ah                  
        ja      ienED13                 
        mov     cx,160                  ;16*10=160byte   
        jmp     ienED70                                 
ienED13:                                                
        cmp     ax,0Bh                  
        jb      ienED14                 
        cmp     ax,14h                  
        ja      ienED14                 
        mov     cx,160                  ;16*10=160byte   
        jmp     ienED70                                 
ienED14:                                                
        cmp     ax,15h                  
        jb      ienED15                 
        cmp     ax,1Fh                  
        ja      ienED15                 
        mov     cx,66                   ;6*11=66byte     
        jmp     ienED70                                 
ienED15:                                                
        cmp     ax,20h                  
        jb      ienED16                 
        cmp     ax,24h                  
        ja      ienED16                 
        mov     cx,80                   ;16*5=80byte     
        jmp     ienED70                                 
ienED16:                                                
        cmp     ax,25h                  
        jb      ienED17                 
        cmp     ax,29h                  
        ja      ienED17                 
        mov     cx,80                   ;16*5=80byte     
        jmp     ienED70                                 
ienED17:                                                
        cmp     ax,2Ah                  
        jb      ienED18                 
        cmp     ax,38h                  
        ja      ienED18                 
        mov     cx,240                  ;16*15=240byte   
        jmp     ienED70                                 
ienED18:                                                
        cmp     ax,100h                 
        jnz     ienED20                 
        mov     cx,514                  ;2+512=514byte   
        jmp     ienED70                                 

ienED20:                                                
        cmp     cl,10h                  
        jnz     ienED90                 
        cmp     ah,1                    
        jnz     ienED90                 
        
moji_out:                                               
        mov     si,dx                                   
        cmp     byte ptr ds:[si],'$'                    
;;;;;;;;        cmp     byte ptr ds:[dx],'$'            
        jz      ienED90                                 
        push    ds                                      
        mov     si,[bp].pmUserDX        ;offset address 
        mov     ds,[bp].pmUserDS        ;segment address
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        movsb                                           
        pop     ds                                      
        jmp     moji_out                                


ienED70:                                                
        push    ds                                      
        mov     si,[bp].pmUserDX        ;offset address 
        mov     ds,[bp].pmUserDS        ;segment address
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
        pop     cx                                      
ienED80:                                                
;----------- 
        push    ax                                      
        mov     ax,segDXDataPM                          
        mov     [bp].intUserES,ax       ;segment address
        pop     ax                                      
;------------------------------------------------------------
        mov     [bp].intUserDX,offset DGROUP:rgbXfrBuf1 
ienED90:                                                
        ret                                             
        

;--------------------------------------------------------
;       IntExitED
;--------------------------------------------------------
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING          
        public  IntExitED                               

IntExitED:                                              

        cmp     cl,0Ch                  
        jz      iexED                                   
        jmp     iexED10                                 
iexED:                                                  
        push    cx                                      
        cmp     ax,0                    
        jnz     iexED1                  
        mov     cx,386                  ;386byte         
        jmp     iexED70                                 
iexED1:                                                 
        cmp     ax,0FFh                 
        jnz     iexED2                  
        mov     cx,786                  ;786byte         
        jmp     iexED70                                 
iexED2:                                                 
        cmp     ax,1                    
        jb      iexED3                  
        cmp     ax,0Ah                  
        ja      iexED3                  
        mov     cx,160                  ;16*10=160byte  
        jmp     iexED70                                 
iexED3:                                                 
        cmp     ax,0Bh                  
        jb      iexED4                  
        cmp     ax,14h                  
        ja      iexED4                  
        mov     cx,160                  ;16*10=160byte   
        jmp     iexED70                                 
iexED4:                                                 
        cmp     ax,15h                  
        jb      iexED5                  
        cmp     ax,1Fh                  
        ja      iexED5                  
        mov     cx,66                   ;6*11=66byte     
        jmp     iexED70                                 
iexED5:                                                 
        cmp     ax,20h                  
        jb      iexED6                  
        cmp     ax,24h                  
        ja      iexED6                  
        mov     cx,80                   ;16*5=80byte     
        jmp     iexED70                                 
iexED6:                                                 
        cmp     ax,25h                  
        jb      iexED7                  
        cmp     ax,29h                  
        ja      iexED7                  
        mov     cx,80                   ;16*5=80byte     
        jmp     iexED70                                 
iexED7:                                                 
        cmp     ax,2Ah                  
        jb      iexED8                  
        cmp     ax,38h                  
        ja      iexED8                  
        mov     cx,240                  ;16*15=240byte   
        jmp     iexED70                                 
iexED8:                                                 
        cmp     ax,100h                 
        jnz     iexED10                 
        mov     cx,514                  ;2+512=514byte   
        jmp     iexED70                                 

iexED10:                                                
        cmp     cl,0Dh                  
        jnz     iexED20                 
        jmp     iexED80                 
iexED20:                                
        cmp     cl,10h                  
        jnz     iexED90                 
        cmp     ah,1                    
        jnz     iexED90                 
        jmp     iexED80                 
iexED70:                                
        push    ds                      
        mov     si,[bp].pmUserDX        ;offset address  
        mov     ds,[bp].pmUserDS        ;segment address 
        mov     di,offset DGROUP:rgbXfrBuf1             
        cld                                             
        rep     movsb                                   
        pop     ds                                      
        pop     cx                                      
iexED80:                                                
        push    ax                                      
;----------- 
        mov     ax,[bp].pmUserDS                        
        mov     [bp].intUserDS,ax                       
;------------------------------------------------------------
        mov     ax,[bp].pmUserDX                        
        mov     [bp].intUserDX,ax                       
        pop     ax                                      
iexED90:                                                
        ret                                             


DXPMCODE    ends                                        

;/////////////////////////////////////////////////////////////////////////
;       Hmode no GRAPH ha INT 1Dh(Graph BIOS) niyori byouga sareru.
;       DOSX deha,
;/////////////////////////////////////////////////////////////////////////
; -------------------------------------------------------
;       PMIntr      GRAPH BIOS
;--------------------------------------------------------

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntrGraph                             

;///////////////////////////////////////////////////////////////////////
;;      extrn   fNHmode:BYTE            ;NHmode
;///////////////////////////////////////////////////////////////////////

PMIntrGraph:                                            


;;      test    fNHmode,0FFh                           
;;      jz      GBios_Nmode                            
        call    EnterIntHandler     ;build a stack frame and fix up the         
        cld                         ; return address so that the interrupt      
                                    ;service routine will return to us.         
;
; Perform fixups on the entry register values            

        push    ax                      
        mov     ax,[bp].pmUserDS        
        call    GetSegmentAddress       
        shr     dx,4                    
        shl     bx,12                   
        or      bx,dx                   ;bx now = seg of parent psp
        mov     [bp].intUserDS,bx       
        pop     ax                      
        
        
;
; Execute the interrupt service routine                  
        SwitchToRealMode                                
        assume  ss:DGROUP                               
        pop     es                                      
        pop     ds                                      
        assume  ds:NOTHING,es:NOTHING                   
        popa                                            
        call    rglpfnRmISR[4*1Dh]  ;execute the real mode interrupt routine 
        pushf                                           
        cli                                             
        cld                                             
        pusha                                           
        push    ds                                      
        push    es                                      
        
        mov     ax,ss                                   
        mov     ds,ax                                   
        mov     es,ax                                   
        
        mov     bp,sp               ;restore stack frame pointer 
        SwitchToProtectedMode                           
        assume  ds:DGROUP,es:DGROUP                     
;
; Perform fixups on the return register values.          
        mov     ax,[bp].pmUserAX    ;get original function code 
;///////////// 
        push    ax                                      
        mov     ax,[bp].pmUserDS                        
        mov     [bp].intUserDS,ax                       
        pop     ax                                      
;///////////// 
;
; And return to the original caller.                     
        call    LeaveIntHandler                         

        iret                                            


DXPMCODE    ends                                        

DXPMCODE    segment                                     
        assume  cs:DXPMCODE                             
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        
        public  PMIntr11dummy                           
                                                        
PMIntr11dummy   proc    near                            
                                                        
        and     ax,0FFFDh                               
        iret                                            
                                                        
PMIntr11dummy   endp                                    
DXPMCODE    ends                                        

endif   ;NEC_98
DXPMCODE segment
        assume cs:DXPMCODE

IFDEF WOW

        public Wow32IntrRefl
Wow32IntrRefl label word
??intnum = 0
rept 256
        push    word ptr ??intnum
        jmp     Wow32Intr16Reflector
        ??intnum = ??intnum + 1
endm
;--------------------------------------------------------
;
;   Wow32Intr16Reflector -- This routine reflects a 32 bit
;       interrupt to a 16 bit handler.  It switches to the
;       dos extender stack to do so.
;
;   Inputs: none
;   Outputs: none
;
        assume ds:nothing,es:nothing,ss:nothing
        public Wow32Intr16Reflector
Wow32Intr16Reflector proc
.386p
        push    ebp
        mov     ebp,esp
        push    ds
        push    eax
        push    ebx
        push    edi
        mov     ax,ss
        movzx   eax,ax
        lar     eax,eax
        test    eax,(AB_BIG SHL 8)
        jnz     w32i16r10

        movzx   ebp,bp
w32i16r10:

;
; Get a frame on the dosx stack.
;
        mov     ax,selDgroupPM
        mov     ds,ax
        assume  ds:DGROUP

        movzx   ebx,pbReflStack
        sub     pbReflStack,CB_STKFRAME

;
; Build a frame on the stack
;
        sub     bx,30
        mov     eax, [ebp+6]            ; eip
        mov     [bx+20], eax
        mov     eax, [ebp+10]           ; cs
        mov     [bx+24], eax

        mov     [bx + 18],ss            ; ss for stack switch back
        mov     eax,ebp
        add     eax,6                   ; ebp, int number
        mov     [bx + 14],eax           ; esp for stack switch back
        mov     ax,[ebp + 14]           ; get flags
        mov     [bx + 12],ax
        mov     ax,cs
        mov     [bx + 10],ax
        mov     [bx + 8],offset DXPMCODE:w3216r30
        mov     eax,[ebp]
        mov     [bx],eax                ; put ebp on other stack for pop
;
; Get handler
;
        mov     di,[ebp + 4]            ; int number
        shl     di,2                    ; al * 4
        add     di,offset DGROUP:Wow16BitHandlers
        mov     ax,[di]
        mov     [bx + 4],ax             ; handler ip
        mov     ax,[di + 2]
        mov     [bx + 6],ax             ; handler cs

;
; Set up for stack switch
;
        push    ds
        push    ebx
;
; Restore registers
;
        mov     ax,[ebp - 2]
        mov     ds,ax
        mov     eax,[ebp - 6]
        mov     ebx,[ebp - 10]
        mov     edi,[ebp - 14]
;
; Switch stacks, restore ebp, and call handler
;
        lss     esp,[ebp - 20]
        pop     ebp
        retf
;
; N.B.  i31_RMCall looks on the stack to get the original user stack pointer.
;       if you change the stack frame the is passed to the 16 bit int
;       handlers, that WILL break.
;

w3216r30:
;
; Switch stacks, deallocate frame from dosx stack and return
;
        push    ebx
        push    eax
        push    ds
        lds     ebx,[esp+10]            ;get ss:esp
        mov     eax,[esp+16]
        mov     [ebx],eax               ;eip
        mov     eax,[esp+20]
        mov     [ebx+4],eax             ;cs
        pop     ds
        pop     eax
        pop     ebx

        lss     esp,[esp]
        push    ebx


        pushfd
        push    eax
        mov     ax,ss
        movzx   eax,ax
        lar     eax,eax
        test    eax,(AB_BIG SHL 8)      ; is the stack big?
        jnz     w32i16r40               ; jif yes, use 32bit operations
        pop     eax                     ; restore regs
        popfd

        rpushfd                         ; save flags, set virtual int bit
        pop     ebx
        push    ebp
        movzx   ebp, sp
        mov     [ebp + 16],ebx          ; put flags on iret frame
        pop     ebp
        push    ds
        mov     bx,selDgroupPM
        mov     ds,bx
        add     pbReflStack,CB_STKFRAME
        pop     ds
        pop     ebx
        riretd

w32i16r40:                              ; stack is big
        pop     eax                     ; restore regs
        popfd

        rpushfd32
        pop     ebx
        mov     [esp + 12],ebx
        push    ds
        mov     bx,selDgroupPM
        mov     ds,bx
        add     pbReflStack,CB_STKFRAME
        pop     ds
        pop     ebx
        riretd32

.286p
Wow32Intr16Reflector endp
ENDIF
DXPMCODE ends
;
;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxrom.asm ===
PAGE	,132
	TITLE	DXROM.ASM  -- Dos Extender ROM Specific Code

; Copyright (c) Microsoft Corporation 1990-1991. All Rights Reserved.

;***********************************************************************
;
;	DXROM.ASM      -- Dos Extender ROM Specific Code
;
;-----------------------------------------------------------------------
;
; This module contains code specific to the ROM version of the DOS
; Extender.
;
;-----------------------------------------------------------------------
;
;  11/05/90 jimmat  Created.
;
;***********************************************************************

	.286p

IFDEF	ROM

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include dxrom.inc
	.list


; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; Define some pubilc symbols to be exported for the ROM Image Builder

	public	__selDXCODE,  __selDXDGROUP, __selDXPMCODE

__selDXCODE	=	SEL_DXCODE
__selDXDGROUP	=	SEL_DXDATA
__selDXPMCODE	=	SEL_DXPMCODE

	public	__selFirstLDT, __selLDTAlias

__selFirstLDT	=	SEL_USER
__selLDTAlias	=	SEL_LDT_ALIAS


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

	extrn	ParaToLinear:NEAR
	extrn	AllocateLDTSelector:NEAR
	extrn	ChildTerminationHandler:NEAR

externFP	NSetSegmentDscr

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA	segment

	extrn	selGDTFree:WORD
	extrn	segDXData:WORD
	extrn	ExitCode:BYTE

SaveROMVector	dw	?

cparChildMem	dw	?		; size of child DOS mem block in para's
regOurSSSP	dd	?		; SS:SP save location

DXDATA  ends

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE	segment

; For the ROM version, the following items locate (and size) the
; DGROUP and DXPMCODE segments.  These items are 'imported' from
; the ROM Image Builder which sets the values when the ROM image
; is created.

	extrn	lmaDXDGROUP:DWORD, cparDXDGROUP:ABS, lmaDXPMCODE:DWORD
	public	lmaRomDXPMCode

cparDgroup	dw	cparDXDGROUP
lmaDGroup	dd	lmaDXDGROUP
lmaRomDXPMCode	dd	lmaDXPMCODE

DXCODE	ends


DXPMCODE segment

	extrn	selDgroupPM:WORD

	extrn	lmaROMTOC:DWORD

MyLmaROMTOC	dd	lmaROMTOC

DXPMCODE ends


; -------------------------------------------------------
	subttl	ROM Real Mode ROM Specific Routines
        page
; -------------------------------------------------------
;	    ROM REAL MODE ROM SPECIFIC ROUTINES
; -------------------------------------------------------

DXCODE	segment
	assume	cs:DXCODE

; -------------------------------------------------------
; ROMEntry --  Setup the special ROM environment needed
;	immediately by DOSX.
;
;   Note:   This routine runs in real mode only!
;
;   Input:  ES	  -> PSP for use by DOSX
;   Output: CY clear if successful, set if init failed
;	    DS	  -> DOSX RAM DGROUP
;	    DX:AX =  far return address to app that invoked DOSX
;   Errors: none
;   Uses:   All except ES

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
	public	ROMEntry

ROMEntry proc	near

; Allocate a data segment in RAM and copy down the ROM version

	mov	ah,48h			;allocate RAM for DGROUP
	mov	bx,cparDgroup
	int	21h
	jc	REAllocFailed		;big trouble if this happens

	push	ax			;save RAM DGROUP

	mov	dx, word ptr lmaDGroup[0]
	mov	bx, word ptr lmaDGroup[2]
	mov	cx, 4
	xor	si, si
@@:
	shr	bx, 1			;determine if its in conventional
	rcr	dx, 1			;memory and if so the canonical
	rcr	si, 1			;segment:offset in dx:si
	loop	@B

	or	bx, bx
	jnz	RECopyFromExtended

RECopyFromConventional:
	push	es			;save es
	mov	es,ax
	mov	ds,dx
	mov	cx,cparDgroup		;		      (CS variable)
	shl	cx,3			;DGROUP size in words
	xor	di,di
	cld
	rep	movsw
	pop	es			;restore es

	pop	ds			;point to RAM dgroup
	assume	ds:DGROUP, es:NOTHING

	clc				;worked!

REAllocFailed:

	ret

RECopyFromExtended:

	sub	sp, 30h
	mov	si, sp
	push	ss
	pop	es
	mov	di, si
	push	ax
	xor	ax,ax
	mov	cx, 18h
	rep	stosw
	dec	ax
	mov	es:[si+10h], ax 	; Limits to FFFF
	mov	es:[si+18h], ax
	mov	al, 93h
	mov	es:[si+15h], al 	; access to data rw
	mov	es:[si+1Dh], al
	pop	ax
	mov	cx, 4
	sub	dx, dx
@@:
	shl	ax, 1			;compute new DGROUP lma
	rcl	dx, 1
	loop	@B
	mov	es:[si+1Ah], ax 	;stuff into dest descr
	mov	es:[si+1Ch], dl
	mov	ax, word ptr lmaDGroup[0]
	mov	dx, word ptr lmaDGroup[2]
	mov	es:[si+12h], ax
	mov	es:[si+14h], dl 	;put ROM lma in source descr
	mov	cx, cparDGroup
	shl	cx, 3			;length of dgroup ***in words ***
	mov	ah, 87h 		;fn 87h = copy extended memory
	int	15h
	jc	REExtCopyFailed
	add	sp, 30h
	pop	ds			;get ram address in ds
	clc
	ret

REExtCopyFailed:
	add	sp, 32h 		;remove stuff from stack
	stc
	ret

ROMEntry endp


; -------------------------------------------------------
; InvokeROMChild  --  ROM specific method of invoking the
;	child application.
;
;   Note:   This routine must be called in real mode!
;	It returns to the caller after the child returns.  Control
;	passes directly to ChildTerminationHandler if child does a
;	DOS exit call.
;
;   Input:  none
;   Output: CY clear if child executed successfully, set if failed
;	    AX = error code if failure (8 = insufficient DOS memory)
;   Errors: none
;   Uses:   All except DS

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	InvokeROMChild

InvokeROMChild proc	near

; Setup the environment for the ROM child app.	First, allocate
; the largest conventional memory block available and build a PSP
; at the start of it.

	mov	bx,-1			; how big is the largest avail block?
	dossvc	48h

	cmp	bx,64 SHL 6		; is there at least 64k available?
	jae	@f
	mov	ax,8			; DOS insufficient memory error
	jmp	short IRCFail
@@:
	mov	cparChildMem,bx 	; save block size
	dossvc	48h			; allocate block

IF	DEBUG
	jnc	@f			; shouldn't fail, but...
	int	3
@@:
ENDIF

; Got conventional memory, now build a PSP at the start of it.

	mov	dx,ax			; new PSP here
	mov	si,10h			; use this as mem length for now
	dossvc	55h			; duplicate PSP call

; Set up the termination vector in the child's PSP to point to
; the Dos Extender termination code.

	mov	es,dx
	assume	es:PSPSEG

	mov	word ptr [lpfnParent],offset ChildTerminationHandler
	mov	word ptr [lpfnParent+2],cs

; Switch to protected mode to complete initialization of child environment

	SwitchToProtectedMode
	assume	ds:DGROUP,es:DGROUP

	sti

; Allocate/init a selector mapping first 64k of child memory block & PSP

	call	AllocateLDTSelector	; get new selector in AX

					; DX still has PSP segment,
	call	ParaToLinear		;   convert to linear memory address

	push	bx			; save lma for later
	push	dx
	push	ax			; save mem/PSP selector too

	cCall	NSetSegmentDscr,<ax,bx,dx,0,0FFFFh,STD_DATA>

; Allocate/init a zero length selector pointing to just past the end of
; the child's memory block and plug the selector into the PSP.

	call	AllocateLDTSelector	; get another selector

	pop	es
	assume	es:PSPSEG

	mov	segMemEnd,ax		; store in child's PSP

	mov	dx,cparChildMem 	; get size of memory block in bytes
	call	ParaToLinear		;   in BX:DX

	pop	ax			; recover lma of block start
	pop	cx			;   in CX:AX

	add	dx,ax
	adc	bx,cx			; BX:DX = lma of block end

	cCall	NSetSegmentDscr,<segMemEnd,bx,dx,0,0,STD_DATA>

; Allocate/init a selector pointin to our DOS environment block--plug this
; into the child's PSP so it can party on the same env block.

	call	AllocateLDTSelector

	mov	dx,segEnviron		; segment from PSP
	call	ParaToLinear

	cCall	NSetSegmentDscr,<ax,bx,dx,0,7FFFH,STD_DATA>

	mov	segEnviron,ax		; selector to PSP

; The child environment is now build, invoke the child with DS = ES =
; memory/PSP block.  Set the stack 64k (less one word) into the block,
; push our far return address on the stack.

	mov	word ptr [regOurSSSP],sp	;save DOSX stack location
	mov	word ptr [regOurSSSP+2],ss

	mov	ax,es			; switch to child stack
	mov	ss,ax
	mov	sp,0FFFEh

	push	cs			; far return address to us
	push	offset IRCReturn

	call	GetROMTOCPointer	; push the kernel entry CS:IP on stack
	assume	es:ROMTOC

	push	word ptr [KRNL_CSIP+2]
	push	word ptr [KRNL_CSIP]

	mov	ds,ax
	mov	es,ax
	assume	ds:NOTHING,es:NOTHING

	xor	cx, cx			; tell KRNL386 linear == physical
	xor	dx, dx

	retf				; invoke the kernel

	public	IRCReturn		;public for debugging
IRCReturn:

	mov	ds,selDgroupPM			; restore our DS
	assume	ds:DGROUP

	mov	ss,word ptr [regOurSSSP+2]	;   and our stack
	mov	sp,word ptr [regOurSSSP]

	mov	ExitCode,al			; save the child exit code

	SwitchToRealMode
	sti

	clc
	ret

IRCFail:
	stc
	ret

InvokeROMChild endp


; -------------------------------------------------------
; ROMInitialization	-- This routine performs the initial ROM
;	specific DOS Extender initialization.
;
;   Note:   This routine runs in real mode only!
;
;   Input:  none
;   Output: CY clear if successful, set if init failed
;   Errors: none
;   Uses:   AX

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	ROMInitialization

ROMInitialization	proc	near

; Point 2nd word of DOSX ROM Int vector to the data segment.

	push	es
	xor	ax,ax
	mov	es,ax

	mov	ax, word ptr es:[ROMIntVector*4][2]	;save current vector
	mov	SaveROMVector,ax			;  contents

	mov	word ptr es:[ROMIntVector*4][2],ds	;point vector to data
	pop	es

	clc

ROMInitFailed:

	ret

ROMInitialization	endp


; -------------------------------------------------------
; ROMCleanUp	-- This routine performs the ROM specific
;	DOS Extender termination clean up.
;
;   Note:   This routine runs in real mode only!
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   none

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	ROMCleanUp

ROMCleanUp	proc	near

; Remove DOSX Int vector pointer to the data segment.

	push	es
	xor	ax,ax
	mov	es,ax

	mov	ax,SaveROMVector			;restore prior contents
	mov	word ptr es:[ROMIntVector*4][2],ax

	pop	es

	ret

ROMCleanUp	endp


; -------------------------------------------------------
	subttl	ROM Real Mode Utility Routines
        page
; -------------------------------------------------------
;	    ROM REAL MODE UTILITY ROUTINES
; -------------------------------------------------------

; GetDXDataRM	-- This routine returns the paragraph address of
;	the DOS Extender data segment.	It should only be called
;	by real mode code.
;
;   Input:  none
;   Output: AX = DOSX data segment paragraph address
;   Errors: none
;   Uses:   none

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
	public	GetDXDataRM

GetDXDataRM	proc	near

; Get data segment value from 2nd word of DOSX Int vector

	push	ds

	xor	ax,ax
	mov	ds,ax
	mov	ax,word ptr ds:[ROMIntVector*4][2]

IF	DEBUG
	mov	ds,ax
	cmp	ax,ds:[segDXData]	; Make sure ax points to the
	jz	@f			;   right place
	int	3
@@:
ENDIF
	pop	ds
	ret

GetDXDataRM	endp


; -------------------------------------------------------
; SetDXDataRM	-- This routine sets DS equal to the DOS Extender
;	data segment address.  It should only be called by real
;	mode code.
;
;   Input:  none
;   Output: DS -> DOSX data segment
;   Errors: none
;   Uses:   none

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
	public	SetDXDataRM

SetDXDataRM	proc	near

; Get data segment value from 2nd word of DOSX Int vector

	push	ax

	xor	ax,ax
	mov	ds,ax
	mov	ds,word ptr ds:[ROMIntVector*4][2]

IF	DEBUG
	mov	ax,ds			; Make sure DS points to the
	cmp	ax,ds:[segDXData]	;   right place
	jz	@f
	int	3
@@:
ENDIF
	pop	ax
	ret

SetDXDataRM	endp


DXCODE	ends

;****************************************************************

DXPMCODE SEGMENT
	assume	cs:DXPMCODE

; -------------------------------------------------------
	subttl	ROM Protect Mode Utility Routines
        page
; -------------------------------------------------------
;	    ROM PROTECT MODE UTILITY ROUTINES
; -------------------------------------------------------

; ROMInitLDT	-- This routine initializes the LDT descriptors
;	defined in the ROM prototype LDT.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   none

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	ROMInitLDT

ROMInitLDT	proc	near

; Access the ROM Table of Contents to find out where the proto LDT
; is, and how many descriptors it contains.

	pusha
	push	ds
	push	es

	call	GetROMTOCPointer	; Note: uses SEL_SCR0
	assume	es:ROMTOC

	mov	cx,cROMsels		   ; # descriptors defined in proto LDT
	mov	bx,word ptr [lmaROMLDT+2]
	mov	dx,word ptr [lmaROMLDT]       ; bx:dx = lma of proto LDT
	mov	ax,FirstROMSel
	mov	di, ax

; Do a quick (and dirty?) allocation of the correct number of LDT selectors.
; DANGER: this code has intimate knowledge of how the LDT free list is kept!
; We could make CX calls to AllocateLDTSelector, but that is slow and would
; do zillions and zillions of segment loads.
;
	cmp	ax,selGDTFree		; next free descriptor in LDT
	jne	alloc_in_chain

IF	DEBUG
	cmp	ax,__selFirstLDT	; first one free better be the one
	jz	@f			;   the ROM Image Builder used.
	int	3
@@:
ENDIF
	shl	cx,3			; 'allocate' all these by setting
	add	ax,cx			;   the next free to be beyond them
	mov	selGDTFree,ax
	push	SEL_LDT_ALIAS OR STD_RING
	pop	es
	jmp	short sels_alloced

alloc_in_chain:
	mov	si, ax
	sub	si, 8
	push	SEL_LDT_ALIAS OR STD_RING
	pop	es
	shl	cx, 3
	add	ax, cx
	mov	es:[si], ax

sels_alloced:

; Copy the prototype descriptors into the actual LDT

	cCall	NSetSegmentDscr,<SEL_SCR0,bx,dx,0,-1,STD_DATA>

	push	SEL_SCR0 OR STD_TBL_RING
	pop	ds			; ds -> proto LDT descriptors
	assume	ds:NOTHING

	xor	si,si

	shr	cx,1			; # words of descriptors to copy

	cld
	rep movsw			; move'm into the LDT

	pop	es
	pop	ds
	assume	ds:DGROUP,es:NOTHING
	popa

	ret

ROMInitLDT	endp


; -------------------------------------------------------
; GetROMTOCPointer -- return ES:0 pointing to the ROM Table of
;	Contents.
;
;   Note: modifies the SEL_SCR0 descriptor!
;
;   Input:  none
;   Output: ES:0 -> ROM TOC
;   Errors: none
;   Uses:   none

	assume	ds:DGROUP,es:NOTHING,ss:NOTHING
	public	GetROMTOCPointer

GetROMTOCPointer proc	near

	push	bx
	push	dx

	mov	bx,word ptr [MyLmaROMTOC+2]
	mov	dx,word ptr [MyLmaROMTOC]	;bx:dx = lma of ROMTOC

	cCall	NSetSegmentDscr,<SEL_SCR0,bx,dx,0,-1,STD_DATA>

	push	SEL_SCR0 OR STD_TBL_RING
	pop	es

	pop	dx
	pop	bx

	ret

GetROMTOCPointer endp


; -------------------------------------------------------
; GetDXDataPM	-- This routine returns the paragraph address of
;	the DOS Extender data segment.	It should only be called
;	by protected mode code.
;
;   Input:  none
;   Output: AX = DOSX data segment paragraph address
;   Errors: none
;   Uses:   none

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
	public	GetDXDataPM

GetDXDataPM	proc	near

; Get data segment value from 1st word of DOSX Int vector

	push	ds

	mov	ax,SEL_RMIVT or STD_RING
	mov	ds,ax
	mov	ax,word ptr ds:[ROMIntVector*4][2]

	pop	ds
	ret

GetDXDataPM	endp

if 0	;***************************************************************
; -------------------------------------------------------
; SetDXDataPM	-- This routine sets DS equal to the DOS Extender
;	data segment address.  It should only be called by protected
;	mode code.
;
;   Input:  none
;   Output: DS -> DOSX data segment
;   Errors: none
;   Uses:   none

	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
	public	SetDXDataPM

SetDXDataPM	proc	near

; Set DS = data segment selector.

	push	SEL_DXDATA OR STD_RING
	pop	ds
	ret

SetDXDataPM	endp
endif	;***************************************************************


DXPMCODE ends

;****************************************************************

ifdef ROMSTUB	;--------------------------------------------------------

	*********************************************
	*********************************************
	*****					*****
	*****	 THIS CODE IS NO LONGER USED	*****
	*****					*****
	*********************************************
	*********************************************

DXSTUB	SEGMENT
	assume	cs:DXSTUB

; -------------------------------------------------------
	subttl	Real Mode RAM Stub Segment
        page
; -------------------------------------------------------
;	    REAL MODE RAM STUB SEGMENT
; -------------------------------------------------------

; This segment contains code and data that is moved to conventional
; RAM during initialization.  The code is only executed from RAM
; mode and exists for those few cases where it is most convenient
; to have code segement variables.
;
; Note: Since this code is moved to RAM, be very carefull of the
; instructions it contains.  In particular, realize the the code segment
; value is going to be different from the copy in ROM.

; -------------------------------------------------------
;		CODE SEGMENT VARIABLES
; -------------------------------------------------------

	public	PrevInt2FHandler

PrevInt2FHandler	dd	?

; -------------------------------------------------------
; StubInt2FHook -- This code is used by the DOS Extender real mode
;	Int 2Fh hook to chain the interrupt to the previous Int 2Fh
;	handler.
;
; Note: This code executes in real mode only!
;
;   Input:  stack = [DS] [IP] [CS] [FL]
;   Output: none
;   Errors: none
;   Uses:   none


	assume	ds:NOTHING,es:NOTHING,ss:NOTHING
	public	StubInt2FHook

StubInt2FHook	proc	far

	pop	ds
	jmp	[PrevInt2FHandler]

StubInt2FHook	endp

; -------------------------------------------------------

DXSTUB	ends

endif	;----------------------------------------------------------------

;****************************************************************

ENDIF	;ROM

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxmain.asm ===
PAGE    ,132
        TITLE   DXMAIN.ASM -- Main Module for Dos Extender

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXMAIN.ASM      -   Dos Extender Main Module            *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains the main routines for the Dos          *
;*  Extender.  This is based on code written for Microsoft      *
;*  by Murray Sargent of Scroll Systems from Tucson Arizona.    *
;*                                                              *
;*  The Dos Extender provides support to allows specially       *
;*  written programs to run in protected mode mode on the       *
;*  80286 and 80386 under MS-DOS.  The following areas of       *
;*  support are provided to accomplish this:                    *
;*                                                              *
;*  Program Loading and Initialization                          *
;*      This involves creating a program segment prefix and     *
;*      then loading and relocating the exe file.  When         *
;*      loading an exe for protected mode operation, it is      *
;*      necessary to create segment descriptors for all         *
;*      segments used by the program and to then substitute     *
;*      the corresponding selectors when fixing up the segment  *
;*      references in the code.                                 *
;*                                                              *
;*  Dos Function Call Support                                   *
;*      Since Dos must execute in real mode, it is necessary    *
;*      to perform mode switching into real mode and the back   *
;*      to protected mode when the application makes Dos calls. *
;*      Also, any far pointers that are parameters to the       *
;*      function must be converted from the selector:offset     *
;*      form that the application uses to a segment:offset form *
;*      that Dos can use, with the corresponding data being     *
;*      buffered from the application's extended memory address *
;*      space to Dos's real mode address space.                 *
;*                                                              *
;*  Other Interrupt Support                                     *
;*      Hardware interrupts are processed in real mode, and     *
;*      so the Dos Extender performs mode switching on each     *
;*      interrupt.  Also other system resources (such as the    *
;*      mouse driver and the bios) are entered through software *
;*      interrupts, and require the same kind of buffering      *
;*      and parameter translation that the Dos functions        *
;*      require.                                                *
;*                                                              *
;*  Extended Memory Management                                  *
;*      The protected mode application has access to the full   *
;*      address space of the machine, and a memory manager is   *
;*      provided that duplicates the functions of the Dos       *
;*      memory manager over the entire address space of the     *
;*      machine.                                                *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  08/08/90 earleh DOSX and Client privilege ring determined   *
;*      by equate in pmdefs.inc                                 *
;*  03/23/90 davidw   Added the reflecting of it 23h, ^C.       *
;*  11/09/89 jimmat   Added more IOCTL 0Dh support for Windows. *
;*  10/11/89 jimmat   Changed hooking of Int 1,2,3 under a      *
;*                    debugger to work better with CVW.         *
;*  07/28/89 jimmat   Fixed Int 21h/56h (Rename), fixed Int 21  *
;*                    calls that just returned a pointer.       *
;*  06/07/89 jimmat   Fixed length of FCB moves and special     *
;*                    case hooking Int 1Eh.                     *
;*  05/30/89 jimmat   Completed Int 21h/5Ah processing.         *
;*  04/25/89 jimmat   Added support for undocumented INT 21h    *
;*                    5Fh/05 DOS call.                          *
;*  04/12/89 jimmat   Allow one level of nested DOS calls to    *
;*                    support PM critical error handlers        *
;*  04/10/89 jimmat   Supported INT 21h/5Eh & 5Fh--also small   *
;*                    clean-up of the dosentry/dosexit code.    *
;*  04/05/89 jimmat   Fixed MOVDAT FCB length check.            *
;*  04/04/89 jimmat   Stop reflecting real mode software ints   *
;*                    to protect mode.  This is how Windows/386 *
;*                    works, and it fixes a problem with DOS    *
;*                    networks since the real mode redirector   *
;*                    expects to have access to the DOS stack,  *
;*                    not a DOS extender interrupt stack frame. *
;*  03/28/89 jimmat   Incorporated bug fixes from GeneA         *
;*  03/17/89 jimmat   Some code clean-up and debugging checks   *
;*  03/15/89 jimmat   Minor changes to run child in ring 1      *
;*  02/22/89 (GeneA): removed dead code and data left over      *
;*      from the Murray Sargent/SST days.                       *
;*  02/22/89 (GeneA): moved handlers for all interrupts but     *
;*      Int 21h to DXINTR.ASM.  Fixed problem with re-entrancy  *
;*      caused when the other interrupts were executed while    *
;*      in DOS.  (int 15h was causing the specific problem).    *
;*  02/14/89 (GeneA): fixed bug in IntExitMisc.  Was storing    *
;*      return value in rmrg.xes, changed to pmrg.xes.          *
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*      medium model.                                           *
;*  12/01/88 (GeneA): Changed name of mentry and mexit to       *
;*      IntEntryMouse and IntExitMouse.  Added functions        *
;*      IntEntryMisc and IntExitMisc to handle entry and        *
;*      exit processing for BIOS INT 15h.                       *
;*  11/20/88 (GeneA): modified DFSetVector so that is checks to *
;*      see if a vector has already been hooked before saving   *
;*      the old value in the real mode interrupt vector shadow  *
;*      buffer.                                                 *
;*  09/15/88 (GeneA):   created by extracting code from the     *
;*      SST debugger modules DOSXTND.ASM, VIRTMD.ASM,           *
;*      VRTUTIL.ASM, and INTERRPT.ASM                           *
;*                                                              *
;****************************************************************

        .286p
        .287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include intmac.inc
include bop.inc
include dpmi.inc
include hostdata.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; STKSTR  -- stack layout structure for user registers in the pmrg and
; rmrg arrays in the data segment DXDATA.  pmrg is an exact replica of the pm
; user registers on entry to the Dos Extender (DE).  rmrg is a translated
; version used to communicate with the real-mode world.  The rmrg array is
; initially set equal to the pm user values by the instructions push ds, push
; es, pusha.  The pmrg array es and ds are inevitably set equal to the pm user
; values and its general register values are defined if data translations may be
; required (int-10/21).

stkstr  struc           ;Level-0 Stack structure. bp is set = sp here
xdi     dw      ?
xsi     dw      ?
xbp     dw      ?
xasp    dw      ?       ;Alternate sp
xbx     dw      ?
xdx     dw      ?
xcx     dw      ?
xax     dw      ?       ;pusha pushes xax to xdi
xes     dw      ?
xds     dw      ?
stkstr  ends


; -------------------------------------------------------
;   This structure describes the EXEC parameter block used
;   by MS-DOS function 4Bh.

execblk struc           ;INT-21 ah=4bh EXEC parameter block
evrnmt  dw      ?       ;Paragraph of environment string to be passed
cmdptr  dd      ?       ;Ptr to command line to be placed at PSP+80h
fcb1ptr dd      ?       ;Ptr to default FCB to be passed at PSP+5ch
fcb2ptr dd      ?       ;Ptr to default FCB to be passed at PSP+6ch
xsssp   dd      ?       ;Initial program stack ss:sp
xcsip   dd      ?       ;Program entry point cs:ip
execblk ends

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   gtpara:NEAR
        extrn   GetSegmentAddress:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   SelOff2SegOff:NEAR
        extrn   ParaToLDTSelector:NEAR
        extrn   NSetSegmentDscr:FAR
        extrn   ChildTerminationHandler:NEAR

; -------------------------------------------------------
;               DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   selGDT:WORD
        extrn   segPSPChild:WORD
        extrn   npXfrBuf1:WORD
        extrn   rgbXfrBuf0:BYTE
IFDEF WOW_x86
        extrn   FastBop:FWORD
ENDIF

        extrn   segDXCode:word
        extrn   segCurrentHostData:word
; -------------------------------------------------------
;           General DOS EXTENDER Variables
; -------------------------------------------------------

pmdta   dw      2 dup(?)    ;PM DTA.  Used for getting dir info

EntryFlag db    -1          ;Flag to check for nested DOS interrupts

rcount  dw      ?       ;Remaining requested file byte count to read/write
ccount  dw      ?       ;Current count of total read/written

;=======================================================================
;Keep from here thru Iend in the following order:

        align   2
Ibegin  label   byte            ;start of PMIntrDos nested 'Instance' data

        dw      128 dup(?)      ;Extra stack for real mode

rmrg    stkstr  <>              ;Corresponding real-mode set
rmivip  dw      ?               ;Real-mode interrupt-vector offset
rmivcs  dw      ?               ;Real-mode interrupt-vector segment
rmivfl  dw      ?               ;Real-mode interrupt flags to be used
rmroff  dw      ?               ;Real-mode return address offset
rmrseg  dw      ?               ;Real-mode return address segment
rmflags dw      ?               ;flags

pmrg    stkstr  <>              ;Protected-mode user registers

        public  pmusrss, pmusrsp

pmusrsp dw      ?       ;PM user sp
pmusrss dw      ?       ;PM user ss

enxseg  dw      ?       ;transfer segment used on dos function exit

Iend    label   byte    ;end of PMIntrDos nested 'Instance' data
;=======================================================================

ILENGTH equ     Iend - Ibegin   ;length of instance data

Isave   db      ILENGTH dup (?) ;instance data save area

DXDATA  ends


; -------------------------------------------------------
;               CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   segDXData:WORD
        extrn   selDgroup:WORD

DXCODE  ends

DXPMCODE    segment

        extrn   selDgroupPM:WORD
        extrn   segDXCodePM:WORD
        extrn   segDXDataPM:WORD

; -------------------------------------------------------
;           Dos Function Parameter Tables
; -------------------------------------------------------

; The Dos Extender provides parameter buffering and translation
; on entry to and exit from Dos system calls.  The following table
; is used to describe the operations to be performed for this process.
; The basic idea is that there is an entry parameter code and an
; exit paramter code.  This code describes whether any data buffering
; is necessary.  If buffering is necessary, it describes the nature of
; the data being transferred (e.g. ASCIIZ string, FCB, etc.) which is
; used to determine the transfer length.  The entry/exit code also
; describes which temporary buffer to use for the transfer, and which
; user register (e.g. DS:DX, ES:BX, etc) points to the data to transfer.
;
; The data transfers described by this table is sufficient to handle
; the majority of the Dos system calls.  However, any Dos call which
; requires the transfer of more than one buffer of data, or which requires
; that additional processing be performed other than simply copying a
; buffer is handled with special case code.


; The following symbols define various parts of the entry/exit codes
; used in the parameter table.

; Nibble 0 of a transfer word is a code that specifies the length of the
; transfer as follows:

; 0       no xfer
; 1       FCB                     to/from         (f,10,11,12,13,16,17,23,24,29
; 2       PTR$                    from            (1b,1c,34)
; 3       ASCZ                    to/from         (39,3a,3b,3c,3d,41,43,4b,4e,56
;                                                  5a,5b)
; 4       DOLLAR terminated       to DOS          (9)
; 5       AX$                     from            (3f)
; 6       CX$                     to/from         (3f,40,44)
; 7       KEYBUF                  to/from DOS     (a)
; 8       Country INFO (34)       to/from         (38)
; 9       EXTERR (22)             to              (5d)
; a       DIRectory (64)          from            (47)
; b       EXEC parm (14)          to              (4b)
; c       file MATCH (43)         to/from         (4e,4f)
; d       CMND line (128)         to              (29)
; e       PALETTE (17)            to              (int-10/1002)
; f       VBIOS (64)              from            (int-10/1b)
;
;
; Nibble 1 specifies the segment value transferred as follows (DOS entries
; affected are listed in parentheses):
;
; Segment ptr
;
; 0       none
; 1       ds:dx   to/from DOS     (9,a,f,10,11,12,13,14,16,17,21,22,23,24,25,27
;                                  28,39,3a,3b,3c,3d,3f,40,41,43,44,4b,4e,4f,56
;                                  5a,5b)
; 2       DTA     to/from         (11,12,14,15,21,22,27,28,4e)
; 3       ds:bx   from            (1b,1c)         (Allocation table info)
; 4       ds:si   to/from         (29,47)         (Parse FN, get dir)
; 5       es:di   to/from         (29,56)         (Parse FN, rename)
; 6       es:bx   to/from         (2f,35,4b)      (Get DTA, intvct, EXEC)
; 7       es      to              (49,4a)         (RAM allocation)
;
; Byte 1 (high byte) on has meanings:
;
; bit 0 = 1       (A0) use small data area 0 (limited to 60h bytes)
; bit 1 = 1       (A1) use large area 1 (4K)
; bit 2 = 1       (RP) Real/Protect mode transfer needed (for int 21 ah = 3f/40)
; bit 7 = 1/0     (EX) exitcd/entrycd


entrycd record  EnArea:4,EnSegCod:4,EnLenCod:4
exitcd  record  ExArea:8,ExSegCod:4,ExLenCod:4

;Length codes:

FCB     equ     1
PTR$    equ     2       ;only supports DSBX & ESBX for now (and DSSI if DBCS)
ASCZ    equ     3
DOL     equ     4
AX$     equ     5
CX$     equ     6
KYB     equ     7
INFO    equ     8       ;Constant length transfers from here down vvvvvvvv
EXTERR  equ     9
DIR     equ     0Ah
EXEC    equ     0Bh
MTCH    equ     0Ch
CMD     equ     0Dh
PALETTE equ     0Eh
VBIOS   equ     0Fh     ;Constant length transfers from here up ^^^^^^^^^^

;Segment codes:

DSDX    equ     1
DTA     equ     2
DSBX    equ     3
DSSI    equ     4
ESDI    equ     5       ;Also used by int-10/ah=1bh
ESBX    equ     6       ;Also used by int-10/ah=1ch
ES$     equ     7
ESDX    equ     8       ;Used by int-10/ah=10,12, int-33/ah=22,23
ESBP    equ     9       ;Used by int-10/ah=11,13


;RAM area codes:

A0      equ     1
A1      equ     2
RP      equ     4
EX      equ     80h


pmrmxfr entrycd <>              ;0 - Program Terminate
        exitcd  <>
        entrycd <>              ;1 - Keyboard Input
        exitcd  <>
        entrycd <>              ;2 - Display output
        exitcd  <>
        entrycd <>              ;3 - Auxiliary Input
        exitcd  <>
        entrycd <>              ;4 - Auxiliary Output
        exitcd  <>
        entrycd <>              ;5 - Printer Output
        exitcd  <>
        entrycd <>              ;6 - Direct Console I/O
        exitcd  <>
        entrycd <>              ;7 - Direct Console Input Without Echo
        exitcd  <>
        entrycd <>              ;8 - Console Input Without Echo
        exitcd  <>
        entrycd <A1,DSDX,DOL>   ;9 - Print string
        exitcd  <>
        entrycd <A1,DSDX,KYB>   ;0A - Buffered Keyboard Input
        exitcd  <EX+A0,DSDX,KYB>
        entrycd <>              ;0B - Check Standard Input Status
        exitcd  <>
        entrycd <>              ;0C - Clear Kbd Buffer and Invoke Kbd Function
        exitcd  <>
        entrycd <>              ;0D - Disk Reset
        exitcd  <>
        entrycd <>              ;0E - Select Disk
        exitcd  <>
        entrycd <>              ;0F - Open File        ** Unsupported! **
        exitcd  <>
        entrycd <>              ;10 - Close File       ** Unsupported! **
        exitcd  <>
        entrycd <A0,DSDX,FCB>   ;11 - Search for First Entry
        exitcd  <EX+A1,DTA,FCB>
        entrycd <A0,DSDX,FCB>   ;12 - Search for Next Entry
        exitcd  <EX+A1,DTA,FCB>
        entrycd <A0,DSDX,FCB>   ;13 - Delete File
        exitcd  <>
        entrycd <>              ;14 - Sequential Read  ** Unsupported! **
        exitcd  <>
        entrycd <>              ;15 - Sequential Write ** Unsupported! **
        exitcd  <>
        entrycd <>              ;16 - Create File      ** Unsupported! **
        exitcd  <>
        entrycd <A0,DSDX,FCB>   ;17 - Rename File
        exitcd  <>
        entrycd <>              ;18 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;19 - Current Disk
        exitcd  <>
        entrycd <A1,DSDX,>      ;1A - Set Disk Transfer Address
        exitcd  <>
        entrycd <>              ;1B - Allocation Table Info
        exitcd  <,DSBX,PTR$>
        entrycd <>              ;1C - Alloc Table Info for Specific Device
        exitcd  <,DSBX,PTR$>
        entrycd <>              ;1D - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;1E - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;1F - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;20 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;21 - Random Read      ** Unsupported! **
        exitcd  <>
        entrycd <>              ;22 - Random Write     ** Unsupported! **
        exitcd  <>
        entrycd <>              ;23 - File Size        ** Unsupported! **
        exitcd  <>
        entrycd <>              ;24 - Set Relative Record Field ** Unsupported! **
        exitcd  <>
        entrycd <,DSDX,>        ;25 - Set Interrupt Vector (0/ds:dx/0)
        exitcd  <>
        entrycd <,DSDX,>        ;26 - Create new PSP
        exitcd  <>
        entrycd <>              ;27 - Random Block Read  ** Unsupported! **
        exitcd  <>
        entrycd <>              ;28 - Random Block Write ** Unsupported! **
        exitcd  <>
        entrycd <A0,DSSI,ASCZ>  ;29 - Parse Filename
        exitcd  <EX+A1,ESDI,FCB>
        entrycd <>              ;2A - Get Date
        exitcd  <>
        entrycd <>              ;2B - Set Date
        exitcd  <>
        entrycd <>              ;2C - Get Time
        exitcd  <>
        entrycd <>              ;2D - Set Time
        exitcd  <>
        entrycd <>              ;2E - Set/Reset Verify Switch
        exitcd  <>
        entrycd <>              ;2F - Get Disk Transfer Address
        exitcd  <EX+A0,ESBX,>
        entrycd <>              ;30 - Get DOS Version Number
        exitcd  <>
        entrycd <>              ;31 - Terminate and Stay Resident
        exitcd  <>
        entrycd <>              ;32 - Get Drive Parameter Block
        exitcd  <,DSBX,PTR$>
        entrycd <>              ;33 - Ctrl-Break Check
        exitcd  <>
        entrycd <>              ;34 - Get InDOS flag address
        exitcd  <,ESBX,PTR$>
        entrycd <>              ;35 - Get Interrupt Vector
        exitcd  <EX,ESBX,>
        entrycd <>              ;36 - Get Disk Free Space
        exitcd  <>
        entrycd <>              ;37 - Used Internally by DOS
        exitcd  <>
        entrycd <A1,DSDX,>      ;38 - Set/Get Country Dependent Info
        exitcd  <EX+A1,DSDX,INFO>
        entrycd <A0,DSDX,ASCZ>  ;39 - MKDIR
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;3A - RMDIR
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;3B - CHDIR
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;3C - Create a File
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;3D - Open a File
        exitcd  <>
        entrycd <>              ;3E - Close a File Handle
        exitcd  <>
        entrycd <RP,DSDX,>      ;3F - Read from a File or Device
        exitcd  <EX+RP,DSDX,AX$>
        entrycd <RP,DSDX,CX$>   ;40 - Write to a File or Device
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;41 - Delete a File from a Specified Directory
        exitcd  <>
        entrycd <>              ;42 - Move File Read/Write Pointer
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;43 - Change File Mode
        exitcd  <>
        entrycd <>              ;44 - I/O Control for Devices
        exitcd  <>               ;See ioctlw for write
        entrycd <>              ;45 - Duplicate a File Handle
        exitcd  <>
        entrycd <>              ;46 - Force a Duplicate of a File Handle
        exitcd  <>
        entrycd <A0,DSSI,>      ;47 - Get Current Directory
        exitcd  <EX+A0,DSSI,ASCZ>
        entrycd <>              ;48 - Allocate Memory
        exitcd  <>
        entrycd <,ES$,>         ;49 - Free Allocated Memory
        exitcd  <>
        entrycd <,ES$,>         ;4A - Modify Allocated Memory Blocks
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;4B - Load or Execute a Program (EXEC)
        exitcd  <>
        entrycd <>              ;4C - Terminate a Process
        exitcd  <>
        entrycd <>              ;4D - Get Return Code of a Sub-process
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;4E - Find First Matching File
        exitcd  <EX+A1,DTA, MTCH>
        entrycd <A1,DTA,MTCH>   ;4F - Find Next Matching File
        exitcd  <EX+A1,DTA, MTCH>
        entrycd <,ESBX,>        ;50 - Set current PSP (code restores bx)
        exitcd  <>
        entrycd <>              ;51 - Get current PSP
        exitcd  <>
        entrycd <>              ;52 - Get Pointer to SysInit Variables
        exitcd  <,ESBX,PTR$>
        entrycd <A1,DSSI,DIR>   ;53 - Set Drive Parameter Block
        exitcd  <>
        entrycd <>              ;54 - Get Verify Setting
        exitcd  <>
        entrycd <,DSDX,>        ;55 - Duplicate PSP
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;56 - Rename a File
        exitcd  <>
        entrycd <>              ;57 - Get/Set a File's Date and Time
        exitcd  <>
        entrycd <>              ;58 - Get/Set Allocation Strategy
        exitcd  <>
        entrycd <>              ;59 - Get Extended Error
        exitcd  <>
        entrycd <A0,DSDX,ASCZ>  ;5A - Create Temporary File
        exitcd  <EX+A0,DSDX,ASCZ>
        entrycd <A0,DSDX,ASCZ>  ;5B - Create New File
        exitcd  <>
        entrycd <>              ;5C - Lock/Unlock File Access
        exitcd  <>
        entrycd <A0,DSDX,EXTERR>  ;5D - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;5E - Network Machine Name/Printer Setup
        exitcd  <>
        entrycd <>              ;5F - Get/Make Assign-List Entry
        exitcd  <>
        entrycd <>              ;60 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;61 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;62 - Get PSP Address
        exitcd  <>
        entrycd <>              ;63 - Get Lead Byte Table  ** Unsupported! **
        exitcd  <>
        entrycd <>              ;64 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;65 - Get Extended Country Info
        exitcd  <EX+A1,ESDI,CX$>;     ** Only Partially Supported **
        entrycd <>              ;66 - Get/Set Code Page
        exitcd  <>
        entrycd <>              ;67 - Set Handle Count
        exitcd  <>
        entrycd <>              ;68 - Commit File
        exitcd  <>
        entrycd <>              ;69 - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;6A - Used Internally by DOS
        exitcd  <>
        entrycd <>              ;6B - Used Internally by DOS
        exitcd  <>
        entrycd <A0,DSSI,ASCZ>  ;6C - Extended Open File
        exitcd  <>

MaxInt21 equ    06Ch            ;max supported Int 21h function

UnSupported entrycd <>          ;for unsupported DOS calls
            exitcd  <>

if DEBUG   ;------------------------------------------------------------

; Table of partially supported/unsupported/unknown Int 21h functions

ifdef DBCS
tblBad21  db    18h,1Dh,1Eh,1Fh,20h,37h,5Dh,60h,61h
          db    64h,65h,6Ah,6Bh,0
else
tblBad21  db    18h,1Dh,1Eh,1Fh,20h,37h,5Dh,60h,61h,63h
          db    64h,65h,6Ah,6Bh,0
endif
endif   ;DEBUG  --------------------------------------------------------
;
; For compatibility with WIN386, the following FCB calls are failed
; unconditionally.
;
MIN_REAL_BAD_21 equ     0fh
MAX_REAL_BAD_21 equ     28h

tblRealBad21    db 0fh,10h,14h,15h,16h,21h,22h,23h,24h,27h,28h,0



; Special codes for special INT 21h functions

int215E         entrycd <A0,DSDX,>              ;5E/00 - Get Machine Name
                exitcd  <EX+A0,DSDX,ASCZ>
                entrycd <A0,DSDX,ASCZ>          ;5E/01 - Set Machine name
                exitcd  <>
                entrycd <A0,DSSI,CX$>           ;5E/02 - Set Printer Setup Str
                exitcd  <>
                entrycd <A0,ESDI,>              ;5E/03 - Get Printer Setup Str
                exitcd  <EX+A0,ESDI,CX$>

int215F02       entrycd <A0,DSSI>               ;5F/02 - Get Redir List Entry
                exitcd  <EX+A0,DSSI,ASCZ>
                entrycd <A0,DSSI,ASCZ>          ;5F/03 - Set Redir List Entry
                exitcd  <>
                entrycd <A0,DSSI,ASCZ>          ;5F/04 - Cancel Redirection
                exitcd  <>
                entrycd <A0,DSSI>               ;5F/05 - Get Redir List Entry
                exitcd  <EX+A0,DSSI,ASCZ>

ifdef DBCS
int2163         entrycd <>              ;63/00 - Get Lead Byte Table Entry
                exitcd  <,DSSI,PTR$>
endif ; DBCS

int21esdi       entrycd <A1,ESDI,ASCZ>          ;56 & 5F/02&03&05 eXtra buffer
                exitcd  <EX+A1,ESDI,ASCZ>


;
; We only use the entry code from the following.  If we don't
; we trash the stack in applications like borland c++
;
int21pfn        entrycd <A1,ESDI,FCB>           ;29, fcb buffer
                exitcd  <>


; Additional tables for run time support associated with register
; translation and buffering.

;                 8   9       a    b    c     d     e      f
;               INFO EXTERR  DIR  EXEC MATCH CMND PALETTE VBIOS
mvcnt   db      34,   22,    40h, 0Eh,  43,   80h,  17,    64

;                 1    2     3     4     5     6    7     8     9
;               DSDX, DTA, DSBX, DSSI, ESDI, ESBX, ES$, esdx, esbp
regoffs dw       xdx,  0,   xbx,  xsi,  xdi,  xbx,  0,   xdx,  xbp

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Main Program
        page
; -------------------------------------------------------
;               MAIN PROGRAM
; -------------------------------------------------------


DXPMCODE  segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   PMIntrDos -- This function is the main handler for int 21h calls
;       that require special case processing.  Most interrupts
;       go through the interrupt reflector (PMIntrReflector in
;       dxintr.asm).  DOS int 21h interrupts are vectored here.
;
;       This routine performs any register manipulation, data buffering
;       etc. needed to pass the interrupt parameters from the
;       protected mode caller to the real mode handler.  Register
;       manipulation and data transfers can occur either on entry
;       to the interrupt handler or on exit from the interrupt
;       handler (to fix up return values.)
;
;   Input:  normal registers for Dos calls
;   Output: normal register returns for Dos calls
;   Errors: normal Dos errors
;   Uses:   In general, all registers are preserved.  For interrupts where
;           register translation or buffering occurs, some registers may
;           be changed, depending on the interrupt and its parameters.

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntrDos

PMIntrDos       proc    far

        push    ds
        push    ax
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        assume  ds:DGROUP
        mov     ax,ss
        mov     pmusrss,ax
        mov     ax,sp
        add     ax,4
        mov     pmusrsp,ax
        pop     ax

        FBOP    BOP_DPMI,XlatInt21Call,FastBop
; If we get here, the api wasn't translated.  The translation code will
; simulate the iret
        assume  ds:nothing

NotXlated:
        cld                     ;Code assumes direction flag is cleared

; Save PM user ds, es, and flags, and switch to DOS extender stack

        push    ax              ;Save caller's AX
        push    bp
        mov     bp,sp           ;[bp] = bp ax ip cs fl - 286 int gates assumed
                                ;        0  2  4  6  8
        push    es

        mov     es,selDgroupPM          ;Address our DGROUP
        assume  es:DGROUP


; Check for nested DOS interrupts--this code was written with the assumption
; that we would never be reentered, but it turns out that we may need to
; support nested DOS calls from a critical error handler.  If this is one
; of those ultra-rare occasions, save our previous 'instance' data in Isave.

        inc     EntryFlag       ;The normal case will be to jump
        jz      @f

        push    cx              ;Being reentered, save last instance data
        push    di
        push    si

        mov     cx,ILENGTH                      ;NOTE!!!  The next movs has
        mov     si,offset DGROUP:Ibegin         ;  an es override, if ints
        mov     di,offset DGROUP:Isave          ;  are enabled, an interrupt
        rep movs byte ptr [di],byte ptr es:[si] ;  on this instr can 'forget'
                                                ;  about the es override with
        pop     si                              ;  some processors
        pop     di
        pop     cx
@@:

; Start saving callers state.

        mov     pmrg.xds,ds     ;Save PM user ds
        mov     ax,[bp+8]       ;Get ax = flags when int occurred
        mov     rmflags,ax      ;Store flags for real-mode handler

        pop     pmrg.xes        ;Save PM user es

        pop     bp
        pop     ax              ;Recover user ax. [sp] = ip cs fl

; At this point all general registers (but not ES) have the user's values

        push    es              ;Address DGROUP, user's DS already
        pop     ds              ;  saved in pmrg.xds
        assume  ds:DGROUP

        mov     pmusrss,ss      ;Save PM user stack ptr
        mov     pmusrsp,sp      ;[sp] = ds ip cs fl
                                ;        0  2  4  6
        mov     pmrg.xsi,si     ;Save PM si since need to use before pusha

        push    ds              ;Switch to rmrg stack for this routine
        pop     ss
        mov     sp,offset DGROUP:rmflags        ;PM flags already on stack
        FSTI                     ;We don't really need interrupts disabled


; Setup iret frames for iret'ing to real-mode handler and for that handler
; returning to the DOS extender

        pop     si              ;Get rmflags
        and     si,not 4100h    ;Kill NT, TF
        push    si              ;Push flags for iret to BackFromDOS
        push    segDXCodePM     ;Push return cs:ip for iret
        push    offset BackFromDOS

        and     si,not 0200h    ;Kill IF
        push    si              ;Push flags for iret to real-mode handler

        sub     sp,4                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp


; Setup protected mode and real mode copies of registers.

        mov     si,pmrg.xsi     ;Restore si
        push    ds              ;Save space for real mode ds
        push    es              ;  and es
        pusha                   ;Save user general registers

        mov     si,offset DGROUP:rmrg   ;Copy user values to PM set for
        mov     di,offset DGROUP:pmrg   ;  reference (real-mode set may change)
        mov     cx,8            ;8 general registers (es and ds already stored)
        rep     movsw

        mov     ax,segDXDataPM  ;ax = DOS extender real-mode dgroup segment
        mov     rmrg.xds,ax     ;Default real-mode data segments
        mov     rmrg.xes,ax     ;  (dosentry may change them)

        mov     ax,rmrg.xax

if DEBUG   ;------------------------------------------------------------

; Check for partially supported/unsupported/unknown DOS calls

        cmp     ah,0DCh                 ;krnl286 is doing this now, quit
        jz      goodfunc                ;  complaining about it

        cmp     ax,5D0Ah                ;Set Extended Error is the only
        jz      goodfunc                ;5Dh function handled properly!

        cmp     ah,MaxInt21             ;is the request within our range?
        ja      badfunc

        mov     bx,offset DXPMCODE:tblBad21
@@:
        cmp     ah,cs:[bx]
        jb      goodfunc
        jz      badfunc
        inc     bx
        jmp     short @b

badfunc: Trace_Out "Possible Unsupported DOS Call! AX=#AX"

goodfunc:

endif   ;DEBUG  --------------------------------------------------------

; Check for FCB calls that we fail unconditionally (because WIN386 does.)

        cmp     ah,MIN_REAL_BAD_21
        jb      goodfunc1
        cmp     ah,MAX_REAL_BAD_21
        ja      goodfunc1

mov     bx,offset DXPMCODE:tblRealBad21
@@:
        cmp     ah,cs:[bx]
        je      badfunc1
        inc     bx
        cmp     byte ptr cs:[bx],0
        jz      goodfunc1               ; Ran off end of table.
        jmp     short @b

badfunc1:

if DEBUG
        Debug_Out "Unsupported DOS Call! AX=#AX"
endif   ;DEBUG

        or      byte ptr rmflags,1      ; Set CF
        call    xfrflg
        jmp     LeaveDOSExtender

goodfunc1:


; int 21 entry register translations and data transfers
        cmp     ah,00h          ;old style DOS Exit call?
        jnz     @f
        call    DosExitCall     ;sets CY if it handles the call, otherwise
        jnc     @f              ;  do it normally...
        jmp     LeaveDOSExtender
@@:
        ;
        ; Handle terminate specially.  We mess with the PSP here to set
        ; up a terminate vector we like.  We don't do anything special for
        ; TSR (31h)
        ;
        cmp     ah,4ch          ; terminate?
        jnz     @f

        call    TerminateProcess
@@:

        cmp     ah, 5dh         ; check for unsupported 5d codes
        jnz     short @f
        cmp     al, 0ah
        jz      short @f
        jmp     LeaveDOSExtender
@@:

        mov     rcount,0        ;Default no remaining bytes to read/write
        mov     ccount,0        ;No bytes read or written yet

        cmp     ah,3Fh          ;If read
        jz      @f
        cmp     ah,40h          ;  or write,
        jnz     TransferLoop
@@:
        mov     cx,pmrg.xcx     ;  initialize remaining count = requested value
        mov     rcount,cx


; Start of loop for doing large read/write transfers

TransferLoop:

        call    dosentry        ;Do selector translations, data buffering


; Come here after entry register translations and data transfers are complete

        SwitchToRealMode        ;Switch back to real mode.  ds = es = rm dgroup
                                ;Stack is at same place in memory

; Set registers to possibly translated values and iret to real-mode DOS.
; DOS then irets to BackFromDOS.

        popa                    ;Set appropriate general register values

        pop     es
        pop     ds

        public  GoingToDOS

GoingToDOS:                     ;for debugging, etc.

        iret                    ;invoke real mode DOS

        assume  ds:NOTHING, es:NOTHING, ss:NOTHING


; Return here from real-mode interrupt handler (DOS)

        public  BackFromDOS

BackFromDOS:

        pushf                   ;Save return flags (to rmflags)
        cld                     ;  (better safe than sorry)

        push    cs              ;Push return cs:ip for multiple xfers
        push    offset BackFromDOS

        sub     sp,2*3          ;Bypass room for iret to interrupt handler
                                ; (to keep stack layout the same as on entry)

        push    ds              ;Save register set
        push    es
        pusha

        mov     ds,segDXData
        assume  ds:DGROUP


;  "push" iret frame for real mode int 21 rtn in case we need to do it again

        mov     ax,rmflags
        and     ax,not 4300h    ;Kill NT, TF, and IF
        mov     rmivfl,ax

        xor     ax,ax
        mov     es,ax
        mov     ax,word ptr es:[21h*4+2]
        mov     rmivcs,ax
        mov     ax,word ptr es:[21h*4]
        mov     rmivip,ax


; Switch back to protected mode

        SwitchToProtectedMode   ;Switch back to protected mode
        assume  ds:DGROUP,es:DGROUP

        FSTI                     ;Don't need ints disabled

        call    xfrflg          ;Transfer relevant return flags over to pm iret frame

        mov     ax,pmrg.xax     ;Recover AX from caller


; Perform any int-21 selector translations, data buffering

        call    dosexit


; Check for large xfers (Read File 3Fh, Write File 40h, some IOCTL 44h)

        cmp     rcount,0        ;Read/write more bytes?
        jz      TransferDone

        mov     cx,rmrg.xax     ;Maybe. cx = count transferred (if 3Fh or 40h)
        mov     ax,pmrg.xax     ;Restore entry code
        mov     rmrg.xax,ax

        cmp     ah,40h          ;Write?
        jnz     @f

        sub     rcount,cx       ;Yes. Written all originally requested?
        jz      TransferDone

        cmp     cx,rmrg.xcx     ;  No. Written all last specified?
        jz      @f              ;    Yes. Go do some more

        mov     ax,ccount       ;A large write has failed!  ccount has already
        sub     ax,rmrg.xcx     ;  been updated assuming success, back out the
        add     ax,cx                   ;  attempted xfer amount, and add in
        jmp     short TransferCount     ;  the actual, then split
@@:
        jmp     TransferLoop    ;Yep (or 3Fh or 44h). Do another xfer

TransferDone:
        mov     ax,ccount       ;Multiple count xfer?
        or      ax,ax
        jz      LeaveDOSExtender

TransferCount:
        mov     rmrg.xax,ax     ;Yes update return amount
        mov     ax,pmrg.xcx
        mov     rmrg.xcx,ax     ;Restore initial request count


; Restore possibly translated registers and to return to pm caller

        public  LeaveDOSExtender

LeaveDOSExtender:

        popa                    ;Restore possibly changed user registers

        mov     ss,pmusrss      ;Restore pm user stack
        mov     sp,pmusrsp
        assume  ss:NOTHING

        push    pmrg.xds        ;push user seg regs on user stack
        push    pmrg.xes

        dec     EntryFlag       ;dec nested entry flag - normal case is to jmp
        jnz     NotNested
                                ;If this was a nested DOS call (from
        push    cx              ;  a critical error handler), restore
        push    si              ;  the state for the prior DOS call
        push    di              ;  which is still in progress

        mov     cx,ds           ;make darn sure es -> DGROUP
        mov     es,cx

        cld                                     ;NOTE: we need to retreive
        mov     cx,ILENGTH                      ;  all current user registers
        mov     di,offset DGROUP:Ibegin         ;  before moving this data
        mov     si,offset DGROUP:Isave
        rep movsb

        pop     di
        pop     si
        pop     cx

NotNested:
        pop     es              ;restore user seg regs
        pop     ds
        assume  ds:NOTHING,es:NOTHING

        public  DOSXiret
DOSXiret:                       ;for debugging, etc.

        iret                    ;return to caller

PMIntrDos       endp


; -------------------------------------------------------
;   DOSENTRY    -- This function performs buffering and register
;       translation for entry into MS-DOS functions.
;
;   Input:      AX:  AX value at time of INT 21h
;   Output:
;   Errors:
;   Uses:

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP

dosentry:

        cmp     ah,26h          ;Create new PSP?
        jnz     @f
        mov     si,rmrg.xdx     ;yes, translate selector to paragraph
        call    gtpara
        mov     rmrg.xdx,ax
        return
@@:
        cmp     ah,53h          ;Set drive parameter block?
        jnz     @f
        push    ax
        mov     si,pmrg.xes     ;int 21h/53h has an extra parameter in ES:BP
        call    gtpara          ;  we change the selector to a segment, but
        mov     rmrg.xes,ax     ;  the segment had better already be in
        pop     ax              ;  conventional memory
        jmp     short dentr2b
@@:
        cmp     ah,50h          ;Set current PSP?
        jnz     dentr1
        mov     si,rmrg.xbx     ;Yes. Translate selector to paragraph
        call    gtpara
        mov     rmrg.xbx,ax
        return

dentr1: cmp     ah,55h          ;Duplicate PSP?
        jnz     dentr2
        mov     si,rmrg.xbx     ;Translate selector bx to paragraph
        call    gtpara
        mov     rmrg.xbx,ax
        mov     si,rmrg.xdx     ;  and dx also
        call    gtpara
        mov     rmrg.xdx,ax
        return

dentr2:
        cmp     ah,56h          ;Rename?
        jnz     dentr2a
        push    ax              ;rename has a second ASCIIZ buffer
        push    pmrg.xes        ;  pointed to by es:di -- move that
        pop     enxseg          ;  now, the ds:dx one below
        mov     ax,int21esdi
        call    gtarea          ;let the 'standard' gtarea/movdat
        mov     dx,enxseg       ;  routines take care of it
        call    movdat
        pop     ax
        jmp     short dentr2b

dentr2a:
        cmp     ah,5Fh          ;Get/Make Assign-List Entry?
        jne     dentr2a1
        call    net5Fenter      ;  Yes, may require extra buffering
        jmp     short dentr2b

dentr2a1:
        cmp     ah,29h          ; parse filename?
        jne     dentr2b

        push    ax
        push    pmrg.xes
        pop     enxseg
        mov     ax,int21pfn
        call    gtarea
        mov     dx,enxseg
        call    movdat
        pop      ax
;;        jmp     short dentr2b

dentr2b:
        call    GetEntryCd      ;ax = func entry code, di = ptr to entry cd

        or      ax,ax           ;Entry code specify something to do?
        rz

        cmp     byte ptr pmrg.xax+1,1Ah ;Store DTA?
        jnz     dentr3

        mov     pmdta,dx                ;  Yes. Save it for data returns
        push    pmrg.xds
        pop     pmdta+2
        jmp     short dentr4

dentr3: cmp     byte ptr pmrg.xax+1,4Bh ;EXEC program?
        callz   dosxec

; DENTR4 - enter with ax = entrycd/exitcd.  Translate ptr's for real-
; mode calls and transfer any data indicated.

dentr4: push    pmrg.xds
        pop     enxseg
        call    gtarea          ;Get es:di = area for transfer
        rz                      ;Something to xfer?
        mov     dx,enxseg       ;Yes. Fall thru to movdat

        errnz  <movdat-$>


; -------------------------------------------------------
;   MOVDAT      --  This routine performs the buffer transfer
;       for entry into or exit from an MS-DOS function.  The data
;       is copied from DX:SI to ES:DI.  The code in CX determines
;       the type of data being transferred, which is used to determine
;       the length.
;
;   Input:  DX:SI       - far pointer to source buffer
;           ES:DI       - far pointer to destination buffer
;           CX          - transfer length code
;   Output: none
;   Errors: none
;   Uses:   AX, BX, CS, SI, DI modified

        assume  ds:DGROUP,es:NOTHING,ss:DGROUP
        public  movdat

movdat:
        push    ds
        mov     bx,cx           ;Simple count?
        sub     bl,INFO
        jc      movda2
        cmp     bl,PALETTE-INFO ;Yes. Use pm es?
        jc      movda0
        mov     dx,pmrg.xes     ;Yes
movda0: mov     cl,mvcnt[bx]    ;cx = count
movda1: mov     ds,dx

if DEBUG   ;------------------------------------------------------------

        push    ax
        mov     ax,es
        lsl     ax,ax
        sub     ax,di
        jc      movbad
        cmp     ax,cx
        jnc     @f
movbad:
        Debug_Out "Movdat: copy beyond end of dest seg!"
@@:
        pop     ax

endif   ;DEBUG  --------------------------------------------------------

movd1a: rep     movsb           ;Move data
        pop     ds
        return

movda2: cmp     cl,CX$          ;Use pmrg.xcx?
        jnz     movda3
        mov     cx,rmrg.xcx     ;cx usually = pmrg.xcx, but in any event
                                ;  cx < CB_XFRBUF1
movd21: add     ccount,cx
        jmp     short movda1

movda3: mov     ah,0
        cmp     cl,ASCZ
        jz      movda4
        cmp     cl,DOL
        jnz     movda5
        mov     ah,"$"
movda4: mov     ds,dx
movd42: lodsb
        stosb
        cmp     al,ah
        jnz     movd42
        pop     ds
        return

movda5: cmp     cl,AX$  ;Use rmrg.xax?
        jnz     movda6
        mov     cx,rmrg.xax     ;Yes (only occurs for ah=3fh - read - on exit)
        jmp     short movd21

movda6:
        cmp     cl,FCB
        jnz     movda7
        mov     ds,dx
        mov     cl,byte ptr ds:[si]
        cmp     cl,0ffh                 ;standard or extended FCB?
        mov     cx,37                   ;standard FCB len
        jnz     movd1a
        mov     cx,44                   ;extended FCB len
        jmp     short movd1a

movda7:                         ;KYB remains
        pop     ds
        return


; -------------------------------------------------------
;   DOSEXIT     -- This function is called on exit from the MS-DOS
;       functions to perform any data buffering and register translation
;       needed.
;
;   Input:      AX: AX value at time of INT 21h
;   Output:
;   Errors:
;   Uses:

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  dosexit

dosexit:
        cmp     ah,51h          ;Get current PSP?
        jz      dose0a
        cmp     ah,62h          ;Get PSP address?
        jnz     dose00
dose0a:
        mov     ax,rmrg.xbx     ;Yes. Translate segment to selector
        mov     bx,STD_DATA
        call    ParaToLDTSelector
        mov     rmrg.xbx,ax
        return

dose00: cmp     ah,2fh          ;Get current DTA?
        jnz     dose01
        mov     ax,pmdta        ;Yes. Load PM DTA into caller's registers
        mov     rmrg.xbx,ax
        mov     ax,pmdta+2
        verr    ax              ; if the dta selector is no longer valid,
        jz      @f              ; return the NULL selector instead (so we
        xor     ax,ax           ; don't GP fault in DOSX).
@@:     mov     pmrg.xes,ax
        return

dose01: cmp     ah,55h          ;Duplicate PSP?
        jnz     dosex1
        mov     ax,rmrg.xbx     ;Yes, translate segments to selectors
        mov     bx,STD_DATA
        call    ParaToLDTSelector
        mov     rmrg.xbx,ax
        mov     ax,rmrg.xdx
        mov     bx,STD_DATA
        call    ParaToLDTSelector
        mov     rmrg.xdx,ax
        return

dosex1: cmp     ah,56h          ;Rename?
        jnz     dosex2
        push    pmrg.xdi        ;Rename has a second pointer in ES:DI--we
        pop     rmrg.xdi        ;  need to restore DI here, DX below
        jmp     short dosex3

dosex2: cmp     ah,5Fh          ;Get/Make Assign-List Entry?
        callz   net5Fexit       ;  Yes, extra buffering may be needed

dosex3:
        call    GetEntryCd      ;ax=func entry code, di=ptr to entry code

        call    rstreg          ;Restore entry register?
        jz      dosex6

        cmp     byte ptr pmrg.xax+1,29h   ;Yes, Parse filename?
        jnz     dosex4

        add     ax,rmrg.xsi                   ;Yes. Increment past string
        sub     ax,offset DGROUP:rgbXfrBuf0   ;     that was parsed
        push    pmrg.xdi
        pop     rmrg.xdi                ;Restore pm di (for es:di ptr)

dosex4: mov     word ptr rmrg[si],ax    ;Restore register

        cmp     byte ptr pmrg.xax+1,4Bh ;EXEC program
        jnz     dosex6

        push    di
        mov     di,pmrg.xbx         ;Yes, restore bx too (dx restored above)
        mov     rmrg.xbx,di         ;es and ds are restored automatically
        cmp     byte ptr pmrg.xax,1 ;INT-21/4b01h (undocumented debug)?
        jnz     @f

        mov     si,npXfrBuf1       ;Yes. Pass back user ss:sp and cs:ip
        lea     si,[si].xsssp
        lea     di,[di].xsssp
        mov     es,pmrg.xes
        movsw                   ;Move ss:sp
        movsw
        movsw                   ;Move cs:ip
        movsw
@@:
        pop     di

dosex6: mov     ax,cs:[di+2]    ;Exit xfer?
        or      ax,ax
        rz

dosex7: call    CheckStatus     ;Check the DOS return status to see if the
        rnz                     ;  data should be transfered back to PM

        mov     cx,ax           ;Is a pointer being returned? (no data
        and     cl,0fh          ;  transfer)
        cmp     cl,PTR$
        jnz     dosex8

        shr     al,4            ;  yes, isolate pointer type
        mov     si,offset rmrg.xds
        mov     di,offset pmrg.xds
        cmp     al,DSBX
        jz      dosex7a
ifdef DBCS                      ; for function 63h (Get Lead Byte)
        cmp     al,DSSI
        jz      dosex7a
endif ; DBCS
        mov     si,offset rmrg.xes
        mov     di,offset pmrg.xes
dosex7a:
        mov     ax,[si]         ;  get a selector for the segment, and
        mov     bx,STD_DATA     ;  setup to return it to caller
        call    ParaToLDTSelector
        mov     [di],ax
        return

dosex8:
        push    pmrg.xds
        pop     enxseg
        call    gtarea          ;Get area for xfer from PM to DOS
        rz                      ;Something to move?

        xchg    si,di           ;Turn pointers around
        mov     dx,ds           ;dx:si -> DOS xfer area in dgroup
        mov     es,enxseg       ;es:di -> PM-caller data area
        jmp     movdat          ;Yes

; -------------------------------------------------------
;   DosExitCall -- Special processing for DOS exit call service (Int 21h/00h)
;
;       This procedure handles the obsolete Int 21h/00h terminate process
;       call in a special slimy way for Windows.  Instead of doing a 00h
;       DOS call in real mode, it hacks up the parent's PSP and does a 4Ch
;       that causes control to return to the extender, who then RETURNS TO
;       THE CALLER!!!  The caller must then do appropriate set PSP calls, etc.
;       This was implemented so pMode Windows kernel could have DOS clean up
;       after a Windows app terminates, but still have kernel get control
;       back.
;
;       Note:   This code assumes that the Parent PID field contains a
;               SELECTOR!
;
;       Note^2: If for some reason it's the DOS Extender's child that's 1800doing
;               the terminate call, we let it go through normally.
;
;   Input:      none
;   Output:     CY set if exit call processed by this routine, clear otherwise
;   Errors:
;   Uses:       none

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  DosExitCall

DosExitCall     proc    near

        push    ax
        push    bx
        push    dx
        push    es

        SwitchToRealMode                ;much of this is easier in real mode
        FSTI                             ;allow interrupts

        mov     ah,51h                  ;get PSP of current task
        pushf
        FCLI
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset dec_10)
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

dec_10: cmp     bx,segPSPChild          ;is this our child terminating?
        jnz     @f                      ;if not, go process the call ourselves
        jmp     decTermChild            ;  yes...
@@:
        FCLI                             ;we want to preserve the current
        xor     ax,ax                   ;  rMode Int 24h handler across this
        mov     es,ax                   ;  exit call (the terminating PSP
        mov     ax,es:[24h*4]           ;  has the pMode handler address).
        mov     dx,es:[24h*4+2]         ;  So get the current Int 24h handler
        FSTI                             ;  address from the rMode IDT.

        mov     es,bx                   ;address terminating PSP
        assume  es:PSPSEG

        mov     word ptr [lpfnInt24],ax         ;point PSP to same Int 24h
        mov     word ptr [lpfnInt24+2],dx       ;  handler

        mov     ax,offset DXCODE:decTermHandler ;point PSP to our termination
        mov     word ptr [lpfnParent],ax        ;  handler
        mov     word ptr [lpfnParent+2],cs

        push    es
        mov     ax,segParentPSP         ;Windows has the PSP's parent
        push    ax                      ;  field as a selector, we need the seg
        mov     dx, [segEnviron]
        push    dx
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP

        FSTI
        pop     ax                          ;get selector for environment
        or      ax,ax                       ; NULL selector (krnl386 does this)
        jnz     @f
        xor     bx,bx                       ; zero environment segment
        jmp     dec_HaveEnvSeg
@@:
        call    GetSegmentAddress
        test    bx,0fff0h                   ; >1mb?
        jz      @f                          ;   no
        xor     bx,bx                       ;   yes, zero environment segment
        xor     dx,dx
@@:
        shr     dx, 4
        shl     bx, 12
        or      bx, dx                      ;seg of environment

dec_HaveEnvSeg:
        pop     ax                          ;get parent psp off stack
        push    bx                          ;save seg of environment

        call    GetSegmentAddress       ;returns BX:DX = lma of segment
        shr     dx,4
        shl     bx,12
        or      bx,dx                   ;bx now = seg of parent psp

        SwitchToRealMode                ;back to the shadows again...
        FSTI
        pop     cx                          ;seg of environment

        pop     dx                      ;terminating PSP segment from stack
        mov     es,bx                   ;address the parent's PSP
        assume  es:PSPSEG

        mov     ax,sp
        sub     ax,12*2                 ;some magic for DOS
        mov     word ptr [lpStack],ax   ;set our stack in parent's PSP
        mov     word ptr [lpStack+2],ss

        mov     es,dx                   ;(re)address terminating PSP
        assume  es:PSPSEG
        mov     [segEnviron], cx

        mov     segParentPSP,bx         ;real DOS doesn't like selectors in
                                        ;  parent PSP field, zap it to segment

        mov     ax,pmrg.xax             ;terminate the process
        mov     ah,4Ch                  ;  with a 4Ch DOS call
        pushf
        FCLI
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     word ptr [bp + 6],offset decTermHandler
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf
        assume  ds:NOTHING,es:NOTHING,ss:NOTHING        ;play it safe

decTermHandler:                         ;should return back here

        push    ss
        pop     ds

        SwitchToProtectedMode           ;back to pMode
        assume  ds:DGROUP,es:DGROUP

        FSTI

        les     bx,dword ptr pmusrsp            ;es:bx -> ip cs flag
        and     byte ptr es:[bx+2*2],not 1      ;clear CY in caller's flags

        stc                             ;exit call has been processed

dec90:
        pop     es
        pop     dx
        pop     bx
        pop     ax

        ret

EndHighSegment

BeginLowSegment

decTermChild:

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP

        FSTI
        clc

        jmp     short dec90

DosExitCall     endp


; -------------------------------------------------------
;   net5Fenter  -- Additional entry processing for INT 21h/5Fh
;       functions.
;
;       INT 21h/5Fh subfunctions 2, 3, and 5 have two buffers of data to
;       transfer.  The normal DOSENTRY processing only does one, so we
;       setup the other buffer here.

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  net5Fenter

net5Fenter      proc    near

        cmp     al,2                    ;This routine only works on
        rc                              ;  subfunctions 2, 3, and 5
        cmp     al,4
        rz
        cmp     al,6
        rnc

        push    ax
        mov     ax,int21esdi            ;entry code for INT 21h/5Fh extra buff
        call    gtarea                  ;let gtarea set it up
        pop     ax

        cmp     al,3                    ;Make redirection function?
        rnz

; 5F/03 needs a buffer copied down to A1, but it's non standard in that
; the buffer contains two (count'em 2) asciiz strings

        push    ax
        push    cx
        push    ds

        mov     ds,pmrg.xes             ;user's ES:DI -> buffer, gtarea sets
        xor     ah,ah                   ;  up our si to have user's di
        mov     cl,2

@@:     lodsb                           ;copy one asciiz string
        stosb
        cmp     al,ah
        jnz     @b

        dec     cl                      ;   and then the other
        jnz     @b

        pop     ds
        pop     cx
        pop     ax
        return

net5Fenter      endp


; -------------------------------------------------------
;   net5Fexit  -- Additional exit processing for INT 21h/5Fh
;       functions.
;
;       INT 21h/5Fh subfunctions 2, 3, & 5 have 2 buffers of data to transfer.
;       The normal DOSENTRY processing only does one, so do the other
;       buffer here.

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  net5Fexit

net5Fexit       proc    near

        cmp     al,2                    ;This routine only works on
        rc                              ;  subfunctions 2, 3 and 5
        cmp     al,4
        rz
        cmp     al,6
        rnc

        push    pmrg.xdi                ;Restore protected mode DI register
        pop     rmrg.xdi

        cmp     al,2                    ;Get redirection function?
        jz      @f
        cmp     al,5
        rnz
@@:

; 5F/02 & 05 need a buffer copied from A1

        test    byte ptr rmflags,1      ;Success? (carry flag)
        rnz                             ;  No, don't transfer anything

        push    ax

        mov     ax,int21esdi+2          ;exit code for int 21/5F extra buffer
        push    pmrg.xes
        pop     enxseg
        call    gtarea                  ;let gtarea setup the move
        xchg    si,di
        mov     dx,ds
        mov     es,enxseg
        call    movdat                  ;  and let movdat move it

        pop     ax
        return

net5Fexit       endp


; -------------------------------------------------------
;   RSTREG      -- This function sets up to restore the original
;       protected-mode registers.  This cleans up after register
;       translations performed when going into the or returning
;       from an MS-DOS call.  On entry, AX contains the entry code
;       value from the entry/exit operations table.  If this code
;       implies that a register needs to be restored this function
;       will return with NZ true and AX = original register value
;       and SI pointing to the appropriate location in the PMRG array.
;       If no register needs to be restored, return with Z true.
;
;   Input:  AX      - entry code value
;   Output: NZ true if register needs to be restores
;           AX      - register value to restore
;           SI      - pointer into PMRG to the register image
;           ZR true if no restoration needed
;   Errors: none
;   Uses:   AX, SI modified

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  rstreg

rstreg: or      ax,ax
        rz

        shr     ax,3
        and     ax,1Eh
        rz

        cmp     al,2*DTA        ;DTA?
        rz

        xchg    si,ax           ;No. Restore appropriate register, e.g., dx
        mov     si,regoffs[si-2]
        mov     ax,word ptr pmrg[si]
        return


; -------------------------------------------------------
;   GTAREA      -- This function examines the entry code/exit code
;       parameter and determines if any data transfer needs to be
;       performed.  If so, it sets up pointers and length codes for
;       the transfer.
;       There are two transfer buffers used.  The A0 buffer is 60h bytes
;       long and the A1 buffer is CB_XFRBUF1 bytes (about 4k) long.
;
;   Input:  AX      - entry code/exit code
;   Output: NZ true if something needs to be transferred
;           SI      - offset of source pointer
;           DI      - offset of destination pointer
;           ENXSEG  - segment for caller's buffer
;                     (source on entry, destination on exit)
;           CX      - transfer length/type code
;   Errors: none
;   Uses:   AX, CX, SI, DI, ES modified
;           ENXSEG modified

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  gtarea

gtarea:
        test    ah,RP           ;Real/PM xfer (ah = 3f/40)?
        jz      gtare2

        mov     si,pmrg.xds     ;Yes. *si:pmrg.xdx = pm caller's xfer area
        and     si,SELECTOR_INDEX
        test    ah,EX           ;Exit call?
        jz      gtare1
        push    es
        push    ax
        mov     es,selGDT
        mov     al,es:[si].adrBaseHigh
        mov     ah,es:[si].adrbBaseHi386
        test    ax,0FFF0h                   ; check for transfer to extended
                                            ; memory
        pop     ax
        pop     es
        jnz     @f
        jmp     gtar54
@@:
        mov     cx,rmrg.xax     ;Yes. cx = amount read/written
        sub     rcount,cx       ;Update remaining count
        cmp     cx,rmrg.xcx     ;All that was requested?
        jnc     gtare3
        mov     rcount,0        ;No: done
        jmp     short gtare3

gtare1: push    ax              ;Read/Write entry
        mov     ax,si
        mov     dx,pmrg.xdx     ;ax:dx = selector:offset of buffer
        call    SelOff2SegOff   ;translate to seg:off if in conventional mem
        jnz     gtar12
        mov     rmrg.xds,ax     ;store corresponding paragraph
        mov     rmrg.xdx,dx     ;  and offset
        pop     ax
        jmp     short gtar54    ;No more setup needed

gtar12: pop     ax              ;XRAM/RRAM read/write entry
        mov     cx,rcount       ;Try to xfer remaining amount
        cmp     cx,CB_XFRBUF1   ;Too much to fit in buffer?
        jbe     gtar14
        mov     cx,CB_XFRBUF1   ;Yes, only transfer a buffer size
gtar14: mov     rmrg.xcx,cx
        jmp     short gtare3

gtare2: test    ah,A0+A1        ;xfer area?
        jz      gtare4

gtare3: mov     di,offset DGROUP:rgbXfrBuf0     ;Point at small buffer (90h bytes)
        test    ah,1            ;Area 0 (small area) ?
        jnz     gtare4
        mov     di,npXfrBuf1       ;No. Point at large buffer (4K)

gtare4: push    ax              ;Store ptr to communication area for DOS
        mov     si,di
        shr     al,3            ;Get al = 2 * data ptr type, e.g., DSDX (ds:dx)
        and     al,1Eh          ;al = word offset for data ptr type
        jz      gtare7
        cmp     al,2*DTA        ;DOS Data Transfer Area?
        jnz     gtare5
        mov     si,pmdta        ;Yes, load DTA offset
        push    pmdta+2         ;and the segment
        pop     enxseg
        jmp     short gtare7

gtare5: cmp     al,2*ES$
        jnz     gtare6
        test    ah,80h          ;INT-21 49/4A. Ignore exit call
        mov     ax,0
        jnz     gtar52
        mov     si,pmrg.xes     ;Entry call. si = RAM xfer selector
        call    gtpara          ;Get paragraph given by [si].gdt
        jnz     gtar52          ;XRAM?
        mov     rmrg.xes,ax     ;No, store RRAM paragraph
gtar52: pop     cx              ;Kill saved ptr

gtar54: xor     cx,cx   ;RZ with zero count, i.e., no RM/PM xfer needed
        mov     rcount,cx
        return

gtare6: test    ah,80h          ;Entry?
        cbw
        push    ax
        xchg    di,ax           ;Save real-mode area offset
        mov     di,regoffs[di-2]        ;di = offset of saved register value
        mov     si,word ptr pmrg[di]    ;si = saved value
        jnz     gtar62
        mov     word ptr rmrg[di],ax    ;Entry. Store real-mode area offset
        cmp     byte ptr pmrg.xax+1,29h ;Parse filename?
        jnz     gtar62
        mov     cx,npXfrBuf1       ;Yes. Use npXfrBuf1 for FCB info
        mov     word ptr rmrg.xdi,cx
gtar62: xchg    di,ax           ;Restore di = real-mode area offset

        pop     ax
        cmp     ax,ESDI*2
        jne     gtare7

        push    pmrg.xes
        pop     enxseg

gtare7: pop     cx              ;Recover entrycd/exitcd
        and     cx,0Fh          ;RNZ if something to xfer
        rz                      ;No

        mov     dx,pmrg.xds     ;Xfer needed. dx = original XRAM data selector
        cmp     cl,AX$          ;Use rmrg.xax?
        jz      gtare8
        cmp     cl,CX$          ;Use pmrg.xcx?
        rnz                     ;No, just RNZ


;Return dx:0 = pmrg.xds:si+ccount, where dx is a scratch selector
;and si = 0.  This ensures that dx:si can address a bufferful of bytes
;without overflowing si (sort of like a huge ptr).

gtare8: xchg    ax,si           ;ax = original offset
        mov     si,dx           ;si = pmrg.xds (PM data selector)
        and     si,SELECTOR_INDEX
        xor     dx,dx           ;dxax = original offset in 32-bit form
        add     ax,ccount
        adc     dx,0            ;dxax += ccount (current xfer count)
        push    es
        mov     es,selGDT       ;Point at GDT
        add     ax,es:[si].adrBaseLow
        adc     dl,es:[si].adrBaseHigh  ;dxax absolute XRAM address
        adc     dh,es:[si].adrbBaseHi386
        mov     si,SEL_DOSSCR
        cCall   NSetSegmentDscr,<si,dx,ax,0,0ffffh,STD_DATA>
        pop     es

; original code... changed to line below to fix file read problem.
; may cause other bugs.....
;       mov     dx,si           ;Return scratch selector with 0 offset since
;
        or      si,SELECTOR_TI
        mov     enxseg,si       ;Return scratch selector with 0 offset since
        xor     si,si           ; it points directly to the transfer location
        or      sp,sp           ;RNZ to indicate xfer needed
        return

; -------------------------------------------------------
;   GetEntryCd  --  This routine puts the entry code for the
;                   DOS function into ax.
;
;   Input:  AH      - MS-DOS function number
;   Output: AX      - entry code for function
;           DI      - address of entry code returned
;
;   Errors: none
;   Uses:   AX, DI modified

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  GetEntryCd

GetEntryCd      proc    near

        push    bx

        cmp     ah,MaxInt21     ;Check for unsupported DOS call
        jbe     @f
        mov     di,offset DXPMCODE:Unsupported
        jmp     gec90
@@:
        mov     di,offset DXPMCODE:pmrmxfr

ifdef DBCS
        cmp     ah,63h          ;Get Lead Byte Table?
        jnz     gec10

if DEBUG   ;------------------------------------------------------------

        cmp     al,2
        jbe     gec15

        Debug_Out "Int 21h/63h Unsupported Function (#AX)"
        jmp     short gec80
gec15:

endif   ;DEBUG  --------------------------------------------------------

        cmp     al,0            ;Int 21/63/00 is special
        jne     gec80

        mov     di,offset DXPMCODE:int2163
        jmp     short gec90
gec10:
ENDIF ; DBCS

gec20:  cmp     ah,5Eh          ;Network Machine Name/Printer Setup Str?
        jnz     gec40

if DEBUG   ;------------------------------------------------------------

        cmp     al,3
        jna     gec25

        Debug_Out "Int 21h/5Eh Unsupported Function (#AX)"
        jmp     short gec80
gec25:

endif   ;DEBUG  --------------------------------------------------------

        cmp     al,3            ;Int 21-5E/00-03 are special
        ja      gec80

        mov     bl,al
        mov     di,offset DXPMCODE:int215E
        jmp     short gec85


gec40:  cmp     ah,5Fh          ;Get/Make Assign-List Entry?
        jnz     gec80

if DEBUG   ;------------------------------------------------------------

        cmp     al,5
        ja      @f
        cmp     al,2
        jnb     gec45
@@:
        cmp     al,30h          ;Register based.  Get Redirector version
                                ;used by Lanman Enhanced.
        je      gec80
        Debug_Out "Int 21h/5Fh Unsupported Function (#AX)"
        jmp     short gec80
gec45:

endif   ;DEBUG  --------------------------------------------------------

        cmp     al,2            ;Int 21/5F/02-05 are special
        jb      gec80
        cmp     al,5
        ja      gec80

        mov     bl,al
        sub     bl,2
        mov     di,offset DXPMCODE:int215F02
        jmp     short gec85


gec80:  mov     bl,ah
gec85:  xor     bh,bh
        shl     bx,2

        add     di,bx                   ;Address of entry code
gec90:
        mov     ax,word ptr cs:[di]     ;The entry code itself
        pop     bx
        return

GetEntryCd      endp


; -------------------------------------------------------
;   CheckStatus --  This routine determines if data should be copied
;                   back to protect mode by checking the DOS function
;                   return status.
;
;   Input:  none
;   Output: NZ    - if data should NOT be copied, Z otherwise
;
;   Errors: none
;   Uses:   none

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  CheckStatus

CheckStatus     proc    near

; For now, only worry about the functions that return variable length
; results, like ASCIIZ strings.

        cmp     byte ptr pmrg.xax+1,32h
        jz      @f
        cmp     byte ptr pmrg.xax+1,47h         ;Get Current Directory
        jz      @f
        cmp     byte ptr pmrg.xax+1,5Ah         ;Create Temporary File
        jz      @f
        cmp     byte ptr pmrg.xax+1,5Eh         ;Get Machine Name/Printer Str
        jc      cks90
        cmp     byte ptr pmrg.xax+1,5Fh         ;Get Redirection Entry
        ja      cks90
@@:
        test    byte ptr rmflags,1      ;Carry set?
        return

cks90:  cmp     al,al                   ;Assume status is okay (or doesn't
        return                          ;  matter) -- set Z and return

CheckStatus     endp


; -------------------------------------------------------
;   DOSXEC      -- This function performs the transfer of the
;       DOS exec parameter block on entry to DOS function 4Bh.
;
; transfer int-21 ah = 4b0x EXEC block and associated strings
; to Area 1.  This area is laid out partly analogously to a PSP as follows:
;
; 0-1f    EXEC block defined according to the execblk struc above
; 20-2f   FCB1
; 30-3f   FCB2
; 40-bf   command line
;
; cx, si, di changed.

        assume  ds:DGROUP,es:DGROUP,ss:DGROUP
        public  dosxec

dosxec:
        push    ax              ;Save entrcd code
        push    bx
        push    dx

        mov     cx,10h          ;Setup parameter block.  Xfer pm user block first
        mov     bx,npXfrBuf1    ;Point at larger buffer
        mov     di,bx
        mov     dx,segDXDataPM
        mov     rmrg.xbx,di     ;int-21 4b0x expects es:bx -> exec block
        mov     si,pmrg.xbx     ;npXfrBuf1:0 - 1f (xtra room for undocumented)
        mov     ds,pmrg.xes
        rep     movsw           ;copy caller's exec param block to our buffer

; Copy FCB1 down if the user has specified one.

dsxc20: mov     ax,word ptr es:[bx].fcb1ptr
        cmp     ax,0FFFFh
        jz      dsxc22
        or      ax,word ptr es:[bx].fcb1ptr+2
        jz      dsxc22

        lds     si,es:[bx].fcb1ptr      ;Get pointer to FCB1
        mov     word ptr es:[bx].fcb1ptr,di      ;store new pointer in the copy of the
        mov     word ptr es:[bx].fcb1ptr+2,dx    ; exec block we are building
        mov     cl,8                    ;copy FCB1 down to our buffer
        rep     movsw
        jmp     short dsxc24
dsxc22: add     di,10h

; Copy FCB2 down if the user has specified one.

dsxc24: mov     ax,word ptr es:[bx].fcb2ptr
        cmp     ax,0FFFFh
        jz      dsxc26
        or      ax,word ptr es:[bx].fcb2ptr+2
        jz      dsxc26

        lds     si,es:[bx].fcb2ptr      ;Move FCB2
        mov     word ptr es:[bx].fcb2ptr,di
        mov     word ptr es:[bx].fcb2ptr+2,dx
        mov     cl,8
        rep     movsw
        jmp     short dsxc30
dsxc26: add     di,10h

; Copy the command line down.

dsxc30: lds     si,es:[bx].cmdptr       ;Move command line
        mov     word ptr es:[bx].cmdptr,di
        mov     word ptr es:[bx].cmdptr+2,dx
        mov     cl,[si]
        inc     cx              ;Include count
        inc     cx              ;Include final CR not included in count
        rep     movsb

; Now, we need to set up the enviroment table to be passed to the
; child program.

        mov     di,bx           ;di = npXfrBuf1
        mov     dx,es:[di]      ;Setup desired environment
        or      dx,dx           ;Use parent's environment?
        jnz     dosxegotenv

; pick up the environment segment from the current PDB. It's a selector,
; so it has to be translated.
        push    bx
        push    di
        push    es
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax

        SwitchToRealMode                    ;much of this is easier in real mode

        mov     ah,51h                      ;get PSP of current task
        pushf
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset dosxeret)
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf
dosxeret:
        assume  es:PSPSEG
        mov     es, bx                      ;current PSP
        mov     dx, es:[segEnviron]         ;get environment (currently selector)
        push    dx                          ;save over call (bugbug is this needed?)
        SwitchToProtectedMode
        pop     dx                          ;bugbug is this needed?

        pop     es
        pop     di
        pop     bx


dosxegotenv:
        xor     si,si           ;No. Setup to copy desired environment down
        mov     ds,dx           ;ds = dx has caller's selector. Use 0 offset
        add     di,100h
        shr     di,4            ;Convert offset to paragraph
        mov     dx,segDXDataPM
        add     dx,di           ;dx = absolute paragraph within larger buffer
        shl     di,4            ;Convert back (with low nibble cleared)
        mov     cx,CB_XFRBUF1   ;Max room available for environment
        sub     cx,100h

dosxe2: lodsw                   ;Copy environment down
        stosw
        or      ax,ax
        jz      dosxe4
        dec     si              ;Check every byte offset in environment for double 0
        dec     di
        loop    dosxe2
        xor     dx,dx           ;Environment too large for buffer: use parent's
                                ;Issue error message? Program might run with parent's
                                ; and not with desired monster environment
dosxe4: push    es              ;Fix up parameter block entry
        pop     ds              ;ds:dgroup
        mov     [bx].evrnmt,dx

        pop     dx
        pop     bx
        pop     ax              ;Restore entrcd code
        return


; -------------------------------------------------------
;   XFRFLG      -- This function will transfer the relevant real-mode
;       flags to the protected mode IRET return information on the
;       stack for returning to the protected mode caller.
;
;   Input:
;   Output:
;   Errors:
;   Uses:   AX, CX, DI modified

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  xfrflg

xfrflg: push    es
        les     di,dword ptr pmusrsp    ;es:[di] = ip cs fl (assume 80286)
        mov     ax,rmflags
        mov     cx,es:[di+2*2]          ;Get pm user entry flags
        and     ch,not 19h              ;Only allow real-mode program to
        and     ah,18h                  ; change OF and DF in high byte of flags
        or      ah,ch
        mov     es:[di+2*2],ax
        pop     es
        return

; -------------------------------------------------------
        subttl      Handlers for Special Case Dos Functions
        page
; -------------------------------------------------------
;       HANDLERS FOR SPECIAL CASE DOS FUNCTIONS
; -------------------------------------------------------

; -------------------------------------------------------
;   Terminate process -- This routine replaces the apps
;       termination vector in the PSP with ours.  This allows
;       us to clean up the dos extender.
;
;   Entry: nothing
;   Exit: nothing
;   Uses: none
;
        assume  ds:dgroup,es:nothing
        public TerminateProcess
TerminateProcess proc near
        pusha
        push    es
        ;
        ; Get the childs PSP (bugbug do we need to get the current psp?)
        ;

        SwitchToRealMode

        mov     ah,51h
        pushf
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],offset tp_10
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

tp_10:  FSTI

        ;
        ; Change the termination vector to point to the dos extender
        ;
        mov     es,bx
        mov     bx,es:[0ah]
        mov     ax,es:[0ch]
        mov     cx,offset ChildTerminationHandler
        mov     es:[0ah],cx
        mov     cx,segDXCode
        mov     es:[0ch],cx

        ;
        ; Save the old termination vector for restoration later
        ;
        mov     cx,segCurrentHostData
        mov     es,cx
        mov     word ptr es:[HdPspTerminate],bx
        mov     word ptr es:[HdPspTerminate+2],ax

        SwitchToProtectedMode

        pop     es
        popa
        ret

TerminateProcess endp

DXPMCODE  ends

;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxmmgr.asm ===
PAGE    ,132
        TITLE   DXMMGR    - Dos Extender Memory Management Routines

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXMMGR.ASM      -   Dos Extender Memory Manager         *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains routines for maintaining a dynamic     *
;*  memory heap in extended memory for use in the Dos Extender. *
;*                                                              *
;*  There are two kinds of objects in the memory heap.  There   *
;*  are block headers and data blocks.  The block headers are   *
;*  each 16 bytes long, and are organized in a doubly linked    *
;*  list.  There is a segment descriptor in the global          *
;*  descriptor table for each block header, with each header    *
;*  containing the selectors for the next and previous block    *
;*  to form the list.  Block headers can either control a free  *
;*  block or they can control a data block.  In either case,    *
;*  the block immediately follows the header in memory, and     *
;*  the header contains a field that gives its size.  Free      *
;*  blocks do not have a descriptor in the global descriptor    *
;*  table, but in use data blocks do.  In the case where the    *
;*  in use data block is larger than 64k, there will be a       *
;*  contiguous range of selectors for the block.  The block     *
;*  header contains a field giving the initial selector for     *
;*  the data block for in use blocks.                           *
;*                                                              *
;*  A special type of free block serve as sentinels. They mark  *
;*  start and end of each physical block of memory available to *
;*  the memory manager. They are identified by the reserved     *
;*  value of 0FFFE (start sentinel) and 0FFFF (end sentinel) in *
;*  the selBlkOwner field. Unlike other blocks, they may not be *
;*  moved without appeal to some higher level of memory         *
;*  allocation.                                                 *
;*                                                              *
;*  Except for a pair of sentinels, a pair of blocks are        *
;*  contiguous in memory if and only if their headers are       *
;*  adjacent in the header chain.                               *
;*                                                              *
;*  The blocks at the start and end of the header chain are     *
;*  sentinals. Their selectors are stored in global variables.  *
;*  The start and end of the block header chain are identified  *
;*  by NULL (0) pointers in the Next and Previous pointer fields*
;*  respectively.                                               *
;*                                                              *
;****************************************************************
;*  Naming Conventions Used:                                    *
;*                                                              *
;*  The following hungarian prefixes are used in this module:   *
;*      lp      - far pointer (selector:offset)                 *
;*      bp      - linear byte pointer (32 bit byte offset from  *
;*                  the beginning of memory)                    *
;*      p       - near pointer (16 bit offset)                  *
;*      sel     - protected mode segment selector               *
;*      seg     - real mode paragraph address                   *
;*      cb      - count of bytes                                *
;*      id      - generic byte that contains an ID code         *
;*      hmem    - handle to XMS extended memory block           *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  11/28/90 amitc    IntLowHeap allocates memory from Switcher *
;*                    if it can.                                *
;*                                                              *
;*  08/08/90 earleh   DOSX and client privilege ring determined *
;*                    by equate in pmdefs.inc                   *
;*  05/09/90 jimmat   Started VCPI changes.                     *
;*  05/09/90 jimmat   Incorporated bug fix from CodeView folks, *
;*                    changes marked with [01]                  *
;*  06/23/89 jimmat:  Added init of variable with heap handle   *
;*  04/17/89 jimmat:  Added routines for special low memory     *
;*                    heap for use by network mapping           *
;*  03/28/89 jimmat:  Incorporated bug fixes from GeneA         *
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*          medium model                                        *
;*  12/07/88 (GeneA): moved SetupHimemDriver to dxinit.asm      *
;*  08/30/88 (GeneA):   created                                 *
;*                                                              *
;****************************************************************

.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

include gendefs.inc
include segdefs.inc
include pmdefs.inc
include dpmi.inc

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------



; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   XMScontrol:FAR

pmxmssvc macro   fcn
        ifnb    <fcn>
        mov     ah, fcn
        endif
        call    XMScontrol
endm

        extrn   FreeSelector:NEAR
        extrn   FreeSelectorBlock:NEAR
        extrn   AllocateSelector:NEAR
        extrn   AllocateSelectorBlock:NEAR
        extrn   GetSegmentAddress:NEAR
        extrn   SetSegmentAddress:NEAR
        extrn   DupSegmentDscr:NEAR
externFP        NSetSegmentDscr
        extrn   RemoveFreeDescriptor:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   EnterRealMode:NEAR
        extrn   MoveMemBlock:NEAR
ifdef WOW_x86
externNP        NSetSegmentAccess
externNP        NSetSegmentBase
externNP        NSetSegmentLimit
endif

DXDATA  segment

        extrn   selPSPChild:WORD
        extrn   selGDT:WORD
        extrn   bpGDT:FWORD

ifdef WOW_x86
        extrn   FastBop:fword
endif
DXDATA  ends

; -------------------------------------------------------
;           DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

DXDATA  segment

; Minimum xmem allocation in K
;       Note: This value MUST be a power of 2!!!
;       Note: We will allocate a smaller block if only smaller blocks
;             are available from xms
XMEM_MIN_ALLOC equ 256

        extrn   lpfnXmsFunc:DWORD
;
; These variables control access to the extended memory heap.

        public  cKbInitialHeapSize
cKbInitialHeapSize dw   -1      ; Optional specification for first block
                                ; of extended memory in KB.

        public  dsegCurrent
dsegCurrent     dw      0       ; Paragraph count if the current block comes from DOS

        public  hmemHeap
hmemHeap        dw      ?       ;XMS memory manager handle to the memory
                                ; block containing the heap
bpHeapStart     dd      ?       ;byte address of start of heap
                                ; (points to block header of first heap block)
bpHeapEnd       dd      ?       ;byte address of end of heap
                                ; (points to block header of last heap block)
cbHeapMove      dd      ?       ;number of bytes by which a subheap moved

        public  cbHeapSize,selLowHeapStart,selHiHeapStart,selHeapStart
cbHeapSize      dd      ?       ;number of bytes in the heap

selHeapStart    dw      ?       ;selector for the sentinel block at the
                                ; start of the heap list
bpCurTop        dd      0       ;current top of compacted heap
                                ; (used during heap compaction)

cbHeapBlkMax    dd      ?       ;size of largest free block seen while
                                ; searching the heap

cbHeapFreeSpace dd      ?       ;total free space in the heap

selHiHeapStart  dw      ?       ;selector for the sentinel block at the start
                                ; of the higm memory heap
selLowHeapStart dw      ?       ;selector for the sentinel block at the start
                                ; of the special low heap
segLowHeap      dw      ?       ;segment address of low memory heap
selLowHeapEnd   dw      ?       ;selector for the sentinel block at the end
                                ; of the special low heap
fDosErr         db      ?

        public  hmem_XMS_Table,hmem_XMS_Count

hmem_XMS_Table          dw      CXMSBLOCKSDX    DUP(0)
hmem_XMS_Count          dw      0

        public  NoAsyncSwitching

NoAsyncSwitching        db      0       ;0=> async switching allowed

        public LowMemAllocFn,LowMemFreeFn

LowMemAllocFn   dd 0
LowMemFreeFn    dd 0

DXDATA  ends

; -------------------------------------------------------
;       MISCELLANEOUS DATA STRUCTURE DECLARATIONS
; -------------------------------------------------------

; ****** also in dxvcpi.asm ******

.ERRE CB_MEMHDR EQ 10h          ;size of memory block header

; ****** also in dxvcpi.asm ******

; This segment declaration describes the format of the memory
; block header at the beginning of each object in the heap.

MEMHDR  segment at 0    ;Analogous to MS-DOS arenas

fBlkStatus  db      ?       ;Status bits about the arena block
cselBlkData db      ?       ;number of selectors used by the data block
                            ; that this arena header controls
selBlkData  dw      ?       ;initial selector for the data block that this
                            ; arena header controls.
                            ; (if the block is >64k, this is the first of the
                            ;  range of selectors assigned to the block)
selBlkOwner dw      ?       ;PSP selector of owner.  0 if free.
;
; !!!!! There is code in ModifyXmemBlock which depends on the previous
; !!!!! four fields (and only those) being at lower addresses than selBlkHdr.
;
selBlkHdr   dw      ?       ;the selector of the block header.  This points
                            ; back at itself, so that we can find the selector
                            ; to the header from its address
selBlkNext  dw      ?       ; next block header selector
selBlkPrev  dw      ?       ; previous block header selector
cbBlkLen    LABEL DWORD     ; Block size in bytes
hBlockHandle dw     ?       ; The handle returned by DOS or HIMEM
dsegBlock   dw      ?       ; 0 => HIMEM ELSE DOS paragraph count

MEMHDR  ends


; -------------------------------------------------------
        subttl  Initialization Routines
        page

DXPMCODE  segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;               INITIALIZATION ROUTINES
; -------------------------------------------------------
;
;   InitLowHeap -- Allocate and initialize the special low
;                  memory heap for use by network buffers
;                  and the like.
;
;   Input:  AX      - number of K bytes of LOW heap needed
;                     (assumed to be < 1 Meg)
;   Output: none
;   Errors: CY set if error occurs
;   Uses:   All registers preserved
;
;   Note:   This routine must be called in protected mode
;           and it assumes that interrupts should be enabled
;           while it runs.

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitLowHeap

InitLowHeap     proc    near

        ret

InitLowHeap     endp

; -------------------------------------------------------
;   AddToXmemHeap    -- This routine will add a block of memory
;       to the extended memory heap.  It creates the sentinel header
;       blocks and a header block for a free object containing
;       the new memory.
;
;   Input:  CX  -   Least significant part of minimum block length required
;           DX  -   Most significant part of minimum block length required
;   Output: None
;   Errors: None
;   Uses:
;   NOTES:   This routine must be called in protected mode.
;            With XMS-only providing memory, all XMS memory is allocated
;            the first time this routine is called.
;
;            If VCPI is active, and VCPI memory is being used, then
;            enough memory is allocated from the server to satisfy
;            the request.  The allocation is handled in dxvcpi.asm.
;

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

cProc AddToXmemHeap,<NEAR,PUBLIC>,<ax,bx,cx,dx,si,es>
cBegin

;
; Add to requested size the size of our header overhead
;
        add     cx,3*CB_MEMHDR  ; Adjust for header overhead
        adc     dx,0
;
; Round allocation up to next MIN_ALLOC size by first rounding up to the
; nearest 1K, then converting to K and rounding
;

        add     cx,1023
        adc     dx,0
        shr     cx,10
        push    dx
        shl     dx,6
        or      cx,dx                   ; cx is now size rounded to K
        pop     dx
        add     cx,XMEM_MIN_ALLOC - 1
        adc     dx,0
        and     cx,NOT (XMEM_MIN_ALLOC - 1) ; rounded to next higher MIN_ALLOC


; See How much memory is available from the HIMEM driver

atxh100:
        pmxmssvc 8                      ; query freespace available
        cmp     bl,0                    ; Test for error
        jnz     atxhDone                 ; No luck - Try DOS
        cmp     ax,0
        je      atxhDone

;        cmp     ax,cx           ; is largest block > allocation desired?
;        jb      atxh110         ; no, use largest block

;        mov     ax,cx           ; yes, use desired alloc
atxh110:
        mov     dx,ax           ; Load reported size of largest free block
        mov     bx,ax           ; Calculate number of bytes available
        shl     bx,10
        shr     ax,6            ; AX:BX = available bytes

        sub     bx,3*CB_MEMHDR  ; Adjust for header overhead
        sbb     ax,0
        mov     word ptr cbHeapSize,bx     ; Save lower order bytes available
        mov     word ptr [cbHeapSize+2],ax ; Save higher order bytes available

        pmxmssvc 9              ; Allocate the largest possible block
        cmp     ax,0            ; Check for error
        jz      atxhDone        ; HIMEM driver speak with forked tongue
        mov     hmemHeap,dx     ; Save the handle

        pmxmssvc 0Ch            ; Lock and query address
        xchg    bx,dx
        mov     dsegCurrent,0   ; Flag this allocate was not from DOS
        cmp     ax,0            ; Test result
        jnz     atxh300         ; Rejoin common code

        Trace_Out "AddToXmemHeap: Lock of XMS handle #DX failed."

        jmp     atxhDone        ; Jump on error

atxh300:

        call    StructureHeap   ; Build sentinels and free block

        mov     ax,selHeapStart ; Remember the high heap start selector
        mov     selHiHeapStart,ax

; Done allocating memory.

atxhDone:

cEnd

; -------------------------------------------------------
;   InitXmemHeap    -- This routine will initialize the
;                      extended memory heap.
;
;   Input:
;   Output:
;   Errors:
;   Uses:
;

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitXmemHeap

InitXmemHeap:
        ret

IFNDEF WOW_x86
; -------------------------------------------------------
;    FreeXmemHeap -- This routine gives the xms memory back to
;       the xms driver.  The selectors for the heap are not
;       freed.  Shortly after we release the heap, the LDT will
;       be reinitialized, and that will free the selectors
;
        public FreeXmemHeap
FreeXmemHeap:
        ret ; bugbug
ENDIF
; -------------------------------------------------------
;   StructureHeap -- This routine creates the sentinel header
;       blocks and a header block for a free object containing
;       the new memory.
;
;   Input:  BX  -   Most significant part of heap block address
;           DX  -   Least significant part of heap block address
;
;   Output: None
;   Errors: Carry flag set if there was not enough memory available
;   Uses:   BX, DX
;
;   NOTE:   This routine must be called in protected mode.
;

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  StructureHeap

StructureHeap   proc    near

        push    ax
        push    cx
        push    es

        push    bx              ; most significant part of address
        push    dx              ; least significant part of address

; Allocate selectors for the two sentinel blocks, and the initial free
; block and link them at the start of the chain.
;
; Create the end sentinel

        add     dx,word ptr cbHeapSize       ;Calculate address of end sentinel
        adc     bx,word ptr [cbHeapSize + 2]
        add     dx,2*CB_MEMHDR
        adc     bx,0
        call    AddSelectorToChain           ;Allocate/link the end sentinel

; Initialize the ending sentinel block.

        assume  es:MEMHDR
        xor     ax,ax
        mov     fBlkStatus,al
        mov     cselBlkData,al
        mov     selBlkData,ax
        mov     selBlkOwner,0FFFFh
        mov     cx,hmemHeap         ; Save handle
        mov     hBlockHandle,cx
        mov     cx,dsegCurrent      ; Save paragraph count
        mov     dsegBlock,cx

; Create the free block

        pop     dx                  ; least significant part of address
        pop     bx                  ; most significant part of address
        add     dx,CB_MEMHDR        ; Calculate address of Free block
        adc     bx,0
        call    AddSelectorToChain  ; Allocate and link the Free Block

; Initialize the header for the free data block.

        mov     fBlkStatus,al
        mov     cselBlkData,al
        mov     selBlkData,ax
        mov     selBlkOwner,ax
        mov     cx,word ptr [cbHeapSize]
        mov     word ptr [cbBlkLen],cx
        mov     cx,word ptr [cbHeapSize+2]
        mov     word ptr [cbBlkLen+2],cx

; Create the starting sentinel

        sub     dx,CB_MEMHDR        ; Calculate address of start sentinel
        sbb     bx,0
        call    AddSelectorToChain  ; Allocate and link the start sentinel

; Initialize the starting sentinel block.

        mov     fBlkStatus,al
        mov     cselBlkData,al
        mov     selBlkData,ax
        mov     selBlkOwner,0FFFEh  ;mark it as in use
        mov     cx,hmemHeap         ; Save handle
        mov     hBlockHandle,cx
        mov     cx,dsegCurrent      ; Save paragraph count
        mov     dsegBlock,cx

        pop     es
        pop     cx
        pop     ax

        ret

StructureHeap   endp


; -------------------------------------------------------
; AddSelectorToChain    -- This function will create a header block at a
;                          specified address and link it to the head of the
;                          header chain. It is the caller's responsibility
;                          to initialize all fields in the header other
;                          than the chain link pointers themselves.
;
;   This function can only be called in protected mode.
;
;   Input:  BX      - Most significant part of header address
;           DX      - Least significant part of header address
;   Output: ES      - selector for the new header
;   Errors: Carry flag set on error
;   Uses:   all registers except ES preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  AddSelectorToChain

AddSelectorToChain:
        push    ax                  ; Save callers regs
        push    bx                  ;
        push    cx                  ;
        call    AllocateSelector    ; Get a free selector
        jc      astcFail            ; Jump on error
        mov     cx,CB_MEMHDR - 1    ;
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

        mov     cx,selHeapStart     ; Load old start of chain
        jcxz    @f
        mov     es,cx               ; Point to old start of chain
        assume  es:MEMHDR           ;
        mov     selBlkPrev,ax       ; Link to new start of chain
@@:
        mov     es,ax               ; Point to new head of chain
        mov     selBlkNext,cx       ; Link it to old head
        mov     selBlkPrev,0        ; NULL back pointer
        mov     selBlkHdr,ax        ; Block header points to itself
        mov     selHeapStart,ax     ; Store new head of chain
        clc                         ; Flag no error
astcFail:
        pop     cx                  ; Restore Users regs
        pop     bx                  ;
        pop     ax                  ;
        ret                         ; AddSelectorToChain


; -------------------------------------------------------
; AllocateXmem32        -- This function will return a 32-bit address and
;                          handle of a block of memory allocated in extended
;                          memory.
;
;   Input:  BX:CX   - Size of block desired
;           DX      - Owner of block
;   Output: BX:CX   - Address of memory
;           SI:DI   - handle of memory
;   Errors: Carry flag set on error
;   Uses:
; -------------------------------------------------------

        public  AllocateXmem32
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
AllocateXmem32  proc    near

        FBOP    BOP_DPMI, AllocXmem, FastBop
        ret

AllocateXmem32  endp


; -------------------------------------------------------
; FreeXmem32            -- This function will free a block of extended memory
;                          allocated by AllocateXmem.
;
;   Input:  SI:DI   - Handle of memory
;   Errors: Carry flag set on error
;   Uses:
; -------------------------------------------------------

        public  FreeXmem32
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
FreeXmem32      proc    near

        FBOP    BOP_DPMI, FreeXmem, FastBop
        ret

FreeXmem32      endp


DXPMCODE    ends

DXCODE  segment
        assume  cs:DXCODE

; -------------------------------------------------------
;   ReleaseLowHeap      -- This routine will release the
;       special low memory heap.  After this function is
;       called, InitLowHeap must be called again before
;       any other low heap functions can be used.
;
;       Currently this routine doesn't bother to release
;       selectors used by the blocks in the low heap (like
;       ReleaseXmemHeap does) under the assumption that
;       the DOS extender is about to terminate.  If you are
;       really going reinitialize the low heap with InitLowHeap,
;       then you should do more clean up here.
;
;   Input:  none
;   Output: none
;   Errors:
;   Uses:   All preserved
;
;   Note:   This routine must be called in real mode!

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  ReleaseLowHeap

ReleaseLowHeap  proc    near

        push    ax
        push    es

        mov     ax,segLowHeap           ;make sure there really is a low heap
        or      ax,ax
        jz      rlh90

        mov     es,ax                   ;now use DOS to get rid of it
        mov     ah,49h
        pushf
        sub     sp,8                    ; make room for stack frame
        push    bp
        mov     bp,sp
        push    es
        push    ax

        xor     ax,ax
        mov     es,ax
        mov     [bp + 8],cs
        mov     [bp + 6],word ptr (offset rlh10)
        mov     ax,es:[21h*4]
        mov     [bp + 2],ax
        mov     ax,es:[21h*4 + 2]
        mov     [bp + 4],ax
        pop     ax
        pop     es
        pop     bp
        retf

rlh10:  xor     ax,ax                   ;just to be tidy
        mov     segLowHeap,ax
        mov     selLowHeapStart,ax

rlh90:
        pop     es
        pop     ax
        ret

ReleaseLowHeap  endp


; -------------------------------------------------------
;   ReleaseXmemHeap     -- This routine will release memory
;       used by the extended memory heap.  After this function
;       is called, no extended memory manager routines can
;       be called except InitXmemHeap.
;
;   Input:
;   Output:
;   Errors:
;   Uses:
;
;   Note:    Do NOT enable interrupts while in protected mode!

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  ReleaseXmemHeap

ReleaseXmemHeap:
        push    ax
        push    bx
        push    cx
        push    dx
        push    ds
        push    es

        SwitchToProtectedMode   ; Needed for selector juggling

ifdef MD
        call    CheckXmemHeap
endif
        mov     bx,selHeapStart ; Point to the start of the block chain
        mov     es,bx           ;
        assume  es:MEMHDR       ;
;
; This is the start of a loop on all blocks. ES and BX both contain the
; selector for the current block, or zero if at the end of the chain.
rxh100:
        or      bx,bx           ; End of chain?
        jz      rxhEnd          ; Yes - Jump
        mov     cl,cselBlkData  ; Load number of data segments
        xor     ch,ch           ;
        jcxz    rxh200          ; Jump if nothing to do
        mov     ax,selBlkData   ; Load first data segment
        and     ax,SELECTOR_INDEX ; Treat like GDT entry for FreeSelector
rxh110:
        push    ax              ; Since it is destroyed by FreeSelector
        call    FreeSelector    ; Free each of the data selectors
        pop     ax              ;
        add     ax,8            ; Point to the next data descriptor
        loop    rxh110          ;
;
; All data descriptors for this block now free (if there ever were any)
rxh200:
        push    selBlkNext      ; Push pointer to the next block in the chain
        push    es              ; Push the pointer to this one
        cmp     selBlkOwner,0FFFFh ; Is this an end sentinel ?
        jne     rxh300          ; No - jump
;
; Time to free a HIMEM allocated memory blcok
rxh210:
        mov     dx,hBlockHandle ;
        push    dx              ; Since the data may move after the unlock
        ASSUME  es:NOTHING      ;
        pmxmssvc 0Dh,disable    ;unlock the memory block containing the heap
        pop     dx              ;
        pmxmssvc 0Ah,disable    ;free the block
;
; Time to free the header selector.
rxh300:
        pop     ax              ; Retrieve the selector for the current header
        pop     bx              ; Retrieve the selector for the next one
        mov     es,bx           ;
        call    FreeSelector    ; Free the selector for the current header
        jmp     rxh100          ; Loop for the next block
;
; All done
rxhEnd:
        mov     selHeapStart,0  ; Point to the start of the block chain
ifdef MD
        call    CheckXmemHeap
endif
        SwitchToRealMode        ; Restore callers environment
        sti                     ;
        pop     es
        pop     ds
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret

; -------------------------------------------------------

DXCODE  ends

; -------------------------------------------------------
        subttl  Main Routines
        page
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;           MAIN MEMORY MANAGEMENT ROUTINES
; -------------------------------------------------------
;
;   AllocateLowBlock -- This function will allocate a block
;       of memory from the special low memory heap.
;       If the requested block is larger than 64k, multiple segment
;       descriptors will be allocated, one for each full 64k and one
;       for whatever is left over.  When multiple segment descriptors
;       are created, the selectors will differ by 8 for each segment.
;       (i.e. the returned selector accesses the first 64k, add 8 to
;        get to the next 64k, etc.)
;
;   Input:  CX      - low word of requested block size
;           DX      - high word of requested block size
;   Output: AX      - initial selector for the memory block
;   Errors: returns CY set and size of largest free memory block in CX,DX.
;           This can occur either because there isn't a large enough
;           free block in the memory pool, or there isn't a contiguous
;           range of free segment descriptors that is large enough.
;   Uses:   AX, all else preserved.  Modifies the segment descriptors
;           for the SEL_SCR0 and SEL_SCR1 segments
;
;   Note:   This routine is _very_ similar to AllocateXmemBlock,
;           but just different enough that it's a separate routine.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  AllocateLowBlock

AllocateLowBlock  proc  near

        push    bp
        mov     bp,sp
        sub     sp,14
        push    es
        push    si
        push    bx
        push    cx
        push    dx

Segm    equ word ptr [bp - 2]
StartSel equ word ptr [bp - 4]
Largest equ word ptr [bp - 6]
MemSize    equ [bp - 10]
cSelector equ word ptr [bp - 12]
selHeader equ word ptr [bp - 14]

        mov     word ptr MemSize,cx
        mov     word ptr MemSize + 2,dx

;
; See if we need to use wow kernel to manage low memory
;
        mov     ax,word ptr [LowMemAllocFn]
        or      ax,word ptr [LowMemAllocFn + 2]
        je      alm3
        jmp     alm130
;
; Round up to the next paragraph
;
alm3:   add     cx,15
        adc     dx,0
        and     cx,0FFF0h

;
; Form a paragraph count
;
        mov     bx,cx
        shr     bx,4
        shl     dx,12
        or      bx,dx

;
; Add one to make room for the heap header
;
        cmp bx,0ffffh
        je      alm5                            ; won't succed, but get size

        inc bx
alm5:
;
; Switch to real mode and allocate the memory
;
        SwitchToRealMode

        mov     ax,4800h
        int     21h                             ; call dos

        jnc     alm10

        mov     Segm,ax
        mov     Largest,bx
        mov     cx,0
        jmp     alm20
;
; Remember the values returned
;

alm10:  mov     Segm,ax
        mov     cx,1

alm20:  SwitchToProtectedMode
        cmp     cx,0
        jne     alm40

        ;
        ; return an error
        ;

alm30:  mov     cx,bx
        mov     dx,bx
        shr     dx,12
        shl     cx,4                            ; form bytes available
        mov     ax,Segm                         ; actually error code for fail
        add     sp,4                            ; skip cx,dx
        stc
        jmp     alm110

alm40:  mov     ax,word ptr MemSize + 2
        mov     bx,word ptr MemSize

        or      bx, bx
        jnz     short alm44
        or      ax, ax
        jz      short alm45                     ; if zero then don't adjust

alm44:
        sub     bx,1
        sbb     ax,0                            ; go from size to limit
alm45:
        mov     word ptr MemSize + 2,ax
        mov     word ptr MemSize,bx
        inc     ax                              ; we always want 2 more
        inc     ax
        mov     cSelector,ax
        xor     cx, cx                          ;allocate from lower range
        call    AllocateSelectorBlock
        jnc     alm50

        mov     ax,8                            ; insufficient memory
        mov     bx,Largest
        jmp     alm30

alm50:  or      ax,STD_RING
        mov     si,ax
        mov     StartSel,ax
        mov     ax,word ptr MemSize + 2
        mov     bx,word ptr MemSize             ; ax:bx - block size
        mov     cx,Segm
        mov     dx,cx
        shr     cx,12
        shl     dx,4                            ; cx:dx - block base
        ;
        ; Set up the first one to have the entire limit
        ;
        cCall   NSetSegmentDscr,<si,cx,dx,ax,bx,STD_DATA>

        ;
        ; Set up the rest to have 64K limits
        ;

        dec     ax                              ; already set one
        cmp     ax,0FFFFh
        je      alm80

        cmp     ax,0
        je      alm70

        mov     di,0FFFFh
alm60:  add     si,8
        inc     cx                              ; add 64K to base

        cCall   NSetSegmentDscr,<si,cx,dx,0,di,STD_DATA>

        dec     ax
        cmp     ax,0
        jne     alm60

        ;
        ; Just one selector left, so set the correct limit
        ;

alm70:  add     si,8
        inc     cx
        cCall   NSetSegmentDscr,<si,cx,dx,0,bx,STD_DATA>

        ;
        ; Set up header
        ;

alm80:  mov     ax,Segm
        mov     bx,ax
        shr     ax,12
        shl     bx,4                            ; ax:bx = base of header
        add     bx,word ptr MemSize
        adc     ax,word ptr MemSize + 2
        add     si,8
        cCall   NSetSegmentDscr,<si,ax,bx,0,CB_MEMHDR,STD_DATA>

        ;
        ; Set up values in header and add to chain
        ;
        mov     es,si
        mov     selHeader,si
        assume  es:MEMHDR
        mov     [selBlkHdr],si
        mov     ax,StartSel
        mov     [selBlkData],ax
        mov     ax,cSelector
        mov     [cselBlkData],al
        mov     ax,selPSPChild
        mov     [selBlkOwner],ax
        mov     ax,Segm
        mov     [hBlockHandle],ax
        mov     ax,selLowHeapStart
        mov     [selBlkNext],ax
        mov     bx,0
        mov     [selBlkPrev],bx
        or      ax,ax
        jz      alm100

        mov     bx,es
        mov     es,ax
        mov     [selBlkPrev],bx

        ;
        ; set up return values
        ;
alm100: mov     ax,selHeader
        mov     selLowHeapStart,ax
        mov     ax,StartSel
        clc
alm105: pop     dx
        pop     cx
alm110: pop     bx
        pop     si
        pop     es
        mov     sp,bp
        pop     bp
        ret

alm130: push    dx
        push    cx
        call    [LowMemAllocFn]
        or      ax,ax
        jz      alm140
        clc
        jmp     alm105

alm140: xor     cx,cx
        stc
        add     sp,4
        jmp     alm110

AllocateLowBlock  endp


; -------------------------------------------------------
;   FreeLowBlock   -- This function will free the low heap
;       memory block specified by the given selector.  It
;       will return the memory block to the free memory pool,
;       and release all selectors used by this block.
;
;   Input:  AX      - selector of the data block to free
;   Output: none
;   Errors: returns CY set if invalid selector
;   Uses:   AX, all other registers preserved
;           Modifies the descriptor for segment SEL_SCR0

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FreeLowBlock

FreeLowBlock    proc    near
        push    bp
        mov     bp,sp
        sub     sp,4
Segm    equ word ptr [bp - 2]
HeaderSel equ word ptr [bp - 4]
        push    es
        push    bx
        push    cx

        ;
        ; See if we need to use the wow kernel to manage memory
        ;
        mov     bx,word ptr [LowMemFreeFn]
        or      bx,word ptr [LowMemFreeFn + 2]
        jz      flm5
        jmp     flm130

        ;
        ; search for the block to free
        ;
flm5:   mov     bx,selLowHeapStart
flm10:  or      bx,bx                           ; any low blocks?
        jz      flm100

        mov     es,bx
        assume  es:MEMHDR

        cmp     [selBlkData],ax
        je      flm30                           ; found the correct block

        mov     bx,[selBlkNext]
        jmp     flm10

        ;
        ; Unlink the block from the list
        ;
flm30:  mov     ax,es
        mov     HeaderSel,ax

        mov     ax,[selBlkPrev]
        mov     bx,[selBlkNext]
        cmp     ax,0
        je      flm40

        mov     es,ax
        mov     [selBlkNext],bx
        jmp     flm50

flm40:  mov     SelLowHeapStart,bx
flm50:  cmp     bx,0
        je      flm60

        mov     es,bx
        mov     [selBlkPrev],ax

flm60:  mov     ax,HeaderSel
        mov     es,ax
        mov     ax,[hBlockHandle]
        mov     Segm,ax

        mov     ax,[selBlkData]
        xor     cx,cx
        mov     cl,[cselBlkData]
        push    0
        pop     es
        call    FreeSelectorBlock

        SwitchToRealMode
        mov     ax,Segm
        mov     es,ax
        mov     ax,4900h
        int     21h                             ; free the memory

        push    ax                              ; save return code
        jnc     flm70

        mov     cx,0                            ; error
        jmp     flm80

flm70:  mov     cx,1                            ; no error
flm80:  SwitchToProtectedMode
        pop     ax
        cmp     cx,0
        je      flm100                          ; error path

flm85:  clc
flm90:  pop     cx
        pop     bx
        pop     es
        mov     sp,bp
        pop     bp
        ret

flm100: stc
        jmp     flm90

flm130: push    ax
        call    [LowMemFreeFn]
        or      ax,ax
        jz      flm85

        mov     ax,9
        stc
        jmp     flm90

FreeLowBlock    endp

; -------------------------------------------------------
;
;   AllocateXmemBlock -- This function will allocate a block
;       of extended memory and return selectors for accessing it.
;       If the requested block is larger than 64k, multiple segment
;       descriptors will be allocated, one for each full 64k and one
;       for whatever is left over.  When multiple segment descriptors
;       are created, the selectors will differ by 8 for each segment.
;       (i.e. the returned selector accesses the first 64k, add 8 to
;        get to the next 64k, etc.)
;
;   Input:  BL      - flag controlling allocation of selectors,
;                     if 0 - a selector will be allocated for each 64k
;                     if != 0 - only one selector will be allocated to
;                     the block.
;           CX      - low word of requested block size
;           DX      - high word of requested block size
;   Output: AX      - initial selector for the memory block
;   Errors: returns CY set and size of largest free memory block in CX,DX.
;           This can occur either because there isn't a large enough
;           free block in the memory pool, or there isn't a contiguous
;           range of free segment descriptors that is large enough.
;   Uses:   AX, all else preserved.  Modifies the segment descriptors
;           for the SEL_SCR0 and SEL_SCR1 segments
;
;   Notes:  Hard coding an int 3 in this routine is fatal.  This routine
;           is used to allocate the stack used for exception handling.
;

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  AllocateXmemBlock

AllocateXmemBlock       proc    near

axb1:   push    bp
        mov     bp,sp
        sub     sp,20
        push    es
        push    bx
        push    si
        push    di
        push    cx
        push    dx

AllocFlag equ byte ptr [bp - 2]
cSelector equ word ptr [bp - 4]
MemHandle equ [bp - 8]
MemSize equ [bp - 12]
MemAddr equ [bp - 16]
StartSel equ word ptr [bp - 18]
HeaderSel equ word ptr [bp - 20]

        mov     AllocFlag,bl
        mov     word ptr MemSize,cx
        mov     word ptr MemSize + 2,dx
        mov     word ptr MemHandle,0
        mov     word ptr MemHandle + 2,0

        ;
        ; Save room for header
        ;
        add     cx,16
        adc     dx,0

        mov     bx,dx
        mov     dx, selPSPChild

        call    AllocateXmem32

        jnc     axb40
        jmp     axb130

axb40:  mov     word ptr MemAddr,cx
        mov     word ptr MemAddr + 2,bx
        mov     word ptr MemHandle,di
        mov     word ptr MemHandle + 2,si
        ;
        ; Change size to limit
        ;
        mov     ax,word ptr MemSize + 2
        mov     bx,word ptr MemSize
        sub     bx,1
        sbb     ax,0                    ; size -> limit
        mov     word ptr MemSize,bx
        mov     word ptr MemSize + 2,ax

        ;
        ; Figure out how many selectors to allocate
        ;
        cmp     AllocFlag,0
        jne     axb50

        inc     ax
        jmp     axb60

axb50:  mov     ax,1

        ;
        ; Add one additional for the header block
        ;
axb60:  inc     ax
        mov     cSelector,ax

        ;
        ; Allocate the selectors
        ;
        xor     cx,cx                           ; allocate from lower range
        call    AllocateSelectorBlock
        jnc     axb65

        jmp     axb120

axb65:  or      ax,STD_RING
        mov     StartSel,ax

        ;
        ; Set up the first selector to have the entire limit
        ;
        mov     di,cSelector
        mov     si,ax
        mov     ax,word ptr MemSize + 2
        mov     bx,word ptr MemSize
        mov     cx,word ptr MemAddr + 2
        mov     dx,word ptr MemAddr
        add     dx,16                   ; room for header
        adc     cx,0
        cCall   NSetSegmentDscr,<si,cx,dx,ax,bx,STD_DATA>
        dec     di
        dec     ax
        add     si,8

        cmp     di,1
        je      axb90

        ;
        ; Set up the rest with 64K limits
        ;
axb70:  cmp     ax,0
        je      axb80

        inc     cx
        cCall   NSetSegmentDscr,<si,cx,dx,0,0FFFFh,STD_DATA>
        dec     ax
        add     si,8
        jmp     axb70

        ;
        ; Set up the last one with the remaining limit
        ;
axb80:  inc     cx
        cCall   NSetSegmentDscr,<si,cx,dx,0,bx,STD_DATA>
        add     si,8

        ;
        ; Set up Header selector
        ;
axb90:  mov     ax,word ptr MemAddr + 2
        mov     bx,word ptr MemAddr
        cCall   NSetSegmentDscr,<si,ax,bx,0,CB_MEMHDR,STD_DATA>
        mov     HeaderSel,si

        ;
        ; Set up header
        ;
        mov     es,si
        assume  es:MEMHDR
        mov     [selBlkHdr],si
        mov     ax,StartSel
        mov     [selBlkData],ax
        mov     ax,cSelector
        mov     [cselBlkData],al
        mov     ax,selPSPChild
        mov     [selBlkOwner],ax
        mov     ax,MemHandle
        mov     [hBlockHandle],ax
        mov     ax,word ptr MemHandle + 2
        mov     [dsegBlock],ax                  ; use for high half handle
        mov     ax,selHiHeapStart
        mov     [selBlkNext],ax
        mov     bx,0
        mov     [selBlkPrev],bx
        or      ax,ax
        jz      axb100

        mov     bx,es
        mov     es,ax
        mov     [selBlkPrev],bx
axb100: mov     ax,HeaderSel
        mov     selHiHeapStart,ax

        ;
        ; return information to the caller
        ;
        clc
        mov     ax,StartSel
        pop     dx
        pop     cx
axb110: pop     di
        pop     si
        pop     bx
        pop     es
        mov     sp,bp
        pop     bp
        ret

        ;
        ; Error
        ;

axb120: mov     dx,word ptr MemHandle
        or      dx,word ptr MemHandle + 2
        jz      axb130

        mov     di,word ptr MemHandle
        mov     si,word ptr MemHandle + 2

        FBOP    BOP_DPMI, FreeXmem, FastBop
        ;
        ; Get largest free block
        ;
axb130: pmxmssvc 08h
        mov     dx,ax
        mov     cx,ax
        shl     cx,10
        shr     dx,6
        add     sp,4                    ; skip cx,dx on stack
        stc
        jmp     axb110

AllocateXmemBlock       endp

; -------------------------------------------------------
;   FreeXmemBlock   -- This function will free the extended
;       memory block specified by the given selector.  It
;       will return the memory block to the free memory pool,
;       and release all selectors used by this block.
;
;   Input:  AX      - selector of the data block to free
;   Output: none
;   Errors: returns CY set if invalid selector
;   Uses:   AX, all other registers preserved
;           Modifies the descriptor for segment SEL_SCR0

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FreeXmemBlock


FreeXmemBlock:

fxb1:   push    bp
        mov     bp,sp
        sub     sp,6
HeaderSel equ word ptr [bp - 2]
MemHandle equ [bp - 6]
        push    es
        push    bx
        push    si
        push    di
        push    dx
        push    cx

        ;
        ; search for the block to free
        ;
        mov     bx,selHiHeapStart
fxb10:  or      bx,bx                           ; any hi blocks?
        jnz     fxb20
        jmp     fxb100

fxb20:  mov     es,bx
        assume  es:MEMHDR

        cmp     [selBlkData],ax
        je      fxb30                           ; found the correct block

        mov     bx,[selBlkNext]
        jmp     fxb10

        ;
        ; Unlink the block from the list
        ;
fxb30:  mov     ax,es
        mov     HeaderSel,ax

        mov     ax,[selBlkPrev]
        mov     bx,[selBlkNext]
        cmp     ax,0
        je      fxb40

        mov     es,ax
        mov     [selBlkNext],bx
        jmp     fxb50

fxb40:  mov     SelHiHeapStart,bx
fxb50:  cmp     bx,0
        je      fxb60

        mov     es,bx
        mov     [selBlkPrev],ax

fxb60:  mov     ax,HeaderSel

        mov     es,ax
        mov     dx,[dsegBlock]                  ; high half handle
        mov     word ptr MemHandle + 2,dx
        mov     dx,[hBlockHandle]
        mov     word ptr MemHandle,dx

        ;
        ; Free the selectors
        ;
        mov     ax,[selBlkData]
        xor     cx,cx
        mov     cl,[cselBlkData]
        push    0
        pop     es
        assume  es:nothing
        call    FreeSelectorBlock

        mov     si,word ptr MemHandle + 2
        mov     di,word ptr MemHandle

        call    FreeXmem32
        clc

fxb90:  pop     cx
        pop     dx
        pop     di
        pop     si
        pop     bx
        pop     es
        mov     sp,bp
        pop     bp
        ret

fxb100: stc
        jmp     fxb90

; -------------------------------------------------------
;   ModifyXmemBlock -- This function will modify the size
;       of the specified extended memory block to the new
;       size specified by CX,DX.  If the block is being
;       shrunk, the new size must be at least CB_HDRSIZ bytes
;       smaller than the old size, or nothing is done.If the
;       block grows beyond the next 64k boundary,
;       it may be necessary to allocate another segment
;       descriptor for it.  If this is not possible, the grow
;       will fail.
;
;   Input:  AX      - segment selector for the data block to modify
;           BL      - flag controlling allocation of selectors to block,
;                     if 0 - selectors will be allocated for each 64k
;                     if != 0 - only one selector is allocated to block
;           CX      - low word of new desired size
;           DX      - high word of new desired size
;   Output: none
;   Errors: CY set if unable to accomplish the request.
;           returns error code in AX.
;           CX,DX will be set to the largest possible size that the
;           block could be modified to have
;   Uses:   AX,CX,DX,Flags

        assume  ds:DGROUP,es:NOTHING
        public  ModifyXmemBlock

ModifyXmemBlock proc    near
mxb1:   push    bp
        mov     bp,sp
        sub     sp,20
HeaderSel equ word ptr [bp - 2]
AllocFlags equ byte ptr [bp - 4]
MemSize equ [bp - 8]
MemAddr equ [bp - 12]
Success equ word ptr [bp - 14]
cSelector equ word ptr [bp - 16]
BlockHandle equ word ptr [bp - 20]
        push    es
        push    bx
        push    cx
        push    dx

        mov     word ptr MemSize + 2,dx
        mov     word ptr MemSize,cx
        mov     AllocFlags,bl
        mov     Success,1

        ;
        ; Search for the block to resize
        ;
        mov     bx,selHiHeapStart
mxb10:  or      bx,bx                           ; any hi blocks?
        jnz     mxb15
        jmp     mxb140

mxb15:  mov     es,bx
        assume  es:MEMHDR

        cmp     [selBlkData],ax
        je      mxb30                           ; found the correct block

        mov     bx,[selBlkNext]
        jmp     mxb10

        ;
        ; Calculate the number of selectors needed
        ;
mxb30:  mov     HeaderSel,es
        test    AllocFlags,1
        jne     mxb40

        sub     cx, 1                           ; size -> limit
        sbb     dx,0
        inc     dl
        jmp     mxb50

mxb40:  mov     dl,1
mxb50:  inc     dl                              ; always need 1 more

        ;
        ; See if we have enough selectors
        ;
        cmp     dl,[cselBlkData]
        jna     mxb55
        jmp     mxb120

mxb55:  and     dl,0ffh
        mov     cSelector,dx
        mov     dx,[dsegBlock]
        mov     word ptr BlockHandle + 2,dx
        mov     dx,[hBlockHandle]
        mov     word ptr BlockHandle,dx

        mov     bx,word ptr MemSize + 2
        mov     cx,word ptr MemSize
        add     cx,010h
        adc     bx,0
        mov     si,word ptr BlockHandle + 2
        mov     di,word ptr BlockHandle

        FBOP    BOP_DPMI, ReallocXmem, FastBop
        jnc     mxb60

        mov     Success,0

mxb60:  mov     word ptr MemAddr,cx
        mov     word ptr MemAddr + 2,bx
        mov     word ptr BlockHandle,di
        mov     word ptr BlockHandle + 2,si
        ;
        ; Fix the base of the Header selector
        ;
        mov     bx,word ptr MemAddr + 2
        mov     dx,word ptr MemAddr
        mov     ax,HeaderSel
        call    SetSegmentAddress
        mov     es,ax

        ;
        ; Fix the handle (may have changed
        ;
        mov     dx,word ptr BlockHandle
        mov     [hBlockHandle],dx
        mov     dx,word ptr BlockHandle + 2
        mov     [dsegBlock],dx

        ;
        ; Change size to limit
        ;
        mov     ax,word ptr MemSize + 2
        mov     bx,word ptr MemSize
        sub     bx,1
        sbb     ax,0                    ; size -> limit
        mov     word ptr MemSize,bx
        mov     word ptr MemSize + 2,ax

        ;
        ; Set up the first selector to have the entire limit
        ;
        mov     di,cSelector
        mov     si,[selBlkData]
        mov     ax,word ptr MemSize + 2
        mov     bx,word ptr MemSize
        mov     cx,word ptr MemAddr + 2
        mov     dx,word ptr MemAddr
        add     dx,16                   ; room for header
        adc     cx,0
        cCall   NSetSegmentDscr,<si,cx,dx,ax,bx,STD_DATA>
        dec     di
        dec     ax
        add     si,8

        cmp     di,1
        je      mxb100

        ;
        ; Set up the rest with 64K limits
        ;
mxb80:  cmp     ax,0
        je      mxb90

        inc     cx
        cCall   NSetSegmentDscr,<si,cx,dx,0,0FFFFh,STD_DATA>
        dec     ax
        add     si,8
        jmp     mxb80

        ;
        ; Set up the last one with the remaining limit
        ;
mxb90:  inc     cx
        cCall   NSetSegmentDscr,<si,cx,dx,0,bx,STD_DATA>
        add     si,8

        ;
        ; Were we successfull?
        ;
mxb100: cmp     Success,1
        jne     mxb130

        clc
        pop     dx
        pop     cx
mxb110: pop     bx
        pop     es
        mov     sp,bp
        pop     bp
        ret

        ;
        ; We had an error, not enough selectors.  Figure out how large
        ; it could have been
        ;
mxb120: xor     dx,dx
        xor     cx,cx
        mov     dl,[cselBlkData]
        dec     dl                              ; don't count header sel
        mov     ax,8
        add     sp,4                            ; pop cx,dx
        stc
        jmp     mxb110

        ;
        ; We had an error calling xms.  Get the largest block
        ;
mxb130: pmxmssvc 08h
        mov     cx,ax                           ; convert to bytes
        mov     dx,ax
        shl     cx,10
        shr     dx,6
        mov     ax,8
        add     sp,4
        stc
        jmp     mxb110

        ;
        ; We had an error, invalid selector
        ;
mxb140: mov     ax,9
        add     sp,4
        stc
        jmp     mxb110

ModifyXmemBlock endp
        ret


;
; -------------------------------------------------------
        subttl  Utility Routines
        page
; -------------------------------------------------------
;               UTIITY ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
;   CalculateMaximumSegmentSpace -- This function will see if there
;                            are enough free segments available
;                            to expand a block of memory.
;                            If not it returns with carry set
;                            and the maximum space available.
;
;   Input;  ES      - segment selector for the data block to modify
;           CX      - low word of new desired size
;           DX      - high word of new desired size
;
;   Output  CX      - / If CY set: The maximum available
;           DX      - \ If CY not set: Unchanged
;   Errors: CY set if unable to accomplish the request.
;           CX,DX will be set to the largest possible size that the
;           block could be modified to have
;   Uses:   AX,CX,DX,Flags

        assume  ds:DGROUP,es:MEMHDR
        public  CalculateMaximumSegmentSpace

CalculateMaximumSegmentSpace:
        push    bx
        push    es
        xor     bx,bx
        mov     bl,cselBlkData      ; Allocated selector count
        shl     bx,3                ; Convert to byte offset
        add     bx,selBlkData       ; Add starting data selector offset
        and     bx,SELECTOR_INDEX   ; Treat it as a GDT selector
        mov     es,selGDT           ; Base the global descriptor table
        assume  es:NOTHING          ;

; Count through the immediately following selectors

cmssLoop:
        cmp     bx,word ptr bpgdt       ; Off the end of the GDT ?
        ja      cmssOutOfSelectors      ; Yes - Jump
        cmp     word ptr es:[bx].arbSegAccess,0 ; Is the next selector free ?
        jne     cmssOutOfSelectors      ; No - jump

; Point to the next selector

        add     bx,8                ; Increment to next selector
        jnc     cmssLoop            ; Try the next one

; BX points to the first following selector which is not free

cmssOutOfSelectors:
        pop     es                  ; Recover block header segment
        assume  es:MEMHDR
        push    dx                  ; Subtract base selector address
        mov     dx,selBlkData
        and     dx,SELECTOR_INDEX
        sub     bx,dx
        pop     dx
        shr     bx,3                ; Number of contiguous selectors available
        cmp     bx,dx               ; Is it enough ?
        jb      cmssNotEnough       ; No - jump
        jne     cmssOK              ; Yes - jump
        or      cx,cx               ; Don't know - Look at less significant part
        jnz     cmssNotEnough       ; Yes it will fit after all - jump

; Not enough free selectors

cmssNotEnough:
        mov     dx,bx               ; Put max available in CX&DX
        xor     cx,cx               ;
        stc                         ; Flag error
        jmp     short cmssExit      ; Leave
;
; There are enough selectors to satisfy the request
cmssOK:
        clc                         ; Reset the error flag
;
; All Done
cmssExit:
        pop     bx                  ; Restore registers
        ret                         ; CalculateMaximumSegmentSpace

; -------------------------------------------------------
;   CalculateMaximumSpace -- This function will see if there
;                            is room to expand a block of memory.
;                            If not it returns with carry set
;                            and the maximum space available.
;
;   Input:  AL      - check selectors yes/no flag - 0 = yes, !0 = no
;           ES      - segment selector for the data block to modify
;           CX      - low word of new desired size
;           DX      - high word of new desired size
;   Output: AX      - Strategy used: 0 = expand into same block
;                                    1 = expand into next block
;                                    2 = expand into next and previous blocks
;                                    3 = allocate a new block and transfer data
;                                    4 = move lower and higher blocks
;           CX      - / If CY set: The maximum available
;           DX      - \ If CY not set: Unchanged
;   Errors: CY set if unable to accomplish the request.
;           CX,DX will be set to the largest possible size that the
;           block could be modified to have
;   Uses:   AX,CX,DX,Flags

        assume  ds:DGROUP,es:MEMHDR
        public  CalculateMaximumSpace

CalculateMaximumSpace   proc    near

        push    bp
        mov     bp,sp
        push    es
        push    cx                      ; Save required length
        push    dx
        push    ax                      ; Save segment/selector flag

        mov     cx,word ptr [cbBlkLen]  ; Load present length
        mov     dx,word ptr [cbBlkLen+2] ;
        mov     ax,0                    ; Load strategy code
        cmp     dx,word ptr [bp - 6]    ; Compare available with needed
        jb      cms90                   ; Jump if it doesn't fit
        ja      cmsOKa                  ; Jump if it fits
        cmp     cx,word ptr [bp - 4]    ;
        jb      cms90                   ;
cmsOKa:
        jmp     cmsOK

; There is not enough room in the current block. See if the following
; one is free

cms90:
        mov     es,[selBlkNext]         ; Point to the following block
        cmp     [selBlkOwner],0         ; Is it in use?
        jnz     cmsFail                 ; Yes - cannot use it
        add     cx,CB_MEMHDR            ; Add the header of next block
        adc     dx,0
        add     cx,word ptr [cbBlkLen]  ; Add the body of the next block
        adc     dx,word ptr [cbBlkLen+2];
        mov     ax,1                    ; Load strategy code
        cmp     dx,word ptr [bp - 6]    ; Compare available with needed
        ja      cmsOK                   ; Jump if it fits
        cmp     cx,word ptr [bp - 4]    ;
        jae     cmsOK                   ;

; Cannot expand. The max available is in CX&DX

cmsFail:
        add     sp,6                    ; Throw away requested size, and strat
        pop     es                      ; Point to original header

        cmp     byte ptr [bp-8],0       ; Should we check the # of
        jz      @f                      ;   available selectors?
        stc
        jmp     short cmsExit
@@:
        call    CalculateMaximumSegmentSpace    ;Check for enough selectors
        stc                                     ;Flag error
        jmp     short cmsExit

; Expand will succeed. Strategy number is in ax

cmsOK:
        add     sp,2                    ; discard strategy
        pop     dx                      ; Restore requested size
        pop     cx                      ;
cms900:
        pop     es                      ; Point to original header

        cmp     byte ptr [bp-8],0       ; Should we check the # of
        jz      @f                      ;   available selectors?
        clc
        jmp     short cmsExit
@@:
        call    CalculateMaximumSegmentSpace    ;Check for enough selectors

cmsExit:
        pop     bp
        ret

CalculateMaximumSpace   endp


; -------------------------------------------------------
;
;
; CombineFreeBlocks -- This routine is used when freeing
;   an extended memory block.  It will examine the previous
;   and following blocks to see if they are free also, and
;   combine them into a single larger block if so.
;
;   Input:  AX      - selector of segment descriptor for the block
;   Output: AX      - selector for new free memory block
;   Errors: none
;   Uses:   AX, ES modified, all other registers preserved
;
;   NOTE:   This routine may free the segment descriptor for the
;           entry block as part of the process of combining blocks.
;           The original entry value may no longer be used after
;           calling this routine.  If access to the block header
;           for the free segment is still needed, you must use
;           the value returned in AX to access it.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  CombineFreeBlocks

CombineFreeBlocks:
        push    bx
        push    dx
;
        mov     bx,ax           ;save entry value in BX
;
; Look at the previous block and see if it is free.
        mov     es,bx           ;look at block header of entry block
        assume  es:MEMHDR
        mov     es,[selBlkPrev] ;look at block header of previous block
        cmp     [selBlkOwner],0 ;is it in use?
        jnz     cfrb30          ;if so, continue on
;
; The previous memory block is free.  We need to combine it with the
; current one.
        mov     ax,bx
        call    SpliceBlocks
        mov     bx,es
;
; Look at the following block and see if it is free.
cfrb30: mov     es,bx           ;look at the current lower free block
        assume  es:MEMHDR
        mov     es,[selBlkNext] ;look at the following block
        cmp     [selBlkOwner],0 ;is it in use?
        jnz     cfrb90
;
; The following memory block is free.  We need to combine it with the
; current one.
        mov     ax,es
        mov     es,bx
        call    SpliceBlocks
;
; All done
cfrb90: mov     ax,bx
        pop     dx
        pop     bx
        ret

; -------------------------------------------------------
;   SpliceBlocks    -- This routine is used by CombineFreeBlocks
;       to perform the actual combination of two adjacent free
;       blocks.  The space occupied by the upper block is assigned
;       to the lower block, and the upper block is then eliminated.
;
;   Input:  AX      - selector to the upper block
;           ES      - selector to the lower block
;   Output: none
;   Errors: none
;   Uses:   AX, DX modified

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

SpliceBlocks:
        push    ds
        mov     ds,ax
        assume  ds:NOTHING          ;DS points at upper block
                                    ;ES points at lower block
        push    ax
;
        mov     dx,word ptr ds:[cbBlkLen]
        mov     ax,word ptr ds:[cbBlkLen+2]
        add     dx,CB_MEMHDR
        adc     ax,0
        add     word ptr es:[cbBlkLen],dx
        adc     word ptr es:[cbBlkLen+2],ax
        mov     ax,ds:[selBlkNext]
        mov     es:[selBlkNext],ax
        mov     ds,ax           ;DS points at block following entry block
        mov     ds:[selBlkPrev],es
;
        pop     ax
        pop     ds

        call    FreeSelector        ;release the segment descriptor for the
                                    ; upper block
        ret

; -------------------------------------------------------
;   FindFreeBlock   -- This function will search the extended
;       memory heap looking for a free memory block of at
;       least the requested size.
;
;   Input:  CX      - low word of requested block size
;           DX      - high word or requested block size
;   Output: AX      - selector for the block header of the free block
;           cbHeapBlkMax    - size of largest free block found
;           cbHeapFreeSpace - total free space seen
;   Errors: Returns CY set if large enough free block not found.
;           If that happens, then cbHeapBlkMax contains the size of the
;           largest free block, and cbHeapFreeSpace contains the total
;           of all free blocks.
;   Uses:   AX modified, all other registers preserved.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FindFreeBlock

FindFreeBlock:
        push    cx
        push    dx
        push    es
;
        mov     word ptr [cbHeapBlkMax],0
        mov     word ptr [cbHeapBlkMax+2],0
        mov     word ptr [cbHeapFreeSpace],0
        mov     word ptr [cbHeapFreeSpace+2],0
;
        cmp     selHeapStart,0      ;
        jz      ffrb80              ; No heap - no allocate - jump
        mov     es,selHeapStart     ; ES points at the beginning of the heap
        assume  es:MEMHDR
;
; Is the current memory block free?
ffrb20:
        cmp     selBlkOwner,0           ;if the block isn't free, try the next one
        jnz     ffrb26
;
; Accumulate size into free space count.
        mov     ax,word ptr [cbBlkLen]
        add     word ptr [cbHeapFreeSpace],ax
        mov     ax,word ptr [cbBlkLen+2]
        adc     word ptr [cbHeapFreeSpace+2],ax
;
; Update our view of what the largest free block is.
        mov     ax,word ptr [cbBlkLen+2]
        cmp     ax,word ptr [cbHeapBlkMax+2]
        jc      ffrb26
        jnz     ffrb22
        mov     ax,word ptr [cbBlkLen]
        cmp     ax,word ptr [cbHeapBlkMax]
        jc      ffrb26
ffrb22: mov     ax,word ptr [cbBlkLen+2]
        mov     word ptr [cbHeapBlkMax+2],ax
        mov     ax,word ptr [cbBlkLen]
        mov     word ptr [cbHeapBlkMax],ax
;
; Check the size of this memory block to see if it is large enough.
ffrb24: cmp     dx,word ptr [cbBlkLen+2]
        jc      ffrb40
        jnz     ffrb26
        cmp     cx,word ptr [cbBlkLen]
        jna     ffrb40
;
; Go to the next block in the heap
ffrb26:
        cmp     selBlkNext,0                ; End of chain?
        jz      ffrb80                      ; Yes - jump
        mov     es,[selBlkNext]
        jmp     ffrb20
;
; Found a free block that is large enough
ffrb40: mov     ax,es
        clc
        jmp     short ffrb90
;
; Didn't find one, return error.
ffrb80: stc
;
; All done
ffrb90: pop     es
        pop     dx
        pop     cx
        ret

; -------------------------------------------------------
;   FreeSpace   -- This function is used to find out how
;       much free space there is in the heap, plus that
;       which is potentially available from an XMS driver.
;
;   Input:  None
;   Output: AX:DX -- Total free space
;           BX:CX -- Largest free block
;   Errors: none
;   Uses:   AX, all else preserved
;
;   History:10/09/90 -- earleh wrote it.
;
cProc FreeSpace,<NEAR,PUBLIC>,
cBegin

        ;
        ; Call xms to get free memory space
        ;
        pmxmssvc 08h

        ;
        ; convert to bytes
        ;
        mov     bx,dx
        mov     dx,ax
        mov     cx,bx
        shl     dx,10
        shr     ax,6
        shl     cx,10
        shr     bx,6

        ;
        ; account for heap header
        ;
        sub     dx,CB_MEMHDR
        sbb     ax,0
        sub     cx,CB_MEMHDR
        sbb     bx,0

        ret
cEnd

; -------------------------------------------------------
;   SplitBlock  -- This function will split the specified
;       memory block into two blocks, with the first one
;       being the specified size, and the second one containing
;       the remaining space.
;
;   Input:  AX      - selector of block header for memory block to split
;           CX      - low word of requested size
;           DX      - high word of requested size
;   Output: none
;   Errors: none
;   Uses:   AX, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  SplitBlock

SplitBlock:
        push    bx
        push    cx
        push    dx
        push    si
        push    es
;
        mov     es,ax
        assume  es:MEMHDR
;
; We are going to need a segment descriptor for the remainder block
; when we do the split.  Make sure that we can allocate the selector
; now, before we change anything.
        call    AllocateSelector
        jnc     spbl20              ;
        jmp     spbl90              ;get out if error
spbl20: mov     si,ax               ;save selector in SI for later
;
; Adjust the size of the current block and figure the size of the
; remainder.
        xchg    cx,word ptr [cbBlkLen]      ;store the new block length
        xchg    dx,word ptr [cbBlkLen+2]    ; and get the old block length
        push    cx                          ;Save the original size for recovery
        push    dx
        sub     cx,word ptr [cbBlkLen]      ;compute the amount of space
        sbb     dx,word ptr [cbBlkLen+2]    ; remaining in the block
        sub     cx,CB_MEMHDR        ;also account for the new block header
        sbb     dx,0
        jc      spbl25              ;Jump if not enough memory to split
        jnz     spbl30              ;if there is some remaining memory, then
        cmp     cx,0                ; we have additional work to do
        jnz     spbl30
;
; There is no remaining memory.  Free the selector that we allocated
; earlier and then get out.
spbl25: mov     ax,si
        pop     dx                  ;Recover old size
        pop     cx
        mov     word ptr [cbBlkLen],cx ;restore the old block length
        mov     word ptr [cbBlkLen+2],dx
        call    FreeSelector
        jmp     spbl90
;
; We need to create a segment descriptor for the new memory block header
; for the remainder block.
spbl30: add     sp,4                ;Dispose of unneeded recovery data
        push    cx                  ;save memory block length for later
        push    dx
        mov     ax,es               ;selector of current memory header
        call    GetSegmentAddress
        mov     cx,CB_MEMHDR - 1
        add     dx,word ptr [cbBlkLen]  ;bump by size of current block
        adc     bx,word ptr [cbBlkLen+2]
        add     dx,CB_MEMHDR        ;plus size of block header
        adc     bx,0
        mov     ax,si
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>
        pop     dx
        pop     cx
;
; Now, we need to build a new memory block header for the remainder of
; the original block.  CX,DX has the size of the new block.
        push    ds
;
        mov     ds,si
        assume  ds:NOTHING          ;DS points at new block header
        assume  es:NOTHING          ;ES points at old block header
        xor     ax,ax
        mov     ds:[fBlkStatus],al
        mov     ds:[cselBlkData],al
        mov     ds:[selBlkData],ax
        mov     ds:[selBlkOwner],ax
        mov     ds:[selBlkHdr],ds
        mov     word ptr ds:[cbBlkLen],cx
        mov     word ptr ds:[cbBlkLen+2],dx
        mov     ds:[selBlkPrev],es
        mov     ax,es:[selBlkNext]
        mov     ds:[selBlkNext],ax
        mov     es:[selBlkNext],si
        mov     ds,ax               ;DS points at following block
        mov     ds:[selBlkPrev],si
        cmp     ds:[selBlkOwner],0  ;is it in use?
;
        pop     ds
        assume  ds:DGROUP
        jnz     spbl90              ;Jump if the following block is not free
;
; The following memory block is free.  We need to combine it with the
; current one.
        mov     es,si
        call    SpliceBlocks
;
; All done
spbl90: pop     es
        pop     si
        pop     dx
        pop     cx
        pop     bx
        ret

; -------------------------------------------------------
;   GetBlockHeader  -- This function will return the selector
;       for the block header of the specified memory data
;       block.
;
;   Input:  AX      - selector of the data block
;   Output: AX      - selector of the block header
;   Errors: returns CY set if the entry selector doesn't point
;           to a valid data block
;   Uses:   AX, all other registers preserved
;           Modifies the descriptor for segment SEL_SCR0

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

GetBlockHeader:
        push    bx
        push    cx
        push    dx
        push    es

        push    ax                  ;save entry value for later
        mov     bx,SEL_SCR0 or STD_TBL_RING
        call    DupSegmentDscr      ;duplicate input descriptor to scratch
        mov     ax,bx
        call    GetSegmentAddress
        sub     dx,CB_MEMHDR        ;backup to supposed header
        sbb     bx,0
        mov     cx,CB_MEMHDR-1      ;  has the proper limit!
        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

        mov     es,ax
        assume  es:MEMHDR

        pop     cx                  ;recover data block selector
        cmp     cx,[selBlkData]     ;does the header point back to the
        jz      gtbh50              ; data block.

        stc                         ;if not, then what were given wasn't a
        jmp     short gtbh90        ; selector to a memory block

gtbh50: mov     ax,[selBlkHdr]      ;get the real selector to the header

gtbh90: pop     es
        pop     dx
        pop     cx
        pop     bx
        ret

; -------------------------------------------------------
;   DisposeBlock        -- This routine will free all segment
;       descriptors associated with the specified memory block,
;       and remove the block header from the heap list.
;
;   Input:  AX      - selector of block to dispose
;   Output: none
;   Errors: none
;   Uses:   All registers preserved
;
; NOTE: This routine frees selectors for the specified memory block.
;       If this selector is already in a segment register when this
;       routine is called a GP fault will occur it that segment
;       register is later saved or restored.  Also, any references to
;       memory using that segment register might destroy random data
;       in memory.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  DisposeBlock

DisposeBlock:
        push    cx
        push    si
        push    di
        push    es
;
; Remove the block header from the heap list.
        mov     es,ax               ;header selector to ES
        mov     si,es:[selBlkNext]  ;SI points to following block
        mov     di,es:[selBlkPrev]  ;DI points to previous block
        mov     es,di               ;ES points to previous block
        mov     es:[selBlkNext],si  ;previous block points to following block
        mov     es,si               ;ES points to following block
        mov     es:[selBLkPrev],di  ;following block points back to prev. block
;
; Free any data block descriptors associated with this memory object.
        mov     es,ax
        cmp     es:[selBlkOwner],0
        jz      dspb40
        xor     ch,ch
        mov     cl,es:[cselBlkData]
        mov     ax,es:[selBlkData]
        and     ax,SELECTOR_INDEX   ;treat as GDT FreeSelectorBlock
        call    FreeSelectorBlock
;
; Free the descriptor for the block header.
dspb40: mov     ax,es
        pop     es
        call    FreeSelector
;
; All done
dspb90: pop     di
        pop     si
        pop     cx
        ret

; -------------------------------------------------------
;   SetUpDataDescriptors -- This function will initialize
;       all of the data segment descriptors associated with
;       a block. Those that should point to data will be
;       initialized accordingly. Those corresponding to
;       addresses beyond the allocated data will be initialized
;       as not present. If insufficient data segment
;       descriptors have been allocated, an attempt
;       will be made to allocate them. If this fails an error
;       occurs.
;
;   Input:  AX  -   Selector of the header segment.
;
;   Output: None
;
;   Errors: Returns CY set if not enough data segment descriptors
;           are available.
;
;   Uses:   Segment descriptor table is modified. Possibly the
;           data segment count in the header is modified.
;           No registers affected.
;
    assume  ds:DGROUP,es:NOTHING,ss:NOTHING

    public  SetUpDataDescriptors

SetUpDataDescriptors:
        push    es
        push    si
        push    bx
        push    cx
        push    dx
        push    ax

        mov     es,ax
        mov     si,ax               ;save header segment for dup
        assume  es:MEMHDR
        mov     bx,selBlkData       ;Starting data selector index
        and     bx,SELECTOR_INDEX
        xor     cx,cx
        mov     cl,cselBlkData      ;Load segment count
        inc     cx
        mov     dx,word ptr es:[cbBlkLen+2] ;Full data segment count
        mov     es,selGDT
        assume  es:NOTHING
sudd30:
        or      dx,dx                   ;is this the last segment?
        jnz     sudd35
        pop     es                      ;Get the header segment
        push    es
        cmp     word ptr es:[cbBlkLen],0 ;Test partial length
        mov     es,selGDT               ;Rebase the global descriptor table
        jnz     sudd35                  ;Jump if the partial length is 0
        jmp     sudd60
sudd35: loop    short sudd40            ;Out of segments?
        xchg    bx,ax
        call    RemoveFreeDescriptor    ;Attempt to get segment
        xchg    bx,ax
        jnc     sudd37
        jmp     sudd80
sudd37: inc     cx
sudd40: mov     ax,si
        call    DupSegmentDscr          ; replicate the previous seg (in si)
        mov     si,bx

; Set the DPL of allocated blocks to user DPL

ifndef WOW_x86
        mov     es:[si].arbSegAccess,STD_DATA
else
        push    ax
        xor     ax,ax
        mov     ah,es:[si].cbLimitHi386
        or      ax,STD_DATA
        cCall   NSetSegmentAccess,<si,ax>
        pop     ax
endif

; Increment the segment start address past the previous one

        cmp     es:[si].cbLimit,CB_MEMHDR-1  ; Is this the first block?
        jne     sudd41                       ; No - jump
ifndef WOW_x86
        add     es:[si].adrBaseLow,CB_MEMHDR ; bump segment start to point
        adc     es:[si].adrBaseHigh,0        ;past the block header
else
        push    ax
        push    dx
        mov     ax,es:[si].adrBaseLow
        mov     dl,es:[si].adrBaseHigh
        mov     dh,es:[si].adrbBaseHi386
        add     ax,CB_MEMHDR
        adc     dx,0
        cCall   NSetSegmentBase,<si,dx,ax>
        pop     dx
        pop     ax
endif
        jmp     short sudd42
ifndef WOW_x86
sudd41: add     es:[si].adrBaseHigh,1        ; bump segment start by 64k
else
sudd41: push    ax
        push    dx
        mov     ax, es:[si].adrBaseLow
        mov     dl, es:[si].adrBaseHigh
        mov     dh, es:[si].adrbBaseHi386
        inc     dx
        cCall   NSetSegmentBase,<si,dx,ax>
        pop     dx
        pop     ax
endif

; Set the segment length

sudd42: add     bx,8                    ; Offset of next segment descriptor
        or      dx,dx                   ; Was this a partial segment?
        jnz     sudd45                  ; jump if not
;
; We are at the partial (<64k) chunk at the end.
        pop     es                      ;Get the header segment
        push    es
        mov     dx,word ptr es:[cbBlkLen] ; Segment length
        dec     dx                      ; Last legal offset
        mov     es,selGDT
        mov     es:[si].cblimit,dx      ; Store in segment descriptor
ifdef WOW_x86
        cCall   NSetSegmentLimit,<si>
endif
        jmp     sudd60                  ; All valid data segs now exist
sudd45:
        mov     es:[si].cbLimit,0FFFFh  ;set segment limit at 64k
ifdef WOW_x86
        cCall   NSetSegmentLimit,<si>
endif
        dec     dx                      ; On to the next data segment
        jmp     sudd30
;
; Invalidate remaining segments
sudd50: mov     ax,si
        call    DupSegmentDscr          ; replicate the previous one and
        mov     si,bx
        mov     word ptr es:[si].arbSegAccess,0 ; Invalidate the segment
        add     bx,8                    ; Offset of next segment descriptor
sudd60: loop    sudd50
;
; All done
        clc
        jmp     short sudd90
;
; Allocate of a segment descriptor failed.
sudd80: pop     ax                      ;Header Segment
        mov     es,ax                   ;
        mov     dx,es:selBlkData        ;Calculate # segments
        and     dx,SELECTOR_INDEX       ;  successfully allocated
        sub     bx,dx
        shr     bx,3                    ;Succesfully allocated
        mov     es:[cselBlkData],bl     ;Store new value
        mov     dx,bx                   ;Return max allocatable space
        mov     cx,0                    ;
        add     sp,4                    ;Pop redundant stack data
        stc                             ;Flag error
        jmp     short sudd100           ;Join common exit code
;
; Tidy up
sudd90: pop     ax                      ;Header segment
        mov     es,ax
        mov     dx,es:selBlkData        ;Calculate # segments
        and     dx,SELECTOR_INDEX
        sub     bx,dx
        shr     bx,3
        mov     es:[cselBlkData],bl     ;Store new value
        pop     dx
        pop     cx
sudd100:
        pop     bx
        pop     si
        pop     es
        ret
;
ifdef MD

; -------------------------------------------------------
;   CheckXmemHeap    -- This routine will check the integrity
;                       of the chain of block headers.
;
;   Input:  NONE
;   Output: None
;   Errors: INT3 If an error is found
;   Uses:   All registers preserved
;
;   NOTE:   This routine must be called in protected mode.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  CheckXmemHeap

CheckXmemHeap:
        push    bp
        mov     bp,sp
        pushf
        push    bx
        push    cx
        push    dx
        push    es
        xor     cx,cx
        mov     dx,cx
        mov     bx,selHeapStart ; Load start of chain
cxmh100:
        or      bx,bx           ;
        jnz     cxmh101
        jmp     cxmh200         ;
cxmh101:
        mov     es,bx           ;
        assume  es:MEMHDR       ;
        cmp     selBlkHdr,bx    ;
        je      cxmh110         ;
        int     3
        jmp     cxmh200
;;        Debug_Out "CheckXmemHeap: Block header does not point to block header!"
cxmh110:
        cmp     selBlkPrev,dx   ;
        je      cxmh120         ;
        int     3
        jmp     cxmh200
;;        Debug_Out "CheckXmemHeap: Previous block does not point to previous block!"
cxmh120:
        mov     dx,bx           ;
        mov     bx,selBlkNext   ;
        loop    cxmh100         ;
        int     3
;;        Debug_Out "CheckXmemHeap: Can't find end of arena chain!"
cxmh200:
        pop     es
        pop     dx
        pop     cx
        pop     bx
        popf
        pop     bp
        ret
endif

; -------------------------------------------------------
;   FreeMemByOwner -- This routine frees all of the mem
;       blocks that belong to the specified owner.
;
;   Input:  bx = owner
;   Output: none
;   Uses:   ax
;
;  Note:  We have to start at the beginning of the heap
;       after we free a block, because the free may
;       coalesce the heap, and the selector for the
;       next block may no longer be correct.  We know we
;       are done when we have traversed the entire heap,
;       and not found a block to free.

        assume ds:DGROUP, es:nothing, ss:nothing
        public FreeMemByOwner

FreeMemByOwner:
        push    es
        push    cx

        cmp     bx,0                    ; owner is free owner??
        je      fbo40

; First traverse xmem heap
        push    selHeapStart
        mov     ax,selHiHeapStart
        mov     selHeapStart,ax

        call    FreeHiMemByOwnerW
        call    FreeLowMemByOwnerW
        pop     selHeapStart


fbo40:
        pop     cx
        pop     es
        ret

FreeHiMemByOwnerW:
fhbow10: mov     ax,selHiHeapStart
fhbow20: cmp     ax,0
        je      @f
        lar     cx, ax                  ;is this a valid selector?
        jz      fhbow25                 ;yes, go ahead
@@:
        ret

fhbow25: mov     es,ax
        assume es:MEMHDR
        cmp     selBlkOwner,bx
        jne     fhbow30

        mov     ax,selBlkDAta
        push    0
        pop     es
        call    FreeXmemBlock
        jmp     fhbow10                   ; check again.

fhbow30: mov     ax,selBlkNext           ; check next block
        jmp     fhbow20

FreeLowMemByOwnerW:
flbow10: mov     ax,selLowHeapStart
flbow20: cmp     ax,0
        je      @f
        lar     cx, ax                  ;is this a valid selector?
        jz      flbow25                 ;yes, go ahead
@@:
        ret

flbow25: mov     es,ax
        assume es:MEMHDR
        cmp     selBlkOwner,bx
        jne     flbow30

        mov     ax,selBlkData
        push    0
        pop     es
        call    FreeLowBlock
        jmp     flbow10                   ; check again.

flbow30: mov     ax,selBlkNext           ; check next block
        jmp     flbow20
; -------------------------------------------------------
; -------------------------------------------------------
; -------------------------------------------------------
; -------------------------------------------------------
; -------------------------------------------------------

DXPMCODE  ends
;
;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxstrt.asm ===
PAGE    ,132
        TITLE   DXSTRT.ASM -- Dos Extender Startup Code

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXSTRT.ASM      -   Dos Extender Startup Code           *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains the executive initialization code for  *
;*  the Dos Extender.  The module DXBOOT.ASM contains the code  *
;*  specific to starting up the Dos Extender.  The module       *
;*  DXINIT.ASM contains the code specific to starting up the    *
;*  child program of the Dos Extender.  The code in these       *
;*  two modules is discarded at the end of the initialization.  *
;*  The code in this module calls the initialization routines   *
;*  in the other to init modules, and then performs the final   *
;*  juggling of things to throw away the low memory init code,  *
;*  and transfer control to start up the child program.         *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  01/09/91 amitc  At exit time Co-Processor being reset       *
;*  08/08/90 earleh DOSX and client privilege ring determined   *
;*      by equate in pmdefs.inc                                 *
;*  12/08/89 jimmat  Added call to reenable EMM driver.         *
;*  08/29/89 jimmat  Restores Int 2Fh vector at exit            *
;*  08/20/89 jimmat  Removed A20 code, since HIMEM version 2.07 *
;*                   A20 code now works properly.               *
;*  06/28/89 jimmat  Now calls OEM layer instead of NetMapper   *
;*  06/16/89 jimmat  Implemented Windows/386 startup/exit Int   *
;*                   2Fh calls and ifdef'd combined EXE code    *
;*  05/17/89 jimmat  ChildTerminationHandler sets its SS:SP     *
;*  04/18/89 jimmat  Added calls to init/term NetBIOS mapper    *
;*  03/28/89 jimmat  Incorporated bug fix from GeneA related    *
;*                   to nested GP faults in ChildTermHandler    *
;*  03/11/89 jimmat  Added support for TSS & LDT                *
;*  03/07/89 jimmat   converted to use WDEB386                  *
;*  02/27/89 (GeneA): shrink initial memory block size on entry *
;*  02/25/89 (GeneA): added support for combined exe file where *
;*      the Dos Extender and the child reside in the same exe   *
;*      file.                                                   *
;*  02/17/89 (GeneA): fixed error termination code for startup  *
;*      errors that occur while in protected mode               *
;*  02/14/89 (GeneA): added code to reduce size of real mode    *
;*      code segment to throw away initialization code.         *
;*  01/31/89 (GeneA):   created by copying code from the old    *
;*      DXINIT.ASM                                              *
;*  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;****************************************************************

.286p

; -------------------------------------------------------
;               INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

.sall
.xlist
include segdefs.inc
include gendefs.inc
include pmdefs.inc

include hostdata.inc
include dpmi.inc
include intmac.inc
.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


WIN386_INIT     equ     1605h           ;Win/386 startup Int 2Fh
WIN386_EXIT     equ     1606h           ;Win/386 shutdown Int 2Fh

WIN386_DOSX     equ     0001h           ;Win/386 init/exit really DOSX flag


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   InitDosExtender:NEAR
        extrn   RestoreRMIntrVectors:NEAR
        extrn   SaveRMIntrVectors:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   InitializeOEM:NEAR
        extrn   TerminateOEM:NEAR
externNP        NSetSegmentAccess
        extrn   DupSegmentDscr:NEAR

        extrn   EMMEnable:NEAR

ifdef WOW_x86
        externFP NSetSegmentDscr
else
        externFP NSetGDTSegmentDscr
ENDIF; WOW_x86

        extrn   PMIntr19:NEAR
        extrn   PMIntr13:NEAR
        extrn   PMIntr31:NEAR
        extrn   PMIntr28:NEAR
        extrn   PMIntr25:NEAR
        extrn   PMIntr26:NEAR
        extrn   PMIntr4B:NEAR
        extrn   PMIntrDos:NEAR
        extrn   PMIntrMisc:NEAR
        extrn   PMIntrVideo:NEAR
        extrn   PMIntrMouse:NEAR
        extrn   PMIntrIgnore:NEAR
        extrn   PMIntrEntryVector:NEAR
        extrn   PMFaultEntryVector:NEAR
ifdef      NEC_98    ;
        extrn   PMIntr11dummy:NEAR
        extrn   PMIntrPrinter:NEAR
        extrn   PMIntrCalTi:NEAR
        extrn   PMIntrGraph:NEAR
endif   ;NEC_98   ;

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

; -------------------------------------------------------

DXDATA  segment
        extrn   A20EnableCount:WORD
        extrn   lpfnUserMouseHandler:DWORD
        extrn   lpfnUserPointingHandler:DWORD
        extrn   f286_287:BYTE

        extrn   cDPMIClients:WORD
        extrn   selCurrentHostData:WORD
        extrn   segCurrentHostData:WORD

ifdef WOW_x86
        extrn   FastBop:fword
endif
        extrn   DpmiFlags:WORD

        org     0

        public  rgwStack,npEHStackLimit,npEHStacklet, selEHStack,
;
; Pmode fault handler stack used during initialization only.
;
            dw      80h dup (?)
rgwStack    label   word

;
; This is the stack area used while running in the interrupt reflector.
; This is divided up into a number of stack frames to allow reentrant
; execution of the interrupt reflector.  The stack pointer pbReflStack
; indicates the current stack frame to use.  Each entry into the interrupt
; reflector decrements this variable by the size of the stack frame, and
; each exit from the interrupt reflector increments it.

C_STKFRAME      =   36
CB_REFLSTACK    =   C_STKFRAME * CB_STKFRAME

if  DEBUG       ;--------------------------------------------------------
        public  StackGuard
StackGuard      dw  1022h       ;unlikely value to check for stk overrun
endif           ;--------------------------------------------------------

        public  pbReflStack,bReflStack
if DBG
bReflStack      db  CB_REFLSTACK dup (0AAh)
else
bReflStack      db  CB_REFLSTACK dup (?)
endif

;----------------------------------------------------------------------------
; The following stack is used for hw interrupts while booting where
; the kernel or ntvdm switches the stack before an interrupt is reflected.
;----------------------------------------------------------------------------
CB_HWINTRSTACK  =   1000h
if DBG
bHwIntrStack    db  CB_HWINTRSTACK dup (0AAh)
else
bHwIntrStack    db  CB_HWINTRSTACK dup (?)
endif
        public  pbHwIntrStack
pbHwIntrStack   dw  bHwIntrStack + CB_HWINTRSTACK

pbReflStack     dw  bReflStack + CB_REFLSTACK

npEHStackLimit  dw      offset DGROUP:rgwStack
npEHStacklet    dw      offset DGROUP:rgwStack
selEHStack      dw      0

        public  cdscGDTMax, selGDTFree, segGDT, selGDT

cdscGDTMax      dw      CDSCGDTDEFAULT

selGDTFree      dw      ?       ;head of list of free descriptors in GDT

segGDT          dw      0       ;real mode paragraph address of the GDT
                                ; This variable always stores the real mode
                                ; paragraph address

selGDT          dw      0       ;current mode segment/selector for the GDT
                                ; segment.  This variable holds the real
                                ; mode paragraph address during initialization
                                ; and then holds the protected mode selector
                                ; when running in protected mode.

        public  bpGDT, bpGDTcb, bpGDTbase

bpGDT           label   fword
bpGDTcb         dw      ?
bpGDTbase       dd      ?


        public  segIDT, selIDT

segIDT          dw      0
selIDT          dw      0

        public  bpIDT, bpIDTcb, bpIDTbase

bpIDT           label   fword
bpIDTcb         dw      ?
bpIDTbase       dd      ?

        public  bpRmIVT

bpRmIVT         dq      0FFFFh  ;This is the segment descriptor for the real
                                ; mode interrupt vector table.

        public  lpfnXMSFunc

lpfnXMSFunc     dd      0       ;far pointer to XMS memory driver entry point

        public  idCpuType

idCpuType       dw      0

        public  segPSP, selPSP

segPSP          dw      ?       ;segment address of Dos Extender PSP
selPSP          dw      ?       ;selector for Dos Extender PSP
                                ; code during processing of GP faults

        public  selPSPChild, segPSPChild

segPSPChild     dw      ?       ;real mode segment address of child's PSP
; note the following in 1, so that in low mem heap management, we can use
; selPSPChild to mark the owner of the memory.
selPSPChild     dw      1       ;selector of child program's PSP


        public  DtaSegment, DtaOffset, DtaSelector
DtaSegment dw 0
DtaSelector dw 0
DtaOffset dw 0


        public  regChildSP,  regChildSS,  regChildIP,  regChildCS

regChildSP      dw      ?       ;initial user stack pointer from exe file
regChildSS      dw      ?       ;initial user stack segment from exe file
regChildIP      dw      ?       ;initial user program counter from exe file
regChildCS      dw      ?       ;initial user code segment from exe file

        public  hmemDOSX

hmemDOSX        dw      0

IFDEF   ROM
                public  segDXCode, segDXData

segDXCode       dw      ?               ;holds real mode paragraph address
                                        ; of the code segment
segDXData       dw      ?               ;holds real mode paragraph address
                                        ; of the data segment
ENDIF

ifdef      NEC_98
        public  fPCH98

fPCH98          db      0       ;NZ if running on a Micro Channel system

        public  fNHmode

fNHmode         db      0       ;NZ if running on a Hmode system
endif   ;!NEC_98
        public  fFaultAbort, ExitCode

fFaultAbort     db      0       ;NZ if terminating due to unrecoverable fault
ExitCode        db      0FFh    ;exit code to use when terminating
fQuitting       db      0

fEMbit          db      0FFh    ;MSW EM bit at startup (FF = not checked yet)

        public fUsingHMA
fUsingHMA       db      0

; The one and only Task State Segment is here (it's too small to allocate
; a block for it in extended memory)

        public  sysTSS

sysTSS  TSS286  <>

; After initialization is complete, the following buffers (rgbXfrBuf0 and
; rgbXfrBuf1) are used to transfer data between real mode address space
; and protected mode address space during the processing of various interrupt
; function calls.  During the initialization process, these buffers are also
; used as temporary work space as described below:
;   CheckCPUType uses the first 6 bytes of rgbXfrBuf0 as scratch space.
;   The functions for moving the Dos Extender protected mode code segment
;   and the GDT and IDT use rgbXfrBuf0 as buffer space for building a
;   parameter block.  The child loading code in DXINIT.ASM uses the buffer
;   RELOC_BUFFER for holding the base part of the file name (name.exe portion)
;   of the child exe file while determining the complete path to the child
;   in the case where the child name is specified on the command line.  Note,
;   this buffer is also used for holding sectors from the relocation table
;   while loading the program, but that occurs after the child exe file name
;   has been determined.
;   The child loading code in DXINIT.ASM also uses rgbXfrBuf1 to hold several
;   buffers as well.  The locations and purposes of these buffers are
;   described in GENDEFS.INC.  All of the buffers are defined with equates
;   named EXEC_?????
;
;   The file search logic in DXFIND.ASM assumes some parameters are setup in
;   the rgbXfrBuf1 file name buffers.  Some of the code was moved from
;   DXINIT.ASM to DXFIND.ASM.

        public      rgbXfrBuf0, rgbXfrBuf1
        public      npXfrBuf0,  npXfrBuf1

        align       2

rgbXfrBuf0  db      CB_XFRBUF0 dup (?)
rgbXfrBuf1  db      CB_XFRBUF1 dup (?)

npXfrBuf0   dw      offset DGROUP:rgbXfrBuf0
npXfrBuf1   dw      offset DGROUP:rgbXfrBuf1

DtaBuffer   dw      128 dup (0) ; used as the dta for PM if dta changed

; Parameter block for passing to DOS EXEC call to run the child
; program.
;
public  exec_par_blk

exec_par_blk    dw  0
cmd_off         dw  OFFSET EXEC_CMNDLINE
cmd_seg         dw  DXDATA
                dw  OFFSET EXEC_FCB0
fcb1_seg        dw  DXDATA
                dw  OFFSET EXEC_FCB1
fcb2_seg        dw  DXDATA


; The following variables are used during reading the relocation table
; from the exe file and relocating the child program.

        public  fhExeFile
        public  clpRelocItem
        public  plpRelocItem

fhExeFile       dw      ?       ;DOS file handle for the exe file
clpRelocItem    dw      ?       ;number of relocation items in the exe file
plpRelocItem    dw      ?       ;pointer to next relocation item in the table

szDebugHello    label   byte
if      DEBUG
        db      'DOSX: Beginning protected mode initialization.',13,10,0
endif
        db      0

FreeMem dw      0

DXDATA  ends

; -------------------------------------------------------
        page
; -------------------------------------------------------
;               CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   CodeEnd:NEAR
        extrn   ER_DXINIT:BYTE
        extrn   ER_REALMEM:BYTE
        extrn   RMDefaultInt24Handler:FAR

        public  segDXCode, segDXData, selDgroup

segDXCode       dw      ?       ;holds the real mode paragraph address
                                ; of the code segment
segDXData       dw      ?       ;holds the real mode paragraph address
                                ; of the data segment

selDgroup       dw      ?       ;holds the paragraph address/selector for
                                ; DGROUP depending on the current mode

        public  PrevInt2FHandler

PrevInt2FHandler dd     ?       ;previous real mode Int 2F handler

DXCODE  ends


DXPMCODE    segment

        extrn   CodeEndPM:NEAR

        org     0

        public  selDgroupPM, segDXCodePM, segDXDataPM

selDgroupPM     dw      ?       ;This variable always contains the
                                ; data segment selector
segDXCodePM     dw      ?       ;This variable contains the paragraph
                                ; address of the real mode code segment
segDXDataPM     dw      ?       ;This variable contains the paragraph
                                ; address of the data segment
externFP        NSetSegmentDscr

DXPMCODE    ends

; -------------------------------------------------------

BeginLowSegment

; -------------------------------------------------------
;               DOS EXTENDER ENTRY FUNCTION
; -------------------------------------------------------
;
; This is the program entry point for the Dos Extender.  This
; function decides if the Dos Extender is being run as a single
; time operation to extend a single program, or if it is being
; run as a TSR to wait for programs to request its services
; later on.
;

        assume  ds:PSPSEG,es:PSPSEG,ss:NOTHING
        public  start

start:

; Set up the initial segment registers.

        mov     ax,DGROUP
        mov     ds,ax
        assume  ds:DGROUP

        mov     segPSP,es       ;save the PSP segment address

        mov     ss,ax
        mov     sp,offset DGROUP:rgwStack
        assume  ss:DGROUP

;
; Set up the INT 24h handler.  The default INT 24h handler fails the
; system call in progress, for DPMI compatibility.
;

        push    ds
        mov     ax,cs
        mov     ds,ax
        mov     dx,offset DXCODE:RMDefaultInt24Handler
        mov     ax,2524h
        int     21h
        pop     ds

; Issue the Win/386 startup Int 2Fh (almost) first thing

        push    ds

        mov     ax,WIN386_INIT  ;gives other PM software a chance
        xor     bx,bx           ;  to disable itself, release XMS, etc.
        mov     cx,bx
        mov     si,bx
        mov     ds,bx
        mov     es,bx
        assume  ds:NOTHING, es:NOTHING
        mov     dx,WIN386_DOSX
        mov     di,DXVERSION
        int     2Fh

        pop     ax              ;restore ds/es DGROUP addressability
        mov     ds,ax
        mov     es,ax
        assume  ds:DGROUP, es:DGROUP


        jcxz    Allow_Startup   ;if cx still == 0, keep going (we ignore
                                ;  all the other possible return values)

        mov     ExitCode,2      ;  otherwise we should abort now
        jmp     RealModeCleanUp

Allow_Startup:

; Initialize the Dos Extender

        call    InitDosExtender         ;NOTE: passes data to InitChildProgram
        jnc     @F                      ;  in rgbXfrBuf1 -- don't overwrite it!
        jmp     strt88
@@:

; Save the state of the MSW EM bit (Emulate Math coprocessor), and turn
; it off (win87em wants it off).

ifndef WOW_x86
        smsw    ax

        out1    <What to do about this?>

        test    al,01h                  ;in V86 mode?
        jnz     @f                      ;  can't do the lmsw if so

        push    ax
        and     al,04h
        mov     fEMbit,al
        pop     ax
        and     al,not 04h
        lmsw    ax
@@:
endif ; WOW_x86
; Switch the machine into protected mode.

        FCLI
        call    SaveRMIntrVectors

        SwitchToProtectedMode

        public  DXPMInit
DXPMInit        LABEL   BYTE

if      DEBUG
        Trace_Out "*******************************************************************************"
        Trace_Out "*******************************************************************************"
        Trace_Out "****                                                                       ****"
        Trace_Out "****            THIS IS A DEBUG RELEASE THIS IS A DEBUG RELEASE            ****"
        Trace_Out "****                                                                       ****"
        Trace_Out "*******************************************************************************"
        Trace_Out "*******************************************************************************"
endif

        assume  ds:DGROUP,es:NOTHING

        mov     ax,SEL_IDT or STD_RING
        mov     selIDT,ax
        mov     ax,SEL_LDT_ALIAS OR STD_RING
        mov     selGDT,ax

; Initialize the LDT now that we are in protected mode.  First, set the
; contents to zero.

        mov     es,selGDT               ; actually LDT
        assume  es:NOTHING
        mov     cx,cdscGDTMax
IFDEF WOW
        mov     di,GDT_SIZE
        sub     cx,di
ENDIF
        shl     cx,2                    ; CX = words in LDT segment
        xor     ax,ax                   ; AX = 0
IFNDEF WOW
        mov     di,ax
ENDIF
        cld
        rep     stosw                   ; CX = 0

        dec     cx                      ; CX = 0FFFFh

        push    ax
        push    cx
        mov     ax,es                   ; LDT selector
        lsl     cx,ax                   ; LDT size
        mov     di,SEL_USER and SELECTOR_INDEX
        DPMIBOP InitLDT
        pop     cx
        pop     ax

;
; Set the two scratch selectors to 64k data starting at zero.  Actual
; addresses set as used.
;
        cCall   NSetSegmentDscr,<SEL_SCR0,ax,ax,ax,cx,STD_DATA>
        cCall   NSetSegmentDscr,<SEL_SCR1,ax,ax,ax,cx,STD_DATA>
ifndef WOW_x86
        mov     dx,40h*16
        cCall   NSetGDTSegmentDscr,<040h,ax,dx,ax,cx,STD_DATA>
endif

; Bop to initialize 32 bit support.

        push    es
        mov     ax,SEL_DXCODE OR STD_RING
        mov     es,ax
        assume  es:DXCODE
        mov     di, sp                          ;original stack offset

        push    ds
        push    offset DGROUP:DtaBuffer
        push    ds
        push    offset DGROUP:pbReflStack
        push    ds
        push    offset DGROUP:rgbXfrBuf1
        push    ds
        push    offset DGROUP:rgbXfrBuf0

        mov     si,sp                           ;pass stack offset
        FBOP    BOP_DPMI,InitDosx,FastBop
        mov     sp, di                          ;restore stack
        pop     es
        assume es:nothing

        call    AllocateExceptionStack
        FSTI                             ;don't need ints disabled

; Shrink the size of our real mode code segment to throw away init code.

        SwitchToRealMode

        mov     bx,(offset CodeEnd) + 15
        shr     bx,4
        add     bx,segDXCode
        sub     bx,segPSP
        push    es
        mov     es,segPSP
        dossvc  4Ah
        pop     es

        call    DetermineFreeMemory
        mov     FreeMem,bx
        SwitchToProtectedMode

; Initialize the OEM layer.  This can allocate DOS memory, so it goes
; after the final program shrink.

        call    InitializeOEM           ;currently initializes NetBIOS mapper

if1
%OUT    InitializeOEM can fail!!!!!
endif

        FBOP    BOP_DPMI,ResetLDTUserBase,FastBop

; Exec the child application

        SwitchToRealMode
        FSTI
;; bugbug hack ...... williamh
;; turn off A20 line before we terminate and keep resident.
        cmp     A20EnableCount, 0
        jz      A20IsOff
@@:
        xmssvc  6
        dec     A20EnableCount
        jnz     @B
A20IsOff:

        mov     ax,segPSP
        mov     es,ax
        assume es:nothing
        mov     ax,es:[2ch]
        mov     es,ax
        dossvc  49h                     ; free env block

        call    DetermineFreeMemory
        mov     dx,(offset CodeEnd) + 15
        shr     dx,4
        add     dx,FreeMem
        sub     dx,bx
        add     dx,segDXCode
        sub     dx,segPSP
        mov     al,0
        dossvc  31h                     ; tsr.
help:   int     3                       ; should never get here
        jmp     help

        lea     bx, exec_par_blk
        lea     dx, EXEC_PROGNAME
        xor     al, al
        dossvc  4bh

; If we get here, the EXEC failed for some reason!

        mov     bx,offset DXCODE:ER_REALMEM     ;assume insufficient memory
        xchg    ax,bx
        cmp     bx,8                            ;is it really?
        jz      strt88
        mov     ax,offset DXCODE:ER_DXINIT      ;no, use generic msg

strt88:
        mov     ExitCode,1              ;return NZ exit code

        mov     dx,cs                   ;pass msg ptr in DX:AX (ax already set)

        push    cs                              ;fake a far call so no fixup
        push    offset DXCODE:RealModeCleanUp   ;  needed -- return to clean up
        jmp     near ptr DisplayErrorMsg

; -------------------------------------------------------
;   ChildTerminationHandler --  This routine receives control
;       when the child program running under the Dos Extender
;       terminates.  It will free all resources being used by
;       the child.  If we were not running TSR, then the Dos
;       Extender will complete cleaning up and terminate itself.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

        public  DosxTerminationHandler
DosxTerminationHandler:

        mov     ds,selDgroup
        mov     es,selDgroup
        mov     ss,selDgroup                    ;make sure we know where the
        mov     sp,offset DGROUP:rgwStack       ;  stack is when we get here

        assume  ds:DGROUP,es:DGROUP

; Check if we are already in the middle of a termination sequence and
; bail out if so.  This will prevent us from hanging up in an infinite
; loop if we get a GP fault while we are quitting.

        cmp     fQuitting,0
        jz      @f
        jmp     chtm90
@@:
        mov     fQuitting,1

; Terminate the OEM layer

        call    TerminateOEM    ;current term's NetBIOS mapper & low net heap

; Make sure that no interrupt vectors still point to us.

        call    RestoreRMIntrVectors

; if this is a 80286 & 80287 configuration, we should reset the Co-Processor.

        cmp     [f286_287],0            ;286 and 287 config ?
        jz      CTH_Not286And287        ;no.

; reset the 80287 Co-Processor to make sure that it gets out of protected
; mode.

        xor     al,al                   ;need to out 0
        out     0F1H,al                 ;reset the coprocessor

CTH_Not286And287:

; If we're aborting due to a processor fault, do some extra clean-up on
; the mouse (just to be nice).  If this is a normal termination, we leave
; it up to the child to save/restore the mouse state.

        test    fFaultAbort,0FFh
        jz      normal_exit

; Check if the mouse driver callback function has been set, and
; reset the mouse driver if so.

        mov     ax,word ptr lpfnUserMouseHandler
        or      ax,word ptr lpfnUserMouseHandler+2
        jz      @F
        xor     ax,ax
        int     33h
@@:

; Check if the PS/2 Pointing Device Handler Address has been set and
; disable it if so.

ifndef NEC_98
        mov     ax,word ptr lpfnUserPointingHandler
        or      ax,word ptr lpfnUserPointingHandler+2
        jz      @f
        mov     ax,0C200h
        xor     bh,bh
        int     15h
@@:
endif   ;!NEC_98

; Hmmm, we have HP mouse code in dxhpbios.asm, but no clean up here...

normal_exit:

; Release the extended memory heap.

;        call    ReleaseXmemHeap

; Release the space being used for the descriptor tables and
; the protected mode code segment.

;
; If we have allocated an extended memory block, then free it.
; If we have allocated the HMA, then free it.
;
        mov     dx,hmemDOSX
        or      dx,dx
        jz      @F
        xmssvc  0Dh
        xmssvc  0Ah
@@:
        cmp     fUsingHMA,0
        je      @F
        xmssvc  2
@@:

; Clean up after real mode code (and possible real mode incomplete
; initialization) -- restore real mode interrupt vectors.

chtm90:
RealModeCleanUp:

; Disable A20 if it was left enabled (normally 1 on 386 systems, 0 on 286)

        mov     cx,A20EnableCount
        jcxz    A20Okay
@@:     xmssvc  6
        loop    @b
A20Okay:

; Restore the MSW EM bit (Emulate Math coprocessor) to its initial state
ifndef WOW_x86
        inc     fEMbit          ;if fEMbit = FF, we never got far 'nuff to
        jz      @f              ;  change it
        dec     fEMbit

        smsw    ax
        test    al,01h                  ;in V86 mode?
        jnz     @f                      ;  can't do the lmsw if so
        or      al,fEMbit
        lmsw    ax
@@:
endif
; Make sure DOS knows that the DOS extender is the current process

        mov     bx,segPSP
        dossvc  50h

; Reenable a friendly EMM driver if we disabled it at startup

        call    EMMEnable

; Restore real mode interrupt vectors

        push    ds

        lds     dx,PrevInt2FHandler     ;Int 2Fh handler
        assume  ds:NOTHING

        mov     ax,ds                   ;may not have gotten far enough to
        or      ax,dx                   ;  set interrupt vectors, so make
        jz      @f                      ;  sure before resotring.

        mov     ax,252Fh
        int     21h

@@:
        pop     ds
        assume  ds:DGROUP


; We have cleaned up after ourselves, so now we can quit.

        mov     ax,WIN386_EXIT  ;use Win/386 exit Int 2Fh to tell any
        mov     dx,WIN386_DOSX  ;  interested parties that we are
        int     2Fh             ;  terminating

        mov     al,ExitCode     ;exit the extender with either the exit
        cmp     al,0FFH         ;  status from the child, or a status
        jnz     @f              ;  that we have forced
        dossvc  4Dh             ;get child exit status if we haven't forced it
@@:
ifdef      NEC_98
        push    ax
        push    es                      ; Dec IN_BIOS(0:456)
        mov     ax, 0040h
        mov     es, ax
        test    byte ptr es:[0], 20h    ; check suspend/redume
        jz      @f
        dec     byte ptr es:[056h]      ; for Y55
@@:
        pop     es
        pop     ax
endif   ;NEC_98
        dossvc  4Ch             ;say goodnight Gracy...

; -------------------------------------------------------
;   ChildTerminationHandler --
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  ChildTerminationHandler

ChildTerminationHandler:
        sub     sp,4                            ; room for far ret
        push    ds
        push    es
        pusha
        mov     si,ss
        mov     di,sp

        mov     ds,selDgroup
        mov     es,selDgroup
        mov     ss,selDgroup                    ;make sure we know where the

        mov     sp,offset DGROUP:rgwStack       ;  stack is when we get here

        assume  ds:DGROUP,es:DGROUP

        ;bugbug less than zero?
        dec     cDPMIClients

        ; free xmem allocated to this client
        SwitchToProtectedMode

        mov     dx, selPspChild
        FBOP    BOP_DPMI,TerminateApp,FastBop

        test    DpmiFlags,DPMI_32BIT
        jz      cth05

;
; Return the stack frame used by the Wow32Intr16 interrupt handler
;
        add     pbReflStack,CB_STKFRAME
cth05:  cmp     cDPMIClients,0
        jne     cth10

;
; Reset the exception stack pointer to indicate free'd memory
;
        mov     selEHStack,0

;
; Give back the xms memory
;
        FCLI

        call    ReInitIdt
        push    0
        pop     es
        call    ReInitGdt
        FBOP    BOP_DPMI,DpmiNoLongerInUse,FastBop

cth10:
        SwitchToRealMode

        ;bugbug put resource cleanup code here
        cmp     cDPMIClients,0
        jne     cth20

cth20:  mov     ax,[SegCurrentHostData]
        mov     es,ax
        mov     ax,es:[HdSegParent]
        mov     [SegCurrentHostData],ax
        mov     ax,es:[HdSelParent]
        mov     [SelCurrentHostData],ax
        mov     ax,es:[HdPSPParent]
        mov     SelPSPChild,ax
        mov     ax,word ptr es:[HdPspTerminate + 2]
        mov     bx,word ptr es:[HdPspTerminate]
        mov     cx,segPSPChild
        mov     ds,cx
        assume  ds:nothing
        ;
        ; Restore termination vector (app may think it knows what's here)
        ;
        mov     ds:[0ah],bx
        mov     ds:[0ch],ax
        xor     cx,cx
        mov     ds,cx
        ;
        ; Restore int 22 vector (terminate) Just in case
        ;
        mov     ds:[22h * 4],bx
        mov     ds:[22h * 4 + 2],ax
        mov     es,si
        mov     es:[di+20],bx
        mov     es:[di+22],ax
        mov     ss,si
        mov     sp,di
        popa
        pop     es
        pop     ds
        retf

; -------------------------------------------------------
;  DisplayErrorMsg -- Display an error message on the screen.  We set the
;       video adapter to a text mode so the msg is visable (and gets rid
;       of any bizarre mode that others may have set (like WIN.COM)).
;
;  Note: This routine can be executed in real OR protected mode, so
;        don't do anything mode specific--keep is short and sweet.
;
;  Input:   AX - offset of msg to display
;           DX - segment of msg to display
;  Output:  None.
;  Uses:    AX, DX modified, all else preserved

        assume  ds:NOTHING, es:NOTHING
        public  DisplayErrorMsg

DisplayErrorMsg proc    far

        push    ds              ;save current DS
        push    ax              ;save msg offset

; Set a text mode (normally 3, but possibly 7)

ifdef      NEC_98
        mov     ah,41h          ;
        int     18h
        mov     ah,0Ch          ;
        int     18h
else    ;!NEC_98
        mov     ax,0003h        ;set video mode 3
        int     10h
        mov     ah,0Fh          ;get video mode
        int     10h
        cmp     al,03h          ;did we change to 3?
        jz      @f
        mov     ax,0007h        ;no, must be mode 7
        int     10h
@@:
endif   ;!NEC_98

; Display the msg

        mov     ds,dx
        pop     dx
        dossvc  9

        pop     ds

        ret

DisplayErrorMsg endp

; -------------------------------------------------------
; DetermineFreeMemory -- Determine how much memory is free
;
; Input:   none
; Output:  bx = #paragraphs free memory
; Uses:    bx
;
        assume ds:dgroup,es:nothing
        public DetermineFreeMemory

DetermineFreeMemory proc near
        push    ax
        mov     bx,0ffffh               ; allocate all of memory
        dossvc  48h
        jnc     @f

        pop     ax
        ret

;bugbug report error
@@:     mov     bx,0ffffh
        pop     ax
        ret
DetermineFreeMemory endp
EndLowSegment

DXPMCODE segment
        assume cs:DXPMCODE
;--------------------------------------------------------
; ReInitIdt -- Set Idt entries back to default values
;
; Input:   none
; Output:  none
; uses:    none
;
        assume ds:dgroup,es:nothing
        public ReInitIdt

ReInitIdt proc near

        push    bx
        push    cx
        push    dx
        push    si
        push    di
        push    es
        mov     ax,SEL_IDT OR STD_RING
        mov     es,ax

; Fill the IDT with interrupt gates that point to the fault handler and
; interrupt reflector entry vector.

        xor     di,di

        mov     dx,offset DXPMCODE:PmIntrEntryVector
        mov     cx,256
iidt23: mov     es:[di].offDest,dx
        mov     es:[di].selDest,SEL_DXPMCODE or STD_RING
        mov     es:[di].cwParam,0
        mov     es:[di].arbGate,STD_TRAP   ; BUGBUG- int gates not set up
        mov     es:[di].rsvdGate,0
        add     dx,5
        add     di,8
        loop    iidt23

; Now, fix up the ones that don't point to the interrupt reflector.
IFDEF WOW_x86
        mov     es:[1h*8].offDest,offset PMIntrIgnore
        mov     es:[3h*8].offDest,offset PMIntrIgnore
ifdef      NEC_98
        mov     es:[11h*8].offDest,offset PMIntr11dummy
        mov     es:[18h*8].offDest,offset PMIntrVideo
        mov     es:[1ah*8].offDest,offset PMIntrPrinter
        mov     es:[1bh*8].offDest,offset PMIntr13
        mov     es:[1ch*8].offDest,offset PMIntrCalTi
        mov     es:[1dh*8].offDest,offset PMIntrGraph
        mov     es:[1fh*8].offDest,offset PMIntrMisc
else    ;!NEC_98
        mov     es:[10h*8].offDest,offset PMIntrVideo
        mov     es:[13h*8].offDest,offset PMIntr13
        mov     es:[15h*8].offDest,offset PMIntrMisc
        mov     es:[19h*8].offDest,offset PMIntr19
endif   ;!NEC_98
ENDIF

        mov     es:[21h*8].offDest,offset DXPMCODE:PMIntrDos
        mov     es:[25h*8].offDest,offset DXPMCODE:PMIntr25
        mov     es:[26h*8].offDest,offset DXPMCODE:PMIntr26
        mov     es:[28h*8].offDest,offset DXPMCODE:PMIntr28
        mov     es:[30h*8].offDest,offset DXPMCODE:PMIntrIgnore
        mov     es:[31h*8].offDest,offset DXPMCODE:PMIntr31
        mov     es:[33h*8].offDest,offset DXPMCODE:PMIntrMouse
        mov     es:[41h*8].offDest,offset DXPMCODE:PMIntrIgnore

ifndef WOW_x86
        mov     es:[4Bh*8].offDest,offset DXPMCODE:PMIntr4B
ifdef      NEC_98
;  Sound BIOS Int D2h handler
        mov     es:[0D2h*8].offDest,offset DXPMCODE:PMIntrSound

;  extended DOS Int DCh handler (KANA/KANJI)
        mov     es:[0DCh*8].offDest,offset DXPMCODE:PMIntrExDos
endif   ;!NEC_98
endif
;
; Set up the IDT, and dpmi32 state
;
        mov     ax,es                   ; Idt selector
        mov     bx,VDM_INT_16
        DPMIBOP InitIDT

        mov     ax,5                    ; handler increment
        mov     cx,SEL_DXPMCODE OR STD_RING
        mov     dx,offset DXPMCODE:PmFaultEntryVector

        DPMIBOP InitExceptionHandlers

IFDEF WOW_x86
; make the stacks 16 bit again

        cCall NSetSegmentAccess,<selDgroupPM,STD_DATA>
        cCall NSetSegmentAccess,<selEHStack,STD_DATA>
ENDIF
; All done

iidt90: pop     es
        pop     di
        pop     si
        pop     dx
        pop     cx
        pop     bx
        ret
ReInitIdt endp

        assume ds:DGROUP,es:NOTHING
        public ReInitGdt
ReInitGdt proc near

        push    ax
        push    cx
        push    di

        mov     ax,selGDT               ; LDT selector
        lsl     cx,ax                   ; LDT size
        mov     di,SEL_USER and SELECTOR_INDEX
        DPMIBOP InitLDT

        pop     di
        pop     cx
        pop     ax
        ret
ReInitGdt endp

;--------------------------------------------------------
; AllocateExceptionStack -- Get space for exception handler
;
; Input:   none
; Output:  none
;       carry set on error
; uses: AX, BX, CX, DX, SI, DI
;
        assume ds:dgroup,es:nothing
        public  AllocateExceptionStack
AllocateExceptionStack proc near

        cmp     selEHStack, 0           ;have we allocated one already
        jnz     aes_ok                  ;yes, return no carry

        xor     bx,bx
        mov     dx,bx
        mov     cx,1000h                ;length of block
        mov     ax, 501h
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop
        jc      @F

        mov     ax, SEL_USER_STACK or STD_RING
        mov     selEHStack,ax

        cCall   NSetSegmentDscr,<ax,bx,cx,0,0fffh,STD_DATA>
        mov     ax,selEHStack

        mov     cx,1000h                ;reload length
        dec     cx
        and     cx,0fffeh                ; Make sure SP is WORD aligned
        mov     npEHStackLimit,cx

        ;; mark the stack with 0DEADh
        mov     bx, cx
        push    ds
        mov     ds,ax
        sub     bx,2
        mov     word ptr [bx],0DEADh
        pop     ds
        mov     npEHStacklet, bx

        push    es
        mov     ax, selEHStack
        mov     es, ax
        mov     bx, npEHStackLimit
        DPMIBOP InitPmStackInfo
        pop     es

aes_ok:
        clc
@@:
        ret

AllocateExceptionStack endp

DXPMCODE ends

;****************************************************************

        end     start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxnetbio.asm ===
PAGE    ,132
        TITLE   DXNETBIO.ASM  -- Dos Extender NetBIOS API Mapper

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXNETBIO.ASM    -   DOS Extender NetBIOS API Mapper
;
;-----------------------------------------------------------------------
;
; This module provides the 286 DOS Extender's API mapping of Int 2Ah and
; 5Ch NetBIOS requests.  It allows a protected mode application to
; issue NetBIOS requests without worrying about segment to selector
; translations and mapping of buffers between extended and conventional
; memory.
;
;-----------------------------------------------------------------------
;
;  11/29/90 amitc    Modified code to have the POST routine in GlobalMemory
;                    and queue the POST when DOSX is not around.
;  11/29/90 amitc    Call to InitLowHeap moved to this file from DXOEM.ASM
;  02/01/90 jimmat   Update Api mapping table for Ungerman-Bass extensions
;                    as per new data from UB.
;  06/15/89 w-glenns Finished TermNetMapper, added Delay/ResumeNetPosting
;  04/18/89 jimmat   Original version.
;  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include interupt.inc
include netbios.inc
include intmac.inc
include stackchk.inc

include bop.inc
include rdrsvc.inc
include dpmi.inc

        .list

; -------------------------------------------------------
;           FLAG FOR PM NCB HANDLING
; -------------------------------------------------------

PM_NCB_HANDLING equ     1       ; set to 0 for NCB handling in VM

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; The following equates define the codes that map between a NCB Command code
; and the mapping flags used to process it.  To be compatible with Windows/386,
; these values are all increments of 4 (they use 32 bit offsets).  These
; values should always correspond to the values used by the Windows/386
; NetBIOS mapping!

ApiMapUnknown   EQU     00h
ApiMapNone      EQU     04h
ApiMapIn        EQU     08h
ApiMapOut       EQU     0Ch
ApiMapInOut     EQU     10h
ApiChainSend    EQU     14h
ApiCancel       EQU     18h
ApiBufferIn     EQU     1Ch
ApiBufferOut    EQU     20h
ApiBufferInOut  EQU     24h


; The following equates define the bit flags which identify the actions
; to take on entry and exit of a NetBIOS request.

BUFF_IN         EQU     01h             ;Buffer data to the int handler
BUFF_OUT        EQU     02h             ;Buffer data from the int handler
BUFF_CHAIN      EQU     04h             ;Special chain send buffering
BUFF_CANCEL     EQU     08h             ;Special cancel buffering

REPLACE_MAP_TABLE EQU   1607h           ;Int2fh replace net map table service
VNETBIOS_DEV_ID   EQU   14h             ;VNETBIOS device ID

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   EnterIntHandler:NEAR
        extrn   LeaveIntHandler:NEAR
        extrn   EnterRealMode:NEAR
        extrn   EnterProtectedMode:NEAR
        extrn   GetSegmentAddress:NEAR
externFP   NSetSegmentDscr
        extrn   Lma2SegOff:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

ifdef      NEC_98
        extrn   fNHmode:BYTE
endif   ;NEC_98
        extrn   pbReflStack:WORD
        extrn   bReflStack:WORD
        extrn   regUserSS:WORD
        extrn   regUserSP:WORD
        extrn   rgbXfrBuf1:BYTE
        extrn   segDXCode:WORD
        extrn   NetHeapSize:WORD

ifdef WOW_x86
        extrn   FastBop:fword
endif

OldInt76 dd 0
        public  HCB_List

Cancel_NCB      EQU     rgbXfrBuf1      ;Easier for commenting/readability

HCB_List        dw      0               ;linked list of low HCB/NCB/Buffers

lpfnOldInt2A    dd      ?               ;old int vector 2Ah & 5Ch routines
lpfnOldInt5C    dd      ?

lpfnRmNetIsr    dd      ?               ;Real Mode vector to Network Int Rtn

SelNetStubCode                  dw 0    ;sel for stub code
SegNetStubCode                  dw 0    ;segment for stub code
AddrfStubDelayNetPosting        dw ?    ;address of fStubDelayNetPosting in StubSeg
AddrfStubTermNetRequest         dw ?    ;address of fStubTermNetRequest in StubSeg

NBPSp           dw      0

; The ApiMapTbl converts an NCB Command code (0-7F) into a code that
; identifies the particular mapping routine to execute.

ApiMapTbl       label   byte
        db      ApiMapUnknown           ; 00h -
        db      ApiMapUnknown           ; 01h -
        db      ApiMapUnknown           ; 02h -
        db      ApiMapUnknown           ; 03h -
        db      ApiMapUnknown           ; 04h -
        db      ApiMapUnknown           ; 05h -
        db      ApiMapUnknown           ; 06h -
        db      ApiMapUnknown           ; 07h -
        db      ApiMapUnknown           ; 08h -
        db      ApiMapUnknown           ; 09h -
        db      ApiMapUnknown           ; 0Ah -
        db      ApiMapUnknown           ; 0Bh -
        db      ApiMapUnknown           ; 0Ch -
        db      ApiMapUnknown           ; 0Dh -
        db      ApiMapUnknown           ; 0Eh -
        db      ApiMapUnknown           ; 0Fh -
        db      ApiMapNone              ; 10h - Call
        db      ApiMapNone              ; 11h - Listen
        db      ApiMapNone              ; 12h - Hang up
        db      ApiMapUnknown           ; 13h -
        db      ApiBufferIn             ; 14h - Send
        db      ApiBufferOut            ; 15h - Receive
        db      ApiBufferOut            ; 16h - Receive any
        db      ApiChainSend            ; 17h - Chain send
        db      ApiMapUnknown           ; 18h -
        db      ApiMapUnknown           ; 19h -
        db      ApiMapUnknown           ; 1Ah -
        db      ApiMapUnknown           ; 1Bh -
        db      ApiMapUnknown           ; 1Ch -
        db      ApiMapUnknown           ; 1Dh -
        db      ApiMapUnknown           ; 1Eh -
        db      ApiMapUnknown           ; 1Fh -
        db      ApiBufferIn             ; 20h - Send datagram
        db      ApiBufferOut            ; 21h - Receive datagram
        db      ApiBufferIn             ; 22h - Send broadcast datagram
        db      ApiBufferOut            ; 23h - Receive broadcast dgram
        db      ApiMapUnknown           ; 24h -
        db      ApiMapUnknown           ; 25h -
        db      ApiMapUnknown           ; 26h -
        db      ApiMapUnknown           ; 27h -
        db      ApiMapUnknown           ; 28h -
        db      ApiMapUnknown           ; 29h -
        db      ApiMapUnknown           ; 2Ah -
        db      ApiMapUnknown           ; 2Bh -
        db      ApiMapUnknown           ; 2Ch -
        db      ApiMapUnknown           ; 2Dh -
        db      ApiMapUnknown           ; 2Eh -
        db      ApiMapUnknown           ; 2Fh -
        db      ApiMapNone              ; 30h - Add name
        db      ApiMapNone              ; 31h - Delete name
        db      ApiMapNone              ; 32h - Reset
        db      ApiMapOut               ; 33h - Adapter status
        db      ApiMapOut               ; 34h - Session status
        db      ApiCancel               ; 35h - Cancel
        db      ApiMapNone              ; 36h - Add group name
        db      ApiMapUnknown           ; 37h -
        db      ApiMapUnknown           ; 38h -
        db      ApiMapUnknown           ; 39h -
        db      ApiMapUnknown           ; 3Ah -
        db      ApiMapUnknown           ; 3Bh -
        db      ApiMapUnknown           ; 3Ch -
        db      ApiMapUnknown           ; 3Dh -
        db      ApiMapUnknown           ; 3Eh -
        db      ApiMapUnknown           ; 3Fh -
        db      ApiMapUnknown           ; 40h -
        db      ApiMapUnknown           ; 41h -
        db      ApiMapUnknown           ; 42h -
        db      ApiMapUnknown           ; 43h -
        db      ApiMapUnknown           ; 44h -
        db      ApiMapUnknown           ; 45h -
        db      ApiMapUnknown           ; 46h -
        db      ApiMapUnknown           ; 47h -
        db      ApiMapUnknown           ; 48h -
        db      ApiMapUnknown           ; 49h -
        db      ApiMapUnknown           ; 4Ah -
        db      ApiMapUnknown           ; 4Bh -
        db      ApiMapUnknown           ; 4Ch -
        db      ApiMapUnknown           ; 4Dh -
        db      ApiMapUnknown           ; 4Eh -
        db      ApiMapUnknown           ; 4Fh -
        db      ApiMapUnknown           ; 50h -
        db      ApiMapUnknown           ; 51h -
        db      ApiMapUnknown           ; 52h -
        db      ApiMapUnknown           ; 53h -
        db      ApiMapUnknown           ; 54h -
        db      ApiMapUnknown           ; 55h -
        db      ApiMapUnknown           ; 56h -
        db      ApiMapUnknown           ; 57h -
        db      ApiMapUnknown           ; 58h -
        db      ApiMapUnknown           ; 59h -
        db      ApiMapUnknown           ; 5Ah -
        db      ApiMapUnknown           ; 5Bh -
        db      ApiMapUnknown           ; 5Ch -
        db      ApiMapUnknown           ; 5Dh -
        db      ApiMapUnknown           ; 5Eh -
        db      ApiMapUnknown           ; 5Fh -
        db      ApiMapUnknown           ; 60h -
        db      ApiMapUnknown           ; 61h -
        db      ApiMapUnknown           ; 62h -
        db      ApiMapUnknown           ; 63h -
        db      ApiMapUnknown           ; 64h -
        db      ApiMapUnknown           ; 65h -
        db      ApiMapUnknown           ; 66h -
        db      ApiMapUnknown           ; 67h -
        db      ApiMapUnknown           ; 68h -
        db      ApiMapUnknown           ; 69h -
        db      ApiMapUnknown           ; 6Ah -
        db      ApiMapUnknown           ; 6Bh -
        db      ApiMapUnknown           ; 6Ch -
        db      ApiMapUnknown           ; 6Dh -
        db      ApiMapUnknown           ; 6Eh -
        db      ApiMapUnknown           ; 6Fh -
        db      ApiMapNone              ; 70h - Unlink
        db      ApiMapUnknown           ; 71h -
        db      ApiMapNone              ; 72h - Ungerman Bass Register
        db      ApiBufferIn             ; 73h - Ungerman Bass SendNmc
        db      ApiMapNone              ; 74h - Ungerman Bass Callniu
        db      ApiMapNone              ; 75h - Ungerman Bass Calladdr
        db      ApiMapNone              ; 76h - Ungerman Bass Listenaddr
        db      ApiBufferIn             ; 77h - Ungerman Bass SendPkt
        db      ApiBufferOut            ; 78h - Ungerman Bass RcvPkt
        db      ApiBufferIn             ; 79h - Ungerman Bass SendAttn
        db      ApiBufferOut            ; 7Ah - Ungerman Bass RcvAttn
        db      ApiBufferOut            ; 7Bh - Ungerman Bass Listenniu
        db      ApiBufferOut            ; 7Ch - Ungerman Bass RcvRaw
        db      ApiBufferIn             ; 7Dh - Ungerman Bass SendNmc2
        db      ApiMapUnknown           ; 7Eh -
        db      ApiMapNone              ; 7Fh - Install check

; The next table maps the (Windows/386 compatible) code from ApiMapTbl
; to the bit flags which control our entry/exit mapping.

EntryExitFlags  label   byte
        db      BUFF_IN+BUFF_OUT        ;ApiMapUnknown
        db      0                       ;ApiMapNone
        db      BUFF_IN                 ;ApiMapIn
        db      BUFF_OUT                ;ApiMapOut
        db      BUFF_IN+BUFF_OUT        ;ApiMapInOut
        db      BUFF_CHAIN              ;ApiChainSend
        db      BUFF_CANCEL             ;ApiCancel
        db      BUFF_IN                 ;ApiBufferIn
        db      BUFF_OUT                ;ApiBufferOut
        db      BUFF_IN+BUFF_OUT        ;ApiBufferInOut

DXDATA  ends


; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   selDgroup:WORD

DXCODE  ends

DXPMCODE    segment

        extrn   selDgroupPM:WORD

DXPMCODE    ends

        page
; ----------------------------------------------------------------------
;
;   The following routines handle INT 2Ah and 5Ch interrupts that
;   request NetBIOS services.  Typically, these interrupts require
;   that a NCB and/or buffer be copied between conventional and
;   extended memory, and register values be modified due to real-
;   mode/protected-mode addressing differences.
;
;   (Note: this comment copied almost unchanged from DXINTR.ASM)
;
;   The following conventions are used:
;
;   A stack is allocated from the interrupt reflector stack for these
;   routines to use.  This allows nested servicing of interrupts.
;   A stack frame is built in the allocated stack which contains the
;   following information:
;
;           original caller's stack address
;           caller's original flags and general registers (in pusha form)
;           caller's original segment registers (DS & ES)
;           flags and general registers to be passed to interrupt routine
;               (initially the same as caller's original values)
;           segment registers (DS & ES) to be passed to interrupt routine
;               (initially set to the Dos Extender data segment address)
;
;   This stack frame is built by the routine EnterIntHandler, and its
;   format is defined by the structure INTRSTACK.  The stack frame is
;   destroyed and the processor registers set up for return to the user
;   by the function LeaveIntHandler.
;
;   There are two sets of general registers and two sets of segment
;   registers (DS & ES) on the stack frame.  One set of register values
;   has member names of the form intUserXX.  The values in these stack
;   frame members will be passed to the interrupt service routine when
;   it is called, and will be loaded with the register values returned
;   by the interrupt service routine.  The other set of registers values
;   has member names of the form pmUserXX.  These stack frame members
;   contain the original values in the registers on entry from the
;   user program that called the interrupt.
;
;   When we return to the original caller, we want to pass back the
;   general registers as returned by the interrupt routine (and possibly
;   modified by the exit handler), and the same segment registers as
;   on entry, unless the interrupt routine returns a value in a segment
;   register. (in this case, there must be some code in the exit routine
;   to handle this).  This means that when we return to the caller, we
;   return the general register values from the intUserXX set of stack
;   frame members, but we return the segment registers from the pmUserXX
;   set of frame members.  By doing it this way, we don't have to do
;   any work for the case where the interrupt subfuntion doesn't require
;   any parameter manipulation.  NOTE however, this means that when
;   manipulating register values to be returned to the user, the segment
;   registers are treated opposite to the way the general registers are
;   treated.  For general registers, to return a value to the user,
;   store it in a intUserXX stack frame member.  To return a segment
;   value to the user, store it in a pmUserXX stack frame member.
;


; -------------------------------------------------------
        subttl NetBIOS API Mapper Initialization Routine
        page
; -------------------------------------------------------
;        NetBIOS API MAPPER INITIALIZATION ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

;--------------------------------------------------------
;   InitNetMapper -- This routine initializates the NetBIOS API mapper.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   all registers preserved
;
;   Note:   This routine expects to be called late enough in the DOS
;           extender initialization cycle that it can use other interrupt
;           mapping functions (like INT 21h).  It must be called in
;           PROTECTED MODE!
;           And, assumes interrupts are to be enabled.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  InitNetMapper

InitNetMapper   proc near

        pusha
        push    es

; Do an installation check before doing anything else

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP
        FSTI

        mov     ax,355Ch                ;make sure the Int 5Ch vector
        int     21h                     ;  really points somewhere
        assume  es:NOTHING

ifdef      NEC_98
        mov     ax,es

        test    fNHmode, 0FFh            ;N/Hmode no kiriwake
        jz      NetBios_Nmode

        cmp     ax,60h                  ;Hmode default(not install)
;coading no tameni toriaezu 60h wo ireteoku node debug no tokini 
;60h no ataiwo Hmode youni change surukoto!!!!!

        jz      inm20
        jmp     NetBio_Install

NetBios_Nmode:
        cmp     ax,60h                  ;Nmode default(not install)
        jz      inm20
NetBio_Install:
endif   ;NEC_98
        mov     ax,es                   ;can't be installed if 0 vector
        or      ax,bx
        jz      inm20

        push    ds
        pop     es
        assume  es:DGROUP

        mov     cx,(size NCB_Struc)/2   ;build a dummy NCB with an invalid
        mov     di,offset rgbXfrBuf1    ;  7Fh (Install) command code
        mov     bx,di
        xor     ax,ax
        cld
        rep stosw

        mov     [bx].NCB_Command,Install        ;issue invalid request
        int     5Ch

        xor     bx,bx                   ;assume not installed
        cmp     al,RC_Invalid_Cmd       ;if it says invalid command, then
        jnz     inm20                   ;  it must be installed

        dec     bx                      ;bx !=0 means NetBIOS is installed

inm20:
        SwitchToProtectedMode
        FSTI

        or      bx,bx                   ;skip install if no NetBIOS
        jnz     inm20A                  ;net bios is there
        jmp     inm80                   ;no NetBios

inm20A:

; we need to allocate a block of memory in the low heap and copy some code
; down there which would handle the POST calls from the NetWork. It is
; necessary to have a piece in global memory do the POST handling because
; DOSX might have been swapped out by the Switcher when a POST request
; comes in.
;
; -----
; CAVEAT:
; This archaic piece of code was only necessary on the real DOSX running
; standard mode Windows 3.0. On NT, dosx is never switched out. So the
; relocation performed here could be just thrown away and replaced with a
; normal piece of RM code.
;
        mov     bx,(SIZE_OF_GLOBAL_NET_STUB_CODE+15) SHR 4
        mov     ax,100h                         ;allocate block
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop

        jnc     inm20C                          ;allocation succeeded
        jmp     inm80                           ;fail the initialization

inm20C:
        xchg    ax,dx
        mov     [SegNetStubCode],dx             ;save it

; DX has a selector pointing to the start of the block. Copy the stub routine
; down into the block.

        push    es                              ;save
        mov     [SelNetStubCode],ax             ;save the selector value
        push    ds                              ;save
        mov     es,ax                           ;destination sel of the xfer
        push    cs
        pop     ds
        xor     di,di                           ;destination offset
        lea     si,NetBiosStubCode              ;source offset of xfer
        mov     cx,SIZE_OF_GLOBAL_NET_STUB_CODE ;size of the block
        cld
        rep     movsb                           ;copy the block down
        pop     ds                              ;restore our DS


; now copy the FAR address of the RMPostRtn into the stub code segment

        lea     di,FarAddrOfRMPostRtn           ;variable where address to be saved
        lea     ax,NetBiosStubCode              ;offset of the routine
        sub     di,ax                           ;DI has the offset in the stub
        mov     ax,segDXCode                    ;segment of real mode DosX
        mov     es:[di][2],ax                   ;save the segment
        lea     ax,RMPostRtn                    ;offset of the POST routine
        mov     es:[di][0],ax                   ;save the offset

; patch the address 'NBS_Patch_CalFarAddr' with the address in DI

        mov     si,NBS_Patch_CallFarAddr        ;address to patch
        mov     es:[si],di                      ;patch it.

; calculate the offset to the other flag bytes in the stub code area that
; we will have to access.

        lea     di,fStubDelayNetPosting         ;address when assembled
        lea     ax, NetBiosStubCode             ;address of start of routine
        sub     di,ax                           ;address after move
        mov     [AddrfStubDelayNetPosting],di   ;save it

; patch the address 'NBS_Patch_fsDelayNetPosting' with the value in DI

        mov     si,NBS_Patch_fsDelayNetPosting  ;address to patch
        mov     es:[si],di                      ;patch it.

        lea     di,fStubTermNetRequests         ;address when assembled
        sub     di,ax                           ;address after move
        mov     [AddrfStubTermNetRequest],di    ;save it

; patch the address 'NBS_Patch_fsTermNetRequests' with the value in DI

        mov     si,NBS_Patch_fsTermNetRequests  ;address to patch
        mov     es:[si],di                      ;patch it.
        pop     es

; The stub routine in global memory has now been put in place to handle POST
; calls. We now need to hook the INT 2AH and 5CH PM vectors to trap the network
; calls.

; The network seems to be installed, hook the INT 2Ah & 5Ch PM vectors

        mov     ax,352Ah        ;get/store old Int 2Ah vector
        int     21h
        assume  es:NOTHING

        mov     word ptr lpfnOldInt2A,bx
        mov     word ptr [lpfnOldInt2A+2],es

        mov     ax,355Ch        ;get/store old Int 5Ch vector
        int     21h

        mov     word ptr lpfnOldInt5C,bx
        mov     word ptr [lpfnOldInt5C+2],es

        push    ds
        pop     es

        push    cs
        pop     ds
        assume  ds:NOTHING,es:DGROUP

        mov     ax,252Ah                        ;set new Int 2Ah handler
        mov     dx,offset DXPMCODE:PMIntr2A
        int     21h

        mov     ax,255Ch                        ;set new Int 5Ch handler
        mov     dx,offset DXPMCODE:PMIntr5C
        int     21h

        push    es
        pop     ds
        assume  ds:DGROUP

; See if anybody wants to provide a different NetBIOS mapping table

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        FSTI                             ;don't need 'em disabled

        xor     cx,cx                   ;subf'n zero
        mov     es,cx                   ;preset address to copy to NULL
        mov     di,cx
        mov     ax,REPLACE_MAP_TABLE
            ; DOSX net extender API call to substitute alternate NETBIOS
            ; mapping table
        mov     bx,VNETBIOS_DEV_ID      ;VNETBIOS device ID
        int     2Fh
            ; ES:DI contains address of alternate mapping table or NULL

        mov     cx,es                   ;Q: valid table pointer ?
        jcxz    inm70                   ;N: NULL...keep current table

        ;Y: copy table pointed to by es:di to table area (simple replace)

        mov     ax,ds           ; string move source (int 2F provided) table
        mov     es,ax           ; in ds:si, and destination ApiMapTbl in the
        mov     ds,cx           ; data segment now in es:di
        mov     si,di
        mov     di,offset ApiMapTbl     ;ptr to table
        mov     cx,64                   ;copy over 128 byte table
        cld
        rep     movsw
        mov     ds,ax           ;recall data segment

inm70:
        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        FSTI
        clc
        jmp     short inm90

inm80:
        stc                             ;tell caller we didn't install

inm90:
        pop     es
        popa

        ret

InitNetMapper   endp

;-----------------------------------------------------------------------------
; NetBiosStubCode
;
; DESCRIPTION   This routine is actually relocated to a block of Global Memory
;               obtained from the Switcher. It handles the POST calls from the
;               NETBIOS layer. If DosX has been swapped out, fStubDelayPosting
;               would be true and this routine would set a flag in the HCB
;               to imply that the POSTing must be done. If DosX is active, this
;               routine will call off to the RMPostRtn in DosX via a far call
;               pointer.
;
; ENTRY:
;    ES:BX      - HCB
;
; EXIT:
;    All registers preserved but for flags.
;
; USES:
;    Flags
;
; NOTE:
;    This routine will actually be copied to a global memory stub segment
;    and will execute from there. However, since the routine would be moved
;    while we are in protected mode, the routine is being assembled in the
;    protected mode code segment.
;-----------------------------------------------------------------------------
NetBiosStubCode proc far


        assume  ds:NOTHING,es:NOTHING,ss:NOTHING

        FCLI                             ;just to be sure

; Don't post anything if in the process of terminating

;-----------------------------------------------------------------------------
; The following instruction will have to be patched after the move:
;
;       cmp     cs:[fStubTermNetRequests],1
;
; we will mark the place that has to be patched.
;-----------------------------------------------------------------------------

        db      2eh, 80h, 3eh           ;CS: CMP BYTE PTR

NBS_Patch_fsTermNetRequests equ $ - NetBiosStubCode

        dw      ?                       ;address to compare
        db      1                       ;value to comapare
;-----------------------------------------------------------------------------

        je      NBSC_post_done

; Check if posting should be delayed

;-----------------------------------------------------------------------------
; The following instruction will have to be patched after the move:
;
;       cmp     cs:[fStubDelayNetPosting],0;Q: delay postings ?
;
; we will mark the place that has to be patched.
;-----------------------------------------------------------------------------

        db      2eh, 80h, 3eh           ;CS: CMP BYTE PTR

NBS_Patch_fsDelayNetPosting equ $ - NetBiosStubCode

        dw      ?                       ;address to compare
        db      0                       ;value to comapare
;-----------------------------------------------------------------------------

        je      NBSC_post_no_delay      ;N: don't delay this posting

; we can do no posting. DosX has been swapped out. Set a flag in the HCB to
; imply that POSTing must be done later.

        or      byte ptr es:[bx.HCB_Flags],HCB_DELAY    ;Y: mark as delayed
        jmp     short NBSC_post_done

NBSC_post_no_delay:

;-----------------------------------------------------------------------------
; call off to RMPostRtn in DosX. We will have to patch the following
; instruction after the move.
;
;       call    cs:[FarAddrOfRMPostRtn] ;call routine in DosX proper
;
; we will mark the place to match
;-----------------------------------------------------------------------------

        db      2eh,0ffh,1eh            ;CALL CS: DWORD PTR

NBS_Patch_CallFarAddr equ $ - NetBiosStubCode

        dw      ?                       ;call far address
;------------------------------------------------------------------------------

NBSC_post_done:

        riret

NetBiosStubCode  endp
;----------------------------------------------------------------------------;
; allocate space for some of the variables that the Stub Code uses. These    ;
; will be filled in by PMODE code in the DosX.                               ;
;----------------------------------------------------------------------------;

fStubTermNetRequests    db      0               ;DosX is terminating
fStubDelayNetPosting    db      0               ;delay posting, DosX swapped
FarAddrOfRMPostRtn      dd      ?               ;address of the actual POST rtn

SIZE_OF_GLOBAL_NET_STUB_CODE equ $ - NetBiosStubCode
;-----------------------------------------------------------------------------;

DXPMCODE    ends

; -------------------------------------------------------
        subttl NetBIOS API Mapper Termination Routine
        page
; -------------------------------------------------------
;          NetBIOS API MAPPER TERMINATION ROUTINE
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

;   TermNetMapper --  This routine is called when the 286 DOS extender
;       is winding down so that any pending network requests from the
;       protected mode application can be canceled.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   ax,bx,cx,dx,si,di,es
;
;   Note:  This routine must be called in REAL MODE!

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  TermNetMapper

TermNetMapper   proc  near

; set a flag in the stub code to imply that DosX is terminating and no more
; POSTs to be done.

        mov     di,[SelNetStubCode]     ;selector for the stub area
        or      di,di                   ;is global heap in place ?
        jnz     @f                      ;yes.
        ret
@@:

        SwitchToProtectedMode
        assume  ds:DGROUP,es:DGROUP,ss:NOTHING

        push    es
        mov     es,di
        assume  es:nothing

; get the address of the flag byte fStubTermNetRequest after the block was
; relocated

        mov     di,[AddrfStubTermNetRequest]

; ES:DI has the flag byte address. Set the flag

        mov     byte ptr es:[di],1      ;set flag to delay posting
        pop     es
        assume  es:dgroup

        ; terminating the net driver interface...no more postings allowed

        FSTI

        mov     cx,size NCB_Struc / 2
        mov     si,offset Cancel_NCB    ;cancel control block buffer
        mov     di,si
        xor     ax,ax                   ;zero fill structure
        cld
        rep     stosw

        mov     ds:[si.NCB_Command],Cancel  ;Cancel command NCB

; We don't need to release the NCB/buffer(s) from the low heap because
; the entire low heap will soon be released.

; Search low heap list looking for copy of target NCB

        mov     cx,HCB_List
        mov     di,HCB_Header_Size      ;offset of NCB in low heap block

term_next:
        jcxz    term_done

        mov     ax,cx
        call    GetSegmentAddress
        add     dx,di
        adc     bx,0                    ;BX:DX = lma of low target NCB

        call    Lma2SegOff              ;BX:DX = normalized SEG:OFF

        dec     bx                      ;return the same slightly unnormalized
        add     dx,10h                  ;  SEG:OFF that was used initially

        mov     ds:[si.NCB_Buffer_Seg],bx   ; point to NCB to cancel
        mov     ds:[si.NCB_Buffer_Off],dx

        SwitchToRealMode                ;also disables ints for us
        assume  ds:DGROUP,es:DGROUP

        mov     bx,si                   ;ES:BX points to cancelling NCB

        pushf
        call    lpfnRmNetIsr            ;do the cancel call
        ; return code in AL

        SwitchToProtectedMode
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

        FSTI
        mov     es,cx
        mov     cx,es:[di.HCB_Next]
        jmp     short term_next

term_done:

        SwitchToRealMode
        assume  ds:DGROUP,es:DGROUP

        FSTI
        ret

TermNetMapper   endp

; -------------------------------------------------------

DXCODE  ends

; -------------------------------------------------------
        subttl NetBIOS API Int 2Ah Mapper Interrupt Hook
        page
; -------------------------------------------------------
;        NetBIOS API INT 2Ah MAPPER INTERRUPT HOOK
; -------------------------------------------------------

DXPMCODE    segment
        assume cs:DXPMCODE

; -------------------------------------------------------
;   PMIntr2A -- This routine traps Int 2Ah requests from a
;       protected mode application.  NetBIOS requests (ah =
;       1 or 4) are passed on to the Int 5Ch handler for
;       further processing.  Other requests are passed on
;       to the next Int 2Ah handler in the interrupt chain.
;
;   Input:  User regs at time of interrupt
;   Output: none
;   Errors: none
;   Uses:   none
;

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr2A

PMIntr2A  proc  near

        cld                             ;cya...

        cmp     ah,1                    ;we only need to map the Int 2Ah
        jz      @f                      ;  ah = 1 & 4 services--if it's
        cmp     ah,4                    ;  not one of those, just pass it
        jz      @f                      ;  on down the chain...

        sub     sp,4                    ; build a stack frame
        push    bp
        mov     bp,sp
        push    ax
        push    ds
        mov     ds,selDgroupPM
        assume  ds:DGROUP
        mov     ax,word ptr [lpfnOldInt2A+2]    ; store previous INT 2A
        mov     word ptr [bp+4],ax              ; handler
        mov     ax,word ptr [lpfnOldInt2A]
        mov     word ptr [bp+2],ax
        pop     ds
        assume  ds:NOTHING
        pop     ax
        pop     bp                      ; SS:SP -> previous handler
                                        ;let someone else deal with it
        retf                            ;  (most likely PMIntrReflector)
@@:

if PM_NCB_HANDLING

;
; if this is NT then we have decided we are making a NetBIOS call (es:bx points
; to an NCB in protect-mode memory). INT 0x2A, ah=1 or ah=4 just ends up calling
; the 0x5C entry point; ah is returned as 1 or 0, depending on whether an error
; is returned from 0x5C or not
;

        push    dx
        mov     dl,2ah

else

        push    bx                      ;save caller's bx
        mov     bx,4*2Ah                ;indicate we came from int 2A handler

endif ; PM_NCB_HANDLING

        jmp     short DoNetRqst         ;int 2Ah/5Ch common code

PMIntr2A  endp


; -------------------------------------------------------
        subttl NetBIOS API Int 5Ch Mapper Interrupt Hook
        page
; -------------------------------------------------------
;        NetBIOS API INT 5Ch MAPPER INTERRUPT HOOK
; -------------------------------------------------------
;   PMIntr5C -- This routine maps Int 5Ch (and selected Int 2Ah)
;       NetBIOS requests between a protected mode application, and
;       the real mode interrupt handler.
;
;   Input:  User regs at time of interrupt
;   Output: regs as returned by interrupt handler
;   Errors:
;   Uses:   none
;

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMIntr5C

PMIntr5C  proc  near

if PM_NCB_HANDLING
;
; we no longer want to make the call through the real-mode handler, since all
; it does is make the BOP
;

        cld                             ; just in case
        push    dx
        mov     dl,5ch

DoNetRqst:

;
; Do a  sync/async NETBIOS presence check. Don't BOP for this simple case.
; Also don't do the async call because Delrina WinFax Pro hasn't initialized
; The post address in the NCB.
;
        cmp     byte ptr es:[bx],7fh    ; sync NETBIOS presence check
        je      skip_bop
        cmp     byte ptr es:[bx],0ffh   ; async NETBIOS presence check
        je      skip_bop
ifdef WOW_x86
.386p
        push    ds
        mov     ds,selDgroupPM

        assume  ds:DGROUP

        FBOP    BOP_REDIR, SVC_NETBIOS5C, FastBop
        pop     ds
.286p
else
        SVC     SVC_NETBIOS5C
endif ; WOW_x86

        cmp     dl,2ah
        jne     @f

;
; this was a 0x2A call. Return ah = 0 if NetBIOS returned al = 0, else return
; ah = 1
;

        sub     ah,ah
        or      al,al
        jz      @f
        inc     ah
@@:     pop     dx
        riret

skip_bop:
        mov     al,3                    ; INVALID COMMAND error
        mov     es:[bx].ncb_retcode,al  ; returned in NCB_RETCODE && al
        mov     es:[bx].ncb_cmd_cplt,al ; and NCB_CMD_CPLT
        pop     dx
        riret


else

        cld                             ;cya...

        push    bx                      ;save caller's bx
        mov     bx,4*5Ch                ;indicate we came from int 5C

DoNetRqst       label   near            ;start of int 2Ah/5Ch common code

        push    ax                      ;move the address of the
        push    ds                      ;  proper real mode interrupt
        mov     ds,selDgroupPM          ;  handler (2A or 5C) to global var
        assume  ds:DGROUP
        push    es

        mov     ax,SEL_RMIVT OR STD_RING
        mov     es,ax
        mov     ax,word ptr es:[bx]
        mov     word ptr lpfnRmNetIsr,ax
        mov     ax,word ptr es:[bx+2]
        mov     word ptr [lpfnRmNetIsr+2],ax

        pop     es
        pop     ds                      ;restore caller's environment
        assume  ds:NOTHING
        pop     ax
        pop     bx

        call    EnterIntHandler         ;build an interrupt stack frame
        assume  ds:DGROUP,es:NOTHING

        FSTI             ;-----------------------------------------------

; Allocate space in the low heap for the HCB/NCB and maybe a buffer

        xor     dx,dx
        mov     cx,HCB_SIZE             ;DX:CX = # bytes low heap required

        call    GetEntryExitFlags       ;AX=Entry flags / ES:BX -> PM NCB

        test    al,BUFF_IN+BUFF_OUT+BUFF_CHAIN  ;need to allocate a low buffer?
        jz      i5c_alloc

;
; RLF 06/09/93
;
; from the command type, we think we have a buffer address and size. If either
; of these is 0, then we actually don't have a buffer; skip it
;

        mov     ah,al                   ; set default no buffer
        and     al,not (BUFF_IN or BUFF_OUT)
        mov     dx,es:[bx.NCB_Buffer_Off]
        or      dx,es:[bx.NCB_Buffer_Seg]
        jz      i5c_alloc
        mov     dx,es:[bx.NCB_Length]
        or      dx,dx
        jz      i5c_alloc
        xor     dx,dx                   ; restore dx to 0
        mov     al,ah                   ; restore buffer flags

        add     cx,es:[bx.NCB_Length]   ;if so, add in it's length
        adc     dx,0
        add     cx,1fh                  ;allow space to align buffer
        adc     dx,0                    ;  on a paragraph boundry
        and     cx,not 0fh

        test    al,BUFF_CHAIN           ;a 2nd weird-o buffer?
        jz      i5c_alloc

        add     cx,word ptr es:[bx.NCB_CallName]    ;yes, add in it's len also
        adc     dx,0
        add     cx,1fh                  ;allow space to align buffer
        adc     dx,0                    ;  on a paragraph boundry
        and     cx,not 0fh

i5c_alloc:
        push    ax                      ;save entry/exit flags

        FCLI             ;treat allocate as critical section ------------

        push    bx
        mov     bx,cx                           ;loword length
        mov     ax,dx                           ;hiword length

        add     bx,15                           ;round up
        shr     bx,4                            ;discard last 4 bits
        and     ax,0fh                          ;discarded bits were 0
        shl     al,4                            ;get it in MS nibble
        or      bh,al                           ;BX has the size in paragraphs

        mov     ax,100h                         ;allocate block
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop
        pop     bx
        jnc     @f                      ;  HCB/NCB and maybe buffer

        Debug_Out "Low heap allocation failed!"

        pop     ax                      ;clear stack

        mov     byte ptr [bp].intUserAX,RC_Resources
        mov     es:[bx.NCB_RetCode],RC_Resources
        mov     es:[bx.NCB_Cmd_Cplt],RC_Resources
        jmp     i5c_done
@@:
        mov     ax,dx                   ;get the selector

; Copy the PM NCB to the low heap and add our extra HCB fields

        mov     es,ax
        xor     di,di                   ;es:di -> low heap block

        cld
        stosw                           ;HCB_Handle
        mov     ax,bx
        stosw                           ;HCB_PM_NCB_Off
        mov     ax,[bp].pmUserES
        stosw                           ;HCB_PM_NCB_Seg
        mov     ax,HCB_List
        stosw                           ;HCB_Next
        xor     ax,ax
        stosw                           ;HCB_Flags = 0

        mov     HCB_List,es             ;link HCB to head of list

        FSTI             ;-----------------------------------------------

        push    ds
        mov     ds,[bp].pmUserES
        assume  ds:NOTHING

        errnz   <size NCB_Struc and 1>  ;if odd # bytes, can't just movsw

        mov     si,bx                   ;ES:DI->low NCB, DS:SI->PM NCB
        mov     cx,size NCB_Struc / 2
        rep     movsw

        pop     ds
        assume  ds:DGROUP


; Update the interrupt handler's registers to point to the low NCB

        mov     ax,es
        call    GetSegmentAddress
        add     dx,HCB_Header_Size
        adc     bx,0                    ;BX:DX = lma of low NCB

        pop     ax                      ;refresh entry flags
        push    ax

        push    bx                      ;save lma of NCB
        push    dx

        call    Lma2SegOff              ;BX:DX = normalized SEG:OFF of low NCB

        dec     bx                      ;we want to do a negative offset on the
        add     dx,10h                  ;  NCB segment, so un-normalize it some

        mov     [bp].intUserES,bx       ;point int handler's ES:BX to low NCB
        mov     [bp].intUserBX,dx


; If this is a cancel request, find the target NCB in the low heap

        test    al,BUFF_CANCEL          ;cancel request?
        jz      i5c_not_cancel

        mov     di,HCB_Header_Size      ;ES:DI -> low heap Cancel NCB

        FCLI             ;don't want list changing while looking --------

        call    FindTargetNCB           ;BX:DX = SEG:OFF of target NCB

        FSTI             ;-----------------------------------------------

if DEBUG   ;------------------------------------------------------------
        jnc     @f
        Debug_Out "FindTargetNCB didn't!"
@@:
endif   ;DEBUG  --------------------------------------------------------

        jc      @f

        mov     es:[di.NCB_Buffer_Off],dx       ;point cancel NCB to low
        mov     es:[di.NCB_Buffer_Seg],bx       ;  heap target NCB
@@:

i5c_not_cancel:

        pop     dx                      ;restore lma of NCB
        pop     bx


; If necessary, update NCB buffer pointer(s) and copy buffer(s) to low heap

        pop     ax                      ;recover entry flags

        test    al,BUFF_IN+BUFF_OUT+BUFF_CHAIN  ;a buffer to point to?
        jnz     @f
        jmp     i5c_no_buf_in
@@:

        add     dx,size NCB_Struc + 0fh ;get lma of buffer, rounded up
        adc     bx,0                    ;  to the next higher paragraph
        and     dx,not 0fh

        push    ds
        mov     ds,[bp].pmUserES
        mov     si,[bp].pmUserBX        ;DS:SI -> PM NCB
        assume  ds:NOTHING

        push    bx
        push    dx

        call    Lma2SegOff              ;BX:DX = SEG:OFF of low buffer

        mov     di,HCB_Header_Size      ;ES:DI -> low NCB
        mov     es:[di.NCB_Buffer_Off],dx
        mov     es:[di.NCB_Buffer_Seg],bx

        pop     dx
        pop     bx

        test    al,BUFF_IN+BUFF_CHAIN   ;actually need to copy buffer?
        jz      i5c_buf_in_done

        mov     cx,ds:[si.NCB_Length]                   ;CX = buffer len
        lds     si,dword ptr ds:[si.NCB_Buffer_Off]     ;DS:SI -> buffer

        push    ax
        xor     ax,ax
        call    CopyBuffer              ;copies DS:SI to lma BX:DX len CX
        pop     ax

        test    al,BUFF_CHAIN
        jz      i5c_buf_in_done

        add     dx,es:[di.NCB_Length]   ;BX:DX = lma of 2nd low heap buffer
        adc     bx,0
        add     dx,0fh
        adc     bx,0
        and     dx,not 0fh

        push    bx                      ;update low heap NCB with SEG:OFF
        push    dx                      ;  of 2nd buffer

        call    Lma2SegOff

        mov     word ptr es:[di.NCB_CallName+2],dx      ;2nd buffer loc stored
        mov     word ptr es:[di.NCB_CallName+4],bx      ;  at callname + 2

        pop     dx
        pop     bx

        mov     ds,[bp].pmUserES
        mov     si,[bp].pmUserBX        ;DS:SI -> PM NCB

        mov     cx,word ptr ds:[si.NCB_CallName]        ;CX = buffer len
        lds     si,dword ptr ds:[si.NCB_CallName+2]     ;DS:SI -> buffer

        xor     ax,ax
        call    CopyBuffer              ;copies DS:SI to lma BX:DX len CX


i5c_buf_in_done:

        pop     ds
        assume  ds:DGROUP

i5c_no_buf_in:

; Switch to real mode, and load the mapped real mode registers.

        SwitchToRealMode                ;also disables ints
        assume  ss:DGROUP

; --------------- START OF REAL MODE CODE ------------------------------

        pop     es
        pop     ds
        assume  ds:NOTHING,es:NOTHING
        popa                            ;restore all the other registers

; If this is a NoWait command, hook the mapped NCB to point to our post
; routine.  At this time ES:BX -> mapped NCB

        test    byte ptr es:[bx.NCB_Command],NoWait
        jz      @f

        push    ax                      ;save

;
; RLF 06/09/93
;
; although this is an async command, there may be no post address (app just
; polls return code until it goes non-0xff). In this case, don't set up our
; asynchronous notification routine
;

        mov     ax,es:[bx.NCB_Post_Off]
        or      ax,es:[bx.NCB_Post_Seg]
        jz      no_post_routine

        assume  ss:DGROUP               ;ss has DOSX's data seg
        mov     ax,[SegNetStubCode]     ;get segment of stub code

; the address of the stub code that will handle the POST is AX:0. Save this
; in the HCB.

        mov     word ptr es:[bx.NCB_Post_Off],0
        mov     word ptr es:[bx.NCB_Post_Seg],ax

no_post_routine:
        pop     ax                      ;restore
@@:
        or      byte ptr es:[bx.HCB_FLAGS],HCB_ISSUED

; Invoke the appropriate real mode interrupt handler (2Ah or 5Ch),
; reestablish our stack frame with the handler's returned registers,
; and then back to protected mode

        call    lpfnRmNetIsr            ;exectue real mode interrupt handler
        pushf
        FCLI
        pusha
        push    ds
        push    es

        mov     bp,sp                   ;restore stack frame pointer

        mov     ax,es:[bx.HCB_Handle]   ;recover selector to current NCB/buff
        push    ax

        SwitchToProtectedMode
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING

; --------------- START OF PROTECTED MODE CODE -------------------------

; With some network drivers, and some NoWait commands, the operation may
; get 'posted' even before the driver IRETs from the issue call.  If this
; has happened, the HCB_POSTED flag will be set.  In this case, the caller's
; NCB and (possibly) buffer has already been updated, so we just discard
; the low heap block and exit.  If the operation hasn't been posted already,
; we copy back the updated NCB info, and maybe a buffer.  Note that interrupts
; are disabled, so we don't get 'posted' half way through this operation--
; that would be bad.

        pop     ax                      ;handle (selector) of low heap block
        mov     es,ax
        mov     di,HCB_Header_Size      ;es:di -> low heap NCB

        test    byte ptr es:[di.HCB_Flags],HCB_POSTED   ;already posted?
        jnz     i5c_release                             ;  yes, just discard

        and     byte ptr es:[di.HCB_Flags],not HCB_ISSUED   ;so post rtn knows
                                                            ;we updated already

        push    ax                      ;save handle for later

        call    UpdateNCB               ;update the caller's NCB

        call    GetEntryExitFlags       ;AX=Exit Flags / ES:BX->PM NCB

        test    es:[bx.NCB_Command],NoWait      ;don't copy buff now if NoWait
        jnz     i5c_no_buf_out

        test    al,BUFF_OUT
        jz      i5c_no_buf_out

;
; RLF 06/09/93
;
; although the flags for this command say we have an output buffer, we may
; not have one - address or length is 0; check it out
;

        mov     ax,es:[bx.NCB_Buffer_Off]
        or      ax,es:[bx.NCB_Buffer_Seg]
        jz      i5c_no_buf_out
        mov     ax,es:[bx.NCB_Length]
        or      ax,ax
        jz      i5c_no_buf_out

        pop     ax                      ;handle to low block back
        push    ax

        call    CopyBufferOut           ;copy low heap buffer to pm app buffer

i5c_no_buf_out:


; If this was a Wait operation (or NoWait that failed), we are finished with
; the low heap block and can release it now.

        pop     ax                      ;recover handle to low heap block

        test    es:[bx.NCB_Command],NoWait      ;if Wait, go release now
        jz      i5c_release

        cmp     es:[bx.NCB_RetCode],RC_Pending
        jz      i5c_done

; Most NetBIOS implementations seem to (correctly) set the RetCode to
; RC_Pending on NoWait requests.  However, it seems that some Novell
; NetBIOS implementations can return RetCode == 00 but Cmd_Cplt ==
; RC_Pending (FFh).  So, if it is a NoWait request, and RetCode isn't
; Pending, also check the Cmd_Cplt code.

        cmp     es:[bx.NCB_Cmd_Cplt],RC_Pending
        jz      i5c_done

        Debug_Out "NoWait cmd with non Pending retcode!"


i5c_release:

        push    ds                      ;make sure es != low heap block sel
        pop     es                      ;  (else FreeLowBlock will GP fault)

        call    DeLink                  ;DeLink HCB/NCB/Buffers from lnk list

        push    dx
        mov     dx,ax                   ;selector to free
        mov     ax,101h                 ;free block
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop
        pop     dx

; Finished! (at least for now)  Restore caller's regs/stack and return

i5c_done:
        mov     ax,[bp].pmUserBX        ;restore possibly modified BX to
        mov     [bp].intUserBX,ax       ;  PM NCB offset

        call    LeaveIntHandler

        riret

endif ; if PM_NCB_HANDLING

PMIntr5C  endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl NetBIOS API Mapper Post Routine
        page
; -------------------------------------------------------
;             NetBIOS API MAPPER POST ROUTINE
; -------------------------------------------------------

;*******************************************************************************
;*
;*  The code from here on down is only used if we are switching between real
;*  and protect mode when making NetBIOS requests. It is ifdef'd out for WOW
;*  because we now BOP the NetBIOS requests without switching modes
;*
;******************************************************************************/

;ife PM_NCB_HANDLING

DXCODE  segment
        assume  cs:DXCODE

; -------------------------------------------------------
;   RMPostRtn -- This REAL MODE routine is invoked by the network
;       software when a NoWait NetBIOS command completes.  This
;       routine must update the applications copy of the NCB,
;       possibly copy a buffer of data to the application, and
;       possibly invoke the application's own post routine.
;
;       Note, this will now be called when it is OK to POST the request
;       back to the application. The Stub Code in global mrmory makes
;       sure that this is OK to do.
;
;   Input:
;   Output:
;   Errors:
;   Uses:

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  RMPostRtn

RMPostRtn  proc far

        FCLI                             ;just to be sure
        cld                             ;cya...

        push    ax
        push    bx
        push    es
        push    ds                      ; NBP assumes ds saved, greaseballs

        mov     ds,selDgroup
        assume  ds:DGROUP


; Allocate a new stack frame, and then switch to the reflector stack
; frame.

        mov     regUserSP,sp
        mov     regUSerSS,ss
        mov     ss,selDgroup
        mov     sp,pbReflStack

        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame

        FIX_STACK
        push    regUserSS               ;save current stack loc on our stack
        push    regUserSP               ;  so we can restore it later

        push    es:[bx.HCB_Handle]      ;selector to low heap block

; We are now running on our own stack, so we can switch into protected mode.

        SwitchToProtectedMode           ;destroys ax

; --------------- START OF PROTECTED MODE CODE -------------------------

        pop     ax                      ;ax = selector to low heap block

        call    NetBiosPostRoutine      ;do the actual posting

        pop     regUserSP               ;recover previous stack location
        pop     regUserSS

        SwitchToRealMode                ; Switch back to real mode.

; --------------- START OF REAL MODE CODE ------------------------------

; Switch back to the original stack, deallocate the interrupt stack frame,
; and return to the network software

        CHECK_STACK
        mov     ss,regUserSS
        mov     sp,regUserSP
        add     pbReflStack,CB_STKFRAME

        pop     ds                      ; give ds back to NBP/XNS
        pop     es
        pop     bx
        pop     ax
        ret

RMPostRtn  endp

DXCODE  ends

; -------------------------------------------------------
        subttl NetBIOS API Mapper Utility Routines
        page
; -------------------------------------------------------
;          NetBIOS API MAPPER UTILITY ROUTINES
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
;   NetBiosPostRoutine -- local routine
;       This PROTECT MODE routine is called when the network
;       software completes a NoWait NetBIOS command.  This
;       routine must update the applications copy of the NCB,
;       possibly copy a buffer of data to the application, and
;       possibly invoke the application's own post routine.
;
;   Input:  ax --> selector to low heap block
;   Output:
;   Errors:
;   Uses: ax,bx,es

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  NetBiosPostRoutine

NetBiosPostRoutine proc near

IFNDEF WOW_x86
        pusha
else
.386p
        pushad
        push    fs
        push    gs
.286p
endif

; Update the protected mode copy of the NCB and copy buffer if required

        push    ax                      ;handle (selector) of low heap block

        call    UpdateNCB               ;always update the caller's NCB

        mov     es,ax
        mov     bx,HCB_Header_Size                  ;ES:BX -> low heap NCB
        les     bx,dword ptr es:[bx.HCB_PM_NCB_Off] ;ES:BX -> PM NCB

        call    GetExitFlags2           ;AX=Exit Flags

        test    al,BUFF_OUT
        jz      postsub_no_buf

;
; RLF 06/09/93
;
; once more unto the breach dear friends: although we think this command has
; an output buffer, the app may think otherwise; let's check...
;

        mov     ax,es:[bx.NCB_Buffer_Off]
        or      ax,es:[bx.NCB_Buffer_Seg]
        jz      postsub_no_buf
        mov     ax,es:[bx.NCB_Length]
        or      ax,ax
        jz      postsub_no_buf

        pop     ax                      ;handle to low block back
        push    ax

        call    CopyBufferOut           ;copy low heap buffer to pm app buffer

postsub_no_buf:

; Release the low heap space, unless the HCB_ISSUED flag is set (meaning
; that the net driver called us before returning from the initial Int 5Ch).
; In that case, the low heap block will be released by the Int 5Ch mapper.

        pop     ax                      ;recover handle to low heap block
        push    ax

        push    es
        mov     es,ax
        mov     di,HCB_Header_Size
        or      byte ptr es:[di.HCB_Flags],HCB_POSTED   ;mark as posted
        pop     es

; Invoke the user's PM post routine, if there is one - AL=retcode, ES:BX->NCB

        mov     ax,es:[bx.NCB_Post_Off] ;did user specify a post routine?
        or      ax,es:[bx.NCB_Post_Seg]
        jnz     @f
        jmp     postsub_done
@@:

        mov     [NBPSp],sp
        rpushf                          ;build iret frame for user's
        push    cs                      ; routine to return to us
        push    offset postsub_ret

        mov     al,es:[bx.NCB_RetCode]  ;pass ret code in al

        push    es:[bx.NCB_Post_Seg]    ;invoke the user's post routine
        push    es:[bx.NCB_Post_Off]

        retf

; PM app's post routine returns here when finished

postsub_ret:
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        mov     sp,[NBPSp]

postsub_done:
        pop     ax
        mov     es,ax
        test    byte ptr es:[di.HCB_Flags],HCB_ISSUED   ;still in Int 5C code?
        jnz     postsub_no_release                      ;  yes, don't release

        push    ds                      ;make sure es != low heap block sel
        pop     es                      ;  (else FreeLowBlock will GP fault)

        call    DeLink                  ;DeLink HCB/NCB/Buffers from lnk list

        push    dx
        mov     dx,ax                   ;selector to free
        mov     ax,101h                 ;free block
        push    ds
        FBOP    BOP_DPMI, Int31Call, FastBop
        pop     dx
postsub_no_release:

IFNDEF WOW_x86
        popa
ELSE
.386p
        pop     gs
        pop     fs
        popad
.286p
ENDIF
        ret

NetBiosPostRoutine endp

; -------------------------------------------------------
;   DelayNetPostings -- This function is called when NetBIOS completions
;       are to be delayed.  We simply set a flag that causes the async
;       post routine not to post to the application.
;
;   Input: none
;   Output: none
;   Errors: none
;   Uses: none

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  DelayNetPosting

DelayNetPosting proc near

; Make sure posting is delayed. We need to set a flag in the StubCode area.

        push    es                      ;save
        push    di
        mov     di,[SelNetStubCode]     ;selector for the stub area
        or      di,di                   ;did we copy to global memory ?
        jz      DelayNetPostingRet      ;no, nothing to do.
        mov     es,di

; get the address of the flag byte fStubDelayNetPosting after the block was
; relocated

        mov     di,[AddrfStubDelayNetPosting]

; ES:DI has the flag byte address. Set the flag

        mov     byte ptr es:[di],1      ;set flag to delay posting

DelayNetPostingRet:

        pop     di
        pop     es                      ;restore
        ret

DelayNetPosting endp


; -------------------------------------------------------
;   ResumeNetPostings -- This function is called when completed NetBIOS
;       postings can be resumed to the application.  We traverse the
;       list of NetBIOS requests, and 'post' the application on any that
;       completed while posting were delayed.
;
;   Input: none
;   Output: none
;   Errors: none
;   Uses: none

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  ResumeNetPosting

ResumeNetPosting proc near

        push    es
        push    di
        push    bx                      ; used by NetBiosPostRoutine
        push    ax

; set a flag in the StubCode area to imply that POSTing need not be delayed.

        mov     di,[SelNetStubCode]     ;selector for the stub area
        or      di,di                   ;global heap in place ?
        jnz     dummy1
        jmp     ResumeNetPostingRet     ;no.
dummy1:
        mov     es,di

; get the address of the flag byte fStubDelayNetPosting after the block was
; relocated

        mov     di,[AddrfStubDelayNetPosting]

; ES:DI has the flag byte address. ReSet the flag

        mov     byte ptr es:[di],0      ;reset the flag


        FCLI                             ;protect access to linked list

        mov     cx,HCB_List
        mov     di,HCB_Header_Size      ;offset of NCB in low heap block

resume_next:
        jcxz    resume_done

        mov     es,cx
        mov     cx,es:[di.HCB_Next]

        test    byte ptr es:[di.HCB_Flags],HCB_DELAY  ;Has this one completed?
        jz      resume_next                           ;  no, skip it

        ;Y: this packet was delayed...post it NOW !

        mov     ax,es:[di.HCB_Handle]   ;selector to low heap block

        FSTI

        call    NetBiosPostRoutine      ;post the NCB finally

        FCLI

        ; *** modification warning ***
        ; note: block has just been de-linked from list, so we MUST
        ; get the pointer to the next block before NetBiosPostRoutine
        ; is called (which calls DeLink)!

        jmp     short resume_next

resume_done:

        FSTI


ResumeNetPostingRet:

        pop     ax
        pop     bx
        pop     di
        pop     es
        ret

ResumeNetPosting endp


; ------------------------------------------------------
;   CopyBufferOut -- This routine copies a buffer from the low heap
;       block up to the PM app's buffer area.
;
;   Input:  AX    =  Selector to low heap block
;           ES:BX -> PM NCB
;   Output: none
;   Errors: none
;   Uses:   none

        assume  ds:DGROUP,es:NOTHING
        public  CopyBufferOut

CopyBufferOut   proc    near

        pusha

        mov     cx,es:[bx.NCB_Buffer_Seg]
        or      cx,es:[bx.NCB_Buffer_Off]
        jz      CBO_Buffer_Is_Null

        push    ds

        mov     di,bx                   ;ES:DI -> PM NCB
        call    GetSegmentAddress       ;BX:DX = lma of low heap block

        lds     si,dword ptr es:[di.NCB_Buffer_Off]     ;DS:SI -> PM buffer
        assume  ds:NOTHING

        add     dx,size NCB_Struc + HCB_Header_Size + 0fh
        adc     bx,0
        and     dx,not 0fh              ;BX:DX = lma of low heap buffer

        mov     cx,es:[di.NCB_Length]   ;CX = buffer length

        mov     al,1
        call    CopyBuffer              ;copies from lma BX:DX to DS:SI, len CX

        pop     ds
        assume  ds:DGROUP

CBO_Buffer_Is_Null:
        popa

        ret

CopyBufferOut   endp


; ------------------------------------------------------
;   CopyBuffer -- This routine copies a buffer of length CX
;       from DS:SI to the lma in BX:DX _or_ from the lma in
;       BX:DX to DS:SI.
;
;   Input:  AX    = direction flag, Z = from DS:SI -> lma,
;                                  NZ = from lma   -> DS:SI
;           BX:DX = lma of source or dest
;           CX    = length in bytes
;           DS:SI = pointer to source or dest
;   Output: none
;   Errors: none
;   Uses:   none

        assume  ds:NOTHING,es:NOTHING
        public  CopyBuffer

CopyBuffer      proc    near

        pusha
        push    ds
        push    es


        rpushf
        FCLI

; Setup a selector/descriptor for the linear memory address

        push    ax                      ;save direction flag

        push    ds
        mov     ds,selDgroupPM          ;temp dgroup addressability
        assume  ds:DGROUP

        mov     ax,SEL_NBSCRATCH or STD_RING ;our scratch selector to use
        dec     cx                      ;length to limit


        cCall   NSetSegmentDscr,<ax,bx,dx,0,cx,STD_DATA>

        pop     ds
        assume  ds:NOTHING

        inc     cx                      ;back to length

; If necessary, adjust the length so we don't fault due by overrunning the
; DS segment

        mov     bx,ds                   ;get limit for DS segment
        lsl     bx,bx
        sub     bx,si                   ;less the DS offset
        inc     bx                      ;  (limit is len - 1)
        cmp     bx,cx                   ;at least CX bytes left in segment?
        jae     @f
        mov     cx,bx                   ;  no, only do # remaining
@@:

; Copy the buffer

        xor     di,di                   ;AX:DI is now SEL:OFF to lma

        pop     bx                      ;recover direction flag
        or      bx,bx
        jnz     @f

        mov     es,ax                   ;from DS:SI -> AX:DI, almost ready
        jmp     short cb_copy
@@:
        xchg    si,di                   ;from AX:DI -> DS:SI, adjust
        push    ds                      ;  regs for movs instruction
        pop     es
        mov     ds,ax

cb_copy:
        cld
        shr     cx,1                    ;byte count to words, low bit to CY
        rep movsw
        jnc     @f
        movsb                           ;get any odd byte
@@:
        npopf

        pop     es
        pop     ds
        popa

        ret

CopyBuffer      endp


; ------------------------------------------------------
;   DeLink -- This routine will unlink a HCB/NCB/Buffer low heap
;       block from the HCB_List linked list.
;
;   Input:  AX = selector to block to unlink
;   Output: block unlinked
;   Uses:   none

        assume  ds:DGROUP,es:NOTHING
        public  DeLink

DeLink  proc    near

        push    bx
        push    cx
        push    es

        mov     bx,HCB_Header_Size

        cmp     ax,HCB_List             ;special case likely condition
        jnz     ul_search

        mov     es,ax                   ;ES:BX -> block to unlink

        mov     cx,es:[bx.HCB_Next]     ;block is first in linked list
        mov     HCB_List,cx
        jmp     short ul_done

ul_search:
        mov     es,HCB_List             ;ES:BX -> first block in list

ul_loop:
        mov     cx,es:[bx.HCB_Next]     ;is this just before the block?
        cmp     ax,cx
        jz      ul_got_it

        mov     es,cx                   ;  no, try the next one
        jmp     short ul_loop

ul_got_it:
        push    es                      ;okay, cut the selected block
        mov     es,cx                   ;  out of the linked list
        mov     cx,es:[bx.HCB_Next]
        pop     es
        mov     es:[bx.HCB_Next],cx

ul_done:
        pop     es
        pop     cx
        pop     bx

        ret

DeLink  endp


; ------------------------------------------------------
;   FindTargetNCB -- This routine searches the low memory heap
;       to locate an NCB pointed to by another user PM NCB.
;
;   Input:  ES:DI -> Cancel NCB pointing to PM target NCB
;   Output: BX:DX =  RM SEG:OFF of target NCB in low heap
;   Error:  CY if target NCB can't be found
;   Uses:   none

        assume  ds:DGROUP,es:NOTHING
        public  FindTargetNCB

FindTargetNCB   proc    near

        push    ax
        push    cx
        push    di
        push    es

        mov     bx,es:[di.NCB_Buffer_Seg]       ;get selector:offset of PM
        mov     dx,es:[di.NCB_Buffer_Off]       ;  target NCB to cancel


; Search low heap list looking for copy of target NCB

        mov     cx,HCB_List
        mov     di,HCB_Header_Size      ;offset of NCB in low heap block

ft_next:
        jcxz    ft_err

        mov     es,cx                   ;ES:DI -> first/next HCB/NCB in list

        cmp     bx,es:[di.HCB_PM_NCB_Seg]       ;is this the one?
        jnz     ft_not_it
        cmp     dx,es:[di.HCB_PM_NCB_Off]
        jz      ft_got_it

ft_not_it:                                      ;  no, get ptr to next one
        mov     cx,es:[di.HCB_Next]
        jmp     short ft_next

ft_got_it:

; ES:DI now points at the low heap copy of the target NCB, convert to SEG:OFF

        mov     ax,es
        call    GetSegmentAddress
        add     dx,di
        adc     bx,0                    ;BX:DX = lma of low target NCB

        call    Lma2SegOff              ;BX:DX = normalized SEG:OFF

        dec     bx                      ;return the same slightly unnormalized
        add     dx,10h                  ;  SEG:OFF that was used initially

        clc                             ;found it!
        jmp     short ft_done

ft_err: stc                             ;couldn't find the target ?!

ft_done:
        pop     es
        pop     di
        pop     cx
        pop     ax

        ret

FindTargetNCB   endp


;--------------------------------------------------------
;   GetEntryExitFlags -- This routine looks up the entry/exit mapping
;       flags for the current NetBIOS command.
;
;   Input:  user regs on stack frame
;   Output: AX = flags
;           ES:BX -> caller's PM NCB
;   Errors: none
;   Uses:

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  GetEntryExitFlags

GetEntryExitFlags  proc near

        mov     es,[bp].pmUserES        ;point ES:BX to pm app's NCB
        mov     bx,[bp].pmUserBX        ;  and get command code

GetExitFlags2   label   near

        push    di

        mov     al,es:[bx.NCB_Command]
        and     al,7Fh
        cbw

        mov     di,ax                   ;map NCB command code to API
        mov     al,ApiMapTbl[di]        ;  mapping code via ApiMapTbl

        shr     ax,2                    ;use map code to select entry/exit
        mov     di,ax                   ;  flags via EntryExitCode
        mov     al,EntryExitFlags[di]

        pop     di
        ret

GetEntryExitFlags  endp


; ------------------------------------------------------
;   UpdateNCB -- This routine updates the user's PM NCB copy from the
;       low heap real mode copy.
;
;   Input:  AX = selector pointing to low heap HCB/NCB
;   Output: User's PM NCB updated
;   Errors: none
;   Uses:   none

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  UpdateNCB

UpdateNCB       proc    near

        push    ax
        push    cx
        push    si
        push    di
        push    ds
        push    es

        mov     ds,ax
        mov     si,HCB_Header_Size      ;DS:SI -> low heap NCB

        les     di,dword ptr [si.HCB_PM_NCB_Off]  ;ES:DI -> protect mode NCB

        mov     al,[si.NCB_Command]     ;want to check the command code later
        and     al,not NoWait

        cld
        movsw
        movsw                           ;copy command, retcode, LSN, Num

        add     si,4                    ;skip the buffer pointer
        add     di,4

        movsw                           ;move the length

        mov     cx,34 / 2               ;len of callname, name, rto, sto (words)

        cmp     al,ChainSend            ;funkey chain send command?
        jnz     @f

        add     si,16                   ;  yes, skip callname
        add     di,16
        sub     cx,16 / 2
@@:
        rep movsw                       ;move name, rto, sto, maybe callname

        add     si,4                    ;skip the post address
        add     di,4

        mov     cx,16 / 2               ;move the rest
        rep movsw

        pop     es
        pop     ds
        pop     di
        pop     si
        pop     cx
        pop     ax

        ret

UpdateNCB       endp

; -------------------------------------------------------

DXPMCODE    ends

;endif   ; ife PM_NCB_HANDLING

DXDATA  segment

my_sp   dw      ?

DXDATA  ends

DXPMCODE segment
        assume  cs:DXPMCODE

;*******************************************************************************
;*
;*  HandleNetbiosAnr
;*
;*      Called when a simulated h/w interrupt for net callback functions occurs.
;*      Checks if the call is a PM netbios ANR. If it is, we get the NCB
;*      information and call the PM post routine
;*
;*  ENTRY       Nothing
;*
;*  EXIT        Nothing
;*
;*  RETURNS     Nothing
;*
;*  ASSUMES     Nothing
;*
;******************************************************************************/

        public HandleNetbiosAnr
HandleNetbiosAnr proc

        assume  cs:DXPMCODE
        assume  ds:DGROUP
        assume  es:nothing
        assume  ss:nothing

;
; perform a BOP to discover if this is a protect mode netbios ANR. If it is then
; es and bx will point to the NCB
;

        push    ds
        push    SEL_DXDATA OR STD_RING
        pop     ds

ifdef WOW_x86
.386p
        FBOP    BOP_REDIR, SVC_NETBIOSCHECK, FastBop
.286p
else
        SVC     SVC_NETBIOSCHECK
endif ; WOW_x86

        jnz     @f
        jmp     chain_previous_int      ; not PM Netbios ANR

@@:

;
; this is a PM Netbios ANR. Save state and call the post routine. There MUST be
; a post routine if we're here
;

IFNDEF WOW_x86
        pusha
ELSE
.386p
        pushad                          ; save all 32 bits
        push    fs
        push    gs
.286p
ENDIF
        push    es

ifdef WOW_x86
.386p
        FBOP    BOP_REDIR, SVC_NETBIOS5CINTERRUPT, FastBop
.286p
else
        SVC     SVC_NETBIOS5CINTERRUPT
endif ; WOW_x86

;
; save the stack pointer - apparently some apps will RETF, not IRET from the
; ANR. NB - this ISR cannot be re-entered since we only have the one previous
; stack pointer saved. This should be okay as long as the EOI is issued at the
; end of the ISR
;

        mov     my_sp,sp

;
; perform a fake interrupt to the PM post routine. ES:BX point at the NCB, AL is
; the return code. Post routine will IRET back (supposedly)
;

        mov     al,es:[bx.NCB_RetCode]  ; pass ret code in al
        pushf
        call    dword ptr es:[bx.NCB_Post_Off]

;
; restore our data segment and stack pointer, lest the app didn't IRET
;

        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        mov     sp,my_sp

;
; restore the interrupted state, then perform a BOP to reset the PIC and clean
; up any interrupt state
;

        pop     es
IFNDEF WOW_x86
        popa
ELSE
.386p
        pop     gs
        pop     fs
        popad
.286p
ENDIF

;
; this BOP will clear the emulated PICs (sends non-specific EOIs), and cause the
; next NET interrupt to be generated, if one is queued
;

ifdef WOW_x86
.386p
        FBOP    BOP_REDIR, SVC_RDRINTACK2, FastBop
.286p
else
        SVC     SVC_RDRINTACK2
endif ; WOW_x86

;
; restore the rest of the interrupted context and resume
;

        pop     ds
        riret

chain_previous_int:
        push    word ptr OldInt76+2     ; selector of previous handler
        push    word ptr OldInt76       ; offset of previous handler
        push    bp
        mov     bp,sp
        mov     ds,[bp+6]               ; retrieve interrupted ds
        pop     bp
        retf    2                       ; chain previous handler, removing space
                                        ; used for ds

HandleNetbiosAnr endp

        public  HookNetBiosHwInt

HookNetBiosHwInt proc near

        ;
        ; Save everything!!
        ;
        pusha
        push    ds
        push    es

ifdef      NEC_98                       ; '98/6/2 RAID #178452
        mov     ax,350dh                ; get old handler
else
        mov     ax,3576h                ; get old handler
endif      ;NEC_98
        int     21h

        mov     word ptr [OldInt76],bx
        mov     word ptr [OldInt76 + 2],es

        mov     dx,SEL_NBPMCODE OR STD_RING
        mov     ds,dx
        mov     dx,offset HandleNetbiosAnr
        mov     ah,25h
        int     21h                     ; set new handler

        pop     es
        pop     ds
        popa

        ret
HookNetBiosHwInt endp




DXPMCODE    ends

;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxoem.asm ===
PAGE    ,132
        TITLE   DXOEM.ASM  -- Dos Extender OEM Interface

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;***********************************************************************
;
;       DXOEM.ASM       - DOS Extender OEM Interface
;
;-----------------------------------------------------------------------
;
; This module contains the routines that may need to be modified by OEMs
; when adding new device/interface support to the Microsoft 286 DOS
; Extender portion of Windows/286.  There are four routines contained
; in this module:
;
;       InitializeOEM   - called during DOSX initialization
;
;       SuspendOEM      - called when the protected mode app is about
;                         to be suspended (currently when running a
;                         standard DOS 'old' app from Windows).
;
;       ResumeOEM       - called when the protected mode app is about
;                         to be resumed (currently when returning from
;                         a standard DOS 'old' app to Windows).
;
;       TerminateOEM    - called during DOSX termination
;
; Note: when this module refers to the 'OEM layer,' it is refering to
; the 286 DOS Extender device drivers, API mappers, etc., not the
; Windows OEM layer.
;
;-----------------------------------------------------------------------
;
;  06/28/89 jimmat  Original version.
;  11/29/90 amitc   Removed SuspendOEM/ResumeOEM - not required for 3.1
;  11/29/90 amitc   Moved call to 'InitLowHeap' from here to DXNETBIO.ASM
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
include     pmdefs.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   InitNetMapper:NEAR
        extrn   TermNetMapper:NEAR

; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA	segment

        extrn   NetHeapSize:WORD

DXDATA	ends


; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

DXCODE  ends

DXPMCODE    segment

DXPMCODE    ends

; -------------------------------------------------------
        subttl OEM Initialization Routine
        page
; -------------------------------------------------------
;           OEM INITIALIZATION ROUTINE
; -------------------------------------------------------

DXPMCODE    segment
        assume  cs:DXPMCODE

;--------------------------------------------------------
;   InitializeOEM --  This routine is called during DOSX initialization
;       in order to initialize the OEM layer (device drivers, API
;       mappers, etc.).  It expectes to be called late enough in the
;       initialization process that other interrupt mapping functions
;       (like Int 21h) are available.
;
;       This routine is called in protected mode, and can enable/disable
;       interrupts if it so requires.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   ax, all others preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  InitializeOEM

InitializeOEM	proc	near

; Initialize the NetBios mapper.


;                    ;;bugbug NetHeapSize isn't actually being used, other
;                    ;; than possibly to turn off the NETBIOS mapper


        mov     ax,NetHeapSize          ;don't initialize if net heap
        or      ax,ax                   ;  size set to zero
        jz      @f

        call    InitNetMapper           ;initialize the NetBIOS mapper--CY set
                                        ;  if NetBIOS not installed
@@:
        ret

InitializeOEM	endp

; -------------------------------------------------------

DXPMCODE    ends

; -------------------------------------------------------
        subttl OEM Termination Routine
        page
; -------------------------------------------------------
;              OEM TERMINATION ROUTINE
; -------------------------------------------------------

DXCODE	segment
        assume  cs:DXCODE

; -------------------------------------------------------
;   TerminateOEM --  This routine is called during DOSX termination
;       to disable the OEM layer.
;
;   Note:  This routine must is called in REAL MODE!  If some termination
;       code must run in protected mode, the routine must switch to
;       protected mode itself, and switch back to real mode before
;       returning.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   ax,bx,cx,dx,si,di,es
;

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  TerminateOEM

TerminateOEM	proc	near

        call    TermNetMapper           ;terminate the NetBIOS mapper

        ret

TerminateOEM	endp

; -------------------------------------------------------

DXCODE	ends
;****************************************************************
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxrom.inc ===
; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*  DXROM.INC  --  ROM Defintions for Dos Extender		*
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*								*
;*  11/05/90 jimmat Created.					*
;*                                                              *
;****************************************************************

IFDEF	ROM

; Define the ROM Table of Contents structure.  Note that this structure
; is defined in other pieces of software and all must be updated if any
; are.	Currently known to be defined in the ROM Image Builder (RIB) and
; the ROM Test loader.

ROMTOC	SEGMENT AT 0
szID		db	10 dup (?)	; ID string
DOSX_CSIP	dd	?		; DOSX initial CS:IP   (seg:off)
KRNL_CSIP	dd	?		; Kernel initial CS:IP (sel:off)
lmaROMLDT	dd	?		; lma of ROM prototype LDT
cROMsels	dw	?		; # descriptors used in ROM proto LDT
FirstROMsel	dw	?		; first LDT selector in ROM proto LDT
offSysDir	dw	?		; offset to system directory string
cModules	dw	?		; # modules defined in ROM TOC
ModEntries	db	?		; start of module entries

; module entries follow at this point...

ROMTOC	ENDS


RomIntVector	=	31h		;Interrupt vector to use


; This macro returns the DOS Extender data segment paragraph address in AX.
; It must only be used by real mode code.

GetRMDataSeg	macro

		ifndef	GetDXDataRM
		extrn	GetDXDataRM:NEAR
		endif

		call	GetDXDataRM
		endm


; This macro sets DS to point to the DOS Extender data segment.  It must
; only be used by real mode code.

SetRMDataSeg	macro

		ifndef	SetDXDataRM
		extrn	SetDXDataRM:NEAR
		endif

		call	SetDXDataRM
		endm


; This macro returns the DOS Extender data segment paragraph address in AX.
; It must only be used by protected mode code.

GetPMDataSeg	macro

		ifndef	GetDXDataPM
		extrn	GetDXDataPM:NEAR
		endif

		call	GetDXDataPM
		endm


; This macro sets DS to point to the DOS Extender data segment.  It must
; only be used by protected mode code.

SetPMDataSeg	macro

		ifndef	SetDXDataPM
		extrn	SetDXDataPM:NEAR
		endif

		call	SetDXDataPM
		endm

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxutil.asm ===
PAGE    ,132
        TITLE   DXUTIL.ASM -- Dos Extender Miscellaneous Routines

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      DXUTIL.ASM      -   Dos Extender Miscellaneous          *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*                                                              *
;*  This module contains miscellaneous routines for the Dos     *
;*  Extender.                                                   *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  08/08/90 earleh DOSX and client privilege ring determined   *
;*      by equate in pmdefs.inc                                 *
;*  04/09/90 jimmat   If 286 with 287, put 287 into pMode too.  *
;*  08/20/89 jimmat   Removed local A20 code since HIMEM 2.07   *
;*                    works properly across processor resets    *
;*  07/28/89 jimmat   Added A20 check/set routines, added       *
;*                    SelOff2SegOff & Lma2SegOff routines.      *
;*  06/19/89 jimmat   Set direction flag before REP MOVS        *
;*  05/25/89 jimmat   Added GetSegmentAccess routine            *
;*  03/30/89 jimmat   Set IOPL = 3 when entering protect mode   *
;*  03/16/89 jimmat   Added more debug sanity checks            *
;*  03/15/89 jimmat   Minor changes to run child in ring 1      *
;*  03/13/89 jimmat   Added support for LDT & TSS               *
;*  02/10/89 (GeneA): changed Dos Extender from small model to  *
;*      medium model.  Also added MoveMemBlock function.        *
;*  01/25/89 (GeneA): changed initialization of real mode code  *
;*      segment address in EnterRealMode.  caused by adding     *
;*      new method of relocationg dos extender for PM operation *
;*  12/13/88 (GeneA): moved EnterProtectedMode and EnterReal-   *
;*      Mode here from dxinit.asm                               *
;*  09/16/88 (GeneA):   created by extracting code from the     *
;*      SST debugger modules DOSXTND.ASM, VIRTMD.ASM,           *
;*      VRTUTIL.ASM, and INTERRPT.ASM                           *
;*  18-Dec-1992 sudeepb Changed cli/sti to faster FCLI/FSTI     *
;*  24-Jan-1992 v-simonf Added WOW callout when INT 8 hooked    *
;*                                                              *
;****************************************************************

.286p
.287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

; .sall
; .xlist
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include dpmi.inc
include intmac.inc
.list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

SHUT_DOWN   =   8Fh         ;address in CMOS ram of the shutdown code
CMOS_ADDR   =   70h         ;i/o address of the cmos ram address register
CMOS_DATA   =   71h         ;i/o address of the cmos ram data register

DMAServiceSegment       equ     040h    ;40:7B bit 5 indicates DMA services
DMAServiceByte          equ     07Bh    ;  are currently required
DMAServiceBit           equ     020h

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------


; -------------------------------------------------------
;           DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   segGDT:WORD
        extrn   segIDT:WORD
        extrn   selGDT:WORD
        extrn   selIDT:WORD
        extrn   selGDTFree:WORD
        extrn   bpGDT:FWORD
        extrn   bpIDT:FWORD
        extrn   bpRmIVT:FWORD
        extrn   rgbXfrBuf1:BYTE
        extrn   PMFaultVector:DWORD
        extrn   lpfnXMSFunc:DWORD


        extrn   pbReflStack:WORD

bIntMask        db      0

bpBogusIDT      df      0       ;This is loaded into the IDT register to
                                ; force a bogus IDT to be defined.  When we
                                ; then do an interrupt a triple fault will
                                ; occur forcing the processor to reset.  This
                                ; is when doing a mode switch to real mode.

IDTSaveArea     dw      3 DUP (?)       ;save area for IDT during mode switch

        public  A20EnableCount

A20EnableCount  dw      0

ShutDownSP      dw      0       ;stack pointer during 286 reset

        public  f286_287

f286_287        db      0       ;NZ if this is a 286 with 287 coprocessor


if DEBUG   ;------------------------------------------------------------

        extrn   fTraceA20:WORD
        extrn   fTraceMode:WORD

        public  fA20

fA20    db      0

endif   ;DEBUG  --------------------------------------------------------

selPmodeFS      dw      0
selPmodeGS      dw      0

        public HighestSel
HighestSel dw 0

ifndef WOW_x86
        public IretBopTable
IretBopTable label byte
        irp x,<0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15>
        db  0c4h, 0c4h, 05dh, x
        endm
else
        public FastBop
FastBop         df 0

IretBopTable label byte
        irp x,<0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15>
        db  02eh, 066h, 0FFh, 01eh, 00h, 00h, 05dh, x
        endm

NullSel dd      0
        dd      0
endif
        extrn   DpmiFlags:WORD
DXDATA  ends

; -------------------------------------------------------
;               CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

        extrn   segDXData:WORD
        extrn   segDXCode:WORD
        extrn   selDgroup:WORD

DXCODE  ends


DXPMCODE    segment

        extrn selDgroupPM:WORD

DXPMCODE    ends

; -------------------------------------------------------
        subttl  Real/Protected Mode Switch Routines
        page

; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE

; -------------------------------------------------------
;       REAL/PROTECTED MODE SWITCH ROUTINES
; -------------------------------------------------------
;
;  EnterProtectedMode   -- This routine will switch the processor
;       into protected mode.  It will return with the processor
;       in protected mode and all of the segment registers loaded
;       with the selectors for the protected mode segments.
;       (CS with the selector for DXCODE and DS,ES,SS with the
;       selector for DXDATA)
;       It will also switch mode dependent memory variables.
;       It assumes that InitGlobalDscrTable and InitIntrDscrTable
;       have been called to set up the descriptor tables appropriately.
;
;   Note:   Except for a very brief time in this routine and in
;           EnterRealMode, the DOS Extender runs in the same ring along
;           with it's child app.  This has the benefit of eliminating
;           ring transitions on hardware and software interrupts.
;           It also makes it possible for the child to hook their
;           own interrupt routine into the IDT.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   AX, DS, ES, SS, CS modified, all others preserved
;
;   NOTE:   This routine turns interrupts of and does not turn them
;           back on.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  EnterProtectedMode

EnterProtectedMode  proc  near

        FCLI

; Update the mode dependent variables.

        mov     ax,SEL_DXDATA or STD_RING
        mov     selDgroup,ax

; Set the DMA services required bit for pMode users.

        mov     ax,DMAServiceSegment
        mov     es,ax
        or      byte ptr es:[DMAServiceByte],DMAServiceBit


; 'local enable' the A20 line via HIMEM before switching to pMode.
; This is more complicated than you might think.  Some real mode code
; (like old versions of SMARTDRV.SYS) may diddle with A20 on their own.
; These programs may not want us to change A20 on them.  RMIntrReflector
; may do a XMS 'local enable' to turn A20 back on for one of these pgms.
; Also, on a 386 where we actually do the mode switch, we try to leave
; A20 enabled so as to not waste time diddling for nothing.  The
; A20EnabledCount variable tracks if we've 'local enabled' A20 or not.
; Since we can't really trust real mode to leave A20 alone, we double
; check that it's really really on when we think it should be.

        push    bx                      ;save bx around XMS calls

        cmp     A20EnableCount,0        ;should A20 already be enabled?
        jz      enpm10                  ;  no, (normal 4 286) just go enable it

        xmssvc  7                       ;  yes, is it really enabled?
        or      ax,ax
        jnz     enpm15                  ;  yes, we be done!

if DEBUG   ;------------------------------------------------------------
        or      fA20,1                  ;  somebody done us wrong
endif   ;---------------------------------------------------------------

        xmssvc  6                       ;keep enable/disable calls balanced
        dec     A20EnableCount
enpm10:
        xmssvc  5                       ;local enable A20
        inc     A20EnableCount

if DEBUG   ;------------------------------------------------------------

        or      ax,ax
        jnz     @f
        or      fA20,2                  ;enable failed!
@@:
        cmp     fTraceA20,0
        jz      @f
        xmssvc  7                       ;in debug mode, make double sure
        or      ax,ax                   ;  A20 was enabled.  Slows things
        jnz     @f                      ;  down, but it's better to know.
        or      fA20,2
@@:
endif   ;DEBUG  --------------------------------------------------------

enpm15: pop     bx

ifndef WOW_x86
        DPMIBOP SetAltRegs
; Make sure that the nested task flag is clear

        pushf
        pop     ax
        and     ax,NOT 4000h
        push    ax
        npopf

; Make sure that we have the appropriate descriptor tables in effect,
; and switch the machine into protected mode

enpr20: smsw    ax              ;get current machine state
        or      ax,1            ;set the protected mode bit
        lgdt    bpGDT
        lidt    bpIDT
        lmsw    ax              ;and away we go

; Flush the instruction queue and load the code segment selector
; by doing a far jump.

        db      0EAh            ;jump far opcode
        dw      offset enpm40   ;offset of far pointer
        dw      SEL_DXCODE0     ;selector part of PM far pointer (ring 0)

; Load the other segment registers with valid selectors (not under VCPI)

enpm40: mov     ax,SEL_DXDATA0  ;stack has gotta be ring 0 also
        mov     ss,ax

; Load the LDT register and the Task Register

        mov     ax,SEL_LDT
        lldt    ax                      ;load the LDT register

        mov     ax,SEL_DXDATA or STD_RING
        mov     ds,ax                           ;ds to our DGROUP

        mov     ax,SEL_GDT
        mov     es,ax                           ;es to GDT

        push    si                              ;make sure busy bit is off
        mov     si,SEL_TSS                      ;  in the TSS descriptor
        mov     es:[si].arbSegAccess,STD_TSS    ;    before trying to load it
        ltr     si                              ;now load the task register
        pop     si
else
        .386p
        push    ebp
        mov     ebp,esp
        push    SEL_DXCODE or STD_RING  ; new cs
        push    0                       ; high half eip
        push    offset epmwow           ; new eip
        push    SEL_DXDATA or STD_RING  ; new ss
        push    ebp
        push    SEL_DXDATA or STD_RING  ; new ds
        DPMIBOP DPMISwitchToProtectedMode
epmwow:
        pop     ebp
        .286p
endif

        push    ds                      ;point es to DGROUP
        pop     es

; If this is a 286 machine with a 287 math coprocessor, put the coprocessor
; into protected mode also.

        cmp     f286_287,0              ;286 and 287?
        jz      @f

ifndef NEC_98
        xor     al,al                   ;  yup, clear co-processor busy line
        out     0F0h,al
endif   ;!NEC_98
        fsetpm                          ;     and put it in pMode
@@:

; We're currently running in ring 0.  Setup an interlevel iret frame
; to switch to our normal ring, and also force IOPL=3.  I spent 1+ day
; debugging on a 286 system (with no debugger!) because the 286 seemed
; switch into protected mode with IOPL=0, and once we got to an outer
; ring, we would fault on things like CLI instructions.

enpmSwitchRing:
ifndef WOW_x86
        mov     ax,sp                   ;still points to return address
        push    SEL_DXDATA or STD_RING  ;new ss
        push    ax                      ;new sp
        pushf
        pop     ax
        or      ah,30h
        push    ax                      ;new flags, with IOPL=3
        push    SEL_DXCODE or STD_RING  ;new cs
        push    offset DXCODE:epm_ret   ;new ip
        iret
endif
; When we get here, we are now in an outer ring.

epm_ret:

.386
        mov     ax, selPmodeFS
        mov     fs, ax
        mov     ax, selPmodeGS
        mov     gs, ax
.286p

        ret                     ;near return to caller in pMode

EnterProtectedMode endp


; -------------------------------------------------------
; EnterRealMode     -- This routine will switch the processor
;       from protected mode back into real mode.  It will also
;       reset the various mode dependent variables to their
;       real mode values and load the segment registers with
;       the real mode segment addresses.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   AX, DS, ES, SS, CS modified
;
;   NOTE:   This routine must be called with the stack segment set
;           to the Dos Extender data segment, as it resets the stack
;           segment register to the Dos Extender real mode data segment
;           but does not modify the stack pointer.
;   NOTE:   This routine turns interrupts off and and does not turn
;           them back on.

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  EnterRealMode

EnterRealMode   proc    near

.386
        mov     ax,fs
        mov     selPmodeFS, ax
        mov     ax,gs
        mov     selPmodeGS, ax
.286p

        FCLI

        mov     es,selDgroup

        push    SegDxCode
        push    offset DXCODE:enrmwow
        push    SegDxData
        push    sp
        push    SegDxData
.386p
        DPMIBOP DPMISwitchToRealMode
.286p
enrmwow: add    sp,6                    ; remove rest of parameters
        push    ds
        pop     es                      ; es not set by mode switch

enrm70:
        push    es                              ;clear DMA services required
        mov     ax,DMAServiceSegment            ;  bit for real mode
        mov     es,ax
        and     byte ptr es:[DMAServiceByte],not DMAServiceBit
        pop     es

        mov     ax,segDXData
        mov     selDgroup,ax

        ret

EnterRealMode   endp

; -------------------------------------------------------
        public RmUnsimulateProc

RmUnsimulateProc proc far
        BOP     BOP_UNSIMULATE
RmUnsimulateProc endp

; -------------------------------------------------------
DXCODE ends

DXPMCODE    segment
        assume cs:DXPMCODE

        public PmUnsimulateProc

PmUnsimulateProc proc far
        BOP     BOP_UNSIMULATE
PmUnsimulateProc endp

; -------------------------------------------------------
;       RAW MODE SWITCH ROUTINES
; -------------------------------------------------------

; ------------------------------------------------------
; PmRawModeSwitch       -- This routine performs a raw mode switch from
;       protected mode to real mode.  NOTE: applications will JUMP at this
;       routine
;
;   Input:   ax - new DS
;            cx - new ES
;            dx - new SS
;            bx - new sp
;            si - new CS
;            di - new ip
;    Output: DS, ES, SS, sp, CS, ip contain new values
;    Errors: none
;    Uses:
;
;
;
        assume ds:nothing, ss:nothing, es:nothing
        public PmRawModeSwitch
PmRawModeSwitch proc far

        push    ss
        pop     ds
        push    bx
.386p
        mov     bx,ss
        movzx   ebx,bx
        lar     ebx,ebx
        test    ebx,(AB_BIG SHL 8)
        mov     ebx,esp
        jnz     prms10

        movzx   ebx,bx
prms10:
.286p

; Switch to dosx stack (since switch to real mode will do that to us anyway
; NOTE: no-one can call EnterIntHandler or ExitIntHandler until we switch to
;       the user's new stack.  If they do, they will use the area we stored
;       the parameters for this call for a stack frame

        rpushf
        FCLI
        push    SEL_DXDATA OR STD_RING
        pop     ss
        assume ss:DGROUP
.386p
        movzx   esp,word ptr pbReflStack
.286p

; Save user registers

        push    dx              ; ss
.386p
        push    word ptr [ebx]
        push    word ptr [ebx - 2]; flags pushed before cli
.286p
        push    si              ; cs
        push    di              ; ip
        push    ax              ; ds
        push    cx              ; es

; switch modes

        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        SwitchToRealMode

; set the registers, switch stacks, and return to the user

        pop     es
        pop     ds
        pop     ax              ; ip
        pop     bx              ; cs
        pop     cx              ; flags
        pop     si              ; sp
        pop     ss
        assume ss:nothing
        mov     sp,si
        push    cx
        popf
        push    bx
        push    ax
        ret

PmRawModeSwitch endp

; NOTE: this is now the DXCODE segment, NOT the DXPMCODE segment (courtesy
;       of SwitchToRealMode

; ------------------------------------------------------
; RmRawModeSwitch       -- This routine performs a raw mode switch from
;       protected mode to real mode.  NOTE: applications will JUMP at this
;       routine
;
;   Input:   ax - new DS
;            cx - new ES
;            dx - new SS
;            bx - new sp
;            si - new CS
;            di - new ip
;    Output: DS, ES, SS, sp, CS, ip contain new values
;    Errors: none
;    Uses:
;
;
;
        assume ds:nothing, ss:nothing, es:nothing
        public RmRawModeSwitch
RmRawModeSwitch proc far

        push    ss
        pop     ds
        push    bx
        mov     bx,sp

; Switch to dosx stack (since switch to real mode will do that to us anyway
; NOTE: no-one can call EnterIntHandler or ExitIntHandler until we switch to
;       the user's new stack.  If they do, they will use the area we stored
;       the parameters for this call for a stack frame

        pushf
        FCLI
        push    segDxData
        pop     ss
        assume ss:DGROUP
        mov     sp,pbReflStack

; Save user registers

        push    dx              ; ss
        push    word ptr [bx]   ; sp
        push    word ptr [bx - 2] ; flags from before cli
        push    si              ; cs
        push    di              ; ip
        push    ax              ; ds
        push    cx              ; es

; switch modes

        mov     ax,segDxData
        mov     ds,ax
        SwitchToProtectedMode

; set the registers, switch stacks, and return to the user

        pop     es
        pop     ds
.386p
        test    DpmiFlags,DPMI_32BIT
        jnz     rrms10

        xor     eax,eax         ; clear high 16 bits
        xor     edi,edi         ; clear high 16 bits
.286p
rrms10: pop     di              ; ip
        pop     ax              ; cs
        pop     cx              ; flags from before cli
        pop     bx              ; sp
        assume ss:nothing
        pop     ss
.386p
        mov     esp,ebx
.286p
        push    cx
        rpopf

.386p
        push    eax
        push    edi
        db      066h
        retf
.286p

RmRawModeSwitch endp

DXPMCODE ENDS

DXCODE SEGMENT

; -------------------------------------------------------
;       STATE SAVE/RESTORE ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
; RmSaveRestoreState     -- This routine exists as a placeholder.  It
;       is not currently necessary to perform any state saving/restoring
;       for raw mode switch.  The DPMI spec states that the user can call
;       this routine with no adverse effect.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   none
;
        assume ds:nothing, ss:nothing, es:nothing
        public RmSaveRestoreState
RmSaveRestoreState proc far
        ret
RmSaveRestoreState endp

DXCODE  ends

; -------------------------------------------------------

DXPMCODE  segment
        assume  cs:DXPMCODE

; -------------------------------------------------------
; RmSaveRestoreState     -- This routine exists as a placeholder.  It
;       is not currently necessary to perform any state saving/restoring
;       for raw mode switch.  The DPMI spec states that the user can call
;       this routine with no adverse effect.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   none
;
        assume ds:DGROUP, ss:nothing, es:nothing
        public PmSaveRestoreState
PmSaveRestoreState proc far
        push    ax
        push    ds
        mov     ax, SEL_DXDATA or STD_RING
        mov     ds, ax
        test    DpmiFlags,DPMI_32BIT
        pop     ds
        pop     ax
        jnz     short @f                ; 32-bit return
        ret
@@:
        db      66h
        ret

PmSaveRestoreState endp

ifdef      NEC_98
        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  IncInBios
        public  DecInBios

;
;       IncInBios / DecInBios
;
;       IN_BIOS Inc/Dec SubRoutine      
;
IncInBios       proc    near
                push    ax
                push    es
                mov     ax, 0040h
                mov     es, ax
                test    byte ptr es:[0], 20h
                jz      @f
                inc     byte ptr es:[056h]
@@:
                pop     es
                pop     ax
                ret
IncInBios       endp

DecInBios       proc    near
                push    ax
                push    es
                mov     ax, 0040h
                mov     es, ax
                test    byte ptr es:[0], 20h
                jz      @f
                dec     byte ptr es:[056h]
@@:
                pop     es
                pop     ax
                ret
DecInBios       endp
endif   ;NEC_98


; -------------------------------------------------------
;   GTPARA      -- This routine will return the real mode paragraph
;       address of the specified protected mode memory segment.
;
;   Input:  SI      - selector of the segment
;   Output: returns ZR true if segment is in lower 1MB range
;           AX      - real mode paragraph address
;           returns ZR false if segment is in extended memory
;   Errors: returns CY true if selector isn't valid
;   Uses:   AX modified, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  gtpara

gtpara:
        push    cx
        push    es
        push    si

        push    bx
        mov     bx,selGDT           ;selector for the GDT segment
        mov     es,bx
        lsl     bx,bx
        and     bx,SELECTOR_INDEX
        and     si,SELECTOR_INDEX
        cmp     si,bx   ;check the given selector against
                                    ; the GDT segment limit
        pop     bx
        jc      gtpr20

; The given selector is beyond the end of the GDT, so return error.

        or      sp,sp
        stc

        Debug_Out "gtpara: invalid selector (#si)"

        jmp     short gtpr90

; The selector specified is inside the range of defined descriptors in
; the GDT.  Get the address from the descriptor.

gtpr20: mov     cl,es:[si].adrBaseHigh
        test    cl,0F0h
        jnz     gtpr90

        shl     cl,4
        mov     ax,es:[si].adrBaseLow

if DEBUG   ;------------------------------------------------------------
        test    al,0Fh
        jz      @f
        Debug_Out "gtpara: segment not on para boundry, sel #si at #cl#ax"
@@:
endif   ;DEBUG  --------------------------------------------------------

        shr     ax,4
        or      ah,cl
        cmp     ax,ax
;
gtpr90:
        pop     si
        pop     es
        pop     cx
        ret


; -------------------------------------------------------
;   SelOff2SegOff  -- This routine will return will translate a
;       protected mode selector:offset address to the corresponding
;       real mode segment:offset address.
;
;   Input:  AX      - PM selector
;           DX      - PM offset
;   Output: if Z set:
;           AX      - RM segment
;           DX      - RM offset
;           if NZ set, address is not in conventional memory, and
;             cannot be translated
;
;   Errors: none
;   Uses:   AX, DX; all else preserved
;
;   Note:  This routine is very similar to gtpara, and could replace it!

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  SelOff2SegOff

SelOff2SegOff   proc    near

        push    bx
        push    cx
        push    dx

        call    GetSegmentAddress       ;bx:dx = lma of segment

        pop     cx                      ;cx = offset

        test    bl,0f0h                 ;above 1 Meg line?
        jnz     @f                      ;  yes, cut out now

        add     dx,cx
        adc     bx,0                    ;bx:dx = lma of segment:offset

        call    Lma2SegOff              ;bx:dx = seg:off
        mov     ax,bx                   ;dx:ax = seg:off

        cmp     ax,ax                   ;under 1 Meg, set Z flag
@@:
        pop     cx
        pop     bx

        ret

SelOff2SegOff   endp


; ------------------------------------------------------
;   Lma2SegOff -- This routine converts a linear memory address
;       in BX:DX to a normalized SEG:OFF in BX:DX.
;
;   Input:  BX:DX = lma
;   Output: BX:DX = normalized SEG:OFF
;   Uses:   none


        public  Lma2SegOff

Lma2SegOff      proc    near

        push    dx
        shl     bx,12
        shr     dx,4
        or      bx,dx
        pop     dx
        and     dx,0fh

        ret

Lma2SegOff      endp


; -------------------------------------------------------
;   GetSegmentAddress   -- This routine will return with
;       the linear address of the specified segment.
;
;   Input:  AX      - segment selector
;   Output: DX      - low word of segment address
;           BX      - high word of segment address
;   Errors: none
;   Uses:   BX, DX, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  GetSegmentAddress

GetSegmentAddress:
        push    es
        push    di

        mov     es,selGDT
        mov     di,ax
        and     di,SELECTOR_INDEX
        mov     dx,es:[di].adrBaseLow
        mov     bl,es:[di].adrBaseHigh
        mov     bh,es:[di].adrbBaseHi386

        pop     di
        pop     es
        ret

; -------------------------------------------------------
;   SetSegmentAddress   -- This routine will modify the
;       segment base address of the specified segment.
;
;   Input:  AX      - segment selector
;   Output: DX      - low word of segment address
;           BX      - high word of segment address
;   Errors: None
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  SetSegmentAddress

SetSegmentAddress:
        push    si
        push    es

        mov     es,selGDT
        mov     si,ax
        and     si,SELECTOR_INDEX
        mov     es:[si].adrBaseLow,dx
        mov     es:[si].adrBaseHigh,bl
        mov     es:[si].adrbBaseHi386,bh
        push    ax
        push    bx
        push    cx
        mov     ax,si
        mov     cx,1
        mov     bx,si
.386p
        FBOP BOP_DPMI,<SetDescriptorTableEntries>,FastBop
.286p
        pop     cx
        pop     bx
        pop     ax
        pop     es
        pop     si
        ret

; -------------------------------------------------------
;   NSetSegmentAccess   -- This routine will modify the
;       access rights byte of a specified segment.
;
;   Input:  Selector    - segment selector
;           Access      - Access rights byte value
;   Output: none
;   Errors: Carry set, AX = error code
;   Uses:   All registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
cProc   NSetSegmentAccess,<PUBLIC,NEAR>,<es,si>
        parmW   Selector
        parmW   Access
cBegin
        mov     es,selGDT
        mov     si,Selector
        and     si,SELECTOR_INDEX
        mov     ax,Access
        mov     es:[si].arbSegAccess,al      ; Set access byte.
        and     ah,0F0h                      ; Mask off reserved bits.
        and     es:[si].cbLimitHi386,0fh     ; Clear old extended bits.
        or      es:[si].cbLimitHi386,ah      ; Set new extended bits.
IFDEF WOW_x86
        push    ax
        push    bx
        push    cx
        mov     ax,si
        mov     cx,1
        mov     bx,si
.386p
        FBOP    BOP_DPMI,<SetDescriptorTableEntries>,FastBop
.286p
        pop     cx
        pop     bx
        pop     ax
ENDIF

cEnd

; -------------------------------------------------------
;   ParaToLDTSelector    -- This routine will convert a segment
;       address relative to the start of the exe file into the
;       corresponding selector for the segment.  It searches the
;       LDT to see if a segment is already defined at that address.
;       If so, its selector is returned.  If not, a new segment
;       descriptor will be defined.
;
;   Note:   The LDT and GDT are currently one and the same.
;
;   Input:  AX      - paragraph aaddress of real mode segment
;           BX      - access rights byte for the segment
;   Output: AX      - selector for the segment
;   Errors: returns CY set if unable to define a new segment
;   Uses:   AX, all other registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  ParaToLDTSelector

ParaToLDTSelector  proc near

        push    bx
        push    cx
        push    dx

; Convert the paragraph address to a linear address and see if there
; is a segment defined at that address.

        mov     dx,ax
        call    FindLowSelector
        jnc     @f                      ;if so, we don't need to make one

; This segment isn't defined, so we need to create a descriptor for it.

        mov     ax,dx
        call    MakeLowSegment

if DEBUG   ;------------------------------------------------------------
        jnc     ptos80
        Debug_Out "ParaToLDTSelector: can't make selector!"
ptos80:
endif   ;DEBUG  --------------------------------------------------------

        jc      ptos90

@@:     or      al,SELECTOR_TI or STD_RING      ;look like LDT selector

; All done

ptos90: pop     dx
        pop     cx
        pop     bx
        ret

ParaToLDTSelector       endp

        public FarParaToLDTSelector
FarParaToLDTSelector proc far
        call ParaToLDTSelector
        ret
FarParaToLDTSelector endp

; -------------------------------------------------------
        page
; -------------------------------------------------------
;       DESCRIPTOR TABLE MANIPULATION ROUTINES
; -------------------------------------------------------

; -------------------------------------------------------
;   AllocateSelector    -- This function will obtain the
;       next free descriptor in the global descriptor table.
;       The descriptors in the GDT are stored on a linked list
;       of free descriptors.  The cbLimit field of the descriptor
;       is used as the link to the next element of the list. In
;       addition, free descriptors have the access rights byte
;       set to 0.
;
;   Note:   The function InitGlobalDscrTable must have been
;           called before calling this function.
;
;   Input:  none
;   Output: AX      - selector if one is available
;   Errors: CY clear if successful, AX=0 and CY set if not free selectors
;   Uses:   AX, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  AllocateSelector

AllocateSelector  proc  near

; Get the next free descriptor on the list.

        push    cx
        mov     cx, 1                   ; # of selectors needed
        mov     ax, 0
        push    ds
        FBOP    BOP_DPMI,Int31Call,FastBop
        pop     cx
        ret


AllocateSelector  endp


; -------------------------------------------------------
;   FreeSelector        --  This routine will mark the segment
;       descriptor for the specified selector as free.  This
;       is used to release a temporary selector when no longer
;       needed.  The descriptor is marked as free by setting the
;       access rights byte to 0 and placing it on the free list.
;
;   Note:   This routine can only be called in protected mode.
;
;   Input:  AX      - selector to free
;   Output: none
;   Errors: CY clear if no error, set if selector is invalid
;   Uses:   AX used, all other registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FreeSelector

FreeSelector    proc    near

        push    bx
        mov     bx,ax
        mov     ax,1
        push    ds
        FBOP    BOP_DPMI,Int31Call,FastBop
        pop     bx
        ret


FreeSelector    endp


; -------------------------------------------------------
;   FindLowSelector  -- This function will search the global
;       descriptor table for a descriptor matching the given
;       address.
;
;   Input:  AX      - real mode paragraph to search for
;           BX      - access rights byte for the segment
;   Output: AX      - selector corresponding to input paragraph address
;   Errors: returns CY set if specified descriptor not found
;   Uses:   AX, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FindLowSelector

FindLowSelector:
        push    bx
        push    dx
;
        mov     dx,ax
        push    bx
        call    ParaToLinear
        pop     ax
        mov     bh,al
        call    FindSelector
;
        pop     dx
        pop     bx
        ret


; -------------------------------------------------------
;   FindSelector    -- This function will search the global
;       descriptor table for a segment descriptor matching
;       the specified linear byte address.
;
;       Note that this routine cannot be used to find
;       selectors pointing to addresses above 16 Megabytes.
;       This is not really a problem, since the routine
;       is used to find selectors in real mode DOS land
;       most of the time.
;
;   Input:  DX      - low word of linear byte address
;           BL      - high byte of linear address
;           BH      - access rights byte for the segment
;   Output: AX      - selector of corresponding segment
;   Errors: returns CY set if specified descriptor not found
;   Uses:   AX used, all other registers preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  FindSelector

FindSelector    proc    near

        push    si
        push    di
        push    es
        push    cx

; Get segment limit of the GDT to use as a limit on the search.

        lsl     di,selGDT
        mov     es,selGDT

; Look for a descriptor matching the address in BL:AX

        mov     si,SEL_USER     ;search starting here
if 0
fnds20: cmp     es:[si].arbSegAccess,0
else
fnds20: cmp     word ptr es:[si].arbSegAccess,0
endif
        jz      fnds28          ;skip if unused descriptor
        cmp     bl,es:[si].adrBaseHigh
        jnz     fnds28
        cmp     dx,es:[si].adrBaseLow
        jnz     fnds28
if      0
        cmp     es:[si].cbLimit,0
        jz      fnds28          ;skip if dscr has 0 limit
else
        cmp     es:[si].cbLimit,0ffffh
        jnz     fnds28          ;skip unless dscr has 64k limit
endif
        mov     cl,bh
        xor     cl,es:[si].arbSegAccess
        and     cl,NOT AB_ACCESSED
        jz      fnds90
fnds28: add     si,8            ;bump to next descriptor
        jc      fnds80
        cmp     si,di           ;check against end of GDT
        jc      fnds20          ;if still less, continue on.

; Hit the end of the GDT and didn't find one.  So return error.

fnds80: stc
        jmp     short fnds99

; We found it, so return the selector

fnds90: mov     ax,si
fnds99: pop     cx
        pop     es
        pop     di
        pop     si
        ret

FindSelector    endp



; -------------------------------------------------------
; DupSegmentDscr        -- This function will duplicate the specified
;   segment descriptor into the specified destination descriptor.  The
;   end result is a second segment descriptor pointing to the same place
;   in memory as the first.
;
;   Input:  AX      - selector of segment descriptor to duplicate
;           BX      - selector of the segment descriptor to receive duplicate
;   Output: none
;   Errors: none
;   Uses:   All registers preserved.    Modifies the segment
;           descriptor for the specified segment.  If this selector happens
;           to be in a segment register when this routine is called, that
;           segment register may end up pointing to the new location.

        assume  ds:DGROUP,es:NOTHING
        public  DupSegmentDscr

DupSegmentDscr  proc    near

        push    cx
        push    si
        push    di
        push    ds
        push    es

        mov     si,ax
        mov     di,bx
        and     si,SELECTOR_INDEX
        and     di,SELECTOR_INDEX
        mov     es,selGDT
        mov     ds,selGDT
        assume  ds:NOTHING
        mov     cx,4
        cld
        rep     movs word ptr [di],word ptr [si]

        pop     es
        pop     ds
        pop     di
        pop     si
        pop     cx
        ret

DupSegmentDscr  endp

IFDEF   ROM
; -------------------------------------------------------

DXPMCODE ends

; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE
ENDIF

; -------------------------------------------------------
; NSetSegmentDscr    -- This function will initialize the
;       specified descriptor table entry with the specified data.
;
;   This function can be called in real mode or protected mode.
;
;   Input:
;               Param1  - WORD segment selector
;               Param2  - DWORD 32-bit segment base address
;               Param3  - DWORD 32-bit segment limit
;               param4  - WORD segment access/type
;   Output: returns selector for the segment
;   Errors: none
;   Uses:   Flags

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
cProc   NSetSegmentDscr,<PUBLIC,FAR>,<es,di,ax,bx>
        parmW   Selector
        parmD   Base
        parmD   Limit
        parmW   Access
cBegin
        mov     es,selGDT
        mov     di,Selector
        and     di,SELECTOR_INDEX

        mov     ax,off_Base                     ; Set segment base
        mov     es:[di].adrBaseLow,ax
        mov     ax,seg_Base
        mov     es:[di].adrBaseHigh,al
        mov     es:[di].adrbBaseHi386,ah

        mov     ax,word ptr Access
        and     ax,070ffh                       ; clear 'G' bit and
                                                ; extended limit bits
        mov     word ptr es:[di].arbSegAccess,ax
                                                ; set access
        mov     ax,seg_Limit
        mov     bx,off_Limit                    ; AX:BX = segment limit
        test    ax,0fff0h                       ; big?
        jz      ssd_0                           ; No
        shr     bx,12d                          ; Yes, make it page granular.
        shl     ax,4d
        or      bx,ax
        mov     ax,seg_Limit
        shr     ax,12d
        or      al,080h                         ; set 'G' bit
ssd_0:
        or      es:[di].cbLimitHi386,al         ; set high limit
        mov     es:[di].cbLimit,bx              ; set low limit
        push    ax
        push    bx
        push    cx
        mov     ax,di
        mov     cx,1
        mov     bx,di
.386p
        FBOP    BOP_DPMI,<SetDescriptorTableEntries>,FastBop
.286p
        pop     cx
        pop     bx
        pop     ax
cEnd

ifndef WOW_x86
; -------------------------------------------------------
; NSetGDTSegmentDscr    -- This function will initialize the
;       specified descriptor table entry with the specified data.
;
;   This function can be called in real mode or protected mode.
;
;   Input:
;               Param1  - WORD segment selector
;               Param2  - DWORD 32-bit segment base address
;               Param3  - DWORD 32-bit segment limit
;               param4  - WORD segment access/type
;   Output: returns selector for the segment
;   Errors: none
;   Uses:   Flags

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
cProc   NSetGDTSegmentDscr,<PUBLIC,FAR>,<es,di,ax,bx>
        parmW   Selector
        parmD   Base
        parmD   Limit
        parmW   Access
cBegin
        mov     ax,SEL_GDT
        mov     es,ax
        mov     di,Selector
        and     di,SELECTOR_INDEX

        mov     ax,off_Base                     ; Set segment base
        mov     es:[di].adrBaseLow,ax
        mov     ax,seg_Base
        mov     es:[di].adrBaseHigh,al
        mov     es:[di].adrbBaseHi386,ah

        mov     ax,word ptr Access
        and     ax,070ffh                       ; clear 'G' bit and
                                                ; extended limit bits
        mov     word ptr es:[di].arbSegAccess,ax
                                                ; set access
        mov     ax,seg_Limit
        mov     bx,off_Limit                    ; AX:BX = segment limit
        test    ax,0fff0h                       ; big?
        jz      @f                              ; No
        shr     bx,12d                          ; Yes, make it page granular.
        shl     ax,4d
        or      bx,ax
        mov     ax,seg_Limit
        shr     ax,12d
        or      al,080h                         ; set 'G' bit
@@:
        or      es:[di].cbLimitHi386,al         ; set high limit
        mov     es:[di].cbLimit,bx              ; set low limit
cEnd
endif ; WOW_x86


IFDEF   ROM
; -------------------------------------------------------

DXCODE  ends

; -------------------------------------------------------

DXPMCODE  segment
        assume  cs:DXPMCODE
ENDIF

; -------------------------------------------------------
;   MakeLowSegment      -- This function will create a segment
;       descriptor for the specified low memory paragraph address.
;       The segment length will be set to 64k.  The difference
;       between this and MakeScratchSelector is that this function
;       allocates a new segment descriptor in the user area of
;       the global descriptor table, thus creating a more or less
;       permanent selector.  MakeScratchSelector always uses the
;       same descriptor location in the descriptor table, thus
;       creating a very temporary selector.
;
;   Input:  AX      - paragraph address in low memory
;           BX     - access rights word for the segment
;   Output: AX      - selector to use to access the memory
;   Errors: returns CY clear if no error, CY set if unable to
;           allocate a segment descriptor
;   Uses:   AX used, all else preserved

        assume  ds:DGROUP,es:NOTHING,ss:NOTHING
        public  MakeLowSegment

MakeLowSegment  proc    near

; We need to allocate a segment descriptor, convert the paragraph address
; to a linear byte address, and then initialize the allocated segment
; descriptor.

        push    dx
        push    cx

        mov     cx,bx
        mov     dx,ax               ;paragraph address to DX
        call    AllocateSelector    ;get a segment descriptor to use
        jc      mksl90              ;get out if error
        call    ParaToLinear
        cCall   NSetSegmentDscr,<ax,bx,dx,0,0FFFFh,cx>

        clc
mksl90:
        pop     cx
        pop     dx
        ret

MakeLowSegment  endp

; -------------------------------------------------------
;   ParaToLinear
;
;   This function will convert a paragraph address in the lower
;   megabyte of memory space into a linear address for use in
;   a descriptor table.
;
;   Input:  DX      - paragraph address
;   Output: DX      - lower word of linear address
;           BX     - high word of linear address
;   Errors: none
;   Uses:   DX, BL used, all else preserved

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  ParaToLinear

ParaToLinear    proc    near

        mov     bl,dh
        shr     bl,4
        shl     dx,4
        xor     bh,bh
        ret

ParaToLinear    endp

; -------------------------------------------------------
;   RZCall -- Utility routine to call a Ring
;       Zero procedure.  Stack parameter is the NEAR
;       address of the routine in the DXPMCODE segment to
;       call.  The called routine must be declared FAR
;       and take no stack parameters.
;
;   USES:       Whatever Ring 0 routine uses
;               +Flags
;   RETURNS:    Whatever Ring 0 routine returns
;
;   NOTE:       Assumes that interrupts must be disabled
;               for the Ring 0 routine.
;
;   History:
;       12-Feb-1991 -- ERH wrote it!!!
; -------------------------------------------------------

My_Call_Gate    dd      (SEL_SCR0 or STD_TBL_RING) shl 10h

        public  RZCall
RZCall proc near

        pushf
        FCLI
        push    bp
        mov     bp,sp
        cCall   NSetSegmentDscr,<SEL_SCR0,0,SEL_EH,0,[bp+6],STD_CALL>
        pop     bp

        call    dword ptr My_Call_Gate

        cCall   NSetSegmentDscr,<SEL_SCR0,0,0,0,-1,STD_DATA>

        npopf

        retn    2

RZCall endp

; -------------------------------------------------------
; -------------------------------------------------------

DXPMCODE    ends

;
;****************************************************************

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxvcpibt.asm ===
PAGE	,132
	TITLE	DXVCPIBT.ASM -- Dos Extender VCPI Support Code (initialization)

; Copyright (c) Microsoft Corporation 1990-1991. All Rights Reserved.

;*** dxvcpibt.asm - vcpi detection/setup code (discardable)
;
;   Copyright <C> 1990, Microsoft Corporation
;
;   Purpose:
;
;   Revision History:
;
;
;  08-07-90 earleh rearranged memory map to allow building full-sized
;	    Pmode data structures in v86 mode, allow booting to Pmode
;	    without a LIM 3.2 page frame, fixed up detection code to
;	    work with various strange interpretations of LIM 4.0 by
;	    Limulator vendors.  Allow use of entire linear space below
;	    16 Meg by DOSX and VCPI server.
;
;  05/07/90 jimmat Started incorporating VCPI changes from languages group.
;
;   []      20-Feb-1990 Dans    Created
;
;
; note that this should only be called on a 386, except
;       CheckForVCPI, which can be called from 286 machines.
;
;       this code is for the real mode portion of the dos extender and
;       is released back to DOS prior to switching to protect mode the
;       first time.  NO DATA defined here in either segment as it will
;	be discarded.
;
;************************************************************************/

.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

.xlist
.sall
include         segdefs.inc
include         gendefs.inc
include         pmdefs.inc
.list

; This entire file is only for VCPI support

if VCPI

.xlist
.sall
include 	dxvcpi.inc
.list

;
; data
;

DXDATA  segment

;
; Externs
;

extrn   idCpuType:word
extrn	segBootPmode:word
extrn	pPteFirst:dword
extrn	cPteMax:dword
extrn	bpdxsyspages:dword
extrn	iddxsystype:byte
extrn	hmem_System_Block:word
extrn   fEMS:byte
extrn   fVCPI:byte
extrn   cFreePages:dword
extrn   bpGDT:fword
extrn   bpGDTbase:dword
extrn   bpGDTcb:word
extrn   bpIDT:fword
extrn   bpIDTbase:dword
extrn   bpIDTcb:word
extrn   selGDT:word
extrn   segGDT:word
extrn   selIDT:word
extrn   segIDT:word
extrn   cdscGDTMax:word
extrn   cdscIDTMax:word
extrn   segPSP:word
extrn   selPSP:word
extrn   selGDTFree:word
extrn   sysTSS:WORD
ifdef NOT_NTVDM_NOT
extrn   fHPVectra:BYTE
endif
extrn	lpfnXMSFunc:DWORD
extrn   rgbXfrBuf1:BYTE

DMAServiceSegment	equ	040h	;40:7B bit 5 indicates DMA services
DMAServiceByte		equ	07Bh	;  are currently required
DMAServiceBit		equ	020h
extrn	bDMAServiceBit:BYTE

if	DEBUG
extrn	fTraceBug:WORD
ifdef CV_TSS
extrn	FaultStack:word
endif
endif

EXTRN	hmem_XMS_Table:WORD
EXTRN	hmem_XMS_Count:WORD

	extrn	fDebug:BYTE

DXDATA	ends


DXSTACK segment

extrn	rgw0Stack:WORD

DXSTACK ends


DXCODE	segment

extrn	CodeEnd:NEAR
extrn	CallVCPI:NEAR
extrn	ResetVCPI:NEAR
extrn	segDXCode:WORD

DXCODE	ends


DXPMCODE        segment

;
; Externs
;
extrn   fnVCPIPMoff:dword
extrn   CodeEndPM:near

extrn	PMIntr31:NEAR
extrn	PMIntr28:NEAR
extrn	PMIntr25:NEAR
extrn	PMIntr26:NEAR
extrn	PMIntr4B:NEAR
extrn	PMIntr70:NEAR
extrn	PMIntrDos:NEAR
extrn	PMIntrMisc:NEAR
extrn	PMIntrVideo:NEAR
extrn	PMIntrMouse:NEAR
extrn	PMIntrIgnore:NEAR
extrn	PMInt2FHandler:NEAR
extrn	PMIntrEntryVector:NEAR
extrn	PMFaultEntryVector:NEAR
extrn	HPxBIOS:NEAR
extrn	PMFaultReflectorIRET:FAR

if DEBUG
extrn	PMDebugInt:NEAR
endif

externFP	NSetSegmentDscr

DXPMCODE	ends

DXCODE  segment

        assume  cs:DXCODE, ds:DXDATA, es:nothing

	extrn	WdebVCPI:BYTE

;
; Definitions
;
rgbEMMDrv       db      'EMMXXXX0',0    ; emm device driver name
rbgQEMMDrv      db      'EMMQXXX0',0    ; QEMM v. 5.0 with "FRAME=NONE"

DebOut_Int	equ	41h	;Wdeb386 pMode interface Interrupt
DS_VCPI_Notify	equ	005Bh	;Notify Wdeb386 of VCPI interface

	extrn	ER_QEMM386:BYTE
ERC_QEMM386     equ offset ER_QEMM386
	extrn   DisplayErrorMsg:FAR

;
; Externs
;
extrn   fnVCPIoff:dword
extrn   V86ToPm:word
extrn   laVTP:dword

;extrn   FreeEMSHandle:proc
externNP     FreeEMSHandle
extrn	SetupHimemDriver:proc


;*** QEMM386Trap
;
;   Purpose: A device driver or TSR has just failed the Windows INT 2Fh
;            AX = 1605H startup broadcast.  Version 5.1 and 5.11 of
;            QEMM386 will do this for any version of DOSX which it
;            doesn't know how to patch to work with VCPI.  Since we
;            do know how to work with VCPI now, QEMM386 is behaving in
;            an inappropriate manner.  Furthermore, QEMM386 is required
;            to output an informative message if it does this, and it
;            does not.
;
;            This routine will ask the user for permission
;            to proceed.
;
;   Uses:
;
;   Input:   A process has told DOSX not to load by returning
;            non-zero in CX on an INT 2Fh, AX=1605h.
;
;   Output:  AX = Zero, proceed.
;            AX = Non-zero, abort.
;
;************************************************************************/
cProc QEMM386Trap,<NEAR,PUBLIC>,<ds,es>
cBegin

	mov     dx,cs                   ;pass msg ptr in DX:AX
	mov     ax,ERC_QEMM386
	call    DisplayErrorMsg         ; Tell the user something

	mov     ah, 8                   ; Get a character from the keyboard
	int     21h
	or      al,20h                  ; Force lower case.
	cmp     al,'y'                  ; Party if it's a 'y'.
	mov     ax,0
	jne     IQ_Abort
	jmp     IQ_Exit

IQ_Abort:
	dec     ax
IQ_Exit:
IQ_Not_Open:
	or      ax,ax
cEnd

;*** CheckForEMS
;
;   Purpose:    see if an ems driver is loaded
;
;   Register
;       Usage:  ax, cx
;
;   Input:      ES:BX contains int 67h vector.
;
;   Output:     none
;
;   Returns:    carry not set if ems is loaded, set if not
;
;   Exceptions: none
;
;   Notes:      This checks for a LIM 4.0 driver.  It also checks
; 		for a driver named 'EMMQXXX0' which could be QEMM 5.0
;		without a page frame.
;
;************************************************************************/

cProc CheckForEMS,<NEAR,PUBLIC>,<di,si,ds>
cBegin

	mov	di, 0ah 			; es:di has string to look at

        mov     ax, cs
        mov     ds, ax

	assume  ds:DXCODE,ss:DGROUP

        mov     si, offset DXCODE:rgbEMMDrv     ; ds:si has driver string
	mov	cx, CBEMMSTR			; cx has rep count
        repe    cmpsb
	jne	short CheckFor_QEMM
						; try QEMM driver with
						; non-standard name for
						; "FRAME=NONE"

	emscall GETEMSVER
        or      ah, ah
	jz	@F
        xor     ax, ax
@@:
	cmp	al, 40h				; LIM 4.0?
	jb	Failure_Exit			; No, can't use it.

	inc	fEMS				; set flag
	clc					; return success
	jmp     CheckForEMS_ret
CheckFor_QEMM:					; look for QEMM signature
	mov	di, 0ah 			; es:di has string to look at
	mov	si, offset DXCODE:rbgQEMMDrv	; ds:si has driver string
	mov	cx, CBEMMSTR			; cx has rep count
        repe    cmpsb
	jne	short Failure_Exit		; if not equal, exit
	inc	fEMS				; set flag
	clc
	jmp     CheckForEMS_ret

Failure_Exit:
	stc					; zero out return value first
CheckForEMS_ret:
cEnd

assume  ds:DGROUP


;*** CheckForVCPI
;
;   Purpose:    to see if a vcpi server is loaded
;
;   Register
;       Usage:  ax, bx, cx
;
;   Input:      none
;
;   Output:     none
;
;   Returns:    ax = vcpi version if it is loaded, 0 otherwise
;
;   Exceptions: none
;
;   Notes:      this calls CheckForEMS first, and EMSVer as well
;
;************************************************************************/
cProc CheckForVCPI,<NEAR,PUBLIC>,<es>
cBegin

	cmp	idCpuType, 3		; must be 386 or better to have
	jnb	@F
	jmp	novcpi286		;  vcpi server running.
@@:
.386
        mov     ax, 03500h+EMS_INT      ; ah = get interrupt, al = vector to get
	int	021h			; returns with es:bx == int vector
	mov	ax,es			; int vector set?
	or	ax,bx
	jz	novcpi			; No.

	call	CheckForEMS
	jc	novcpi			; no ems, can't be any vcpi
	
	call	SwitchToV86		; force v86 mode
        or      al, al
        jz      novcpi                  ; failed to allocate, out of here

        RMvcpi  vcpiVER                 ; see if vcpi is available
        or      ah, ah
	jnz	novcpi

	inc	fVCPI			; set flag

	jc	novcpi


	movzx	eax,segBootPmode
	shl	eax,4
	add	eax,GDTOFF
	shr	eax,4

	mov	selGDT,ax		; save it for later
	mov	segGDT,ax		; save it for later

	; If this is changed, then GetVCPIInterface must be changed
	; to save correct value in pPteFirst.
.ERRE   VCPIPTOFF EQ 0

	cCall   GetVCPIInterface,<segBootPmode,VCPIPTOFF,ax,SEL_VCPI>

	call	SetupPageTables 	;
	jc	novcpi			; had a problem setting up page table
;
; Load the VDS-implemented bit from the BIOS data area.
;
	mov	ax,DMAServiceSegment
	mov	es,ax
	mov	al,byte ptr es:[DMAServiceByte]
	and	al,DMAServiceBit
	mov	[bDMAServiceBit],al

	RMvcpi	vcpiVER 		; refetch VCPI version
	mov	ax,bx			; put it in AX
	jmp	CheckForVCPI_exit	; return no error
.286p
novcpi:
        call    FreeEMSHandle           ; free the handle we allocated.
novcpi286:				; (Free routine uses 386 instructions.)
	xor	ax, ax			; none loaded
CheckForVCPI_exit:
cEnd

DXCODE  ends

;**************************************************************
;       386 only code from here on down!!!
;**************************************************************
.386p
include         prot386.inc

DXCODE  segment

        assume  cs:DXCODE, ds:DXDATA, es:nothing

;*** SwitchToV86
;
;   Purpose:    Switch to v86 mode in preparation for vcpi calls
;
;   Register
;       Usage:  eax, bx, ecx, es
;
;   Input:      none
;
;   Output:     hEMM is updated, pages are mapped into ems frame
;		segBootPmode setup
;
;   Returns:    al == 1 if successful, al == 0 otherwise
;
;   Exceptions: none
;
;   Notes:      By allocating an ems handle/page, we force the lim 4.0
;               emulator to switch from real mode to v86 mode.  Do not free
;               the ems memory until exit time.
;
;************************************************************************/
cProc SwitchToV86,<NEAR,PUBLIC>,<es,si,edi,cx>
cBegin
;
	smsw	ax
	test	al,01h			; In V86 mode?
	jz	stv_badexit		; We don't know how to turn on
					; a VCPI server without allocating
					; EMS memory.
	mov	cx,(offset CodeEnd) + CBPAGE386 - 1
	shr	cx,4
	mov	ax,segDXCode
	add	ax,cx
	and	ax,0FF00H		; page align DOS block

	mov	segBootPmode,ax
	mov	es,ax			; zero it out

	mov	al,1

	jmp     stvExit

stv_badexit:
	call	FreeEMSHandle
	xor	al, al
stvExit:
cEnd

;*** GetVCPIInterface
;
;   Purpose:    To retrieve the vcpi protect mode interface data
;
;   Register
;       Usage:  es, ax, edx, ebx
;
;   Input:      lpPT: far ptr to a page table
;               lprggdte: far ptr to a range of 3 gdt entries.
;
;   Output:     fnVCPIoff updated with 32-bit offset of pm entry point
;                       for vcpi calls
;               *lpPT updated with 4k vcpi 0th page table
;               *lprggdte updated with vcpi server code segment, extras
;
;
;   Returns:    nothing
;
;   Exceptions:
;
;   Notes:      only call in real mode prior to relocation of DosExtender,
;               as it sets up a variable in DXPMCODE that needs to be
;               copied up when relocated.
;
;************************************************************************/
cProc GetVCPIInterface,<NEAR,PUBLIC>,<es>
parmD  lpPT
parmD  lprggdte
cBegin
        push    ds                      ; save ds
        les     di, lpPT                ; es:di -> vcpi's page table
        lds     si, lprggdte            ; ds:si -> vcpi's gdt entries

        assume ds:nothing

        RMvcpi  vcpiPMINTERFACE
	mov	word ptr pPteFirst,di
	mov	ax, CBPAGE386		; AX = size of page table
	sub	ax, di			; AX = #bytes left over in zeroth PT
	shr	ax, 2			; AX = #PTEs left over
	add	ax, DXPTMAX shr 2	; AX = total # user PTEs available,
	mov	word ptr cPteMax, ax	; counting those in zeroth PT
        pop     ds                      ; restore ds

        assume ds:DXDATA

        mov     fnVCPIoff, ebx
        mov     ax, seg DXPMCODE
        mov     es, ax

        assume  es:DXPMCODE

        mov     fnVCPIPMoff, ebx        ; set pm call
;
; Refer to VCPI spec. Version 1.0 for why this call sequence is used to
; find the number of VCPI pages we may allocate.
;
	emscall GETNUMOFPAGES
	movzx	ebx,bx			; BX = unallocated EMS pages
	shl	ebx, 2			; EBX = unallocated VCPI pages
	mov	cFreePages, ebx 	; Never allocate more than this amt.

cEnd

	assume es:nothing

;*****************************************************************************
;       Memory map of system tables buffer prior to switch to protected
;	mode under vcpi.
;
;	      __+-------------------------------+->USERPTOFF
;	      __+-------------------------------+->LDTTOP
;     ~100k	|				|
;               |                               |
;		|   LDT, 64k (8190 entries)	|
;               |                               |
;               |                               |
;		|_______________________________|->
;		|				|
;               |                               |
;               |                               |
;		|     DXPMCODE (~18.5k) 	|
;               | Exact size may be found from  |
;               |       codeendPM symbol.       |
;               |                               |
;	      __|_______________________________|
;		|				|->DXPMCODEOFF (GDTTOP)
;		|	      GDT		|
;	      __|_______________________________|
;		|				|->GDTOFF
;               | TSS space (2 of them for 386) |
;      18k    __|_______________________________|
;		|	   IDT, 2k		|->TSSOFF
;      16k    __|_______________________________|
;		|				|->IDTOFF
;		|				|
;               |     page directory (DXPD)     |
;      12k    __|_______________________________|
;		|				|->DXPDOFF
;		| DOSX Pmode page table (DXPT2) |
;               |        (DXLINEARBASE)         |
;	8k    __|_______________________________|
;		|				|->DXPTSYSOFF
;               |  1st user page table (DXPT1)  |
;               |           (4-8 Meg)           |
;       4k    __|_______________________________|
;		|				|->DXPT1OFF = DXTEMPPTOFF
;               |    0th page table (VCPIPT)    |
;               |           (0-4 Meg)           |
;	0k    __|_______________________________|->VCPIPTOFF
;		|   Wasted for page alignment	|
;   CodeEnd --->|-------------------------------|
;    Label
;
; System data structures and DOSX Pmode code will be located at linear
; addresses pointed to by the page table which begins at DXPTSYSOFF.
; During the first switch to Pmode, these addresses will exist in a
; block of conventional memory allocated from DOS.  After the first
; switch, a block of extended memory allocated from VCPI will be used.
; The user page table starting at DXTEMPPTOFF will be used to access the
; second block of memory for initialization purposes.
;
; Note that the first page, which contains the zeroth page table, shared
; with the VCPI server, must use the same physical page of memory before
; and after the switch.
;
;       Terms:
;               DXPMCODE        Dos eXtender Protect Mode CODE
;               IDT             Interrupt Descriptor Table
;               GDT             Global Descriptor Table
;               DXPTx           Dos eXtender Page Table number x
;               VCPIPT          VCPI Pate Table (we can't touch this one)
;               DXPD            Dos eXtender Page Directory
;
;*****************************************************************************

;*** SetupPageTables
;
;   Purpose:    To set up page tables and directory in ems
;               frame (as described above)
;
;   Register
;       Usage:  eax, bx, cx, edx, esi, edi
;
;   Input:      none
;
;   Output:     DXPD, DXPTx, GDT setup.
;
;   Returns:    cy set if error
;
;   Exceptions:
;
;   Notes:
;
;************************************************************************/
cProc SetupPageTables,<NEAR,PUBLIC>,<ds,es>
cBegin

	mov	cdscGDTMax,8190 ; max out the GDT size

	mov	bx, segBootPmode
	mov	es, bx
	mov	di,DXBOOTPTOFF
	shr	bx, 8			; convert to 16-bit page aligned

;
; Our extended memory stuff is located in a single contiguous
; block of DOS memory.
;
	mov	ecx, DXPMPAGES
physaddrloop:
        xchg    cx, bx                  ; put page number in cx, save count
                                        ;       in bx
        RMvcpi  vcpiPHYSADDRPAGE        ; get the physical address
        or      ah, ah
        jnz     badexit
        and     dx, 0f000h              ; mask off 12 lsb's
        or      dx, NEWPTEMASK          ; store with decent page flags
        mov     es:[ di ], edx          ; store physical in DXPT1
        add     di, 4                   ; advance to next
        xchg    cx, bx                  ; get loop counter in cx,
        inc     bx                      ; advance to next page in ems frame
	loop	physaddrloop
pagesmapped:
	;
        ; Save away the page directory base for cr3 loading
	;
	mov	eax, es:[DXBOOTPTOFF + (DXPDOFF shr 10)]
					; Save the pte (physical addr) of
        and     ax, 0f000h              ;  page directory, mask 12 lsb's
        mov     V86ToPm.zaCr3VTP, eax   ; store it
        ;
        ; Save the linear address of bpGDT and bpIDT in V86ToPm as well
        ;
        xor     eax, eax
        mov     ax, DXDATA              ; dgroup segment, masked hi word
        shl     eax, 4                  ; linearize it
        mov     ebx, eax                ; save it
        add     eax, offset DGROUP:bpGDT; add in offset
        mov     V86ToPm.laGdtrVTP, eax  ; save it in vcpi v86 to pm structure
        mov     eax, ebx                ; restore linear dgroup
        add     eax, offset DGROUP:bpIDT; add in offset
        mov     V86ToPm.laIdtrVTP, eax  ; save it in vcpi v86 to pm structure
        xor     eax, eax
        mov     ax, cs                  ; get current code segment
        shl     eax, 4                  ; linear dxcode
        add     eax, offset DXCODE:V86ToPm      ; add in offset of v86 to pm structure
        mov     laVTP, eax              ; save linear ptr of v86 to pm structure
        ;
        ; set up the page directory (DXPD)
        ;       with 0-x to be VCPIPT thru DXPTx (x+1 total)
        ;
        ; (copy them out of dxpt1, starting with the 2nd entry)
	;

	mov	edi, DXPDOFF
	push	ds
	push	es			; make ds point to emspageframe
        pop     ds                      ;  as well
	assume ds:nothing
	mov	esi, DXBOOTPTOFF + (VCPIPTOFF shr 10)	; point to 2nd entry in DXPT1
					; (must be VCPIPT)
	mov	ecx, CPTDX + 1		; # of user pt's + vcpi's pt
	rep	movsd
					; point DXLINEARBASE at system area
	mov	esi,DXBOOTPTOFF + (DXBOOTPTOFF shr 10)
	mov	edi,DXPDOFF + (DXLINEARBASE shr 20)
	movsd

	pop	es
	assume  es:DGROUP
;
; Allocate a block of VCPI 4k pages, enough to copy our system tables
; and Pmode code into once we have achieved protected mode operation.
; Map these pages into one of the page tables that is unused until
; heap initialization time.
;
; If there is insufficient VCPI memory to complete this operation, then
; we try to grab XMS memory instead.
;
	lea	di,bpdxsyspages
	
	cmp	cFreePages, DXPMPAGES-1
	jc	tryXMSServer		; insufficient VCPI pages to
					; build this block
	mov	cx,DXPMPAGES-1
allocate_syspage_from_VCPI:
	RMvcpi	vcpiALLOCPAGE
	or	ah,ah
	jnz	badexit
	mov	eax,edx
	stosd
	loop	allocate_syspage_from_VCPI

        sub     cFreePages,  DXPMPAGES-1

	mov	iddxsystype,DXINVCPI
;
; Map these pages into a temporary area, which we use later to move most
; of the stuff in this DOS block up into extended memory.
;
	push	es
	pop	ds
	assume	es:nothing,ds:DGROUP
	mov	ax, segBootPmode
	mov	es, ax
	lea	si,bpdxsyspages
	mov	cx,DXPMPAGES-1
	mov	di,DXTEMPPTOFF
	mov	eax,es:[DXBOOTPTOFF + (VCPIPTOFF shr 10)]
	stosd
copy_syspage:
	lodsd
 	or	eax,NEWPTEMASK
	stosd
	loop	copy_syspage
	jmp	goodexit
tryXMSServer:
	assume	es:nothing,ds:DGROUP
	push	es
	pop	ds
	call	SetupHimemDriver		; Need XMS driver now.
	mov	dx,DXPMPAGES shl 2		; kbytes = pages times 4
	xmssvc	09h				; allocate an XMS block
	cmp	ax,1				; got a block?
	jne	goodexit			; no, try using DOS mem.
	mov	hmem_System_Block,dx
	xmssvc	0ch				; lock the block
	cmp	ax,1				; did it work?
	je	@F
	mov	dx,hmem_System_Block		; No, free it up.
	mov	hmem_System_Block,0
	xmssvc	0ah
	jmp	goodexit			; and try to run in DOS mem
@@:
	shl	edx,10h				; DX:BX = locked block address
	mov	dx,bx				; EDX = locked block address
;
; Make sure the locked XMS block is page aligned.  If is not, then we
; will have to adjust the bottom address used and shrink the GDT by a
; full 386 page.
;
	test	dx,MASK allbitsPTE
	jz	XMSpagealigned
	and	dx,MASK pfaPTE
	sub	cdscGDTMax,CBPAGE386 / 8	; shrink the GDT size
XMSpagealigned:
	mov	ax, segBootPmode
	mov	es, ax
	mov	di,DXTEMPPTOFF
	mov	eax,es:[DXBOOTPTOFF + (VCPIPTOFF shr 10)]
	stosd
	mov	cx,DXPMPAGES-1
	mov	eax,edx
 	or	eax,NEWPTEMASK
insertXMSpage:
	stosd
	add	eax,CBPAGE386
	loop	insertXMSpage
	mov	iddxsystype,DXINXMS
goodexit:
	clc
	jmp     exit
badexit:
        stc
exit:

cEnd

        assume ds:DXDATA


;*** InitGDTVCPI - initialize the gdt when running under vcpi
;
;   Purpose:
;
;   Register
;       Usage:  uses eax, all others preserved
;
;   Input:      none
;
;   Output:     gdt/ldt is initialized
;
;   Returns:	returns carry set if failure to map EMS pages
;
;   Exceptions:
;
;   Notes:
;
;************************************************************************/

        assume  ds:DGROUP,es:DGROUP,ss:NOTHING
        public  InitGDTVCPI
cProc   InitGDTVCPI,<NEAR,PUBLIC>,<ebx,ecx,edx,di,es>
cBegin
	mov	edx,LADXGDTBASE 	; set gdt linear address
	mov	bpGDTbase,edx
	mov	ecx,GDT_SIZE - 1	; set the GDT segment size
	mov	bpGDTcb,cx
	mov	bh, STD_DATA		; make it be a data segment
	mov	ax, SEL_GDT
	cCall	NSetSegmentDscr,<SEL_GDT,edx,ecx,STD_DATA>

; Set up a descriptor for the LDT and an LDT data alias.

	mov	edx,LADXLDTBASE
	movzx	ecx,cdscGDTMax
	shl	ecx,3
	dec	ecx
	cCall	NSetSegmentDscr,<SEL_LDT,edx,ecx,STD_LDT>

;
; Set up the descriptors for the page directory and page tables
;
	mov	eax,LADXPDBASE
	cCall	NSetSegmentDscr,<SEL_DXPD,eax,0,CBPAGE386LIM,STD_DATA>

	mov	edx, LADXPTBASE 	; EDX = user page tables linear base

	mov	ecx, ( (CPTDX + 1) shl 12 ) - 1
			    ; # of user PTE's + vcpi's PTE's minus one
	cCall	NSetSegmentDscr,<SEL_DXPT,edx,ecx,STD_DATA>

; Setup a selector and data alias for the TSS

	mov	edx,LADXTSS1BASE		;get base address of TSS
	mov	ecx,(TYPE TSS386) - 1
	cCall	NSetSegmentDscr,<SEL_TSS,edx,ecx,STD_TSS386>

	mov	eax,DXLINEARBASE
	xor     ecx,ecx
	dec     cx
	cCall	NSetSegmentDscr,<SEL_LDT_ALIAS,eax,ecx,STD_DATA>
	mov     eax,DX_TEMP_LINEARBASE
	cCall	NSetSegmentDscr,<SEL_TSS_ALIAS,eax,ecx,STD_DATA>


; Set up a descriptor for our protected mode code.

	mov	dx,cs
	movzx	edx,dx			;our code segment paragraph address
	shl	edx,4			;convert to linear byte address
	cCall	NSetSegmentDscr,<SEL_DXCODE,edx,0,0ffffh,STD_CODE>

; Set up another one, but ring 0 this time.

	cCall	NSetSegmentDscr,<SEL_DXCODE0,edx,0,0ffffh,ARB_CODE0>

	mov	edx,LADXPMCODEBASE	; EDX = LADXPMCODEBASE
	mov	ecx, offset DXPMCODE:CodeEndPM + 10h
	cCall	NSetSegmentDscr,<SEL_DXPMCODE,edx,ecx,STD_CODE>
;
; Set up the Ring 0 DXPMCODE alias for handling protected mode processor
; exceptions.
;
	cCall	NSetSegmentDscr,<SEL_EH,edx,ecx,EH_CODE>

; Set up a descriptor for our protected mode data and stack area.

	mov	dx,ds
	movzx	edx,dx			;our data segment paragraph address
	shl	edx,4			;convert to linear byte address
	mov	ecx,0FFFFh
	cCall	NSetSegmentDscr,<SEL_DXDATA,edx,ecx,STD_DATA>

; And another one of those for ring 0

	cCall	NSetSegmentDscr,<SEL_DXDATA0,edx,ecx,ARB_DATA0>

; Set up descriptors pointing to our PSP and environment.

        movzx   edx, segPSP             ; segment address of the PSP
        shl     edx, 4                  ; linear address of PSP
	cCall	NSetSegmentDscr,<SEL_PSP,edx,ecx,STD_DATA>
        mov     selPSP, SEL_PSP

; set up environment selector

        push    es
        mov     es,segPSP
        assume  es:PSPSEG
	movzx	edx,segEnviron		;segment addr of environment
	shl	edx,4			;linear address of env
	mov	ecx,7FFFh		;environments can only be 32k
					; byte by DOS
	cCall	NSetSegmentDscr,<SEL_ENVIRON,edx,ecx,STD_DATA>
        pop     es
        assume  es:DGROUP

; Set up a descriptor pointing to the BIOS code and data areas

        mov     edx, 0f0000h            ; set to linear f0000 (f000:0000)
        mov     ecx, 0ffffh             ; make it be a 64k segment
	cCall	NSetSegmentDscr,<SEL_BIOSCODE,edx,ecx,STD_CODE>

        mov     edx, 40h * 16           ; linear byte addr of BIOS data area
	cCall	NSetSegmentDscr,<SEL_BIOSDATA,edx,ecx,STD_DATA>

; Set up a descriptor pointing to the real mode interrupt vector table.
        xor     edx, edx                ; the IVT is at linear address 0,
					;other registers are still set up
                                        ; 64k data segment from last one
	cCall	NSetSegmentDscr,<SEL_RMIVT,edx,ecx,STD_DATA>

; And,	set up a selector for VCPI/WDEB386 to use to access all of memory.
	xor	edx,edx
	mov	ecx,edx
	dec	ecx
	cCall	NSetSegmentDscr,<SEL_VCPIALLMEM,edx,ecx,ARB_DATA0>

; Set up the call gate descriptor for the reset to V86 mode routine.

	mov	ecx,offset DXCODE:ResetVCPI
@@:	mov	edx,SEL_DXCODE0
	cCall	NSetSegmentDscr,<SEL_RESET,edx,ecx,STD_CALL>

; Set up a call gate to invoke the VCPI pMode interface in ring 0.

	mov	ecx,offset DXCODE:CallVCPI
	cCall	NSetSegmentDscr,<SEL_CALLVCPI,edx,ecx,STD_CALL>

; Init call gate descriptors for all the DynaLink services.

if DEBUG   ;------------------------------------------------------------

	extrn	DXOutDebugStr:NEAR

	mov	ax,SEL_DYNALINK + (OutDebugStr shl 3)
	mov	ecx,offset DXCODE:DXOutDebugStr
	mov	edx,(SEL_DXCODE0 or EH_RING) or 00080000h ;copy 8 stack words
	cCall	NSetSegmentDscr,<ax,edx,ecx,STD_CALL>

	extrn	DXTestDebugIns:NEAR

	mov	ax,SEL_DYNALINK + (TestDebugIns shl 3)
	movzx	edx,dx					  ;copy 0 stack words
	mov	ecx,offset DXCODE:DXTestDebugIns
	cCall	NSetSegmentDscr,<ax,edx,ecx,STD_CALL>

endif	;DEBUG ---------------------------------------------------------

; Set up the fault reflector IRET call gate.

	mov	ax,offset DXPMCODE:PMFaultReflectorIRET
	cCall   NSetSegmentDscr,<SEL_RZIRET,5,SEL_EH,0,ax,STD_CALL>

	clc
cEnd


;*** InitIDTVCPI                       ;[ds]
;
;   Purpose:    to initialize the idt when running under vcpi
;
;   Register
;       Usage:  eax, all others preserved
;
;   Input:      none
;
;   Output:     idt is initialized
;
;   Returns:    can't fail, cy clear
;
;   Exceptions:
;
;   Notes:      only under real mode!!!!!
;
;************************************************************************/
cProc   InitIDTVCPI,<NEAR,PUBLIC>,<ebx,ecx,edx,di,es>
cBegin

	jnc	@F
	jmp     InitIDTVCPI_ret
@@:
	movzx	eax, segBootPmode	 ; set up segIDT,selIDT with
	shl	eax, 4			; the RM seg of the idt
        add     eax, IDTOFF
        ;
        ; IDT must be paragraph aligned!!!!! (guarenteed--see dxvcpi.inc)
        ;
        shr     eax, 4
        mov     segIDT, ax              ; base of IDT
        mov     selIDT, ax              ;

        movzx   ecx, cdscIDTMax         ; number of descriptors in table
        shl     cx, 3                   ; convert to count of bytes
        dec     cx                      ; compute segment size limit

        mov     bpIDTcb, cx             ; set up idtr with limit,
        mov     edx, LADXIDTBASE        ; ...and...
        mov     bpIDTbase, edx          ; ...linear base
	cCall	NSetSegmentDscr,<SEL_IDT,edx,ecx,STD_DATA>

; Fill the IDT with interrupt gates that point to the interrupt reflector
; entry vector.

        mov     es, segIDT
	xor	di,di
	mov	dx,offset DXPMCODE:PMFaultEntryVector	;the 1st 32 go here
	mov	cx,32
@@:	mov	es:[di].offDest,dx
	mov	es:[di].selDest,SEL_EH or EH_RING
        mov     es:[di].cwParam,0
	mov	es:[di].arbGate,STD_INTR
        mov     es:[di].rsvdGate,0
        add     dx,3
        add     di,8
	loop	@b

	mov	dx,offset DXPMCODE:PMIntrEntryVector+(32*3) ; the rest go here
	mov	cx,cdscIDTMax
	sub	cx,32
@@:	mov	es:[di].offDest,dx
	mov	es:[di].selDest,SEL_DXPMCODE or STD_RING
        mov     es:[di].cwParam,0
	mov	es:[di].arbGate,STD_INTR
        mov     es:[di].rsvdGate,0
        add     dx,3
        add     di,8
	loop	@b

; Now, fix up the ones that don't point to the interrupt reflector.

	mov	es:[21h*8].offDest,offset DXPMCODE:PMIntrDos
	mov	es:[25h*8].offDest,offset DXPMCODE:PMIntr25
	mov	es:[26h*8].offDest,offset DXPMCODE:PMIntr26
	mov	es:[28h*8].offDest,offset DXPMCODE:PMIntr28
	mov	es:[2Fh*8].offDest,offset DXPMCODE:PMInt2FHandler
	mov	es:[30h*8].offDest,offset DXPMCODE:PMIntrIgnore
	mov	es:[31h*8].offDest,offset DXPMCODE:PMIntr31
	mov	es:[33h*8].offDest,offset DXPMCODE:PMIntrMouse
	mov	es:[41h*8].offDest,offset DXPMCODE:PMIntrIgnore

if DEBUG   ;-------------------------------------------------------------

	cmp	fTraceBug,0
	jz	@f
	mov	es:[41h*8].offDest,offset DXCODE:PMDebugInt
	mov	es:[41h*8].selDest,SEL_DXCODE or STD_RING
@@:
endif	;DEBUG	---------------------------------------------------------

	mov	es:[4Bh*8].offDest,offset DXPMCODE:PMIntr4B

ifdef NOT_NTVDM_NOT
	;  HP Extended BIOS System Call handler

	test	fHPVectra,0ffh		;only do this for an HP Vectra
	jz	NoHPBios

; Supposedly the system driver is going to force the HP Bios to
; use interrupt 6Fh while Windows is running, so we don't need to
; search for the moveable HP Bios interrupt--just use Int 6Fh.

	mov	es:[6Fh*8].offDest,offset HPxBios

NoHPBios:
endif
	mov	es:[70h*8].offDest,offset DXPMCODE:PMIntr70

	clc				; return success
InitIDTVCPI_ret:

cEnd

;*** InitTSSVCPI - initialize the tss for use under vcpi
;
;   Purpose:
;
;   Register
;       Usage:  uses eax, all others preserved
;
;   Input:      none
;
;   Output:	tss is setup
;
;   Returns:    none
;
;   Exceptions: none
;
;   Notes:      none
;
;************************************************************************/
cProc    InitTSSVCPI,<NEAR,PUBLIC>,<es,di>
cBegin

	jnc	@F
	jmp     InitTSSVCPI_ret
@@:
	mov	ax, segBootPmode
	add	ax, ( (TSSOFF shr 16d) shl 12d )
	mov	es, ax
	mov	di, TSSOFF AND 0FFFFH

	mov	es:[di + ts3_ldt],SEL_LDT	;set the LDT selector

; Set the ring 0 stack seg/pointer, we don't bother to set the others
; since nothing runs below user privilege level.  Currently very little
; code runs ring 0 - just when switching between real/proteted modes.

	mov	es:[di + ts3_ss0],SEL_DXDATA0
	mov	word ptr es:[di + ts3_esp0],offset DGROUP:rgw0Stack

	clc
InitTSSVCPI_ret:

cEnd

;
;************************************************************************/
;
; The rest of this file is code which is called during protected mode
; initialization.
;
;************************************************************************/
;
;**************************************************************
;*** CallVCPIPM
;
; Utility routine to call VCPI server in protected mode.  Masks out
; interrupts during the call because QEMM enables the processor
; interrupt flag when you call it.
;
; Entry: AX = VCPI function code.
; Uses:  Depends upon call.
;
; Note: There is a copy of this routine in dxvcpi.asm and another
;	in dxvcpibt.asm.  This is to allow near calls.	The copy
;	in dxvcpibt.asm is discarded after initialization time.
;
;**************************************************************
cProc	CallVCPIPM,<NEAR>,<si>
cBegin

	push	ax			   ; save function code
;
; Shut out all interrupts.
; QEMM 5.0 enables interrupts during this call.  All our interrupt
; handlers are in the user code ring.  A workaround is to shut off
; hardware interrupts during the call.
;

        in      al,INTA01
	IO_Delay
	mov	si, ax
	mov	al,0FFh
	out	INTA01,al
	IO_Delay

	pop	ax			    ;restore function code
	db	9Ah			    ;call  far SEL_CALLVCPI:0
	dw	0,SEL_CALLVCPI or STD_RING

; Restore the state of the interrupt mask register

	xchg	si, ax
        out     INTA01,al
	IO_Delay
	xchg	si, ax
cEnd
;**************************************************************
; This variable is used to allow calling NSetSegmentDscr from
; the DXCODE segment in protected mode.
;
NSetSegmentDscrCall label dword
	dw OFFSET DXPMCODE:NSetSegmentDscr,SEL_DXPMCODE or STD_RING

	extrn	EnterProtectedMode:NEAR
	extrn	EnterRealMode:NEAR

DXCODE	ends

DXPMCODE	segment
	extrn	XMScontrol:FAR
DXPMCODE	ends

DXCODE	segment

XMScontrolCall	label dword
	dw OFFSET DXPMCODE:XMScontrol,SEL_DXPMCODE or STD_RING

pmxmssvc macro   fcn
	ifnb    <fcn>
	mov     ah, fcn
	endif
	call	XMScontrolCall
endm

;************************************************************************/
;*** GrowPageTables
;
; Purpose:  To grow the user memory page tables large enough to
;	    accomodate any expected memory allocation request.
;
; Register
;     Usage: NONE
;
; Input: NONE
;
; Output: Page tables grown to anticipated demand.  cPteMax updated.
;	  Page table segment limit extended.
;
; Returns:
;
; Exceptions:
;
; Notes: Fails unless there is an XMS block to hold the new page
;	 tables.  Cannot extend the page tables using VCPI memory.
;
;************************************************************************/
cProc GrowPageTables,<NEAR,PUBLIC>,<ebx,ecx,edx,si,di,es>

cBegin

	PMvcpi	vcpiCFREEPAGES		; Fetch current VCPI free pages
	mov	ecx,edx
	pmxmssvc  08h			; Query free extended memory
	shr	ax,2			; convert to pages
	movzx	eax,ax
	add	ecx,eax			; ECX = theoretical pages we could
					; allocate
	sub	ecx,cPteMax		; minus what we have room for
	jna	GPT_ret 		; enough space already
;
; So we work on machines with more than 64 Meg. RAM, we should put in a check
; here to see whether it looks like we have more.
;
	shr	ecx,8			; ECX = kilobytes to hold this stuff
;
; Instead, we do this quick hack for now.  If there appears to be more
; than 60 Mb available, then grow the page tables to 512k.
;
	cmp	ecx,60
	jb	@F
	mov	ecx,512
@@:
	mov	dx,cx
	add	dx,3			; need to page align

	pmxmssvc  09h			; Allocate a chunk of XMS to hold it
	or	ax,ax
	jz	GPT_ret

	lea     si, hmem_XMS_Table      ; SI points to saved handles buffer
	inc	[hmem_XMS_Count]	; bump XMS handle count
	mov	[si],dx 		; save handle for later disposal

	pmxmssvc  0Ch			; lock the handle
	or	ax,ax
	jnz	@F			; jump on success
	mov	dx,[si] 		; couldn't lock handle
	pmxmssvc  0Dh			; free it
	dec	[hmem_XMS_Count]	; decrement count of allocated handles
	jmp	GPT_ret 		; out of here
@@:
	shl	edx,16			; EDX = physical address of extended
	mov	dx,bx			; page tables

	shr	edx,10
	add	edx,3			; begin on a page boundary
	shr	edx,2
	shl	edx,12
	or	dl,NEWPTEMASK		; EDX = first PTE

	mov	selGDT,SEL_GDT
	mov	ax,SEL_DXPT
	lsl	ebx,eax
	shl	ecx,10			; ECX = extra space in bytes
	add	ebx,ecx 		; EBX = page table segment limit
	mov	eax, LADXPTBASE		; EAX = user page tables linear base
	cCall	[NSetSegmentDscrCall],<SEL_DXPT,eax,ebx,STD_DATA>
	mov	selGDT,SEL_LDT_ALIAS

	mov	eax,ecx
	shr	eax,2			; ECX = new PTEs
	add	cPteMax,eax

	add	ecx,CBPAGE386 - 1
	shr	ecx,12			; ECX = pages of page tables
	mov	ax,SEL_DXPD
	mov	es,ax
	mov	edi, ( CPTDX + 1 ) shl 2

	push	ecx
	push	edi
	mov	eax,edx

;
; Map the new page tables into the page directory.
;
GPT_add_PD:
	stos	dword ptr es:[edi]
	add	eax,CBPAGE386
	dec	ecx
	jnz	GPT_add_PD

;
; Map the new page tables into the page table segment, by copying
; the page directory entries.
;
	mov	eax, DXLINEARBASE + DXPTSYSOFF + ( USERPT shl 2 )
	xor	ecx,ecx
	dec	cx
	cCall	[NSetSegmentDscrCall],<SEL_SCR0,eax,ecx,STD_DATA>
	pop	edi
	mov	esi,edi
	pop	ecx
	push	ds
	assume	ds:nothing
	mov	ax,es
	mov	ds,ax
	mov	ax,SEL_SCR0 or STD_TBL_RING
	mov	es,ax
	rep	movsd
	pop	ds
	assume	ds:DGROUP

GPT_ret:

cEnd

;************************************************************************/
;*** VCPIBootStrap
;
;    Purpose: Move the Pmode memory block into extended memory.
;
;    Register Usage:
;             EAX, BX, CX, SI, DI, Flags.
;
;    Input:   System is in Pmode.
;
;    Output:  If successful, the entire block of memory at DXLINEARBASE
;	      is copied to DX_TEMP_LINEARBASE.	Then the page directory
;	      and page tables are swapped around, and a new cr3 value is
;	      loaded, so that the new block is placed at DXLINEARBASE.
;	      The VCPI server reloads cr3.
;
;    Exceptions:
;	      No defined errors.  A bug in this routine will most likely
;	      crash the program.
;
;    Returns: Nothing.
;************************************************************************/

cProc VCPIBootStrap,<NEAR,PUBLIC>,<eax,ecx,si,di>
cBegin

	assume	ds:DGROUP,ss:DGROUP

	call	EnterProtectedMode

	cmp	fDebug,0
	jz      SkipVCPIDebugINIT

	mov     ax,SEL_DXCODE or STD_RING
	mov     es,ax
	assume  es:NOTHING
	mov     di,offset DXCODE:WdebVCPI
	mov     ax,DS_VCPI_Notify
	int     DebOut_Int

	push    ds
	pop     es
	assume  es:DGROUP
SkipVCPIDebugINIT:

	push	es
	push    ds
	assume  ds:NOTHING,es:NOTHING
	mov	ax,SEL_LDT_ALIAS
	mov     ds,ax
	mov	ax,SEL_TSS_ALIAS
	mov     es,ax

;
; Copy the block of memory at DXLINEARBASE, which is really in a DOS
; memory block in conventional memory, to DX_TEMP_LINEARBASE.
;
	xor     si,si
	mov     di,si
	mov	cx,LDTOFF shr 2
	rep     movsd
;
; Manipulate the page tables and page directory in the extended
; memory block, so that all our selectors point to the new area.
;
	mov     ax,es
	mov     ds,ax
	mov     si,DXTEMPPTOFF
	mov     di,DXPTSYSOFF
	mov     cx,CBPAGE386 shr 2
	rep     movsd
;
; Zero out the temporary page table that was used to copy our stuff
; up here.
;
	mov     di,DXTEMPPTOFF
	mov     cx,CBPAGE386 shr 2
	xor	eax,eax
	rep     stosd
;
; Fill in the new page directory.  First, the low memory page tables.
;
	mov     si,DXPTSYSOFF + (VCPIPTOFF shr 10)
	mov     di,DXPDOFF
	mov     cx,CPTDX + 1
	rep     movsd
;
; Second, the entry for our high memory system area.
;
	mov     si,DXPTSYSOFF + (DXPTSYSOFF shr 10)
	mov     di,DXPDOFF + (DXLINEARBASE shr 20)
	movsd

;
; Copy the two user page table page table entries to their final location.
;
	mov	cx,2
	mov	si,DXPTSYSOFF
	mov	di,DXPTSYSOFF + ( USERPT shl 2 )
	rep	movsd
;
; Zero out the original entries.
;
	mov	cx,2
	mov	di,DXPTSYSOFF
	xor	eax,eax
	rep	stosd
;
; Move our protected mode code segment up.
;
	mov	di,DXPMCODEOFF
	mov	ax,SEL_GDT
	mov	ds,ax
	mov	si,SEL_LDT_ALIAS
	mov	dx,DXPMCODE
	mov	ax,dx
	shl	ax,4
	shr	dx,12
	mov	ds:[si].adrBaseLow,ax
	mov	ds:[si].adrBaseHigh,dl
	mov	ds:[si].adrbBaseHi386,dh
	mov	cx,offset DXPMCODE:CodeEndPM + 10h
	shr	cx,2
	xor	si,si
	mov	ax,SEL_LDT_ALIAS
	mov	ds,ax
	rep	movsd
;
; Fetch page directory address for later cr3 loading.
;
	mov     eax, es:[DXPTSYSOFF + (DXPDOFF shr 10)]
	pop     ds
	assume  ds:DGROUP
	pop     es
	push	eax

	call	EnterRealMode

	pop	eax			; get new page directory address
					; Save the pte (physical addr) of
        and     ax, 0f000h              ;  page directory, mask 12 lsb's
	mov	V86ToPm.zaCr3VTP, eax	; store it
;
; VCPI server will load new CR3 value when we do the next real
; to protected mode switch.
;
	call	EnterProtectedMode

; Set up a descriptor for the LDT data alias.

	mov	edx,LADXLDTBASE
	movzx	ecx,cdscGDTMax
	shl	ecx,3
	dec	ecx
	mov	selGDT,SEL_GDT
	cCall	[NSetSegmentDscrCall],<SEL_LDT_ALIAS,edx,ecx,STD_DATA>
	xor	eax,eax
	cCall	[NSetSegmentDscrCall],<SEL_TSS_ALIAS,eax,eax,STD_DATA>
	mov	selGDT,SEL_LDT_ALIAS

	call	EnterRealMode

cEnd

;************************************************************************/
;*** AddXMStoVCPIHeap
;
; Purpose: Allocate extended memory for the DOS Extender heap by
;          allocating and locking blocks of XMS memory.  Fill in
;          user page tables to point to the allocated memory.
;
; Register
;     Usage: eax, edx
;
; Input:   ES:DI points to beginning of user page tables.
;
; Output:  ES:DI points to next unused page table entry.
;
; Returns:
;
; Exceptions:
;
; Notes: This function should not be called if memory has already been
;        allocated from another source.
;
;************************************************************************/
cProc AddXMStoVCPIHeap,<FAR,PUBLIC>,<bx,cx,si>
localD  cVCPIFreePages
cBegin
	cCall	GrowPageTables

	lea	si, hmem_XMS_Table	; SI points to saved handles buffer
	mov	ax,[hmem_XMS_Count]	; Point to the first free one.
	shl	ax,1
	add	si,ax

AXVH_begin:

	xor	eax,eax
	pmxmssvc  08h                   ; Query free extended memory
	and     ax,NOT 3                ; truncate to page size
	or      ax,ax                   ; any available?
	jz      AXVH_x                  ; no
	mov	ecx,cPteMax		; ECX = number of pages that will fit
	shl	ecx,2			; ECX = number of kilobytes
	cmp	eax,ecx			; compare available to space in page tables
	jb      AXVH_0                  ; will fit in page tables
	mov     ax,cx                   ; won't, ask for less
AXVH_0:
	mov     cx,ax                   ; save copy of size
	or      cx,cx
	jz      AXVH_x                  ; none left
	PMvcpi  vcpiCFREEPAGES          ; Store current VCPI free pages
	mov     cVCPIFreePages,edx
	mov     dx,cx                   ; dx = #kilobytes requested
	pmxmssvc  09h                   ; allocate extended memory block
	cmp     ax,1                    ; got a block?
	jne     AXVH_x                  ; no
	mov     [si],dx                 ; yes, got one, save handle
	PMvcpi  vcpiCFREEPAGES          ; Fetch VCPI free pages
	cmp     edx,cVCPIFreePages      ; Count still the same?
	jne     AXVH_0a                 ; No, allocate the memory from VCPI.
	mov     dx,[si]                 ; fetch handle
	pmxmssvc  0ch                   ; lock the block
	cmp     ax,1                    ; did it work?
	je      AXVH_1                  ; yes
AXVH_0a:
	mov     dx,[si]                 ; no, fetch handle, free it and exit
	pmxmssvc  0ah
	jmp     AXVH_x                  ; (can't use unlocked blocks)
AXVH_1: 				; handle to locked block is in
					;  [si], address in DX:BX
	movzx	eax,dx
	shl	eax,10h
	mov     ax,bx                   ; EAX = linear address of block
	shr     cx,2                    ; CX = number of 386 pages in block

	test	ax,MASK allbitsPTE	; Page aligned?
	jz      AXVH_2                  ; yes
	and	ax,NOT (MASK allbitsPTE)
	add	ax,CBPAGE386
	dec	cx
	jcxz    AXVH_x                  ; none left
AXVH_2:
	movzx	ecx,cx
	sub	cPteMax,ecx		; this many PTEs used up
	or      ax,NEWPTEMASK           ; make it a page table entry
	mov	edx,CBPAGE386
	cld
AXVH_AddPage:
	stos	dword ptr es:[edi]
	add	eax,edx
	loop	AXVH_AddPage

	inc	[hmem_XMS_Count]	; bump XMS handle count
	add     si,2                    ; point to next slot in handle array
	cmp	si,(OFFSET hmem_XMS_Table) + ( CXMSBLOCKSDX * 2 )
	jb      AXVH_begin              ; jump if more handles fit in array

AXVH_x:
cEnd


DXCODE	ends

endif	;VCPI
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxvcpi.asm ===
PAGE	,132
	TITLE	DXVCPI.ASM -- Dos Extender VCPI Support Code

; Copyright (c) Microsoft Corporation 1990-1991. All Rights Reserved.

;*** dxvcpi.asm - vcpi detection/maintenance/cleanup code (resident)
;
;   Copyright <C> 1990, Microsoft Corporation
;
;   Purpose:
;
;   Revision History:
;
;
;  08-07-90 earleh Allow program to boot without LIM 3.2 page frame.
;  05/07/90 jimmat Started incorporating VCPI changes from languages group.
;
;   []      20-Feb-1990 Dans    Created
;
;************************************************************************/

.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

.xlist
.sall
include         segdefs.inc
include         gendefs.inc
include 	pmdefs.inc
.list

; This entire file is only for VCPI support

if VCPI

.xlist
.sall
include         dxvcpi.inc
.list
;
; miscellaneous equates
;
;
; also in dxmmgr.asm
;
.ERRE CB_MEMHDR EQ 10h          ;size of memory block header
;
; also in dxmmgr.asm
;
;
; data
;

DXDATA  segment

;
; Externs
;

extrn   idCpuType:word
extrn   bpGDT:fword

extrn   cKbInitialHeapSize:word
extrn   cbHeapSize:dword
extrn   dsegCurrent:word
extrn   hmemHeap:word
extrn	lpfnXMSFunc:DWORD

extrn	selGDT:WORD
;
; Definitions, data
;

public	fEms
fEMS            db      0               ; ems present

public  fVCPI
fVCPI           db      0               ; vcpi present

public	iddxsystype
iddxsystype	db	DXINDOS		; type of memory used to hold
					; final dx Pmode data.
public	segBootPmode
segBootPmode	dw	0		; segment of block used to
					; build system tables in real
align	4

public  cFreePages
cFreePages      dd      0               ; free 4k pages, updated on each
					;  allocation.
public	bpdxsyspages
bpdxsyspages	dd	DXPMPAGES-1	dup(0)
;
; pointer (off of SEL_DXPT) where next free page table entry is
;
;       we initialize dxpt1 to have cptdx+2 entries in it (see
;       SetupPageTables in dxvcpibt.asm)
;

;
; Offset in zeroth page table of first page table entry that belongs
; to DX.  Set by initial call to GetVCPIInterface.
;
public	pPteFirst
pPteFirst	dd	0

;
; Offset in block pointed to by SEL_DXPT of where to put next page
; table entry when allocating extended memory by the page.
;
public	pPteNext
pPteNext	dd	0

;
; Maximum number of user page table entries that will fit in our
; original page table buffers.
;
public	cPteMax
cPteMax 	dd	0

EXTRN	hmem_XMS_Table:WORD
EXTRN	hmem_XMS_Count:WORD

public	hmem_System_Block
hmem_System_Block	dw	0

DXDATA  ends


DXPMCODE	segment

IFDEF	ROM
	%OUT VCPI Support not compatible with ROM!  Code segment variables!
	.ERR
ENDIF

;
; Data set up in real mode prior to relocation of DX into vcpi
;       (read only after init time anyway)
;

public  fnVCPIPM, fnVCPIPMoff

fnVCPIPM        label   fword           ; vcpi interface entrypoint
fnVCPIPMoff     dd      0               ; set up in GetVCPIInterface
                dw      SEL_VCPI        ; we know what this is.

externFP NSetSegmentDscr
	extrn   XMScontrol:FAR

pmxmssvc macro   fcn
	ifnb    <fcn>
	mov     ah, fcn
	endif
	call    XMScontrol
endm

DXPMCODE        ends

DXCODE  segment
;
; Data set up in real mode prior to relocation of DX into vcpi
;       (read only after init time anyway)
;

public	WdebVCPI, fnVCPI, fnVCPIoff

;---------	WdebVCPIInfo structure	-----------

public	laVTP, V86ToPm

;
; Begin WDEB386 VCPI notification structure.  The following variables
; are copied by WDEB386 when we send it a VCPI presence notification,
; just after entering protected mode.  The structure of this block of variables
; must not be changed without also changing the format of the data
; structure used by WDEB386.
;
;---------	WdebVCPIInfo structure	-----------
WdebVCPI	LABEL	BYTE

fnVCPI          label   fword           ; vcpi interface entrypoint
fnVCPIoff       dd      0               ; set up in GetVCPIInterface
		dw	SEL_VCPI	; we know what this is.

		dw	SEL_VCPIALLMEM	; for Wdeb386 information

laVTP		dd	0		; linear address of next structure
;
; End WDEB386 VCPI notification structure.
;

; Structure for switching from v86 mode to protect mode via VCPI

	EXTRN	epmVCPI:BYTE

V86ToPm VTP	<,,, SEL_LDT, SEL_TSS, OFFSET epmVCPI, 0, SEL_DXCODE0>

	externFP AddXMStoVCPIHeap

DXCODE  ends


DXCODE  segment

        assume  cs:DXCODE, ds:DXDATA, es:nothing


;*** FreeEMSHandle - free DX system memory
;
;   Purpose:	free the VCPI pages OR XMS block we allocated for system use
;
;   Register
;	Usage:	eax, edx, si, cx
;
;   Input:      none
;
;   Output:	VCPI DOS Extender system pages freed
;		XMS handle deallocated
;
;   Returns:	nothing
;
;   Exceptions: No operation if none of these entities have been
;		allocated yet
;
;   Notes:
;
;************************************************************************/
cProc FreeEMSHandle,<NEAR,PUBLIC,<>
cBegin
	lea	si,bpdxsyspages		; Load VCPI system pages array.
	mov	cx,DXPMPAGES-1		; (First page was in PSP block.)
	cld
.386
FreeVCPI_syspage:
	lodsd				; fetch next page
	or	eax,eax			; page present?
	jz	FreeVCPI_Done		; No, could have been XMS.
	and	ax,0f000h		; Yes, clear lower 12 bits.
	mov	edx,eax
	RMvcpi	vcpiFREEPAGE		; and free it.
	loop	FreeVCPI_syspage	; loop until all freed
.286p
FreeVCPI_Done:
	test	iddxsystype,DXINXMS	; loaded in XMS?
	jz	FreeEMSHandle_ret	; No.
	mov	dx,hmem_System_Block	; Yes, load block
	xmssvc	0dh			; unlock XMS block
	mov	dx,hmem_System_Block
	xmssvc	0ah			; free XMS block
FreeEMSHandle_ret:
cEnd

DXCODE  ends

;**************************************************************
;       386 only code from here on down!!!
;**************************************************************
.386p

include prot386.inc

DXCODE  segment

        assume  cs:DXCODE, ds:DXDATA, es:nothing

DXCODE  ends


DXPMCODE        segment
	assume	cs:DXPMCODE

;**************************************************************
;*** CallVCPIPM
;
; Utility routine to call VCPI server in protected mode.  Masks out
; interrupts during the call because QEMM enables the processor
; interrupt flag when you call it.
;
; Entry: AX = VCPI function code.
; Uses:  Depends upon call.
;
; Note: There is a copy of this routine in dxvcpi.asm and another
;	in dxvcpibt.asm.  This is to allow near calls.	The copy
;	in dxvcpibt.asm is discarded after initialization time.
;
;**************************************************************
cProc	CallVCPIPM,<NEAR>,<si>
cBegin

	push	ax			   ; save function code
;
; Shut out all interrupts.
; QEMM 5.0 enables interrupts during this call.  All our interrupt
; handlers are in the user code ring.  A workaround is to shut off
; hardware interrupts during the call.
;

        in      al,INTA01
	IO_Delay
	mov	si, ax
	mov	al,0FFh
	out	INTA01,al
	IO_Delay

	pop	ax			    ;restore function code
	db	9Ah			    ;call  far SEL_CALLVCPI:0
	dw	0,SEL_CALLVCPI or STD_RING

; Restore the state of the interrupt mask register

	xchg	si, ax
        out     INTA01,al
	IO_Delay
	xchg	si, ax
cEnd

;************************************************************************/
;*** AllocVCPIMem
;
;   Purpose:    to allocate a block of memory from VCPI
;
;   Register
;       Usage:  eax, ebx, edx, ecx, es
;
;   Input:	ECX has number of 4k pages to allocate
;		ES:EDI points to page table entries to fill.
;
;   Output:     pPteNext updated with next free pte
;               cFreePages updated with number of free 4k pages from vcpi
;
;   Returns:    if success, linear ptr in eax
;               if fail, eax 0, ebx has number of 4k pages available.
;
;   Exceptions:
;
;   Notes:      maximum allocation is 65535 4k pages (more than enough)
;               at one time.
;               Also, this is PROTECT MODE ONLY.
;
;************************************************************************/
cProc AllocVCPIMem,<NEAR,PUBLIC>,<bx,dx>
cBegin
	;
        ; Compute the number of entries free in our page table 
        ;
	mov	edx, cPteMax
	cmp     ecx, edx                ; compare request with PTEs
        jb      @F
        ;
        ; our page tables have less room than the vcpi server can allocate,
        ; so adjust our count downward to reflect that
        ;
	mov	ecx, edx
@@:
	cmp     ecx, cFreePages         ; compare request with pages we are
					; allowed to allocate
	jb      @F                      ; request < max.?
	mov     ecx, cFreePages         ; No, clip.
@@:
	jecxz	AVM_exit		; ECX = pages to allocate

AVM_getpage:

	PMvcpi	vcpiALLOCPAGE

	or	ah, ah
	jnz     AVM_exit                ; something happened...not as much
                                        ; as vcpi said was there.
	dec     cPteMax                 ; fix up free PTEs
	dec     cFreePages              ; and free VCPI pages
;
; make it a page table entry, and store into page table
; don't need to worry about the tlb here, since not-present
; pages are not cached in the tlb.
;
	or      dx, NEWPTEMASK
	mov     eax, edx
	stos	dword ptr es:[edi]

	dec	ecx
	jnz	AVM_getpage		; next allocate

AVM_exit:
cEnd

;************************************************************************/
;*** VCPISpace
;
;   Purpose:    Return maximum possible VCPI memory allocation.
;
;   Uses:
;
;   Input:
;
;   Output:
;
;   Return:     EAX = maximum possible VCPI pages we can get.
;
;   Exceptions:
;
;   Notes:
;
;************************************************************************/
cProc VCPISpace,<NEAR,PUBLIC>,<edx>
cBegin

	PMvcpi  vcpiCFREEPAGES          ; EDX = free VCPI pages
	cmp     edx,cFreePages          ; clip to maximum EMS allocation
	jb      VS_00
	mov     edx,cFreePages
VS_00:
	mov	eax,cPteMax	       ; clip to space in page tables
	cmp     edx,eax
	jb      VS_01
	mov     edx,eax
VS_01:
	mov     eax,edx
cEnd

;************************************************************************/
;*** FreeVCPIHeap
;
;   Purpose:    To free the Extended Memory heap memory.
;
;   Register
;       Usage:  eax, ebx, ecx, edx
;
;   Input:
;
;   Output:     All VCPI pages allocated for the heap are freed.
;               All XMS blocks allocated for the heap are freed.
;               Page table entries are set to zero.
;
;
;   Returns:    nothing
;
;   Exceptions: none
;
;   Notes:      Protect mode only
;
;************************************************************************/
cProc	FreeVCPIHeap,<NEAR,PUBLIC>,<es,edi,si,eax,edx>
cBegin

	mov     ax, SEL_DXPT            ; set up es with the selector
	mov     es, ax                  ;  for our page tables
	mov	edi, pPteFirst		; point to first page allocated
	mov	ecx, pPteNext		; point to first unallocated PTE
	sub	ecx, edi
	jbe     Free_XMS_Handles
	shr	ecx, 2			; ECX = pages to free

startloop:
	mov	edx, es:[edi]		; get pte into edx
	and	dx, 0f000h		; mask off 12 lsb's

	PMvcpi	vcpiFREEPAGE		; free the page

	xor	eax, eax
	stos	dword ptr es:[edi]	; clear out PTE
	dec	ecx
	jnz	startloop
@@:
Free_XMS_Handles:
	lea     si, hmem_XMS_Table      ; si points to XMS handle array
	mov	cx,[hmem_XMS_Count]
	jcxz	No_XMS_Handles

Free_XMS_Handles_Loop:
	mov	dx,[si]
	pmxmssvc  0dh                   ; unlock any XMS blocks
	mov     dx,[si]
	pmxmssvc  0ah                   ; free any XMS blocks
	add	si,2			; point to next slot in handle array
	loop    Free_XMS_Handles_Loop   ; loop if more handle slots

No_XMS_Handles:

cEnd

AddXMStoVCPIHeapCall label dword
	dw offset dxcode:AddXMStoVCPIHeap,SEL_DXCODE or STD_RING

;*** AddVCPIHeap
;
;   Purpose:    to replace the himem specific code in AddToXmemHeap
;
;   Register
;       Usage:  all preserved except return values in bx:dx
;
;   Input:      dx:cx is the minimum block length required (bytes).
;
;   Output:     cbHeapSize is updated if a heap is allocated
;
;   Returns:    bx:dx is 32bit linear address of allocated block if success,
;               cy clear, else cy set
;
;   Exceptions:
;
;   Notes:
;
;************************************************************************/
cProc   AddVCPIHeap,<NEAR,PUBLIC>,<eax,ecx>
localD  cbNeeded
cBegin

	push    ebx                     ; save extended registers
	push    edx

	add     cx, CB_MEMHDR * 3       ; add memory manager overhead
	adc     dx, 0
	movzx   ecx,cx
	shl     edx,16d
	or      ecx,edx                 ; ECX = minimum bytes wanted
	mov     cbNeeded,ecx
	add     ecx,CBPAGE386-1
	shr     ecx,12d                 ; ECX = minimum pages wanted
	mov	eax, cPteMax
	cmp     ecx,eax                 ; make sure we have enough
	jna     AVH_00                  ; page table entries
	mov     ecx,eax                 ; ECX = minimum pages wanted
AVH_00:

	mov     cbHeapSize,0

	mov     ax, SEL_DXPT            ; ES -> user page tables
	mov     es, ax
	mov	edi, pPteNext		; Point to first unused PTE
	or	edi, edi		; Initialized?
	jnz     AVH_10                  ; Yes, skip XMS allocate.
	mov	edi, pPteFirst		; No, initialize first unused PTE.
	mov	pPteNext, edi

	cCall	AddXMStoVCPIHeapCall

	mov	pPteFirst,edi		; VCPI allocations start here

AVH_10:
	mov	ebx, pPteNext		; EBX = first PTE
	shl     ebx, 10d                ; EBX = linear address of start of block
	mov     dx, bx
	shr     ebx, 16d                ; DX:BX = linear address of block

	mov	eax, edi
	sub	eax, pPteNext
	shr	eax, 2			; AX = count of pages allocated
	sub	ecx, eax		; Get what we asked for?
	jbe     AVH_Done                ; Yes.

	cCall   AllocVCPIMem            ; allocate it from VCPI
					; cx has number of 4k pages
AVH_Done:
	mov	eax, edi
	sub	eax, pPteNext
	mov	pPteNext, edi
	or	eax, eax
	jz      AVH_BadExit
	shl     eax, 10d                ; EAX = count of bytes allocated
	sub     eax, CB_MEMHDR * 3      ; deduct overhead
	mov     cbHeapSize, eax
	clc
	jmp     AVH_Exit
AVH_BadExit:
	stc
AVH_Exit:
;
; Result is in BX:DX, but we have to save restore the MSW of EBX and
; that of EDX before we return to our caller.
;
	mov     ax,dx
	pop     edx
	mov     dx,ax
	mov     ax,bx
	pop     ebx
	mov     bx,ax
cEnd

DXPMCODE        ends

endif	;VCPI

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\hostdata.inc ===
;*++
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    Hostdata.inc
;
;Abstract:
;
;    This module contains definitions associated with the host private data
;    for the NT vdm dpmi host
;
;Author:
;
;    Dave Hastings (daveh) 18-Mar-1992
;
;
;Revision History:
;*++

;
; Note: the following structure should match the pmUser portion of the
;       INTRSTACK structure.
;
AppState struc
IFDEF DPMI32
AsES    dd      ?
AsDS    dd      ?
AsDI    dd      ?
AsSI    dd      ?
AsBP    dd      ?
AsSPx   dd      ?
AsBX    dd      ?
AsDX    dd      ?
AsCX    dd      ?
AsAX    dd      ?
AsFL    dd      ?
AsSS    dd      ?
AsSP    dd	?
ELSE
AsES    dw      ?
AsDS    dw      ?
AsDI    dw      ?
AsSI    dw      ?
AsBP    dw      ?
AsSPx   dw      ?
AsBX    dw      ?
AsDX    dw      ?
AsCX    dw      ?
AsAX    dw      ?
AsFL    dw      ?
AsSS    dw      ?
AsSP    dw	?
ENDIF
AppState ends

IFDEF DPMI32
APPSTATE_SIZE equ 52
ELSE
APPSTATE_SIZE equ 26
ENDIF

HostData struc
Hdflags         dw      0
HdSelParent     dw      0
HdSegParent     dw      0
HdSelPSP        dw      0
HdPSPParent     dw      0
HdPspTerminate  dd      0
HdState         db      APPSTATE_SIZE dup (0)
HostData ends

IFDEF DPMI32
HOST_DATA_SIZE equ 58
ELSE
HOST_DATA_SIZE equ 36
ENDIF

HD_32BITAPP     equ     1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\interupt.inc ===
; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	INTERUPT.INC - Definitions for 286 DOS Exterder Interrupt Handlers
;
;-----------------------------------------------------------------------
;
;  04/18/89 jimmat  Original version.
;
;***********************************************************************

; This structure defines the stack frame used to hold the register
; values Interrupt Reflector functions.

INTRSTACK   struc

intUserES   dw      ?
intUserDS   dw      ?
intUserDI   dw      ?
intUserSI   dw      ?
intUserBP   dw      ?
intUserSPx  dw      ?
intUserBX   dw      ?
intUserDX   dw      ?
intUserCX   dw      ?
intUserAX   dw      ?

intUserFL   dw      ?

pmUserES    dw      ?
pmUserDS    dw      ?
pmUserDI    dw      ?
pmUserSI    dw      ?
pmUserBP    dw      ?
pmUserSPx   dw      ?
pmUserBX    dw      ?
pmUserDX    dw      ?
pmUserCX    dw      ?
pmUserAX    dw      ?

pmUserFL    dw      ?

pmUserSS    dw      ?
pmUserSP    dw	    ?

wParam1     dw	    ?
wParam2     dw	    ?
lParam	    dd	    ?

INTRSTACK   ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\intmac.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intmac.inc
;
; Abstract:
;
;    This module contains macros to allow code running in 16 bit protected
;    mode to manipulate the virtual interrupt flag
;
; Author:
;
;   Dave Hastings (daveh) 24-Apr-1992
;
; Revision History:
;
;--


VDM_INT_TRAP_GATE EQU 00000000h
VDM_INT_INT_GATE  EQU 00000001h
VDM_INT_32        EQU 00000002h
VDM_INT_16        EQU 00000000h
EFLAGS_VIF equ 080000H

ifdef WOW_x86
include vint.inc
riret macro
    local   a,b,c,d
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[bp+6]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     bp
    iret
    endm

riretd macro
    local   a,b,c,d
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[bp+10]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     bp
    iretd
    endm

riretd32 macro
    local   a,b,c,d
    push    ebp
    mov     ebp,esp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[ebp+0ch]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     ebp
    iretd
    endm

rpopf macro
    local a,b,c,d
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[bp+2]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     bp
    popf
    endm

rpopfd macro
    local a,b,c,d
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,[bp+2]
    test    ax,200h
    jz      a
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      c
    sti
c:  lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    jmp     short b
a:
    test    ds:FIXED_NTVDMSTATE_REL40,RI_BIT_MASK
    jz      d
    cli
d:  lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
b:
    pop     ds
    pop     ax
    pop     bp
    popfd
    endm

;
; The following assume that the RI bit implies a virtual interrupt flag
; in eflags.   See appendix h of the Pentium user's manual
;
rpushf macro
    local a,b,c,d
    .386p
    pushf
    push    ebp
    mov     ebp,esp
    push    eax
    push    ds

    mov     ax,ss
    movzx   eax,ax
    lar     eax,eax
    test    eax,(AB_BIG SHL 8)
    jnz     @f
    movzx   ebp,bp
@@:

    mov     ax,40h
    mov     ds,ax
    mov     ax,word ptr ds:FIXED_NTVDMSTATE_REL40
    test    ax,RI_BIT_MASK
    jz      c
    pushfd
    test    dword ptr [ebp-10],EFLAGS_VIF
    jz      d
    or      word ptr [ebp+4],200h
    popfd
    jmp     b
d:
    and     word ptr [ebp+4],NOT 200h
    popfd
    jmp     b
c:
    test    ax,VIRTUAL_INTERRUPT_BIT
    jz      a
    or      word ptr [ebp+4],200h
    jmp     b
a:
    and     word ptr [ebp+4],NOT 200h
b:
    pop     ds
    pop     eax
    pop     ebp
    .286p
    endm

rpushfd macro
    local a,b,c,d
    pushfd
    push    bp
    mov     bp,sp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,word ptr ds:FIXED_NTVDMSTATE_REL40
    test    ax,RI_BIT_MASK
    jz      c
    test    dword ptr [bp+2],EFLAGS_VIF
    jz      d
    or      word ptr [bp+2],200h
    jmp     b
d:
    and     word ptr [bp+2],NOT 200h
    jmp     b
c:
    test    ax,VIRTUAL_INTERRUPT_BIT
    jz      a
    or      word ptr [bp+2],200h
    jmp     b
a:
    and     word ptr [bp+2],NOT 200h
b:
    pop     ds
    pop     ax
    pop     bp
    endm


rpushfd32 macro
    local a,b,c,d
    pushfd
    push    ebp
    mov     ebp,esp
    push    ax
    push    ds
    mov     ax,40h
    mov     ds,ax
    mov     ax,word ptr ds:FIXED_NTVDMSTATE_REL40
    test    ax,RI_BIT_MASK
    jz      c
    test    dword ptr [ebp+4],EFLAGS_VIF
    jz      d
    or      word ptr [ebp+4],200h
    jmp     b
d:
    and     word ptr [ebp+4],NOT 200h
    jmp     b
c:
    test    ax,VIRTUAL_INTERRUPT_BIT
    jz      a
    or      word ptr [ebp+4],200h
    jmp     b
a:
    and     word ptr [ebp+4],NOT 200h
b:
    pop     ds
    pop     ax
    pop     ebp
    endm
ELSE
riret macro
    iret
    endm

riretd macro
    iretd
    endm

riretd32 macro
    iretd
    endm

rpopf macro
    popf
    endm

rpopfd macro
    popfd
    endm

rpushf macro
    pushf
    endm

rpushfd macro
    pushfd
    endm

rpushfd32 macro
    pushfd
    endm

FCLI macro
    cli
    endm

FSTI macro
    sti
    endm

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\netbios.inc ===
; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	NETBIOS.INC	-   NetBIOS Definitions for 286 DOS Extender
;
;-----------------------------------------------------------------------
;
;  04/18/89 jimmat  Original version.
;
;***********************************************************************

; NetBIOS return codes

RC_Good 	EQU	000h
RC_Invalid_Cmd	EQU	003h
RC_Max_Cmd	EQU	022h
RC_In_Progress	EQU	024h
RC_Pending	EQU	0FFh

RC_Resources	EQU	035h	; OS/2 (!) Required OS Resources Exhausted


; Some NetBIOS command codes

SessCall	EQU	10h		; Call command
SessListen	EQU	11h		; Listen command
HangUp		EQU	12h		; Hang up command
Send		EQU	14h		; Send command
Recv		EQU	15h		; Recv command
RecvAny 	EQU	16h		; Recv any command
ChainSend	EQU	17h		; Chain send command
SendGram	EQU	20h		; Send datagram
RecvGram	EQU	21h		; Recv datagram
SendBroad	EQU	22h		; Send broadcast datagram
RecvBroad	EQU	23h		; Recv broadcast datagram
AddName 	EQU	30h		; Add name command
DelName 	EQU	31h		; Delete name command
Reset		EQU	32h		; Reset command
AdptStat	EQU	33h		; Adapter status command
SessStat	EQU	34h		; Session status command
Cancel		EQU	35h		; Cancel command
AddGName	EQU	36h		; Add group name command
Unlink		EQU	70h		; Unlink command
Install 	EQU	7Fh		; Install check  (?)

NoWait		EQU	80h		; APPLIES TO MOST COMMANDS (High bit)


; some UB netbios command codes

UBNB_Register   EQU     72h
UBNB_SendNmc    EQU     73h
UBNB_Callniu    EQU     74h
UBNB_Calladdr   EQU     75h
UBNB_Listenaddr EQU     76h
UBNB_SendPkt    EQU     77h
UBNB_RcvPkt     EQU     78h
UBNB_SendAttn   EQU     79h
UBNB_RcvAttn    EQU     7Ah
UBNB_Listenniu  EQU     7Bh
UBNB_RcvRaw     EQU     7Ch
UBNB_SendNmc2   EQU     7Dh


;******************************************************************************
;			     S T R U C T U R E S
;******************************************************************************
;
;   Network Control Block structure
;
NCB_Struc	STRUC
NCB_Command	db	?		; Command
NCB_RetCode	db	?		; Return code
NCB_LSN 	db	?		; Local session #
NCB_Num 	db	?		; Name #
NCB_Buffer_Off	dw	?		; Buffer offset
NCB_Buffer_Seg	dw	?		; Buffer segment
NCB_Length	dw	?		; Buffer length
NCB_CallName	db 16 dup (?)		; Name on local or remote adapter
NCB_Name	db 16 dup (?)		; Name on local adapter
NCB_RTO 	db	?		; Receive timeout
NCB_STO 	db	?		; Send timeout
NCB_Post_Off	dw	?		; Post routine offset
NCB_Post_Seg	dw	?		; Post routine segment
NCB_LanA_Num	db	?		; Adapter #
NCB_Cmd_Cplt	db	?		; Command status field
NCB_Reserved	db 14 dup (?)		; Reserved
NCB_Struc	ENDS


HCB_Flags	EQU	WORD PTR [-02h]
HCB_Next	EQU	WORD PTR [-04h]
HCB_PM_NCB_Seg	EQU	WORD PTR [-06h]
HCB_PM_NCB_Off	EQU	WORD PTR [-08h]
HCB_Handle	EQU	WORD PTR [-0Ah]

HCB_Header_Size EQU	0Ah
HCB_Size	EQU	SIZE NCB_Struc + HCB_Header_Size

; HCB_Flags defines

HCB_DELAY	EQU	001h
HCB_ISSUED	EQU	002h
HCB_POSTED	EQU	004h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\gendefs.inc ===
; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*  GENDEFS.INC  -- General Symbol Defintions for Dos Extender  *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  05/08/90 jimmat Changes for VCPI support.                   *
;*  01/07/90 jimmat Make DOSX version 03.00.                    *
;*   7/28/89 jimmat Increased GDT/LDT size yet again.           *
;*   4/01/89 jimmat Increased size of GDT/LDT (again)           *
;*   3/30/89 jimmat Added ChkPoint macro for debugging          *
;*   3/11/89 jimmat Added support for LDT & TSS                 *
;*   3/09/89 jimmat Added DX_DYNALINK function                  *
;*  02/22/89 (GeneA): increased size of interrupt reflector     *
;*      stack frames (CB_STKFRAME) from 128 to 256 bytes        *
;*  02/17/89 (GeneA): removed ERC_??? equates                   *
;*  02/10/89 (GeneA): changed form of definitions for the       *
;*      EXEC_??? symbols, and added ERC_??? error code symbols. *
;*  12/13/88 (GeneA): moved definitions for EXEC_??? symbols    *
;*      and RELOC_BUFFER here from dxinit.asm
;*  12/08/88 (GeneA): added npopf function                      *
;*  12/08/88 (GeneA): added HMMFUNC definition                  *
;*                                                              *
;****************************************************************

ifndef DEBUG                    ;define DEBUG switch if it isn't already
DEBUG   =       0
endif
ifndef MINBUG
MINBUG  =       0
endif
ifndef VCPI
VCPI    =       0
endif
ifndef NO386
NO386   =       0
endif

; -------------------------------------------------------
;               MISC. PROGRAM CONSTANTS
; -------------------------------------------------------

DXVERSION       =   030Ah   ;Version 03.10
DPMI_32BIT      equ     0000000000000001b

if VCPI
CDSCGDTDEFAULT  =   3072          ;default size of GDT **** temp for VCPI **** !!!
CDSCLDTDEFAULT  =   2
else
CDSCGDTDEFAULT  =   3072    ;default size of GDT
endif

CDSCMAXLDT      =   8190    ;maximum possible LDT selectors

CDSCIDTDEFAULT  =   256     ;default size of IDT

CB_XFRBUF0  =       128     ;size of small transfer buffer
;
; Performance enhancement, by RalphL
;
CB_XFRBUF1  =       8192        ;size of large transfer buffer

CB_STKFRAME     =   384     ;size of a stack frame

CB_MEMHDR       =       16      ; size of memory block header (1 paragraph)

CXMSBLOCKSDX    =       16      ; number of XMS blocks to allocate

INTA00      =   20h         ;i/o address of master 8259
INTA01      =   21h
INTB00      =   0A0h        ;i/o address of slave 8259
INTB01      =   0A1h

CMOSLoc     =   70h         ;CMOS ram/Real-Time Clock location port
CMOSValue   =   71h         ;CMOS ram/Real-Time Clock value port

HP_VECTRA   =   01h         ;Running on an HP Vectra
HP_CLASSIC  =   02h         ;Running on a 'Classic' Vectra (A & A+)

CRESERVED   =   32          ;Reserved interrupt numbers

; The following equates define the DOS Extender DynaLink services

if DEBUG

OutDebugStr     =       0       ;debugging text out service
TestDebugIns    =       1       ;debugger installation check service

NUM_DYNALINK    =       2

else ;  !DEBUG

NUM_DYNALINK    =       0

endif



; This structure defines the format of the Exec paramter block used
; by the MS-DOS exec function (ah=4Bh, al=01).

XBLK    struc

segEnv          dw      ?       ;segment address of environment to use
lpchCmnd        dd      ?       ;far pointer to command line
lpFCB0          dd      ?       ;far pointer to first default fcb
lpFCB1          dd      ?       ;far pointer to second default fcb
lpChildStack    dd      ?       ;return value, far pointer to child stack
lpChildCode     dd      ?       ;return value, far pointer to child code

XBLK    ends


; The following symbols define locations in rgbXfrBuf1 used
; during initialization.  ParseCommandLine places this information
; into the buffer to be used by later programs.

BUFTMP  = CB_XFRBUF1 - 1024         ;use the top 1k for the temporary buffers

EXEC_PROGNAME   equ <DGROUP:rgbXfrBuf1+BUFTMP+0000h> ;child program's exe file name
EXEC_DXNAME     equ <DGROUP:rgbXfrBuf1+BUFTMP+0080h> ;Dos Extender program name
EXEC_CMNDLINE   equ <DGROUP:rgbXfrBuf1+BUFTMP+0100h> ;command line to pass to the child
EXEC_EXEHDR     equ <DGROUP:rgbXfrBuf1+BUFTMP+0180h> ;buffer for holding exe header for
                                                     ; the overlay currently being
                                                     ; loaded
EXEC_FCB0       equ <DGROUP:rgbXfrBuf1+BUFTMP+01A0h> ;FCB0 to pass to the child
EXEC_FCB1       equ <DGROUP:rgbXfrBuf1+BUFTMP+01D0h> ;FCB1 to pass to the child
RELOC_BUFFER    equ <DGROUP:rgbXfrBuf1+BUFTMP+0200h> ;file input buffer used to hold
                                                     ; pages of the relocation table
                                                     ; while relocating the current
                                                     ; overlay
;
; This structure defines the stack frame used to hold the entry
; values and automatic variables for Dos Extender functions.

FUNCSTACK   struc

fnsUserES   dw      ?
fnsUserDS   dw      ?
fnsUserDI   dw      ?
fnsUserSI   dw      ?
fnsUserBP   dw      ?
fnsUserSPx  dw      ?
fnsUserBX   dw      ?
fnsUserDX   dw      ?
fnsUserCX   dw      ?
fnsUserAX   dw      ?

fnsUserIP   dw      ?
fnsUserCS   dw      ?
fnsUserFL   dw      ?

fnsUserSS   dw      ?
fnsUserSP   dw      ?

FUNCSTACK   ends

; -------------------------------------------------------
;               DEFINITIONS FOR MACROS
; -------------------------------------------------------

; These macros are used to switch between the protected mode
; only code segment and the mixed protected/real mode code segment.
; They are intended to be used for switching between modes in-line
; within a routine.  They must be used in pairs, bracketing the
; code that needs to be in the other mode (from the initial or 'native'
; mode of the function.)

; -------------------------------------------------------
;
; This macro switches the processor and the local segment context
; to the dos extender protected mode segment.

SwitchToProtectedMode   macro
        local   foo

        ifndef  EnterProtectedMode
        extrn   EnterProtectedMode:NEAR
        endif

        call    EnterProtectedMode
        % ifidni  <@CURSEG>,<DXCODE>
;       jmp     far ptr foo
        db      0EAh                            ;avoid need for fixups
        dw      offset DXPMCODE:foo
        dw      SEL_DXPMCODE OR STD_RING
DXCODE  ends

DXPMCODE    segment
        assume  cs:DXPMCODE
        endif
foo:
        endm

; -------------------------------------------------------
;
; This macro switches the processor and the local segment context
; to the dos extender mixed protected/real mode segment.

SwitchToRealMode    macro
        local   foo

        % ifidni  <@CURSEG>,<DXPMCODE>
;       jmp     far ptr foo
        db      0EAh                            ;avoid need for fixups
        dw      offset DXCODE:foo
        dw      SEL_DXCODE OR STD_RING
DXPMCODE    ends


DXCODE  segment
        assume  cs:DXCODE
        endif

        ifndef  EnterRealMode
        extrn   EnterRealMode:NEAR
        endif

foo:
        call    EnterRealMode

        endm


; -------------------------------------------------------
;

BeginLowSegment macro

DXCODE  segment
        assume  cs:DXCODE

        endm

EndLowSegment   macro

DXCODE  ends

        endm


BeginHighSegment    macro

DXPMCODE    segment
        assume  cs:DXPMCODE

        endm

EndHighSegment  macro

DXPMCODE    ends

        endm

; -------------------------------------------------------
;
; This macro switches the local segment context
; to the dos extender protected mode segment.

ChangeToHighSegment     macro
        local   foo

        % ifidni  <@CURSEG>,<DXCODE>
        .err
        %out Switch to high segment when already in high segment
        endif
        jmp     far ptr foo
DXCODE  ends

DXPMCODE    segment
        assume  cs:DXPMCODE
foo:
        endm

; -------------------------------------------------------
;
; This macro switches the local segment context
; to the dos extender mixed protected/real mode segment.

ChangeToLowSegment  macro
        local   foo
        % ifidni  <@CURSEG>,<DXCODE>
        .err
        %out Switch to low segment when already in low segment
        endif

        jmp     far ptr foo
DXPMCODE    ends

DXCODE  segment
        assume  cs:DXCODE
foo:
        endm


; -------------------------------------------------------
;

PushCParams MACRO P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
        IRP Param, <P10, P9, P8, P7, P6, P5, P4, P3, P2, P1>
        IFNB <Param>
        push    Param
        ENDIF
        ENDM
        ENDM

ClearCParams MACRO Count, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
IFNB <P1>
        ClearCParams %(Count+1), <P2>, <P3>, <P4>, <P5>, <P6>, <P7>, <P8>, <P9>, <P10>
ELSE
IF Count
        add     sp, Count*2
ENDIF
ENDIF
        ENDM


; -------------------------------------------------------
; This macro calls one of the DX services

DXcall  MACRO Procedure, Param_List
IFNDEF  WOW_x86                             ; BUGBUG
        PushCParams Param_List
        db      9Ah                     ;call sel:0
        dw      0
        dw      SEL_DYNALINK + (Procedure SHL 3)
        ClearCParams 0, Param_List
ENDIF
        ENDM

; -------------------------------------------------------
; This macro displays a string if DEBUG
;
; Note: This macro only works in PROTECT MODE! **********

Trace_Out MACRO String, nocrlf
        LOCAL   String_Offset
ifndef WOW_x86      ;bugbug
IF DEBUG

DXDATA SEGMENT
String_Offset LABEL BYTE
        db      String
IFB <nocrlf>
        db      0Ah, 0Dh
ENDIF
        db      0
DXDATA ENDS

        push    ds
        pushf
        cli
        pusha                           ; save our registers
        pusha                           ; copy them for print routine

        mov     ax,SEL_DXDATA           ; make sure string is addressable
        mov     ds,ax

        mov     si,OFFSET DGROUP:String_Offset
        DXcall  OutDebugStr

        popa                            ; restore our registers

        npopf
        pop     ds
ENDIF
endif   ;WOW_x86
        ENDM

; -------------------------------------------------------
; This macro displays a string and breaks if DEBUG
;
; Note: This macro only works in PROTECT MODE! **********

Debug_Out MACRO String
        LOCAL   Skip_Int1
IF DEBUG
        pushf
        Trace_Out   <String>
        DXcall  TestDebugIns
        jz      SHORT Skip_Int1
        int     1
Skip_Int1:
        npopf
ENDIF
        ENDM

; -------------------------------------------------------
; This macro displays a string if DEBUG
;
; Note: This macro only works in REAL MODE! **********
;
; DS must be set to the DOS Extender's DS before using, too.
;

Real_Trace_Out MACRO String, nocrlf
        LOCAL   String_Offset
IF DEBUG

ifndef DXOutDebugStr
        EXTRN DXOutDebugStr:FAR
endif

DXDATA SEGMENT
String_Offset LABEL BYTE
        db      String
IFB <nocrlf>
        db      0Ah, 0Dh
ENDIF
        db      0
DXDATA ENDS

        pushf
        cli
        pusha                           ; save our registers
        pusha                           ; copy them for print routine

        mov     si,OFFSET DGROUP:String_Offset
        call    DXOutDebugStr

        popa                            ; restore our registers

        npopf
ENDIF
        ENDM

; -------------------------------------------------------
; This macro displays a string and breaks if DEBUG
;
; Note: This macro only works in REAL MODE! **********
;
; DS must be set to the DOS Extender's DS before using, too.
;

Real_Debug_Out MACRO String
        LOCAL   Skip_Int1
IF DEBUG
        pushf
        Real_Trace_Out  <String>
        cmp     fDebug,0
        jz      SHORT Skip_Int1
        int     1
Skip_Int1:
        npopf
ENDIF
        ENDM

; -------------------------------------------------------
; Delay for I/O Instructions...

IO_Delay MACRO
        jmp     short $+2
        jmp     short $+2
        jmp     short $+2
        ENDM

; -------------------------------------------------------
;8080-style return macros due to Greg Whitten

genrcc  macro   cc
r&cc    &macro  labl
if      $-___ret gt 126d
        jn&cc   $+3     ;;Skip around ret
___ret  = $
        ret
else
        j&cc    ___ret  ;;jmp to last ret
endif
        &endm

rn&cc   &macro  labl
if      $-___ret gt 126d
        j&cc    $+3     ;;Skip around ret
___ret  = $
        ret
else
        jn&cc   ___ret  ;;jmp to last ret
endif
        &endm

call&cc &macro  labl
        jn&cc   $+5     ;;Skip around call
        call    labl
        &endm

calln&cc        &macro  labl
        j&cc    $+5     ;;Skip around call
        call    labl
        &endm

jmp&cc  &macro  labl
        jn&cc   $+5     ;;Skip around jmp
        jmp     labl
        &endm

jmpn&cc &macro  labl
        j&cc    $+5     ;;Skip around jmp
        jmp     labl
        &endm

        endm

; -------------------------------------------------------
;       rcc and rncc macro generators

genrcc  a
genrcc  ae
genrcc  b
genrcc  be
genrcc  c
genrcc  e
genrcc  g
genrcc  ge
genrcc  l
genrcc  le
genrcc  o
genrcc  s
genrcc  z

return  macro
___ret  = $
        ret
        endm

; -------------------------------------------------------
;
; This macro is used to get around the bug in the POPF instruction in
; some early 80286 chips.
IFDEF WOW
npopf   macro
        rpopf
        endm
ELSE
npopf   macro
        local   a
        jmp     $+3             ; Fix for bug in POPF on IBM AT
a:      iret                   ; This simulates a POPF instruction
        push    cs
        call    a
endm
ENDIF
; -------------------------------------------------------
;
; MS-DOS function call macros

dossvc  macro   fcn
        ifnb    <fcn>
        mov     ah,fcn
        endif
        int     21h
        endm

pmdossvc macro  fcn
        ifnb    <fcn>
        mov     ah,fcn
        endif
        pushf                   ;don't do Int 21h in case child has Int 21h
        cli                     ;  hooked (like Windows)
        push    cs
        call    PmIntrDos
        endm

; -------------------------------------------------------
; This macro will request a Dos Extender funtion.

dxsvc   macro   fcn
        ifnb    <fcn>
        mov     al,fcn
        endif
        mov     ah,DXFUNC
        int     2Fh
        endm

; -------------------------------------------------------
; This macro is used to make calls to the XMS driver for
; extended memory management.

HMMFUNC =       43h             ;Himem driver Int 2Fh function code

xmssvc  macro   fcn
        ifnb    <fcn>
        mov     ah,fcn
        endif
        call    [lpfnXMSFunc]
        endm

; -------------------------------------------------------

out1    macro   p
        if1
        %out p
        endif
        endm

; -------------------------------------------------------

errnz   macro   p
        if2
        .errnz  p
        endif
        endm

; -------------------------------------------------------
; -------------------------------------------------------
; -------------------------------------------------------

;****************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\dxvcpi.inc ===
;*** dxvcpi.inc - include file for vcpi functions/maintenance
;
;   Copyright <C> 1990-1991, Microsoft Corporation
;
;   Purpose:
;
;   Revision History:
;
;  08-07-90 earleh rearranged things to allow building Pmode data
;	    structures with total size exceeding that of LIM 3.2 page
;	    frame
;  05/09/90 jimmat Started incorporating VCPI changes from languages group.
;
;   []      20-Feb-1990 Dans    Created
;
;************************************************************************/

CurrentCpu	=	@Cpu		;select 386 assembly if not already
ife (CurrentCpu AND 0008h)
	.386
endif

;
; Hungarian used:
;       la      Linear Address
;       za      Physical Address
;

;
;
; Miscellaneous equates
;
EMS_INT         =       067h
VCPIINT         =       067h
CBEMMSTR        =       8h
CPTDX		=	1h		; count of user page tables dx uses
CPTDXEXT	=	(CPTDX+1)	; count of total page tables dx uses
CBPAGE386	=	1000h		; bytes in 386 page
CBPAGE386LIM	=	1000h-1

DXINDOS 	=	00000001b
DXINEMS 	=	00000010b	; obsolete
DXINVCPI	=	00000100b
DXINXMS 	=	00001000b

;
; See dxvcpi.asm for a rough sketch of the memory block that the
;   following variables describe

DXLINEARBASE	=	80000000h	; Linear base of DX system memory

VCPIPTOFF	=	0 * CBPAGE386	; vcpi's 0th page table
DXPT1OFF	=	1 * CBPAGE386	; dx's first user page table
DXPTSYSOFF	=	DXPT1OFF + (CPTDX * CBPAGE386)
					; dx's system page table
DXPDOFF 	=	DXPTSYSOFF + CBPAGE386	; page directory
DXLASTPTOFF	=	DXPDOFF
DXBOOTPTOFF	=	DXPTSYSOFF
;
; Last user page table is used to bootstrap our protected mode
; data into extended memory.
;
DXTEMPPTOFF		=	DXPTSYSOFF - CBPAGE386
DX_TEMP_LINEARBASE	=	(DXTEMPPTOFF - VCPIPTOFF) shl	10

;
; The next number comes from the dosx.map file, and is equal to the
; offset of the CODEENDPM symbol, plus whatever padding we want to use
; so we don't have to update this include file too often.
;
if DEBUG
DXPMCODESIZE	=	04900H
else ; DEBUG
DXPMCODESIZE	=	04000H
endif ; DEBUG

IDTOFF		=	DXLASTPTOFF + CBPAGE386
IDTSIZE         =       CDSCIDTDEFAULT * 8
IDTLIM          =       IDTSIZE - 1

TSSOFF		=	IDTOFF + IDTSIZE
TSSTOP		=	TSSOFF + (type TSS386)

GDTOFF		=	((TSSTOP + 0fh) shr 4) shl 4   ; paragraph align
GDTLIM		=	GDT_SIZE - 1
GDTTOP		=	GDTOFF + GDT_SIZE

DXPMCODEOFF	=	((GDTTOP + 0fh) shr 4) shl 4	; paragraph align

LDTOFF		=	((DXPMCODEOFF + DXPMCODESIZE + CBPAGE386 - 1) shr 12) shl 12
LDTSIZE 	=	CDSCMAXLDT * 8
LDTLIM		=	LDTSIZE - 1
LDTTOP		=	LDTOFF + LDTSIZE

;
; Final place where page tables are mapped in Protected mode is
; at the first linear page boundary after the end of the LDT.
;

USERPT		=	(LDTTOP + CBPAGE386 - 1) shr 12
USERPTOFF	=	((LDTTOP + CBPAGE386 - 1) shr 12) shl 12

;
; The total number of 386 pages we need for the block that holds our
; system tables and protected mode code.
;
DXPMPAGES	=	(LDTTOP + (CBPAGE386 - 1)) shr 12
DXPMBYTES	=	DXPMPAGES shl 12
DXPMPARAGRAPHS	=	DXPMBYTES shr 4

;
; compile time asserts for sizes/offsets/alignment
;
.ERRE	(type TSS386) GE 104
.ERRE	TSSTOP LE GDTOFF
.ERRE	IDTOFF EQ ((IDTOFF SHR 4) SHL 4)

;
; Limits of tables
;
DXPTMAX         =       CPTDX * CBPAGE386       ; space we allocate for
						; user page tables

;
; Linear pointers to bases of various tables when running under vcpi
;

; For a selDXPD descriptor (dos extender's page directory)
;
LADXPDBASE	=	DXLINEARBASE + DXPDOFF

; For a selDXPT descriptor (dos extender's page tables)
;
LADXPTBASE	=	DXLINEARBASE + USERPTOFF	; (Plus runtime value.)

; For a selGDT descriptor
;
LADXGDTBASE     =       DXLINEARBASE + GDTOFF

; For a selLDT descriptor
;
LADXLDTBASE     =       DXLINEARBASE + LDTOFF

; For a selIDT descriptor
;
LADXIDTBASE     =       DXLINEARBASE + IDTOFF

; For a selTSS descriptor
;
LADXTSS1BASE    =       DXLINEARBASE + TSSOFF
LADXTSS2BASE    =       DXLINEARBASE + TSSOFF + type TSS386

; For a SEL_DXPMCODE descriptor
;
LADXPMCODEBASE  =       DXLINEARBASE + DXPMCODEOFF


;
; vcpi/ems service macros
;
RMvcpi  macro fCode
        ifnb    <fCode>
        mov     ax, fCode
        endif
        int     VCPIINT
        endm

PMvcpi  macro fCode
        ifnb    <fCode>
        mov     ax, fCode
	endif
	cCall	CallVCPIPM
        endm

emscall macro   fCode
        ifnb    <fCode>
        mov     ax, fCode
        endif
        int     EMS_INT
        endm

; EMS functions/subfunctions

GETFRAMEADDRESS =	04100h

ALLOCATEPAGES	=	05A00h
GETNUMOFPAGES	=	04200h
MAPHANDLEPAGE   =       04400h
DEALLOCATEPAGES =       04500h
GETEMSVER       =       04600h
SETHANDLENAME   =       05301h
GETPAGEADDRS	=	05800h
GETNUMPAGEMAP	=	05801h

page
;
; VCPI functions/subfunctions
;       all functions take the vcpi function code in ax as input
;       all functions return ah=0 if successful, ah != 0 if failure
;       if function return has no ah value, it can't fail (ah == 0)
;
;

; vcpi version, presence
;
vcpiVER         =       0de00h
        ;
        ; input:
        ; return:       ah = 0, bl = vcpi minor revision, bh = major revision
        ;

; get protect mode interface
;
vcpiPMINTERFACE =       0de01h
        ;
        ; input:        es:di = ptr to 4k page table,
        ;               ds:si = ptr to 3 entries in GDT
        ; return:       di = 1st unused page table entry,
        ;               ebx = offset in server CS of PM entry point
        ;

; get max physical address in system
;
vcpiMAXPHYSADDR =       0de02h
        ;
        ; input:
        ; return:       edx = physical addr of highest 4k page that
        ;                       could ever be allocated
        ;

; count of free 4k pages
;
; Note:  This call gives the total 386 pages available to all tasks
; in the system from the VCPI server.  According to VCPI version 1.0,
; however, we should only allocate as much memory as there is EMS
; memory available.  The following call, therefore, is not real useful
; to us.
;
vcpiCFREEPAGES  =       0de03h
        ;
        ; input:
        ; return:       edx = number of free 4k pages
        ;

; allocate a 4k page
;
vcpiALLOCPAGE   =       0de04h
        ;
        ; input:
        ; return:       ah = 0, edx = physical address of allocated 4k page
        ;               ah != 0, edx = trashed
        ;

; free a 4k page
;
vcpiFREEPAGE    =       0de05h
        ;
        ; input:        edx = physical address of page to free
        ; return:       ah = 0
        ;               ah != 0
        ;

; physical address of page in 1st meg
;
vcpiPHYSADDRPAGE=       0de06h
        ;
        ; input:        cx = page number (linear addr of page SHR by 12)
        ; return:       ah = 0, edx = physical address of 4k page
        ;               ah != 0
        ;

; read cr0
;
vcpiREADCR0     =       0de07h
        ;
        ; input:
        ; return:       ebx = cr0 value
        ;

; read debug registers
;
vcpiREADDRx     =       0de08h
        ;
        ; input:        es:di = ptr to 8 dwords, dr0 first, dr4, dr5 not present
        ; return:
        ;

; load debug registers
;
vcpiLOADDRx     =       0de09h
        ;
        ; input:        es:di = ptr to 8 dwords, dr0 first, dr4, dr5 not present
        ; return:
        ;

; get mapping of hardware interrupts
;
vcpiGET8259MAP  =       0de0ah
        ;
        ; input:
        ; return:       bx = 1st vector mapping for master 8259a
        ;               cx = 1st vector mapping for slave  8259a

; set mapping of hardware interrupts
;
vcpiSET8259MAP  =       0de0bh
        ;
        ; input:        interrupts disabled
        ;               bx = 1st vector mapping for master 8259a
        ;               cx = 1st vector mapping for slave  8259a
        ; return:
        ;

; switch from v86 mode to protect mode or protect mode to v86 mode
;
vcpiSWITCHTOPM  =       0de0ch
        ;
        ; input:        interrupts disabled
        ;               esi = linear address (in first megabyte) of data
        ;                       structure (v86topm struc)
        ;
        ; return:       (output in pm)
        ;               gdtr, idtr, ldtr, tr loaded
        ;               ss:esp must have 16 bytes of space on it, pm must
        ;                       set up it's stack
        ;               eax = trashed
        ;               esi = trashed
        ;               ds, es, fs, gs all modified
        ;               interrupts disabled
        ;

vcpiSWITCHTOV86 =       0de0ch
        ;
        ; input:        interrupts disabled
        ;               STACK:  28  dword   gs
        ;                       24  dword   fs
        ;                       20  dword   ds
        ;                       1c  dword   es
        ;                       18  dword   ss
        ;                       14  dword   esp
        ;                       10  dword   eflags reserved
        ;                       0c  dword   cs xfer to
        ;                       08  dword   eip xfer to
        ;                       00  qword   far32 return (garbage)
        ;
        ;
        ; return:       (output in rm)
        ;               ss:esp loaded with values from stack
        ;               segment registers loaded with stack values
        ;               eax = trashed
        ;               interrupts disabled

;
; structures
;
VTP     struc
        zaCr3VTP        dd      0       ; physical addr of page directory
        laGdtrVTP       dd      0       ; linear addr in first meg of gdtr
        laIdtrVTP       dd      0       ; linear addr in first meg of idtr
        selLdtVTP       dw      0       ; selector of ldt
        selTrVTP        dw      0       ; selector of tr
        ipVTP           dw      0       ; 48-bit address of protect
        unusedVTP       dw      0       ;   mode entry point to xfer to
        csVTP           dw      0       ;
VTP     ends


ife (CurrentCpu AND 0008h)		;restore cpu type if not 386
   if (CurrentCpu AND 0080h)
      .286p
   else
      .286
   endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\prot386.inc ===
;*** prot386.inc - 386 protect mode structures, records, and masks.
;
;   Copyright <C> 1990-1991, Microsoft Corporation
;
;   Purpose:
;
;   Revision History:
;
;   []      20-Feb-1990 Dans    Created
;
;************************************************************************/
;
; page table entry record
;
PTEAltr record              \
        pfaPTEA:20,         \
        availPTEA:3,        \
        unusedPTEA:2,       \
        dirtyPTEA:1,        \
        accessedPTEA:1,     \
        pcdPTEA:1,          \
        pwtPTEA:1,          \
        usersuperPTEA:1,    \
        readwritePTEA:1,    \
        presentPTEA:1


PTEr    record              \
        pfaPTE:20,          \
        allbitsPTE:12
;
; New page table entry mask
;
NEWPTEMASK      =       mask presentPTEA OR     \
                        mask readwritePTEA OR   \
                        mask usersuperPTEA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\ntnpxem.asm ===
PAGE    ,132
        TITLE   NTNPXEM.ASM -- Support for fielding exceptions from npx em

; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      NTNPXEM.ASM     -   Exception handler for npx emulation *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*      This module contains code to field exceptions from the  *
;*      Nt NPX emulator.   These exceptions will only be        *
;*      received on machines without 387's, on which the app    *
;*      has set the EM bit.                                     *
;****************************************************************

        .286p
        .287

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include segdefs.inc
include gendefs.inc
include pmdefs.inc
include ks386.inc
include intmac.inc
        .list

; -------------------------------------------------------
;           GENERAL SYMBOL DEFINITIONS
; -------------------------------------------------------

; -------------------------------------------------------
;           EXTERNAL SYMBOL DEFINITIONS
; -------------------------------------------------------

        extrn   PmFaultEntryVector:near

; -------------------------------------------------------
;               DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

DXDATA  segment

        extrn   rgw0stack:word

DXDATA  ends

; -------------------------------------------------------
;               Exception Handler
; -------------------------------------------------------


DXPMCODE segment
        assume cs:DXPMCODE
        .386p
;
; N.B.  The following routine will be executed on a special
;       code selector.  The following routine must ALWAYS
;       appear at offset zero in this code selector.
;

; -------------------------------------------------------
;   NpxExceptionHandler -- This function switches to the
;       exception handler stack, pushes an exception frame,
;       and restores the registers.  It then transfers control
;       the trap 7 fault handler.
;
;   Input:      ss:esp -> an NT CONTEXT record
;   Output:     all registers restored to fault time
;               values, and exception frame pushed.
;   Errors:     none
;   Uses:       all

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING,fs:NOTHING
        public NpxExceptionHandler,EndNpxExceptionHandler

NpxExceptionHandler proc far

	FCLI
        mov     ax,ss
        mov     ds,ax
        mov     ebx,esp                         ; ds:ebx->CONTEXT
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ss,ax
        mov     esp,offset DXDATA:rgw0Stack     ; ss:esp->exception stack

;
; Push exception frame on exception stack
;
        movzx   eax,word ptr [ebx].CsSegSs
        push    eax
        push    dword ptr [ebx].CsEsp
        push    dword ptr [ebx].CsEFlags
        movzx   eax,word ptr [ebx].CsSegCs
        push    eax
        push    dword ptr [ebx].CsEip
;
; Restore registers
;
        mov     gs,[ebx].CsSegGs
        mov     fs,[ebx].CsSegFs
        mov     es,[ebx].CsSegEs
        mov     ebp,[ebx].CsEbp
        mov     edi,[ebx].CsEdi
        mov     esi,[ebx].CsEsi
        mov     edx,[ebx].CsEdx
        mov     ecx,[ebx].CsEcx
        mov     ax,[ebx].CsSegDs
        push    ax
        push    dword ptr [ebx].CsEbx
        mov     eax,[ebx].CsEax
        pop     ebx
        pop     ds
        db      0eah
        dw      (offset PmFaultEntryVector + 21)
        dw      SEL_DXPMCODE OR STD_RING
EndNpxExceptionHandler:
NpxExceptionHandler endp

DXPMCODE ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\pmdefs.inc ===
; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      PMDEFS.INC      --  80286 Protected Mode Definitions    *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*   7/28/89 jimmat   Changes selectors for Wdeb386 (it now     *
;*                    needs 4, not 2)                           *
;*   3/11/89 jimmat   Added selector for TSS                    *
;*   3/09/89 jimmat   Added selectors for DynaLink call gates   *
;*  02/10/89 (GeneA): reorganized selector definitions for      *
;*      change from small model to medium model                 *
;*  12/01/88 (GeneA): added definitions for SEL_BIOSCODE and    *
;*      SEL_USERSCR                                             *
;*                                                              *
;****************************************************************
;
; -------------------------------------------------------
;                  SELECTOR FIELDS
; -------------------------------------------------------

SELECTOR_RPL    =   00000011b           ;Requested Privilege Level mask
SELECTOR_TI     =   00000100b           ;Table Indicator mask
SELECTOR_INDEX  =   0fff8h              ;Index mask

SELECTOR_PL0    =   00000000b           ;Ring 0 privilege level
SELECTOR_PL1    =   00000001b           ;Ring 1 privilege level
SELECTOR_PL2    =   00000010b           ;Ring 2 privilege level
SELECTOR_PL3    =   00000011b           ;Ring 3 privilege level

SELECTOR_PL_DX  =   SELECTOR_PL3        ;Privilege level used by DOSX

; -------------------------------------------------------
;           ACCESS RIGHTS BIT DEFINITIONS
; -------------------------------------------------------
;
; These are the access rights byte bit position definitions.

; These fields are common to all descriptors
AB_PRESENT  =   10000000b   ;segment present bit
AB_DPL0     =   00000000b   ;ring 0 DPL
AB_DPL1     =   00100000b   ;ring 1 DPL
AB_DPL2     =   01000000b   ;ring 2 DPL
AB_DPL3     =   01100000b   ;ring 3 DPL
AB_DPL      =   01100000b   ;mask for DPL field

;AB_DPL_DX   =  AB_DPL3     ;DPL used by DOSX
AB_DPL_DX   =   (SELECTOR_PL_DX shl 5)      ;DPL used by DOSX

; These fields are relevant to code and data segment descriptors
;   (non-system descriptors)
AB_DATA     =   00010000b   ;data segment
AB_CODE     =   00011000b   ;code segment
AB_STACK    =   00010100b   ;expand down (stack) segment
AB_WRITE    =   00000010b   ;writable data
AB_READ     =   00000010b   ;readable code
AB_CONFORM  =   00000100b   ;conforming code
AB_ACCESSED =   00000001b   ;segment has been accessed
AB_BIG      =   0100000000000000b ; 32 bit segment

; These fields are relevant to system descriptors
AB_INVALID  =   00000000b   ;invalid descriptor
AB_TSS      =   00000001b   ;task state segment descriptor
AB_TSS386   =   00001001b   ;task state segment descriptor 386
AB_BUSY     =   00000010b   ;busy bit for task state descriptor
AB_LDT      =   00000010b   ;local descriptor table descriptor
AB_CALLGATE =   00000100b   ;call gate descriptor
AB_TASKGATE =   00000101b   ;task gate descriptor
AB_INTRGATE =   00000110b   ;interrupt gate descriptor
AB_TRAPGATE =   00000111b   ;trap gate descriptor
AB_IGATE386 =   00001110b   ;80386 interrupt gate descriptor

; These are some common combinations of the above fields making up
; useful access rights bytes.

ARB_CODE0   =   AB_PRESENT+AB_DPL0+AB_CODE+AB_READ      ;ring 0 code segment
ARB_CODE1   =   AB_PRESENT+AB_DPL1+AB_CODE+AB_READ      ;ring 1 code segment
ARB_CODE3   =   AB_PRESENT+AB_DPL3+AB_CODE+AB_READ      ;ring 3 code segment
ARB_CODE_DX =   AB_PRESENT+AB_DPL_DX+AB_CODE+AB_READ    ;DOSX ring code segment

ARB_DATA0NP =              AB_DPL0+AB_DATA+AB_WRITE     ;illegal segment
ARB_DATA0   =   AB_PRESENT+AB_DPL0+AB_DATA+AB_WRITE     ;ring 0 read/write data
ARB_DATA1   =   AB_PRESENT+AB_DPL1+AB_DATA+AB_WRITE     ;ring 1 read/write data
ARB_DATA3   =   AB_PRESENT+AB_DPL3+AB_DATA+AB_WRITE     ;ring 3 read/write data
ARB_DATA_DX =   AB_PRESENT+AB_DPL_DX+AB_DATA+AB_WRITE   ;DOSX ring read/write data

ARB_STACK0  =   AB_PRESENT+AB_DPL0+AB_STACK+AB_WRITE    ;ring 0 stack
ARB_STACK1  =   AB_PRESENT+AB_DPL1+AB_STACK+AB_WRITE    ;ring 1 stack
ARB_STACK3  =   AB_PRESENT+AB_DPL3+AB_STACK+AB_WRITE    ;ring 3 stack
ARB_STACK_DX =  AB_PRESENT+AB_DPL_DX+AB_STACK+AB_WRITE  ;DOSX ring stack

ARB_TRAP0   =   AB_PRESENT+AB_DPL0+AB_TRAPGATE          ;ring 0 trap gate
ARB_TRAP1   =   AB_PRESENT+AB_DPL1+AB_TRAPGATE          ;ring 1 trap gate
ARB_TRAP3   =   AB_PRESENT+AB_DPL3+AB_TRAPGATE          ;ring 3 trap gate
ARB_TRAP_DX =   AB_PRESENT+AB_DPL_DX+AB_TRAPGATE        ;DOSX ring trap gate

ARB_INTR0   =   AB_PRESENT+AB_DPL0+AB_INTRGATE          ;ring 0 interrupt gate
ARB_INTR1   =   AB_PRESENT+AB_DPL1+AB_INTRGATE          ;ring 1 interrupt gate
ARB_INTR3   =   AB_PRESENT+AB_DPL3+AB_INTRGATE          ;ring 3 interrupt gate
ARB_INTR_DX =   AB_PRESENT+AB_DPL_DX+AB_INTRGATE        ;DOSX ring interrupt gate

ARB_INTR0386=   AB_PRESENT+AB_DPL0+AB_IGATE386          ;ring 0 386 int gate
ARB_INTR1386=   AB_PRESENT+AB_DPL1+AB_IGATE386          ;ring 1 386 int gate
ARB_INTR3386=   AB_PRESENT+AB_DPL3+AB_IGATE386          ;ring 3 386 int gate
ARB_INTR_DX386= AB_PRESENT+AB_DPL_DX+AB_IGATE386        ;DOSX ring 386 int gate

ARB_CALL0   =   AB_PRESENT+AB_DPL0+AB_CALLGATE          ;ring 0 call gate
ARB_CALL1   =   AB_PRESENT+AB_DPL1+AB_CALLGATE          ;ring 1 call gate
ARB_CALL3   =   AB_PRESENT+AB_DPL3+AB_CALLGATE          ;ring 3 call gate
ARB_CALL_DX =   AB_PRESENT+AB_DPL_DX+AB_CALLGATE        ;DOSX ring call gate

ARB_TSS1    =   AB_PRESENT+AB_DPL1+AB_TSS               ;ring 1 task state seg
ARB_TSS3    =   AB_PRESENT+AB_DPL3+AB_TSS               ;ring 3 task state seg
ARB_TSS_DX  =   AB_PRESENT+AB_DPL_DX+AB_TSS             ;DOSX ring task state seg

ARB_TSS1386 =   AB_PRESENT+AB_DPL1+AB_TSS386            ;ring 1 386 TSS
ARB_TSS3386 =   AB_PRESENT+AB_DPL3+AB_TSS386            ;ring 3 386 TSS
ARB_TSS_DX386 = AB_PRESENT+AB_DPL_DX+AB_TSS386          ;DOSX ring 386 TSS

ARB_LDT1    =   AB_PRESENT+AB_DPL1+AB_LDT               ;ring 1 local dscr tbl
ARB_LDT3    =   AB_PRESENT+AB_DPL3+AB_LDT               ;ring 3 local dscr tbl
ARB_LDT_DX  =   AB_PRESENT+AB_DPL_DX+AB_LDT             ;DOSX ring local dscr tbl

;--------------------------------------------------------
;       STANDARD DESCRIPTOR TABLE/RING EQUATES
;--------------------------------------------------------

; Currently DOSX is setup to run most of itself and the child app in
; ring 1.  However this may be changed by changing the following equates.

STD_DPL         =       AB_DPL_DX
STD_DATA        =       ARB_DATA_DX
STD_CODE        =       ARB_CODE_DX
STD_STACK       =       ARB_STACK_DX
STD_TRAP        =       ARB_TRAP_DX
STD_INTR        =       ARB_INTR_DX
STD_INTR386     =       ARB_INTR_DX386
STD_CALL        =       ARB_CALL_DX
STD_TSS         =       ARB_TSS_DX
STD_TSS386      =       ARB_TSS_DX386
STD_LDT         =       ARB_LDT_DX

STD_TBL         =       SELECTOR_TI
STD_RING        =       SELECTOR_PL_DX OR SELECTOR_TI
STD_TBL_RING    =       (STD_TBL or STD_RING)

;
; Code descriptor type for handling processor exceptions.
;
EH_CODE         =       ARB_CODE0
EH_RING         =       SELECTOR_PL0
EH_RING_MASK    =       NOT 3
EH_DATA         =       ARB_DATA0

; -------------------------------------------------------
;           DESCRIPTOR STRUCTURE DEFINITIONS
; -------------------------------------------------------

; This structure defines the layout of a segment descriptor on the '286
; These can appear in either the local descriptor table or the global
; descriptor table.  The local descriptor table descriptors also fit into
; this format, but they can only appear in the global descriptor table.

SEGDSCR     struc
cbLimit         dw      0       ;segment size limit
adrBaseLow      dw      0       ;low word of segment base address
adrBaseHigh     db      0       ;high byte of segment base address
arbSegAccess    db      0       ;access rights byte
rsvdSeg         dw      0       ;Intel reserved, must be 0
SEGDSCR     ends

SEGDSCR386      struc
cbLimit386      dw      0       ;segment size limit
adrwBaseLow386  dw      0       ;low word of segment base address
adrbBaseMid386  db      0       ;mid byte of segment base address
arbSegAccess386 db      0       ;access rights byte
cbLimitHi386    db      0       ;hi nybble of size limit
adrbBaseHi386   db      0       ;high byte of segment base address
SEGDSCR386      ends

; This structure defines the layout of gate descriptors.  These can appear
; in any of the descriptor tables.  Only Interrupt Gate, Trap Gate, and
; Task Gate descriptors can appear in the interrupt descriptor table.

GATEDSCR    struc
offDest         dw      0       ;destination function offset (not used in
                                ; task gates)
selDest         dw      0       ;destination function segment selector
cwParam         db      0       ;count of parameter words to transfer
arbGate         db      0       ;access rights byte
rsvdGate        dw      0       ;Intel reserved, must be 0
GATEDSCR    ends

; This is the structure defines the layout of a Task State Segment
; descriptor.  This can only appear in the Global Descriptor Table

TSSDSCR     struc
cbTssLimit      dw  0           ;segment size limit
adrTssBaseLow   dw  0           ;low word of segment base address
adrTssBaseHigh  db  0           ;high byte of segment base address
arbTssAccess    db  0           ;access rights byte
rsvdTss         dw  0           ;Intel reserved, must be 0
TSSDSCR     ends

; -------------------------------------------------------
;               80286 TASK STATE SEGMENT
; -------------------------------------------------------
;
; This structure describes the layout of an 80286 task state
; segment.

TSS286  struc
tss_backlink    dw  ?           ;backlink to previous task
tss_sp0         dw  ?           ;privelege level 0 stack pointer
tss_ss0         dw  ?           ;privelege level 0 stack segment
tss_sp1         dw  ?           ;privelege level 1 stack pointer
tss_ss1         dw  ?           ;privelege level 1 stack segment
tss_sp2         dw  ?           ;privelege level 2 stack pointer
tss_ss2         dw  ?           ;privelege level 2 stack segment
tss_ip          dw  ?           ;initial instruction pointer
tss_flags       dw  ?
tss_ax          dw  ?
tss_cx          dw  ?
tss_dx          dw  ?
tss_bx          dw  ?
tss_sp          dw  ?
tss_bp          dw  ?
tss_si          dw  ?
tss_di          dw  ?
tss_es          dw  ?
tss_cs          dw  ?
tss_ss          dw  ?
tss_ds          dw  ?
tss_ldt         dw  ?           ;local descriptor table for this task

TSS286  ends

; -------------------------------------------------------
;               80386 TASK STATE SEGMENT
; -------------------------------------------------------
;
; This structure describes the layout of an 80386 task state
; segment.

TSS386  struc
ts3_backlink    dw  0           ;backlink to previous task
                dw  0
ts3_esp0        dd  0           ;privelege level 0 stack pointer
ts3_ss0         dw  0           ;privelege level 0 stack segment
                dw  0
ts3_esp1        dd  0           ;privelege level 1 stack pointer
ts3_ss1         dw  0           ;privelege level 1 stack segment
                dw  0
ts3_esp2        dd  0           ;privelege level 2 stack pointer
ts3_ss2         dw  0           ;privelege level 2 stack segment
                dw  0
ts3_eip         dd  0           ;initial instruction pointer
ts3_cr3         dd  0
ts3_eflags      dd  0
ts3_eax         dd  0
ts3_ecx         dd  0
ts3_edx         dd  0
ts3_ebx         dd  0
ts3_esp         dd  0
ts3_ebp         dd  0
ts3_esi         dd  0
ts3_edi         dd  0
ts3_es          dw  0
                dw  0
ts3_cs          dw  0
                dw  0
ts3_ss          dw  0
                dw  0
ts3_ds          dw  0
                dw  0
ts3_fs          dw  0
                dw  0
ts3_gs          dw  0
                dw  0
ts3_ldt         dw  0           ;local descriptor table for this task
                dw  0
ts3_iomap       dw  0
                dw  0

TSS386  ends


; -------------------------------------------------------
;               EXCEPTION VECTORS
; -------------------------------------------------------

; These are the interrupt vector numbers for the exception
; interrupts reserved by the 80286/80386.

EXC_DIV0        =   0           ;divide error
EXC_SINGLESTEP  =   1           ;single step
EXC_NMI         =   2           ;NMI interrupt
EXC_BREAKPOINT  =   3           ;breakpoint interrupt
EXC_INTO        =   4           ;overflow interrupt
EXC_BOUND       =   5           ;bounds overflow exception
EXC_OPCODE      =   6           ;invalid opcode exception
EXC_COPROCESSOR =   7           ;processor extension not available
EXC_DOUBLE      =   8           ;double fault
EXC_XOVERRUN    =   9           ;coprocessor segment overrun
EXC_TSS         =   10          ;invalid task state segment exception
EXC_NOTPRESENT  =   11          ;segment not present exception
EXC_STACK       =   12          ;stack overrun, or stack segment not present
EXC_GP          =   13          ;general protection exception
EXC_PF          =   14          ;page fault

; -------------------------------------------------------
;           GLOBAL DESCRIPTOR DECLARATIONS
; -------------------------------------------------------
;
;   The following symbols define the segment descriptors that
;   are statically defined in the Dos Extender.
;
;   NOTE:
;   These selector definitions assume that codeview is running
;   at privelege level 0.  If codeview is running at another
;   privelege level, the RPL fields must be adjusted.
;
;   Global Descriptor Table Conventions used in the Dos Extender

SEL_NULL        = 00h           ;null selector

SEL_GDT         = 80h           ;read/write data segment pointing to the
                                ; global descriptor table
SEL_IDT         = 88h           ;read/write data segment pointing to the
                                ; protected mode interrupt descriptor table
SEL_RMIVT       = 90h           ;read/write data segment pointing to the
                                ; real mode interrupt vector table
SEL_PSP         = 98h           ;Dos Extender PSP
SEL_ENVIRON     = 0A0h          ;Dos Extender Environment
SEL_BIOSCODE    = 0A8h          ;points at segment F000
SEL_DXDATA      = 0B0h          ;Dos Extender data segment
SEL_BIOSDATA    = 0B8h          ;PC BIOS data segment
SEL_DXPMCODE    = 0C0h          ;Dos Extender extended memory code segment
SEL_DXCODE      = 0C8h          ;Dos Extender low memory code segment
SEL_LDT_ALIAS   = 0D0h          ;read/write alias to LDT

;SEL_VDMTIB      = 0D8h          ;used by DOSX to access TIB

SEL_EH          = 0E0h          ;Ring 0 segment code for handling processor
                                ;exceptions in PMODE

SEL_DOSSCR      = 0E8h

SEL_DXDATA0     = 0f0h
SEL_DXCODE0     = 0f8h
;SEL_RZIRET      = 0100h
SEL_LDT         = 0108h
;SEL_RESET       = 0110h
SEL_TSS         = 0118h
SEL_TSS_ALIAS   = 0120h

SEL_NBSCRATCH   = 0128h   

SEL_WOW_LDT     = 0130h         ; readonly LDT selector for WOW kernel

SEL_NPXHDLR     = 0138h         ; selector for NpxExceptionHandler

SEL_IRETHOOK    = 0140h
SEL_NBPMCODE    = 0148H          ; net bios anr handler cs
;
; Size of the GDT.
;
GDT_SIZE        = (SEL_NBPMCODE + 8)
GDT_SELECTORS   = (GDT_SIZE shr 3)

;
; Special LDT selectors.
;

SEL_DPMI_FIRST  =      0        ; first reserved DPMI LDT selector
C_DPMI_RESERVED =      10h      ; count of reserved DPMI LDT selectors
SEL_DPMI_LAST   =      (C_DPMI_RESERVED - 1) * 8
                                ; last reserved DPMI LDT selector

SEL_SCR0        = SEL_NBPMCODE + 8

                                ;scratch selector 0
SEL_SCR1        = SEL_SCR0 + 8  ;scratch selector 1
SEL_USERSCR     = SEL_SCR1 + 8  ;user scratch selector. This is used for
                                ; temporary return values to user from
                                ; system and bios calls
SEL_USER_STACK  = SEL_USERSCR + 8
SEL_USER        = SEL_USER_STACK + 8
; -------------------------------------------------------
; -------------------------------------------------------
; -------------------------------------------------------

;****************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\segdefs.inc ===
; Copyright (c) Microsoft Coropration 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      SEGDEFS.INC  -- Segment Declarations for Dos Extender   *
;*                                                              *
;****************************************************************
;*  Revision History:                                           *
;*                                                              *
;*  12/13/88 (GeneA): reordered segments so that the code       *
;*      segment is last.                                        *
;*                                                              *
;****************************************************************
;
; -------------------------------------------------------
;               DOS EXTENDER SEGMENTS
; -------------------------------------------------------

;; Touch here to force rebuild of DOSX!  EarleH

?DF=1
?PLM=1
?WIN=0
?MEDIUM=1
DOS5=1
IFNDEF WHEN_COMMAND_COM_WORKS
WINDOWS=1
ELSE
WINDOWS=0
ENDIF
include .\cmacros.inc

DXDATA  segment para public 'DATA'

DXDATA  ends


DXSTACK segment para stack 'STACK'

DXSTACK ends


;
; This segment contains both real mode and protected mode code and
; resides in low memory.
DXCODE  segment para public 'CODE'

DXCODE  ends

;
; This segment contains protected mode code only, and is moved up
; into extended memory during the initialization process.

DXPMCODE    segment para public 'PMCODE'

DXPMCODE    ends

; -------------------------------------------------------
;               GROUP DECLARATIONS
; -------------------------------------------------------

DGROUP  group   DXDATA, DXSTACK

; -------------------------------------------------------
;       MS-DOS PROGRAM SEGMENT PREFIX DEFINITION
; -------------------------------------------------------

PSPSEG  segment at  0

fnExit          dw      ?       ;INT 20h instruction for termination linkage
segMemEnd       dw      ?       ;segment address of end of program's memory
rsvd1           db      ?       ;undefined
fnDosFunc       db      5 dup (?)   ;far call to DOS function dispatcher
lpfnParent      dd      ?       ;far pointer to parent program
lpfnInt23       dd      ?       ;previous contents of INT 23h vector (^C)
lpfnInt24       dd      ?       ;previous contents of INT 24h vector
segParentPSP    dw      ?       ;segment address of parent PSP
bFileTable      db      20 dup (?)  ;process file table
segEnviron      dw      ?       ;segment address of environment
lpStack         dd      ?       ;application's SS:SP (updated on each dos call)
cbFileTable     dw      ?       ;size of process file table
lpFileTable     dd      ?       ;far pointer to process file table

        org     5Ch

fcbDefault1     db      10h dup (?) ;default FCB 1
fcbDefault2     db      10h dup (?) ;default FCB 2

        org     80h

cbCommand       db      ?       ;lenght of command string
chCommand       db      7Fh dup (?) ;command string

PSPSEG      ends

; -------------------------------------------------------
;           BIOS DATA SEGMENT DEFINITIONS
; -------------------------------------------------------

BIOS_DATA   segment at  40h     ;BIOS Data segment

        org     67h
IO_ROM_INIT     dw      ?       ;Shutdown code 0Ah will cause the
IO_ROM_SEG      dw      ?       ; bios to return control to the far
                                ; address stored here.
                                ;Shutdown code 09h will cause the
                                ; bios to load SS:SP from here and
                                ; do an IRET.
INTR_FLAG       db      ?

        org     72h
RESET_FLAG      dw      ?       ;For Ctrl-Alt-Del

BIOS_DATA   ends

; -------------------------------------------------------

;****************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\ntintr32.asm ===
include intmac.inc
        public rgw032Stack

            dw      64 dup (?)          ; DOSX Ring -> Ring 0 transition stack
;
; Interrupts in the range 0-1fh cause a ring transition and leave
; an outer ring IRET frame right here.
;
Ring0_EH_DS             dw      ?       ; place to put user DS
Ring0_EH_AX             dw      ?       ; place to put user AX
Ring0_EH_BX             dw      ?       ; place to put user BX
Ring0_EH_CX             dw      ?       ; place to put user CX
Ring0_EH_BP             dw      ?       ; place to put user BP
Ring0_EH_PEC            dw      ?       ; lsw of error code for 386 page fault
                                ; also near return to PMFaultEntryVector
Ring0_EH_EC             dw      ?       ; error code passed to EH
Ring0_EH_IP             dw      ?       ; interrupted code IP
                        dw      ?
Ring0_EH_CS             dw      ?       ; interrupted code CS
                        dw      ?
Ring0_EH_Flags          dw      ?       ; interrupted code flags
                        dw      ?
Ring0_EH_SP             dw      ?       ; interrupted code SP
                        dw      ?
Ring0_EH_SS             dw      ?       ; interrupted code SS
                        dw      ?
rgw032Stack   label   word

; ------------------------------------------------------------------
;   PMFaultAnalyzer -- This routine is the entry point for
;       the protected mode fault/trap/exception handler.  It tries
;       to distinguish between bona fide processor faults and
;       hardware/software interrupts which use the range of
;       interrupts that is reserved by Intel.  If a fault is
;       detected, then format the stack for a DPMI fault handler,
;       then vector to the handler whose address is stored in
;       PMFaultVector.  If it looks more like an interrupt, then
;       set up the stack for an interrupt handler, jump to the
;       handler whose address is stored in PMIntelVector.
;
;   Input:  none
;   Output: none

        assume  ds:NOTHING,es:NOTHING,ss:DGROUP
        public  PMFaultAnalyzer

PMFaultAnalyzer  proc near

;
; Make sure we are on the right stack.  Else, something fishy is going on.
; Note that stack faults won't do too well here.
;
        push    ax
        mov     ax,ss
        cmp     ax,SEL_DXDATA or STD_RING
        pop     ax
        je      pmfa_stack_passed
        jmp     pmfa_bad_stack
pmfa_stack_passed:
;
; Is the stack pointer pointing at a word error code (minus 2)?
;
        cmp     sp,offset DGROUP:Ring0_EH_PEC
        je      pmfa_fault              ; Yes, processor fault.

;
; Is it pointing to where it is supposed to be for a hardware or
; software interrupt?
;
        cmp     sp,offset DGROUP:Ring0_EH_EC
        je      pmfa_20
        jmp     pmfa_bad_stack
pmfa_20:jmp     pmfa_inspect

pmfa_fault:
;
; Getting here, we have a known exception with a word error code of some
; sort on the stack.  Perform an outward ring transition, switch to the
; client stack, then vector through the exception handler vector to the
; appropriate handler.
;
        push    bp
        push    cx
        push    bx
        push    ax
        push    ds
        lea     bp,Ring0_EH_SS
        mov     ax,word ptr [bp]
        mov     cx,selEHStack
        cmp     ax,cx
        jne     pmfa_stack_OK
        mov     bx,[bp-2]
        jmp     pmfa_copy_stack
pmfa_stack_OK:
        mov     bx,npEHStackLimit
pmfa_copy_stack:
        mov     ds,cx                   ; DS:BX = user SS:SP
        mov     cx,13
        add     bp,2                    ; put both halves of ss
pmfa_copy_stack_loop:
        dec     bx
        dec     bx
        mov     ax,word ptr [bp]
        mov     word ptr [bx],ax
        dec     bp
        dec     bp
        loop    pmfa_copy_stack_loop

; DS:BX points to stack on entry to PMFaultReflector

;
; Build a far return frame on user stack, switch to user stack, and return
;
        lea     bp,Ring0_EH_PEC
        mov     word ptr [bp+6],ds
        mov     word ptr [bp+4],bx

        sub     bx,2
        mov     word ptr ds:[bx],SEL_DXPMCODE OR STD_RING; push cs
        sub     bx,2
        mov     ds:[bx],offset DXPMCODE:PMFaultReflector; push ip
        lea     bp,Ring0_EH_PEC
        mov     ax,Ring0_EH_CX                  ; get BP value
        sub     bx,2
        mov     ds:[bx],ax                      ; push bp
        mov     Ring0_EH_PEC,bx                 ; sp for lss
        mov     bx,ds
        mov     Ring0_EH_EC,bx                  ; ss for lss
        pop     ds
        pop     ax
        pop     bx
        pop     cx
.386p
        lss     sp,[bp]                         ; switch stack
.286p
        pop     bp
        retf

pmfa_inspect:
;
; Stack is set up as for an interrupt or exception without error code.
; Adjust the stack pointer and put an error code of zero.  Then try to
; determine whether we have an exception or an interrupt.  First test
; is the interrupt number.
;
        push    Ring0_EH_EC
        mov     Ring0_EH_EC,0
        cmp     Ring0_EH_PEC,offset PMFaultEntryVector + ((7 + 1) * 3)
        ja      pfma_50
        push    Ring0_EH_PEC
        mov     Ring0_EH_PEC,0
        jmp     pmfa_fault      ; Yes, definitely a fault.
pfma_50:
;
; At this point, all valid exceptions have been eliminated except for
; exception 9, coprocessor segment overrun, and exception 16, coprocessor
; error.
;

;         **********************************************
;         * Your code to detect these exceptions here. *
;         **********************************************

        push    bp
        push    cx
        push    bx
        push    ax
        push    ds                              ; SP -> Ring0_EH_DS
;
; Point to the user's stack.
;
        lea     bp,Ring0_EH_SS
        mov     cx,[bp]
        mov     ds,cx
        mov     bx,[bp-2]                       ; DS:[BX] -> user stack
;
; Copy the IRET frame to the user stack.
;
        lea     bp,Ring0_EH_Flags
        mov     cx,6
pmfa_copy_IRET:
        mov     ax,[bp]
        dec     bx
        dec     bx
        mov     [bx],ax
        dec     bp
        dec     bp
        loop    pmfa_copy_IRET
;
; Point BP at vector entry for this (reserved) interrupt.
;
        mov     ax,Ring0_EH_PEC                 ; fetch near return address
        sub     ax,offset DXPMCODE:PMFaultEntryVector+3
        mov     cl,3
        div     cl                              ; AX = interrupt number
        shl     ax,2                            ; AX = vector entry offset
        lea     bp,PMIntelVector
        add     bp,ax                   ; BP -> interrupt handler address
        mov     ax,[bp]                         ; AX = IP of handler
        mov     cx,[bp+2]                       ; CX = CS of handler
;
; Build a far return frame on user stack, switch to user stack, and return
;

        sub     bx,2
        mov     ds:[bx],cx                      ; push cs
        sub     bx,2
        mov     ds:[bx],ax                      ; push ip
        lea     bp,Ring0_EH_PEC
        mov     ax,Ring0_EH_BP
        sub     bx,2
        mov     ds:[bx],ax                      ; push bp
        mov     Ring0_EH_PEC,bx                 ; sp for lss
        mov     bx,ds
        mov     Ring0_EH_EC,bx                  ; ss for lss
        pop     ds
        pop     ax
        pop     bx
        pop     cx
.386p
        lss     sp,[bp]                         ; switch stack
.286p
        pop     bp
        retf                                    ; Out of here.

pmfa_bad_stack:

if      DEBUG
        mov     ax,ss
        mov     bx,sp
        Trace_Out       "Fault Handler Aborting with SS:SP = #AX:#BX"
        pop     ax
        sub     ax, (offset DXPMCODE:PMFaultEntryVector) + 3
        mov     bx,3
        div     bl
        Trace_Out       "Fault Number #AX"
        pop     ax
        pop     bx
        pop     cx
        pop     dx
        Trace_Out       "First four stack words: #AX #BX #CX #DX."
endif
        push    selDgroupPM
        push    offset DGROUP:rgwStack
        rpushf
        push    SEL_DXPMCODE or STD_RING
        push    offset DXPMCODE:pmfr_death
        riret
pmfr_death:
        mov     ax,cs
        mov     ds,ax
        mov     dx,offset szRing0FaultMessage
        pmdossvc        09h
        jmp     PMAbort

PMFaultAnalyzer  endp

FR_Stack        Struc
        FR_BP           dd      ?
        FR_AX           dd      ?
        FR_BX           dd      ?
        FR_DS           dw      ?
        FR_ENTRY        dd      ?       ; SS:[SP] points here on entry
                                        ; to PMReservedReflector
        FR_Toss         dd      ?       ; DPMI return IP
        FR_Ret_IP       dd      ?       ; actual fault handler gets put
        FR_Ret_CS       dd      ?       ; here to return to
        FR_IP           dd      ?
        FR_CS           dd      ?
        FR_FL           dd      ?
        FR_SP           dd      ?
        FR_SS           dd      ?
FR_Stack        Ends
;
; Alternate names so the structure above makes more sense to
; PMFaultReflector.
;
FR_Handler_IP           equ     FR_DS
FR_Handler_CS           equ     FR_ENTRY
FR_Handler_Ret_IP       equ     FR_Toss
FR_Handler_Ret_CS       equ     FR_Ret_IP
FR_Handler_Entry        equ     FR_Handler_Ret_CS
FR_EC                   equ     FR_Ret_CS

; ------------------------------------------------------------------
; PMFaultReflector -- Dispatch a fault to a fault handler installed
;       in PMFaultVector.  When the fault handler returns, return
;       to the faulting code, using the addresses placed on the
;       DPMI fault handler stack by the last called fault handler.
;
;   Input:
;       Entry is by a NEAR call, with an IP within the range
;       of PMFaultEntryVector on the stack.  The stack has been
;       set up for use by a DPMI fault handler.
;
;   Output:
;       Controlled by fault handler.
;
;   Uses:
;       Controlled by fault handler.
;
;   Notes:
;       Fault handlers are called on a static stack.  This routine
;       is NOT REENTRANT.
;
        public  PMFaultReflector
        public  PMFaultReflectorIRET
PMFaultReflector        proc    near
        assume  ss:nothing,ds:nothing,es:nothing

        sub     sp,6
        push    bx
        push    eax
        push    bp
        mov     bp,sp
        push    ds
        mov     ax,SEL_DXDATA or STD_RING
        mov     ds,ax
        assume  ds:dgroup
        mov     ax,[bp.FR_Handler_Entry]
        sub     ax,offset DXPMCODE:PMFaultEntryVector+3
        mov     bl,3
        div     bl                      ; AX = interrupt number
        shl     ax,3                    ; AX = offset of fault handler

        lea     bx,PMFaultVector
        add     bx,ax                   ; SS:[BX] -> fault vector entry
        mov     eax,word ptr ds:[bx]
        mov     [bp.FR_Handler_IP],eax
        mov     ax,word ptr ds:[bx+2]
        mov     [bp.FR_Handler_CS],ax

        lea     ax,pmfr_cleanup
        movzx   eax,ax
        mov     [bp.FR_Handler_Ret_IP],eax
        push    cs
        pop     [bp.FR_Handler_Ret_CS]

        pop     ds
        assume  ds:nothing
        pop     bp
        pop     ax
        pop     bx
        db 066h,0CBh                    ; This calls the fault handler.

PMFaultReflectorIRETCall:
        dd      (SEL_RZIRET or STD_RING) shl 10h

pmfr_cleanup:
;
; Unwind the fault handler stack.  Return to the faulting code.
; This works by calling a Ring 0 procedure to do the actual IRET.
; If we do it that way, we can return to the faulting code without
; actually touching the faulting code's stack.
;
PMFaultReflectorIRET:

        ; BUGBUG Daveh using user stack this way is less robust!!!

.386p
        add     sp,4                    ; pop error code
        push    bp
        mov     bp,sp
        push    ebx
        push    ds
        push    eax
        mov     ax,[bp + 18]
        mov     ds,ax
        mov     ebx,[bp + 14]           ; ds:bx -> user stack
        sub     ebx,4
        mov     eax,[bp + 10]
        mov     ds:[ebx],eax            ; push flags
        sub     ebx,4
        mov     eax,[bp + 4]
        mov     ds:[ebx],eax            ; push cs
        sub     ebx,4
        mov     eax,[bp + 2]
        mov     ds:[ebx],eax            ; push ip
        sub     ebx,2
        mov     ax,[bp]
        mov     ds:[ebx],ax             ; push bp
        mov     [bp + 8],bx
        pop     eax
        pop     ds
        pop     ebx
        pop     bp

        add     sp,6                    ; point to ss:sp
        mov     bp,sp

        lss     esp,[bp]
.286p
        pop     bp                      ; restore bp
        riretd
endif
PMFaultReflector        endp
;
; -------------------------------------------------------
;   PMReservedReflector -- This routine is for reflecting
;       exceptions to a protected mode interrupt handler.
;       The default for exceptions 1, 2, and 3 is to have
;       a near call to this routine placed in the PMFaultVector.
;
;       This routine strips off the fault handler stack set
;       up by PMFaultAnalyzer, switches to the stack pointed
;       to by the pushed SS and SP values, sets up an IRET
;       frame for use by PMIntrReflector, and jumps to
;       PMIntrReflector.  Eventual return is via an IRET
;       from PMIntrReflector.
;
;   Input:
;       Entry is by a NEAR call, with an IP within the range
;       of PMReservedEntryVector on the stack.  The stack has been
;       set up for use by a DPMI fault handler.
;
;   Output:
;       Switch to stack registers set up by any previous fault
;       handler, jump to PMIntrReflector with an IRET frame set up
;       for direct return to the interrupted code.
;
;   Errors: none
;
;   Uses:   Modifies SS, SP.  Does not return to caller.
;

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  PMReservedReflector
PMReservedReflector:

        push    ds
        push    ebx
        push    eax
        push    ebp
        mov     bp,sp
;
; BP now points to a stack frame described by the structure
; above.  This will be copied to a stack frame on the stack pointed to
; by FR_SS:FR_SS.  In most cases, the destination stack is actually
; the same as the present stack, offset by four bytes.  The following
; block of code is therefore very likely an overlapping copy.  Think
; carefully before modifying how it works.
;

        mov     bx,[bp.FR_SS]
        mov     ds,bx
        mov     ebx,[bp.FR_SP]  ; DS:[BX] -> interrupted code's stack
        sub     bx, (size FR_Stack) - 8         ; (not copying SP or SS)
                                ; DS:[BX] -> place to copy our stack frame

        mov     eax,[bp.FR_FL]  ; Push user IRET frame onto the destination
        mov     [ebx.FR_FL],eax ; stack.
        mov     eax,[bp.FR_CS]
        mov     [ebx.FR_CS],eax
        mov     eax,[bp.FR_IP]
        mov     [ebx.FR_IP],eax

        mov     eax,[bp.FR_ENTRY]       ; Copy our caller's near return.
        mov     [ebx.FR_ENTRY],eax

        mov     ax,[bp.FR_DS]   ; Copy saved registers.
        mov     [ebx.FR_DS],ax
        mov     eax,[bp.FR_BX]
        mov     [ebx.FR_BX],eax
        mov     eax,[bp.FR_AX]
        mov     [ebx.FR_AX],eax
        mov     eax,[bp.FR_BP]
        mov     [ebx.FR_BP],eax

        mov     ax,ds           ; Switch to user stack.
        mov     ss,ax
        mov     esp,ebx
        mov     ebp,esp

        mov     ax,[ebp.FR_ENTRY]        ; AX = offset of caller
        sub     ax,offset DXPMCODE:PMReservedEntryVector + 3
        mov     bl,3
        div     bl                      ; AX = interrupt number
        shl     ax,2                    ; AX = offset into PMIntelVector
        mov     ds,SelDgroupPM
        assume  ds:DGROUP
        lea     bx,PMIntelVector
        add     bx,ax                   ; DS:[BX] -> interrupt handler

        mov     eax,[bx]                 ; Place vector entry just below
        mov     [ebp.FR_Ret_IP],eax       ; IRET frame.
        mov     eax,[bx+4]
        mov     [ebp.FR_Ret_CS],eax

        lea     esp,[ebp.FR_BP]           ; Point to saved registers.
        pop     ebp                      ; Pop 'em.
        pop     eax
        pop     ebx
        pop     ds
        add     esp,4                    ; Fix up stack.

        db 066h,0CBh              ; jump to interrupt handler via far return


DXPMCODE    ends

; -------------------------------------------------------
        subttl  Real Mode Interrupt Reflector
        page
; -------------------------------------------------------
;           REAL MODE INTERRUPT REFLECTOR
; -------------------------------------------------------

DXCODE  segment
        assume  cs:DXCODE
; -------------------------------------------------------
;   RMIntrEntryVector   -- This table contains a vector of
;       near jump instructions to the real mode interrupt
;       reflector.  Real mode interrupts that have been hooked
;       by the protected mode application have their vector
;       set to entry the real mode reflector through this table.

        public      RMIntrEntryVector

RMIntrEntryVector:

        rept    256
        call    RMIntrReflector
        endm

; -------------------------------------------------------
;   RMIntrReflector -- This routine is the entry point for
;       the real mode interrupt reflector.  This routine
;       is entered when an interrupt occurs (either software
;       or hardware) that has been hooked by the protected mode
;       application.  It switches the processor to protected mode
;       and transfers control to the appropriate interrupt
;       service routine for the interrupt.  After the interrupt
;       service routine completes, it switches back to real
;       mode and returns control to the originally interrupted
;       real mode code.
;       Entry to this routine comes from the RMIntrEntryVector,
;       which contains a vector of near call instructions, which
;       all call here.  The interrupt number is determined from
;       the return address of the near call from the interrupt
;       entry vector.
;       The address of the protected mode interrupt service routine
;       to execute is determined from the protected mode interrupt
;       descriptor tabel and the interrupt number.
;
;   Input:  none
;   Output: none
;   Errors: none
;   Uses:   The segment registers are explicitly preserved by
;           this routine.  Other registers are as preserved or
;           modified by the interrutp service routine.

        assume  ds:NOTHING,es:NOTHING,ss:NOTHING
        public  RMIntrReflector

RMIntrReflector:
;
; On entry, the stack layout is:
;   [6] FLAGS   -        "
;   [4] CS      -        "
;   [2] IP      - from original interrupt
;   [0] IP      - from interrupt entry vector call
;
	FCLI
        cld
        push    ds
IFDEF   ROM
        SetRMDataSeg
ELSE
        mov     ds,selDgroup
ENDIF
        assume  ds:DGROUP
if DEBUG
;
; Are we on a DOSX interrupt reflector stack?
;
        push    ax
        push    cx
        mov     ax,ss
        mov     cx,ds
        cmp     ax,cx
        pop     cx
        jne     @F

        cmp     sp,offset bReflStack
        jb      @F
        cmp     sp,offset pbReflStack
        jnb     @F
;
; If so, have we overflowed a stacklet?
;
        mov     ax,pbReflStack
        cmp     sp,ax
        ja      @F
        add     ax,CB_STKFRAME
        cmp     sp,ax
        jb      @F
        pop     ax
        Real_Debug_Out "DOSX:RMIntrReflector--Reflector stack overflow."
        push    ax
@@:
        pop     ax
endif ;DEBUG
        mov     regUserAX,ax    ;save user AX for later
        push    bp              ;stack ->   BP  DS  IP  IP  CS  FL
        mov     bp,sp           ;           [0] [2] [4] [6] [8] [A]
        mov     ax,[bp+0Ah]     ;get the interrupted routine's flags
        and     ax,NOT 4100h    ;clear the trace flag in case we got
                                ; an interrupt on an instruction about
                                ; to be single stepped
        mov     regUserFL,ax    ;and save for later
        mov     ax,es
        xchg    ax,[bp+4]       ;save ES and get entry vector address
        pop     bp

; Some software (like older versions of Smartdrv.sys) may enable A20 on
; their own, and get very 'suprised' to find it turned off by our PM->RM
; mode switch.  If they used Himem.sys, this wouldn't be necessary, but...

if VCPI
        cmp     fVCPI,0
        jnz     @f
endif
        push    ax              ;get/save current A20 state on stack
        push    bx
        xmssvc  7
        mov     regUserSP,ax    ;use regUserSP as a temp var
        pop     bx
        pop     ax
@@:
        push    regUserSP

; The state that we want to save on the user's stack has been set up.
; Convert the entry vector return address into an interrupt number.

        sub     ax,offset RMIntrEntryVector+3
        push    cx
        mov     cl,3
        div     cl
        pop     cx

if DEBUG
        mov     PMIntNo,ax
endif

; Allocate a new stack frame, and then switch to the reflector stack
; frame.

        mov     regUserSP,sp    ;save entry stack pointer so we can
        mov     regUSerSS,ss    ; switch to our own stack
IFDEF   ROM
        push    ds
        pop     ss
ELSE
        mov     ss,selDgroup    ;switch to the reflector stack frame
ENDIF
        mov     sp,pbReflStack
        push    pbReflStack     ;save stack frame ptr on stack
        sub     pbReflStack,CB_STKFRAME ;adjust pointer to next stack frame

; We are now running on our own stack, so we can switch into protected mode.

        push    ax              ;save interrupt vector table offset
        SwitchToProtectedMode
        pop     ax

if      DEBUG   ;--------------------------------------------------------

        push    0DEADh          ;debugging id & interrupt number
        push    PMIntNo

        cmp     fTraceReflect,0
        jz      @f
        push    ax
        mov     ax,PMIntNo
        Trace_Out "(rp#AL)",x
        pop     ax
@@:

; Perform a too-late-to-save-us-now-but-we-want-to-know check on the
; reflector stack.

        cmp     StackGuard,1022h
        jz      @f
        Debug_Out "DOSX:RMIntrReflector--Global reflector stack overflow."
@@:
endif   ;DEBUG  ---------------------------------------------------------

; Build an IRET frame on the stack so that the protected mode interrupt service
; routine will return to us when it is finished.

        push    regUserSS       ;save user stack address on our own stack
        push    regUserSP       ; frame so we can restore it later
        push    ds
        push    regUserFL
        push    cs
        push    offset rmrf50

; Build an IRET frame on the stack to use to transfer control to the
; protected mode ISR

        and     byte ptr regUserFL+1,not 02h    ;use entry flags less the
        push    0                               ; high half esp
        push    regUserFL                       ;  interrupt flag (IF)

        xchg    bx,ax           ;interrupt vector offset to BX, preserve BX
        cmp     bx,CRESERVED    ;Interrupt in reserved range?
        jc      rmrf_reserved
        shl     bx,3
        mov     es,selIDT
        jmp     rmrf_setISR
rmrf_reserved:
        shl     bx,2
        mov     es,SelDgroupPM
        add     bx,offset DGROUP:PMIntelVector
rmrf_setISR:
        push    dword ptr es:[bx+4] ;push segment of isr
        push    dword ptr es:[bx]   ;push offset of isr
        xchg    bx,ax
        mov     ax,regUserAX    ;restore entry value of AX
        push    ds
        pop     es

; At this point the interrupt reflector stack looks like this:
;
;   [18]    previous stack frame pointer
;   [16]    stack segment of original stack
;   [14]    stack pointer of original stack
;   [12]    protected mode dos extender data segment
;   [10]    dos extender flags
;   [8]     segment of return address back to interupt reflector
;   [6]     offset of return address back to interrupt reflector
;   [4]     user flags as on entry from original interrupt
;   [2]     segment of protected mode ISR
;   [0]     offset of protected mode ISR
;
; Execute the protected mode interrupt service routine

        iretd

; The protected mode ISR will return here after it is finsished.

rmrf50: pop     ds
        pushf                   ;save flags as returned by PM Int routine

	FCLI			 ;We have to clear interrupts here, because
        cld                     ; the interrupt routine may have returned
                                ; with interrupts on and our code that uses
                                ; static variables must be protected.  We
                                ; turn them off after to pushf instruction so
                                ; that we can preserve the state of the
                                ; interrupt flag as returned by the ISR.
        mov     regUserAX,ax
        pop     ax
        pop     regUserSP
        pop     regUserSS

if DEBUG
        add     sp,4            ;'pop' off debugging info
endif

        pop     pbReflStack     ;deallocate stack frame(s)

; Switch back to real mode.

        push    ax              ;preserve AX
        SwitchToRealMode
        pop     ax

; Switch back to the original stack.

        mov     ss,regUserSS
        mov     sp,regUserSP

; Make sure the A20 line matches whatever state it was when the int occured.
; This is for the benefit of any software that diddles A20 without using
; an XMS driver

        pop     regUserSP       ;A20 state at time of interrupt to temp var
if VCPI
        cmp     fVCPI,0
        jnz     rmrf75
endif
        push    ax              ;save current ax
        mov     ax,regUserSP    ;ax = A20 state at time of interrupt
        or      ax,ax           ;if it was off, don't sweat it
        jz      rmrf70
        push    bx              ;save bx (XMS calls destroy bl)
        push    ax
        xmssvc  7               ;ax = current A20 state
        pop     bx              ;bx = old A20 state
        cmp     ax,bx           ;if A20 is still on, don't need to diddle
        jz      @f
        xmssvc  5               ;force A20 back on
        inc     A20EnableCount  ;  and remember that we did this
if DEBUG
        or      fA20,04h
endif
@@:
        pop     bx
rmrf70:
        pop     ax
rmrf75:

; Put the flags returned by the real mode interrupt routine back into
; the caller's stack so that they will be returned properly.

        push    bp              ;stack ->   BP  DS  ES  IP  CS  FL
        mov     bp,sp           ;           [0] [2] [4] [6] [8] [10]
        and     [bp+10],0300h   ;clear all but the interrupt and trace flags
                                ; in the caller's original flags
        or      [bp+10],ax      ;combine in the flags returned by the
                                ; interrupt service routine.  This will cause
                                ; us to return to the original routine with
                                ; interrupts on if they were on when the
                                ; interrupt occured, or if the ISR returned
                                ; with them on.
        pop     bp

; And return to the original interrupted program.

        mov     ax,regUserAX
        pop     ds
        pop     es
        iret

DXCODE  ends

WowIntr3216 proc

	FCLI
        push    ebp
        mov     ebp,esp
        mov     regUserAX,eax
        mov     regUserBX,ebx
        mov     regUserDS,ds
        mov     regUserES,es
        mov     regUserFlags,[ebp + 16]
        mov     ax,SEL_DXDATA OR STD_RING
        mov     ds,ax
        assume ds:dgroup
        mov     ebx,esp
        mov     regUserSp,eax
        mov     ax,ss
        mov     regUserSs,ax
        mov     bx,pbReflStack                  ; get pointer to new frame
        sub     bpReflStack,CB_STKFRAME

;
; put user stack pointer on new stack
;
        sub     bx,4
        mov     [bx],regUserSs
        sub     bx,4
        mov     [bx],dword ptr regUserSp

        mov     ax,[ebp + 4]

;
; switch to new stack
;

        push    ds
        pop     ss
        movzx   esp,bx

;
; Save ss:esp for lss esp
;
        push    regUserSs
        push    regUserSp
;
; Create an int frame
;
        pushf
        push    cs
        push    offset wi30

;
; Put handler address on stack
;

        shl     ax,3
        mov     es,selDgroupPM
        add     bx,offset DGROUP:Intr16Vector
        push    [bx + 2]
        push    [bx]

;
; Restore Registers
;
        mov     eax,regUserAx
        mov     ebx,regUserBX
        mov     es,regUserES
        mov     ds,regUserDS
        assume ds:nothing
;
; call handler
;
        retf

wi30:
;
; handler will return here
;

;
; Switch stacks
;
        mov     ebp,esp
        lss     esp,[ebp]
        mov     ebp,esp

        push    eax
        push    ds
        mov     ds,SEL_DXDATA OR STD_RING
        assume ds:DGROUP

;
; Deallocate stack frame
;
        add     pbReflStack,CB_STKFRAME
        pop     eax
        pop     ds

;
; Return flags from int handler
;
        pushf
        pop     [ebp + 16]

;
; Return to interrupted code
;
        pop     ebp
        riretd

WowIntr3216 endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\smartdrv.inc ===
; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;******************************************************************************
;
;   Title:	smartdrv.inc - smartdrv equates & structures
;
;   Version:	1.00
;
;   Date:	15-Sep-1989
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   15-Sep-1989 ARR Original
;
;==============================================================================

;
; Device name of SMARTDRV
;
SD_DEV_NAME	equ	"SMARTAAR",0

;
; SMARTDRV cache type (XMS or EMS) -- SD_IR_Driver_Type field
;

SD_CACHE_XMS	equ	1	    ; Cache is in XMS
SD_CACHE_EMS	equ	2	    ; Cache is in EMS

;
; Structure of the data returned on the SMARTDRV IOCTL read call
;
SD_IOCTL_Read	struc

    SD_IR_Write_Through   db	?   ; Write-through flag, currently always 1
    SD_IR_Write_Buff	  db	?   ; Buffer write flag, currently always 0
    SD_IR_Enable_Int13	  db	?   ; Cache enable flag, 1 = enabled
    SD_IR_Driver_Type	  db	?   ; Type 1 (XMS cache) or 2 (EMS cache)
    SD_IR_Tick_Setting	  dw	?   ; Ticks between flushes, currently unused
    SD_IR_Lock_Cache	  db	?   ; Non-zero if cache is locked
    SD_IR_Reboot_Flush	  db	?   ; Non-zero if cache should be flushed on reboot
    SD_IR_Cache_All	  db	?   ; Zero if full track writes are not cached
			  db	?   ; Unused
    SD_IR_Original_INT13  dd	?   ; INT 13 address SMARTDRV hooked
    SD_IR_Version	  dw	?   ; SMARTDrive version, packed BCD
			  dw	?   ; Unused
                    ; Next three values are used for computing
                    ; cache statistics.  They may be scaled rather
                    ; than absolute values
    SD_IR_Total_Sec_Read  dw	?   ; Count of sectors read
    SD_IR_Cache_Sec_Read  dw	?   ; Count of sectors read from cache
    SD_IR_Track_Sec_Read  dw	?   ; Count of sectors read from track buffer
                    ; Cache statistics
    SD_IR_Cache_Hit_Ratio db	?   ; = Cache_Sec_Read * 100 / Total_Sec_Read
    SD_IR_Track_Hit_Ratio db	?   ; = Track_Sec_Read * 100 / Total_Sec_Read

    SD_IR_Total_Tracks	  dw	?   ; Number of tracks in the cache
    SD_IR_Total_Used	  dw	?   ; Tracks currently in use
    SD_IR_Total_Locked	  dw	?   ; Tracks currently locked
    SD_IR_Total_Dirty	  dw	?   ; Tracks currently dirty
                    ; Information for resizing cache
                    ; All values are in terms of 16Kb pages.
    SD_IR_Current_Size	  dw	?   ; Current size of the cache, in 16Kb pages
    SD_IR_Dev_Size	  dw	?   ; Original size requested by user
    SD_IR_Min_Cache_Size  dw	?   ; Minimum allowable size

SD_IOCTL_Read	ends
;
; IOCTL Write functions
;   The function is encoded in the first byte of the IOCTL write data
;
SD_IOCTL_WR_Flush		equ	0	; Flush the cache
SD_IOCTL_WR_Flush_Invalidate	equ	1	; Flush the cache and discard it
SD_IOCTL_WR_Disable_Cache	equ	2	; Turn caching off
SD_IOCTL_WR_Enable_Cache	equ	3	; Turn caching on

SD_IOCTL_WR_Set_Tick		equ	5	; Set tick count for flush
SD_IOCTL_WR_Lock		equ	6	; Lock current cache contents
SD_IOCTL_WR_Unlock		equ	7	; Unlock current cache contents
SD_IOCTL_WR_Reboot_Flush	equ	8	; Set Reboot_Flush flag


SD_IOCTL_WR_Shrink_Cache	equ	11	; Reduce cache size
SD_IOCTL_WR_Grow_Cache		equ	12	; Increase cache size
SD_IOCTL_WR_Set_INT_13		equ	13	; Set the address SMARTDRV
						;   chains to on INT 13s
;
; Structures for the IOCTL write calls
;
;  These calls do not take any parameters so the correct write count is 1
;	(the function code byte)
;
;  WR_Flush
;  WR_Flush_Invalidate
;  WR_Disable_Cache
;  WR_Enable_Cache
;  WR_Set_Tick
;  WR_Lock
;  WR_Unlock
;
SD_IOCTL_WR_NoParm	struc

  SD_I_W_Func		db    ?

SD_IOCTL_WR_NoParm	ends
;
;  WR_Reboot_Flush
;
SD_IOCTL_WR_Reboot	struc

  SD_I_W_FuncR		db    SD_IOCTL_WR_Reboot_Flush
  SD_I_W_RebootFlg	db    ? 		; 0 to turn reboot flush off
						; 1 to turn reboot flush on
SD_IOCTL_WR_Reboot	ends
;
;  WR_Shrink_Cache
;  WR_Grow_Cache
;
SD_IOCTL_WR_GrwShrk	struc

  SD_I_W_FuncGS 	db    ? 		; Function, one of:
						;   SD_IOCTL_WR_Shrink_Cache
						;   SD_IOCTL_WR_Grow_Cache
  SD_I_W_GS_Size	dw    ? 		; Count of 16k "pages" to
						;   grow or shrink cache by
						;   THIS IS A SIZE DELTA
						;   not a total size.
SD_IOCTL_WR_GrwShrk	ends
;
;  WR_Set_INT_13
;
SD_IOCTL_WR_SetI13	struc

  SD_I_W_FuncS13	db    SD_IOCTL_WR_Set_INT_13

  SD_I_W_S13_Addr	dd    ? 		; Segment:Offset address
						;   to set Original_INT13 to.
						;   NO RECORD IS KEPT OF PREV
						;   VALUE, caller's responsible
						;   for save and restore.
SD_IOCTL_WR_SetI13	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\stackchk.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stackchk.inc
;
; Abstract:
;
;    This module implements stack checking for the dos extender
;
; Author:
;
;    Dave Hastings (daveh) 20-Apr-1993
;
;--

if DBG

FIX_STACK macro
        local foo,foo1
        push    bp
        mov     bp,pbReflStack
        cmp     bp,offset DGROUP:bReflStack
        ja      foo1

        BOP BOP_DBGBREAKPOINT

foo1:   mov     bp,sp
;        cmp     word ptr [bp - CB_STKFRAME + 2],0AAAAH
;        je      foo

;        BOP BOP_DBGBREAKPOINT

foo:    mov     word ptr [bp - CB_STKFRAME + 2],0AAAAH
        pop     bp
        endm

CHECK_STACK macro
        local foo
        push    bp
        mov     bp,pbReflStack
;        cmp     word ptr [bp + 2],0AAAAh
;        je      foo

;        BOP BOP_DBGBREAKPOINT

foo:    pop     bp
        endm

ifdef NEC_98

ASSERT_CLI macro
        endm

else

ASSERT_CLI macro
        local foo1

        push    ds
        push    40h
        pop     ds
        test    ds:[314h],0200h
        jz      foo1

        BOP BOP_DBGBREAKPOINT
foo1:   pop     ds
        endm

endif ;!NEC_98


ASSERT_REFLSTK_OK macro
        local   foo1
        cmp     pbReflStack,offset DGROUP:pbReflStack
        jna     foo1

        BOP BOP_DBGBREAKPOINT
foo1:
        endm
else
FIX_STACK macro
        endm

CHECK_STACK macro
        endm

ASSERT_CLI macro
        endm

ASSERT_REFLSTK_OK macro
        endm
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\woaswapi.inc ===
;----------------------------------------------------------------------------;
; Copyright (C) Microsoft Corporation 1985-1991. All Rights Reserved.	     ;
;----------------------------------------------------------------------------;
  
;----------------------------------------------------------------------------;
; This file has the equates for the switch api calls.			     ;
;									     ;
; History:								     ;
;									     ;
;        Thu Aug-23-1990.  	-by-  Amit Chatterjee [amitc]		     ;
;        Created for Switcher. (Added the History legend)    		     ;
;----------------------------------------------------------------------------;

;----------------------------------------------------------------------------;
; define constants for the switch API.					     ;
;----------------------------------------------------------------------------;

SWAPI_BUILD_CHAIN 	equ	4B01h	;INT 2F code for the Switch API
SWAPI_DETECT_SWITCHER	equ	4B02h	;call to detect presence of switcher
SWAPI_ALLOCATE_SW_ID	equ	4B03h	;allocates switcher ID (done by shell)
SWAPI_FREE_SW_ID	equ	4B04h	;frees switcher ID (done by shell)
SWAPI_GET_INST_DATA	equ	4B05h	;gets instance data
SWAPI_ALLOC_MEM_CALLIN	equ	4B06h	;allocate global memory	call in

SWAPI_ALLOC_MEM		equ	0001h	;allocate global memory


		;-----------------------------------------;
		; call out equates.			  ;
		;-----------------------------------------;

SWAPI_INIT_SWITCHER	equ	0	;switcher starts
SWAPI_QUERY_SUSPEND	equ	1	;Query_Suspend
SWAPI_SUSPEND		equ	2	;Suspend session
SWAPI_RESUME		equ	3	;Resume session
SWAPI_SESSION_ACTIVE	equ	4	;resume session now active
SWAPI_CREATE		equ	5	;Create session
SWAPI_Destroy		equ	6	;Destroy session
SWAPI_SWITCHER_EXIT	equ	7	;switcher exits

		;-----------------------------------------;
		; call in equates.			  ;
		;-----------------------------------------;

SWAPI_GETVERSION	equ	0	;GetVersion call in
SWAPI_TESTMEMORYREGION	equ	1	;TestMemoryRegion
SWAPI_SUSPEND_SWITCHER	equ	2	;SuspendSwitcher
SWAPI_RESUME_SWITCHER	equ	3	;ResumeSwitcher
SWAPI_HOOK_CALLOUT	equ	4	;Hook CallOut
SWAPI_UNHOOK_CALLOUT	equ	5	;UnHook CallOut
SWAPI_QUERY_API_SUPPORT	equ	6	;get network API support details


		;----------------------------------------;
		; Switch API call back info structure.   ;
		;----------------------------------------;

Switch_Call_Back_Info STRUC

SCBI_Next	dd	?		;pointer to next structure in list
SCBI_Entry_Pt	dd	?		;CS:IP of entry point procedure
SCBI_Reserved	dd	?		;used by the switcher
SCBI_API_Ptr	dd	?		;pinter to list of API structures

Switch_Call_Back_Info ENDS

		;----------------------------------------;
		; structure for API support details.     ;
		;----------------------------------------;

API_Info_Struc STRUC

AIS_Length	  dw	?		;length of the structure
AIS_API		  dw	?		;the API ID value
AIS_Major_Ver	  dw	?		;major version of API spec
AIS_Minor_Ver	  dw	?		;minor version of the API spec
AIS_Support_Level dw	?		;support level

API_Info_Struc ENDS

		;----------------------------------------;
		; currently defined API ID values.       ;
		;----------------------------------------;

API_NETBIOS	  equ	1		;Netbios
API_8022	  equ	2         	;802.2
API_TCPIP	  equ	3		;TCP/IP
API_LANMAN	  equ	4		;LAN Manager named pipes
API_IPX		  equ	5		;NetWare IPX

		 ;---------------------------------------;
		 ; currently defined support levels      ;
		 ;---------------------------------------;

API_SL_STOPALL	  equ	1		;stop all calls
API_SL_MINIMAL    equ	2		;stop asynchronous calls
API_SL_API	  equ	3		;API level support
API_SL_SW_COMPT	  equ	4		;switcher compatible
API_SL_SEAMLESS	  equ	5		;seamless support

		 ;---------------------------------------;
		 ; structure for return from get version ;
		 ;---------------------------------------;

Switcher_Ver_Struc STRUC

SVS_API_Major	  dw	?		;major version of the specs
SVS_API_Minor	  dw 	?		;minor version of the specs
SVS_Product_Major dw	?		;major version of the task switcher
SVS_Product_Minor dw	?		;minor version of the product
SVS_Switcher_ID	  dw	?		;ID of the switcher
SVS_Flags	  dw	?		;enabled/disabled
SVS_Name_Ptr	  dd	?		;long pointer to ID string
SVS_Prev_Switcher dd	?		;pointer to next switcher

Switcher_Ver_Struc ENDS

		;----------------------------------------;
	        ; constants used by the Switcher         ;
		;----------------------------------------;

OUR_API_MAJOR	  equ	1		;major ver of the specs
OUR_API_MINOR	  equ	0		;minor ver of the specs
OUR_PRODUCT_MAJOR equ   5		;major ver of the switcher
OUR_PRODUCT_MINOR equ   0		;minor ver of the switcher

OUR_NB_MAJOR_VER  equ	2		;major version of NetBios 
OUR_NB_MINOR_VER  equ   0		;minor version of NetBios
	
;----------------------------------------------------------------------------;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\wowmac.inc ===
; Copyright (c) Microsoft Corporation 1988-1991. All Rights Reserved.

;****************************************************************
;*                                                              *
;*      WOWMAC.INC      -  Macros to do wow specific stuff      *
;*                                                              *
;****************************************************************
;*                                                              *
;*  Module Description:                                         *
;*      This module contains macros to hide the 386 specific    *
;*      stuff in the dos extender.  In general, these macros    *
;*      expand to the original code for non-386, and special    *
;*      code for 386                                            *
;****************************************************************

;
; These two macros are used by the dos extender to hide the differences
; in building a dosx stack frame from a 32 bit frame and from a 16 bit frame
;
EnterInt macro
ifdef WOW_x86
        call [pfnEnterIntHandler]
else
        call EnterIntHandler
endif
        endm

LeaveInt macro
ifdef WOW_x86
        call [pfnLeaveIntHandler]
else
        call LeaveIntHandler
endif
        endm

;
; These two macros are used to hide the difference in the int stack frame
; as used by the routines which switch to real mode to call int routines.
;

pushaw macro
ifdef WOW_x86
.386p
        pushad
.286p
else
        pusha
endif
        endm

popaw macro
ifdef WOW_x86
.386p
        popad
.286p
else
        popa
endif
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\br\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS detectou um erro de incompatibilidade de CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS detectou um conflito com outro software ',13,10
                db      '  no modo protegido.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS encontrou um erro ao inicializar o ',13,10
                db      '  gerenciador de memria estendida.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS encontrou um erro no-especfico.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  No h memria convencional suficiente.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  No h memria estendida suficiente.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  No  possvel executar este aplicativo no modo;',13,10
                db      '  protegido de 16 bits.',13,10,13,10
                db      '  O extensor do DOS no pde encontrar os arquivos de',13,10
                db      '  sistema necessrios.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  No  possvel executar no modo padro devido a um',13,10,13,10
                db      '  problema de gerenciamento de memria.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Um driver de dispositivo ou um programa residente na memria'
                db      13,10
                db      '            solicitou que no se carregue agora o Windows no modo padro.'
                db      13,10
                db      '            Remova este programa ou obtenha uma verso mais atualizada'
                db      13,10
                db      '            compatvel com o modo padro do Windows.'
                db      13,10
                db      13,10
                db      '            Pressione "s" para carregar o Windows no modo padro.'
                db      13,10
                db      13,10
                db      '            Pressione qualquer outra tecla para voltar ao DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  Extensor do DOS: Exceo de modo protegido no-capturada.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  Extensor do DOS: Erro interno.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\chs\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\cs\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS detekoval neshodn procesory (CPU).',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS detekoval konflikt s dalm softwarem ',13,10
                db      '  pro chrnn reim.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS narazil na chybu pi inicializaci sprvce ',13,10
                db      '  rozen pamti.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS narazil na nespecifikovanou chybu.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Nen dostatek konvenn pamti.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Nen dostatek rozen pamti.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Tuto aplikaci pro 16-bitov chrnn reim nelze spustit;',13,10,13,10
                db      '  Rozen systm DOS nenalezl potebn systmov soubory.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Nebylo mon spustit ve standardnm reimu: Problm sprvce pamti.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Ovlada zazen i program TSR vyaduje, aby se systm Windows'
                db      13,10
                db      '            ve standardnm reimu nespustil nyn. Bu tento program odstrate,'
                db      13,10
                db      '            nebo si od dodavatele vydejte aktualizaci kompatibiln'
                db      13,10
                db      '            se standardnm reimem systmu Windows.'
                db      13,10
                db      13,10
                db      '            Stiskem "y" mete spustit Windows ve standardnm reimu.'
                db      13,10
                db      13,10
                db      '            Jakoukoliv jinou klvesou se vrtte do systmu DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  Rozen DOS: Nezachycen vyjmka chrnnho reimu.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  Rozen DOS: Intern chyba.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\chp\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\cht\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\es\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10                
		db      '  El DOS extendido ha detectado un conflicto de la CPU.',13,10
                                    db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  El DOS extendido ha detectado un conflicto con otro programa ',13,10
		db      '  en modo protegido.',13,10
		db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  El DOS extendido ha encontrado un error al inicializar el ',13,10
		db      '  administrador de memoria extendida.',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  El DOS extendido ha encontrado un error no especificado.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  Memoria convencional insuficiente.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  Memoria extendida insuficiente.',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  No se puede ejecutar esta aplicacin de 16 bits en modo protegido;',13,10,13,10
		db      '  El DOS extendido no ha podido encontrar los archivos de sistema necesarios.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  No se puede utilizar el Modo estndar debido a un problema de gestin de memoria.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            Un controlador de dispositivo o un programa residente en memoria'
		db      13,10
		db      '            ha solicitado que no se cargue Windows en Modo estndar. Quite'
		db      13,10
		db      '            este programa o consiga una versin actualizada que sea compatible'
		db      13,10
		db      '            con Windows en Modo estndar.'
		db      13,10
		db      13,10
		db      '            Presione "s" para cargar Windows en Modo estndar de todas formas.'
		db      13,10
		db      13,10
		db      '            Presione cualquier otra tecla para volver a DOS.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS extendido: excepcin en modo protegido no capturada.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS Extender: error interno.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\el\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  夘   ⢜  16-bit   ⤞ ',13,10,13,10
                db      '  暨 ⡫  DOS 槠  CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  夘   ⢜  16-bit   ⤞ ',13,10,13,10
                db      '  暨 ⡫  DOS 槠  ⤜  ᢢ  ',13,10
                db      ' ⤞ 嘪.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  夘   ⢜  16-bit   ⤞ ',13,10,13,10
                db      '  暨 ⡫  DOS 駠 ⤘ ᢣ    ',13,10
                db      '  娠  㣞 extended.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  夘   ⢜  16-bit   ⤞ ',13,10,13,10
                db      '  暨 ⡫  DOS 駠 ⤘ ⤦ ᢣ.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  夘  ⢜  16-bit   ⤞ ',13,10,13,10
                db      '  ᨮ   㣞.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  夘  ⢜  16-bit   ⤞ ',13,10,13,10
                db      '  ᨮ  㣞 extended.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  夘   ⢜  16-bit   ⤞ ',13,10,13,10
                db      '  暨 ⡫  DOS        㣘',13,10
                db      '  ov   ⢜.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  夘   ⢜   ᩫ 嘪 .',13,10
                db      '  㣘  娠 㣞.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            뤘 暨 㚞   TSR ᝜ ',13,10
                db      '             ᩫ 嘪'
                db      13,10
                db      '             Windows     騘.  㩫 ,'
                db      13,10
                db      '             暨  嫜  ⤞ ⡛   '
                db      13,10
                db      '            夘     ᩫ 嘪  Windows.'
                db      13,10
                db      13,10
                db      '            㩫 "y"      ᩫ 嘪.'
                db      13,10
                db      13,10
                db      '            ⩫ 㧦 ᢢ 㡫   嫜  DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  暨 ⡫  DOS:  棜 娜',13,10
                db      '  ⤞ ᩫ 嘪.',13,10,'$'
                                                                  
        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  暨 ⡫  DOS: ᩫ ૜ ᢣ.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\da\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  Dette 16-bit program i beskyttet tilstand kan ikke kres.',13,10,13,10
		db      '  DOS extender har genkendt en forkert CPU-version.',13,10
		db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  Dette 16-bit program i beskyttet tilstand kan ikke kres.',13,10,13,10
		db      '  DOS extender har fundet en konflikt med anden software til.',13,10
		db      '  at kre beskyttet tilstand.',13,10
		db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  Dette 16-bit program i beskyttet tilstand kan ikke kres.',13,10,13,10
		db      '  DOS extender har fundet en fejl under initialiseringen af den udvidede',13,10
		db      '  hukommelsesstyring (HIMEM).',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  Dette 16-bit program i beskyttet tilstand kan ikke kres.',13,10,13,10
		db      '  DOS extender har fundet en uspecificeret fejl.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  Dette 16-bit program i beskyttet tilstand kan ikke kres.',13,10,13,10
		db      '  Der er ikke nok konventionel hukommelse.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  Dette 16-bit program i beskyttet tilstand kan ikke kres.',13,10,13,10
		db      '  Der er ikke nok udvidet hukommelse (XMS).',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  Dette 16-bit program i beskyttet tilstand kan ikke kres.',13,10,13,10
		db      '  DOS extender kunne ikke finde de ndvendige systemfiler.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  Der kan ikke kres i standardtilstand p grund af hukommelsesstyringsproblemer.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            En enhedsdriver eller TSR kan ikke indlse Windows i standard'
		db      13,10
		db      '            tilstand. Fjern programmet, eller indls en opdateret version.'
		db      13,10
		db      '            Opdateringen skal vre kompatibel med'
		db      13,10
                db      '            Windows i standard tilstand'
		db      13,10
		db      13,10
		db      '            Tryk p "j" for alligevel at indlse Windows i standard tilstand.'
		db      13,10
                db      13,10
		db      '            Tryk p enhver anden tast for at afbryde og g til DOS.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS extender: Fejl i beskyttet-tilstand.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverble.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS extender: Intern fejl.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\fi\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db	'  Suojatun tilan 16-bittist sovellusta ei voi kynnist.',13,10,13,10
		db	'  DOS-laajennin havaitsi yhteensopimattoman keskusyksikn.',13,10
		db	13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db	'  Suojatun tilan 16-bittist sovellusta ei voi kynnist.',13,10,13,10
		db	'  DOS-laajennin havaitsi ristiriidan toisen suojattua tilaa kyttvn ',13,10
		db	'  sovelluksen kanssa.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM	db	13,10
		db	'  Suojatun tilan 16-bittist sovellusta ei voi kynnist.',13,10,13,10
		db	'  DOS-laajennin havaitsi virheen alustaessaan laajennetun ',13,10
		db	'  muistin muistinhallintaohjelmaa.',13,10
		db	13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db	'  Suojatun tilan 16-bittist sovellusta ei voi kynnist.',13,10,13,10
		db	'  DOS-laajennin kohtasi mrittmttmn virheen.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db	'  Suojatun tilan 16-bittist sovellusta ei voi kynnist.',13,10,13,10
		db	'  Perusmuistia ei ole riittvsti.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db	'  Suojatun tilan 16-bittist sovellusta ei voi kynnist.',13,10,13,10
		db	'  Laajennettua muistia ei ole riittvsti.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db	'  Suojatun tilan 16-bittist sovellusta ei voi kynnist.',13,10,13,10
		db	'  DOS-laajennin ei lytnyt tarvittavia jrjestelmtiedostoja.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  Windowsia ei voi kynnist vakiotilassa muistinhallintavirheen takia.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            Laiteohjain tai muistinvarainen ohjelma (TSR) est Windowsin'
		db      13,10
		db      '            kynnistmisen vakiotilassa.  Poista tm ohjelma tai pyyd'
		db      13,10
		db      '            jlleenmyyjlt pivitetty versio, joka on yhteensopiva'
		db      13,10
		db      '            Windowsin vakiotilan kanssa.'
		db      13,10
		db      13,10
		db      '            Kynnist Windows vakiotilassa valitsemalla "k".'
		db      13,10
		db      13,10
		db      '            Palaa DOS:iin valitsemalla jokin muu nppin.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db	'  DOS-laajennin: Tuntematon suojatun tilan poikkeus.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db	'  DOS-laajennin: Sisinen virhe.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\jpn\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\kor\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\ger\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es wurde eine CPU-Unvertrglichkeit entdeckt.',13,10
		db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es ist ein Konflikt mit anderer im geschtzten Modus ',13,10
		db      '  ausgefhrten Software aufgetreten.',13,10
		db      13,10,'$'

;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Bei der Initialisierung des Erweiterungsspeichers ist',13,10
		db      '  ein Fehler aufgetreten.',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es ist ein nicht zu bestimmender Fehler aufgetreten.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es steht nicht gengend konventioneller Arbeitsspeicher ',13,10
		db      '  zur Verfgung.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Es steht nicht gengend Erweiterungsspeicher ',13,10
		db      '  zur Verfgung.',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  Diese 16-Bit-Anwendung fr den geschtzten Modus',13,10
		db      '  kann nicht ausgefhrt werden.',13,10,13,10
		db      '  Bentigte Systemdateien konnten nicht gefunden werden.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  Wegen eines Speichermanager-Problems kann der Standard-Modus ',13,10,13,10
		db      '  nicht verwendet werden.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            Ein Gertetreiber oder TSR hat verlangt, dass Windows'
		db      13,10
		db      '            jetzt nicht im Standard-Modus gestartet wird.'
		db      13,10
		db      '            Entfernen Sie dieses Programm, oder verlangen Sie'
		db      13,10
		db      '            von Ihrem Hersteller ein Programm, das mit '
		db      13,10
		db      '            Windows im Standard-Modus kompatibel ist.'
		db      13,10
		db      13,10
		db      '            Drcken Sie die Y-TASTE, um Windows dennoch'
		db      '            im Standard-Modus zu starten.'
		db      13,10
		db      13,10
		db      '            Drcken Sie eine andere Taste, um abzubrechen und '
		db      '            zu DOS zu gelangen.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS Extender: Nicht behebbare Ausnahme im geschtzten Modus.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS Extender: Interner Fehler.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\fr\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS a dtect une UC qui ne correspond pas.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS a dtect un conflit avec un autre logiciel',13,10
                db      '  en mode protg.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS a rencontr une erreur',13,10
                db      '  d''initialisation dans le gestionnaire de mmoire tendue.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS a rencontr une erreur non-spcifique.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  Il n''y a pas suffisamment de mmoire conventionnelle.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  Il n''y a pas suffisamment de mmoire tendue.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Impossible d''excuter cette application 16-bit en mode protg;',13,10,13,10
                db      '  L''unit d''extension DOS n''a pas pu trouver les fichiers systme',13,10,13,10
                db      '  ncessaires  son excution.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Une erreur du gest. de mmoire empche l''excution en mode standard.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Un pilote de priphrique ou un TSR a demand que le mode standard'
                db      13,10
                db      '            de Windows ne soit pas charg maintenant. Supprimez ce programme, ou'
                db      13,10
                db      '            procurez vous une mise  jour compatible avec le mode standard de'
                db      13,10
                db      '            Windows auprs de votre fournisseur.'
                db      13,10
                db      13,10
                db      '            Appuyez sur "o" pour charger quand mme le mode standard de Windows.'
                db      13,10
                db      13,10
                db      '            Appuyez sur n''importe quelle autre touche pour sortir du DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  Unit d''extension DOS: Exception en mode protg non capture.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  Unit d''extension DOS: Erreur interne.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\psu\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\hu\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  A DOS vdett md bvtje CPU hibt szlelt.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  Az alkalmazs tkzik egy msik vdett md  ',13,10
                db      '  programmal.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  A DOS vdett md bvt nem tudta alaphelyzetbe hozni a ',13,10
                db      '  kiterjesztettmemria-kezelt.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  A DOS vdett md bvt meghatrozatlan hibt szlelt.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  Nincs elegend hagyomnyos memria.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  Nincs elegend kiterjesztett memria.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Ez a 16 bites vdett md alkalmazs nem futtathat;',13,10,13,10
                db      '  DOS vdett md bvt nem tallja a futtatshoz szksges rendszerfjlokat.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  A memriakezel hibja miatt a programot nem lehet Standard zemmdban futtatni.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Az illesztprogram vagy TSR nem engedi, hogy a Windows '
                db      13,10
                db      '            standard zemmdban tltdjn be. Tvoltsa el a programot, vagy '
                db      13,10
                db      '            szerezze be egy jabb vltozatt, amely kompatbilis a '
                db      13,10
                db      '            Windows standard zemmdjval.'
                db      13,10
                db      13,10
                db      '            Az "y" billentyt letve a Windows standard mdban indul.'
                db      13,10
                db      13,10
                db      '            Brmely ms billentyt letve visszajut a DOS-hoz.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS vdett md bvt: nem kezelt vdett md kivtel.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      ' DOS vdett md bvt: bels hiba.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\it\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender ha rilevato un''incompatibilit della CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender ha rilevato un conflitto con altro software ',13,10
                db      '  in modalit protetta.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender ha rilevato un errore durante l''inizializzazione',13,10
                db      '  del gestore di memoria estesa.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender ha rilevato un errore non specifico.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  Memoria convenzionale insufficiente.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  Memoria estesa insufficiente.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Impossibile eseguire questa applicazione in modalit protetta 16 bit.',13,10,13,10
                db      '  DOS extender non ha trovato i file di sistema necessari',13,10
                db      '  per l''esecuzione.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Impossibile eseguire in modalit Standard per un problema di gestione memoria.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Un driver o TSR di periferica ha impedito il caricamento'
                db      13,10
                db      '            di Windows in questa modalit standard.  Rimuovere questo'
                db      13,10
                db      '            programma, o richiedere un aggiornamento che sia compatibile'
                db      13,10
                db      '            con Windows in modalit standard.'
                db      13,10
                db      13,10
                db      '            Premere "s" per caricare ugualmente Windows in modalit standard.'
                db      13,10
                db      13,10
                db      '            Premere un altro tasto per ritornare a DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS extender: exception senza trap in modalit protetta.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS extender: errore interno.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\nl\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Verkeerd type CPU.',13,10
		db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is een conflict met andere software die in protected-modus ',13,10
		db      '  wordt uitgevoerd.',13,10
		db	13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is een fout opgetreden bij het initialiseren van de ',13,10
		db      '  Extended Memory Manager (XMS-stuurprogramma).',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is een algemene fout opgetreden.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is onvoldoende conventioneel geheugen beschikbaar.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  Er is onvoldoende extended memory beschikbaar.',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  Kan deze 16-bits protected-modus toepassing niet starten.',13,10,13,10
		db      '  De voor het starten benodigde systeembestanden zijn niet gevonden.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  Kan niet in de standaardmodus starten vanwege een probleem met ',13,10
		db      '  het geheugenbeheerprogramma.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            Een stuurprogramma of TSR heeft opdracht gegeven dat Windows'
		db      13,10
		db      '            nu niet in de standaardmodus kan worden geladen. Verwijder dit'
		db      13,10
		db      '            programma of gebruik een bijgewerkte versie van de fabrikant'
		db      13,10
		db      '            die compatibel is met Windows in standaardmodus.'
		db      13,10
		db      13,10
		db      '            Druk op "j" als u Windows toch in de standaardmodus wilt laden.'
		db      13,10
		db      13,10
		db      '            Druk op een willekeurige toets als u DOS wilt afsluiten.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS Extender: niet-afgevangen uitzondering van protected-modus.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS Extender: interne fout.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\no\dxmsg.asm ===
PAGE	,132
	TITLE	DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;	DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public	ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public	ER_EXTMEM, ER_NOEXE

if	VCPI
	public ER_VCPI, ER_QEMM386
endif	;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE	db	13,10
		db	'  Kan ikke kjre dette 16-bits programmet for beskyttet modus.',13,10,13,10
		db	'  DOS har oppdaget en CPU-uoverensstemmelse.',13,10
		db	13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE	db	13,10
		db	'  Kan ikke kjre dette 16-bits programmet for beskyttet modus.',13,10,13,10
		db	'  DOS har oppdaget en konflikt med andre programmer for',13,10
		db	'  beskyttet modus.',13,10
		db	13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM	db	13,10
		db	'  Kan ikke kjre dette 16-bits programmet for beskyttet modus.',13,10,13,10
		db	'  DOS har oppdaget en feil under initialisering av styreprogrammet',13,10
		db	'  for tilleggsminne.',13,10
		db	13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT	db	13,10
		db	'  Kan ikke kjre dette 16-bits programmet for beskyttet modus.',13,10,13,10
		db	'  DOS har oppdaget en generell feil.'
		db	13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM	db	13,10
		db	'  Kan ikke kjre dette 16-bits programmet for beskyttet modus.',13,10,13,10
		db	'  Ikke nok konvensjonelt minne.',13,10,13,10
		db	13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM	db	13,10
		db	'  Kan ikke kjre dette 16-bits programmet for beskyttet modus.',13,10,13,10
		db	'  Ikke nok utvidet minne.',13,10,13,10
		db	13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE	db	13,10
		db	'  Kan ikke kjre dette 16-bits programmet for beskyttet modus.',13,10,13,10
		db	'  DOS kan ikke finne de ndvendige systemfilene.',13,10,13,10
		db	13,10,'$'

if	VCPI
;
; VCPI initialization failed.
;
ER_VCPI 	db	13,10
		db	'  Kan ikke kjre i standardmodus pga. problemer med minnebehandling.'
		db	13,10,'$'
endif	;VCPI

if	VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            En enhetsdriver eller TSR forhindrer at Windows lastes'
		db      13,10
		db      '            i standardmodus n. Fjern dette programmet, eller skaff'
		db      13,10
		db      '            en oppdatert versjon som er kompatibel med Windows i'
		db      13,10
		db      '            standardmodus.'
		db      13,10
		db      13,10
		db      '            Trykk "j" for  laste Windows i standardmodus.'
		db      13,10
		db      13,10
		db      '            Trykk en annen tast for  avslutte til DOS'
		db      13,10,'$'
endif	;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public	szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage	db	13,10
		db	'  DOS-utvider: Uoppfanget unntak for beskyttet modus.',13,10,'$'

	public	szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage	db	13,10
		db	'  DOS-utvider: Intern feil.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\pl\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS wykry niezgodno procesora.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS wykry konflikt z innym oprogramowaniem  ',13,10
                db      '  trybu chronionego.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS napotka bd podczas inicjowania menedera ',13,10
                db      '  pamici rozszerzonej typu extended.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS napotka nieokrelony bd.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Za mao pamici konwencjonalnej.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Za mao pamici rozszerzonej typu extended.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Nie mona uruchomi tej 16-bitowej aplikacji trybu chronionego;',13,10,13,10
                db      '  Extender DOS nie znalaz niezbdnych plikw systemowych.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      ' Nie mona uruchomi w trybie standardowym z powodu problemu'
                db      13,10
                db      ' z menederem pamici.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Sterownik urzdzenia lub program TSR zabroni zaadowania trybu'
                db      13,10
                db      '            standardowego Windows. Usu ten program lub uzyskaj uaktualnienie'
                db      13,10
                db      '            zgodne z trybem standardowym systemu Windows od producenta tego'
                db      13,10
                db      '            programu.'
                db      13,10
                db      13,10
                db      '            Nacinij "t", aby mimo wszystko zaadowa tryb standardowy Windows.'
                db      13,10
                db      13,10
                db      '            Nacinij dowolny inny klawisz, aby wyj do systemu DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Nieznany wyjtek trybu chronionego.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Bd wewntrzny.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\nec_98\dxmsg.asm ===
include    jpn\dxmsg.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\tst\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\usa\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a CPU mismatch.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has detected a conflict with other protect ',13,10
                db      '  mode software.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender has encountered an error initializing the extended ',13,10
                db      '  memory manager.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender encounted a non-specific error.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient conventional memory.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  There is insufficient extended memory.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Cannot run this 16-bit protected mode application;',13,10,13,10
                db      '  The DOS extender could not find system files needed to run.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Unable to run in Standard Mode because of a memory manager problem.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            A device driver or TSR has requested that Standard Mode'
                db      13,10
                db      '            Windows not load now.  Either remove this program, or'
                db      13,10
                db      '            obtain an update from your supplier that is compatible'
                db      13,10
                db      '            with Standard Mode Windows.'
                db      13,10
                db      13,10
                db      '            Press "y" to load Standard Mode Windows anyway.'
                db      13,10
                db      13,10
                db      '            Press any other key to exit to DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Extender: Untrapped protected-mode exception.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Extender: Internal error.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\ru\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS 㦥  ᮮ⢥騩 ⨯ CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS 㦥 䫨  㣨 ணࠬ ',13,10
                db      '  ᯥ祭, ࠡ饬  饭 ०.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS 㦨 訡  樠樨',13,10
                db      '  ᯥ ⥫쭮  (XMS).',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS 㦨  訡.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '   ꥬ 筮 .',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '   ꥬ ⥫쭮  (XMS).',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '     16-ࠧ來 ਫ  饭 ०;',13,10,13,10
                db      '  ७ DOS  㦨 室  ᪠ ⥬ 䠩.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '    ⠭ ० - 訡 ᯥ .'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            ࠩ ன⢠  १⭠ ணࠬ (TSR) ॡ,'
                db      13,10
                db      '            ⮡ ⠭ ० Windows ᥩ  㦠.'
                db      13,10
                db      '              ணࠬ     ᮢ⨬'
                db      13,10
                db      '             ⠭ ० Windows.'
                db      13,10
                db      13,10
                db      '              "Y", ⮡  ࠢ 㧨'
                db      13,10
                db      '            ⠭ ० Windows.'
                db      13,10
                db      '               , ⮡   DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  ७ DOS:  訡 饭 ०.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  ७ DOS: ७ 訡.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\pt\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS detectou uma discordncia de CPU.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS detectou um coflito com outro software ',13,10
                db      '  de modo protegido.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS encontrou um erro ao inicializar o gestor de ',13,10
                db      '  memria de extenso.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS encontrou um erro no especificado.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  A memria convencional  insuficiente.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  A memria de extenso  insuficiente.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Impossvel executar esta aplicao de modo protegido de 16-bits;',13,10,13,10
                db      '  O expansor de DOS no encontrou ficheiros de sistema necessrios.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Impossvel executar em modo padro dado um problema no gestor de memria.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Um controlador de dispositivo ou TSR exigiu que o Windows em modo'
                db      13,10
                db      '            padro no fosse agora carregado. Remova este programa ou'
                db      13,10
                db      '            obtenha uma actualizao que seja compatvel com o Windows em'
                db      13,10
                db      '            modo padro.'
                db      13,10
                db      13,10
                db      '            Prima "s" para carregar o Windows em modo padro de qq. forma.'
                db      13,10
                db      13,10
                db      '            Prima qq. outra tecla para sair para DOS.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  Expansor de DOS: excepo de modo protegido no capturada.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  Expansor de DOS: erro interno.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\sv\dxmsg.asm ===
PAGE    ,132
	TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

	.286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

	.xlist
	.sall
include     segdefs.inc
include     gendefs.inc
	.list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

	public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
	public  ER_EXTMEM, ER_NOEXE

if      VCPI
	public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge;',13,10,13,10
		db      '  DOS-utkaren upptckte en avvikelse i CPU:n.',13,10
		db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge;',13,10,13,10
		db      '  DOS-utkaren har upptckt en konflikt med andra programvaror',13,10
		db      '  i skyddat lge.',13,10
		db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge;',13,10,13,10
		db      '  Det uppstod ett fel med DOS-utkaren vid initiering av',13,10
		db      '  utkad minneshanteraren.',13,10
		db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge:',13,10,13,10
		db      '  Det uppstod ett ospecificerat fel med DOS-utkaren.'
		db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge:',13,10,13,10
		db      '  Det finns inte tillrckligt med konventionellt minne.',13,10,13,10
		db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge:',13,10,13,10
		db      '  Det finns inte tillrckligt med utkat minne.',13,10,13,10
		db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
		db      '  Det gr inte att kra detta 16-bitars program i skyddat lge:',13,10,13,10
		db      '  DOS-utkaren kunde inte hitta systemfilerna som behvs fr att kra.',13,10,13,10
		db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
		db      '  Det gr inte att kra i standardlge pga problem med minneshanteraren.'
		db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
		db      '            En drivrutin eller TSR har efterfrgat standardlge, vilket Windows'
		db      13,10
		db      '            fr tillfllet inte kr. Ta bort programmet eller'
		db      13,10
		db      '            anskaffa en uppdatering som r kompatibel med Windows'
		db      13,10
		db      '            standardlge frn din leverantr.'
		db      13,10
		db      13,10
		db      '            Tryck p "j" fr att lsa in standardlge.'
		db      13,10
		db      13,10
		db      '            Tryck p valfri annan tangent fr att avsluta DOS.'
		db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
	public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
		db      '  DOS-utkare: Undantagsfall, skyddat lge.',13,10,'$'

	public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
		db      '  DOS-utkare: Internt fel.',13,10,'$'

DXPMCODE ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\debug.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains debugging routines for dpmi.

Revision History:

    Neil Sandlin (neilsa) Nov. 1, 95 - wrote it

--*/

#include "precomp.h"
#pragma hdrstop
#include "softpc.h"


#if DBG

#define MAX_TRACE_ENTRIES 100

DPMI_TRACE_ENTRY DpmiTraceTable[MAX_TRACE_ENTRIES];

const int DpmiMaxTraceEntries = MAX_TRACE_ENTRIES;
int DpmiTraceIndex = 0;
int DpmiTraceCount = 0;
BOOL bDpmiTraceOn = TRUE;

VOID
DpmiDbgTrace(
    int Type,
    ULONG v1,
    ULONG v2,
    ULONG v3
    )

{
    if (!bDpmiTraceOn) {
        return;
    }

    DpmiTraceTable[DpmiTraceIndex].Type = Type;
    DpmiTraceTable[DpmiTraceIndex].v1 = v1;
    DpmiTraceTable[DpmiTraceIndex].v2 = v2;
    DpmiTraceTable[DpmiTraceIndex].v3 = v3;

    DpmiTraceTable[DpmiTraceIndex].eax = getEAX();
    DpmiTraceTable[DpmiTraceIndex].ebx = getEBX();
    DpmiTraceTable[DpmiTraceIndex].ecx = getECX();
    DpmiTraceTable[DpmiTraceIndex].edx = getEDX();
    DpmiTraceTable[DpmiTraceIndex].esi = getESI();
    DpmiTraceTable[DpmiTraceIndex].edi = getEDI();
    DpmiTraceTable[DpmiTraceIndex].ebp = getEBP();
    DpmiTraceTable[DpmiTraceIndex].esp = getESP();
    DpmiTraceTable[DpmiTraceIndex].eip = getEIP();
    DpmiTraceTable[DpmiTraceIndex].eflags = getEFLAGS();

    DpmiTraceTable[DpmiTraceIndex].cs = getCS();
    DpmiTraceTable[DpmiTraceIndex].ds = getDS();
    DpmiTraceTable[DpmiTraceIndex].es = getES();
    DpmiTraceTable[DpmiTraceIndex].fs = getFS();
    DpmiTraceTable[DpmiTraceIndex].gs = getGS();
    DpmiTraceTable[DpmiTraceIndex].ss = getSS();


    DpmiTraceIndex++;
    if (DpmiTraceIndex >= MAX_TRACE_ENTRIES) {
        DpmiTraceIndex = 0;
    }
    if (DpmiTraceCount < MAX_TRACE_ENTRIES) {
        DpmiTraceCount++;
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi\tr\dxmsg.asm ===
PAGE    ,132
        TITLE   DXMSG.ASM  -- Dos Extender Text Messages

; Copyright (c) Microsoft Corporation 1989-1991. All Rights Reserved.

;***********************************************************************
;
;       DXMSG.ASM      -- Dos Extender Text Messages
;
;-----------------------------------------------------------------------
;
; This module contains the text messages displayed by the 80286 DOS
; Extender.  The messages are contained in this file to ease their
; conversion to other languages.
;
;-----------------------------------------------------------------------
;
;  12/06/89 jimmat  Update message text as per User Ed
;  08/03/89 jimmat  Original version
;
;***********************************************************************

        .286p

; -------------------------------------------------------
;           INCLUDE FILE DEFINITIONS
; -------------------------------------------------------

        .xlist
        .sall
include     segdefs.inc
include     gendefs.inc
        .list

; -------------------------------------------------------
;           CODE SEGMENT VARIABLES
; -------------------------------------------------------

DXCODE  segment

; Note: these DXCODE segment messages are all linked after the CodeEnd
; variable, so they will be discarded after initialization.

        public  ER_CPUTYPE, ER_PROTMODE, ER_NOHIMEM, ER_DXINIT, ER_REALMEM
        public  ER_EXTMEM, ER_NOEXE

if      VCPI
        public ER_VCPI, ER_QEMM386
endif   ;VCPI
;
; Wrong CPU type.
;
ER_CPUTYPE      db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      ' DOS uzatcs bir CPU uyumazl alglad.',13,10
                db      13,10,'$'
;
; Can't figure out how to get into protected mode.
;
ER_PROTMODE     db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      ' DOS uzatcs dier korumal yazlmla ',13,10
                db      ' bir akma alglad.',13,10
                db      13,10,'$'
;
; Couldn't initialize XMS driver.
;
ER_NOHIMEM      db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      ' DOS uzatcs uzatlm bellek yneticisini balatrken bir',13,10
                db      '  hatayla karlat.',13,10
                db      13,10,'$'
;
; Non-specific unable to initialize DOSX error.
;
ER_DXINIT       db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      '  DOS uzatcs belirli olmayan bir hatayla karlat.'
                db      13,10,'$'
;
; A DOS memory allocation failed.
;
ER_REALMEM      db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      '  Yeterli geleneksel bellek yok.',13,10,13,10
                db      13,10,'$'
;
; Couldn't get enough extended memory to run.
;
ER_EXTMEM       db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      '  Yeterli uzatlm bellek yok.',13,10,13,10
                db      13,10,'$'
;
; Where is KRNL[23]86.EXE!!!
;
ER_NOEXE        db      13,10
                db      '  Bu 16-bit korumal kip uygulamas altrlamyor;',13,10,13,10
                db      '  DOS uzatcs altrmak iin gerekli sistem dosyalarn bulamad.',13,10,13,10
                db      13,10,'$'

if      VCPI
;
; VCPI initialization failed.
;
ER_VCPI         db      13,10
                db      '  Bellek yneticisi sorunu nedeniyle Standart Kip''te altrlamyor.'
                db      13,10,'$'
endif   ;VCPI

if      VCPI
;
; This message is displayed if someone fails the Windows INT 2Fh startup
; broadcast.  All of the "Windows 3.0 compatible" 3rd party memory managers
; do this.
;
ER_QEMM386      db      13,10
                db      '            Bir aygt srcs veya TSR imdi Standart Kipte'
                db      13,10
                db      '            Windows yklenmemesini istedi.  Bu program kaldrn veya'
                db      13,10
                db      '            salaycnzdan Standart Kip Windows ile uyumlu bir'
                db      13,10
                db      '            gncelletirme edinin.'
                db      13,10
                db      13,10
                db      '            Yine de Standart Kip Windows''u yklemek iin "e"ye basn.'
                db      13,10
                db      13,10
                db      '            DOS''a dnmek iin herhangi bir tua basn.'
                db      13,10,'$'
endif   ;VCPI

DXCODE  ends

DXPMCODE segment
;
; Both of the next two messages probably mean a serious crash in Windows.
;
        public  szFaultMessage
;
; Displayed if a protected mode fault is caught by DOSX.
;
szFaultMessage  db      13,10
                db      '  DOS Uzatcs: Yakalanmam korumal kip zel durumu.',13,10,'$'

        public  szRing0FaultMessage
;
; Fault in the DOSX internal fault handler.  Not recoverable.
;
; Note:  This is for a real bad one.
;
szRing0FaultMessage     db      13,10
                db      '  DOS Uzatcs:  hata.',13,10,'$'

DXPMCODE ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\buffer.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Buffer.c

Abstract:

    This module contains routines to perform the actual buffering of data
    for dpmi api translation support.

Author:

    Dave Hastings (daveh) 30-Nov-1992

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"

PUCHAR
DpmiMapAndCopyBuffer(
    PUCHAR Buffer,
    USHORT BufferLength
    )
/*++

Routine Description:

    This routine selects the appropriate buffer for the translation,
    and copies the high memory buffer to it.

Arguments:

    Buffer -- Supplies buffer in high memory
    BufferLength -- Supplies the length of the buffer

Return Value:

    Returns a pointer to the translation buffer

--*/
{
    PUCHAR NewBuffer;

    //
    // if the buffer is already in low memory, don't do anything
    //

    if ((ULONG)(Buffer + BufferLength - IntelBase) < MAX_V86_ADDRESS) {
        return Buffer;
    }

    NewBuffer = DpmiAllocateBuffer(BufferLength);

    CopyMemory(NewBuffer, Buffer, BufferLength);

    return NewBuffer;
}

VOID
DpmiUnmapAndCopyBuffer(
    PUCHAR Destination,
    PUCHAR Source,
    USHORT BufferLength
    )
/*++

Routine Description:

    This routine copies the information back to the high memory buffer

Arguments:

    Destination -- Supplies the destination buffer
    Source -- Supplies the source buffer
    BufferLength -- Supplies the length of the information to copy

Return Value:

    None.

--*/
{

    //
    // If the addresses are the same, don't do anything
    //
    if (Source == Destination) {
        return;
    }

    CopyMemory(Destination, Source, BufferLength);

    //
    // Free the buffer
    //

    DpmiFreeBuffer(Source, BufferLength);
}


USHORT
DpmiCalcFcbLength(
    PUCHAR FcbPointer
    )
/*++

Routine Description:

    This routine calculates the length of an FCB.

Arguments:

    FcbPointer -- Supplies the Fcb

Return Value:

    Length of the fcb in bytes

--*/
{
    if (*FcbPointer == 0xFF) {
        return 0x2c;
    } else {
        return 0x25;
    }
}

PUCHAR
DpmiMapString(
    USHORT StringSeg,
    ULONG StringOff,
    PWORD16 Length
    )
/*++

Routine Description:

    This routine maps an asciiz string to low memory

Arguments:

    StringSeg -- Supplies the segment of the string
    StringOff -- Supplies the offset of the string

Return Value:

    Pointer to the buffered string

;   NOTE:
;       DOS has a tendency to look one byte past the end of the string "\"
;       to look for ":\" followed by a zero.  For this reason, we always
;       map three extra bytes of every string.

--*/
{
    USHORT CurrentChar = 0;
    PUCHAR String;
    ULONG Limit;

    String = VdmMapFlat(StringSeg, StringOff, VDM_PM);

    //
    // Scan string for NULL
    //

    GET_SHADOW_SELECTOR_LIMIT(StringSeg, Limit);
    Limit -= StringOff;
    while (CurrentChar <= (USHORT)Limit) {
        if (String[CurrentChar] == '\0') {
            break;
        }
        CurrentChar++;
    }

    //
    // If we didn't reach the end of the segment, we stopped because
    // of the null, and need to include that in the string
    //
    if (CurrentChar < (USHORT)Limit) {
        CurrentChar++;
    }

    //
    // If we didn't find the end, copy 100h bytes
    //
    if ((String[CurrentChar] != '\0') && CurrentChar > 0x100) {
        CurrentChar = 0x100;
    }

    //
    // If there are 3 bytes after the string, copy the extra 3 bytes
    //
    if ((CurrentChar + 3) <= (USHORT)Limit) {
        CurrentChar += 3;
    }

    //
    // The length is one based.  The index is zero based
    //
    *Length = CurrentChar + 1;

    return DpmiMapAndCopyBuffer(String, (USHORT) (CurrentChar + 1));

}

PUCHAR
DpmiAllocateBuffer(
    USHORT Length
    )
/*++

Routine Description:

    This routine allocates buffer space from the static buffer in low
    memory.

Arguments:

    Length -- Length of the buffer needed

Return Value:

    Returns pointer to the buffer space allocated

--*/
{
    //
    // If the data fits in the small buffer, use it
    //
    if ((Length <= SMALL_XLAT_BUFFER_SIZE) && !SmallBufferInUse) {
        SmallBufferInUse = TRUE;
        return SmallXlatBuffer;
    }

    if (Length <= (LARGE_XLAT_BUFFER_SIZE - LargeBufferInUseCount)) {
        LargeBufferInUseCount += Length;
        return (LargeXlatBuffer + LargeBufferInUseCount - Length);
    }

    //
    // Whoops!  No buffer space available.  Bomb with a predictable
    // address.
    //
    ASSERT(0);      // this is an internal error
    return (PUCHAR)0xf00df00d;

}

VOID
DpmiFreeBuffer(
    PUCHAR Buffer,
    USHORT Length
    )
/*++

Routine Description:

    Frees buffer space allocated using DpmiAllocateBuffer

Arguments:

    Buffer -- Supplies a pointer to the buffer allocated above
    Length -- Length of the buffer allocated

Return Value:

    None.

--*/
{
    //
    // Free the buffer
    //

    if (Buffer == SmallXlatBuffer) {
        SmallBufferInUse = FALSE;
    }

    if ((Buffer >= LargeXlatBuffer) &&
        (Buffer < (LargeXlatBuffer + LARGE_XLAT_BUFFER_SIZE))
    ) {
        LargeBufferInUseCount -= Length;
    }
}

VOID
DpmiFreeAllBuffers(
    VOID
    )
/*++

Routine Description:

    This routine frees all of the currently allocated buffer space.

Arguments:


Return Value:

    None.

--*/
{
    SmallBufferInUse = FALSE;
    LargeBufferInUseCount = 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\dosmem.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dosmem.c

Abstract:

    This module contains routines for allocating and freeing DOS memory.

Author:

    Neil Sandlin (neilsa) 12-Dec-1996

Notes:


Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include <malloc.h>
#include <xlathlp.h>

#define DOSERR_NOT_ENOUGH_MEMORY 8
#define DOSERR_INVALID_BLOCK     9

MEM_DPMI DosMemHead = { NULL, 0, &DosMemHead, &DosMemHead, 0};


VOID
DpmiAllocateDosMem(
    VOID
    )
/*++

Routine Description:

    This routine allocates a block of DOS memory. The client is switched
    to V86 mode, and DOS is called to allocate the memory. Then a selector
    is allocated for the PM app to reference the memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI DosMemBlock;
    CLIENT_REGS SaveRegs;
    USHORT Sel;
    USHORT Seg;
    ULONG ParaSize = getBX();
    ULONG MemSize = ((ULONG)ParaSize) << 4;
    USHORT DosError = 0;
    USHORT SizeLargest = 0;

    SAVE_CLIENT_REGS(SaveRegs);

    if (WOWAllocSeg) {
        PUCHAR VdmStackPointer;
        ULONG NewSP;

        //
        // WOW is doing the allocation
        //

        BuildStackFrame(4, &VdmStackPointer, &NewSP);

        setCS(WOWAllocSeg);
        setIP(WOWAllocFunc);

        *(PDWORD16)(VdmStackPointer-4) = MemSize;
        *(PWORD16)(VdmStackPointer-6) =  (USHORT) (PmBopFe >> 16);
        *(PWORD16)(VdmStackPointer-8) =  (USHORT) PmBopFe;
        setSP((WORD)NewSP);

        host_simulate();

        Sel = getAX();
        Seg = getDX();
        if (!Sel) {
            DosError = DOSERR_NOT_ENOUGH_MEMORY;
        }

    } else {
        USHORT SelCount;

        //
        // DOS is doing the allocation
        // First get a mem_block to track the allocation
        //

        DosMemBlock = malloc(sizeof(MEM_DPMI));

        if (!DosMemBlock) {

            // Couldn't get the MEM_DPMI
            DosError = DOSERR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // Next allocate the selector array
            //

            SelCount = (USHORT) ((MemSize+65535)>>16);
            Sel = ALLOCATE_SELECTORS(SelCount);

            if (!Sel) {

                // Couldn't get the selectors
                DosError = DOSERR_NOT_ENOUGH_MEMORY;
                free(DosMemBlock);

            } else {

                //
                // Now have DOS allocate the memory
                //

                DpmiSwitchToRealMode();

                setBX((WORD)ParaSize);
                setAX(0x4800);

                DPMI_EXEC_INT(0x21);

                if (getCF()) {
                    USHORT i;

                    // Couldn't get the memory
                    DosError = getAX();
                    SizeLargest = getBX();
                    for (i = 0; i < SelCount; i++, Sel+=8) {
                        FreeSelector(Sel);
                    }
                    free(DosMemBlock);

                } else {
                    ULONG Base;

                    //
                    // Got the block. Save the allocation info, and set
                    // up the descriptors
                    //

                    Seg = getAX();
                    Base = ((ULONG)Seg) << 4;

                    DosMemBlock->Address = (PVOID)Seg;
                    DosMemBlock->Length = (ULONG)ParaSize;
                    DosMemBlock->Sel = Sel;
                    DosMemBlock->SelCount = SelCount;
                    INSERT_BLOCK(DosMemBlock, DosMemHead);

                    SetDescriptorArray(Sel, Base, MemSize);
                }

                DpmiSwitchToProtectedMode();
            }
        }
    }

    SET_CLIENT_REGS(SaveRegs);

    if (DosError) {
        setAX(DosError);
        setBX(SizeLargest);
        setCF(1);
    } else {
        setDX(Sel);
        setAX(Seg);
        setCF(0);
    }
}

VOID
DpmiFreeDosMem(
    VOID
    )
/*++

Routine Description:

    This routine frees a block of DOS memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI DosMemBlock;
    CLIENT_REGS SaveRegs;
    USHORT Sel = getDX();
    USHORT DosError = 0;

    SAVE_CLIENT_REGS(SaveRegs);

    if (WOWFreeSeg) {
        PUCHAR VdmStackPointer;
        ULONG NewSP;

        //
        // WOW is doing the free
        //

        BuildStackFrame(3, &VdmStackPointer, &NewSP);

        setCS(WOWFreeSeg);
        setIP(WOWFreeFunc);

        *(PWORD16)(VdmStackPointer-2) = Sel;
        *(PWORD16)(VdmStackPointer-4) =  (USHORT) (PmBopFe >> 16);
        *(PWORD16)(VdmStackPointer-6) =  (USHORT) PmBopFe;
        setSP((WORD)NewSP);

        host_simulate();

        Sel = getAX();
        if (!Sel) {
            DosError = DOSERR_INVALID_BLOCK;
        }

    } else {
        USHORT i;
        DosError = DOSERR_INVALID_BLOCK;    // assume failure
        //
        // DOS is doing the free
        // First find the mem_block for this allocation
        //
        DosMemBlock = DosMemHead.Next;

        while(DosMemBlock != &DosMemHead) {

            if (DosMemBlock->Sel == Sel) {

                DpmiSwitchToRealMode();

                setES((WORD)DosMemBlock->Address);
                setAX(0x4900);

                DPMI_EXEC_INT(0x21);

                if (getCF()) {
                    USHORT i;

                    // Couldn't free the memory
                    DosError = getAX();

                } else {

                    for (i = 0; i < DosMemBlock->SelCount; i++, Sel+=8) {
                        FreeSelector(Sel);
                    }
                    DosError = 0;

                }

                DpmiSwitchToProtectedMode();

                DELETE_BLOCK(DosMemBlock);
                free(DosMemBlock);
                break;
            }
            DosMemBlock = DosMemBlock->Next;
        }
    }

    SET_CLIENT_REGS(SaveRegs);

    if (DosError) {
        setAX(DosError);
        setCF(1);
    } else {
        setCF(0);
    }
}

VOID
DpmiSizeDosMem(
    VOID
    )
/*++

Routine Description:

    This routine calls DOS to resize a DOS memory block, or to get
    the largest available block.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DECLARE_LocalVdmContext;
    PMEM_DPMI DosMemBlock;
    CLIENT_REGS SaveRegs;
    USHORT Sel = getDX();
    ULONG ParaSize = getBX();
    ULONG MemSize = ((ULONG)ParaSize) << 4;
    USHORT DosError = 0;

    SAVE_CLIENT_REGS(SaveRegs);

    if (WOWFreeSeg) {

        //
        // WOW is doing the resize
        //

        // Not implemented
        DosError = DOSERR_NOT_ENOUGH_MEMORY;

    } else {
        USHORT SelCount;
        USHORT i;

        //
        // DOS is doing the resize
        // Find the mem_block for this allocation
        // First see if we need a new selector array
        //

        DosError = DOSERR_INVALID_BLOCK;    // assume failure
        DosMemBlock = DosMemHead.Next;

        while(DosMemBlock != &DosMemHead) {

            if (DosMemBlock->Sel == Sel) {
                USHORT NewSel = 0;
                USHORT NewSelCount = 0;

                //
                // If we have to grow the selector array, make sure
                // we can grow it in place
                //
                SelCount = (USHORT) ((MemSize+65535)>>16);

                if (SelCount > DosMemBlock->SelCount) {
                    USHORT TmpSel;

                    NewSel = Sel+(DosMemBlock->SelCount*8);
                    NewSelCount = SelCount - DosMemBlock->SelCount;

                    //
                    // First check to see if the selectors are really all free
                    //
                    for (i=0,TmpSel = NewSel; i < NewSelCount; i++, TmpSel+=8) {
                        if (!IS_SELECTOR_FREE(TmpSel)) {
                            DosError = DOSERR_NOT_ENOUGH_MEMORY;
                            goto dpmi_size_error;
                        }
                    }
                    //
                    // Now attempt to remove them off the free list
                    //
                    for (i=0; i < NewSelCount; i++, NewSel+=8) {
                        if (!RemoveFreeSelector(NewSel)) {
                            // If this happens, we must have a bogus free
                            // selector list
                            DosError = DOSERR_NOT_ENOUGH_MEMORY;
                            goto dpmi_size_error;
                        }
                    }
                }

                DpmiSwitchToRealMode();

                setBX((WORD)ParaSize);
                setES((WORD)DosMemBlock->Address);
                setAX(0x4A00);

                DPMI_EXEC_INT(0x21);

                if (getCF()) {
                    USHORT i;

                    // Couldn't resize the memory
                    DosError = getAX();

                    // Free selectors, if we got new ones
                    if (NewSelCount) {
                        for (i = 0; i < NewSelCount; i++, NewSel+=8) {
                            FreeSelector(NewSel);
                        }
                    }

                } else {
                    ULONG Base;

                    //
                    // Resized the block. Update the allocation info, and set
                    // up the descriptors
                    //


                    if (SelCount < DosMemBlock->SelCount) {
                        USHORT OldSel = Sel+SelCount*8;
                        USHORT OldSelCount = DosMemBlock->SelCount - SelCount;
                        //
                        // Count of selectors has shrunk. Free 'em up.
                        //

                        for (i = 0; i < OldSelCount; i++, OldSel+=8) {
                            FreeSelector(OldSel);
                        }

                    }

                    DosMemBlock->Length = (ULONG)ParaSize;
                    DosMemBlock->SelCount = SelCount;

                    Base = ((ULONG)DosMemBlock->Address) << 4;

                    SetDescriptorArray(Sel, Base, MemSize);
                    DosError = 0;

                }

                DpmiSwitchToProtectedMode();

                break;
            }
            DosMemBlock = DosMemBlock->Next;
        }
    }

dpmi_size_error:
    SET_CLIENT_REGS(SaveRegs);

    if (DosError) {
        setAX(DosError);
        setCF(1);
    } else {
        setCF(0);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\data.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains the x86 specific data for the dpmi library.
    Common data is found in dpmi32.c

Author:

    Dave Hastings (daveh) creation-date 09-Feb-1994

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop

//
// Information about the current PSP
//
USHORT CurrentPSPSelector;

//
// Table of selector bases and limits
//
ULONG FlatAddress[LDT_SIZE];

//
// LDT information
//

PLDT_ENTRY Ldt;
USHORT LdtSel;
USHORT LdtMaxSel = 0;
USHORT LdtUserSel = 0;

//
// Address of 16 bit Idt
//
PIDT_ENTRY Idt;


//
// Pointers to the low memory buffers
//
PUCHAR SmallXlatBuffer;
PUCHAR LargeXlatBuffer;
BOOL SmallBufferInUse;
USHORT LargeBufferInUseCount = 0;
//
// Segment of realmode dosx stack
//
USHORT DosxStackSegment;

//
// segment of realmode dosx code
//
USHORT DosxRmCodeSegment;

//
// selector of realmode code
//
USHORT DosxRmCodeSelector;

//
// Address of pointer to next frame on Dosx stack
//
PWORD16 DosxStackFramePointer;

//
// Size of dosx stack frame
//
USHORT DosxStackFrameSize;

//
// Dpmi flags for the current application
//
USHORT CurrentAppFlags;

//
// Address of Bop fe for ending interrupt simulation
//
ULONG RmBopFe;
ULONG PmBopFe;

//
// Address of buffer for DTA in Dosx
//
PUCHAR DosxDtaBuffer;

//
// Information about the current DTA
//
// N.B.  The selector:offset, and CurrentDta following MAY point to
//       different linear addresses.  This will be the case if the
//       dta selector is in high memory.
//       CurrentDosDta holds the "cached" value of the Dta that has
//       actually been issued to DOS.
PUCHAR CurrentDta;
PUCHAR CurrentPmDtaAddress;
PUCHAR CurrentDosDta;
USHORT CurrentDtaSelector;
USHORT CurrentDtaOffset;

//
// These are the functions in WOW (GlobalDOSAlloc, GlobalDOSFree)
// that are used as helper functions to perform DPMI func's 100,101
// when we are running under WOW.
//

USHORT WOWAllocSeg = 0;
USHORT WOWAllocFunc;
USHORT WOWFreeSeg = 0;
USHORT WOWFreeFunc;

//
// Selector limits
//
#if DBG
ULONG SelectorLimit[LDT_SIZE];
PULONG ExpSelectorLimit = SelectorLimit;
#else
PULONG ExpSelectorLimit = NULL;
#endif

//
// Start of intel address space in process memory
//
ULONG IntelBase = 0;

//
// Variables used for supporting stack switching
// (on x86, these are in the vdmtib)
//
#ifndef i386
USHORT LockedPMStackSel;
ULONG LockedPMStackCount;
ULONG PMLockOrigEIP;
ULONG PMLockOrigSS;
ULONG PMLockOrigESP;

ULONG DosxFaultHandlerIret;
ULONG DosxFaultHandlerIretd;
ULONG DosxIntHandlerIret;
ULONG DosxIntHandlerIretd;
ULONG DosxRMReflector;

#endif

VDM_INTERRUPTHANDLER DpmiInterruptHandlers[256] = {0};
VDM_FAULTHANDLER DpmiFaultHandlers[32] = {0};

ULONG DosxIret;
ULONG DosxIretd;

USHORT PMReflectorSeg;

ULONG DosxRmSaveRestoreState;
ULONG DosxPmSaveRestoreState;
ULONG DosxRmRawModeSwitch;
ULONG DosxPmRawModeSwitch;

ULONG DosxVcdPmSvcCall;
ULONG DosxMsDosApi;
ULONG DosxXmsControl;
ULONG DosxHungAppExit;

//
// WORKITEM: should be in VDMTIB
//
ULONG LastLockedPMStackSS;
ULONG LastLockedPMStackESP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\dpmiint.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmiint.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

Author:

    Neil Sandlin (neilsa) 31-Jul-1995

Revision History:

--*/


#ifndef _X86_

GETREGISTERFUNCTION GetRegisterByIndex[8] = {getEAX, getECX, getEDX, getECX,
                                             getESP, getEBP, getESI, getEDI};
SETREGISTERFUNCTION SetRegisterByIndex[8] = {setEAX, setECX, setEDX, setECX,
                                             setESP, setEBP, setESI, setEDI};

#endif // _X86_

#define STACK_FAULT 12

VOID
DpmiFatalExceptionHandler(
    UCHAR XNumber,
    PCHAR VdmStackPointer
    );

BOOL
DpmiFaultHandler(
    ULONG IntNumber,
    ULONG ErrorCode
    );

BOOL
DpmiEmulateInstruction(
    VOID
    );

BOOL
DpmiOp0f(
    PUCHAR pCode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\dpmi32.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmi32.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator
    Neil Sandlin (neilsa) 15-Sep-1996 - Merged dpmi32p.h, dpmidata.h

--*/

#define FAST_VDM_REGISTERS

//
// DPMI structures and definitions
//

#define I31VERSION 90           // Int 31 services major/minor version #'s
#define I31FLAGS 0x000D         // 386 extender, pMode NetBIOS
#define idCpuType 3             // LATER: conceivably, we could return the real proc type
#define I31MasterPIC    0x08    // Master PIC Interrupts start at 08h
#define I31SlavePIC     0x70    // Slave PIC Interrupts start at 70h


#pragma pack(1)
typedef struct _DPMIMEMINFO {
    DWORD LargestFree;
    DWORD MaxUnlocked;
    DWORD MaxLocked;
    DWORD AddressSpaceSize;
    DWORD UnlockedPages;
    DWORD FreePages;
    DWORD PhysicalPages;
    DWORD FreeAddressSpace;
    DWORD PageFileSize;
} DPMIMEMINFO, *PDPMIMEMINFO;
#pragma pack()

#pragma pack(1)
typedef struct _DPMI_RMCALLSTRUCT {
    DWORD Edi;
    DWORD Esi;
    DWORD Ebp;
    DWORD Reserved;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    WORD Flags;
    WORD Es;
    WORD Ds;
    WORD Fs;
    WORD Gs;
    WORD Ip;
    WORD Cs;
    WORD Sp;
    WORD Ss;
} DPMI_RMCALLSTRUCT, *PDPMI_RMCALLSTRUCT;
#pragma pack()


//
// dpmi32 init structure
//

#pragma pack(1)
typedef struct _DOSX_RM_INIT_INFO {
    USHORT StackSegment;
    USHORT StackFrameSize;
    ULONG  RmBopFe;
    ULONG  PmBopFe;
    USHORT RmCodeSegment;
    USHORT RmCodeSelector;
    ULONG  pFaultHandlerIret;
    ULONG  pFaultHandlerIretd;
    ULONG  pIntHandlerIret;
    ULONG  pIntHandlerIretd;
    ULONG  pIret;
    ULONG  pIretd;
    USHORT RMCallBackBopOffset;
    USHORT RMCallBackBopSeg;
    ULONG  RMReflector;
    USHORT PMReflectorSeg;
    USHORT InitialLDTSeg;
    USHORT InitialLDTSize;
    ULONG  RmSaveRestoreState;
    ULONG  PmSaveRestoreState;
    ULONG  RmRawModeSwitch;
    ULONG  PmRawModeSwitch;
    ULONG  VcdPmSvcCall;
    ULONG  MsDosApi;
    ULONG  XmsControl;
    ULONG  HungAppExit;
} DOSX_RM_INIT_INFO;
typedef DOSX_RM_INIT_INFO UNALIGNED* PDOSX_RM_INIT_INFO;

typedef struct _DOSX_INIT_INFO {
    ULONG  pSmallXlatBuffer;
    ULONG  pLargeXlatBuffer;
    ULONG  pStackFramePointer;
    ULONG  pDtaBuffer;
} DOSX_INIT_INFO;
typedef DOSX_INIT_INFO UNALIGNED* PDOSX_INIT_INFO;
#pragma pack()


#define SWITCH_TO_DOSX_RMSTACK() {                          \
            setSS(DosxStackSegment);                        \
            setSP(*DosxStackFramePointer);                  \
            *DosxStackFramePointer -= DosxStackFrameSize;   \
            }

#define SWITCH_FROM_DOSX_RMSTACK() {                        \
            *DosxStackFramePointer += DosxStackFrameSize;   \
            }

//
// Defines to allow us to use a common dispatch table without having
// to add a bunch of stub functions
//

extern VDM_INTERRUPTHANDLER DpmiInterruptHandlers[256];
extern VDM_FAULTHANDLER DpmiFaultHandlers[32];

#ifdef _X86_

#ifdef FAST_VDM_REGISTERS

#define LockedPMStackSel      (_LocalVdmTib->DpmiInfo.SsSelector)
#define LockedPMStackCount    (_LocalVdmTib->DpmiInfo.LockCount)

#define PMLockOrigEIP         (_LocalVdmTib->DpmiInfo.SaveEip)
#define PMLockOrigESP         (_LocalVdmTib->DpmiInfo.SaveEsp)
#define PMLockOrigSS          (_LocalVdmTib->DpmiInfo.SaveSsSelector)

#define DosxFaultHandlerIret  (_LocalVdmTib->DpmiInfo.DosxFaultIret)
#define DosxFaultHandlerIretd (_LocalVdmTib->DpmiInfo.DosxFaultIretD)
#define DosxIntHandlerIret    (_LocalVdmTib->DpmiInfo.DosxIntIret)
#define DosxIntHandlerIretd   (_LocalVdmTib->DpmiInfo.DosxIntIretD)
#define DosxRMReflector       (_LocalVdmTib->DpmiInfo.DosxRmReflector)


#else   //FAST_VDM_REGISTERS

// Temporary only.  Doing this so I can switch back to the old way in case ...

#define LockedPMStackSel      ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.SsSelector
#define LockedPMStackCount    ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.LockCount

#define PMLockOrigEIP         ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.SaveEip
#define PMLockOrigESP         ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.SaveEsp
#define PMLockOrigSS          ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.SaveSsSelector

#define DosxFaultHandlerIret  ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxFaultIret
#define DosxFaultHandlerIretd ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxFaultIretD
#define DosxIntHandlerIret    ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxIntIret
#define DosxIntHandlerIretd   ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxIntIretD
#define DosxRMReflector       ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.DosxRmReflector

#endif //FAST_VDM_REGISTERS

#else  // _X86_

extern USHORT LockedPMStackSel;
extern ULONG LockedPMStackCount;
extern ULONG PMLockOrigEIP;
extern ULONG PMLockOrigSS;
extern ULONG PMLockOrigESP;

extern ULONG DosxFaultHandlerIret;
extern ULONG DosxFaultHandlerIretd;
extern ULONG DosxIntHandlerIret;
extern ULONG DosxIntHandlerIretd;
extern ULONG DosxRMReflector;

//
// Ldt entry definition
//
// This appears in nti386.h, and winnt.h.  The definitions in
// winnt.h are not included if the nt include files are included.
// The simple solution, since this structure will never change
// is to put the definition here.
//

typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     // Declare as bytes to avoid alignment
            BYTE    Flags2;     // Problems.
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;


//
// Data items
//

extern VOID force_yoda(VOID);
extern VOID DisableEmulatorIretHooks(VOID);
extern VOID EnableEmulatorIretHooks(VOID);

#endif

typedef struct _IDT_ENTRY {
    WORD    OffsetLow;
    WORD    Selector;
    BYTE    Reserved;
    union {
        struct {
            BYTE Flags;
        } Bytes;
        struct {
            BYTE   Type : 5;
            BYTE   Dpl : 2;
            BYTE   Pres : 1;
        } Bits;
    } u;
    WORD    OffsetHi;
} IDT_ENTRY, *PIDT_ENTRY;


#define GET_SELECTOR_BASE(Sel) ( (ULONG) (              \
            Ldt[Sel>>3].BaseLow |                       \
            Ldt[Sel>>3].HighWord.Bytes.BaseMid << 16 |  \
            Ldt[Sel>>3].HighWord.Bytes.BaseHi << 24     \
            ))

#define GET_SELECTOR_LIMIT(Sel) ( (ULONG) (                                     \
            ((Ldt[Sel>>3].HighWord.Bits.LimitHi << 16 | Ldt[Sel>>3].LimitLow)   \
                 << (12 * Ldt[Sel>>3].HighWord.Bits.Granularity)) +             \
                    Ldt[Sel>>3].HighWord.Bits.Granularity * 0xFFF               \
            ))

#if DBG
#define GET_SHADOW_SELECTOR_LIMIT(Selector, Limit) \
            Limit = SelectorLimit[Selector>>3]
#else
#ifdef _X86_
#define GET_SHADOW_SELECTOR_LIMIT(Selector, Limit) _asm      \
         {                                          \
            _asm    xor     eax, eax                \
            _asm    xor     ecx, ecx                \
            _asm    mov     ax, Selector            \
            _asm    or      eax, 7                  \
            _asm    lsl     ecx, eax                \
            _asm    mov     [Limit], ecx            \
         }
#else
#define GET_SHADOW_SELECTOR_LIMIT(Selector, Limit)  \
            Limit = GET_SELECTOR_LIMIT(Selector)
#endif
#endif

#define SET_SELECTOR_LIMIT(Sel, Limit) {                                    \
            USHORT i = Sel>>3;                                              \
            if (!Ldt[i].HighWord.Bits.Granularity) {                        \
                Ldt[i].LimitLow = (USHORT)(Limit & 0x0000FFFF);             \
                Ldt[i].HighWord.Bits.LimitHi =                              \
                    (Limit & 0x000f0000) >> 16;                             \
            } else {                                                        \
                Ldt[i].LimitLow = (USHORT)((Limit >> 12) & 0xFFFF);         \
                Ldt[i].HighWord.Bits.LimitHi =                              \
                    ((Limit >> 12) & 0x000f0000) >> 16;                     \
            }                                                               \
        }

#define SET_SELECTOR_ACCESS(Sel, Access) {                                  \
            Ldt[Sel>>3].HighWord.Bytes.Flags1 = LOBYTE(Access);             \
            Ldt[Sel>>3].HighWord.Bytes.Flags2 = (HIBYTE(Access) & 0xd0) +   \
           (Ldt[Sel>>3].HighWord.Bytes.Flags2 & 0x0f);                      \
            }


#define IS_SELECTOR_FREE(Sel) ((Ldt[Sel>>3].HighWord.Bytes.Flags1 == 0) &&  \
                               (Ldt[Sel>>3].HighWord.Bytes.BaseHi == 0x80))

#define IS_SELECTOR_READABLE(Sel) (                                         \
            ((Ldt[Sel>>3].HighWord.Bytes.Flags1 &                           \
              (AB_DPL3|AB_PRESENT|AB_DATA)) ==                              \
                                      (AB_DPL3|AB_PRESENT|AB_DATA))         \
            )

#ifdef _X86_
#define FLUSH_SELECTOR_CACHE(SelStart, SelCount) TRUE
#else
#define FLUSH_SELECTOR_CACHE(SelStart, SelCount) FlushSelectorCache(SelStart, SelCount)
#endif

//
// These values define the range of the reserved DPMI selectors, given
// out by Int31, func 000d.
//
#define SEL_DPMI_FIRST 0
#define SEL_DPMI_LAST 0x78

// Whenever we allocate a descriptor, the access rights byte is set
// to 0Fh.  This marks it as a '386 task gate, which is not legal to
// have in the GDT.  We need to stick something in this byte, because
// having the access rights byte be 0 means that it is free, which is
// no longer the case.

#define MARK_SELECTOR_ALLOCATED(Sel) {                  \
            Ldt[Sel>>3].HighWord.Bytes.Flags1 = 0xf;    \
            Ldt[Sel>>3].HighWord.Bytes.BaseHi = 0;      \
            }

#define MARK_SELECTOR_FREE(Sel) {                       \
            Ldt[Sel>>3].HighWord.Bytes.Flags1 = 0;      \
            Ldt[Sel>>3].HighWord.Bytes.BaseHi = 0x80;   \
            }

#define NEXT_FREE_SEL(Sel) (Ldt[Sel>>3].LimitLow)

#define ALLOCATE_SELECTOR() AllocateSelectors(1, FALSE)
#define ALLOCATE_SELECTORS(Count) AllocateSelectors(Count, FALSE)
#define ALLOCATE_WOW_SELECTORS(Count) AllocateSelectors(Count, TRUE)



#define SEGMENT_IS_BIG(sel) ((sel<LdtMaxSel) && (Ldt[(sel & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big))
#define SEGMENT_IS_PRESENT(sel) ((sel<LdtMaxSel) && (Ldt[(sel & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Pres))

// This checks for S, Data, W
#define SEGMENT_IS_WRITABLE(sel) ((sel<LdtMaxSel) && ( (Ldt[(sel & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Type & 0x1a) == 0x12))


#define SEL_INDEX_MASK ~7
// Ldt, ring 3 bits
#define SEL_LDT3 7

//
// Descriptor Access Byte constants
//

#define AB_ACCESSED     0x01    //segment has been accessed
#define AB_WRITE        0x02    //writable data

#define AB_DATA         0x10    //data segment
#define AB_CODE         0x18    //code segment
#define AB_DPL3         0x60    //ring 3 DPL
#define AB_PRESENT      0x80    //segment present bit

#define AB_TRAPGATE     0x07    //trap gate descriptor
#define AB_INTRGATE     0x0e    //80386 interrupt gate descriptor

#define STD_DATA AB_PRESENT+AB_DPL3+AB_DATA+AB_WRITE
#define STD_TRAP AB_PRESENT+AB_DPL3+AB_TRAPGATE
#define STD_INTR AB_PRESENT+AB_DPL3+AB_INTRGATE

//
// Internal Constants
//

#define MAX_V86_ADDRESS         64 * 1024 + 1024 * 1024
#define ONE_MB                  1024 * 1024

// bugbug
#define SMALL_XLAT_BUFFER_SIZE  128
// bugbug
#define LARGE_XLAT_BUFFER_SIZE  8192

#define DPMI_32BIT              0x1

#define Frame32 ((BOOL)CurrentAppFlags)
#define LockedPMStackOffset 0x1000

//
// Internal types
//
typedef ULONG (*GETREGISTERFUNCTION)(VOID);
typedef VOID (*SETREGISTERFUNCTION)(ULONG);

#define SAVE_CLIENT_REGS(Regs) {\
    Regs.Eax = getEAX();        \
    Regs.Ebx = getEBX();        \
    Regs.Ecx = getECX();        \
    Regs.Edx = getEDX();        \
    Regs.Edi = getEDI();        \
    Regs.Esi = getESI();        \
    Regs.Ebp = getEBP();        \
    Regs.Eip = getEIP();        \
    Regs.Esp = getESP();        \
    Regs.Eflags = getEFLAGS();  \
    Regs.Cs = getCS();          \
    Regs.Ds = getDS();          \
    Regs.Es = getES();          \
    Regs.Fs = getFS();          \
    Regs.Gs = getGS();          \
    Regs.Ss = getSS();          \
    }

#define SET_CLIENT_REGS(Regs) { \
    setEAX(Regs.Eax);           \
    setEBX(Regs.Ebx);           \
    setECX(Regs.Ecx);           \
    setEDX(Regs.Edx);           \
    setEDI(Regs.Edi);           \
    setESI(Regs.Esi);           \
    setEBP(Regs.Ebp);           \
    setEIP(Regs.Eip);           \
    setESP(Regs.Esp);           \
    setEFLAGS(Regs.Eflags);     \
    setCS(Regs.Cs);             \
    setDS(Regs.Ds);             \
    setES(Regs.Es);             \
    setFS(Regs.Fs);             \
    setGS(Regs.Gs);             \
    setSS(Regs.Ss);             \
    }

typedef struct _CLIENT_REGS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Edi;
    ULONG Esi;
    ULONG Ebp;
    ULONG Eip;
    ULONG Esp;
    ULONG Eflags;
    USHORT Cs;
    USHORT Ss;
    USHORT Es;
    USHORT Ds;
    USHORT Fs;
    USHORT Gs;
} CLIENT_REGS, *PCLIENT_REGS;

//
// Memory management definitions
//

#define DELETE_BLOCK(BLK)   (BLK->Prev)->Next = BLK->Next;\
                (BLK->Next)->Prev = BLK->Prev

#define INSERT_BLOCK(BLK, HEAD)  BLK->Next = HEAD.Next; BLK->Prev= HEAD.Next->Prev;\
                (HEAD.Next)->Prev = BLK; HEAD.Next = BLK

//
// Visible structure for save state stuff
//
typedef struct _VSavedState {
    UCHAR Misc[28];
} VSAVEDSTATE, PVSAVEDSTATE;

//
// Descriptor mapping (for dib.drv)
//

#ifndef _X86_
ULONG
GetDescriptorMapping(
    USHORT Sel,
    ULONG LdtBase
    );

typedef struct _DESC_MAPPING {
    USHORT Sel;
    USHORT SelCount;
    ULONG LdtBase;
    ULONG FlatBase;
    struct _DESC_MAPPING* pNext;
} DESC_MAPPING, *PDESC_MAPPING;
#endif

//
// Dpmi32 data
//

//SLT: these two should be per-thread
extern ULONG LastLockedPMStackSS;
extern ULONG LastLockedPMStackESP;

extern PUCHAR SmallXlatBuffer;
extern PUCHAR LargeXlatBuffer;
extern BOOL SmallBufferInUse;
extern USHORT LargeBufferInUseCount;
extern USHORT DosxStackSegment;
extern USHORT DosxRmCodeSegment;
extern USHORT DosxRmCodeSelector;
extern PWORD16 DosxStackFramePointer;
extern USHORT DosxStackFrameSize;
extern USHORT CurrentAppFlags;
extern ULONG RmBopFe;
extern ULONG PmBopFe;
extern USHORT RMCallBackBopSeg;
extern USHORT RMCallBackBopOffset;
extern USHORT PMReflectorSeg;
extern PUCHAR DosxDtaBuffer;
extern ULONG IntelBase;
extern PLDT_ENTRY Ldt;
extern USHORT LdtSel;
extern USHORT LdtMaxSel;
extern USHORT LdtUserSel;
extern PIDT_ENTRY Idt;
extern USHORT WOWAllocSeg;
extern USHORT WOWAllocFunc;
extern USHORT WOWFreeSeg;
extern USHORT WOWFreeFunc;

//
// Information about the current DTA
//
// N.B.  The selector:offset, and flat pointer following MAY point to
//       different linear addresses.  This will be the case if the
//       dta selector is in high memory
extern PUCHAR CurrentDta;
extern PUCHAR CurrentPmDtaAddress;
extern PUCHAR CurrentDosDta;
extern USHORT CurrentDtaSelector;
extern USHORT CurrentDtaOffset;

#if DBG
extern ULONG SelectorLimit[LDT_SIZE];
#endif


//
// Register manipulation functions (for register that might be 16 or 32 bits)
//
extern GETREGISTERFUNCTION GetCXRegister;
extern GETREGISTERFUNCTION GetDXRegister;
extern GETREGISTERFUNCTION GetDIRegister;
extern GETREGISTERFUNCTION GetSIRegister;
extern GETREGISTERFUNCTION GetBXRegister;
extern GETREGISTERFUNCTION GetAXRegister;
extern GETREGISTERFUNCTION GetSPRegister;

extern SETREGISTERFUNCTION SetCXRegister;
extern SETREGISTERFUNCTION SetDXRegister;
extern SETREGISTERFUNCTION SetDIRegister;
extern SETREGISTERFUNCTION SetSIRegister;
extern SETREGISTERFUNCTION SetBXRegister;
extern SETREGISTERFUNCTION SetAXRegister;
extern SETREGISTERFUNCTION SetSPRegister;


extern USHORT CurrentPSPSelector;
extern ULONG FlatAddress[LDT_SIZE];

extern ULONG DosxIret;
extern ULONG DosxIretd;

extern ULONG DosxRmSaveRestoreState;
extern ULONG DosxPmSaveRestoreState;
extern ULONG DosxRmRawModeSwitch;
extern ULONG DosxPmRawModeSwitch;

extern ULONG DosxVcdPmSvcCall;
extern ULONG DosxMsDosApi;
extern ULONG DosxXmsControl;
extern ULONG DosxHungAppExit;

//
// Monitor functions
//
VOID
GetFastBopEntryAddress(
    PCONTEXT VdmContext
    );

//
// Dispatched functions (via bop)
//

VOID DpmiInitDosxRM(VOID);
VOID DpmiInitDosx(VOID);
VOID DpmiInitLDT(VOID);
VOID DpmiGetFastBopEntry(VOID);
VOID DpmiInitIDT(VOID);
VOID DpmiInitExceptionHandlers(VOID);
VOID DpmiInitPmStackInfo(VOID);
VOID DpmiInitApp(VOID);
VOID DpmiTerminateApp(VOID);
VOID DpmiDpmiInUse(VOID);
VOID DpmiDpmiNoLongerInUse(VOID);

VOID switch_to_protected_mode(VOID);
VOID switch_to_real_mode(VOID);
VOID DpmiSetAltRegs(VOID);

VOID DpmiVcdPmSvcCall32(VOID);
VOID DpmiFreeAppXmem(VOID);
VOID DpmiFreeAllXmem(VOID);

VOID DpmiIntHandlerIret16(VOID);
VOID DpmiIntHandlerIret32(VOID);
VOID DpmiFaultHandlerIret16(VOID);
VOID DpmiFaultHandlerIret32(VOID);
VOID DpmiUnhandledExceptionHandler(VOID);

VOID DpmiRMCallBackCall(VOID);
VOID DpmiReflectIntrToPM(VOID);
VOID DpmiReflectIntrToV86(VOID);

VOID DpmiSetDescriptorEntry(VOID);
VOID DpmiAllocateSelectors(VOID);
VOID DpmiFreeSelector(VOID);
VOID DpmiResetLDTUserBase(VOID);

VOID DpmiXlatInt21Call(VOID);
VOID DpmiInt31Entry(VOID);
VOID DpmiInt31Call(VOID);

VOID DpmiHungAppIretAndExit(VOID);

//
// Internal functions
//

VOID
BeginUseLockedPMStack(
    VOID
    );

BOOL
EndUseLockedPMStack(
    VOID
    );

BOOL
BuildStackFrame(
    ULONG StackUnits,
    PUCHAR *pVdmStackPointer,
    ULONG *pNewSP
    );

VOID
EmulateV86Int(
    UCHAR InterruptNumber
    );

typedef enum {
    RESTORE_FLAGS,
    PASS_FLAGS,
    PASS_CARRY_FLAG,
    PASS_CARRY_FLAG_16
} IRET_BEHAVIOR;

VOID
SimulateIret(
    IRET_BEHAVIOR fdsp
    );

VOID
SimulateFarCall(
    USHORT Seg,
    ULONG Offset
    );

VOID
SimulateCallWithIretFrame(
    USHORT Seg,
    ULONG Offset
    );

BOOL
DpmiSwIntHandler(
    ULONG IntNumber
    );

BOOL
DpmiHwIntHandler(
    ULONG IntNumber
    );

BOOL
DpmiFaultHandler(
    ULONG IntNumber,
    ULONG ErrorCode
    );

BOOL
SetProtectedModeInterrupt(
    USHORT IntNumber,
    USHORT Sel,
    ULONG Offset,
    USHORT Flags
    );

BOOL
SetFaultHandler(
    USHORT IntNumber,
    USHORT Sel,
    ULONG Offset
    );

BOOL
DispatchPMInt(
    UCHAR InterruptNumber
    );

VOID
DpmiRMCall(
    UCHAR mode
    );

VOID
DpmiAllocateRMCallBack(
    VOID
    );

VOID
DpmiFreeRMCallBack(
    VOID
    );

BOOL
PMInt2fHandler(
    VOID
    );

VOID
GetVxDApiHandler(
    USHORT VxdId
    );

BOOL
DpmiSetDebugRegisters(
    PULONG RegisterPointer
    );

BOOL
DpmiGetDebugRegisters(
    PULONG RegisterPointer
    );
//
// Descriptor managagment
//

#ifdef _X86_
BOOL
DpmiSetX86Descriptor(
    USHORT  SelStart,
    USHORT  SelCount
    );
#else
VOID
FlushSelectorCache(
    USHORT  SelStart,
    USHORT  SelCount
    );
#endif

VOID
SetShadowDescriptorEntries(
    USHORT SelStart,
    USHORT SelCount
    );

VOID
SetDescriptorBase(
    USHORT Sel,
    ULONG Base
    );

VOID
SetDescriptor(
    USHORT Sel,
    ULONG Base,
    ULONG Limit,
    USHORT Access
    );

USHORT
AllocateSelectors(
    USHORT Count,
    BOOL bWow
    );

BOOL
FreeSelector(
    USHORT Sel
    );

USHORT
FindSelector(
    ULONG Base,
    UCHAR Access
    );

BOOL
RemoveFreeSelector(
    USHORT Sel
    );

USHORT
SegmentToSelector(
    USHORT Segment,
    USHORT Access
    );

VOID
SetDescriptorArray(
    USHORT Sel,
    ULONG Base,
    ULONG MemSize
    );

//
// Memory management
//

NTSTATUS
DpmiAllocateVirtualMemory(
    PVOID *Address,
    PULONG Size
    );

NTSTATUS
DpmiFreeVirtualMemory(
    PVOID *Address,
    PULONG Size
    );

NTSTATUS
DpmiReallocateVirtualMemory(
    PVOID OldAddress,
    ULONG OldSize,
    PVOID *NewAddress,
    PULONG NewSize
    );

VOID
DpmiGetMemoryInfo(
    VOID
    );

PMEM_DPMI
DpmiAllocateXmem(
    ULONG Size
    );

BOOL
DpmiFreeXmem(
    PMEM_DPMI XmemBlock
    );

BOOL
DpmiIsXmemHandle(
    PMEM_DPMI XmemBlock
    );

BOOL
DpmiReallocateXmem(
    PMEM_DPMI XmemBlock,
    ULONG Size
    );

PMEM_DPMI
DpmiFindXmem(
    USHORT Sel
    );

VOID
DpmiAllocateDosMem(
    VOID
    );

VOID
DpmiFreeDosMem(
    VOID
    );

VOID
DpmiSizeDosMem(
    VOID
    );

//
// Utility functions
//

VOID
DpmiInitRegisterSize(
    VOID
    );

VOID
DpmiSwitchToProtectedMode(
    VOID
    );

VOID
DpmiSwitchToRealMode(
    VOID
    );

VOID
DpmiPushRmInt(
    USHORT InterruptNumber
    );

VOID
DpmiSaveSegmentsAndStack(
    PVOID ContextPointer
    );

PVOID
DpmiRestoreSegmentsAndStack(
    VOID
    );

//
// Int21 translation
//

VOID
SetVector(
    VOID
    );

VOID
GetVector(
    VOID
    );

PUCHAR
DpmiMapAndCopyBuffer(
    PUCHAR Buffer,
    USHORT BufferLength
    );

VOID
DpmiUnmapAndCopyBuffer(
    PUCHAR Destination,
    PUCHAR Source,
    USHORT BufferLength
    );

USHORT
DpmiCalcFcbLength(
    PUCHAR FcbPointer
    );

PUCHAR
DpmiMapString(
    USHORT StringSeg,
    ULONG StringOff,
    PWORD16 Length
    );

PUCHAR
DpmiAllocateBuffer(
    USHORT Length
    );

#define DpmiUnmapString DpmiFreeBuffer
#define DpmiUnmapBuffer DpmiFreeBuffer

VOID
DpmiFreeBuffer(
    PUCHAR Buffer,
    USHORT Length
    );

VOID
DpmiFreeAllBuffers(
    VOID
    );

#ifdef DBCS
VOID
DpmiSwitchToDosxStack(
    VOID
    );

VOID
DpmiSwitchFromDosxStack(
    VOID
    );
#endif //DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\dpmimemr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    name-of-module-filename

Abstract:

    This module contains the code for actually allocating memory for dpmi.
    It uses the same suballocation pool as the xms code

Author:

    Dave Hastings (daveh) creation-date 09-Feb-1994

Notes:

    These functions claim to return NTSTATUS.  This is for commonality on
    x86 where we actually have an NTSTATUS to return.  For this file, we
    simply logically invert the bool and return that.  Callers of these 
    functions promise not to attach significance to the return values other
    than STATUS_SUCCESS.
    
Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include <suballoc.h>
#include <xmsexp.h>
#include "memapi.h"


NTSTATUS
DpmiAllocateVirtualMemory(
    PVOID *Address,
    PULONG Size
    )
/*++

Routine Description:

    This routine allocates a chunk of extended memory for dpmi.

Arguments:

    Address -- Supplies a pointer to the Address.  This is filled in 
        if the allocation is successfull
    Size -- Supplies the size to allocate
    
Return Value:

    STATUS_SUCCESS if successfull.

--*/
{
    BOOL Success;
    NTSTATUS Status;

    Status = VdmAllocateVirtualMemory((PULONG)Address, *Size, TRUE);

    if (Status == STATUS_NOT_IMPLEMENTED) {
    
        ASSERT(STATUS_SUCCESS == 0);
        Success = SAAllocate(
            ExtMemSA,
            *Size,
            (PULONG)Address
            );
        
        //
        // Convert boolean to NTSTATUS (sort of)
        //
        if (Success) {
            Status = STATUS_SUCCESS;
        } else {
            Status = -1;
        }
    }

    return(Status);
}

NTSTATUS 
DpmiFreeVirtualMemory(
    PVOID *Address,
    PULONG Size
    )
/*++

Routine Description:

    This function frees memory for dpmi.  It is returned to the suballocation
    pool.

Arguments:

    Address -- Supplies the address of the block to free
    Size -- Supplies the size of the block to free
    
Return Value:

    STATUS_SUCCESS if successful
--*/
{
    BOOL Success;
    NTSTATUS Status;

    Status = VdmFreeVirtualMemory(*(PULONG)Address);

    if (Status == STATUS_NOT_IMPLEMENTED) {

        Success = SAFree(
            ExtMemSA,
            *Size,
            (ULONG)*Address
            );
               
        //
        // Convert boolean to NTSTATUS (sort of)
        //
        if (Success) {
            Status = STATUS_SUCCESS;
        } else {
            Status = -1;
        }
    }

    return(Status);
}

NTSTATUS
DpmiReallocateVirtualMemory(
    PVOID OldAddress,
    ULONG OldSize,
    PVOID *NewAddress,
    PULONG NewSize
    )
/*++

Routine Description:

    This function reallocates a block of memory for DPMI.

Arguments:

    OldAddress -- Supplies the original address for the block
    OldSize -- Supplies the original size for the address
    NewAddress -- Supplies the pointer to the place to return the new
        address
    NewSize -- Supplies the new size
    
Return Value:

    STATUS_SUCCESS if successfull
--*/
{
    NTSTATUS Status;
    BOOL Success;

    Status = VdmReallocateVirtualMemory((ULONG)OldAddress,
                                        (PULONG)NewAddress,
                                        *NewSize);

    if (Status == STATUS_NOT_IMPLEMENTED) {

        Success = SAReallocate(
            ExtMemSA,
            OldSize,
            (ULONG)OldAddress,
            *NewSize,
            (PULONG)NewAddress
            );
        
        //
        // Convert boolean to NTSTATUS (sort of)
        //
        if (Success) {
            Status = STATUS_SUCCESS;
        } else {
            Status = -1;
        }
    }

    return(Status);
    
}

VOID
DpmiGetMemoryInfo(
    VOID
    )
/*++

Routine Description:

    This routine returns information about memory to the dos extender

Arguments:

    None

Return Value:

    None.

--*/
{
    PDPMIMEMINFO UNALIGNED MemInfo;
    MEMORYSTATUS MemStatus;
    ULONG TotalFree, LargestFree;
    NTSTATUS Status;

    //
    // Get a pointer to the return structure
    //
    MemInfo = (PDPMIMEMINFO)Sim32GetVDMPointer(
        ((ULONG)getES()) << 16,
        1,
        TRUE
        );

    (CHAR *)MemInfo += (*GetDIRegister)();

    //
    // Initialize the structure
    //
    RtlFillMemory(MemInfo, sizeof(DPMIMEMINFO), 0xFF);

    //
    // Get the information on memory
    //
    Status = VdmQueryFreeVirtualMemory(
                &TotalFree,
                &LargestFree
                );

    if (Status == STATUS_NOT_IMPLEMENTED) {
        SAQueryFree(
            ExtMemSA,
            &TotalFree,
            &LargestFree
            );
    }
    
    //
    // Return the information.
    //
    // Filled in MaxUnlocked,MaxLocked,UnlockedPages fields in this structute.
    // Director 4.0 get completlely confused if these fields are -1.
    // MaxUnlocked is correct based on LargestFree. The other two are fake
    // and match values on a real WFW machine. I have no way of making them
    // any better than this at this point. who cares it makes director happy.
    //
    // sudeepb 01-Mar-1995.

    MemInfo->LargestFree = LargestFree;
    MemInfo->MaxUnlocked = LargestFree/4096;
    MemInfo->MaxLocked = 0xb61;
    MemInfo->AddressSpaceSize = 1024 * 1024 * 16 / 4096;
    MemInfo->UnlockedPages = 0xb68;
    MemInfo->FreePages = TotalFree / 4096;
    MemInfo->PhysicalPages = 1024 * 1024 * 16 / 4096;
    MemInfo->FreeAddressSpace = MemInfo->FreePages;
    
    //
    // Get the information on the page file
    //
    MemStatus.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus(&MemStatus);

    MemInfo->PageFileSize = MemStatus.dwTotalPageFile / 4096;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\dpmiint.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dpmiint.c

Abstract:

    This file contains the interrupt support for DPMI. Most of this is
    for supporting the 486 emulator on risc platforms, but some code
    is shared with x86.

Author:

    Neil Sandlin (neilsa) 1-Jun-1995

Revision History:

Comments:

    DPMI stack switching is accomplished by keeping a "locked pm stack"
    count, and when the count is zero, a stack switch occurs. This keeps
    track of the situation with recursive interrupts where the client
    may switch to its own stack. So, a stack switch to our locked stack
    occurs on the first level interrupt, and on subsequent nested interrupts,
    only the count is maintained. This is identical to how win31 managed
    the stack.

    If a client specifies that it is a 32-bit dpmi client, this only affects
    the "width" of a stack frame. A 16-bit client gets 16-bit frames, and
    a 32 bit client gets 32-bit frames. It is still necessary to check
    the size of the stack segment to determine if SP or ESP should be used.

--*/

#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include <dpmiint.h>

BOOL
SetProtectedModeInterrupt(
    USHORT IntNumber,
    USHORT Sel,
    ULONG Offset,
    USHORT Flags
    )

/*++

Routine Description:

    This function services the SetProtectedmodeInterrupt bop.  It retrieves
    the handler information from the Dos application stack, and puts it into
    the VdmTib, for use by instruction emulation.


--*/

{
    DECLARE_LocalVdmContext;

    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;

    if (IntNumber >= 256) {
        return FALSE;
    }

    if ((IntNumber >= 8 && IntNumber <= 0xf) ||
        (IntNumber >= 0x70 && IntNumber <= 0x7f)) {
        //
        // Hardware Interrupt
        //
        Flags |= VDM_INT_INT_GATE;
    } else {
        //
        // Software Interrupt
        //
        Flags |= VDM_INT_TRAP_GATE;
    }

    if (Sel != PMReflectorSeg) {
        //
        // The caller is setting the PM interrupt vector to be something other
        // than the dpmi default "end-of-the-chain" PM handler. Now we check
        // to see if the interrupt needs to be sent up to PM when it is encountered
        // in v86 mode.
        //

        if ((IntNumber == 0x1b) ||      //^Break?
            (IntNumber == 0x1c) ||      //Timer Tick?
            (IntNumber == 0x23) ||      //Ctrl-C?
            (IntNumber == 0x24) ||      //Critical Error Handler?
            (IntNumber == 0x02) ||      //Math co-processor exception used by math library routines!
            ((IntNumber >= 0x08) && (IntNumber <= 0xf)) ||      //Hardware?
            ((IntNumber >= 0x70) && (IntNumber <= 0x77))) {

            // Flag this so that the v86 reflector code will send it to PM
            Flags |= VDM_INT_HOOKED;

            // Mark it down low so NTIO.SYS can do the right thing
            if ( (IntNumber == 0x1c) || (IntNumber == 8) ) {
                *(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) |= VDM_INTS_HOOKED_IN_PM;
            }
        }
    }

    Handlers[IntNumber].Flags = Flags;
    Handlers[IntNumber].CsSelector = Sel;
    Handlers[IntNumber].Eip = Offset;

    DBGTRACE((USHORT)(VDMTR_TYPE_DPMI_SI | IntNumber), Sel, Offset);

#ifdef _X86_
    if (IntNumber == 0x21)
    {
        VDMSET_INT21_HANDLER_DATA    ServiceData;
        NTSTATUS Status;

        ServiceData.Selector = Handlers[IntNumber].CsSelector;
        ServiceData.Offset =   Handlers[IntNumber].Eip;
        ServiceData.Gate32 = Handlers[IntNumber].Flags & VDM_INT_32;

        Status = NtVdmControl(VdmSetInt21Handler,  &ServiceData);

#if DBG
        if (!NT_SUCCESS(Status)) {
            OutputDebugString("DPMI32: Error Setting Int21handler\n");
        }
#endif
    }
#endif      //_X86_

    return TRUE;
}


VOID
DpmiInitIDT(
    VOID
    )
/*++

Routine Description:

    This function initializes the state of the IDT. It takes as input the
    IDT set up by DOSX, updates the IDT's access bytes, and sets the DPMI32
    interrupt handlers by calling SetProtectedModeInterrupt.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT IntNumber;
    USHORT Flags = getBX();

    Idt = (PVOID)VdmMapFlat(getAX(), 0, getMODE());

    for (IntNumber = 0; IntNumber<256; IntNumber++) {

        SetProtectedModeInterrupt(IntNumber,
                                  Idt[IntNumber].Selector,
                                  (((ULONG)Idt[IntNumber].OffsetHi)<<16) +
                                           Idt[IntNumber].OffsetLow,
                                           Flags);

    }

}

BOOL
SetFaultHandler(
    USHORT IntNumber,
    USHORT Sel,
    ULONG Offset
    )

/*++

Routine Description:

    This function services the SetFaultHandler bop.  It retrieves
    the handler information from the Dos application stack, and puts it into
    the VdmTib, for use by instruction emulation.


--*/

{
    DECLARE_LocalVdmContext;

    PVDM_FAULTHANDLER Handlers = DpmiFaultHandlers;

    if (IntNumber >= 32) {
        return FALSE;
    }

    Handlers[IntNumber].Flags = VDM_INT_INT_GATE;
    Handlers[IntNumber].CsSelector = Sel;
    Handlers[IntNumber].Eip = Offset;

    Handlers[IntNumber].SsSelector = 0;     //BUGBUG These are obselete
    Handlers[IntNumber].Esp = 0;            //BUGBUG These are obselete


    DBGTRACE((USHORT)(VDMTR_TYPE_DPMI_SF | IntNumber),
             Handlers[IntNumber].CsSelector,
             Handlers[IntNumber].Eip);
    return TRUE;
}

VOID
DpmiInitExceptionHandlers(
    VOID
    )
{
    DECLARE_LocalVdmContext;
    USHORT OffsetIncr = getAX();
    USHORT IntCount = getBX();
    USHORT Selector = getCX();
    ULONG Offset = (ULONG) getDX();
    USHORT IntNumber;

    for (IntNumber = 0; IntNumber < 32; IntNumber++) {
        SetFaultHandler(IntNumber, Selector, Offset);
        Offset += OffsetIncr;
    }

}


VOID
DpmiUnhandledExceptionHandler(
    VOID
    )
/*++

Routine Description:

    This function gets control when a PM fault occurs that isn't handled
    by an installed handler. The body of this function emulates Win31
    DPMI behavior, where a fault that is reflected to the end of the
    PM fault handler chain is then reflected to the PM *interrupt*
    chain.

Arguments:

    client SS:(E)SP points to dpmi fault stack frame


--*/

{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    USHORT SegSs, SegCs;
    UCHAR XNumber;
    PCHAR VdmStackPointer;
    PCHAR VdmCodePointer;
    USHORT FaultingCS;
    ULONG FaultingEip;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);

    if (SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }

    SegCs = getCS();
    VdmCodePointer = Sim32GetVDMPointer(SegCs<<16, 1, TRUE);

    if (SEGMENT_IS_BIG(SegCs)) {
        VdmCodePointer += getEIP();
    } else {
        VdmCodePointer += getIP();
    }

    XNumber = *(VdmCodePointer);

    if ((XNumber > 7) || (XNumber == 6)) {
        DpmiFatalExceptionHandler(XNumber, VdmStackPointer);
        return;
    }


    if (Frame32) {

        PCHAR VdmNewStackPointer;
        ULONG FrameSS, FrameSP, FrameCS, FrameIP, FrameFlags;

        //
        // Build an iret frame on the faulting stack
        //
        FrameSS = *(PDWORD16) (VdmStackPointer+28);
        FrameSP = *(PDWORD16) (VdmStackPointer+24) - 12;
        *(PDWORD16) (VdmStackPointer+24) = FrameSP;
        VdmNewStackPointer = Sim32GetVDMPointer((ULONG)(FrameSS << 16), 1, TRUE);
        VdmNewStackPointer += FrameSP;

        FrameIP = *(PDWORD16) (VdmStackPointer+12);
        *(PDWORD16) (VdmStackPointer+12) = Handlers[XNumber].Eip;
        *(PDWORD16) (VdmNewStackPointer) = FrameIP;

        FrameCS = *(PDWORD16) (VdmStackPointer+16);
        *(PDWORD16) (VdmStackPointer+16) = (ULONG) Handlers[XNumber].CsSelector;
        *(PDWORD16) (VdmNewStackPointer+4) = FrameCS;

        FrameFlags = *(PDWORD16) (VdmStackPointer+20);
        *(PDWORD16) (VdmNewStackPointer+4) = FrameFlags;
        FrameFlags &= ~(EFLAGS_IF_MASK | EFLAGS_TF_MASK);
        *(PDWORD16) (VdmStackPointer+20) = FrameFlags;

        //
        // Simulate a dpmi fault handler retf
        //
        setCS((USHORT)*(PDWORD16)(VdmStackPointer+4));
        setEIP(*(PDWORD16)(VdmStackPointer));
        setESP(getESP() + 8);

    } else {

        USHORT FrameSS, FrameSP, FrameCS, FrameIP, FrameFlags;
        FrameSS = *(PWORD16) (VdmStackPointer+14);
        FrameCS = *(PWORD16) (VdmStackPointer+8);
        FrameFlags = *(PWORD16) (VdmStackPointer+10);

        if (!SEGMENT_IS_BIG(FrameSS) && !SEGMENT_IS_BIG(FrameCS)) {

            PCHAR VdmNewStackPointer;

            //
            // Build an iret frame on the faulting stack
            //
            FrameSP = *(PWORD16) (VdmStackPointer+12) - 6;
            *(PWORD16) (VdmStackPointer+12) = FrameSP;
            VdmNewStackPointer = Sim32GetVDMPointer((ULONG)(FrameSS << 16)+FrameSP, 1, TRUE);

            FrameIP = *(PWORD16) (VdmStackPointer+6);
            *(PWORD16) (VdmStackPointer+6) = (WORD) Handlers[XNumber].Eip;
            *(PWORD16) (VdmNewStackPointer) = FrameIP;

            *(PWORD16) (VdmStackPointer+8) = Handlers[XNumber].CsSelector;
            *(PWORD16) (VdmNewStackPointer+2) = FrameCS;

            *(PWORD16) (VdmNewStackPointer+4) = FrameFlags;
            FrameFlags &= ~(EFLAGS_IF_MASK | EFLAGS_TF_MASK);
            *(PWORD16) (VdmStackPointer+10) = FrameFlags;

            //
            // Simulate a dpmi fault handler retf
            //
            setCS(*(PWORD16)(VdmStackPointer+2));
            setEIP((DWORD)*(PWORD16)(VdmStackPointer));
            setSP(getSP() + 4);

        } else {
            //
            // Build an iret frame on the locked DPMI stack
            //

            FrameCS = *(PWORD16) (VdmStackPointer+2);
            FrameIP = *(PWORD16) (VdmStackPointer);
            FrameFlags &= ~EFLAGS_IF_MASK;

            setSP(getSP() - 2);

            *(PWORD16)(VdmStackPointer-2) = FrameIP;
            *(PWORD16)(VdmStackPointer)   = FrameCS;
            *(PWORD16)(VdmStackPointer+2) = FrameFlags;
            setCS(Handlers[XNumber].CsSelector);
            setEIP((DWORD)LOWORD(Handlers[XNumber].Eip));
            setSTATUS((WORD) FrameFlags & ~EFLAGS_TF_MASK);
        }

    }

}


VOID
DpmiFatalExceptionHandler(
    UCHAR XNumber,
    PCHAR VdmStackPointer
    )
/*++

Routine Description:

    This function gets control when a PM fault 6, 8-1f occurs that isn't
    handled by an installed handler. It pops up an error dialog for the
    user.

Arguments:

    XNumber - exception number (0-1fh)
    VdmStackPointer - flat pointer to stack frame


--*/

{
    DECLARE_LocalVdmContext;
    char szBuffer[255];
    USHORT FaultingCS;
    ULONG FaultingEip;

    if (Frame32) {
        FaultingCS  = (USHORT)*(PDWORD16)(VdmStackPointer+16);
        FaultingEip = *(PDWORD16)(VdmStackPointer+12);
    } else {
        FaultingCS  = *(PWORD16)(VdmStackPointer+8);
        FaultingEip = (ULONG)*(PWORD16)(VdmStackPointer+6);
    }

    wsprintf(szBuffer, "X#=%.02X, CS=%.04X IP=%.08X",
                            XNumber, FaultingCS, FaultingEip);

    RcErrorDialogBox(EG_BAD_FAULT, szBuffer, NULL);

    //
    // Need to try to ignore it. Since we are on a dpmi exception frame
    // we can just simulate a retf.
    //
    if (Frame32) {
        setCS((USHORT)*(PDWORD16)(VdmStackPointer+4));
        setEIP(*(PDWORD16)(VdmStackPointer));
        setESP(getESP() + 8);
    } else {
        setCS(*(PWORD16)(VdmStackPointer+2));
        setEIP((DWORD)*(PWORD16)(VdmStackPointer));
        setSP(getSP() + 4);
    }
}

VOID
DpmiInitPmStackInfo(
    VOID
    )
/*++

Routine Description:

    This routine is called via BOP by DOSX to initialize values related
    to stack handling.

Arguments:

    Client ES = selector of locked PM stack

Return Value:

    None

Notes:

    The offset of the locked pm stack is hard-coded to 0x1000, per dpmi
    and win31.

--*/
{
    DECLARE_LocalVdmContext;

    LockedPMStackSel = getES();
    LockedPMStackCount = 0;

#ifdef _X86_
    ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.Flags = CurrentAppFlags;
#endif
}

BOOL
DpmiSwIntHandler(
    ULONG IntNumber
    )
/*++

Routine Description:

    This routine is called by the emulator to dispatch a SW interrupt.

Arguments:

    IntNumber - interrupt vector number

Return Value:

    TRUE if the interrupt was dispatched, FALSE otherwise

--*/

{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    PUCHAR VdmStackPointer;
    ULONG SaveEFLAGS;
    ULONG NewSP;

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_SW_INT, (USHORT)IntNumber, 0);

    //
    // If we're here via breakpoint, see if it belongs to NTVDM debug code.
    //
    if ((IntNumber == 3) &&
        (*(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) & VDM_BREAK_DEBUGGER) &&
        DbgBPInt()) {
        return TRUE;
    }


    if (!(getMSW() & MSW_PE)) {

        EmulateV86Int((UCHAR)IntNumber);

    } else {
        PUCHAR VdmStackPointer;

        // Protect mode
        SaveEFLAGS = getEFLAGS();
        //BUGBUG turn off task bits
        SaveEFLAGS &= ~EFLAGS_NT_MASK;
        setEFLAGS(SaveEFLAGS & ~EFLAGS_TF_MASK);

        if (!SEGMENT_IS_PRESENT(Handlers[IntNumber].CsSelector)) {
            return FALSE;
        }

        if (!BuildStackFrame(3, &VdmStackPointer, &NewSP)) {
            return FALSE;
        }

        if (Frame32) {

            *(PDWORD16)(VdmStackPointer-4) =  SaveEFLAGS;
            *(PDWORD16)(VdmStackPointer-8) =  getCS();
            *(PDWORD16)(VdmStackPointer-12) = getEIP();
            setEIP(Handlers[IntNumber].Eip);
            setESP(NewSP);

        } else {

            *(PWORD16)(VdmStackPointer-2) = (WORD) SaveEFLAGS;
            *(PWORD16)(VdmStackPointer-4) = (WORD) getCS();
            *(PWORD16)(VdmStackPointer-6) = (WORD) getEIP();
            setEIP((DWORD)LOWORD(Handlers[IntNumber].Eip));
            setSP((WORD)NewSP);

        }

        setCS(Handlers[IntNumber].CsSelector);

#if DBG
        if (Handlers[IntNumber].CsSelector != getCS()) {
            char szFormat[] = "NTVDM Dpmi Error! Can't set CS to %.4X\n";
            char szMsg[sizeof(szFormat)+30];

            wsprintf(szMsg, szFormat, Handlers[IntNumber].CsSelector);
            OutputDebugString(szMsg);
        }
#endif
    }

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_INT, (USHORT)IntNumber, 0);
    return TRUE;
}

BOOL
DpmiHwIntHandler(
    ULONG IntNumber
    )

/*++

Routine Description:

    This routine is called by the emulator to dispatch a HW interrupt.

Arguments:

    IntNumber - interrupt vector number

Return Value:

    TRUE if the interrupt was dispatched, FALSE otherwise

--*/

{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    PUCHAR VdmStackPointer;
    ULONG SaveEFLAGS;
    ULONG NewSP;

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_HW_INT, (USHORT)IntNumber, 0);

    if (!(getMSW() & MSW_PE)) {

        EmulateV86Int((UCHAR)IntNumber);

    } else {
        PUCHAR VdmStackPointer;

        SaveEFLAGS = getEFLAGS();
        //BUGBUG turn off task bits
        SaveEFLAGS &= ~0x4000;
        setEFLAGS(SaveEFLAGS & ~(EFLAGS_IF_MASK | EFLAGS_TF_MASK));

        BeginUseLockedPMStack();

        if (!BuildStackFrame(6, &VdmStackPointer, &NewSP)) {
            EndUseLockedPMStack();
            return FALSE;
        }

        if (Frame32) {
            *(PDWORD16)(VdmStackPointer-4) = SaveEFLAGS;
            *(PDWORD16)(VdmStackPointer-8) = getCS();
            *(PDWORD16)(VdmStackPointer-12) = getEIP();
            *(PDWORD16)(VdmStackPointer-16) = getEFLAGS();
            *(PDWORD16)(VdmStackPointer-20) = (DWORD)HIWORD(DosxIntHandlerIretd);
            *(PDWORD16)(VdmStackPointer-24) = (DWORD)LOWORD(DosxIntHandlerIretd);
            setEIP(Handlers[IntNumber].Eip);
            setESP(NewSP);
        } else {
            *(PWORD16)(VdmStackPointer-2) = (WORD)SaveEFLAGS;
            *(PWORD16)(VdmStackPointer-4) = (WORD)getCS();
            *(PWORD16)(VdmStackPointer-6) = (WORD)getIP();
            *(PWORD16)(VdmStackPointer-8) = (WORD)getEFLAGS();
            *(PWORD16)(VdmStackPointer-10) = HIWORD(DosxIntHandlerIret);
            *(PWORD16)(VdmStackPointer-12) = LOWORD(DosxIntHandlerIret);
            setEIP((DWORD)LOWORD(Handlers[IntNumber].Eip));
            setSP((WORD)NewSP);
        }
        setCS(Handlers[IntNumber].CsSelector);
    }

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_INT, (USHORT)IntNumber, 0);
    return TRUE;
}


VOID
DpmiIntHandlerIret16(
    VOID
    )

/*++

Routine Description:

    This routine is an IRET hook called via a BOP in dosx. It is called
    at the end of a 16-bit HW or SW interrupt. The main reason we want
    to come in here is to maintain the DPMI stack, and know when to restore
    the original values when we pop back out to level zero.


--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    ULONG NewSP;
    USHORT SegSs;
    BOOL bSsBig;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);

    if (bSsBig = SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }

    //
    // Fast iret (without executing final 16-bit iret)
    //
#ifdef _X86_

    setCS(*(PWORD16)(VdmStackPointer+2));
    setEFLAGS((getEFLAGS()&0xffff0000) | *(PWORD16)(VdmStackPointer+4));

    //
    // if EndUseLockedPMStack fails, then we need to restore EIP and pop
    // the stack frame
    //

    if (!EndUseLockedPMStack()) {

        setEIP((DWORD)*(PWORD16)(VdmStackPointer));

        //
        // Pop iret frame off the stack
        //
        if (bSsBig) {
            setESP(getESP()+6);
        } else {
            setSP(getSP()+6);
        }
    }

    //
    // Slow iret (with executing final 16-bit iret)
    //
#else
    if (EndUseLockedPMStack()) {
        ULONG NewEIP, NewEFLAGS, NewCS;

        NewEIP    = getEIP();
        NewCS     = (ULONG) *(PWORD16)(VdmStackPointer+2);
        NewEFLAGS = (getEFLAGS()&0xffff0000) | *(PWORD16)(VdmStackPointer+4);

        //
        // Since EndUseLockedPMStack() has restored all of EIP, and we may be
        // returning to a 32-bit code segment, build a 32-bit iret frame
        // even if this is a 16-bit client. That way, EIP will be restored
        // correctly.
        // Pass 6 to BuildStackFrame since 6 words = 3 dwords
        //
        if (!BuildStackFrame(6, &VdmStackPointer, &NewSP)) {
#if DBG
            OutputDebugString("NTVDM: Dpmi encountered a stack fault!\n");
#endif
            DpmiFaultHandler(STACK_FAULT, 0);
            return;
        }

        //
        // SS has changed, so we need to check LDT again
        //
        if (SEGMENT_IS_BIG(getSS())) {
            setESP(NewSP);
        } else {
            setSP((WORD)NewSP);
        }

        *(PDWORD16)(VdmStackPointer-4)  = NewEFLAGS;
        *(PDWORD16)(VdmStackPointer-8)  = NewCS;
        *(PDWORD16)(VdmStackPointer-12) = NewEIP;
        setCS(HIWORD(DosxIretd));
        setEIP((ULONG)LOWORD(DosxIretd));

    } else {

        // still on locked stack, just do a real iret (16-bit frame)
        setCS(HIWORD(DosxIret));
        setEIP((ULONG)LOWORD(DosxIret));

    }
#endif // _X86_

}

VOID
DpmiIntHandlerIret32(
    VOID
    )

/*++

Routine Description:

    This routine is an IRET hook called via a BOP in dosx. It is called
    at the end of a 32-bit HW or SW interrupt. The main reason we want
    to come in here is to maintain the DPMI stack, and know when to restore
    the original values when we pop back out to level zero.


--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    ULONG NewSP;
    USHORT SegSs;
    BOOL bSsBig;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);

    if (bSsBig = SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }

#ifdef _X86_

    setCS(*(PDWORD16)(VdmStackPointer+4));
    setEFLAGS(*(PDWORD16)(VdmStackPointer+8));

    //
    // if EndUseLockedPMStack succeeds, then we don't need to restore EIP
    //

    if (!EndUseLockedPMStack()) {

        setEIP(*(PDWORD16)(VdmStackPointer));

        //
        // Pop iret frame off the stack
        //
        if (bSsBig) {
            setESP(getESP()+12);
        } else {
            setSP(getSP()+12);
        }
    }

#else
    if (EndUseLockedPMStack()) {
        ULONG NewEIP, NewCS, NewEFLAGS;

        NewEIP    = getEIP();
        NewCS     = *(PDWORD16)(VdmStackPointer+4);
        NewEFLAGS = *(PDWORD16)(VdmStackPointer+8);


        if (!BuildStackFrame(3, &VdmStackPointer, &NewSP)) {
#if DBG
            OutputDebugString("NTVDM: Dpmi encountered a stack fault!\n");
#endif
            DpmiFaultHandler(STACK_FAULT, 0);
            return;
        }

        //
        // SS has changed, so we need to check LDT again
        //
        if (SEGMENT_IS_BIG(getSS())) {
            setESP(NewSP);
        } else {
            setSP((WORD)NewSP);
        }

        *(PDWORD16)(VdmStackPointer-4) =  NewEFLAGS;
        *(PDWORD16)(VdmStackPointer-8) =  NewCS;
        *(PDWORD16)(VdmStackPointer-12) = NewEIP;
    }

    setCS(HIWORD(DosxIretd));
    setEIP((ULONG)LOWORD(DosxIretd));
#endif // _X86_

}

#ifndef _X86_

BOOL
DpmiFaultHandler(
    ULONG IntNumber,
    ULONG ErrorCode
    )

/*++

Routine Description:

    This routine is called by the emulator when an exception occurs.

Arguments:

    IntNumber - exception number (0-1f)
    ErrorCode - exception error code to be placed on the stack

Return Value:

    TRUE if the interrupt was dispatched, FALSE otherwise

--*/

{
    DECLARE_LocalVdmContext;
    PVDM_FAULTHANDLER Handlers = DpmiFaultHandlers;
    PUCHAR VdmStackPointer;
    ULONG SaveSS, SaveESP, SaveEFLAGS, SaveCS, SaveEIP;
    ULONG StackOffset;
    ULONG NewSP;

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_FAULT, (USHORT)IntNumber, ErrorCode);

    if ((IntNumber == 1)  &&
        (*(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) & VDM_BREAK_DEBUGGER) &&
        DbgTraceInt()) {
        return TRUE;
    }

    if (DbgFault(IntNumber)) {      // try the debugger
        //
        // exception handled via user input
        //
        return TRUE;
    }

    if (!(getMSW() & MSW_PE)) {
        EmulateV86Int((UCHAR)IntNumber);
        return TRUE;
    }

    SaveSS = getSS();
    SaveESP = getESP();
    SaveEFLAGS = getEFLAGS();
    SaveEIP = getEIP();
    SaveCS  = getCS();
    setEFLAGS(SaveEFLAGS & ~(EFLAGS_IF_MASK | EFLAGS_TF_MASK));

    if ((IntNumber == 13) || (IntNumber == 6)) {
        if (DpmiEmulateInstruction()) {
            return TRUE;
        }
    }

    if (!SEGMENT_IS_PRESENT(Handlers[IntNumber].CsSelector)) {
        return FALSE;
    }

    //
    // switch stacks
    //

    BeginUseLockedPMStack();

    //
    // Win31 has an undocumented feature of creating a 32byte area on the
    // stack. Krnl386 sticks stuff in there, so we emulate the behavior here.
    //

    setESP(getESP()-0x20);

    //
    // allocate space on new stack
    //

    if (!BuildStackFrame(8, &VdmStackPointer, &NewSP)) {
        //BUGBUG Check for double fault
        EndUseLockedPMStack();
        return FALSE;
    }

    if (Frame32) {
        *(PDWORD16)(VdmStackPointer-4) = SaveSS;
        *(PDWORD16)(VdmStackPointer-8) = SaveESP;
        *(PDWORD16)(VdmStackPointer-12) = SaveEFLAGS;
        *(PDWORD16)(VdmStackPointer-16) = SaveCS;
        *(PDWORD16)(VdmStackPointer-20) = SaveEIP;
        *(PDWORD16)(VdmStackPointer-24) = ErrorCode;
        *(PDWORD16)(VdmStackPointer-28) = (ULONG) HIWORD(DosxFaultHandlerIretd);
        *(PDWORD16)(VdmStackPointer-32) = (ULONG) LOWORD(DosxFaultHandlerIretd);
        setEIP(Handlers[IntNumber].Eip);
        setESP(NewSP);
    } else {
        *(PWORD16)(VdmStackPointer-2) = (WORD) SaveSS;
        *(PWORD16)(VdmStackPointer-4) = (WORD) SaveESP;
        *(PWORD16)(VdmStackPointer-6) = (WORD) SaveEFLAGS;
        *(PWORD16)(VdmStackPointer-8) = (WORD) SaveCS;
        *(PWORD16)(VdmStackPointer-10) = (WORD) SaveEIP;
        *(PWORD16)(VdmStackPointer-12) = (WORD) ErrorCode;
        *(PDWORD16)(VdmStackPointer-16) = DosxFaultHandlerIret;
        setEIP(LOWORD(Handlers[IntNumber].Eip));
        setSP((WORD)NewSP);
    }

    setCS(Handlers[IntNumber].CsSelector);

#if DBG
    if (Handlers[IntNumber].CsSelector != getCS()) {
        char szFormat[] = "NTVDM Dpmi Error! Can't set CS to %.4X\n";
        char szMsg[sizeof(szFormat)+30];

        wsprintf(szMsg, szFormat, Handlers[IntNumber].CsSelector);
        OutputDebugString(szMsg);
    }
#endif

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_FAULT, (USHORT)IntNumber, 0);
    return TRUE;
}

#endif // _X86_

VOID
DpmiFaultHandlerIret16(
    VOID
    )

/*++

Routine Description:

    This routine is an IRET hook called via a BOP in dosx. It is called
    at the end of the execution of a 16-bit fault handler.


--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    USHORT SegSs;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);
    if (SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }

    EndUseLockedPMStack();

    setEIP((DWORD)*(PWORD16)(VdmStackPointer+2));
    setCS(*(PWORD16)(VdmStackPointer+4));
    setSTATUS(*(PWORD16)(VdmStackPointer+6));
    setSP(*(PWORD16)(VdmStackPointer+8));
    setSS(*(PWORD16)(VdmStackPointer+10));

}

VOID
DpmiFaultHandlerIret32(
    VOID
    )

/*++

Routine Description:

    This routine is an IRET hook called via a BOP in dosx. It is called
    at the end of the execution of a 32-bit fault handler.


--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    USHORT SegSs;

    SegSs = getSS();
    VdmStackPointer = Sim32GetVDMPointer(SegSs<<16, 1, TRUE);
    if (SEGMENT_IS_BIG(SegSs)) {
        VdmStackPointer += getESP();
    } else {
        VdmStackPointer += getSP();
    }


    EndUseLockedPMStack();

    setEIP(*(PDWORD16)(VdmStackPointer+4));
    setCS((USHORT)*(PDWORD16)(VdmStackPointer+8));
    setEFLAGS(*(PDWORD16)(VdmStackPointer+12));
    setESP(*(PDWORD16)(VdmStackPointer+16));
    setSS((USHORT)*(PWORD16)(VdmStackPointer+20));

}


VOID
DpmiHungAppIretAndExit(
    VOID
    )
/*++

Routine Description:

    This routine is called via BOP during hung app processing. The
    Keyboard driver calls this in the context of a hw interrupt in
    order to terminate the app. We need to "unwind" the current
    interrupt, and transfer control to code which will execute
    a DOS exit.

--*/

{
    DECLARE_LocalVdmContext;

    EndUseLockedPMStack();
    setCS(HIWORD(DosxHungAppExit));
    setIP(LOWORD(DosxHungAppExit));
}

BOOL
DispatchPMInt(
    UCHAR IntNumber
    )
/*++

Routine Description:

    This routine is called at the end of a PM int chain. It is provided
    for compatibility to win31/win95. On win31/win95, VMM and VxD's have
    the opportunity to perform some functionality at the point where
    the dpmi host is about to switch the machine to v86 mode to continue
    the interrupt chain. Sometimes, the function is totally handled by
    a hook at this point.

    This routine provides a framework for this mechanism to allow the
    emulation of this behavior.

Arguments:

    IntNumber - the interrupt# that is about to be reflected to v86 mode

Return Value:

    TRUE if the interrupt was handled and control can return to the app
    FALSE otherwise, continue the reflection to v86 mode.

--*/

{
    BOOL bHandled;

    switch(IntNumber) {

    case 0x2f:

        bHandled = PMInt2fHandler();
        break;

    default:
        bHandled = FALSE;
    }

    if (bHandled) {
        SimulateIret(RESTORE_FLAGS);
    }
    return bHandled;

}


BOOL
CheckEIP(
    ULONG Increment
    )
/*++

Routine Description:

    This routine does a limit check on EIP.

Arguments:

    None

Return Value:

    TRUE if EIP is ok, FALSE otherwise

--*/

{
    //BUGBUG NEED TO RETURN FALSE HERE IF EIP WOULD BE OFF THE END OF SEGMENT
    return TRUE;
}

#ifndef _X86_
BOOL
DpmiEmulateInstruction(
    VOID
    )
/*++

Routine Description:

    This routine checks to see if the instruction which caused the
    fault really needs to be emulated. For example, the MS C compiler (v7.00)
    uses instructions to manipulate the FP flags in CR0. The compiler
    expects them to just work as they do on win31, which also emulates them.

Arguments:

    None

Return Value:

    TRUE if the instruction was emulated, FALSE otherwise

--*/

{
    DECLARE_LocalVdmContext;
    PUCHAR pCode;
    UCHAR Opcode;
    ULONG SegCS;
    BOOL bReturn = FALSE;

    SegCS = getCS();
    pCode = Sim32GetVDMPointer(SegCS<<16, 1, TRUE);

    if (Ldt[(SegCS & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
        pCode += getEIP();
    } else {
        pCode += getIP();
    }

    Opcode = *pCode++;
    switch (Opcode) {
        case 0xf:
            if (!CheckEIP(1)) {
                break;
            }
            bReturn = DpmiOp0f(pCode);
            break;

        case 0x8e:
            //
            // This is WIN31 compatibility. If we are trying to dispatch
            // the client, and we get a fault loading the segment registers,
            // then zero them out.
            // BUGBUG currently only looking for FS, GS
            //
            if (!CheckEIP(2)) {
                break;
            }
            //
            // Look for code in dxutil.asm EnterProtectedMode
            //
            if ((SegCS == DosxRmCodeSelector) &&
                ((*pCode == 0xe0)  ||               // mov fs, ax
                 (*pCode == 0xe8))                  // mov gs, ax
                    ) {
                setEIP(getEIP()+2);
                bReturn = TRUE;
            }
            break;
    }

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_OP_EMULATION, Opcode, (ULONG) bReturn);
    return bReturn;
}

#define MI_GET_CRx_OPCODE 0x20
#define MI_SET_CRx_OPCODE 0x22
#define MI_MODMASK 0xC0
#define MI_MODMOVSPEC 0xC0
#define MI_REGMASK 0x38
#define MI_RMMASK  0x7

BOOL
DpmiOp0f(
    PUCHAR pCode
    )
/*++

Routine Description:

    This routine emulates instructions that have 0x0F as the first byte.

Arguments:

    None

Return Value:

    TRUE if the instruction was emulated, FALSE otherwise

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Value;

    switch (*pCode++) {
        case MI_GET_CRx_OPCODE:

            if (!CheckEIP(2)) {
                break;
            }

            if ((*pCode & MI_MODMASK) != MI_MODMOVSPEC) {
                break;
            }

            if (*pCode & MI_REGMASK) {
                Value = 0;              // not CR0
            } else {
                Value = getCR0();
            }

            SetRegisterByIndex[*pCode & MI_RMMASK](Value);
            setEIP(getEIP()+3);
            return TRUE;

        case MI_SET_CRx_OPCODE:

            if (!CheckEIP(2)) {
                break;
            }

            if ((*pCode & MI_MODMASK) != MI_MODMOVSPEC) {
                break;
            }

            if (*pCode & MI_REGMASK) {
                break;                  // not CR0
            }

            setCR0(GetRegisterByIndex[*pCode & MI_RMMASK]());
            setEIP(getEIP()+3);
            return TRUE;
    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\dpmi32.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmi32.c

Abstract:

    This function contains common code such as the dpmi dispatcher,
    and handling for the initialization of the dos extender.

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include <intapi.h>

//
// DPMI dispatch table
//
VOID (*DpmiDispatchTable[MAX_DPMI_BOP_FUNC])(VOID) = {
    DpmiInitDosxRM,                             // 0
    DpmiInitDosx,                               // 1
    DpmiInitLDT,                                // 2
    DpmiGetFastBopEntry,                        // 3
    DpmiInitIDT,                                // 4
    DpmiInitExceptionHandlers,                  // 5
    DpmiInitApp,                                // 6
    DpmiTerminateApp,                           // 7
    DpmiDpmiInUse,                              // 8
    DpmiDpmiNoLongerInUse,                      // 9

    switch_to_protected_mode,                   // 10 (DPMISwitchToProtectedMode)
    switch_to_real_mode,                        // 11 (DPMISwitchToRealMode)
    DpmiSetAltRegs,                             // 12

    DpmiIntHandlerIret16,                       // 13
    DpmiIntHandlerIret32,                       // 14
    DpmiFaultHandlerIret16,                     // 15
    DpmiFaultHandlerIret32,                     // 16
    DpmiUnhandledExceptionHandler,              // 17

    DpmiRMCallBackCall,                         // 18
    DpmiReflectIntrToPM,                        // 19
    DpmiReflectIntrToV86,                       // 20

    DpmiInitPmStackInfo,                        // 21
    DpmiVcdPmSvcCall32,                         // 22
    DpmiSetDescriptorEntry,                     // 23
    DpmiResetLDTUserBase,                       // 24

    DpmiXlatInt21Call,                          // 25
    DpmiInt31Entry,                             // 26
    DpmiInt31Call,                              // 27

    DpmiHungAppIretAndExit                      // 28
};


VOID
DpmiDispatch(
    VOID
    )
/*++

Routine Description:

    This function dispatches to the appropriate subfunction

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Index;
    static USHORT NestLevel = 0;

    Index = *(PUCHAR)VdmMapFlat(getCS(), getIP(), getMODE());

    setIP((getIP() + 1));           // take care of subfn.

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_ENTRY, NestLevel++, Index);

    if (Index >= MAX_DPMI_BOP_FUNC) {
        //BUGBUG IMHO, we should fatal exit here
#if DBG
        DbgPrint("NtVdm: Invalid DPMI BOP %lx\n", Index);
#endif
        return;
    }

    (*DpmiDispatchTable[Index])();

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_DISPATCH_EXIT, --NestLevel, Index);
}


VOID
DpmiIllegalFunction(
    VOID
    )
/*++

Routine Description:

    This routine ignores any Dpmi bops that are not implemented on a
    particular platform. It is called through the DpmiDispatchTable
    by #define'ing individual entries to this function.
    See dpmidata.h and dpmidatr.h.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
   char szFormat[] = "NtVdm: Invalid DPMI BOP from CS:IP %4.4x:%4.4x (%s mode), could be i386 dosx.exe.\n";
   char szMsg[sizeof(szFormat)+64];

   wsprintf(
       szMsg,
       szFormat,
       (int)getCS(),
       (int)getIP(),
       (getMSW() & MSW_PE) ? "prot" : "real"
       );

   OutputDebugString(szMsg);
}

VOID
DpmiInitDosxRM(
    VOID
    )
/*++

Routine Description:

    This routine handles the RM initialization bop for the dos extender.
    It get the addresses of the structures that the dos extender and
    32 bit code share.

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PDOSX_RM_INIT_INFO pdi;

    ASSERT(!(getMSW() & MSW_PE));

    pdi = (PDOSX_RM_INIT_INFO) VdmMapFlat(getDS(), getSI(), VDM_V86);

    DosxStackFrameSize    = pdi->StackFrameSize;

    RmBopFe = pdi->RmBopFe;
    PmBopFe = pdi->PmBopFe;

    DosxStackSegment      = pdi->StackSegment;
    DosxRmCodeSegment     = pdi->RmCodeSegment;
    DosxRmCodeSelector    = pdi->RmCodeSelector;

    DosxFaultHandlerIret  = pdi->pFaultHandlerIret;
    DosxFaultHandlerIretd = pdi->pFaultHandlerIretd;
    DosxIntHandlerIret    = pdi->pIntHandlerIret;
    DosxIntHandlerIretd   = pdi->pIntHandlerIretd;
    DosxIret              = pdi->pIret;
    DosxIretd             = pdi->pIretd;
    DosxRMReflector       = pdi->RMReflector;

    RMCallBackBopOffset   = pdi->RMCallBackBopOffset;
    RMCallBackBopSeg      = pdi->RMCallBackBopSeg;
    PMReflectorSeg        = pdi->PMReflectorSeg;

    DosxRmSaveRestoreState= pdi->RmSaveRestoreState;
    DosxPmSaveRestoreState= pdi->PmSaveRestoreState;
    DosxRmRawModeSwitch   = pdi->RmRawModeSwitch;
    DosxPmRawModeSwitch   = pdi->PmRawModeSwitch;

    DosxVcdPmSvcCall      = pdi->VcdPmSvcCall;
    DosxMsDosApi          = pdi->MsDosApi;
    DosxXmsControl        = pdi->XmsControl;

    DosxHungAppExit       = pdi->HungAppExit;

    //
    // Load the temporary LDT info (updated in DpmiInitLDT())
    //
    Ldt       = VdmMapFlat(pdi->InitialLDTSeg, 0, VDM_V86);
    LdtMaxSel = pdi->InitialLDTSize;

#ifdef _X86_
    //
    // On x86 platforms, return the fast bop address
    //
    GetFastBopEntryAddress(&((PVDM_TIB)NtCurrentTeb()->Vdm)->VdmContext);
#endif

}

VOID
DpmiInitDosx(
    VOID
    )
/*++

Routine Description:

    This routine handles the PM initialization bop for the dos extender.
    It get the addresses of the structures that the dos extender and
    32 bit code share.

    Note: These values are initialized here since they are FLAT pointers,
    and are thus not easily computed at the time of InitDosxRM.

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PDOSX_INIT_INFO pdi;

    ASSERT((getMSW() & MSW_PE));

    pdi = (PDOSX_INIT_INFO) VdmMapFlat(getDS(), getSI(), VDM_PM);

    SmallXlatBuffer = Sim32GetVDMPointer(pdi->pSmallXlatBuffer, 4, TRUE);
    LargeXlatBuffer = Sim32GetVDMPointer(pdi->pLargeXlatBuffer, 4, TRUE);
    DosxDtaBuffer   = Sim32GetVDMPointer(pdi->pDtaBuffer, 4, TRUE);

    DosxStackFramePointer = (PWORD16)((PULONG)Sim32GetVDMPointer(
                                     pdi->pStackFramePointer, 4, TRUE));

}

VOID
DpmiInitApp(
    VOID
    )
/*++

Routine Description:

    This routine handles any necessary 32 bit initialization for extended
    applications.

Arguments:

    None.

Return Value:

    None.

Notes:

    This function contains a number of 386 specific things.
    Since we are likely to expand the 32 bit portions of DPMI in the
    future, this makes more sense than duplicating the common portions
    another file.

--*/
{
    DECLARE_LocalVdmContext;
    PWORD16 Data;

    Data = (PWORD16) VdmMapFlat(getSS(), getSP(), VDM_PM);

    // Only 1 bit defined in dpmi
    CurrentAppFlags = getAX() & DPMI_32BIT;
#ifdef _X86_
    ((PVDM_TIB)NtCurrentTeb()->Vdm)->DpmiInfo.Flags = CurrentAppFlags;
    if (CurrentAppFlags & DPMI_32BIT) {
        *pNtVDMState |= VDM_32BIT_APP;
    }
#endif

    DpmiInitRegisterSize();

    CurrentDta = Sim32GetVDMPointer(
        *(PDWORD16)(Data),
        1,
        TRUE
        );

    CurrentDosDta = (PUCHAR) NULL;

    CurrentDtaOffset = *Data;
    CurrentDtaSelector = *(Data + 1);
    CurrentPSPSelector = *(Data + 2);
}

VOID
DpmiTerminateApp(
    VOID
    )
/*++

Routine Description:

    This routine handles any necessary 32 bit destruction for extended
    applications.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/
{
    DpmiFreeAppXmem();
    CurrentPSPSelector = 0;                     // indicate no running app
}


VOID
DpmiEnableIntHooks(
    VOID
    )

/*++

Routine Description:

    This routine is called very early on in NTVDM initialization. It
    gives the dpmi code a chance to do some startup stuff before any
    client code has run.

    This is not called via bop.

Arguments:

    None

Return Value:

    None.

--*/

{
#ifndef _X86_
    IntelBase = (ULONG) VdmMapFlat(0, 0, VDM_V86);
    VdmInstallHardwareIntHandler(DpmiHwIntHandler);
    VdmInstallSoftwareIntHandler(DpmiSwIntHandler);
    VdmInstallFaultHandler(DpmiFaultHandler);
#endif // _X86_
}

#ifdef DBCS
VOID
DpmiSwitchToDosxStack(
    VOID
    )
{
    DECLARE_LocalVdmContext;

    SWITCH_TO_DOSX_RMSTACK();
}
VOID
DpmiSwitchFromDosxStack(
    VOID
    )
{
    DECLARE_LocalVdmContext;

    SWITCH_FROM_DOSX_RMSTACK();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\dpmiselr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmiselr.c

Abstract:

    This is the code for maintaining descriptor data for dpmi32.

Author:

    Dave Hart (davehart) 11-Apr-1993

Notes:


Revision History:

    09-Feb-1994 (daveh)
        Moved here from not386.c.
    31-Jul-1995 (neilsa)
        Merged with x86 source
    12-Dec-1995 (neilsa)
        Wrote VdmAddDescriptorMapping(), GetDescriptorMapping

--*/

#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include "malloc.h"

#ifndef _X86_
PDESC_MAPPING pDescMappingHead = NULL;
#endif // _X86_

USHORT selLDTFree = 0;


VOID
DpmiSetDescriptorEntry(
    VOID
    )
/*++

Routine Description:

    This function is called via BOP by dosx to set the flataddress
    array and, if on x86, the real LDT maintained by the kernel.

Arguments:

    None

Return Value:

    None.

--*/

{
    DECLARE_LocalVdmContext;
    USHORT SelCount;
    USHORT SelStart;

    SelStart = getAX();
    if (SelStart % 8) {
        return;
    }

    SelCount =  getCX();
    SetShadowDescriptorEntries(SelStart, SelCount);
    // no need to flush the cache on risc since the ldt was changed
    // from the 16-bit side, and has thus already been flushed
}

VOID
SetDescriptor(
    USHORT Sel,
    ULONG Base,
    ULONG Limit,
    USHORT Access
    )
/*++

Routine Description:


Arguments:

    None

Return Value:

    None.

--*/
{

    SET_SELECTOR_ACCESS(Sel, Access);
    SET_SELECTOR_LIMIT(Sel, Limit);
    SetDescriptorBase(Sel, Base);

}

VOID
SetDescriptorBase(
    USHORT Sel,
    ULONG Base
    )
/*++

Routine Description:


Arguments:

    None

Return Value:

    None.

--*/
{
    LDT_ENTRY UNALIGNED *Descriptor;

    // make it qword aligned
    Sel &= SEL_INDEX_MASK;

    Descriptor = &Ldt[Sel>>3];

    Descriptor->BaseLow = (WORD) Base;
    Descriptor->HighWord.Bytes.BaseMid = (BYTE) (Base >> 16);
    Descriptor->HighWord.Bytes.BaseHi = (BYTE) (Base >> 24);

    SetShadowDescriptorEntries(Sel, 1);
    FLUSH_SELECTOR_CACHE(Sel, 1);
}

VOID
SetShadowDescriptorEntries(
    USHORT SelStart,
    USHORT SelCount
    )
/*++

Routine Description:

    This function takes as a parameter an array of descriptors
    directly out of the LDT in the clients address space.
    For each descriptor in the array, it does three things:

    - It extracts the descriptor base and sets it into the FlatAddress
      array. This value may be adjusted on RISC platforms to account
      for DIB.DRV (see VdmAddDescriptorMapping).
    - It extracts the selector limit, and adjusts the limit in the
      descriptor itself if the values would cause the descriptor to
      be able to access kernel address space (see note below). On debug
      builds, the limit is also copied to the Limit array.
    - On x86 builds, it calls DpmiSetX86Descriptor() to write the
      descriptor down to the real LDT in the kernel. On RISC builds,
      it calls down to the emulator to flush compiled LDT entries.

Arguments:

    SelStart - Selector which identifies the first descriptor
    SelCount - number of descriptors to process
    Descriptors -> first descriptor in LDT

Return Value:

    None.

--*/

{
    USHORT i;
    ULONG  Base;
    ULONG Limit;
    USHORT Sel = SelStart;

    for (i = 0; i < SelCount; i++, Sel+=8) {

        // form Base and Limit values

        Base = GET_SELECTOR_BASE(Sel);
        Limit = GET_SELECTOR_LIMIT(Sel);

        //
        // Do NOT remove the following code.  There are several apps that
        // choose arbitrarily high limits for theirs selectors.  This works
        // under windows 3.1, but NT won't allow us to do that.
        // The following code fixes the limits for such selectors.
        // Note: if the base is > 0x7FFEFFFF, the selector set will fail
        //

        if (Base !=0) {
            if ((Limit > 0x7FFEFFFF) || (Base + Limit > 0x7FFEFFFF)) {
                Limit = 0x7FFEFFFF - (Base + 0xFFF);
                SET_SELECTOR_LIMIT(Sel, Limit);
            }
        }

        if ((Sel >> 3) != 0) {
#ifndef _X86_
            {
                ULONG BaseOrig = Base;
                Base = GetDescriptorMapping(Sel, Base);
                if (BaseOrig == Base) {
                    Base += (ULONG)IntelBase;
                }
            }
#endif

            FlatAddress[Sel >> 3] = Base;
#if DBG
            SelectorLimit[Sel >> 3] = Limit;
#endif
        }
    }

#ifdef _X86_
    if (!DpmiSetX86Descriptor(SelStart, SelCount)) {
        return;
    }
#endif
}


#ifndef _X86_
VOID
FlushSelectorCache(
    USHORT  SelStart,
    USHORT  SelCount
    )
{
    DECLARE_LocalVdmContext;
    USHORT SelEnd;
    USHORT Sel;
    USHORT i;

    VdmTraceEvent(VDMTR_TYPE_DPMI | DPMI_GENERIC, SelStart, SelCount);

    //
    // The emulator compiles LDT entries, so we need to flush them
    // out
    //

    for (i = 0, Sel = SelStart; i < SelCount; i++, Sel += 8) {
        VdmFlushCache(LdtSel, Sel & SEL_INDEX_MASK, 8, VDM_PM);
    }

    SelEnd = SelStart + SelCount*8;

    Sel = getCS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setCS(Sel);
    }

    Sel = getDS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setDS(Sel);
    }

    Sel = getES();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setES(Sel);
    }

    Sel = getFS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setFS(Sel);
    }

    Sel = getGS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setGS(Sel);
    }

    Sel = getSS();
    if ((Sel >= SelStart) && (Sel < SelEnd)) {
        setSS(Sel);
    }


}
#endif



//
// Descriptor Mapping functions (RISC ONLY)
//
#ifndef _X86_

BOOL
VdmAddDescriptorMapping(
    USHORT SelectorStart,
    USHORT SelectorCount,
    ULONG LdtBase,
    ULONG Flat
    )
/*++

Routine Description:

    This function was added to support the DIB.DRV implementation on RISC.
    When an app uses DIB.DRV, then the situation arises where the Intel
    linear base address + the flat address of the start of the Intel address
    space does NOT equal the flat address of the memory. This happens when
    the VdmAddVirtualMemory() api is used to set up an additional layer of
    indirection for memory addressing in the emulator.

    But there is more to the story. When app wants to use CreateDIBSection
    via WinG we also need to map selectors, thus this routine should not
    depend upon DpmiSetDesctriptorEntry being called afterwards. Thus, we go
    and zap the flat address table with the new address.

Arguments:

    SelectorStart, Count - range of selectors involved in the mapping
    LdtBase              - Intel base of start of range
    Flat                 - True flat address base to be used for these selectors

Return Value:

    This function returns TRUE on success, or FALSE for failure (out of mem)

--*/

{
    PDESC_MAPPING pdm;
    USHORT i;

    if ((pdm = (PDESC_MAPPING) malloc(sizeof (DESC_MAPPING))) == NULL)
                return FALSE;

    pdm->Sel         = SelectorStart &= SEL_INDEX_MASK;
    pdm->SelCount    = SelectorCount;
    pdm->LdtBase     = LdtBase;
    pdm->FlatBase    = Flat;
    pdm->pNext       = pDescMappingHead;
    pDescMappingHead = pdm;

    // this code does what essentially desctribed in comment above
    for (i = 0; i < SelectorCount; ++i) {
        FlatAddress[(SelectorStart >> 3) + i] = Flat + 65536 * i;
    }

    return TRUE;
}

ULONG
GetDescriptorMapping(
    USHORT sel,
    ULONG LdtBase
    )
/*++

Routine Description:


Arguments:

    sel     - the selector for which the base should be returned
    LdtBase - the base for this selector as is set currently in the LDT

Return Value:

    The true flat address for the specified selector.

--*/
{
    PDESC_MAPPING pdm, pdmprev;
    ULONG Base = LdtBase;

    sel &= SEL_INDEX_MASK;                  // and off lower 3 bits
    pdm = pDescMappingHead;

    while (pdm) {

        if ((sel >= pdm->Sel) && (sel < (pdm->Sel + pdm->SelCount*8))) {
            //
            // We found a mapping for this selector. Now check to see if
            // the ldt base still matches the base when the mapping was
            // created.
            //
            if (LdtBase == (pdm->LdtBase + 65536*((sel-pdm->Sel)/8))) {
                //
                // The mapping appears still valid. Return the remapped address
                //
                return (pdm->FlatBase + 65536*((sel-pdm->Sel)/8));

            } else {
                //
                // The ldt base doesn't match the mapping, so the mapping
                // must be obselete. Free the mapping here.
                //
                if (pdm == pDescMappingHead) {
                    //
                    // mapping is the first in the list
                    //
                    pDescMappingHead = pdm->pNext;

                } else {
                    pdmprev->pNext = pdm->pNext;
                }
                free(pdm);
            }

            break;
        }
        pdmprev = pdm;
        pdm = pdm->pNext;

    }

    return Base;
}

#endif // _X86_

//
// LDT Management routines
//

VOID
DpmiInitLDT(
    VOID
    )
/*++

Routine Description:

    This routine stores the flat address for the LDT table in the 16bit
    land (pointed to by selGDT in 16bit land).

    It also initializes the free selector chain.

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Sel;

    //
    // Get the new LDT location
    //

    LdtSel = getAX();
    Ldt = (PVOID)VdmMapFlat(LdtSel, 0, VDM_PM);
    LdtMaxSel = getCX();

    if (!LdtUserSel) {
        LdtUserSel = getDI() & SEL_INDEX_MASK;
    }

    //
    // Initialize the LDT free list
    //

    selLDTFree = LdtUserSel;

    for (Sel = selLDTFree; Sel < (LdtMaxSel & SEL_INDEX_MASK); Sel += 8) {
        NEXT_FREE_SEL(Sel) = Sel+8;
        MARK_SELECTOR_FREE(Sel);
    }

    NEXT_FREE_SEL(Sel) = 0xffff;

}

VOID
DpmiResetLDTUserBase(
    VOID
    )
/*++

Routine Description:

    This routine can hopefully be eliminated at a later date. The flow of
    dosx initialization has made this necessary. What happens is this:
    Earlier, dosx has called up to dpmi32 to initialize the LDT (DpmiInitLDT),
    where it sets the start of the user are of the LDT, and from there,
    sets up the linked list of free LDT entries. But after that time, and
    before an app is run, there are pieces of dosx code which allocate
    selectors that are not transient. In particular, DXNETBIO does an
    AllocateLowSegment(), which is totally unecessary on NT, but it a
    bit tricky to rework. So what is happening here is a reset of the
    start of the user area of the LDT to permanently reserve any selectors
    that are not free.

Arguments:

    None

Return Value:

    None.

--*/
{
    LdtUserSel = selLDTFree;
}


VOID
DpmiAllocateSelectors(
    VOID
    )
//
// This routine is called via BOP by those routines in DOSX
// that still need to allocate selectors.
//
{
    DECLARE_LocalVdmContext;
    USHORT Sel;

    Sel = ALLOCATE_SELECTORS(getAX());
    if (!Sel) {
        setCF(1);
    } else {
        setAX(Sel);
        setCF(0);
    }
}

VOID
DpmiFreeSelector(
    VOID
    )
//
// This routine is called via BOP by those routines in DOSX
// that still need to free selectors.
//
{
    DECLARE_LocalVdmContext;

    if (FreeSelector(getAX())) {
        setCF(0);
    } else {
        setCF(1);
    }
}



BOOL
RemoveFreeSelector(
    USHORT Sel
    )
/*++

Routine Description:

    This routine removes a specific selector from the free
    selector chain.

Arguments:

    Sel   - the selector to be aquired

Return Value:

    Returns TRUE if the function was successful, FALSE if it
    was an invalid selector (not free)

--*/
{

    if (!IS_SELECTOR_FREE(Sel)) {
        return FALSE;
    }

    if (Sel == selLDTFree) {
        //
        // we are removing the head of the list
        //
        selLDTFree = NEXT_FREE_SEL(Sel);

    } else {
        USHORT SelTest;
        USHORT SelPrev = 0;

        SelTest = selLDTFree;
        while (SelTest != Sel) {
            if (SelTest == 0xffff) {
                // End of list
                return FALSE;
            }

            SelPrev = SelTest;
            SelTest = NEXT_FREE_SEL(SelTest);
        }
        NEXT_FREE_SEL(SelPrev) = NEXT_FREE_SEL(Sel);
    }

    MARK_SELECTOR_ALLOCATED(Sel);
    return TRUE;

}

USHORT
AllocateSelectors(
    USHORT Count,
    BOOL bWow
    )
/*++

Routine Description:

    This routine allocates selectors from the free selector chain.

Arguments:

    Count - number of selectors needed. If this is more than 1, then
            all selectors will be contiguous
    bWow  - if true, then use an allocation scheme that is more typical
            of win31 behavior. This is to avoid problems where winapps
            accidentally rely on the value of selectors

Return Value:

    Returns the starting selector of the block, or zero if the
    allocation failed.

--*/
{
    USHORT Sel;

    if (!Count || (Count>=(LdtMaxSel>>3))) {
        return 0;
    }

    if (Count == 1) {

        //
        // Allocating 1 selector
        //

        if ((Sel = selLDTFree) != 0xffff) {

            // Move next selector to head of list
            selLDTFree = NEXT_FREE_SEL(Sel);
            MARK_SELECTOR_ALLOCATED(Sel);
            return (Sel | SEL_LDT3);
        }

    } else {

        //
        // Allocating a selector block
        //
        // *******************************************************
        // The strategy of allocating selectors has been modified to
        // give preference to selector values above 1000h. This is an
        // attempt to emulate typical values that are returned by win31.
        //  -neilsa
        //
        // Some DPMI DOS applications demand that all selectors(no matter it comes
        // from AllocateLDTSelector or this function) be contiguous, so
        // the strategy for WOW doesn't work for DPMI DOS applications.
        // For this reason, a new parameter is added so the caller can control
        // where to start searching for free selectors.
        // -williamh
        //
#define SEL_START_HI 0x1000

        USHORT SelTest;
        USHORT SelStart = LdtUserSel;
        USHORT SelEnd = LdtMaxSel;
        BOOL bAllFree;

        if (bWow) {
            SelStart = SEL_START_HI;
        }

asrestart:

        for (Sel = SelStart; Sel < (SelEnd - Count*8); Sel += 8) {

            bAllFree = TRUE;
            for (SelTest = Sel; SelTest < Sel + Count*8; SelTest += 8) {

                if (!IS_SELECTOR_FREE(SelTest)) {
                    bAllFree = FALSE;
                    break;
                }

            }

            if (bAllFree) {
                //
                // Found a block. Now we need to peel off the chain from
                // the free list
                //
                int i;

                for (i = 0, SelTest = Sel; i < Count; i++, SelTest+=8) {

                    RemoveFreeSelector(SelTest);

                }
                return (Sel | SEL_LDT3);
            }
        }

        if (bWow && (SelEnd == LdtMaxSel)) {
            //
            // First pass for WOW complete, do it again
            //
            SelStart = LdtUserSel;
            SelEnd = SEL_START_HI + Count;
            goto asrestart;

        }
    }
    return 0;

}

BOOL
FreeSelector(
    USHORT Sel
    )
/*++

Routine Description:

    This routine returns a selector to the free selector chain.

Arguments:

    Sel   - the selector to be freed

Return Value:

    Returns TRUE if the function was successful, FALSE if it
    was an invalid selector (already free, reserved selector)

--*/
{
    if ((Sel < LdtUserSel) || (Sel > LdtMaxSel) ||
        IS_SELECTOR_FREE(Sel)) {
        //
        // invalid selector
        //
        return FALSE;
    }

    //
    // chain selector to head of free list
    //
    NEXT_FREE_SEL(Sel) = selLDTFree;
    selLDTFree = Sel & SEL_INDEX_MASK;

    MARK_SELECTOR_FREE(Sel);

    return TRUE;
}

USHORT
FindSelector(
    ULONG Base,
    UCHAR Access
    )
/*++

Routine Description:

    This routine looks for a selector that matches the base and access
    rights passed as arguments.

Arguments:

    Base  - Base address to compare.
    Access- Access rights byte to compare.

Return Value:

    Returns the selector that matches, or zero if the
    allocation failed.

--*/
{

    USHORT Sel;
    ULONG Limit;

    for (Sel = LdtUserSel; Sel < LdtMaxSel; Sel+=8) {

        if (!IS_SELECTOR_FREE(Sel)) {

            GET_SHADOW_SELECTOR_LIMIT(Sel, Limit);

            if ((Limit == 0xffff) && (Base == GET_SELECTOR_BASE(Sel)) &&
                ((Access & ~AB_ACCESSED) ==
                 (Ldt[Sel>>3].HighWord.Bytes.Flags1 & ~AB_ACCESSED))) {

                return (Sel | SEL_LDT3);

            }

        }

    }

    return 0;

}

USHORT
SegmentToSelector(
    USHORT Segment,
    USHORT Access
    )
/*++

Routine Description:

    This routine either finds or creates selector that can access the
    specified low memory segment.

Arguments:

    Segment- Paragraph segment address
    Access - Access rights

Return Value:

    Returns the selector that matches, or zero if the
    allocation failed.

--*/
{
    ULONG Base = ((ULONG) Segment) << 4;
    USHORT Sel;

    if (!(Sel = FindSelector(Base, (UCHAR)Access))) {

        if (Sel = ALLOCATE_SELECTOR()) {

            SetDescriptor(Sel, Base, 0xffff, Access);

        }

    }

    return Sel;
}

VOID
SetDescriptorArray(
    USHORT Sel,
    ULONG Base,
    ULONG MemSize
    )
/*++

Routine Description:

    This routine allocates a set of descriptors to cover the specified
    memory block. The descriptors are initialized as follows:
    The first descriptor points at the whole block, then all subsequent
    descriptors have a limit of 64k except for the final one, which has
    a limit of block size MOD 64k.

Arguments:

    Sel, Base, Memsize define the range of the selector array

Return Value:

    none

--*/
{

    USHORT SelCount;

    if (MemSize) {
        MemSize--;          // now a descriptor limit
    }

    SelCount = (USHORT) ((MemSize>>16) + 1);

    SetDescriptor(Sel, Base, MemSize, STD_DATA);
    while(--SelCount) {
        Sel += 8;
        MemSize -= 0x10000;         // subtract 64k
        Base += 0x10000;
        SetDescriptor(Sel,
                      Base,
                      (SelCount==1) ? MemSize : 0xffff,
                      STD_DATA);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\int21map.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Int21Map.c

Abstract:

    This module performs int 21 API translation for dpmi

Author:

    Dave Hastings (daveh) 23-Nov-1992


Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop
#include "int21map.h"
#include "softpc.h"
#include "xlathlp.h"
//
// Local constants
//
//#define Verbose 1
#define MAX_SUPPORTED_DOS_CALL 0x6d
#define DosxTranslated NULL

typedef VOID (*APIXLATFUNCTION)(VOID);
APIXLATFUNCTION ApiXlatTable[MAX_SUPPORTED_DOS_CALL] = {

    DosxTranslated                 , // 00h - Terminate process
    NoTranslation                  , // 01h - Char input with echo
    NoTranslation                  , // 02h - Character output
    NoTranslation                  , // 03h - Auxiliary input
    NoTranslation                  , // 04h - Auxiliary output
    NoTranslation                  , // 05h - Print character
    NoTranslation                  , // 06h - Direct console I/O
    NoTranslation                  , // 07h - Unfiltered char input
    NoTranslation                  , // 08h - Char input w/o echo
    DisplayString                  , // 09h - Display "$" term string
    BufferedKeyboardInput          , // 0Ah - Buffered keyboard input
    NoTranslation                  , // 0Bh - Check keyboard status
    FlushBuffReadKbd               , // 0Ch - Flush buff, Read kbd
    NoTranslation                  , // 0Dh - Disk reset
    NoTranslation                  , // 0Eh - Select disk
    NotSupportedFCB                , // 0Fh * Open file with FCB
    NotSupportedFCB                , // 10h * Close file with FCB
    FindFileFCB                    , // 11h - Find First File
    FindFileFCB                    , // 12h - Find Next File
    MapFCB                         , // 13h - Delete File
    NotSupportedFCB                , // 14h * Sequential Read
    NotSupportedFCB                , // 15h * Sequential Write
    NotSupportedFCB                , // 16h * Create File With FCB
    RenameFCB                      , // 17h - Rename File With FCB
    NoTranslation                  , // 18h - UNUSED
    NoTranslation                  , // 19h - Get Current Disk
    SetDTA                         , // 1Ah - Set DTA Address
    GetDriveData                   , // 1Bh - Get Default Drive Data
    GetDriveData                   , // 1Ch - Get Drive Data
    NoTranslation                  , // 1Dh - UNUSED
    NoTranslation                  , // 1Eh - UNUSED
    GetDriveData                   , // 1Fh - Get Drive Parameter Blk
    NoTranslation                  , // 20h - UNUSED
    NotSupportedFCB                , // 21h * Random Read
    NotSupportedFCB                , // 22h * Random Write
    NotSupportedFCB                , // 23h * Get File Size
    NotSupportedFCB                , // 24h * Set Relative Record
    SetVector                      , // 25h - Set interrupt vector
    CreatePSP                      , // 26h - Create PSP
    NotSupportedFCB                , // 27h * Random block read
    NotSupportedFCB                , // 28h * Random block write
    ParseFilename                  , // 29h - Parse filename
    GetDate                        , // 2Ah - Get date
    NoTranslation                  , // 2Bh - Set date
    NoTranslation                  , // 2Ch - Get time
    NoTranslation                  , // 2Dh - Set time
    NoTranslation                  , // 2Eh - Set/Reset verify flag
    GetDTA                         , // 2Fh - Get DTA address
    NoTranslation                  , // 30h - Get DOS version
    TSR                            , // 31h - Terminate and Stay Res
    GetDevParamBlock               , // 32h - Get device parameter blk
    NoTranslation                  , // 33h - Get/Set Control-C Flag
    ReturnESBX                     , // 34h - Get Address of InDOS
    GetVector                      , // 35h - Get Interrupt Vector
    NoTranslation                  , // 36h - Get Disk Free Space
    NoTranslation                  , // 37h - Char Oper
    GetSetCountry                  , // 38h - Get/Set Current Country
    MapASCIIZDSDX                  , // 39h - Create Directory
    MapASCIIZDSDX                  , // 3Ah - Remove Directory
    MapASCIIZDSDX                  , // 3Bh - Change Current Directory
    MapASCIIZDSDX                  , // 3Ch - Create File with Handle
    MapASCIIZDSDX                  , // 3Dh - Open File with Handle
    NoTranslation                  , // 3Eh - Close File with Handle
    ReadWriteFile                  , // 3Fh - Read File or Device
    ReadWriteFile                  , // 40h - Write File or Device
    MapASCIIZDSDX                  , // 41h - Delete File
    NoTranslation                  , // 42h - Move file pointer
    MapASCIIZDSDX                  , // 43h - Get/Set File Attributes
    IOCTL                          , // 44h - IOCTL
    NoTranslation                  , // 45h - Duplicate File Handle
    NoTranslation                  , // 46h - Force Duplicate Handle
    GetCurDir                      , // 47h - Get Current Directory
    AllocateMemoryBlock            , // 48h - Allocate Memory Block
    FreeMemoryBlock                , // 49h - Free Memory Block
    ResizeMemoryBlock              , // 4Ah - Resize Memory Block
    LoadExec                       , // 4Bh - Load and Exec Program
    DosxTranslated                 , // 4Ch - Terminate with Ret Code
    NoTranslation                  , // 4Dh - Get Ret Code Child Proc
    FindFirstFileHandle            , // 4Eh - Find First File
    FindNextFileHandle             , // 4Fh - Find Next File
    SetPSP                         , // 50h - Set PSP Segment
    GetPSP                         , // 51h - Get PSP Segment
    ReturnESBX                     , // 52h - Get List of Lists (invars)
    TranslateBPB                   , // 53h - Translate BPB
    NoTranslation                  , // 54h - Get Verify Flag
    CreatePSP                      , // 55h - Create PSP
    RenameFile                     , // 56h - Rename File
    NoTranslation                  , // 57h - Get/Set Date/Time File
    NoTranslation                  , // 58h - Get/Set Alloc Strategy
    NoTranslation                  , // 59h - Get Extended Error Info
    CreateTempFile                 , // 5Ah - Create Temporary File
    MapASCIIZDSDX                  , // 5Bh - Create New File
    NoTranslation                  , // 5Ch - Lock/Unlock File Region
    Func5Dh                        , // 5Dh - Server DOS call
    Func5Eh                        , // 5Eh - Net Name/Printer Setup
    Func5Fh                        , // 5Fh - Network redir stuff
    NotSupportedBad                , // 60h - NameTrans
    NoTranslation                  , // 61h - UNUSED
    GetPSP                         , // 62h - Get PSP Address
#ifdef DBCS
    ReturnDSSI                     , // 63h - Get DBCS Vector
#else
    NotSupportedBetter             , // 63h - Hangool call
#endif
    NotSupportedBad                , // 64h - Set Prn Flag
    GetExtendedCountryInfo         , // 65h - Get Extended Country Info
    NoTranslation                  , // 66h - Get/Set Global Code Page
    NoTranslation                  , // 67h - Set Handle Count
    NoTranslation                  , // 68h - Commit File
    NoTranslation                  , // 69h -
    NoTranslation                  , // 6Ah -
    NoTranslation                  , // 6Bh -
    MapASCIIZDSSI                    // 6Ch - Extended open
};

VOID
DpmiXlatInt21Call(
    VOID
    )
/*++

Routine Description:

    This routine dispatches to the appropriate routine to perform the
    actual translation of the api

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG DosMajorCode;
    PUCHAR StackPointer;

    //
    // Pop ds from stack
    //
    StackPointer = Sim32GetVDMPointer(
        ((ULONG)getSS() << 16),
        1,
        TRUE
        );

    StackPointer += (*GetSPRegister)();

    setDS(*(PWORD16)StackPointer);

    (*SetSPRegister)((*GetSPRegister)() + 2);

    DosMajorCode = getAH();

    if (DosMajorCode >= MAX_SUPPORTED_DOS_CALL) {
        return; //bugbug find out what win31 does.
    }

    if (ApiXlatTable[DosMajorCode]) {

        ULONG Eip, Esp;
        USHORT Cs, Ss;

        Eip = getEIP();
        Esp = getESP();
        Cs = getCS();
        Ss = getSS();

        (*ApiXlatTable[DosMajorCode])();

        setEIP(Eip);
        setESP(Esp);
        setCS(Cs);
        setSS(Ss);

        SimulateIret(PASS_CARRY_FLAG_16);
    }

    // put this back in after beta 2.5
    DpmiFreeAllBuffers();

}

VOID
NoTranslation(
    VOID
    )
/*++

Routine Description:

    This routine handles int 21 functions which don't need any translation.
    It simply executes the int 21 in real/v86 mode

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();
}

VOID
DisplayString(
    VOID
    )
/*++

Routine Description:

    This routine translates the int 21 display string function.

    N.B. Win 3.1 does this by calling int 21 function 2 repeatedly.
         We do it this way because Win 3.1 does.  If this function is
         frequently used, we should actually buffer the string and
         call the dos display string function.

Arguments:

    None

Return Value:

    None.

--*/
{   PUCHAR String;
    DECLARE_LocalVdmContext;
    USHORT ClientAX, ClientDX;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();

    String = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
             + (*GetDXRegister)();

    //
    // Repeatedly call int 21 function 2 to display the characters
    //
    ClientAX = getAX();
    ClientDX = getDX();
    setAH(2);
    while (*(String) != '$') {
        setDL(*(String));
        DPMI_EXEC_INT(0x21);
        String++;
    }
    setAX(ClientAX);
    setDX(ClientDX);

    DpmiSwitchToProtectedMode();
}

VOID
BufferedKeyboardInput(
    VOID
    )
/*++

Routine Description:

    This routine performs the tranlation for the int 21 function Ah

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR PmInputBuffer, RmInputBuffer;
    USHORT BufferSeg, BufferOff, BufferLen;
    USHORT ClientDX;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    //
    // Get a pointer to the PM buffer
    //
    PmInputBuffer = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                    + (*GetDXRegister)();

    //
    // Get the buffer length (there are two bytes in addition to the
    // buffer)
    //
    BufferLen = *PmInputBuffer + 2;

    //
    // Move the buffer to low memory
    //
    RmInputBuffer = DpmiMapAndCopyBuffer(PmInputBuffer, BufferLen);

    //
    // Set up the registers for the int 21 call
    //
    DPMI_FLAT_TO_SEGMENTED(RmInputBuffer, &BufferSeg, &BufferOff);
    setDS(BufferSeg);
    setDX(BufferOff);

    DPMI_EXEC_INT(0x21);

    //
    // Copy the data back
    //
    DpmiUnmapAndCopyBuffer(PmInputBuffer, RmInputBuffer, BufferLen);

    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);

}

VOID
FlushBuffReadKbd(
    VOID
    )
/*++

Routine Description:

    This routine performs translation for the flush keyboard routines.
    It calls the appropriate xlat routine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    if (getAL() == 0x0a) {
        BufferedKeyboardInput();
    } else {
        NoTranslation();
    }
}

VOID
NotSupportedFCB(
    VOID
    )
/*++

Routine Description:

    This routine does not do any translation.  It prints a warning to
    the debugger

Arguments:

    None.

Return Value:

    None.

--*/
{
#if DBG
    DECLARE_LocalVdmContext;

    DbgPrint(
        "WARNING: DOS INT 21 call AH = %x will not be translated.\n", getAH());
    DbgPrint(
        "         Protected mode applications should not be using\n");
    DbgPrint(
        "         this type of FCB call. Convert this application\n");
    DbgPrint(
        "         to use the handle calls.\n"
    );
#endif
    NoTranslation();
}

VOID
FindFileFCB(
    VOID
    )
/*++

Routine Description:

    This function translates the find first/find next FCB calls.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR FcbAddress, FcbBufferedAddress;
    USHORT FcbSegment, FcbOffset;
    USHORT ClientDX;
    USHORT FcbLength;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    SetDTAPointers();
    ClientDX = getDX();

    FcbAddress = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                 + (*GetDXRegister)();

    //
    // Calculate the size of the FCB
    //
    FcbLength = DpmiCalcFcbLength(FcbAddress);

    //
    // Buffer the FCB
    //
    FcbBufferedAddress = DpmiMapAndCopyBuffer(FcbAddress, FcbLength);

    //
    // Check to see if we need to set the real dta
    //
    if (CurrentDosDta != CurrentDta)
        SetDosDTA();

    //
    // Make the int 21 call
    //

    DPMI_FLAT_TO_SEGMENTED(FcbBufferedAddress, &FcbSegment, &FcbOffset);
    setDS(FcbSegment);
    setDX(FcbOffset);
    DPMI_EXEC_INT(0x21);

    //
    // If the call was successful and the PM dta is in high memory
    //  copy the dta to high memory
    //
    if ((getAL() == 0) && (CurrentPmDtaAddress != CurrentDta)) {
        MoveMemory(CurrentPmDtaAddress, CurrentDta, FcbLength);
        DpmiUnmapAndCopyBuffer(FcbAddress, FcbBufferedAddress, FcbLength);
    } else {
        DpmiUnmapBuffer(FcbBufferedAddress, FcbLength);
    }

    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
}

VOID
MapFCB(
    VOID
    )
/*++

Routine Description:

    This routine translates the delete file fcb int 21 call

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT FcbLength, FcbSegment, FcbOffset;
    PUCHAR FcbAddress, FcbBufferedAddress;
    USHORT ClientDX;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    FcbAddress = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                 + (*GetDXRegister)();

    //
    // Get the length of the FCB
    //
    FcbLength = DpmiCalcFcbLength(FcbAddress);

    //
    // Copy the FCB
    //
    FcbBufferedAddress = DpmiMapAndCopyBuffer(FcbAddress,  FcbLength);

    //
    // Make the int 21 call
    //
    DPMI_FLAT_TO_SEGMENTED(FcbBufferedAddress, &FcbSegment, &FcbOffset);
    setDS(FcbSegment);
    setDX(FcbOffset);
    DPMI_EXEC_INT(0x21);

    //
    // Copy the FCB back
    //
    DpmiUnmapAndCopyBuffer(FcbAddress, FcbBufferedAddress, FcbLength);

    //
    // Clean up
    //
    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
}

VOID
RenameFCB(
    VOID
    )
/*++

Routine Description:

    This routine translates the rename fcb int 21 function

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT FcbSegment, FcbOffset;
    PUCHAR FcbAddress, FcbBufferedAddress;
    USHORT ClientDX;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    FcbAddress = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                 + (*GetDXRegister)();

    //
    // Copy the FCB (The fcb for rename is a special format, fixed size)
    //
    FcbBufferedAddress = DpmiMapAndCopyBuffer(FcbAddress,  0x25);

    //
    // Make the int 21 call
    //
    DPMI_FLAT_TO_SEGMENTED(FcbBufferedAddress, &FcbSegment, &FcbOffset);
    setDS(FcbSegment);
    setDX(FcbOffset);
    DPMI_EXEC_INT(0x21);

    //
    // Copy the FCB back
    //
    DpmiUnmapAndCopyBuffer(FcbAddress, FcbAddress, 0x25);

    //
    // Clean up
    //
    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
}

VOID
GetDriveData(
    VOID
    )
/*++

Routine Description:

    Translates the drive data int 21 calls

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Selector;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    Selector = getDS();
    DpmiSwitchToProtectedMode();

    setDS(SegmentToSelector(Selector, STD_DATA));
    (*SetBXRegister)((ULONG)getBX());

}

VOID
SetVector(
    VOID
    )
/*++

Routine Description:

    This function translates int 21 function 25

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    SetProtectedModeInterrupt(getAL(), getDS(), (*GetDXRegister)(),
                              (USHORT)(Frame32 ? VDM_INT_32 : VDM_INT_16));

}

VOID
CreatePSP(
    VOID
    )
/*++

Routine Description:

    This routine translates the selector to a segment and reflects the
    calls

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Segment;
    USHORT ClientDX;

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Segment = SELECTOR_TO_INTEL_LINEAR_ADDRESS(ClientDX);

    if (Segment > ONE_MB) {
        //
        // Create PSP doesn't do anything on error
        //
    } else {
        setDX((USHORT) (Segment >> 4));
        DPMI_EXEC_INT(0x21);
    }

    setDX(ClientDX);
    DpmiSwitchToProtectedMode();

}

VOID
ParseFilename(
    VOID
    )
/*++

Routine Description:

    This routine translates the int 21 parse filename api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientSI, ClientDI, FcbLength, StringOff, Seg, Off;
    PUCHAR Fcb, BufferedFcb, String, BufferedString;
    USHORT ClientDS = getDS();
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientSI = getSI();
    ClientDI = getDI();

    Fcb = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
          + (*GetDIRegister)();

    FcbLength = DpmiCalcFcbLength(Fcb);

    BufferedFcb = DpmiMapAndCopyBuffer(Fcb, FcbLength);

    String = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
             + (*GetSIRegister)();

    BufferedString = DpmiMapAndCopyBuffer(String, 20);

    DPMI_FLAT_TO_SEGMENTED(BufferedFcb, &Seg, &Off);
    setES(Seg);
    setDI(Off);
    DPMI_FLAT_TO_SEGMENTED(BufferedString, &Seg, &StringOff);
    setDS(Seg);
    setSI(StringOff);

    DPMI_EXEC_INT(0x21);

    DpmiUnmapAndCopyBuffer(Fcb, BufferedFcb, FcbLength);
    DpmiUnmapAndCopyBuffer(String, BufferedString, 20);

    setDI(ClientDI);
    setSI(ClientSI + (getSI() - StringOff));
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
    setES(ClientES);
}

VOID
GetDTA(
    VOID
    )
/*++

Routine Description:

    This routine returns the current DTA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    //
    // Win31 compatibility:
    //
    // Some hosebag programs set the DTA to a selector that they later free!
    // This test makes sure that this does not cause us to crash.
    //

    if (!SEGMENT_IS_WRITABLE(CurrentDtaSelector)) {
        CurrentDtaSelector = 0;
        CurrentDtaOffset = 0;
    }

    setES(CurrentDtaSelector);
    setBX(CurrentDtaOffset);
    setCF(0);

}

VOID
SetDTA(
    VOID
    )
/*++

Routine Description:

    This routine sets the PM dta address.  If the buffer is usable directly,
    CurrentDta is set to the translated address. Otherwise, it is set to
    the dosx dta.

    N.B.  The Set Dta call is not actually reflected to Dos until a function
          call is made that actually uses the Dta, e.g. the Find First/Next
          functions. This techique was implemented to match what is done in
          Win 3.1.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX;

    ClientDX = getDX();
    CurrentDtaOffset = ClientDX;
    CurrentDtaSelector = getDS();

    //
    // Make sure real DTA is updated later
    //
    CurrentDosDta = (PUCHAR) NULL;

}

VOID
SetDTAPointers(
    VOID
    )
/*++

Routine Description:

    This routine sets up the flat address values used elsewhere to
    reference the current DTA.

    N.B. This must be done on every entry to handle function calls because
    the PM dta may have been GlobalRealloc'd. This may change the base
    address of the PM selector (which invalidates the flat addresses),
    but not the selector/offset itself.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PUCHAR NewDta;

    NewDta = Sim32GetVDMPointer(
        (CurrentDtaSelector << 16),
        1,
        TRUE
        );

    NewDta += CurrentDtaOffset;
    CurrentPmDtaAddress = NewDta;

    //
    // If the new dta is not accessible in v86 mode, use the one
    // supplied by Dosx
    //
    if ((ULONG)(NewDta + 128 - IntelBase) > MAX_V86_ADDRESS) {
        NewDta = DosxDtaBuffer;
    }

    //
    // Update Current DTA information
    //
    CurrentDta = NewDta;
}


VOID
SetDosDTA(
    VOID
    )
/*++

Routine Description:

    This routine is called internally by other functions in this module
    to reflect a Set Dta call to Dos.

    WARNING: The client must be in REAL mode


Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientAX, ClientDX, ClientDS, NewDtaSegment, NewDtaOffset;

    ASSERT((getMSW() & MSW_PE) == 0);

    ClientAX = getAX();
    ClientDX = getDX();
    ClientDS = getDS();

    DPMI_FLAT_TO_SEGMENTED(CurrentDta, &NewDtaSegment, &NewDtaOffset);
    setDS(NewDtaSegment);
    setDX(NewDtaOffset);
    setAH(0x1a);

    DPMI_EXEC_INT(0x21);

    setAX(ClientAX);
    setDX(ClientDX);
    setDS(ClientDS);
    CurrentDosDta = CurrentDta;

}

VOID
TSR(
    VOID
    )
/*++

Routine Description:

    This function translates int 21h tsr.  Win 3.1 does some
    magic here.  We didn't before and it worked fine.  Maybe
    we will later.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NoTranslation();
}

VOID
GetDevParamBlock(
    VOID
    )
/*++

Routine Description:

    This routine translates the Device Parameter Block apis

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Selector;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    Selector = getDS();
    DpmiSwitchToProtectedMode();

    setDS(SegmentToSelector(Selector, STD_DATA));
    (*SetBXRegister)((ULONG)getBX());

}

VOID
ReturnESBX(
    VOID
    )
/*++

Routine Description:

    This function translates api that return information in es:bx

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Selector;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    Selector = getES();
    DpmiSwitchToProtectedMode();

    (*SetBXRegister)((ULONG)getBX());
    setES(SegmentToSelector(Selector, STD_DATA));

}

VOID
GetVector(
    VOID
    )
/*++

Routine Description:

    This function translates int 21 function 35

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    USHORT IntNumber = getAL();

    setES(Handlers[IntNumber].CsSelector);
    (*SetBXRegister)(Handlers[IntNumber].Eip);

}

VOID
GetSetCountry(
    VOID
    )
/*++

Routine Description:

    This function translates int 21 function 38

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    if (getDX() == 0xFFFF) {
        NoTranslation();
    } else {

        USHORT ClientDX, Seg, Off;
        PUCHAR Country, BufferedCountry;
        USHORT ClientDS = getDS();

        DpmiSwitchToRealMode();
        ClientDX = getDX();

        Country = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                  + (*GetDXRegister)();

        BufferedCountry = DpmiMapAndCopyBuffer(Country, 34);

        DPMI_FLAT_TO_SEGMENTED(BufferedCountry, &Seg, &Off);
        setDS(Seg);
        setDX(Off);

        DPMI_EXEC_INT(0x21);
        DpmiSwitchToProtectedMode();

        DpmiUnmapAndCopyBuffer(Country, BufferedCountry, 34);

        setDX(ClientDX);
        setDS(ClientDS);
    }
}

VOID
MapASCIIZDSDX(
    VOID
    )
/*++

Routine Description:

    This routine maps the int 21 functions that pass file names in
    ds:dx

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR BufferedString;
    USHORT ClientDX, StringSeg, StringOff, Length;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    BufferedString = DpmiMapString(ClientDS, (GetDXRegister)(), &Length);

    DPMI_FLAT_TO_SEGMENTED(BufferedString, &StringSeg, &StringOff);
    setDS(StringSeg);
    setDX(StringOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapString(BufferedString, Length);
    setDX(ClientDX);
    setDS(ClientDS);
}

VOID
ReadWriteFile(
    VOID
    )
/*++

Routine Description:

    This routine translates the read/write file int 21 calls.  Large reads
    are broken down into 4k chunks.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientCX, ClientDX, ClientAX, Function, DataSeg, DataOff, BytesToRead;
    ULONG BytesRead, TotalBytesToRead;
    PUCHAR ReadWriteData, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();

    ClientCX = getCX();
    ClientDX = getDX();
    Function = getAH();
    ClientAX = getAX();

    TotalBytesToRead = (*GetCXRegister)();
    BytesRead = 0;

    ReadWriteData = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                    + (*GetDXRegister)();

//    while (TotalBytesToRead != BytesRead) {
    do {

        if ((TotalBytesToRead - BytesRead) > 1024 * 4) {
            BytesToRead = 4 * 1024;
        } else {
            BytesToRead = (USHORT)(TotalBytesToRead - BytesRead);
        }

        BufferedData = DpmiMapAndCopyBuffer(ReadWriteData, BytesToRead);

        DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);
        setDS(DataSeg);
        setDX(DataOff);
        setCX(BytesToRead);
        setAX(ClientAX);

        DPMI_EXEC_INT(0x21);

        if (getCF()) {
            DpmiUnmapBuffer(BufferedData, BytesToRead);
            break;
        }

        if (getAX() == 0) {
            DpmiUnmapBuffer(BufferedData, BytesToRead);
            break;
        } else if (getAX() < BytesToRead) {
            CopyMemory(ReadWriteData, BufferedData, getAX());
            DpmiUnmapBuffer(BufferedData, BytesToRead);
            BytesRead += getAX();
            break;
        } else {
            DpmiUnmapAndCopyBuffer(
                ReadWriteData,
                BufferedData,
                BytesToRead
                );
        }

        ReadWriteData += getAX();
        BytesRead += getAX();
//    }
    } while (TotalBytesToRead != BytesRead);
    setDX(ClientDX);
    setCX(ClientCX);
    if (!getCF()) {
        (*SetAXRegister)(BytesRead);
    }
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
}

#define MAX_SUPPORTED_DOS_IOCTL_CALL 0x10

//
// Note:  The translations here differ from those in the windows dpmi vxd,
//        because we do not have to lock memory, and we don't support block
//        device drivers.
//

APIXLATFUNCTION IOCTLXlatTable[MAX_SUPPORTED_DOS_IOCTL_CALL] = {
         NoTranslation    , // 00 - Get Device Data
         NoTranslation    , // 01 - Set Device Data
         MapDSDXLenCX     , // 02 - Receive Ctrl Chr Data
         MapDSDXLenCX     , // 03 - Send Ctrl Chr Data
         MapDSDXLenCX     , // 04 - Receive Ctrl Block Data
         MapDSDXLenCX     , // 05 - Send Ctrl Block Data
         NoTranslation    , // 06 - Check Input Status
         NoTranslation    , // 07 - Check Output Status
         NoTranslation    , // 08 - Check Block Dev Removable
         NoTranslation    , // 09 - Check Block Dev Remote
         NoTranslation    , // 0A - Check if Handle Remote
         NoTranslation    , // 0B - Change sharing retry cnt
         IOCTLMap2Bytes   , // 0C - MAP DS:DX LENGTH 2!
         IOCTLBlockDevs   , // 0D - Generic IOCTL to blk dev
         NoTranslation    , // 0E - Get Logical Drive Map
         NoTranslation      // 0F - Set Logical Drive Map
};

VOID
IOCTL(
    VOID
    )
/*++

Routine Description:

    This function translates the int 21 ioctl function.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT IoctlMinor;

    IoctlMinor = getAL();

    if (IoctlMinor >= MAX_SUPPORTED_DOS_IOCTL_CALL) {
#if DBG
        OutputDebugString("DPMI: IOCTL DOS CALL NOT SUPPORTED\n");
#endif
        NoTranslation();
        return;
    }

    (*IOCTLXlatTable[IoctlMinor])();
}

VOID
GetCurDir(
    VOID
    )
/*++

Routine Description:

    This routine translates the get current directory call

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR DirInfo, BufferedDirInfo;
    USHORT ClientSI, Seg, Off;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientSI = getSI();

    DirInfo = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
              + (*GetSIRegister)();

    BufferedDirInfo = DpmiMapAndCopyBuffer(DirInfo, 64);
    DPMI_FLAT_TO_SEGMENTED(BufferedDirInfo, &Seg, &Off);
    setDS(Seg);
    setSI(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(DirInfo, BufferedDirInfo, 64);
    setSI(ClientSI);
    setDS(ClientDS);
}

VOID
AllocateMemoryBlock(
    VOID
    )
/*++

Routine Description:

    This routine translates the AllocateMemory Int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI pMem;
    ULONG MemSize = ((ULONG)getBX()) << 4;

    pMem = DpmiAllocateXmem(MemSize);

    if (pMem) {

        pMem->SelCount = (USHORT) ((MemSize>>16) + 1);
        pMem->Sel = ALLOCATE_SELECTORS(pMem->SelCount);

        if (!pMem->Sel) {
            pMem->SelCount = 0;
            DpmiFreeXmem(pMem);
            pMem = NULL;
        } else {

            SetDescriptorArray(pMem->Sel, (ULONG)pMem->Address, MemSize);

        }
    }

    if (!pMem) {
        setCF(1);
        setAX(8);
        setBX(0);
    } else {
        setCF(0);
        setAX(pMem->Sel);
    }
}

VOID
FreeMemoryBlock(
    VOID
    )
/*++

Routine Description:

    This routine translates the ResizeMemory Int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI pMem;
    USHORT Sel = getES();

    if (pMem = DpmiFindXmem(Sel)) {

        while(pMem->SelCount--) {
            FreeSelector(Sel);
            Sel+=8;
        }

        DpmiFreeXmem(pMem);
        setCF(0);

    } else {

        setCF(1);
        setAX(9);

    }
}

VOID
ResizeMemoryBlock(
    VOID
    )
/*++

Routine Description:

    This routine translates the ResizeMemory int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI pMem;
    ULONG MemSize = ((ULONG)getBX()) << 4;
    USHORT Sel = getES();

    if (pMem = DpmiFindXmem(Sel)) {

        if (DpmiReallocateXmem(pMem, MemSize)) {

            SetDescriptorArray(pMem->Sel, (ULONG)pMem->Address, MemSize);
            setCF(0);

        } else {

            // not enough memory
            setCF(1);
            setAX(8);

        }
    } else {

        // invalid block
        setCF(1);
        setAX(9);

    }
}

VOID
LoadExec(
    VOID
    )
/*++

Routine Description:

    This function translates the int 21 load exec function.  Load overlay
    is not supported.

    The child always inherits the environment, and the fcbs in the parameter
    block are ignored. (win 3.1 does this)

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR CommandTail, BufferedString, Environment;
    USHORT ClientDX, ClientBX, Seg, Off, Length, i, EnvironmentSel;
    USHORT ClientDS = getDS();
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientDX = getDX();
    ClientBX = getBX();

    if (getAL() == 3) {
        setCF(1);
        setAX(1);
    } else {

        //
        // Make sure real DTA is updated later
        //
        CurrentDosDta = (PUCHAR) NULL;

        //
        // Map the command string
        //
        BufferedString = DpmiMapString(ClientDS, (*GetDXRegister)(), &Length);

        //
        // Set up the Parameter block
        //
        // We use the large xlat buffer.  The parameter block comes
        // first, and we fill in the command tail after
        //
        ZeroMemory(LargeXlatBuffer, 512);

        //
        // The environment segment address is now set
        //

        //
        // Set the command tail address, and copy the command tail (all
        // 128 bytes
        //
        DPMI_FLAT_TO_SEGMENTED((LargeXlatBuffer + 0x10), &Seg, &Off)
        *(PWORD16)(LargeXlatBuffer + 2) = Off;
        *(PWORD16)(LargeXlatBuffer + 4) = Seg;

        //
        // CommandTail = FLAT(es:bx)
        //
        CommandTail = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
                      + (*GetBXRegister)();

        if (CurrentAppFlags & DPMI_32BIT) {
            //
            // CommandTail -> string
            //
            CommandTail = Sim32GetVDMPointer((*(PWORD16)(CommandTail + 4)) << 16, 1, TRUE)
                          + *(PDWORD16)(CommandTail);

        } else {
            //
            // CommandTail -> string
            //
            CommandTail = Sim32GetVDMPointer(*(PDWORD16)(CommandTail + 2), 1, TRUE);
        }

        CopyMemory((LargeXlatBuffer + 0x10), CommandTail, 128);

        //
        // Set FCB pointers and put spaces in the file names
        //
        DPMI_FLAT_TO_SEGMENTED((LargeXlatBuffer + 144), &Seg, &Off)
        *(PWORD16)(LargeXlatBuffer + 6) = Off;
        *(PWORD16)(LargeXlatBuffer + 8) = Seg;
        for (i = 0; i < 11; i++) {
            (LargeXlatBuffer + 144 + 1)[i] = ' ';
        }

        DPMI_FLAT_TO_SEGMENTED((LargeXlatBuffer + 188), &Seg, &Off)
        *(PWORD16)(LargeXlatBuffer + 0xA) = Off;
        *(PWORD16)(LargeXlatBuffer + 0xC) = Seg;
        for (i = 0; i < 11; i++) {
            (LargeXlatBuffer + 188 + 1)[i] = ' ';
        }

        //
        // Save the environment selector, and make it a segment
        //

        Environment = Sim32GetVDMPointer(((ULONG)CurrentPSPSelector << 16) | 0x2C, 1, TRUE);

        EnvironmentSel = *(PWORD16)Environment;

        *(PWORD16)Environment =
            (USHORT)(SELECTOR_TO_INTEL_LINEAR_ADDRESS(EnvironmentSel) >> 4);

        //
        // Set up registers for the exec
        //
        DPMI_FLAT_TO_SEGMENTED(BufferedString, &Seg, &Off);
        setDS(Seg);
        setDX(Off);
        DPMI_FLAT_TO_SEGMENTED(LargeXlatBuffer, &Seg, &Off);
        setES(Seg);
        setBX(Off);

        DPMI_EXEC_INT(0x21);

        //
        // Restore the environment selector
        //
        Environment = Sim32GetVDMPointer(((ULONG)CurrentPSPSelector << 16) | 0x2C, 1, TRUE);

        *(PWORD16)Environment = EnvironmentSel;

        //
        // Free translation buffer
        //

        DpmiUnmapString(BufferedString, Length);
    }
    setDX(ClientDX);
    setBX(ClientBX);
    DpmiSwitchToProtectedMode();
    setES(ClientES);
    setDS(ClientDS);
}

VOID
Terminate(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    // bugbug We're currently mapping this one in the dos extender
}

VOID
FindFirstFileHandle(
    VOID
    )
/*++

Routine Description:

    This routine translates the find first api.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, Seg, Off, StringLength;
    PUCHAR BufferedString;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    SetDTAPointers();
    ClientDX = getDX();

    //
    // Copy the DTA (if necessary)
    //
    if (CurrentDta != CurrentPmDtaAddress) {
        CopyMemory(CurrentDta, CurrentPmDtaAddress, 43);
    }

    //
    // Check to see if we need to set the real dta
    //
    if (CurrentDosDta != CurrentDta)
        SetDosDTA();

    //
    // map the string
    //
    BufferedString = DpmiMapString(ClientDS, (GetDXRegister)(), &StringLength);

    DPMI_FLAT_TO_SEGMENTED(BufferedString, &Seg, &Off);
    setDS(Seg);
    setDX(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);

    DpmiUnmapString(BufferedString, StringLength);

    //
    // Copy the DTA back (if necessary)
    //
    if (CurrentDta != CurrentPmDtaAddress) {
        CopyMemory(CurrentPmDtaAddress, CurrentDta, 43);
    }


    setDX(ClientDX);

}


VOID
FindNextFileHandle(
    VOID
    )
/*++

Routine Description:

    This routine translates the find next api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    DpmiSwitchToRealMode();
    SetDTAPointers();

    //
    // Copy the DTA (if necessary)
    //
    if (CurrentDta != CurrentPmDtaAddress) {
        CopyMemory(CurrentDta, CurrentPmDtaAddress, 43);
    }

    //
    // Check to see if we need to set the real dta
    //
    if (CurrentDosDta != CurrentDta)
        SetDosDTA();

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    //
    // Copy the DTA back (if necessary)
    //
    if (CurrentDta != CurrentPmDtaAddress) {
        CopyMemory(CurrentPmDtaAddress, CurrentDta, 43);
    }

}

VOID
SetPSP(
    VOID
    )
/*++

Routine Description:

    This routine translates the set psp api.  This is substantially the
    same as CreatePSP, except that this can fail (and return carry).  It
    also remembers the PSP selector, so we can return it on request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Segment;
    USHORT ClientBX;

    DpmiSwitchToRealMode();
    ClientBX = getBX();

    if (ClientBX == 0) {
        CurrentPSPSelector = ClientBX;
    } else {
        Segment = SELECTOR_TO_INTEL_LINEAR_ADDRESS(ClientBX);

        if (Segment > ONE_MB) {

            setCF(1);

        } else {
            setBX((USHORT) (Segment >> 4));
            DPMI_EXEC_INT(0x21);
            CurrentPSPSelector = ClientBX;
        }
    }

    setBX(ClientBX);
    DpmiSwitchToProtectedMode();
}

VOID
GetPSP(
    VOID
    )
/*++

Routine Description:

    This routine returns the current PSP selector

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    DpmiSwitchToRealMode();
    //
    // Get the current psp segment to see if it changed
    //
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    //
    // If it changed get a new selector for the psp
    //
    if (getBX() !=
        (USHORT)(SELECTOR_TO_INTEL_LINEAR_ADDRESS(CurrentPSPSelector) >> 4)
    ){
        CurrentPSPSelector = SegmentToSelector(getBX(), STD_DATA);
    }

    setBX(CurrentPSPSelector);
    setCF(0);

}

VOID
TranslateBPB(
    VOID
    )
/*++

Routine Description:

    This function fails and returns.  On NT we do not support this dos
    call.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

#if DBG
    OutputDebugString("DPMI:  Int 21 function 53 is not supported\n");
#endif
    setCF(1);
}

VOID
RenameFile(
    VOID
    )
/*++

Routine Description:

    This routine translates the rename int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR SourceString, DestinationString;
    USHORT ClientDX, ClientDI, Seg, Off, SourceLength, DestinationLength;
    USHORT ClientDS = getDS();
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientDX = getDX();
    ClientDI = getDI();

    SourceString = DpmiMapString(ClientDS, (*GetDXRegister)(), &SourceLength);
    DestinationString = DpmiMapString(ClientES, (*GetDIRegister)(), &DestinationLength);

    DPMI_FLAT_TO_SEGMENTED(SourceString, &Seg, &Off);
    setDX(Off);
    setDS(Seg);
    DPMI_FLAT_TO_SEGMENTED(DestinationString, &Seg, &Off);
    setDI(Off);
    setES(Seg);

    DPMI_EXEC_INT(0x21);

    setDX(ClientDX);
    setDI(ClientDI);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);
    setES(ClientES);
}

VOID
CreateTempFile(
    VOID
    )
/*++

Routine Description:

    This function maps the int 21 create temp file api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR String, BufferedString;
    USHORT ClientDX, Seg, Off, Length;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();


    String = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
             + (*GetDXRegister)();

    Length = 0;
    while (String[Length] != '\0') {
        Length++;
    }

    Length += 13;

    BufferedString = DpmiMapAndCopyBuffer(String, Length);

    DPMI_FLAT_TO_SEGMENTED(BufferedString, &Seg, &Off);
    setDS(Seg);
    setDX(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(String, BufferedString, Length);

    setDX(ClientDX);
    setDS(ClientDS);
}

#define MAX_SUPPORTED_DOS_5D_CALL 12

APIXLATFUNCTION Func5DXlatTable[MAX_SUPPORTED_DOS_5D_CALL] = {
         NotSupportedBad    , // 0
         MapDPL             , // 1
         NotSupportedBad    , // 2
         MapDPL             , // 3
         MapDPL             , // 4
         NotSupportedBad    , // 5
         NotSupportedBad    , // 6
         NoTranslation      , // 7
         NoTranslation      , // 8
         NoTranslation      , // 9
         MapDPL             , // 10
         NotSupportedBad      // 11
};

VOID
Func5Dh(
    VOID
    )
/*++

Routine Description:

    This function translates dos call 5d

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Func5DhMinor;

    Func5DhMinor = getAL();

    if (Func5DhMinor >= MAX_SUPPORTED_DOS_5D_CALL) {
#if DBG
        OutputDebugString("DPMI: DOS FUNCTION 5D UNSUPPORTED\n");
#endif
        NoTranslation();
        return;
    }

    (*Func5DXlatTable[Func5DhMinor])();
}

#define MAX_SUPPORTED_DOS_5E_CALL 4
APIXLATFUNCTION Func5EXlatTable[MAX_SUPPORTED_DOS_5E_CALL] = {
         GetMachineName,
         MapASCIIZDSDX,
         GetPrinterSetup,
         SetPrinterSetup
};

VOID
Func5Eh(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Func5EhMinor;

    Func5EhMinor = getAL();

    if (Func5EhMinor >= MAX_SUPPORTED_DOS_5E_CALL) {
#if DBG
        OutputDebugString("DPMI: DOS FUNCTION 5E UNSUPPORTED\n");
#endif
        NoTranslation();
        return;
    }

    (*Func5EXlatTable[Func5EhMinor])();
}

VOID
Func5Fh(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Func5FMinor;

    Func5FMinor = getAL();

    if (Func5FMinor == 4) {
        MapASCIIZDSSI();
        return;
    } else if ((Func5FMinor == 2) || (Func5FMinor == 3) ||
        (Func5FMinor == 5)
    ){
        USHORT ClientSI, ClientDI, DataOff, DataSeg;
        PUCHAR Data16, BufferedData16, Data128, BufferedData128;
        USHORT ClientDS = getDS();
        USHORT ClientES = getES();

        DpmiSwitchToRealMode();
        ClientDI = getDI();
        ClientSI = getSI();

        Data16 = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                 + (*GetSIRegister)();

        BufferedData16 = DpmiMapAndCopyBuffer(Data16, 16);

        Data128 = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
                  + (*GetDIRegister)();

        BufferedData128 = DpmiMapAndCopyBuffer(Data128, 128);

        DPMI_FLAT_TO_SEGMENTED(BufferedData16, &DataSeg, &DataOff);
        setDS(DataSeg);
        setSI(DataOff);
        DPMI_FLAT_TO_SEGMENTED(BufferedData128, &DataSeg, &DataOff);
        setES(DataSeg);
        setDI(DataOff);

        DPMI_EXEC_INT(0x21);
        DpmiSwitchToProtectedMode();

        DpmiUnmapAndCopyBuffer(Data16, BufferedData16, 16);
        DpmiUnmapAndCopyBuffer(Data128, BufferedData128, 128);

        setDS(ClientDS);
        setES(ClientES);
        setSI(ClientSI);
        setDI(ClientDI);
    } else {
#if DBG
        OutputDebugString("DPMI: UNSUPPORTED INT 21 FUNCTION 5F\n");
#endif
        NoTranslation();
    }
}

VOID
NotSupportedBad(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
#if DBG
    DECLARE_LocalVdmContext;

    DbgPrint("WARNING: DOS INT 21 call AX= %x will not be translated.\n", getAH());
    DbgPrint("         Use of this call is not supported from Prot\n");
    DbgPrint("         mode applications.\n");
#endif
    NoTranslation();
}

VOID
ReturnDSSI(
    VOID
    )
/*++

Routine Description:

    This function translates api that return information in ds:si

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Selector;

    DpmiSwitchToRealMode();
    DPMI_EXEC_INT(0x21);
    Selector = getDS();
    DpmiSwitchToProtectedMode();

    (*SetSIRegister)((ULONG)getSI());
    setDS(SegmentToSelector(Selector, STD_DATA));

}

VOID
NotSupportedBetter(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
#if DBG
    DECLARE_LocalVdmContext;

    DbgPrint("WARNING: DOS INT 21 call AX= %x will not be translated.", getAH());
    DbgPrint("         Use of this call by a Prot Mode app is not");
    DbgPrint("         appropriate. There is a better INT 21 call, or a");
    DbgPrint("         Windows call which should be used instead of this.");
#endif
    NoTranslation();
}

VOID
GetExtendedCountryInfo(
    VOID
    )
/*++

Routine Description:

    This routine translates the get extended country info int 21 api

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR Country, BufferedCountry;
    USHORT ClientDI, Seg, Off, Length;
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientDI = getDI();

    Length = getCX();

    Country = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
              + (*GetDIRegister)();

    BufferedCountry = DpmiMapAndCopyBuffer(Country, Length);

    DPMI_FLAT_TO_SEGMENTED(BufferedCountry, &Seg, &Off);
    setES(Seg);
    setDI(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();
    setES(ClientES);

    DpmiUnmapAndCopyBuffer(Country, BufferedCountry, Length);

    setDI(ClientDI);
}

VOID
MapASCIIZDSSI(
    VOID
    )
/*++

Routine Description:

    This function translates the int 21 extended open call

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR BufferedString;
    USHORT ClientSI, StringSeg, StringOff, Length;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientSI = getSI();

    BufferedString = DpmiMapString(ClientDS, (*GetSIRegister)(), &Length);

    DPMI_FLAT_TO_SEGMENTED(BufferedString, &StringSeg, &StringOff);
    setDS(StringSeg);
    setSI(StringOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapString(BufferedString, Length);
    setSI(ClientSI);
    setDS(ClientDS);
}


VOID
MapDSDXLenCX(
    VOID
    )
/*++

Routine Description:

    This function maps the ioctl calls that pass data in DS:DX, with
    length in cx

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, ClientCX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();
    ClientCX = getCX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetDXRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, ClientCX);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setDX(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, ClientCX);

    setDS(ClientDS);
    setDX(ClientDX);
}

VOID
IOCTLMap2Bytes(
    VOID
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE);

    BufferedData = DpmiMapAndCopyBuffer(Data, 2);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setDX(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, 2);

    setDS(ClientDS);
    setDX(ClientDX);
}

VOID
IOCTLBlockDevs(
    VOID
    )
/*++

Routine Description:

    This function fails the block device ioctls

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT IoctlSubFunction, Seg, Off, ClientDX;
    PUCHAR Data, BufferedData;
    USHORT Length;
    USHORT ClientDS = getDS();

    IoctlSubFunction = getCL();

    if ((IoctlSubFunction < 0x40) || (IoctlSubFunction > 0x42) &&
        (IoctlSubFunction < 0x60) || (IoctlSubFunction > 0x62) &&
        (IoctlSubFunction != 0x68)
    ) {
#if DBG
        OutputDebugString("DPMI: IOCTL DOS CALL NOT SUPPORTED\n");
#endif
        NoTranslation();
        return;
    }

    //
    // Read and write track are special (and a pain)
    //
    if ((IoctlSubFunction == 0x41) || (IoctlSubFunction == 0x61)) {
        IoctlReadWriteTrack();
        return;
    }

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetDXRegister)();

    switch (IoctlSubFunction) {
    case 0x40:
        //
        // Map set device params
        //
        Length = (*(PWORD16)(Data + 0x26));
        Length <<= 2;
        Length += 0x28;
        break;

    case 0x60:
        //
        // Map get device params
        //
        Length = 38;
        break;

    case 0x62:
        //
        // Map format verify
        //
        Length = 5;
        break;

    case 0x68:
        //
        // Map Media sense
        //
        Length = 4;
        break;
    }

    BufferedData = DpmiMapAndCopyBuffer(Data, Length);
    DPMI_FLAT_TO_SEGMENTED(BufferedData, &Seg, &Off);
    setDS(Seg);
    setDX(Off);

    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, Length);

    setDS(ClientDS);
    setDX(ClientDX);
}

VOID
IoctlReadWriteTrack(
    VOID
    )
/*++

Routine Description:

    This routine maps the read/write track ioctl.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, ClientDS, ClientCX, ClientAX;
    USHORT Seg, Off, NumberOfSectors, BytesPerSector;
    USHORT SectorsRead, SectorsToRead;
    PUCHAR ParameterBlock, BufferedPBlock, Data, BufferedData;

    ClientAX = getAX();
    ClientDX = getDX();
    ClientCX = getCX();
    ClientDS = getDS();
    DpmiSwitchToRealMode();

    //
    // Find out how many bytes/sector
    //

    BufferedData = DpmiAllocateBuffer(0x40);
    DPMI_FLAT_TO_SEGMENTED(BufferedData, &Seg, &Off);
    setDS(Seg);
    setDX(Off);

    setAX(0x440D);
    setCX(0x860);

    DPMI_EXEC_INT(0x21);

    if (getCF()) {
        //
        // Failed, we don't know how much data to buffer,
        // so fail read/write track
        //
        DpmiFreeBuffer(BufferedData, 0x40);
        setDX(ClientDX);
        setCX(ClientCX);
        DpmiSwitchToProtectedMode();
        setDS(ClientDS);
        return;
    }

    //
    // Get the number of bytes/sector
    //
    BytesPerSector = *(PWORD16)(BufferedData + 0x7);

    DpmiFreeBuffer(BufferedData, 0x40);

    setDX(ClientDX);

    //
    // First map the parameter block
    //
    ParameterBlock = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
                     + (*GetDXRegister)();

    BufferedPBlock = DpmiMapAndCopyBuffer(ParameterBlock, 13);


    //
    // Get the segment and offset of the parameter block
    //
    DPMI_FLAT_TO_SEGMENTED(BufferedPBlock, &Seg, &Off);

    setDS(Seg);
    setDX(Off);

    if (CurrentAppFlags & DPMI_32BIT) {

        Data = Sim32GetVDMPointer(
            (*((PWORD16)(BufferedPBlock + 0xd)) << 16),
            1,
            TRUE
            );

        Data += *((PDWORD16)(BufferedPBlock + 0x9));

    } else {

        Data = Sim32GetVDMPointer(
            (*((PWORD16)(BufferedPBlock + 0xb)) << 16),
            1,
            TRUE
            );

        Data += *((PWORD16)(BufferedPBlock + 0x9));

    }

    NumberOfSectors = *((PWORD16)(BufferedPBlock + 7));

    SectorsRead = 0;

    while (NumberOfSectors != SectorsRead) {

        if ((NumberOfSectors - SectorsRead) * BytesPerSector > 1024 * 4) {
            SectorsToRead = 4 * 1024 / BytesPerSector;
        } else {
            SectorsToRead = (USHORT)(NumberOfSectors - SectorsRead);
        }

        BufferedData = DpmiMapAndCopyBuffer(
            Data,
            (USHORT) (SectorsToRead * BytesPerSector)
            );

        DPMI_FLAT_TO_SEGMENTED(BufferedData, &Seg, &Off);

        *((PWORD16)(BufferedPBlock + 9)) = Off;
        *((PWORD16)(BufferedPBlock + 11)) = Seg;
        *((PWORD16)(BufferedPBlock + 7)) = SectorsToRead;
        setAX(ClientAX);
        setCX(ClientCX);

        DPMI_EXEC_INT(0x21);

        if (getCF()) {
            DpmiUnmapBuffer(
                BufferedData,
                (USHORT) (SectorsToRead * BytesPerSector)
                );
            break;
        }

        DpmiUnmapAndCopyBuffer(
            Data,
            BufferedData,
            (USHORT) (SectorsToRead * BytesPerSector)
            );

        Data += SectorsToRead * BytesPerSector;
        *((PWORD16)(BufferedPBlock + 5)) += SectorsToRead;
        SectorsRead += SectorsToRead;
    }

    DpmiUnmapBuffer(BufferedPBlock,13);
    setDX(ClientDX);
    DpmiSwitchToProtectedMode();
    setDS(ClientDS);

}

VOID
MapDPL(
    VOID
    )
/*++

Routine Description:

    This routine maps a DPL for the server call

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetDXRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, 22);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setDX(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, 22);

    setDX(ClientDX);
    setDS(ClientDS);
}

VOID
GetMachineName(
    VOID
    )
/*++

Routine Description:

    This routine maps a machine name for int 21 function 5e

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientDX = getDX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetDXRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, 16);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setDX(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, 16);

    setDX(ClientDX);
    setDS(ClientDS);
}

VOID
GetPrinterSetup(
    VOID
    )
/*++

Routine Description:

    This routine maps printer setup data for int 21 function 5e

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientSI, ClientCX, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientDS = getDS();

    DpmiSwitchToRealMode();
    ClientSI = getSI();
    ClientCX = getCX();

    Data = Sim32GetVDMPointer(((ULONG)ClientDS << 16), 1, TRUE)
           + (*GetSIRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, ClientCX);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setDS(DataSeg);
    setSI(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();

    DpmiUnmapAndCopyBuffer(Data, BufferedData, ClientCX);

    setSI(ClientSI);
    setDS(ClientDS);
}

VOID
SetPrinterSetup(
    VOID
    )
/*++

Routine Description:

    This routine maps printer setup data for int 21 function 5e

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    USHORT ClientDI, DataSeg, DataOff;
    PUCHAR Data, BufferedData;
    USHORT ClientES = getES();

    DpmiSwitchToRealMode();
    ClientDI = getDI();

    Data = Sim32GetVDMPointer(((ULONG)ClientES << 16), 1, TRUE)
           + (*GetDIRegister)();

    BufferedData = DpmiMapAndCopyBuffer(Data, 64);

    DPMI_FLAT_TO_SEGMENTED(BufferedData, &DataSeg, &DataOff);

    setES(DataSeg);
    setDI(DataOff);
    DPMI_EXEC_INT(0x21);
    DpmiSwitchToProtectedMode();
    setES(ClientES);
    DpmiUnmapAndCopyBuffer(Data, BufferedData, 64);

    setDI(ClientDI);
}
VOID
GetDate(
    VOID
    )
/*++

Routine Description:

    This routine maps int21 func 2A GetDate

Arguments:

    None.

Return Value:

    Client (DH) - month
    Client (DL) - Day
    Client (CX) - Year
    Client (AL) - WeekDay

--*/
{
    DECLARE_LocalVdmContext;
    SYSTEMTIME TimeDate;

    GetLocalTime(&TimeDate);
    setDH((UCHAR)TimeDate.wMonth);
    setDL((UCHAR)TimeDate.wDay);
    setCX(TimeDate.wYear);
    setAL((UCHAR)TimeDate.wDayOfWeek);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\dpmimscr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dpmimscr.c

Abstract:

    This module contains misc dpmi functions for risc.

Author:

    Dave Hart (davehart) creation-date 11-Apr-1993

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include "softpc.h"

VOID
DpmiGetFastBopEntry(
    VOID
    )
/*++

Routine Description:

    This routine is the front end for the routine that gets the address.  It
    is necessary to get the address in asm, because the CS value is not
    available in c

Arguments:

    None

Return Value:

    None.

--*/
{
#ifdef _X86_
    GetFastBopEntryAddress(&((PVDM_TIB)NtCurrentTeb()->Vdm)->VdmContext);
#else
    //
    // krnl286 does a DPMIBOP GetFastBopAddress even on
    // risc, so just fail the call since fast-bopping
    // will only ever work on x86.
    //

    setBX(0);
    setDX(0);
    setES(0);
#endif
}



VOID
DpmiDpmiInUse(
    VOID
    )
/*++

Routine Description:

    This routine currently does nothing.

Arguments:

    None.

Return Value:

    None.

--*/
{

}

VOID
DpmiDpmiNoLongerInUse(
    VOID
    )
/*++

Routine Description:

    This routine notifies the CPU that the NT dpmi server is no longer in use.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DpmiFreeAllXmem();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\precomp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <dpmi.h>
#include <vint.h>
#include <mvdm.h>
#include <dpmi32.h>
#include <dbgsvc.h>
#include <nt_vdd.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\int21map.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    int21map.h

Abstract:

    This is the private include file for int21 translation support

Author:

    Neil Sandlin (neilsa) 4-Dec-1996

Revision History:


--*/


VOID
NoTranslation(
    VOID
    );

VOID
DisplayString(
    VOID
    );

VOID
BufferedKeyboardInput(
    VOID
    );

VOID
FlushBuffReadKbd(
    VOID
    );

VOID
NotSupportedFCB(
    VOID
    );

VOID
FindFileFCB(
    VOID
    );

VOID
MapFCB(
    VOID
    );

VOID
RenameFCB(
    VOID
    );

VOID
SetDTA(
    VOID
    );

VOID
SetDTAPointers(
    VOID
    );

VOID
SetDosDTA(
    VOID
    );

VOID
GetDriveData(
    VOID
    );

VOID
CreatePSP(
    VOID
    );

VOID
ParseFilename(
    VOID
    );

VOID
GetDTA(
    VOID
    );

VOID
TSR(
    VOID
    );

VOID
GetDevParamBlock(
    VOID
    );

VOID
ReturnESBX(
    VOID
    );

VOID
GetSetCountry(
    VOID
    );

VOID
MapASCIIZDSDX(
    VOID
    );

VOID
ReadWriteFile(
    VOID
    );

VOID
MoveFilePointer(
    VOID
    );

VOID
IOCTL(
    VOID
    );

VOID
GetCurDir(
    VOID
    );

VOID
AllocateMemoryBlock(
    VOID
    );

VOID
FreeMemoryBlock(
    VOID
    );

VOID
ResizeMemoryBlock(
    VOID
    );

VOID
LoadExec(
    VOID
    );

VOID
Terminate(
    VOID
    );

VOID
FindFirstFileHandle(
    VOID
    );

VOID
FindNextFileHandle(
    VOID
    );

VOID
SetPSP(
    VOID
    );

VOID
GetPSP(
    VOID
    );

VOID
TranslateBPB(
    VOID
    );

VOID
RenameFile(
    VOID
    );

VOID
CreateTempFile(
    VOID
    );

VOID
Func5Dh(
    VOID
    );

VOID
Func5Eh(
    VOID
    );

VOID
Func5Fh(
    VOID
    );

VOID
NotSupportedBad(
    VOID
    );

VOID
ReturnDSSI(
    VOID
    );

VOID
NotSupportedBetter(
    VOID
    );

VOID
GetExtendedCountryInfo(
    VOID
    );

VOID
MapASCIIZDSSI(
    VOID
    );

VOID
IOCTLControlData(
    VOID
    );

VOID
MapDSDXLenCX(
    VOID
    );

VOID
IOCTLMap2Bytes(
    VOID
    );

VOID
IOCTLBlockDevs(
    VOID
    );

VOID
MapDPL(
    VOID
    );

VOID
GetMachineName(
    VOID
    );

VOID
GetPrinterSetup(
    VOID
    );

VOID
SetPrinterSetup(
    VOID
    );

VOID
IoctlReadWriteTrack(
    VOID
    );

VOID
GetDate(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


MAJORCOMP=mvdm
MINORCOMP=dpmi32

TARGETNAME=dpmi32
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\.;..\..\inc;..\..\..\inc

SOURCES=        \
        ..\dosmem.c    \
        ..\dpmi32.c \
        ..\dpmiint.c \
        ..\dpmimscr.c  \
        ..\dpmiselr.c \
        ..\buffer.c    \
        ..\data.c         \
        ..\int21map.c  \
        ..\int2f.c     \
        ..\int31.c     \
        ..\modesw.c    \
        ..\register.c     \
        ..\savestat.c     \
        ..\stack.c     \
        ..\vxd.c       \
        ..\xmem.c

i386_SOURCES=..\i386\dpmi386.c ..\i386\dpmimem.c

MIPS_SOURCES=..\dpmimemr.c
PPC_SOURCES=..\dpmimemr.c
ALPHA_SOURCES=..\dpmimemr.c

C_DEFINES=-DLINKED_INTO_MONITOR

UMTYPE=console

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\int2f.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Int2f.c

Abstract:

    This module provides the int 2f API for dpmi

Author:

    Neil Sandlin (neilsa) 23-Nov-1996


Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include "xlathlp.h"

//
// Local constants
//
#define MSCDEX_FUNC 0x15
#define WIN386_FUNC 0x16
#define WIN386_IDLE             0x80
#define WIN386_Get_Device_API   0x84
#define WIN386_INT31            0x86
#define WIN386_GETLDT           0x88
#define WIN386_KRNLIDLE         0x89
#define DPMI_MSDOS_EXT          0x8A

#define SEL_LDT 0x137

#define DISPCRIT_FUNC   0x40
#define DISPCRIT_ENTER  0x03
#define DISPCRIT_EXIT   0x04

#define XMS_ID          0x43
#define XMS_INS_CHK     0x00
#define XMS_CTRL_FUNC   0x10

typedef BOOL (WINAPI *PFNMSCDEXVDDDISPATCH)(VOID);

PFNMSCDEXVDDDISPATCH
LoadMscdexAndGetVDDDispatchAddr(
    VOID
    );


BOOL
PMInt2fHandler(
    VOID
    )
/*++

Routine Description:

    This routine is called at the end of the protect mode PM int chain
    for int 2fh. It is provided for compatibility with win31.

Arguments:

    Client registers are the arguments to int2f

Return Value:

    TRUE if the interrupt was handled, FALSE otherwise

--*/
{
    DECLARE_LocalVdmContext;
    BOOL bHandled = FALSE;
    static char szMSDOS[] = "MS-DOS";
    PCHAR VdmData;
    static PFNMSCDEXVDDDISPATCH pfnMscdexVDDDispatch = NULL;

    switch(getAH()) {

    //
    // Int2f Func 15xx - MSCDEX
    //
    case MSCDEX_FUNC:

        if (!pfnMscdexVDDDispatch) {
            pfnMscdexVDDDispatch = LoadMscdexAndGetVDDDispatchAddr();
        }

        if (pfnMscdexVDDDispatch) {
            bHandled = pfnMscdexVDDDispatch();
        }
        break;



    //
    // Int2f Func 16
    //
    case WIN386_FUNC:

        switch(getAL()) {

        case WIN386_KRNLIDLE:
        case WIN386_IDLE:
            bHandled = TRUE;
            break;

        case WIN386_GETLDT:
            if (getBX() == 0xbad) {
                setAX(0);
                setBX(SEL_LDT);
                bHandled = TRUE;
            }
            break;

        case WIN386_INT31:
            setAX(0);
            bHandled = TRUE;
            break;

        case WIN386_Get_Device_API:
            GetVxDApiHandler(getBX());
            bHandled = TRUE;
            break;

        case DPMI_MSDOS_EXT:
            VdmData = VdmMapFlat(getDS(), (*GetSIRegister)(), VDM_PM);
            if (!strcmp(VdmData, szMSDOS)) {

                setES(HIWORD(DosxMsDosApi));
                (*SetDIRegister)((ULONG)LOWORD(DosxMsDosApi));
                setAX(0);
                bHandled = TRUE;
            }
            break;

        }
        break;

    //
    // Int2f Func 40
    //
    case DISPCRIT_FUNC:
        if ((getAL() == DISPCRIT_ENTER) ||
            (getAL() == DISPCRIT_ENTER)) {
            bHandled = TRUE;
        }
        break;

    //
    // Int2f Func 43
    //
    case XMS_ID:
        if (getAL() == XMS_INS_CHK) {
            setAL(0x80);
            bHandled = TRUE;
        } else if (getAL() == XMS_CTRL_FUNC) {
            setES(HIWORD(DosxXmsControl));
            setBX(LOWORD(DosxXmsControl));
            bHandled = TRUE;
        }
        break;
    }

    return bHandled;

}





PFNMSCDEXVDDDISPATCH
LoadMscdexAndGetVDDDispatchAddr(
    VOID
    )
/*++

Routine Description:

    This routine is called when we want the VCDEX VDD to handle
    a protected-mode Int2f AH=15, but we don't yet have a
    pointer to the VCDEX VDDDispatch entrypoint.

Arguments:

    None

Return Value:

    Pointer to VCDEX VDDDispatch or NULL if the VDD couldn't
    be loaded or the entrypoint couldn't be found.

--*/
{
    static const char szVCDEX[] = "VCDEX";
    DECLARE_LocalVdmContext;
    HANDLE hmodMscdexVdd;
    WORD saveAX, saveBX, saveCX;
    DWORD saveCF;

    //
    // The VDD may already have been loaded by the MSCDEX TSR.
    //

    hmodMscdexVdd = GetModuleHandle(szVCDEX);

    if (!hmodMscdexVdd) {

        //
        // Synthesize an Int2f 1500 to get the VDD loaded.
        // This can fail if the user has removed mscdex
        // from config.nt.
        //

        DpmiSwitchToRealMode();
        saveAX = getAX();
        saveBX = getBX();
        saveCX = getCX();
        saveCF = getCF();

        setAX(0x1500);
        setBX(0);
        DPMI_EXEC_INT(0x2f);

        setCF(saveCF);
        setCX(saveCX);
        setBX(saveBX);
        setAX(saveAX);
        DpmiSwitchToProtectedMode();


        //
        // Try again.  If this fails, so will GetProcAddress below
        // and we'll pass it down to v86 mode handlers.
        //

        hmodMscdexVdd = GetModuleHandle(szVCDEX);
   }

   return (PFNMSCDEXVDDDISPATCH) GetProcAddress(hmodMscdexVdd, "VDDDispatch");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\savestat.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Savestate.c

Abstract:

    This module contains routines to save and restore the 16 bit state

Author:

    Dave Hastings (daveh) 27-Nov-1992

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include <malloc.h>

//
// Internal structures
//
typedef struct _SavedState {
    struct _SavedState *Next;
    USHORT SegSs;
    ULONG Esp;
    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;
} SAVEDCONTEXT, *PSAVEDCONTEXT;

PSAVEDCONTEXT StateStack = NULL;

VOID
DpmiSaveSegmentsAndStack(
    PVOID ContextPointer
    )
/*++

Routine Description:

    This routine saves the segment registers, and the sp value.

Arguments:

    None.

Return Value:

    None.

Notes:

    It would be better if the calling routine did not have to have
    any knowlege of what is being saved, but apparently malloc is now
    and always will be much too slow to be useful, so we do this.

--*/
{
    DECLARE_LocalVdmContext;
    PSAVEDCONTEXT SavedState;

    ASSERT((sizeof(SAVEDCONTEXT) < sizeof(VSAVEDSTATE)));
    SavedState = ContextPointer;

    SavedState->Next = StateStack;
    StateStack = SavedState;

    SavedState->SegSs = getSS();
    SavedState->Esp = getESP();
    SavedState->SegDs = getDS();
    SavedState->SegEs = getES();
    SavedState->SegFs = getFS();
    SavedState->SegGs = getGS();

}

PVOID
DpmiRestoreSegmentsAndStack(
    VOID
    )
/*++

Routine Description:

    This routine restores the segment registers, and the sp value.

Arguments:

    None.

Return Value:

    Pointer to state poped off stack.

--*/
{
    DECLARE_LocalVdmContext;
    PSAVEDCONTEXT SavedState;


    SavedState = StateStack;

    ASSERT((SavedState));
    ASSERT((sizeof(SAVEDCONTEXT) < sizeof(VSAVEDSTATE)));

    StateStack = SavedState->Next;

    setSS(SavedState->SegSs);


#if 0
    if (getSS() != SavedState->SegSs) {
        char szFormat[] = "NTVDM Dpmi Error! Can't set SS to %.4X\n";
        char szMsg[sizeof(szFormat)+30];

        wsprintf(szMsg, szFormat, SavedState->SegSs);
        OutputDebugString(szMsg);
        DbgBreakPoint();
    }
#endif

    setESP(SavedState->Esp);
    setDS(SavedState->SegDs);
    setES(SavedState->SegEs);
    setFS(SavedState->SegFs);
    setGS(SavedState->SegGs);
    return SavedState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\modesw.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    modesw.c

Abstract:

    This module provides support for performing mode switching on the 32 bit
    side.

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

    Neil Sandlin (neilsa) 31-Jul-1995 - Updates for the 486 emulator

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"


RMCB_INFO DpmiRmcb[MAX_RMCBS];

USHORT RMCallBackBopSeg;
USHORT RMCallBackBopOffset;

#define SAVE_ALT_REGS(Regs) {   \
    Regs.Eip = getEIP();        \
    Regs.Esp = getESP();        \
    Regs.Cs = getCS();          \
    Regs.Ds = getDS();          \
    Regs.Es = getES();          \
    Regs.Fs = getFS();          \
    Regs.Gs = getGS();          \
    Regs.Ss = getSS();          \
    }

#define SET_ALT_REGS(Regs) {    \
    setEIP(Regs.Eip);           \
    setESP(Regs.Esp);           \
    setCS(Regs.Cs);             \
    setDS(Regs.Ds);             \
    setES(Regs.Es);             \
    setFS(Regs.Fs);             \
    setGS(Regs.Gs);             \
    setSS(Regs.Ss);             \
    }

typedef struct _ALT_REGS {
    ULONG Eip;
    ULONG Esp;
    USHORT Cs;
    USHORT Ss;
    USHORT Es;
    USHORT Ds;
    USHORT Fs;
    USHORT Gs;
} ALT_REGS, *PALT_REGS;


ALT_REGS AltRegs = {0};

VOID
DpmiSetAltRegs(
    VOID
    )
{
    DECLARE_LocalVdmContext;

    SAVE_ALT_REGS(AltRegs);
}

VOID
SetV86Exec(
    VOID
    )
/*++

Routine Description:

    This routine performs a mode switch to real (v86) mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    setMSW(getMSW() & ~MSW_PE);

#ifndef _X86_
    //BUGBUG This is a workaround to reload a 64k limit into SS for the
    // emulator, now that we are in real mode.
    // Not doing this would cause the emulator to do a hardware reset
    setSS_BASE_LIMIT_AR(getSS_BASE(), 0xffff, getSS_AR());

#else

    //
    // If we have v86 mode fast IF emulation set the RealInstruction bit
    //

    if (VdmFeatureBits & V86_VIRTUAL_INT_EXTENSIONS) {
        _asm {
            mov eax,FIXED_NTVDMSTATE_LINEAR             ; get pointer to VDM State
            lock or dword ptr [eax], dword ptr RI_BIT_MASK
        }
    } else {
        _asm {
            mov eax,FIXED_NTVDMSTATE_LINEAR         ; get pointer to VDM State
            lock and dword ptr [eax], dword ptr ~RI_BIT_MASK
        }
    }
    //
    // turn on real mode bit
    //
    _asm {
        mov     eax,FIXED_NTVDMSTATE_LINEAR             ; get pointer to VDM State
        lock or dword ptr [eax], dword ptr RM_BIT_MASK
    }

#endif

    setEFLAGS((getEFLAGS() & ~(EFLAGS_RF_MASK | EFLAGS_NT_MASK)));
    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_IN_V86, 0, 0);

}

VOID
SetPMExec(
    VOID
    )
/*++

Routine Description:

    This routine performs a mode switch to protected mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;

    setMSW(getMSW() | MSW_PE);

#ifndef _X86_
    //BUGBUG This is a workaround to make sure the emulator goes back
    // to privilege level 3 now that we are in protect mode.
    // Not doing this would cause an access violation in dpmi32.
    setCPL(3);

#else

    //
    // If we have fast if emulation in PM set the RealInstruction bit
    //
    if (VdmFeatureBits & PM_VIRTUAL_INT_EXTENSIONS) {
        _asm {
            mov eax,FIXED_NTVDMSTATE_LINEAR             ; get pointer to VDM State
            lock or dword ptr [eax], dword ptr RI_BIT_MASK
        }
    } else {
        _asm {
            mov eax, FIXED_NTVDMSTATE_LINEAR    ; get pointer to VDM State
            lock and dword ptr [eax], dword ptr ~RI_BIT_MASK
        }
    }

    //
    // Turn off real mode bit
    //
    _asm {
        mov     eax,FIXED_NTVDMSTATE_LINEAR             ; get pointer to VDM State
        lock and dword ptr [eax], dword ptr ~RM_BIT_MASK
    }

#endif

    setEFLAGS((getEFLAGS() & ~(EFLAGS_RF_MASK | EFLAGS_NT_MASK)));

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_IN_PM, 0, 0);
}

VOID
switch_to_protected_mode(
    VOID
    )

/*++

Routine Description:

    This routine is called via BOP from DOSX to transition to
    protected mode.

Arguments:

    None

Return Value:

    None.

--*/

{
    DECLARE_LocalVdmContext;
    PCHAR StackPointer;

    StackPointer = VdmMapFlat(getSS(), getSP(), getMODE());

    setCS(*(PUSHORT)(StackPointer + 12));
    setEIP(*(PULONG)(StackPointer + 8));
    setSS(*(PUSHORT)(StackPointer + 6));
    setESP(*(PULONG)(StackPointer + 2));
    setDS(*(PUSHORT)(StackPointer));

    //
    // Necessary to prevent loads of invalid selectors in FastEnterPM
    //

    setES((USHORT)0);
    setGS((USHORT)0);
    setFS((USHORT)0);

    SetPMExec();

}


VOID
switch_to_real_mode(
    VOID
    )

/*++

Routine Description:

    This routine services the switch to real mode bop.  It is included in
    DPMI.c so that all of the mode switching services are in the same place

Arguments:

    None

Return Value:

    None.

--*/

{
    DECLARE_LocalVdmContext;
    PCHAR StackPointer;


    StackPointer = VdmMapFlat(getSS(), getSP(), getMODE());

    LastLockedPMStackESP = getESP();
    LastLockedPMStackSS = getSS();

    setDS(*(PUSHORT)(StackPointer));
    setESP((ULONG) *(PUSHORT)(StackPointer + 2));
    setSS(*(PUSHORT)(StackPointer + 4));
    setEIP((ULONG) *(PUSHORT)(StackPointer + 6));
    setCS(*(PUSHORT)(StackPointer + 8));
    SetV86Exec();


}

VOID
DpmiSwitchToRealMode(
    VOID
    )
/*++

Routine Description:

    This routine is called internally from DPMI32 (i.e. Int21map)
    to switch to real mode.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DECLARE_LocalVdmContext;
    PWORD16 Data;

    // HACK ALERT
    Data = (PWORD16) VdmMapFlat(DosxRmCodeSegment, 4, VDM_V86);
    *(Data) = DosxStackSegment;

    LastLockedPMStackESP = getESP();
    LastLockedPMStackSS = getSS();

    setCS(DosxRmCodeSegment);
    SetV86Exec();

}

VOID
DpmiSwitchToProtectedMode(
    VOID
    )
/*++

Routine Description:

    This routine is called internally from DPMI32 (i.e. Int21map)
    to switch to real mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PWORD16 Data;

    // HACK ALERT
    Data = (PWORD16) VdmMapFlat(DosxRmCodeSegment, 4, VDM_V86);
    *(Data) = 0xb7;

    setESP(LastLockedPMStackESP);
    setSS(LastLockedPMStackSS);

    SetPMExec();
}

VOID
DpmiAllocateRMCallBack(
    VOID
    )
/*++

Routine Description:

    Service 03/03 -- Allocate Real Mode Call-Back Address

    In:     ax    =  selector to use to point to rm stack
            ds:si -> pMode CS:IP to be called when rMode
                     call-back address executed
            es:di -> client register structure to be updated
                     when call-back address executed
            NOTE: client's DS and ES register values are on stack

    Out:    cx:dx -> SEGMENT:offset of real mode call-back hook
            CY clear if successful, CY set if can't allocate
            call back

--*/
{
    DECLARE_LocalVdmContext;
    int i;

    for (i=0; i<MAX_RMCBS; i++) {
        if (!DpmiRmcb[i].bInUse) {
            break;
        }
    }

    if (i == MAX_RMCBS) {
        // no more rmcbs
        setCF(1);
        return;
    }

    DpmiRmcb[i].StackSel = ALLOCATE_SELECTOR();
    if (!DpmiRmcb[i].StackSel) {
        // no more selectors
        setCF(1);
        return;
    }
    SetDescriptor(DpmiRmcb[i].StackSel, 0, 0xffff, STD_DATA);

    DpmiRmcb[i].bInUse = TRUE;
    DpmiRmcb[i].StrucSeg = getES();           // get client ES register
    DpmiRmcb[i].StrucOffset = (*GetDIRegister)();
    DpmiRmcb[i].ProcSeg = getDS();
    DpmiRmcb[i].ProcOffset = (*GetSIRegister)();

    setCX(RMCallBackBopSeg - i);
    setDX(RMCallBackBopOffset + (i*16));
    setCF(0);

}

VOID
DpmiFreeRMCallBack(
    VOID
    )
/*++

Routine Description:

    Service 03/04 -- Free Real Mode Call-Back Address

    In:     cx:dx -> SEGMENT:offset of rMode call-back to free

    Out:    CY clear if successful, CY set if failure
            ax = utility selector which should be freed

--*/
{
    DECLARE_LocalVdmContext;
    USHORT i = RMCallBackBopSeg - getCX();

    if ((i >= MAX_RMCBS) || !DpmiRmcb[i].bInUse) {
        // already free or invalid callback address
        setCF(1);
        return;
    }

    DpmiRmcb[i].bInUse = FALSE;
    FreeSelector(DpmiRmcb[i].StackSel);
    setCF(0);

}

VOID
GetRMClientRegs(
    PDPMI_RMCALLSTRUCT pcs
    )
{
    DECLARE_LocalVdmContext;

    pcs->Edi = getEDI();
    pcs->Esi = getESI();
    pcs->Ebp = getEBP();
    pcs->Ebx = getEBX();
    pcs->Edx = getEDX();
    pcs->Ecx = getECX();
    pcs->Eax = getEAX();
    pcs->Flags = (WORD) getEFLAGS();
    pcs->Es = getES();
    pcs->Ds = getDS();
    pcs->Fs = getFS();
    pcs->Gs = getGS();
}

VOID
SetRMClientRegs(
    PDPMI_RMCALLSTRUCT pcs
    )
{
    DECLARE_LocalVdmContext;

    setEDI(pcs->Edi);
    setESI(pcs->Esi);
    setEBP(pcs->Ebp);
    setEBX(pcs->Ebx);
    setEDX(pcs->Edx);
    setECX(pcs->Ecx);
    setEAX(pcs->Eax);
    setEFLAGS((getEFLAGS()&0xffff0000) + (ULONG)pcs->Flags);
    setES(pcs->Es);
    setDS(pcs->Ds);
    setFS(pcs->Fs);
    setGS(pcs->Gs);

}

VOID
DpmiRMCallBackCall(
    VOID
    )
/*++

Routine Description:

    This routine gets control when the application executes the
    callback address allocated by DPMI func 0x303. Its job is
    to switch the processor into protect mode as defined by the
    DPMI spec.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PDPMI_RMCALLSTRUCT pcs;
    ULONG StackBase;
    ULONG CurBase;
    BOOL bStackBaseRestore = FALSE;
    USHORT StackSel;
    PUCHAR VdmStackPointer;
    ULONG NewSP;
    USHORT i = RMCallBackBopSeg - getCS();

    if ((i >= MAX_RMCBS) || !DpmiRmcb[i].bInUse) {
        // already free or invalid callback address
        return;
    }

    //
    // Point ip back to BOP (per dpmi)
    //
    setIP(getIP()-4);

    pcs = (PDPMI_RMCALLSTRUCT) VdmMapFlat(DpmiRmcb[i].StrucSeg,
                                          DpmiRmcb[i].StrucOffset,
                                          VDM_PM);

    GetRMClientRegs(pcs);
    pcs->Ip = getIP();
    pcs->Cs = getCS();
    pcs->Sp = getSP();
    pcs->Ss = getSS();

    // Win31 saves DS-GS on the stack here.

    StackBase = (ULONG)(pcs->Ss<<4);
    StackSel = DpmiRmcb[i].StackSel;

    CurBase = GET_SELECTOR_BASE(StackSel);

    if (StackBase != CurBase) {
        bStackBaseRestore = TRUE;
        SetDescriptorBase(StackSel, StackBase);
    }

    setESI(getSP());
    setEDI(DpmiRmcb[i].StrucOffset);

    DpmiSwitchToProtectedMode();
    BeginUseLockedPMStack();

    setDS(DpmiRmcb[i].StackSel);
    setES(DpmiRmcb[i].StrucSeg);
    BuildStackFrame(3, &VdmStackPointer, &NewSP);

    if (Frame32) {
        *(PDWORD16)(VdmStackPointer-4)  = 0x202;
        *(PDWORD16)(VdmStackPointer-8)  = PmBopFe >> 16;
        *(PDWORD16)(VdmStackPointer-12) = PmBopFe & 0x0000FFFF;
        setESP(NewSP);
    } else {
        *(PWORD16)(VdmStackPointer-2) =  0x202;
        *(PWORD16)(VdmStackPointer-4) =  (USHORT) (PmBopFe >> 16);
        *(PWORD16)(VdmStackPointer-6) =  (USHORT) PmBopFe;
        setSP((WORD)NewSP);
    }

    setEIP(DpmiRmcb[i].ProcOffset);
    setCS(DpmiRmcb[i].ProcSeg);

#ifndef _X86_
    // preserve iopl
    setEFLAGS(getEFLAGS() | 0x3000);
#endif

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_REFLECT_TO_PM, 0, 0);
    host_simulate();            // execute PM callback

    //
    // restore stack descriptor if need be
    //
    if (bStackBaseRestore) {
        SetDescriptorBase(StackSel, CurBase);
    }

    pcs = (PDPMI_RMCALLSTRUCT) VdmMapFlat(getES(),
                                          (*GetDIRegister)(),
                                          VDM_PM);

    // win31 restores GS-DS here. Is this only for End_Nest_Exec?
    EndUseLockedPMStack();
    DpmiSwitchToRealMode();
    SetRMClientRegs(pcs);
    setSP(pcs->Sp);
    setSS(pcs->Ss);
    setCS(pcs->Cs);
    setIP(pcs->Ip);
}



VOID
DpmiReflectIntrToPM(
    VOID
    )
/*++

Routine Description:

    This routine gets control when a real mode interrupt is executed that is hooked
    in protected mode. The responsibility of this routine is to switch into PM, reflect
    the interrupt, and return to real mode.

    The actual interrupt number is encoded into CS by subtracting the interrupt number
    from the normal dosx real mode code segment. IP is then adjusted accordingly to
    point to the same place.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR VdmCodePointer;
    ULONG IntNumber;
    PUCHAR VdmStackPointer;
    ULONG NewSP;
    ULONG ISRFlags;
    ULONG SaveEFlags = getEFLAGS();
    USHORT SaveBP;
    ALT_REGS RMSave;

    IntNumber = (ULONG) (HIWORD(DosxRMReflector) - getCS());

    SAVE_ALT_REGS(RMSave);

    DpmiSwitchToProtectedMode();
    setES((USHORT)0);
    setDS((USHORT)0);
    setFS((USHORT)0);
    setGS((USHORT)0);
    BeginUseLockedPMStack();
    DpmiSwIntHandler(IntNumber);

    //
    // Put unsimulate bop on the stack so we get control after the handler's iret
    //
    BuildStackFrame(3, &VdmStackPointer, &NewSP);

    if (Frame32) {
        *(PDWORD16)(VdmStackPointer-4)  = getEFLAGS();
        *(PDWORD16)(VdmStackPointer-8)  = PmBopFe >> 16;
        *(PDWORD16)(VdmStackPointer-12) = PmBopFe & 0x0000FFFF;
        setESP(NewSP);
    } else {
        *(PWORD16)(VdmStackPointer-2) =  LOWORD(getEFLAGS());
        *(PWORD16)(VdmStackPointer-4) =  (USHORT) (PmBopFe >> 16);
        *(PWORD16)(VdmStackPointer-6) =  (USHORT) PmBopFe;
        setSP((WORD)NewSP);
    }

    // Do special case processing for int24
    if (IntNumber == 0x24) {
        SaveBP = getBP();
        setBP(SegmentToSelector(SaveBP, STD_DATA));
    }

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_REFLECT_TO_PM, 0, 0);
    host_simulate();            // execute interrupt

    if (IntNumber == 0x24) {
        setBP(SaveBP);
    }

    //
    // simulate an iret for the frame generated by the SwIntHandler
    //
    if (Frame32) {
        setEIP(*(PDWORD16)(VdmStackPointer));
        setCS((USHORT)*(PDWORD16)(VdmStackPointer+4));
        setEFLAGS(*(PDWORD16)(VdmStackPointer+8));
        setESP(getESP()+12);
    } else {
        setIP(*(PWORD16)(VdmStackPointer));
        setCS(*(PWORD16)(VdmStackPointer+2));
        setEFLAGS((getEFLAGS()&0xffff0000) + *(PWORD16)(VdmStackPointer+4));
        setSP(getSP()+6);
    }
    ISRFlags = getEFLAGS();

    EndUseLockedPMStack();
    DpmiSwitchToRealMode();

    //
    // do the final iret back to the app
    //
    setESP(RMSave.Esp);
    setSS(RMSave.Ss);
    setDS(RMSave.Ds);
    setES(RMSave.Es);
    setFS(RMSave.Fs);
    setGS(RMSave.Gs);

    SimulateIret(PASS_FLAGS);
}


VOID
DpmiReflectIntrToV86(
    VOID
    )
/*++

Routine Description:

    This routine gets control when the end of the interrupt chain is reached
    in protected mode. The responsibility of this routine is to switch into V86 mode,
    reflect the interrupt, and return to protected mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PUCHAR VdmCodePointer;
    ULONG IntNumber;
    PUCHAR VdmStackPointer;
    USHORT SaveSS, SaveSP;
    USHORT SaveCS, SaveIP;
    ALT_REGS PMSave;
    ULONG IntHandler;

    VdmCodePointer = VdmMapFlat(getCS(), getIP(), VDM_PM);
    IntNumber = (ULONG) *VdmCodePointer;

    if (DispatchPMInt((UCHAR)IntNumber)) {
        return;
    }

    SAVE_ALT_REGS(PMSave);
    DpmiSwitchToRealMode();

    //
    // find a safe stack to run on in v86 mode
    //
    SaveSS = getSS();
    SaveSP = getSP();
    SWITCH_TO_DOSX_RMSTACK();

    //
    // Put unsimulate bop on the stack so we get control after the handler's iret
    //
    VdmStackPointer = VdmMapFlat(getSS(), getSP(), VDM_V86);

    SaveCS = getCS();
    SaveIP = getIP();

    *(PWORD16)(VdmStackPointer-2) =  LOWORD(getEFLAGS());
    *(PWORD16)(VdmStackPointer-4) =  (USHORT) (RmBopFe >> 16);
    *(PWORD16)(VdmStackPointer-6) =  (USHORT) RmBopFe;
    setSP(getSP() - 6);

    IntHandler = *(PDWORD16) (IntelBase + IntNumber*4);
    setIP(LOWORD(IntHandler));
    setCS(HIWORD(IntHandler));

    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_REFLECT_TO_V86, 0, 0);
    host_simulate();            // execute interrupt

    setIP(SaveIP);
    setCS(SaveCS);
    setSP(SaveSP);
    setSS(SaveSS);
    SWITCH_FROM_DOSX_RMSTACK();

    DpmiSwitchToProtectedMode();

    //
    // do the final iret back to the app
    //
    setESP(PMSave.Esp);
    setSS(PMSave.Ss);
    setDS(PMSave.Ds);
    setES(PMSave.Es);
    setFS(PMSave.Fs);
    setGS(PMSave.Gs);

    SimulateIret(PASS_FLAGS);
}

VOID
DpmiRMCall(
    UCHAR mode
    )
/*++

Routine Description:

    This routine gets control when an Int31 func 300-302 is executed.
    The responsibility of this routine is to switch into V86 mode,
    reflect the interrupt, and return to protected mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    CLIENT_REGS SaveRegs;
    PDPMI_RMCALLSTRUCT pcs;
    BOOL bUsingOurStack;
    PUCHAR RmStackPointer, PmStackPointer;
    USHORT CopyLen;
    ULONG PmSp = (*GetSPRegister)();

    pcs = (PDPMI_RMCALLSTRUCT) VdmMapFlat(getES(),
                                          (*GetDIRegister)(),
                                          VDM_PM);

    SAVE_CLIENT_REGS(SaveRegs);
    DpmiSwitchToRealMode();

    //
    // This bop will get us back from host_simulate
    //
    setCS((USHORT)(RmBopFe >> 16));
    setIP((USHORT)RmBopFe);

    SetRMClientRegs(pcs);

    if (!pcs->Ss && !pcs->Sp) {
        SWITCH_TO_DOSX_RMSTACK();
        bUsingOurStack = TRUE;
    } else {
        setSS(pcs->Ss);
        setSP(pcs->Sp);
        bUsingOurStack = FALSE;
    }


    if (CopyLen = LOWORD(SaveRegs.Ecx)) {
        CopyLen *= 2;
        setSP(getSP() - CopyLen);
        PmStackPointer = VdmMapFlat(SaveRegs.Ss, PmSp, VDM_PM);
        RmStackPointer = VdmMapFlat(getSS(), getSP(), VDM_V86);
        RtlCopyMemory(RmStackPointer, PmStackPointer, CopyLen);
    }

    //
    // switch on MODE
    //
    switch(mode) {

    case 0:
        // Simulate Int
        EmulateV86Int((UCHAR)SaveRegs.Ebx);
        break;
    case 1:
        // Call with FAR return frame
        SimulateFarCall(pcs->Cs, pcs->Ip);
        break;
    case 2:
        // Call with IRET frame
        SimulateCallWithIretFrame(pcs->Cs, pcs->Ip);
        break;

    }
    DBGTRACE(VDMTR_TYPE_DPMI | DPMI_REFLECT_TO_V86, 0, 0);
    host_simulate();            // execute interrupt

    if (bUsingOurStack) {
        SWITCH_FROM_DOSX_RMSTACK();
    }

    GetRMClientRegs(pcs);
    DpmiSwitchToProtectedMode();
    SET_CLIENT_REGS(SaveRegs);
    setCF(0);                   // function successful
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\register.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Register.c

Abstract:

    This module contains code to allow us to get and set registers that could
    be 16 bits or 32 bits, depending on whether a 16 bit dpmi app is running.

Author:

    Dave Hastings (daveh) 12-Dec-1992

Revision History:

--*/

//
// Note:  We undef the following constant so that we will get the function
//        versions of the register functions.  We can not put a macro into
//        a function pointer
//

#include <precomp.h>
#pragma hdrstop
#undef LINKED_INTO_MONITOR
#include <softpc.h>


//
// Internal functions
//
ULONG
IgetCX(
    VOID
    );

ULONG
IgetDX(
    VOID
    );

ULONG
IgetDI(
    VOID
    );

ULONG
IgetSI(
    VOID
    );

ULONG
IgetBX(
    VOID
    );

ULONG
IgetAX(
    VOID
    );

ULONG
IgetSP(
    VOID
    );

//
// Register manipulation functions (for register that might be 16 or 32 bits)
//
GETREGISTERFUNCTION GetCXRegister = IgetCX;
GETREGISTERFUNCTION GetDXRegister = IgetDX;
GETREGISTERFUNCTION GetDIRegister = IgetDI;
GETREGISTERFUNCTION GetSIRegister = IgetSI;
GETREGISTERFUNCTION GetBXRegister = IgetBX;
GETREGISTERFUNCTION GetAXRegister = IgetAX;
GETREGISTERFUNCTION GetSPRegister = IgetSP;

SETREGISTERFUNCTION SetCXRegister = (SETREGISTERFUNCTION) setCX;
SETREGISTERFUNCTION SetDXRegister = (SETREGISTERFUNCTION) setDX;
SETREGISTERFUNCTION SetDIRegister = (SETREGISTERFUNCTION) setDI;
SETREGISTERFUNCTION SetSIRegister = (SETREGISTERFUNCTION) setSI;
SETREGISTERFUNCTION SetBXRegister = (SETREGISTERFUNCTION) setBX;
SETREGISTERFUNCTION SetAXRegister = (SETREGISTERFUNCTION) setAX;
SETREGISTERFUNCTION SetSPRegister = (SETREGISTERFUNCTION) setSP;

VOID
DpmiInitRegisterSize(
    VOID
    )
/*++

Routine Description:

    This routine sets up the function pointers.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (CurrentAppFlags & DPMI_32BIT) {
        GetCXRegister = getECX;
        GetDXRegister = getEDX;
        GetDIRegister = getEDI;
        GetSIRegister = getESI;
        GetBXRegister = getEBX;
        GetAXRegister = getEAX;
        GetSPRegister = IgetSP;
        SetCXRegister = setECX;
        SetDXRegister = setEDX;
        SetDIRegister = setEDI;
        SetSIRegister = setESI;
        SetBXRegister = setEBX;
        SetAXRegister = setEAX;
        SetSPRegister = setESP;
    } else {
        //
        // Note: we have to call an internal function, because the actual
        //       function only returns 16 bits, the others are undefined
        //
        GetCXRegister = IgetCX;
        GetDXRegister = IgetDX;
        GetDIRegister = IgetDI;
        GetSIRegister = IgetSI;
        GetBXRegister = IgetBX;
        GetAXRegister = IgetAX;
        GetSPRegister = IgetSP;
        //
        // Note: we take advantage of the fact that the compiler always
        //       pushes 32 bits on the stack
        //
        SetCXRegister = (SETREGISTERFUNCTION) setCX;
        SetDXRegister = (SETREGISTERFUNCTION) setDX;
        SetDIRegister = (SETREGISTERFUNCTION) setDI;
        SetSIRegister = (SETREGISTERFUNCTION) setSI;
        SetBXRegister = (SETREGISTERFUNCTION) setBX;
        SetAXRegister = (SETREGISTERFUNCTION) setAX;
        SetSPRegister = (SETREGISTERFUNCTION) setSP;
    }
}

ULONG
IgetCX(
    VOID
    )
{
    return (ULONG)getCX();
}

ULONG
IgetDX(
    VOID
    )
{
    return (ULONG)getDX();
}

ULONG
IgetDI(
    VOID
    )
{
    return (ULONG)getDI();
}

ULONG
IgetSI(
    VOID
    )
{
    return (ULONG)getSI();
}

ULONG
IgetBX(
    VOID
    )
{
    return (ULONG)getBX();
}

ULONG
IgetAX(
    VOID
    )
{
    return (ULONG)getAX();
}

ULONG
IgetSP(
    VOID
    )
{
    //
    // Note: this routine returns the #of bits based on the size (b bit)
    // of ss.  If we don't, bad things happen

    if (Ldt[(getSS() & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
        return getESP();
    } else {
        return (ULONG)getSP();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\int31.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Int31.c

Abstract:

    This module provides the int 31 API for dpmi

Author:

    Neil Sandlin (neilsa) 23-Nov-1996


Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include "xlathlp.h"

VOID Int31NotImplemented(VOID);
VOID Int31SelectorManagement(VOID);
VOID Int31DOSMemoryManagement(VOID);
VOID Int31InterruptManagement(VOID);
VOID Int31Translation(VOID);
VOID Int31Function4xx(VOID);
VOID Int31MemoryManagement(VOID);
VOID Int31PageLocking(VOID);
VOID Int31DemandPageTuning(VOID);
VOID Int31VirtualIntState(VOID);
VOID Int31DbgRegSupport(VOID);

//
// Local constants
//
#define MAX_DPMI_MAJOR_FUNCTION 0xb

typedef VOID (*APIFUNCTION)(VOID);
APIFUNCTION DpmiMajorFunctionTable[MAX_DPMI_MAJOR_FUNCTION+1] = {

    Int31SelectorManagement , // Selector_Management    ;[0]
    Int31DOSMemoryManagement, // DOS_Mem_Mgt            ;[1]
    Int31InterruptManagement, // Int_Serv               ;[2]
    Int31Translation        , // Trans_Serv             ;[3]
    Int31Function4xx        , // Get_Version            ;[4]
    Int31MemoryManagement   , // Mem_Managment          ;[5]
    Int31PageLocking        , // Page_Lock              ;[6]
    Int31DemandPageTuning   , // Demand_Page_Tuning     ;[7]
    Int31NotImplemented     , // Phys_Addr_Mapping      ;[8]
    Int31VirtualIntState    , // Virt_Interrrupt_State  ;[9]
    Int31NotImplemented     , // Not_Supported          ;[A]
    Int31DbgRegSupport      , // Debug_Register_Support ;[B]

};

VOID
DpmiInt31Entry(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when the caller has issued an int31.

Arguments:

    None

Return Value:

    None.

--*/
{

    DECLARE_LocalVdmContext;
    ULONG DpmiMajorCode = getAH();
    PUCHAR StackPointer;

    //
    // Pop ds from stack
    //
    StackPointer = VdmMapFlat(getSS(), (*GetSPRegister)(), VDM_PM);

    setDS(*(PWORD16)StackPointer);
    (*SetSPRegister)((*GetSPRegister)() + 2);

    //
    // Take the iret frame off the stack before we do the operation. This
    // way we have the stack pointer set up to the same place as we would
    // if this was a kernel mode dpmi host.
    //
    SimulateIret(RESTORE_FLAGS);

    setCF(0);       // assume success

    if (DpmiMajorCode <= MAX_DPMI_MAJOR_FUNCTION) {

        (*DpmiMajorFunctionTable[DpmiMajorCode])();

    } else {
        setCF(1);
    }

}

VOID
DpmiInt31Call(
    VOID
    )
/*++

Routine Description:

    This routine dispatches to the appropriate routine to perform the
    actual translation of the api

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    ULONG DpmiMajorCode = getAH();
    PUCHAR StackPointer;

    //
    // Pop ds from stack
    //
    StackPointer = VdmMapFlat(getSS(), (*GetSPRegister)(), VDM_PM);

    setDS(*(PWORD16)StackPointer);
    (*SetSPRegister)((*GetSPRegister)() + 2);

    setCF(0);       // assume success

    if (DpmiMajorCode <= MAX_DPMI_MAJOR_FUNCTION) {

        (*DpmiMajorFunctionTable[DpmiMajorCode])();

    } else {
        setCF(1);
    }

}

VOID
Int31NotImplemented(
    VOID
    )
/*++

Routine Description:

    This routine handles int 31 functions that aren't implemented on NT.
    It just returns carry to the app.

Arguments:

    None

Return Value:

    TRUE - The function has been completed

--*/
{
    DECLARE_LocalVdmContext;

    setCF(1);
}

VOID
Int31SelectorManagement(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 00xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Sel;
    USHORT NewSel;
    UCHAR Func = getAL();
    LDT_ENTRY UNALIGNED *Descriptor;
    USHORT Access;
    ULONG Base;
    USHORT Count;
    ULONG Limit;
    static UCHAR ReservedSelectors[16] = {0};

    //
    // First, validate the selector
    //
    if ((Func >= 4) && (Func <= 0xC)) {
        Sel = getBX() & SEL_INDEX_MASK;

        //
        // Make sure the selector in question is allocated
        //
        if (((Sel <= SEL_DPMI_LAST) && (!ReservedSelectors[Sel>>3])) ||
             (Sel > LdtMaxSel) ||
            ((Sel > SEL_DPMI_LAST) && IS_SELECTOR_FREE(Sel))) {
            setCF(1);
            return;
        }

    }

    switch(Func) {

    //
    // Allocate Selectors
    //
    case 0:
        Count = getCX();
        Sel = ALLOCATE_SELECTORS(Count);

        if (!Sel || !Count) {
            setCF(1);
            break;
        }

        setAX(Sel);
        while(Count--) {
            SetDescriptor(Sel, 0, 0, STD_DATA);
            Sel+=8;
        }
        break;

    //
    // Free Selector
    //
    case 1:
        Sel = getBX() & SEL_INDEX_MASK;

        if (Sel <= SEL_DPMI_LAST) {
            if (!ReservedSelectors[Sel>>3]) {
                setCF(1);
            } else {
                ReservedSelectors[Sel>>3] = 0;
            }
            break;
        }

        if (!FreeSelector(Sel)) {
            setCF(1);
        }

        if (getCF() == 0) {
            // Zero out segment registers if it contains what we just freed
            // shielint: fs, gs, ss??? kernel will fix fs and gs for us. SS is unlikely
            // to have the freed selector.  If yes, the app is gone anyway.
            if (getBX() == getDS()) {
                setDS(0);
            }
            if (getBX() == getES()) {
                setES(0);
            }
        }
        break;

    //
    // Segment to Descriptor
    //
    case 2:
        Sel = SegmentToSelector(getBX(), STD_DATA);
        if (!Sel) {
            setCF(1);
        } else {
            setAX(Sel);
        }
        break;

    //
    // Get Next Selector Increment value
    //
    case 3:
        setAX(8);
        break;

    //
    // Lock functions unimplemented on NT
    //
    case 4:
    case 5:
        break;

    //
    // Get Descriptor Base
    //
    case 6:
        Base = GET_SELECTOR_BASE(Sel);
        setDX((USHORT)Base);
        setCX((USHORT)(Base >> 16));
        break;

    //
    // Set Descriptor Base
    //
    case 7:
        SetDescriptorBase(Sel, (((ULONG)getCX())<<16) | getDX());
        break;

    //
    // Set Segment Limit
    //
    case 8:
        Limit = ((ULONG)getCX()) << 16 | getDX();

        if (Limit < 0x100000) {         // < 1Mb?
            Ldt[Sel>>3].HighWord.Bits.Granularity = 0;
        } else {
            if ((Limit & 0xfff) != 0xfff) {

                // Limit > 1MB, but not page aligned. Return error
                setCF(1);
                break;
            }

            Ldt[Sel>>3].HighWord.Bits.Granularity = 1;

        }

        SET_SELECTOR_LIMIT(Sel, Limit);
        SetShadowDescriptorEntries(Sel, 1);
        FLUSH_SELECTOR_CACHE(Sel, 1);
        break;

    //
    // Set Descriptor Access
    //
    case 9:
        Access = getCX();
        //
        // verify that they aren't setting "System", and that its ring3
        //
        if ((Access & 0x70) != 0x70) {
            setCF(1);
            break;
        }

        SET_SELECTOR_ACCESS(Sel, Access);
        SetShadowDescriptorEntries(Sel, 1);
        FLUSH_SELECTOR_CACHE(Sel, 1);
        break;

    //
    // Create data alias
    //
    case 0xA:
        if (!IS_SELECTOR_READABLE(Sel)) {
            setCF(1);
            break;
        }

        NewSel = ALLOCATE_SELECTOR();
        if (!NewSel) {
            setCF(1);
            break;
        }

        Ldt[NewSel>>3] = Ldt[Sel>>3];

        Ldt[NewSel>>3].HighWord.Bytes.Flags1 &= (AB_PRESENT | AB_DPL3);
        Ldt[NewSel>>3].HighWord.Bytes.Flags1 |= (AB_DATA | AB_WRITE);
        SetShadowDescriptorEntries(NewSel, 1);
        FLUSH_SELECTOR_CACHE(NewSel, 1);

        setAX(NewSel);
        break;

    //
    // Get Descriptor
    //
    case 0xB:
        Descriptor = VdmMapFlat(getES(), (*GetDIRegister)(), VDM_PM);
        *Descriptor = Ldt[Sel>>3];
        break;

    //
    // Set Descriptor
    //
    case 0xC:
        Descriptor = VdmMapFlat(getES(), (*GetDIRegister)(), VDM_PM);

        //
        // verify that this isn't a System descriptor, and that its ring3
        //
        if (!(Descriptor->HighWord.Bits.Type & 0x10) ||
            ((Descriptor->HighWord.Bits.Dpl & 3) != 3)) {
            setCF(1);
            return;
        }

        Ldt[Sel>>3] = *Descriptor;

        SetShadowDescriptorEntries(Sel, 1);
        FLUSH_SELECTOR_CACHE(Sel, 1);
        break;

    //
    // Allocate Specific Sel
    //
    case 0xD:
        Sel = getBX() & ~7;

        if ((Sel > SEL_DPMI_LAST) || ReservedSelectors[Sel>>3]) {
            setCF(1);
        } else {
            ReservedSelectors[Sel>>3] = 1;
        }
        break;

    default:
        setCF(1);
    }

    return;
}

VOID
Int31DOSMemoryManagement(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 01xx functions.
    The functionality is implemented in dosmem.c.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;

    switch(getAL()) {

    //
    // Allocate DOS memory block
    //
    case 0:
        DpmiAllocateDosMem();
        break;

    //
    // Free DOS memory block
    //
    case 1:
        DpmiFreeDosMem();
        break;

    //
    // Resize DOS memory block
    //
    case 2:
        DpmiSizeDosMem();
        break;

    }
}

VOID
Int31InterruptManagement(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 02xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    UCHAR IntNumber = getBL();
    PWORD16 pIvtEntry;

    switch(getAL()) {

    //
    // Get Real Mode Interrupt Vector
    //
    case 0:
        pIvtEntry = (PWORD16) (IntelBase + IntNumber*4);

        setDX(*pIvtEntry++);
        setCX(*pIvtEntry);
        break;

    //
    // Set Real Mode Interrupt Vector
    //
    case 1:
        pIvtEntry = (PWORD16) (IntelBase + IntNumber*4);

        *pIvtEntry++ = getDX();
        *pIvtEntry = getCX();
        break;

    //
    // Get exception handler Vector
    //
    case 2: {
        PVDM_FAULTHANDLER Handlers = DpmiFaultHandlers;

        if (IntNumber >= 32) {
            setCF(1);
            break;
        }

        setCX(Handlers[IntNumber].CsSelector);
        (*SetDXRegister)(Handlers[IntNumber].Eip);

        break;
    }

    //
    // Set exception handler Vector
    //
    case 3:
        if (!SetFaultHandler(IntNumber, getCX(), (*GetDXRegister)())){
            setCF(1);
        }
        break;

    //
    // Get Protect Mode Interrupt Vector
    //
    case 4: {
        PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;

        setCX(Handlers[IntNumber].CsSelector);
        (*SetDXRegister)(Handlers[IntNumber].Eip);

        break;
    }

    //
    // Set Protect Mode Interrupt Vector
    //
    case 5:
        if (!SetProtectedModeInterrupt(IntNumber, getCX(), (*GetDXRegister)(),
                                       (USHORT)(Frame32 ? VDM_INT_32 : VDM_INT_16))) {
            setCF(1);
        }
        break;

    }

}



VOID
Int31Translation(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 03xx functions.
    The functionality is implemented in modesw.c.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;

    switch(getAL()) {

    //
    // Simulate Real Mode Interrupt
    // Call Real Mode Procedure with Far Return Frame
    // Call Real Mode Procedure with Iret Frame
    //
    case 0:
    case 1:
    case 2:
        DpmiRMCall(getAL());
        break;

    //
    // Allocate Real Mode Call-Back Address
    //
    case 3:
        DpmiAllocateRMCallBack();
        break;

    //
    // Free Real Mode Call-Back Address
    //
    case 4:
        DpmiFreeRMCallBack();
        break;

    //
    // Get State Save/Restore Addresses
    //
    case 5:
        setAX(0);
        setBX((USHORT)(DosxRmSaveRestoreState>>16));
        setCX((USHORT)DosxRmSaveRestoreState);
        setSI((USHORT)(DosxPmSaveRestoreState>>16));
        (*SetDIRegister)(DosxPmSaveRestoreState & 0x0000FFFF);
        break;

    //
    // Get Raw Mode Switch Addresses
    //
    case 6:
        setBX((USHORT)(DosxRmRawModeSwitch>>16));
        setCX((USHORT)DosxRmRawModeSwitch);
        setSI((USHORT)(DosxPmRawModeSwitch>>16));
        (*SetDIRegister)(DosxPmRawModeSwitch & 0x0000FFFF);
        break;

    }

}

VOID
Int31Function4xx(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 04xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    USHORT Sel;

    switch(getAL()) {

    //
    // Get Version
    //
    case 0:
        setAX(I31VERSION);
        setBX(I31FLAGS);
        setCL(idCpuType);
        setDX((I31MasterPIC << 8) | I31SlavePIC);
        break;


    //
    // INTERNAL NT FUNCTION: WowAllocSelectors
    // This function is equivalent to DPMI func 0000,
    // except that it skips the step of initializing the
    // descriptors.
    //
    case 0xf1:
        Sel = ALLOCATE_WOW_SELECTORS(getCX());


        if (!Sel) {
            setCF(1);
            // We fall thru to make sure AX is set to 0 in the failure case.
        }

        setAX(Sel);

        break;
    //
    // INTERNAL NT FUNCTION: WowSetDescriptor
    // This function assumes that the local LDT has already
    // been set in the client. All that needs to be done
    // is an update of dpmi32 entries, as well as sending
    // it to the x86 ntoskrnl.
    //
    case 0xf2:

        Sel = getBX() & ~7;

        if (Sel > LdtMaxSel) {
            setCF(1);
            break;
        }

        SetShadowDescriptorEntries(Sel, getCX());
        // no need to flush the cache on risc since the ldt was changed
        // from the 16-bit side, and has thus already been flushed
        break;

    //
    // INTERNAL NT FUNCTION: WowSetLowMemFuncs
    // Wow is passing us the address of GlobalDOSAlloc, GlobalDOSFree
    // so that we can support the DPMI Dos memory management functions
    //
    case 0xf3:
        WOWAllocSeg = getBX();
        WOWAllocFunc = getDX();
        WOWFreeSeg = getSI();
        WOWFreeFunc = getDI();
        break;

    }

}

VOID
Int31MemoryManagement(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 05xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    PMEM_DPMI pMem;

    switch(getAL()) {

    //
    // Get Free Memory Information
    //
    case 0:
        DpmiGetMemoryInfo();
        break;

    //
    // Allocate Memory Block
    //
    case 1:
        pMem = DpmiAllocateXmem(((ULONG)getBX() << 16) | getCX());

        if (!pMem) {
            setCF(1);
            break;
        }
        //
        // Return the information about the block
        //
        setBX((USHORT)((ULONG)pMem->Address >> 16));
        setCX((USHORT)((ULONG)pMem->Address & 0x0000FFFF));
        setSI((USHORT)((ULONG)pMem >> 16));
        setDI((USHORT)((ULONG)pMem & 0x0000FFFF));
        break;

    //
    // Free Memory Block
    //
    case 2:
        pMem = (PMEM_DPMI)(((ULONG)getSI() << 16) | getDI());
        if (!DpmiIsXmemHandle(pMem) || !DpmiFreeXmem(pMem)) {
            setCF(1);
        }
        break;

    //
    // Resize Memory Block
    //
    case 3: {

        ULONG ulMemSize;

        ulMemSize = ((ULONG)getBX() << 16) | getCX();

        //
        // Not allowed to resize to 0
        //
        if ( ulMemSize != 0 ) {

            pMem = (PMEM_DPMI)(((ULONG)getSI() << 16) | getDI());

            if (!DpmiReallocateXmem(pMem, ulMemSize) ) {
                setCF(1);
                break;
            }

            //
            // Return the information about the block
            //
            setBX((USHORT)((ULONG)pMem->Address >> 16));
            setCX((USHORT)((ULONG)pMem->Address & 0x0000FFFF));
        }
        else
        {
            setCF(1);
        }

        break;
        }

    }

}

VOID
Int31PageLocking(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 06xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    switch(getAL()) {

    //
    // Lock functions not implemented
    //
    case 0:
    case 1:
    case 2:
    case 3:
        break;

    //
    // Get Page Size
    //
    case 4:
        setBX(0);
        setCX(0x1000);
        break;

    }

}


VOID
Int31DemandPageTuning(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 07xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    ULONG Addr = (getBX()<<16 | getCX()) + IntelBase;
    ULONG Count = getSI()<<16 | getDI();

    if (Count) {

        switch(getAL()) {

        //
        // Mark Page as Demand Paging Candidate
        //

        case 0:
            // Addr, Count expressed in 4k pages
            Addr <<= 12;
            Count <<= 12;
        case 2:

            VirtualUnlock((PVOID)Addr, Count);

            break;

        //
        // Discard Page Contents
        //

        case 1:
            // Addr, Count expressed in 4k pages
            Addr <<= 12;
            Count <<= 12;
        case 3:

            VirtualAlloc((PVOID)Addr, Count, MEM_RESET, PAGE_READWRITE);

            break;

        default:
            setCF(1);
        }

    }

}

VOID
Int31VirtualIntState(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 09xx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;
    BOOL bVIF = *(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) & VDM_VIRTUAL_INTERRUPTS;

    switch(getAL()) {

    //
    // Get and disable Virtual Interrupt State
    //

    case 0:
        setEFLAGS(getEFLAGS() & ~EFLAGS_IF_MASK);
        break;

    //
    // Get and enable Virtual Interrupt State
    //

    case 1:
        setEFLAGS(getEFLAGS() | EFLAGS_IF_MASK);
        break;


    case 2:
        break;

    default:
        setCF(1);
        return;
    }

    if (bVIF) {
        setAL(1);
    } else {
        setAL(0);
    }
}


VOID
Int31DbgRegSupport(
    VOID
    )
/*++

Routine Description:

    This routine handles Int31 0bxx functions.

Arguments:

    None

Return Value:

    None

--*/
{
    DECLARE_LocalVdmContext;

#ifndef _X86_
    setCF(1);
#else
    ULONG DebugRegisters[6];
    USHORT Handle;
    ULONG Mask;
    ULONG Size;
    ULONG Type;
    UCHAR Func = getAL();

#define DBG_TYPE_EXECUTE 0
#define DBG_TYPE_WRITE 1
#define DBG_TYPE_READWRITE 2
#define DBG_DR6 4
#define DBG_DR7 5

#define DR7_LE 0x100
#define DR7_L0 0x01
#define DR7_L1 0x04
#define DR7_L2 0x10
#define DR7_L3 0x40

//
// Debugging ntvdm under NTSD affects the values of the debug register
// context, so defining the following value turns on some debugging
// code
//
//#define DEBUGGING_DEBUGREGS 1

    if (!DpmiGetDebugRegisters(DebugRegisters)) {
        setCF(1);
        return;
    }

#ifdef DEBUGGING_DEBUGREGS
    {
        char szMsg[256];
        wsprintf(szMsg, " DR0-3=%.8X %.8X %.8X %.8X DR6,7=%.8X %.8X\n",
                        DebugRegisters[0],
                        DebugRegisters[1],
                        DebugRegisters[2],
                        DebugRegisters[3],
                        DebugRegisters[DBG_DR6],
                        DebugRegisters[DBG_DR7]);
        OutputDebugString(szMsg);
    }
#endif

    if (Func != 0) {
        Handle = getBX();
        //
        // point at the local enable bit for this handle in DR7
        //
        Mask = (DR7_L0 << Handle*2);

        if ((Handle >= 4) ||
            (!(DebugRegisters[DBG_DR7] & Mask))) {
            // Invalid Handle
            setCF(1);
            return;
        }

    }


    switch(Func) {

    //
    // Set Debug Watchpoint
    //

    case 0:

        for (Handle = 0, Mask = 3; Handle < 4; Handle++, Mask <<= 2) {
            if (!(DebugRegisters[DBG_DR7] & Mask)) {
                //
                // found a free register
                //

                //
                // Set the linear address
                //
                DebugRegisters[Handle] = (((ULONG)getBX()) << 16) + getCX();

                Size = getDL();
                Type = getDH();

                if (Type == DBG_TYPE_EXECUTE) {
                    // force size to be 1 for execute
                    Size = 1;
                }

                if ((Size > 4) || (Size == 3) || (!Size) || (Type > 2)) {
                    // error: invalid parameter
                    break;
                }

                //
                // convert size to appropriate bits in DR7
                //
                Size--;
                Size <<= (18 + Handle*4);

                //
                // convert type to appropriate bits in DR7
                //
                if (Type == DBG_TYPE_READWRITE) {
                    Type++;
                }
                Type <<= (16 + Handle*4);

                Mask = 0xf << (16 + Handle*4);

                //
                // Set the appropriate Len, R/W, and enable bits in DR7
                // Also set the common global and local enable bits.
                //
                DebugRegisters[DBG_DR7] &= ~Mask;
                DebugRegisters[DBG_DR7] |= (Size | Type | (DR7_L0 << Handle*2));
                DebugRegisters[DBG_DR7] |= DR7_LE;

                //
                // Clear triggered bit for this BP
                //
                DebugRegisters[DBG_DR6] &= ~(1 << Handle);

#ifdef DEBUGGING_DEBUGREGS
                {
                    char szMsg[256];
                    wsprintf(szMsg, "Int31 Setting DBGREG %d, Location %.8X, DR7=%.8X\n",
                            Handle, DebugRegisters[Handle], DebugRegisters[DBG_DR7]);
                    OutputDebugString(szMsg);
                }
#endif

                if (DpmiSetDebugRegisters(DebugRegisters)) {
                    return;
                }
                break;
            }
        }

        setCF(1);
        break;

    //
    // Clear Debug Watchpoint
    //

    case 1:

        //
        // clear enabled and triggered bits for this BP
        //

        DebugRegisters[DBG_DR7] &= ~Mask;
        DebugRegisters[DBG_DR6] &= (1 << Handle);
        DebugRegisters[Handle] = 0;

        //
        // Check to see if this clears all BP's (all local enable bits
        // clear), and disable common enable bit if so
        //
        if (!(DebugRegisters[DBG_DR7] & (DR7_L0 | DR7_L1 | DR7_L2 | DR7_L3))) {
            DebugRegisters[DBG_DR7] &= ~DR7_LE;
        }

#ifdef DEBUGGING_DEBUGREGS
        {
            char szMsg[256];
            wsprintf(szMsg, "Int31 Clearing DBGREG %d, DR7=%.8X\n",
                            Handle, DebugRegisters[DBG_DR7]);
            OutputDebugString(szMsg);
        }
#endif
        if (!DpmiSetDebugRegisters(DebugRegisters)) {
            setCF(1);
        }

        break;

    //
    // Get State of Debug Watchpoint
    //

    case 2:
        if (DebugRegisters[DBG_DR6] & (1 << Handle)) {
            setAX(1);
        } else {
            setAX(0);
        }

#ifdef DEBUGGING_DEBUGREGS
        {
            char szMsg[256];
            wsprintf(szMsg, "Int31 Query on DBGREG %d returns %d\n", Handle, getAX());
            OutputDebugString(szMsg);
        }
#endif
        break;

    //
    // Reset Debug Watchpoint
    //

    case 3:
        DebugRegisters[DBG_DR6] &= ~(1 << Handle);

#ifdef DEBUGGING_DEBUGREGS
        {
            char szMsg[256];
            wsprintf(szMsg, "Int31 Resetting DBGREG %d\n", Handle);
            OutputDebugString(szMsg);
        }
#endif
        if (!DpmiSetDebugRegisters(DebugRegisters)) {
            setCF(1);
        }

        break;

    default:
        setCF(1);
    }


#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\stack.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Stack.c

Abstract:

    This module implements routines for manipulating the 16 bit stack

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"

#if 0   // Disable the code for now
VOID
FreePMStack(
    USHORT Sel
    );

USHORT
AllocatePMStack(
    USHORT MemSize
    );

#endif

VOID
DpmiPushRmInt(
    USHORT InterruptNumber
    )
/*++

Routine Description:

    This routine pushes an interrupt frame on the stack and sets up cs:ip
    for the specified interrupt.

Arguments:

    InterruptNumber -- Specifies the index of the interrupt

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    PWORD16 StackPointer;
    ULONG IntHandler;

    // bugbug stack wrap???

    ASSERT((getSP() > 6));
    ASSERT((!(getMSW() & MSW_PE)));

    StackPointer = (PWORD16)VdmMapFlat(getSS(), getSP(), VDM_V86);

    *(StackPointer - 3) = (USHORT)(RmBopFe & 0x0000FFFF);
    *(StackPointer - 2) = (USHORT)(RmBopFe >> 16);
    *(StackPointer - 1) = getSTATUS();

    setSP(getSP() - 6);

    IntHandler = *(PDWORD16) (IntelBase + InterruptNumber*4);
    setIP(LOWORD(IntHandler));
    setCS(HIWORD(IntHandler));
}

VOID
BeginUseLockedPMStack(
    VOID
    )
/*++

Routine Description:

    This routine switches to the protected DPMI stack as specified by
    the DPMI spec. We remember the original values of EIP and ESP in
    global variables if we are at level zero. This allows us to correctly
    return to a 32 bit routine if we are dispatching a 16-bit interrupt
    frame.


--*/

{
    DECLARE_LocalVdmContext;
#if 0  // Disabled for now
    if (LockedPMStackSel == 0) {
        LockedPMStackSel = AllocatePMStack(LockedPMStackOffset);  // LockedPMStackOffset is acturally the size
        LockedPMStackCount = 0;

        //
        // Note the stack allocation may still fail.  In this case, the setSS() will set SS selector
        // to zero and the error will be catched during BuildStackFrame() call
        //

    }
#endif
    if (!LockedPMStackCount++) {

        DBGTRACE(VDMTR_TYPE_DPMI | DPMI_SWITCH_STACKS, (USHORT)LockedPMStackSel, LockedPMStackOffset);

        PMLockOrigEIP = getEIP();
        PMLockOrigSS = getSS();
        PMLockOrigESP = getESP();
        setSS(LockedPMStackSel);
        setESP(LockedPMStackOffset);
    }
}

BOOL
EndUseLockedPMStack(
    VOID
    )
/*++

Routine Description:

    This routine switches the stack back off the protected DPMI stack,
    if we are popping off the last frame on the stack.

Return Value:

    TRUE if the stack was switched back, FALSE otherwise

--*/


{
    DECLARE_LocalVdmContext;

    if (!--LockedPMStackCount) {

        //
        // We probably should free the PM stack except the one passed from DOSX??
        //

        DBGTRACE(VDMTR_TYPE_DPMI | DPMI_SWITCH_STACKS, (USHORT)PMLockOrigSS, PMLockOrigESP);

        setEIP(PMLockOrigEIP);
        setSS((WORD)PMLockOrigSS);
        setESP(PMLockOrigESP);
        return TRUE;
    }
    return FALSE;

}


BOOL
BuildStackFrame(
    ULONG StackUnits,
    PUCHAR *pVdmStackPointer,
    ULONG *pNewSP
    )
/*++

Routine Description:

    This routine builds stack frames for the caller. It figures if it needs
    to use a 16 or 32-bit frame, and adjusts SP or ESP appropriately based
    on the number of "stack units". It also returns a flat pointer to the
    top of the frame to the caller.

Arguments:

    StackUnits = number of registers needed to be saved on the frame. For
                 example, 3 is how many elements there are on an iret frame
                 (flags, cs, ip)

Return Value:

    This function returns TRUE on success, FALSE on failure

    VdmStackPointer - flat address pointing to the "top" of the frame

Notes:

    BUGBUG This routine doesn't check for stack faults or 'UP' direction
           stacks
--*/

{
    DECLARE_LocalVdmContext;
    USHORT SegSs;
    ULONG VdmSp;
    PUCHAR VdmStackPointer;
    ULONG StackOffset;
    ULONG Limit;
    ULONG SelIndex;
    ULONG NewSP;
    BOOL bExpandDown;
    BOOL rc;

    rc = TRUE;
    SegSs = getSS();
    SelIndex = (SegSs & ~0x7)/sizeof(LDT_ENTRY);

    Limit = (ULONG) (Ldt[SelIndex].HighWord.Bits.LimitHi << 16) |
                     Ldt[SelIndex].LimitLow;

    //
    // Make it paged aligned if not 4G size stack.
    //
    if (Ldt[SelIndex].HighWord.Bits.Granularity) {
        Limit = (Limit << 12) | 0xfff;
    }
    if (Limit != 0xffffffff) Limit++;


    if (Ldt[SelIndex].HighWord.Bits.Default_Big) {
        VdmSp = getESP();
    } else {
        VdmSp = getSP();
    }

    if (CurrentAppFlags) {
        StackOffset = StackUnits*sizeof(DWORD);
    } else {
        StackOffset = StackUnits*sizeof(WORD);
    }

    NewSP = VdmSp - StackOffset;
    bExpandDown = (BOOL) (Ldt[SelIndex].HighWord.Bits.Type & 4);
    if ((StackOffset > VdmSp) ||
        (!bExpandDown && (VdmSp > Limit)) ||
        (bExpandDown && (NewSP < Limit))) {
        // failed limit check
        ASSERT(0);
        rc = FALSE;
    }

    *pNewSP = NewSP;
    VdmStackPointer = VdmMapFlat(SegSs, VdmSp, VDM_PM);
    *pVdmStackPointer = VdmStackPointer;
    return rc;

}


VOID
EmulateV86Int(
    UCHAR InterruptNumber
    )
/*++

Routine Description:

    This routine is responsible for simulating a real mode interrupt. It
    uses the real mode IVT at 0:0.

Arguments:

    IntNumber - interrupt vector number
    Eflags - client flags to save on the stack


--*/

{
    DECLARE_LocalVdmContext;
    PVDM_INTERRUPTHANDLER Handlers = DpmiInterruptHandlers;
    PUCHAR VdmStackPointer;
    PWORD16 pIVT;
    USHORT VdmSP;
    USHORT NewCS;
    USHORT NewIP;
    ULONG Eflags = getEFLAGS();

    VdmStackPointer = VdmMapFlat(getSS(), 0, VDM_V86);
    VdmSP = getSP() - 2;
    *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) Eflags;
    VdmSP -= 2;
    *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getCS();
    VdmSP -= 2;
    *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getIP();
    setSP(VdmSP);

    //
    // See if this interrupt is hooked in protect mode, and if we should
    // reflect there instead.
    //
    if (Handlers[InterruptNumber].Flags & VDM_INT_HOOKED) {
        NewCS = (USHORT) (DosxRMReflector >> 16);
        NewIP = (USHORT) DosxRMReflector;
        //
        // now encode the interrupt number into CS
        //
        NewCS -= (USHORT) InterruptNumber;
        NewIP += (USHORT) (InterruptNumber*16);
    } else {
        PWORD16 pIvtEntry = (PWORD16) (IntelBase + InterruptNumber*4);

        NewIP = *pIvtEntry++;
        NewCS = *pIvtEntry;
    }

    setIP(NewIP);
    setCS(NewCS);
    //
    // Turn off flags like the hardware would
    //
    setEFLAGS(Eflags & ~(EFLAGS_TF_MASK | EFLAGS_IF_MASK));
}


VOID
SimulateFarCall(
    USHORT Seg,
    ULONG Offset
    )
{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    USHORT VdmSP;

    if (getMODE() == VDM_V86) {

        VdmStackPointer = VdmMapFlat(getSS(), 0, VDM_V86);
        VdmSP = getSP() - 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getCS();
        VdmSP -= 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getIP();
        setSP(VdmSP);
        setCS(Seg);
        setIP((USHORT)Offset);

    } else {
        DbgBreakPoint();

    }

}

VOID
SimulateCallWithIretFrame(
    USHORT Seg,
    ULONG Offset
    )
{
    DECLARE_LocalVdmContext;
    PUCHAR VdmStackPointer;
    USHORT VdmSP;

    if (getMODE() == VDM_V86) {

        VdmStackPointer = VdmMapFlat(getSS(), 0, VDM_V86);
        VdmSP = getSP() - 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getEFLAGS();
        VdmSP -= 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getCS();
        VdmSP -= 2;
        *(PWORD16)(VdmStackPointer+VdmSP) = (WORD) getIP();
        setSP(VdmSP);
        setCS(Seg);
        setIP((USHORT)Offset);

    } else {
        DbgBreakPoint();

    }

}

VOID
SimulateIret(
    IRET_BEHAVIOR fdsp
    )
/*++

Routine Description:

    This routine simulates an IRET. The passed parameter specifies
    how the flags are to be treated. In many situations, we pass the
    value of the flags along, thus throwing away the flags on the stack.

    In the case of PASS_FLAGS, we:
     - clear all but the interrupt and trace flags in the caller's
       original flags
     - combine in the flags returned by the interrupt service routine.
       This will cause us to return to the original routine with
       interrupts on if they were on when the interrupt occured, or
       if the ISR returned with them on.


Arguments:

    fdsp - takes the value RESTORE_FLAGS, PASS_FLAGS or PASS_CARRY_FLAG

        PASS_CARRY_FLAG_16 is a special value to indicate that this
        iret will always be on a 16-bit iret frame.


--*/
{
    DECLARE_LocalVdmContext;
    USHORT SegSs;
    ULONG VdmSp;
    ULONG VdmStackPointer;
    USHORT Flags;

    SegSs = getSS();

    if (getMODE() == VDM_V86) {
        VdmSp = getSP() + 6;
        VdmStackPointer = (ULONG) VdmMapFlat(SegSs, VdmSp, VDM_V86);

        setCS(*(PWORD16)(VdmStackPointer - 4));
        setIP(*(PWORD16)(VdmStackPointer - 6));
        Flags = *(PWORD16)(VdmStackPointer - 2);

    } else {
        if (Frame32 && (fdsp!=PASS_CARRY_FLAG_16)) {
            if (SEGMENT_IS_BIG(SegSs)) {
                VdmSp = getESP();
            } else {
                VdmSp = getSP();
            }
            VdmSp += 12;
            VdmStackPointer = (ULONG) VdmMapFlat(SegSs, VdmSp, VDM_PM);

            setCS(*(PWORD16)(VdmStackPointer - 8));
            setEIP(*(PDWORD16)(VdmStackPointer - 12));
            Flags = *(PWORD16)(VdmStackPointer - 4);

        } else {

            VdmSp = getSP() + 6;
            VdmStackPointer = (ULONG) VdmMapFlat(SegSs, VdmSp, VDM_PM);

            setCS(*(PWORD16)(VdmStackPointer - 4));
            setIP(*(PWORD16)(VdmStackPointer - 6));
            Flags = *(PWORD16)(VdmStackPointer - 2);

        }
    }

    switch(fdsp) {

    case RESTORE_FLAGS:
        break;

    case PASS_FLAGS:
        Flags = (Flags & 0x300) | getSTATUS();
        break;

    case PASS_CARRY_FLAG:
    case PASS_CARRY_FLAG_16:
        Flags = (Flags & ~1) | (getSTATUS() & 1);
        break;
    }

    setSTATUS(Flags);
    setESP(VdmSp);
}

#if 0   // Disable the code for now

USHORT
AllocatePMStack(
    USHORT MemSize
    )
/*++

Routine Description:

    This routine allocates PM stack.

Arguments:

    MemSize - Must be less than 64k

Return Value:

    if successful, selector of the PM stack
    otherwise 0

--*/
{
    PMEM_DPMI pMem;

    pMem = DpmiAllocateXmem(MemSize);

    if (pMem) {

        pMem->SelCount = 1;
        pMem->Sel = ALLOCATE_SELECTORS(1);

        if (!pMem->Sel) {
            pMem->SelCount = 0;
            DpmiFreeXmem(pMem);
            pMem = NULL;
        } else {

            SetDescriptorArray(pMem->Sel, (ULONG)pMem->Address, MemSize);

        }
    }
    if (pMem) {
        return pMem->Sel;
    } else {
        return (USHORT)0;
    }
}

VOID
FreePMStack(
    USHORT Sel
    )
/*++

Routine Description:

    This routine releases PM stack

Arguments:

    Sel - Selector of the PM stack to be freed.

Return Value:

    None.

--*/
{
    PMEM_DPMI pMem;

    if (pMem = DpmiFindXmem(Sel)) {

        while(pMem->SelCount--) {
            FreeSelector(Sel);
            Sel+=8;
        }

        DpmiFreeXmem(pMem);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\xlathlp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    xlathlp.h

Abstract:

    This module contains helper macros for the api translation

Author:

    Dave Hastings (daveh) 24-Nov-1992

Revision History:

--*/

#define DPMI_EXEC_INT(x)    SWITCH_TO_DOSX_RMSTACK();       \
                            DpmiPushRmInt(x);               \
                            host_simulate();                \
                            SWITCH_FROM_DOSX_RMSTACK();

//
// VOID
// DPMI_FLAT_TO_SEGMENTED(
//     PUCHAR buffer,
//     PUSHORT seg,
//     PUSHORT off
// )

#define DPMI_FLAT_TO_SEGMENTED(buffer, seg, off) {  \
    *seg = (USHORT)(((ULONG)buffer-IntelBase) >> 4);            \
    *off = (USHORT)(((ULONG)buffer-IntelBase) & 0xf);           \
}


#define SELECTOR_TO_INTEL_LINEAR_ADDRESS(sel) \
    (FlatAddress[(sel & ~7) / sizeof(LDT_ENTRY)] - IntelBase)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\daytona\precomp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <dpmi.h>
#include <vint.h>
#include <mvdm.h>
#include "..\dpmi32.h"
#include <dbgsvc.h>
#include <nt_vdd.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\fe\precomp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the private include file for the 32 bit dpmi and protected mode
    support

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <dpmi.h>
#include <vint.h>
#include <mvdm.h>
#include "..\dpmi32.h"
#include <dbgsvc.h>
#include <nt_vdd.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\xmem.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    xmem.c

Abstract:

    This module contains routines for allocating and freeing "extended" memory.
    The memory is allocated directly from NT.

Author:

    Dave Hastings (daveh) 12-Dec-1992

Notes:

    Moved from dpmi32\i386

Revision History:

    09-Feb-1994 (daveh)
        Modified to be the common front end for the memory allocation.  Calls
        processor specific code to do actual allocation

--*/
#include "precomp.h"
#pragma hdrstop
#include "softpc.h"
#include <malloc.h>

MEM_DPMI XmemHead = { NULL, 0, &XmemHead, &XmemHead, 0};

PMEM_DPMI
DpmiAllocateXmem(
    ULONG BlockSize
    )
/*++

Routine Description:

    This routine allocates a block of "extended" memory from NT.  The
    blocks allocated this way will be 64K aligned (for now).  The address
    of the block is returned to the segmented app in bx:cx

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG BlockAddress;
    NTSTATUS Status;
    PMEM_DPMI XmemBlock;

    //
    // Get a block of memory from NT (any base address)
    //
    BlockAddress = 0;
    Status = DpmiAllocateVirtualMemory(
        (PVOID)&BlockAddress,
        &BlockSize
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        OutputDebugString("DPMI: DpmiAllocateXmem failed to get memory block\n");
#endif
        return NULL;
    }
    XmemBlock = malloc(sizeof(MEM_DPMI));
    if (!XmemBlock) {
        DpmiFreeVirtualMemory(
            (PVOID)&BlockAddress,
            &BlockSize
            );
        return NULL;
    }
    XmemBlock->Address = (PVOID)BlockAddress;
    XmemBlock->Length = BlockSize;
    XmemBlock->Owner = CurrentPSPSelector;
    XmemBlock->Sel = 0;
    XmemBlock->SelCount = 0;
    INSERT_BLOCK(XmemBlock, XmemHead);

    return XmemBlock;

}

BOOL
DpmiFreeXmem(
    PMEM_DPMI XmemBlock
    )
/*++

Routine Description:

    This routine frees a block of "extended" memory from NT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PVOID BlockAddress;
    ULONG BlockSize;


    BlockAddress = XmemBlock->Address;
    BlockSize = XmemBlock->Length;

    Status = DpmiFreeVirtualMemory(
        &BlockAddress,
        &BlockSize
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        OutputDebugString("DPMI: DpmiFreeXmem failed to free block\n");
#endif
        return FALSE;
    }

    DELETE_BLOCK(XmemBlock);

    free(XmemBlock);
    return TRUE;
}

BOOL
DpmiIsXmemHandle(
    PMEM_DPMI XmemBlock
    )
/*++

Routine Description:

    This routine verifies that the given handle is a valid xmem handle.

Arguments:

    Handle to be verified.

Return Value:

    TRUE if handle is valid, FALSE otherwise.

--*/
{
    PMEM_DPMI p1;

    p1 = XmemHead.Next;

    while(p1 != &XmemHead) {
        if (p1 == XmemBlock) {
            return TRUE;
        }
        p1 = p1->Next;
    }
    return FALSE;
}

PMEM_DPMI
DpmiFindXmem(
    USHORT Sel
    )
/*++

Routine Description:

    This routine finds a block of "extended" memory based on its Selector
    field.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PMEM_DPMI p1;

    p1 = XmemHead.Next;

    while(p1 != &XmemHead) {
        if (p1->Sel == Sel) {
            return p1;
        }
        p1 = p1->Next;
    }
    return NULL;
}

BOOL
DpmiReallocateXmem(
    PMEM_DPMI OldBlock,
    ULONG NewSize
    )
/*++

Routine Description:

    This routine resizes a block of "extended memory".  If the change in size
    is less than 4K, no change is made.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG BlockAddress;
    NTSTATUS Status;


    BlockAddress = 0;
    Status = DpmiReallocateVirtualMemory(
        OldBlock->Address,
        OldBlock->Length,
        (PVOID)&BlockAddress,
        &NewSize
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        OutputDebugString("DPMI: DpmiAllocateXmem failed to get memory block\n");
#endif
        return FALSE;
    }

    OldBlock->Address = (PVOID)BlockAddress;
    OldBlock->Length = NewSize;

    return TRUE;
}

VOID
DpmiFreeAppXmem(
    VOID
    )
/*++

Routine Description:

    This routine frees Xmem allocated for the application

Arguments:

    Client DX = client PSP selector

Return Value:

    TRUE  if everything goes fine.
    FALSE if unable to release the memory
--*/
{
    PMEM_DPMI p1, p2;
    NTSTATUS Status;
    PVOID BlockAddress;
    ULONG BlockSize;

    p1 = XmemHead.Next;

    while(p1 != &XmemHead) {
        if (p1->Owner == CurrentPSPSelector) {
            BlockAddress = p1->Address;
            BlockSize = p1->Length;

            Status = DpmiFreeVirtualMemory(
                &BlockAddress,
                &BlockSize
                );

            if (!NT_SUCCESS(Status)) {
#if DBG
                OutputDebugString("DPMI: DpmiFreeXmem failed to free block\n");
#endif
                return;
            }
            p2 = p1->Next;
            DELETE_BLOCK(p1);
            free(p1);
            p1 = p2;
            continue;
        }
        p1 = p1->Next;
    }
    return;
}

VOID
DpmiFreeAllXmem(
    VOID
    )
/*++

Routine Description:

    This function frees all allocated xmem.

Arguments:

    none

Return Value:

    None.

--*/
{
    PMEM_DPMI p1, p2;
    NTSTATUS Status;
    PVOID BlockAddress;
    ULONG BlockSize;

    p1 = XmemHead.Next;
    while(p1 != &XmemHead) {
        BlockAddress = p1->Address;
        BlockSize = p1->Length;

        Status = DpmiFreeVirtualMemory(
            &BlockAddress,
            &BlockSize
            );

        if (!NT_SUCCESS(Status)) {
#if DBG
            OutputDebugString("DPMI: DpmiFreeXmem failed to free block\n");
#endif
            return;
        }
        p2 = p1->Next;
        DELETE_BLOCK(p1);
        free(p1);
        p1 = p2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\i386\dpmi386.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dpmi386.c

Abstract:

    This file contains support for 386/486 only dpmi bops

Author:

    Dave Hastings (daveh) 27-Jun-1991

Revision History:

    Matt Felton (mattfe) Dec 6 1992 removed unwanted verification
    Dave Hastings (daveh) 24-Nov-1992  Moved to mvdm\dpmi32
    Matt Felton (mattfe) 8 Feb 1992 optimize getvdmpointer for regular protect mode path.

--*/

#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include <memory.h>
#include <malloc.h>
#include <nt_vdd.h>


BOOL
DpmiSetX86Descriptor(
    USHORT  SelStart,
    USHORT  SelCount
    )
/*++

Routine Description:

    This function puts descriptors into the real LDT. It uses the client's
    LDT as a source for the descriptor data.

Arguments:

    SelStart - The first selector in the block of selectors to set
    SelCount - The number of selectors to set

Return Value:

    This function returns TRUE if successful, FALSE otherwise

--*/

{
    LDT_ENTRY UNALIGNED *Descriptors = &Ldt[SelStart>>3];
    PPROCESS_LDT_INFORMATION LdtInformation = NULL;
    NTSTATUS Status;
    ULONG ulLdtEntrySize;
    ULONG Selector0,Selector1;

    ulLdtEntrySize =  SelCount * sizeof(LDT_ENTRY);

    //
    // If there are only 2 descriptors, set them the fast way
    //
    Selector0 = (ULONG)SelStart;
    if ((SelCount <= 2) && (Selector0 != 0)) {
        VDMSET_LDT_ENTRIES_DATA ServiceData;

        if (SelCount == 2) {
            Selector1 = SelStart + sizeof(LDT_ENTRY);
        } else {
            Selector1 = 0;
        }
        ServiceData.Selector0 = Selector0;
        ServiceData.Entry0Low = *((PULONG)(&Descriptors[0]));
        ServiceData.Entry0Hi  = *((PULONG)(&Descriptors[0]) + 1);
        ServiceData.Selector1 = Selector1;
        ServiceData.Entry1Low = *((PULONG)(&Descriptors[1]));
        ServiceData.Entry1Hi  = *((PULONG)(&Descriptors[1]) + 1);
        Status = NtVdmControl(VdmSetLdtEntries, &ServiceData);
        if (NT_SUCCESS(Status)) {
          return TRUE;
        }
        return FALSE;
    }

    LdtInformation = malloc(sizeof(PROCESS_LDT_INFORMATION) + ulLdtEntrySize);

    if (!LdtInformation ) {
      return FALSE;
    } else {
        VDMSET_PROCESS_LDT_INFO_DATA ServiceData;

        LdtInformation->Start = SelStart;
        LdtInformation->Length = ulLdtEntrySize;
        CopyMemory(
            &(LdtInformation->LdtEntries),
            Descriptors,
            ulLdtEntrySize
            );

        ServiceData.LdtInformation = LdtInformation;
        ServiceData.LdtInformationLength =  sizeof(PROCESS_LDT_INFORMATION) + ulLdtEntrySize;
        Status = NtVdmControl(VdmSetProcessLdtInfo, &ServiceData);

        if (!NT_SUCCESS(Status)) {
            VDprint(
                VDP_LEVEL_ERROR,
                ("DPMI: Failed to set selectors %lx\n", Status)
                );
            free(LdtInformation);
            return FALSE;
        }

        free(LdtInformation);

        return TRUE;
    }

}


UCHAR *
Sim32pGetVDMPointer(
    ULONG Address,
    UCHAR ProtectedMode
    )
/*++

Routine Description:

    This routine converts a 16/16 address to a linear address.

    WARNIGN NOTE - This routine has been optimized so protect mode LDT lookup
    falls stright through.   This routine is call ALL the time by WOW, if you
    need to modify it please re optimize the path - mattfe feb 8 92

Arguments:

    Address -- specifies the address in seg:offset format
    Size -- specifies the size of the region to be accessed.
    ProtectedMode -- true if the address is a protected mode address

Return Value:

    The pointer.

--*/

{
    ULONG Selector;
    PUCHAR ReturnPointer;

    if (ProtectedMode) {
        Selector = (Address & 0xFFFF0000) >> 16;
        if (Selector != 40) {
            Selector &= ~7;
            ReturnPointer = (PUCHAR)FlatAddress[Selector >> 3];
            ReturnPointer += (Address & 0xFFFF);
            return ReturnPointer;
    // Selector 40
        } else {
            ReturnPointer = (PUCHAR)0x400 + (Address & 0xFFFF);
        }
    // Real Mode
    } else {
        ReturnPointer = (PUCHAR)(((Address & 0xFFFF0000) >> 12) + (Address & 0xFFFF));
    }
    return ReturnPointer;
}


PUCHAR
ExpSim32GetVDMPointer(
    ULONG Address,
    ULONG Size,
    UCHAR ProtectedMode
    )
/*++
    See Sim32pGetVDMPointer, above

    This call must be maintaned as is because it is exported for VDD's
    in product 1.0.

--*/

{
    return Sim32pGetVDMPointer(Address,(UCHAR)ProtectedMode);
}


PVOID
VdmMapFlat(
    WORD selector,
    ULONG offset,
    VDM_MODE mode
    )
/*++

Routine Description:

    This routine converts a 16/16 address to a linear address.

    WARNIGN NOTE - This routine has been optimized so protect mode LDT lookup
    falls stright through.   This routine is call ALL the time by WOW, if you
    need to modify it please re optimize the path - mattfe feb 8 92

Arguments:

    Address -- specifies the address in seg:offset format
    Size -- specifies the size of the region to be accessed.
    ProtectedMode -- true if the address is a protected mode address

Return Value:

    The pointer.

--*/

{
    PUCHAR ReturnPointer;

    if (mode == VDM_PM) {
        if (selector != 40) {
            selector &= ~7;
            ReturnPointer = (PUCHAR)FlatAddress[selector >> 3] + offset;
            return ReturnPointer;
    // Selector 40
        } else {
            ReturnPointer = (PUCHAR)0x400 + (offset & 0xFFFF);
        }
    // Real Mode
    } else {
        ReturnPointer = (PUCHAR)((((ULONG)selector) << 4) + (offset & 0xFFFF));
    }
    return ReturnPointer;
}


BOOL
DpmiSetDebugRegisters(
    PULONG RegisterPointer
    )
/*++

Routine Description:

    This routine is called by dpmi when an app has issued DPMI debug commands.
    The six doubleword pointed to by the input parameter are the desired values
    for the real x86 hardware debug registers. This routine lets
    ThreadSetDebugContext() do all the work.

Arguments:

    None

Return Value:

    None.

--*/
{
    BOOL bReturn = TRUE;

    if (!ThreadSetDebugContext(RegisterPointer))
        {
        ULONG ClearDebugRegisters[6] = {0, 0, 0, 0, 0, 0};

        //
        // an error occurred. Reset everything to zero
        //

        ThreadSetDebugContext (&ClearDebugRegisters[0]);
        bReturn = FALSE;
        }
    return bReturn;
}

BOOL
DpmiGetDebugRegisters(
    PULONG RegisterPointer
    )
/*++

Routine Description:

    This routine is called by DOSX when an app has issued DPMI debug commands.
    The six doubleword pointed to by the input parameter are the desired values
    for the real x86 hardware debug registers. This routine lets
    ThreadGetDebugContext() do all the work.

Arguments:

    None

Return Value:

    None.

--*/
{
    return (ThreadGetDebugContext(RegisterPointer));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\i386\dpmimem.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    name-of-module-filename

Abstract:

    This module contains the code for actually allocating memory for dpmi.
    It uses the same suballocation pool as the xms code

Author:

    Dave Hastings (daveh) creation-date 09-Feb-1994

Notes:

    These functions claim to return NTSTATUS.  This is for commonality on
    x86 where we actually have an NTSTATUS to return.  For this file, we
    simply logically invert the bool and return that.  Callers of these
    functions promise not to attach significance to the return values other
    than STATUS_SUCCESS.

Revision History:


--*/
#include "precomp.h"
#pragma hdrstop
#include <softpc.h>
#include <suballoc.h>
#include <xmsexp.h>

PVOID                    gpLastAlloc           = NULL;
BOOL                     gbUseIncrementalAlloc = FALSE;
SYSTEM_BASIC_INFORMATION gSystemBasicInfo;

#define ALIGN_ALLOCATION_GRANULARITY(p) \
    (((p) + gSystemBasicInfo.AllocationGranularity - 1) & ~(gSystemBasicInfo.AllocationGranularity - 1))

VOID
DpmiSetIncrementalAlloc(
    BOOL bUseIncrementalAlloc
    )
{
    NTSTATUS Status;

    gbUseIncrementalAlloc = FALSE;
    gpLastAlloc = NULL;

    // if worse comes to worse -- and we can't query system info,
    // we use conventional allocation strategy

    if (bUseIncrementalAlloc) {
        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          &gSystemBasicInfo,
                                          sizeof(gSystemBasicInfo),
                                          NULL);
        if (NT_SUCCESS(Status)) {
            gbUseIncrementalAlloc = TRUE;
        }
    }

}

PVOID
DpmiFindNextAddress(
    ULONG ulSize
)
{
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T ReturnLength;
    PVOID pMem = gpLastAlloc;
    ULONG ulSizeCheck;

    //
    // adjust size for granularity alignment
    //
    ulSizeCheck = ALIGN_ALLOCATION_GRANULARITY(ulSize);

    do {
        //
        // adjust the address to align on granularity
        //
        pMem = (PVOID)ALIGN_ALLOCATION_GRANULARITY((ULONG_PTR)pMem);


        Status = NtQueryVirtualMemory(NtCurrentProcess(),
                                      pMem,
                                      MemoryBasicInformation,
                                      &mbi,
                                      sizeof(mbi),
                                      &ReturnLength);
        if (!NT_SUCCESS(Status)) {

            return(NULL);
        }

        //
        // after the query -- step forward
        //

        if ((MEM_FREE & mbi.State) && (ulSizeCheck <= mbi.RegionSize)) {

            // try to reserve it then

            Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                             &pMem,
                                             0,
                                             &ulSize,
                                             MEM_RESERVE,
                                             PAGE_READWRITE);
            if (!NT_SUCCESS(Status)) {
                //
                // we can't reserve the memory - get out, use "normal" allocation

                break;
            }

            return(pMem);
        }

        pMem = (PVOID)((ULONG_PTR)mbi.BaseAddress + mbi.RegionSize);

    } while ((ULONG_PTR)pMem < (ULONG_PTR)gSystemBasicInfo.MaximumUserModeAddress);

    return(NULL);
}






NTSTATUS
DpmiAllocateVirtualMemory(
    PVOID *Address,
    PULONG Size
    )
/*++

Routine Description:

    This routine allocates a chunk of extended memory for dpmi.

Arguments:

    Address -- Supplies a pointer to the Address.  This is filled in
        if the allocation is successfull
    Size -- Supplies the size to allocate

Return Value:

    STATUS_SUCCESS if successfull.

--*/
{
    PVOID pMem = NULL;
    NTSTATUS Status;

    if (NULL != gpLastAlloc && gbUseIncrementalAlloc) {

        // try to find a piece of memory that is beyond this gpLastAlloc

        pMem = DpmiFindNextAddress(*Size);

    }

AllocRetry:

    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &pMem,
                                     0,
                                     Size,
                                     MEM_COMMIT,
                                     PAGE_READWRITE);
    if (NT_SUCCESS(Status)) {

        if (gbUseIncrementalAlloc) {
            gpLastAlloc = (PVOID)((ULONG_PTR)pMem + *Size);
        }

        *Address    = pMem;

        return(Status);
    }

    if (pMem != NULL) {

        pMem = NULL;
        goto AllocRetry;
    }


    return(Status);
}

NTSTATUS
DpmiFreeVirtualMemory(
    PVOID *Address,
    PULONG Size
    )
/*++

Routine Description:

    This function frees memory for dpmi.  It is returned to the suballocation
    pool.

Arguments:

    Address -- Supplies the address of the block to free
    Size -- Supplies the size of the block to free

Return Value:

    STATUS_SUCCESS if successful
--*/
{
    return NtFreeVirtualMemory(
        NtCurrentProcess(),
        Address,
        Size,
        MEM_RELEASE
        );

}

VOID
DpmiCopyMemory(
    ULONG NewAddress,
    ULONG OldAddress,
    ULONG Size
    )

/*++

Routine Description:

    This function copies a block of memory from one location to another. It
    assumes that the old block of memory is about to be freed. As it copies,
    it discards the contents of the pages of the original block to reduce
    paging.

Arguments:

    OldAddress -- Supplies the original address for the block
    Size       -- Supplies the size in bytes to be copied
    NewAddress -- Supplies the pointer to the place to return the new address

Return Value:
    none

--*/
{
    ULONG tmpsize;

#define SEGMENT_SIZE 0x4000

    // first page align the copy
    if (OldAddress & (SEGMENT_SIZE-1)) {
        tmpsize = SEGMENT_SIZE - (OldAddress & (SEGMENT_SIZE-1));
        if (tmpsize > Size) {
            tmpsize = Size;
        }

        CopyMemory((PVOID)NewAddress, (PVOID)OldAddress, tmpsize);

        NewAddress += tmpsize;
        OldAddress += tmpsize;
        Size -= tmpsize;
    }

    while(Size >= SEGMENT_SIZE) {
        CopyMemory((PVOID)NewAddress, (PVOID)OldAddress, SEGMENT_SIZE);

        VirtualAlloc((PVOID)OldAddress, SEGMENT_SIZE, MEM_RESERVE, PAGE_READWRITE);

        NewAddress += SEGMENT_SIZE;
        OldAddress += SEGMENT_SIZE;
        Size -= SEGMENT_SIZE;
    }

    if (Size) {
        CopyMemory((PVOID)NewAddress, (PVOID)OldAddress, Size);
    }
}



NTSTATUS
DpmiReallocateVirtualMemory(
    PVOID OldAddress,
    ULONG OldSize,
    PVOID *NewAddress,
    PULONG NewSize
    )
/*++

Routine Description:

    This function reallocates a block of memory for DPMI.

Arguments:

    OldAddress -- Supplies the original address for the block
    OldSize -- Supplies the original size for the address
    NewAddress -- Supplies the pointer to the place to return the new
        address
    NewSize -- Supplies the new size

Return Value:

    STATUS_SUCCESS if successfull
--*/
{
    ULONG SizeChange;
    ULONG BlockAddress;
    ULONG NewPages, OldPages;
    NTSTATUS Status;

    #define FOUR_K (1024 * 4)

    NewPages = (*NewSize + FOUR_K - 1) / FOUR_K;
    OldPages = (OldSize + FOUR_K - 1) / FOUR_K;

    if ((NewPages == OldPages) || (NewPages < OldPages)) {
        *NewAddress = OldAddress;
        return STATUS_SUCCESS;
    }

    BlockAddress = 0;
    Status = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        (PVOID)&BlockAddress,
        0L,
        NewSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        OutputDebugString("DPMI: DpmiAllocateXmem failed to get memory block\n");
#endif
        return Status;
    }

    *NewAddress = (PVOID) BlockAddress;
    //
    // Copy data to new block (choose smaller of the two sizes)
    //
    if (*NewSize > OldSize) {
        SizeChange = OldSize;
    } else {
        SizeChange = *NewSize;
    }

    DpmiCopyMemory((ULONG)BlockAddress, (ULONG)OldAddress, SizeChange);

    //
    // Free up the old block
    //
    BlockAddress = (ULONG) OldAddress;
    SizeChange = OldSize;
    NtFreeVirtualMemory(
        NtCurrentProcess(),
        (PVOID)&(OldAddress),
        &SizeChange,
        MEM_RELEASE
        );

    return Status;
}

VOID
DpmiGetMemoryInfo(
    VOID
    )
/*++

Routine Description:

    This routine returns information about memory to the dos extender

Arguments:

    None

Return Value:

    None.

--*/
{
    DECLARE_LocalVdmContext;
    MEMORYSTATUS MemStatus;
    PDPMIMEMINFO MemInfo;
    DWORD dwLargestFree;

    //
    // Get a pointer to the return structure
    //
    MemInfo = (PDPMIMEMINFO)Sim32GetVDMPointer(
        ((ULONG)getES()) << 16,
        1,
        TRUE
        );

    (CHAR *)MemInfo += (*GetDIRegister)();

    //
    // Initialize the structure
    //
    RtlFillMemory(MemInfo, sizeof(DPMIMEMINFO), 0xFF);

    //
    // Get the information on memory
    //
    MemStatus.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus(&MemStatus);

    //
    // Return the information
    //

    //
    // Calculate the largest free block. This information is not returned
    // by NT, so we take a percentage based on the allowable commit charge for
    // the process. This is really what dwAvailPageFile is. But we limit
    // that value to a maximum of 15meg, since some apps (e.g. pdox45.dos)
    // can't handle more.
    //

    // Filled in MaxUnlocked,MaxLocked,UnlockedPages fields in this structute.
    // Director 4.0 get completlely confused if these fields are -1.
    // MaxUnlocked is correct based on LargestFree. The other two are fake
    // and match values on a real WFW machine. I have no way of making them
    // any better than this at this point. Who cares it makes director happy.
    //
    // sudeepb 01-Mar-1995.

    dwLargestFree = (((MemStatus.dwAvailPageFile*4)/5)/4096)*4096;

    MemInfo->LargestFree = (dwLargestFree < 15*ONE_MB) ?
                                         dwLargestFree : 15*ONE_MB;

    MemInfo->MaxUnlocked = MemInfo->LargestFree/4096;
    MemInfo->MaxLocked = 0xb61;
    MemInfo->AddressSpaceSize = MemStatus.dwTotalVirtual / 4096;
    MemInfo->UnlockedPages = 0xb68;
    MemInfo->FreePages = MemStatus.dwAvailPhys / 4096;
    MemInfo->PhysicalPages = MemStatus.dwTotalPhys / 4096;
    MemInfo->FreeAddressSpace = MemStatus.dwAvailVirtual / 4096;
    MemInfo->PageFileSize = MemStatus.dwTotalPageFile / 4096;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\vxd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vxd.c

Abstract:

    This module contains misc dpmi functions for risc.

Revision History:

    Neil Sandlin (neilsa) Nov. 1, 95 - split off from "misc" source

--*/

#include "precomp.h"
#pragma hdrstop
#include "softpc.h"

#define W386_VCD_ID 0xe

VOID
GetVxDApiHandler(
    USHORT VxdId
    )
{
    DECLARE_LocalVdmContext;

    if (VxdId == W386_VCD_ID) {

        setES(HIWORD(DosxVcdPmSvcCall));
        setDI(LOWORD(DosxVcdPmSvcCall));

    } else {

        setES(0);
        setDI(0);

    }

}


LONG
    VcdPmGetPortArray(
        VOID
    )
/*++

Routine Description:

    Use the registry enteries in HKEY_LOCAL_MACHINE\\HARDWARE\\DEVICEMAP\\SERIALCOMM
    to simulate the Virtual Comm Device API: VCD_PM_Get_Port_Array. See VCD.ASM
    in the Win 3.1 DDK.


Arguments:

    None

Return Value:

    Port Array in LOWORD. Bit array of valid ports:

    Bit Set   -> Port valid
    Bit clear -> Port invalid

    Bit 0 -> COM1, Bit 1 -> COM2, Bit 2 -> COM3...

--*/
{
    HKEY        hSerialCommKey;
    DWORD       dwPortArray;
    DWORD       dwPortNum;
    DWORD       cbPortName;
    DWORD       cbPortValue;
    CHAR        szPortName[64];
    CHAR        szPortValue[64];
    LONG        iPort;
    LONG        iStatus;

    dwPortArray = 0;
    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      "HARDWARE\\DEVICEMAP\\SERIALCOMM",
                      0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                      &hSerialCommKey) == ERROR_SUCCESS){

        cbPortName  = sizeof(szPortName);
        cbPortValue = sizeof(szPortValue);
        for (iPort = 0;
             (iStatus = RegEnumValue(hSerialCommKey,
                                     iPort, szPortName, &cbPortName,
                                     NULL, NULL, szPortValue,
                                     &cbPortValue)) != ERROR_NO_MORE_ITEMS;
             iPort++)
        {
            if ((iStatus == ERROR_SUCCESS) && (cbPortValue > 3)) {

                if (NT_SUCCESS(RtlCharToInteger(szPortValue+3,10,&dwPortNum))) {
                    dwPortArray |= (1 << (dwPortNum - 1));
                }

            }
            cbPortName  = sizeof(szPortName);
            cbPortValue = sizeof(szPortValue);
        }
    // WOW only supports 9 ports. See WU32OPENCOM in WUCOMM.C.
    dwPortArray &= 0x1FF;
    RegCloseKey(hSerialCommKey);
    }
    return(dwPortArray);
}

// The following values taken from Win 3.1 DDK VCD.ASM:

#define VCD_PM_Get_Version          0
#define VCD_PM_Get_Port_Array       1
#define VCD_PM_Get_Port_Behavior    2
#define VCD_PM_Set_Port_Behavior    3
#define VCD_PM_Acquire_Port         4
#define VCD_PM_Free_Port            5
#define VCD_PM_Steal_Port           6

VOID
    DpmiVcdPmSvcCall32(
        VOID
    )
/*++

Routine Description:

    Dispatch VCD API requests to the correct API.

Arguments:

    Client DX contains API function id.

Return Value:

    Depends on API.
--*/
{
    DECLARE_LocalVdmContext;

    switch (getDX()) {
        case VCD_PM_Get_Version:
            setAX(0x30A);
            break;

        case VCD_PM_Get_Port_Array:
            setAX((WORD)VcdPmGetPortArray());
            break;

        default :
            ASSERT(0);
            setCF(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\dpmi32\nec_98\precomp.h ===
#include    "..\FE\precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\faxcomm.h ===
//************************************************************************
// Common header file for generic Win 3.1 fax printer driver support.
//
// History:
//    02-jan-95   nandurir   created.
//    01-feb-95   reedb      Clean-up, support printer install and bug fixes.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//    16-aug-95   reedb      Move to kernel mode. Move many declarations and
//                              definitions to WOWFAXDD.H and WOWFAXUI.H.
//
//************************************************************************

#include "wowfax.h"

// The following structure ID appears as wfax when dumping byte (db) a FAXDEV:
#define FAXDEV_ID         ((DWORD)'xafw')     

//
// This structure is shared between wowfax and wowfaxui - this keeps
// the interface reliable, consistent and easy to maintain
//

typedef  struct _FAXDEV {
    ULONG    id;               // String to verify what we have
    struct _FAXDEV *lpNext;
    struct _FAXDEV *lpClient;  // Pointer to client side FAXDEV
    HDEV     hdev;             // Engine's handle to this structure

    DWORD    idMap;            // Unique ID
    DWORD    cbMapLow;         // Loword of size of mapped area
    HANDLE   hMap;             // Handle to mapped file
    TCHAR    szMap[16];        // Name of mapped file

    LPWOWFAXINFO lpMap;
    DWORD    offbits;

    HBITMAP  hbm;              // Handle to bitmap for drawing
    DWORD    cPixPerByte;
    DWORD    bmFormat;
    DWORD    bmWidthBytes;
    HSURF    hbmSurf;          // Associated surface

    HWND     hwnd;
    DWORD    tid;
    DWORD    lpinfo16;

    HANDLE   hDriver;          // For access to spooler data
    GDIINFO  gdiinfo;
    DEVINFO  devinfo;
    PDEVMODE pdevmode;
}  FAXDEV, *LPFAXDEV;

// Macro to dword align for RISC
//#define DRVFAX_DWORDALIGN(dw)   ((dw) += ((dw) % 4) ? (4 - ((dw) % 4)) : 0)
#define DRVFAX_DWORDALIGN(dw)   ((dw) = (((dw) + 3) & ~3))

// DrvEscape escape/action codes:

#define DRV_ESC_GET_FAXDEV_PTR  0x8000
#define DRV_ESC_GET_DEVMODE_PTR 0x8001
#define DRV_ESC_GET_BITMAP_BITS 0x8002
#define DRV_ESC_GET_SURF_INFO   0x8003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfaxui\sources.inc ===
!IF 0

Copyright (c) 1989 - 1991  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=wowfaxui
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\user32.lib      \
           $(SDK_LIB_PATH)\gdi32.lib       \
           $(SDK_LIB_PATH)\kernel32.lib    \
           $(SDK_LIB_PATH)\winspool.lib    \
           $(SDK_LIB_PATH)\advapi32.lib

C_DEFINES=-DUNICODE

DLLENTRY=DllInitProc

MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=\
    ..;\
    ..\..;\
    ..\..\wowfax;\
    ..\..\..\inc;\
    $(PRINTSCAN_INC_PATH);\
    $(WINDOWS_INC_PATH)

SOURCES=..\wfhelper.c  \
        ..\wfsheets.c  \
        ..\wfupgrad.c  \
        ..\wowfaxui.c  \
        ..\wowfaxui.rc

UMTYPE=windows

SOURCES_USED=..\sources.inc

CONDITIONAL_INCLUDES=subwtype.h

W32_SB=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfax\wowfaxdd.h ===
//****************************************************************************
// Generic Win 3.1 fax printer driver support
//
// History:
//    02-jan-95   nandurir   created.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//    16-aug-95   reedb      Move to kernel mode. Many declarations and
//                              definitions moved from FAXCOMM.H.
//
//****************************************************************************

#include "string.h"
#include "stddef.h"
#include "windows.h"
#include "winddi.h"
#include "faxcomm.h"

BOOL InitPDEV(
    LPFAXDEV lpCliFaxDev,           // Pointer to the client side FAXDEV
    LPFAXDEV lpSrvFaxDev,           // Pointer to the server side FAXDEV
    ULONG     cPatterns,            // Count of standard patterns
    HSURF    *phsurfPatterns,       // Buffer for standard patterns
    ULONG     cjGdiInfo,            // Size of buffer for GdiInfo
    ULONG    *pulGdiInfo,           // Buffer for GDIINFO
    ULONG     cjDevInfo,            // Number of bytes in devinfo
    DEVINFO  *pdevinfo              // Device info
);

#define COLOR_INDEX_BLACK    0x0
#define COLOR_INDEX_WHITE    0x1

// user server defn.

#define FW_16BIT             0x1  // look for 16bit windows only
LPVOID UserServerDllInitialization(LPVOID);
typedef HWND (*PFNFW)(LPTSTR, LPTSTR, UINT);
typedef LRESULT (*PFNSM)(HWND, UINT, WPARAM, LPARAM);
typedef LRESULT (*PFNSNM)(HWND, UINT, WPARAM, LPARAM);

#if  DBG
#define LOGDEBUG(args) {faxlogprintf args;}
#else
#define LOGDEBUG(args)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfaxui\wfsheets.h ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. User Interface functions
// which are called by WINSPOOL. Support for Two new entry points required
// by the Win 95 printer UI, DrvDocumentPropertySheets and
// DrvDevicePropertySheets
//
// History:
//    24-Apr-96   reedb   created.
//
//************************************************************************

#include "winddiui.h"

// Data structure maintained by the fax driver user interface
typedef struct {

    PVOID           startUiData;
    HANDLE          hPrinter;
    PDEVMODE        pdmIn;
    PDEVMODE        pdmOut;
    DWORD           fMode;
    LPTSTR          pDriverName;
    LPTSTR          pDeviceName;
    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    HANDLE          hFaxOptsPage;
    PVOID           endUiData;

} UIDATA, *PUIDATA;

#define ValidUiData(pUiData) \
        ((pUiData) && (pUiData) == (pUiData)->startUiData && (pUiData) == (pUiData)->endUiData)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfaxui\wfhelper.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. Helper functions which are
//      called in WOWFAXUI.C
//
// History:
//    14-mar-95   reedb      Created. Many of the functions were moved from
//                              FAXCOMM.C, since they're no longer called
//                              from WOWFAX.DLL.
//    16-aug-95   reedb      Move to kernel mode. Debug output and validate
//                              functions moved from FAXCOMM.C.
//
//************************************************************************

#include "wowfaxui.h"
#include "dde.h"

extern LPCRITICAL_SECTION lpCriticalSection;
extern HINSTANCE ghInst;
BOOL InSetupMode(void);

#if DBG

INT     iFaxLogLevel = 20;
INT     iReqFaxLogLevel = 0;

typedef PVOID HANDLE;


//************************************************************************
// faxlogprintf - Two different implementations. One for client side
//      debugging the other for server side.
//
//************************************************************************


// For Debug logging.
#define MAX_DISPLAY_LINE 256                // 128 characters.

TCHAR   szFaxLogFile[] = L"C:\\FAXLOG.LOG";
HANDLE  hfFaxLog = NULL;

// Defines for iFaxLogMode
#define NO_LOGGING     0
#define LOG_TO_FILE    1
#define OPEN_LOG_FILE  2
#define CLOSE_LOG_FILE 3

INT     iFaxLogMode  = NO_LOGGING;

VOID faxlogprintf(LPTSTR pszFmt, ...)
{
    DWORD   lpBytesWritten;
    int     len;
    TCHAR   szText[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    len = wvsprintf(szText, pszFmt, arglist);

    if (iFaxLogMode > LOG_TO_FILE) {
        if (iFaxLogMode == OPEN_LOG_FILE) {
            if((hfFaxLog = CreateFile(szFaxLogFile,
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL)) != INVALID_HANDLE_VALUE) {
                iFaxLogMode = LOG_TO_FILE;
            }
            else {
                hfFaxLog = NULL;
                iFaxLogMode  = NO_LOGGING;
                OutputDebugString(L"Couldn't open fax log file!\n");
            }
        }
        else {
            FlushFileBuffers(hfFaxLog);
            CloseHandle(hfFaxLog);
            hfFaxLog = NULL;
            iFaxLogMode  = NO_LOGGING;
        }
    }

    if (iFaxLogLevel >= iReqFaxLogLevel) {
        if (iFaxLogMode) {
            WriteFile(hfFaxLog, szText, len, &lpBytesWritten, NULL);
        }
        else {
            OutputDebugString(szText);
        }
    }
}


VOID LogWowFaxInfo(LPWOWFAXINFO lpWowFaxInfo)
{
    faxlogprintf(L"\tlpWowFaxInfo (lpMap): %X\n", lpWowFaxInfo);
    faxlogprintf(L"\t\thwnd: %X\n", lpWowFaxInfo->hwnd);
    faxlogprintf(L"\t\ttid: %X\n", lpWowFaxInfo->tid);
    faxlogprintf(L"\t\tproc16: %X\n", lpWowFaxInfo->proc16);
    faxlogprintf(L"\t\tlpinfo16: %X\n", lpWowFaxInfo->lpinfo16);
    faxlogprintf(L"\t\tmsg: %X\n", lpWowFaxInfo->msg);
    faxlogprintf(L"\t\thdc: %X\n", lpWowFaxInfo->hdc);
    faxlogprintf(L"\t\twCmd: %X\n", lpWowFaxInfo->wCmd);
    faxlogprintf(L"\t\tcData: %X\n", lpWowFaxInfo->cData);
    faxlogprintf(L"\t\thwndui: %X\n", lpWowFaxInfo->hwndui);
    faxlogprintf(L"\t\tretvalue: %X\n", lpWowFaxInfo->retvalue);
    faxlogprintf(L"\t\tstatus: %X\n", lpWowFaxInfo->status);
    if (lpWowFaxInfo->lpDevice) {
        faxlogprintf(L"\t\tlpDevice: %s\n", lpWowFaxInfo->lpDevice);
    }
    else {
        faxlogprintf(L"\t\tlpDevice: %X\n", lpWowFaxInfo->lpDevice);
    }
    if (lpWowFaxInfo->lpDriverName) {
        faxlogprintf(L"\t\tlpDriverName: %s\n", lpWowFaxInfo->lpDriverName);
    }
    else {
        faxlogprintf(L"\t\tlpDriverName: %X\n", lpWowFaxInfo->lpDriverName);
    }
    if (lpWowFaxInfo->lpPortName) {
        faxlogprintf(L"\t\tlpPortName: %s\n", lpWowFaxInfo->lpPortName);
    }
    else {
        faxlogprintf(L"\t\tlpPortName: %X\n", lpWowFaxInfo->lpPortName);
    }
    faxlogprintf(L"\t\tlpIn: %X\n", lpWowFaxInfo->lpIn);
    faxlogprintf(L"\t\tlpOut: %X\n", lpWowFaxInfo->lpOut);
    if (lpWowFaxInfo->szDeviceName) {
        faxlogprintf(L"\t\tszDeviceName: %s\n", lpWowFaxInfo->szDeviceName);
    }
    else {
        faxlogprintf(L"\t\tszDeviceName: %X\n", lpWowFaxInfo->szDeviceName);
    }
    faxlogprintf(L"\t\tbmPixPerByte: %X\n", lpWowFaxInfo->bmPixPerByte);
    faxlogprintf(L"\t\tbmWidthBytes: %X\n", lpWowFaxInfo->bmWidthBytes);
    faxlogprintf(L"\t\tbmHeight: %X\n", lpWowFaxInfo->bmHeight);
    faxlogprintf(L"\t\tlpbits: %X\n", lpWowFaxInfo->lpbits);
}

VOID LogFaxDev(LPTSTR pszTitle, LPFAXDEV lpFaxDev)
{
    DWORD dwTmp;
    CHAR  cTmp0, cTmp1, cTmp2, cTmp3;

    faxlogprintf(L"WOWFAXUI!%s: %X\n", pszTitle, lpFaxDev);
    dwTmp = lpFaxDev->id;
    cTmp3 = (CHAR)  dwTmp & 0xFF;
    cTmp2 = (CHAR) (dwTmp >>  8) & 0xFF;
    cTmp1 = (CHAR) (dwTmp >> 16) & 0xFF;
    cTmp0 = (CHAR) (dwTmp >> 24) & 0xFF;
    faxlogprintf(L"\tid: %c%c%c%c\n", cTmp3, cTmp2, cTmp1, cTmp0);
    faxlogprintf(L"\tlpNext: %X\n", lpFaxDev->lpNext);
    faxlogprintf(L"\tlpClient: %X\n", lpFaxDev->lpClient);
    faxlogprintf(L"\thdev: %X\n", lpFaxDev->hdev);
    faxlogprintf(L"\tidMap: %X\n", lpFaxDev->idMap);
    faxlogprintf(L"\tcbMapLow: %X\n", lpFaxDev->cbMapLow);
    faxlogprintf(L"\thMap: %X\n", lpFaxDev->hMap);
    faxlogprintf(L"\tszMap: %s\n", lpFaxDev->szMap);
    if (lpFaxDev->lpMap) {
        LogWowFaxInfo(lpFaxDev->lpMap);
    }
    else {
        faxlogprintf(L"\tlpMap: %X\n", lpFaxDev->lpMap);
    }
    faxlogprintf(L"\toffbits: %X\n", lpFaxDev->offbits);
    faxlogprintf(L"\thbm: %X\n", lpFaxDev->hbm);
    faxlogprintf(L"\tcPixPerByte: %X\n", lpFaxDev->cPixPerByte);
    faxlogprintf(L"\tbmFormat: %X\n", lpFaxDev->bmFormat);
    faxlogprintf(L"\tbmWidthBytes: %X\n", lpFaxDev->bmWidthBytes);
    faxlogprintf(L"\thbmSurf: %X\n", lpFaxDev->hbmSurf);
    faxlogprintf(L"\thwnd: %X\n", lpFaxDev->hwnd);
    faxlogprintf(L"\ttid: %X\n", lpFaxDev->tid);
    faxlogprintf(L"\tlpinfo16: %X\n", lpFaxDev->lpinfo16);
    faxlogprintf(L"\thDriver: %X\n", lpFaxDev->hDriver);
    faxlogprintf(L"\tStart of gdiinfo: %X\n", (DWORD)&(lpFaxDev->gdiinfo));
    faxlogprintf(L"\tStart of devinfo: %X\n", (DWORD)&(lpFaxDev->devinfo));
    faxlogprintf(L"\tpdevmode: %X\n", lpFaxDev->pdevmode);
}
#endif

//************************************************************************
// ValidateFaxDev - Validates the FAXDEV structure by checking the DWORD
//      signature, which is a known fixed value.
//
//************************************************************************

BOOL ValidateFaxDev(LPFAXDEV lpFaxDev)
{
    if (lpFaxDev) {
        if (lpFaxDev->id == FAXDEV_ID) {
            return TRUE;
        }
        LOGDEBUG(0, (L"ValidateFaxDev failed, bad id, lpFaxDev: %X\n", lpFaxDev));
    }
    else {
        LOGDEBUG(0, (L"ValidateFaxDev failed, lpFaxDev: NULL\n"));
    }
    return FALSE;
}

//***************************************************************************
// WFLocalAlloc - Debug version of LocalAlloc.
//***************************************************************************

LPVOID WFLocalAlloc(DWORD dwBytes, LPWSTR lpszWhoCalled)
{
    LPVOID lpTmp;

    lpTmp = LocalAlloc(LPTR, dwBytes);

    if (lpTmp == NULL){
        LOGDEBUG(0, (L"WOWFAXUI!%s, failed on memory allocation of %d bytes\n", lpszWhoCalled, dwBytes));
    }
    return(lpTmp);
}

//***************************************************************************
// FindWowFaxWindow - Put up a message box if you can't.
//***************************************************************************
HWND FindWowFaxWindow(void)
{
    HWND hwnd;
    PROCESS_INFORMATION ProcessInformation;
    STARTUPINFO StartupInfo;
    DWORD WaitStatus;
    TCHAR szMsg[WOWFAX_MAX_USER_MSG_LEN];
    TCHAR szTitle[WOWFAX_MAX_USER_MSG_LEN];
    WCHAR szWowExec[] = L"WOWEXEC";

    if ((hwnd = FindWindow(WOWFAX_CLASS, NULL)) == NULL) {
        // You can't find the WowFaxWindow, try to start WOW.
        RtlZeroMemory((PVOID)&StartupInfo, (DWORD)sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = SW_NORMAL;

        if (CreateProcess(NULL,
                            szWowExec,
                            NULL,               // security
                            NULL,               // security
                            FALSE,              // inherit handles
                            CREATE_NEW_CONSOLE | CREATE_DEFAULT_ERROR_MODE,
                            NULL,               // environment strings
                            NULL,               // current directory
                            &StartupInfo,
                            &ProcessInformation)) {

            WaitForInputIdle(ProcessInformation.hProcess, 120 * 1000);

            if ((hwnd = FindWindow(WOWFAX_CLASS, NULL)) != NULL) {
                return(hwnd);
            }
        }

        // If WOW failed to start -- let user know. 
        //  -- except during setup mode -- the spooler calls into every printer
        //     driver to update the registry printer settings if needed.
        if(!InSetupMode()) {
            if (LoadString(ghInst, WOWFAX_NAME_STR, szTitle, WOWFAX_MAX_USER_MSG_LEN)) {
                if (LoadString(ghInst, WOWFAX_NOWOW_STR, szMsg, WOWFAX_MAX_USER_MSG_LEN)) {
                    MessageBox(hwnd, szMsg, szTitle, MB_OK);
                }
            }
        }
    }
    return(hwnd);
}

//************************************************************************
// DupTokenW - Helper for Get16BitDriverInfoFromRegistry. Allocate and
//      copy a token, wide format. Allocates storage for duplicate.
//      wcsdup is not present in the run-times we link to.
//************************************************************************

LPTSTR DupTokenW(LPTSTR lpTok)
{
    LPTSTR lpRetVal = NULL;

    if (lpTok != NULL) {
        lpRetVal = WFLOCALALLOC((wcslen(lpTok) + 1) * sizeof(TCHAR), L"DupTokenW");
        if (lpRetVal) {
            wcscpy(lpRetVal, lpTok);
        }
    }
    return(lpRetVal);
}

//************************************************************************
// Get16BitDriverInfoFromRegistry - Get the 16-bit driver info (name, port)
//      from the registry where it is written by the 16-bit fax driver
//      install program using an intercepted WriteProfileString. Storage is
//      allocated for the returned info, and must be freed by the caller
//      using Free16BitDriverInfo. See also Set16BitDriverInfoToRegistry
//      in WOW32FAX.C
//************************************************************************

LPREGFAXDRVINFO16 Get16BitDriverInfoFromRegistry(PWSTR pDeviceName)
{
    TCHAR   szRetBuf[MAX_PATH];
    HKEY    hKey = 0;
    DWORD   dwType, cbBufSize = MAX_PATH;
    LPTSTR  lpTok, lpDevName;

    LPREGFAXDRVINFO16 lpRetVal = WFLOCALALLOC(sizeof(REGFAXDRVINFO16), L"Get16BitDriverInfoFromRegistry");

    if ((pDeviceName != NULL) && (lpRetVal != NULL)) {

        // Extract the 16-bit device name from pDeviceName.
        wcscpy(szRetBuf, pDeviceName);
        lpDevName = szRetBuf;
        while (lpTok = wcschr(lpDevName, '\\')) {
            lpDevName = ++lpTok;
        }
        if (lpTok = wcschr(lpDevName, ',')) {
            *lpTok = '\0';
        }

        if (lpRetVal->lpDeviceName = DupTokenW(lpDevName)) {

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             L"Software\\Microsoft\\Windows NT\\CurrentVersion\\WOW\\WowFax\\devices",
                             0, KEY_READ, &hKey ) == ERROR_SUCCESS) {

                if (RegQueryValueEx(hKey, lpDevName, 0, &dwType, (LPBYTE)szRetBuf,
                                    &cbBufSize) == ERROR_SUCCESS) {

                    // Parse registry data into driver name and port name.
                    // Make wcstok multi-thread safe, it stores state.
                    EnterCriticalSection(lpCriticalSection);
                    lpTok = wcstok(szRetBuf, L",");
                    lpRetVal->lpDriverName = DupTokenW(lpTok);
                    lpTok = wcstok(NULL, L",");
                    lpRetVal->lpPortName = DupTokenW(lpTok);
                    LeaveCriticalSection(lpCriticalSection);
                }
                RegCloseKey(hKey);
            }
        }
    }

    if (lpRetVal && lpRetVal->lpDeviceName &&
        lpRetVal->lpDriverName && lpRetVal->lpPortName) {
        LOGDEBUG(1, (L"WOWFAXUI!Get16BitDriverInfoFromRegistry, Name: %s, Driver: %s, Port: %s\n", pDeviceName, lpRetVal->lpDriverName, lpRetVal->lpPortName));
        return(lpRetVal);
    }

    LOGDEBUG(0, (L"WOWFAXUI!Get16BitDriverInfoFromRegistry, failed\n"));
    Free16BitDriverInfo(lpRetVal);
    return(NULL);
}

//************************************************************************
// Free16BitDriverInfo - Free the 16-bit driver info allocated by
//      Get16BitDriverInfoFromRegistry.
//************************************************************************

VOID Free16BitDriverInfo(LPREGFAXDRVINFO16 lpRegFaxDrvInfo16)
{
     if (lpRegFaxDrvInfo16) {
         if (lpRegFaxDrvInfo16->lpDeviceName) {
             LocalFree(lpRegFaxDrvInfo16->lpDeviceName);
         }
         if (lpRegFaxDrvInfo16->lpDriverName) {
             LocalFree(lpRegFaxDrvInfo16->lpDriverName);
         }
         if (lpRegFaxDrvInfo16->lpPortName) {
             LocalFree(lpRegFaxDrvInfo16->lpPortName);
         }
         LocalFree(lpRegFaxDrvInfo16);
         return;
     }
}

//***************************************************************************
// InterProcCommHandler - Handles inter-process communication between
//      WOWFAXUI-WOW32 and WOWFAX-WOW32.
//***************************************************************************

BOOL InterProcCommHandler(LPFAXDEV lpdev, UINT iAction)
{
    LPWOWFAXINFO lpT = lpdev->lpMap;
    HANDLE  hMap = 0;
    WNDPROC wndproc;
    MSG     msg;

    switch (iAction)
    {
        case DRVFAX_SETMAPDATA:
            if (lpdev->lpMap) {
                // init map struct
                lpdev->lpMap->status = FALSE;
                lpdev->lpMap->retvalue = (DWORD)-1;
                lpdev->hwnd = FindWowFaxWindow();
                lpdev->lpMap->hwnd = lpdev->hwnd;
                lpdev->lpMap->msg = 0;
                lpdev->lpMap->hdc = (WPARAM)lpdev->idMap;
                (DWORD)lpdev->lpMap->lpinfo16 = lpdev->lpinfo16;
            }
            break;

        case DRVFAX_SENDTOWOW:
            if (lpdev->lpMap->hwnd) {
                SendMessage(lpdev->lpMap->hwnd, lpdev->lpMap->msg, (WPARAM)lpdev->idMap, 0);
            }
            else {
                LOGDEBUG(0, (L"WOWFAXUI!InterProcCommHandler, No hwnd to send to.\n"));
            }
            break;

        case DRVFAX_CALLWOW:
            if (lpdev->lpMap->hwnd) {
                wndproc = (WNDPROC) GetWindowLongA(lpdev->lpMap->hwnd, GWL_WNDPROC);
                CallWindowProc(wndproc, lpdev->lpMap->hwnd, lpdev->lpMap->msg, (WPARAM)lpdev->idMap, 0);
            }
            else {
                LOGDEBUG(0, (L"WOWFAXUI!InterProcCommHandler, No hwnd to call to.\n"));
            }
            break;

        case DRVFAX_SENDNOTIFYWOW:
            if (lpdev->lpMap->hwnd) {
                SendNotifyMessage(lpdev->lpMap->hwnd, lpdev->lpMap->msg, (WPARAM)lpdev->idMap, 0);

                // To simulate app-modal dialog, pass message's to this threads
                // windows to DefWndProc, until 16-bit fax driver UI is dismissed.
                while (!lpdev->lpMap->status) {
                    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                        // EasyFax ver2.0 & MyTalk ver 2.0
                        // Also Procomm+ 3 cover sheets. Bug #305665
                        if ((msg.message == WM_PAINT) ||
                            (msg.message >= WM_USER)  ||
                            ((msg.message >= WM_DDE_FIRST) && 
                             (msg.message <= WM_DDE_LAST)     )) {
                            DispatchMessage(&msg);
                        }
                        else {
                            DefWindowProc(msg.hwnd, msg.message, msg.wParam, msg.lParam);
                        }
                    }
                }
            }
            break;

        case DRVFAX_CREATEMAP:
        case DRVFAX_DESTROYMAP:
            if (lpdev->lpMap) {

                // destroys the current map - for both iActions
                UnmapViewOfFile(lpdev->lpMap);
                CloseHandle(lpdev->hMap);
                lpdev->lpMap = 0;
                lpdev->hMap = 0;
                lpT = 0;
            }

            if (iAction == DRVFAX_CREATEMAP) {
                // GetFaxDataMapName is WOWFAX_INC_COMMON_CODE in wowfax.h.
                GetFaxDataMapName((DWORD)lpdev->idMap, lpdev->szMap);
                hMap = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE,
                                         0, lpdev->cbMapLow, lpdev->szMap);
                if (hMap) {
                    if (GetLastError() == ERROR_ALREADY_EXISTS) {
                        CloseHandle(hMap);
                    }
                    else {
                        lpT = (LPWOWFAXINFO)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);
                        if (lpT) {
                            lpdev->hMap   = hMap;
                            lpdev->lpMap  = lpT;
                        }
                        else {
                            LOGDEBUG(0, (L"WOWFAXUI!InterProcCommHandler, MapViewOfFile failed, LastError = %ld\n", GetLastError()));
                            CloseHandle(hMap);
                        }
                    }
                }
                else {
                    LOGDEBUG(0, (L"WOWFAXUI!InterProcCommHandler, CreateFileMapping failed, LastError = %ld\n", GetLastError()));
                }
            }
            break;

    } //switch

    return((BOOL)lpT);
}


//************************************************************************
// InSetupMode: Checks if this process is running during NT setup.
//
// return:
//  TRUE if in NT setup
//  FALSE otherwise
//************************************************************************
BOOL InSetupMode(void)
{
    DWORD   SetupMode = FALSE;
    LONG    results;
    DWORD   Type, Size = sizeof(DWORD);
    HKEY    Key;

    results = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"System\\Setup", &Key );

    if (results != ERROR_SUCCESS) return FALSE;

    results = RegQueryValueExW(Key, L"SystemSetupInProgress",
                               NULL, &Type, (PBYTE)&SetupMode, &Size);

    RegCloseKey(Key);

    return (!(SetupMode == 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfaxui\wfsheets.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. User Interface functions
// which are called by WINSPOOL. Support for Two new entry points required
// by the Win 95 printer UI, DrvDocumentPropertySheets and
// DrvDevicePropertySheets
//
// History:
//    24-Apr-96   reedb   created.
//
//************************************************************************

#include "windows.h"
#include "wowfaxui.h"
#include "wfsheets.h"
#include "winspool.h"

//************************************************************************
// Globals
//************************************************************************

extern HINSTANCE ghInst;

DEVMODEW gdmDefaultDevMode;

LONG DrvDocumentProperties(HWND hwnd, HANDLE hPrinter, PWSTR pDeviceName, PDEVMODE pdmOut, PDEVMODE pdmIn, DWORD fMode);
LONG SimpleDocumentProperties(PDOCUMENTPROPERTYHEADER pDPHdr);

//************************************************************************
// NullDlgProc - Procedure for handling "Printer Properties" property
//      sheet page
//************************************************************************

BOOL NullDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

//************************************************************************
// FaxOptionsProc - Procedure for handling "Fax Options" property
//      sheet page
//************************************************************************

BOOL FaxOptionsProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    PDEVMODE pdmOut = NULL;
    PDEVMODE pdmIn  = NULL;
    PUIDATA pUiData;
    TCHAR  szFeedBack[WOWFAX_MAX_USER_MSG_LEN];

    switch (message) {
        case WM_INITDIALOG:
            SetWindowLong(hDlg, DWL_USER, ((PROPSHEETPAGE *) lParam)->lParam);
            return TRUE;

        case WM_COMMAND:
            if (wParam == IDOK) {
                SetWindowText(GetDlgItem(hDlg, IDC_FEEDBACK), L"");

                pUiData = (PUIDATA) GetWindowLong(hDlg, DWL_USER);
                DrvDocumentProperties(hDlg,
                                      pUiData->hPrinter,
                                      pUiData->pDeviceName,
                                      pUiData->pdmOut,
                                      pUiData->pdmIn,
                                      pUiData->fMode);

                //
                // Provide user with feedback text.
                //
                if (LoadString(ghInst, WOWFAX_ENABLE_CONFIG_STR,
                               szFeedBack, sizeof( szFeedBack)/sizeof(TCHAR))) {
                    SetWindowText(GetDlgItem(hDlg, IDC_FEEDBACK), szFeedBack);
                }
            }
            break;

        case WM_NOTIFY:

            if (((NMHDR *) lParam)->code == PSN_APPLY) {

                pUiData = (PUIDATA) GetWindowLong(hDlg, DWL_USER);

                //
                // HACK: Inform common UI library that user has pressed OK
                //

                pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_SET_RESULT,
                                         (LONG) pUiData->hFaxOptsPage,
                                         CPSUI_OK);
                return TRUE;

            }
            break;
    }

    return FALSE;
}

//************************************************************************
// AddDocPropPages -Add our "Document Properties" pages to the property
//      sheet. Returns RUE if successful, FALSE otherwise.
//************************************************************************

BOOL AddDocPropPages(PUIDATA pUiData)
{
    PROPSHEETPAGE   psp;
    LONG            result;

    //
    // "Document Properties" dialog only has one tab - "Fax Options"
    //

    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = ghInst;
    psp.lParam = (LPARAM) pUiData;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DOCPROP);
    psp.pfnDlgProc = FaxOptionsProc;

    pUiData->hFaxOptsPage = (HANDLE)
        pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                 CPSFUNC_ADD_PROPSHEETPAGE,
                                 (LPARAM) &psp,
                                 0);

    return (pUiData->hFaxOptsPage != NULL);
}


//************************************************************************
// MyGetPrinter - Wrapper function for GetPrinter spooler API. Returns
//      Pointer to a PRINTER_INFO_x structure, NULL if there is an error
//************************************************************************

PVOID MyGetPrinter(HANDLE hPrinter, DWORD level)
{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cbNeeded;

    if (!GetPrinter(hPrinter, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = LocalAlloc(LPTR, cbNeeded)) &&
        GetPrinter(hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded))
    {
        return pPrinterInfo;
    }

    LOGDEBUG(0, (L"GetPrinter failed\n"));
    LocalFree(pPrinterInfo);
    return NULL;
}

//************************************************************************
// FreeUiData - Free the data structure used by the fax driver user
//      interface.
//************************************************************************

PUIDATA FreeUiData(PUIDATA pUiData)
{
    if (pUiData) {
        if (pUiData->pDeviceName) LocalFree(pUiData->pDeviceName);
        if (pUiData->pDriverName) LocalFree(pUiData->pDriverName);
    }
    return NULL;
}

//************************************************************************
// FillUiData - Fill in the data structure used by the fax driver user
//      interface. Returns pointer to UIDATA structure, NULL if error.
//************************************************************************

PUIDATA FillUiData(HANDLE hPrinter, PDEVMODE pdmInput, PDEVMODE pdmOutput, DWORD fMode)
{
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    PUIDATA         pUiData;

    //
    // Allocate memory to hold UIDATA structure
    // Get printer info from the spooler. Copy the driver name.
    //

    if (! (pUiData = LocalAlloc(LPTR, sizeof(UIDATA))) ||
        ! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) ||
        ! (pUiData->pDeviceName = DupTokenW(pPrinterInfo2->pPrinterName)) ||
        ! (pUiData->pDriverName = DupTokenW(pPrinterInfo2->pDriverName))) {

        pUiData = FreeUiData(pUiData);
    }
    else {
        pUiData->pdmIn  = pdmInput;
        pUiData->pdmOut = pdmOutput;
        pUiData->fMode  = fMode;

        pUiData->startUiData = pUiData->endUiData = pUiData;
        pUiData->hPrinter    = hPrinter;
    }
    
    if (pPrinterInfo2)
        LocalFree(pPrinterInfo2);

    return pUiData;
}

//************************************************************************
// DrvDocumentPropertySheets - Display "Document Properties" property
//      sheets. Return > 0 if successful, <= 0 if failed.
//************************************************************************

LONG DrvDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    PDOCUMENTPROPERTYHEADER pDPHdr;
    PCOMPROPSHEETUI         pCompstui;
    PUIDATA                 pUiData;
    LONG                    result;

    //
    // Validate input parameters
    //
    if (! (pDPHdr = (PDOCUMENTPROPERTYHEADER) (pPSUIInfo ?  pPSUIInfo->lParamInit : lParam))) {
        return -1;
    }

    if (pPSUIInfo == NULL) {
        return SimpleDocumentProperties(pDPHdr);
    }

    //
    // Create a UIDATA structure if necessary
    //

    pUiData = (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) ?
                    FillUiData(pDPHdr->hPrinter, pDPHdr->pdmIn, pDPHdr->pdmOut, pDPHdr->fMode) :
                    (PUIDATA) pPSUIInfo->UserData;

    if (! ValidUiData(pUiData))
        return -1;

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason) {

    case PROPSHEETUI_REASON_INIT:

        pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
        pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

        //
        // Add our page to the property sheet
        //

        if (AddDocPropPages(pUiData)) {

            pPSUIInfo->UserData = (DWORD) pUiData;
            pPSUIInfo->Result = CPSUI_CANCEL;
            return 1;
        }

        //
        // Clean up properly in case of an error
        //

        FreeUiData(pUiData);
        break;

    case PROPSHEETUI_REASON_GET_INFO_HEADER:

        {   PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
            pPSUIHdr->hInst = ghInst;
            pPSUIHdr->IconID = IDI_CPSUI_PRINTER2;
        }
        return 1;

    case PROPSHEETUI_REASON_SET_RESULT:

        pPSUIInfo->Result = ((PSETRESULT_INFO) lParam)->Result;
        return 1;

    case PROPSHEETUI_REASON_DESTROY:

        //
        // Cleanup properly before exiting
        //

        FreeUiData(pUiData);
        return 1;
    }
    return -1;
}

//************************************************************************
// DrvDevicePropertySheets - Display "Printer Properties" dialog.
//      Return > 0 if successful, <= 0 if failed.
//************************************************************************

LONG DrvDevicePropertySheets(PPROPSHEETUI_INFO   pPSUIInfo, LPARAM lParam)
{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PCOMPROPSHEETUI         pCompstui;
    PROPSHEETPAGE           psp;
    LONG                    result;

    //
    // Validate input parameters
    //
    LOGDEBUG(1,(L"DrvDevicePropertySheets: %d\n", pPSUIInfo->Reason));

    if (!pPSUIInfo || !(pDPHdr = (PDEVICEPROPERTYHEADER) pPSUIInfo->lParamInit)) {
        return -1;
    }

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason) {

    case PROPSHEETUI_REASON_INIT:
        //
        // "Printer Properties" dialog only has one dummy tab
        //
    
        memset(&psp, 0, sizeof(psp));
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = ghInst;
    
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NULLPROP);
        psp.pfnDlgProc = NullDlgProc;
    
        if (pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                       CPSFUNC_ADD_PROPSHEETPAGE,
                                       (LPARAM) &psp,
                                       0))
        {
            pPSUIInfo->Result = CPSUI_CANCEL;
            return 1;
        }
        break;
    
    case PROPSHEETUI_REASON_GET_INFO_HEADER:
        {   PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
            pPSUIHdr->hInst = ghInst;
            pPSUIHdr->IconID = IDI_CPSUI_FAX;
        }
        return 1;

    case PROPSHEETUI_REASON_SET_RESULT:
        pPSUIInfo->Result = ((PSETRESULT_INFO) lParam)->Result;
        return 1;

    case PROPSHEETUI_REASON_DESTROY:
        return 1;
    }

    return -1;
}

LONG
SimpleDocumentProperties(PDOCUMENTPROPERTYHEADER pDPHdr)

/*++

Routine Description:

    Handle simple "Document Properties" where we don't need to display
    a dialog and therefore don't have to have common UI library involved

Arguments:

    pDPHdr - Points to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 otherwise

--*/

{
    LONG lRet;

    lRet = DrvDocumentProperties(NULL,
                                 pDPHdr->hPrinter,
                                 pDPHdr->pszPrinterName,
                                 pDPHdr->pdmOut,
                                 pDPHdr->pdmIn,
                                 pDPHdr->fMode);

    if (pDPHdr->fMode == 0 || pDPHdr->pdmOut == NULL) {
        pDPHdr->cbOut = lRet;
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfax\wowfax.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. 32-bit printer driver
// functions. Runs in the graphics engine context (CSRSS).
//
// History:
//    02-jan-95   nandurir   created.
//    01-feb-95   reedb      Clean-up, support printer install and bug fixes.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//    16-aug-95   reedb      Move to kernel mode. Debug output and validate
//                              functions moved from FAXCOMM.C.
//
//************************************************************************

#include "wowfaxdd.h"

//************************************************************************
// Globals
//************************************************************************

DRVFN  DrvFnTab[] = {
                      {INDEX_DrvEnablePDEV,      (PFN)DrvEnablePDEV  },
                      {INDEX_DrvDisablePDEV,     (PFN)DrvDisablePDEV  },
                      {INDEX_DrvCompletePDEV,    (PFN)DrvCompletePDEV  },
                      {INDEX_DrvEnableSurface,   (PFN)DrvEnableSurface  },
                      {INDEX_DrvDisableSurface,  (PFN)DrvDisableSurface  },
                      {INDEX_DrvStartDoc,        (PFN)DrvStartDoc  },
                      {INDEX_DrvStartPage,       (PFN)DrvStartPage  },
                      {INDEX_DrvSendPage,        (PFN)DrvSendPage  },
                      {INDEX_DrvEndDoc,          (PFN)DrvEndDoc  },
                      {INDEX_DrvDitherColor,     (PFN)DrvDitherColor },
                      {INDEX_DrvEscape,          (PFN)DrvEscape},
                   };

#define NO_DRVFN        (sizeof(DrvFnTab) / sizeof(DrvFnTab[0]))


#if DBG

//************************************************************************
// faxlogprintf - Driver version of the debug output function.
//
//************************************************************************

VOID faxlogprintf(PCHAR pszFmt, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, pszFmt);

    EngDebugPrint("", pszFmt, ap);

    va_end(ap);
}

#endif

//************************************************************************
// ValidateFaxDev - Validates the FAXDEV structure by checking the DWORD
//      signature, which is a known fixed value.
//
//************************************************************************

BOOL ValidateFaxDev(LPFAXDEV lpFaxDev)
{
    if (lpFaxDev) {
        if (lpFaxDev->id == FAXDEV_ID) {
            return TRUE;
        }
        LOGDEBUG(("ValidateFaxDev failed, bad id, lpFaxDev: %X\n", lpFaxDev));
    }
    else {
        LOGDEBUG(("ValidateFaxDev failed, lpFaxDev: NULL\n"));
    }
    return FALSE;
}

//************************************************************************
// DllInitProc
//************************************************************************

BOOL DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(Reason);
    UNREFERENCED_PARAMETER(pContext);

    return TRUE;
}


//***************************************************************************
// DrvEnableDriver
//***************************************************************************

BOOL DrvEnableDriver(ULONG iEngineVersion, ULONG cb, DRVENABLEDATA  *pded)
{
    LOGDEBUG(("WOWFAX!DrvEnableDriver, iEngineVersion: %X, cb: %X, pded: %X\n", iEngineVersion, cb, pded));

    pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    if (cb < sizeof(DRVENABLEDATA)) {
        LOGDEBUG(("WOWFAX!DrvEnableDriver, failed\n"));
        return FALSE;
    }

    pded->c = NO_DRVFN;
    pded->pdrvfn = DrvFnTab;

    return  TRUE;

}

//***************************************************************************
// DrvDisableDriver
//***************************************************************************

VOID DrvDisableDriver(VOID)
{
    LOGDEBUG(("WOWFAX!DrvDisableDriver\n"));
    return;
}

//***************************************************************************
// DrvEnablePDEV
//***************************************************************************
DHPDEV DrvEnablePDEV(DEVMODEW *pdevmode,        // Driver data, Client FAXDEV
                     PWSTR     pwstrPrtName,    // Printer's name in CreateDC()
                     ULONG     cPatterns,       // Count of standard patterns
                     HSURF    *phsurfPatterns,  // Buffer for standard patterns
                     ULONG     cjGdiInfo,       // Size of buffer for GdiInfo
                     ULONG    *pulGdiInfo,      // Buffer for GDIINFO
                     ULONG     cjDevInfo,       // Number of bytes in devinfo
                     DEVINFO  *pdevinfo,        // Device info
                     HDEV      hdev,
                     PWSTR     pwstrDeviceName, // Device Name - "LaserJet II"
                     HANDLE    hDriver          // Printer handle for spooler access
)
{
    LPFAXDEV   lpCliFaxDev, lpSrvFaxDev = NULL;

    LOGDEBUG(("WOWFAX!DrvEnablePDEV, pdevmode: %X, pwstrPrtName: %S\n", pdevmode, pwstrPrtName));

    if (pdevmode) {
        // Point to the end of the DEVMODE where the FAXDEV is located.
        lpCliFaxDev = (LPFAXDEV) ((PBYTE)pdevmode + pdevmode->dmSize);

        // Allocate a server side FAXDEV to be passed back to GDI. Copy the
        // client side FAXDEV to the server side FAXDEV. Note all pointers in
        // the client FAXDEV reference client side memory and cannot be
        // dereferenced on the server side.
        lpSrvFaxDev = (LPFAXDEV)EngAllocMem(0, sizeof(FAXDEV), FAXDEV_ID);
        LOGDEBUG(("WOWFAX!DrvEnablePDEV, allocated lpSrvFaxDev: %X\n", lpSrvFaxDev));

        if (InitPDEV(lpCliFaxDev, lpSrvFaxDev,
                     cPatterns, phsurfPatterns,
                     cjGdiInfo, pulGdiInfo,
                     cjDevInfo, pdevinfo)) {

            lpSrvFaxDev->hDriver = hDriver;
            return (DHPDEV)lpSrvFaxDev;
        }
        else {
            LOGDEBUG(("WOWFAX!DrvEnablePDEV, failed\n"));
            if (lpSrvFaxDev) {
                EngFreeMem(lpSrvFaxDev);
                lpSrvFaxDev = NULL;
            }
        }
    }
    return (DHPDEV)lpSrvFaxDev;
}

//***************************************************************************
// InitPDEV - Called by DrvEnablePDEV and DrvRestartPDEV to initialize the
//      server side PDEV/FAXDEV.
//***************************************************************************


BOOL InitPDEV(
    LPFAXDEV  lpCliFaxDev,           // Pointer to the client side FAXDEV
    LPFAXDEV  lpSrvFaxDev,           // Pointer to the server side FAXDEV
    ULONG     cPatterns,            // Count of standard patterns
    HSURF    *phsurfPatterns,       // Buffer for standard patterns
    ULONG     cjGdiInfo,            // Size of buffer for GdiInfo
    ULONG    *pulGdiInfo,           // Buffer for GDIINFO
    ULONG     cjDevInfo,            // Number of bytes in devinfo
    DEVINFO  *pdevinfo              // Device info
)
{
    PGDIINFO pgdiinfo = (PGDIINFO)pulGdiInfo;
    ULONG    uColors[2];

    if (!ValidateFaxDev(lpCliFaxDev)) {
        return FALSE;
    }

    // lpSrvFaxDev hasn't been initialized yet, so just check pointer.
    if (lpSrvFaxDev == NULL) {
        LOGDEBUG(("WOWFAX!InitPDEV, failed, NULL lpSrvFaxDev parameter\n"));
        return FALSE;
    }

    // Copy client FAXDEV to server.
    RtlCopyMemory(lpSrvFaxDev, lpCliFaxDev, sizeof(FAXDEV));

    // Copy GDIINFO from client FAXDEV to the GDI buffer for GDIINFO.
    RtlCopyMemory(pgdiinfo, &(lpCliFaxDev->gdiinfo), sizeof(GDIINFO));

    // Initialize the DEVINFO structure.
    uColors[0] = RGB(0x00, 0x00, 0x00);
    uColors[1] = RGB(0xff, 0xff, 0xff);

    pdevinfo->hpalDefault = EngCreatePalette(PAL_INDEXED, 2, uColors, 0, 0, 0);
    pdevinfo->iDitherFormat = BMF_1BPP;

    // Make sure we don't journal.
    pdevinfo->flGraphicsCaps |= GCAPS_DONTJOURNAL;

    // Make sure we do dither.
    pdevinfo->flGraphicsCaps |= GCAPS_HALFTONE | GCAPS_MONO_DITHER |
                                    GCAPS_COLOR_DITHER;

    // Copy the DEVINFO data to the server side FAXDEV.
    RtlCopyMemory(&(lpSrvFaxDev->devinfo), pdevinfo, sizeof(DEVINFO));

    return TRUE;
}

//***************************************************************************
// DrvCompletePDEV
//***************************************************************************

VOID DrvCompletePDEV(DHPDEV dhpdev, HDEV hdev)
{
    LPFAXDEV lpSrvFaxDev = (LPFAXDEV) dhpdev;

    LOGDEBUG(("WOWFAX!DrvCompletePDEV, dhpdev %X\n", dhpdev));

    if (ValidateFaxDev(lpSrvFaxDev)) {
        // Store the gdi handle.
        lpSrvFaxDev->hdev = hdev;
    }
    else {
         LOGDEBUG(("WOWFAX!DrvCompletePDEV, failed\n"));
    }

    return;
}

//***************************************************************************
// DrvDisablePDEV
//***************************************************************************

VOID DrvDisablePDEV(DHPDEV  dhpdev)
{
    LPFAXDEV lpSrvFaxDev = (LPFAXDEV) dhpdev;

    LOGDEBUG(("WOWFAX!DrvDisablePDEV, dhpdev %X\n", dhpdev));

    if (ValidateFaxDev(lpSrvFaxDev)) {
        if (lpSrvFaxDev->devinfo.hpalDefault) {
            EngDeletePalette(lpSrvFaxDev->devinfo.hpalDefault);
        }
        EngFreeMem(lpSrvFaxDev);
        LOGDEBUG(("WOWFAX!DrvDisablePDEV, deallocated lpSrvFaxDev: %X\n", lpSrvFaxDev));
    }
    else {
        LOGDEBUG(("WOWFAX!DrvDisablePDEV, failed\n"));
    }
    return;
}


//***************************************************************************
// DrvEnableSurface
//***************************************************************************

HSURF DrvEnableSurface(DHPDEV  dhpdev)
{

    LPFAXDEV  lpFaxDev = (LPFAXDEV)dhpdev;
    HBITMAP   hbm = 0;

    LOGDEBUG(("WOWFAX!DrvEnableSurface, lpFaxDev: %X\n", lpFaxDev));

    if (ValidateFaxDev(lpFaxDev)) {
        // GDI will allocate space for the bitmap bits. We'll use a DrvEscape
        // to copy them to the client side.
        hbm = EngCreateBitmap(lpFaxDev->gdiinfo.szlPhysSize,
                              lpFaxDev->bmWidthBytes,
                              lpFaxDev->bmFormat, BMF_TOPDOWN, NULL);
        if (hbm) {
            lpFaxDev->hbm = hbm;
            EngAssociateSurface((HSURF)hbm, lpFaxDev->hdev, 0);
            return  (HSURF)hbm;
        }
        LOGDEBUG(("WOWFAX!DrvEnableSurface, EngCreateBitmap failed\n"));
    }

    return  (HSURF)hbm;
}

//***************************************************************************
// DrvDisableSurface
//***************************************************************************

VOID DrvDisableSurface(
    DHPDEV dhpdev
)
{
    LPFAXDEV  lpFaxDev = (LPFAXDEV)dhpdev;

    LOGDEBUG(("WOWFAX!DrvDisableSurface, lpFaxDev: %X\n", lpFaxDev));

    if (ValidateFaxDev(lpFaxDev)) {
        if (lpFaxDev->hbm) {
            EngDeleteSurface((HSURF)lpFaxDev->hbm);
            lpFaxDev->hbm = 0;
            return;
        }
    }
    return;
}

//***************************************************************************
// DrvStartDoc
//***************************************************************************

BOOL DrvStartDoc(
    SURFOBJ *pso,
    PWSTR pwszDocName,
    DWORD dwJobId
)
{
    LOGDEBUG(("WOWFAX!DrvStartDoc, pso: %X, pwszDocName: %S, dwJobId: %X\n", pso, pwszDocName, dwJobId));
    return  TRUE;
}

//***************************************************************************
// DrvStartPage
//***************************************************************************

BOOL DrvStartPage(
    SURFOBJ *pso
)
{
    LPFAXDEV  lpFaxDev = (LPFAXDEV)pso->dhpdev;
    BITMAP bm;
    RECTL rc;

    LOGDEBUG(("WOWFAX!DrvStartPage, pso: %X\n", pso));

    // Calculate the size of the rectangle based on the input data
    // in 'pso' - this will  ensure that the entire bitmap is erased.

    if (ValidateFaxDev(lpFaxDev)) {
        rc.left   = 0;
        rc.top    = 0;
        rc.right  = pso->lDelta * lpFaxDev->cPixPerByte;
        rc.bottom = pso->cjBits / pso->lDelta;

        EngEraseSurface(pso, &rc, COLOR_INDEX_WHITE);
        return  TRUE;
    }
    return  FALSE;
}       


//***************************************************************************
// DrvSendPage
//***************************************************************************

BOOL DrvSendPage(SURFOBJ *pso)
{
    LOGDEBUG(("WOWFAX!DrvSendPage, pso %X\n", pso));
    return  TRUE;
}


//***************************************************************************
// DrvEndDoc
//***************************************************************************

BOOL DrvEndDoc(SURFOBJ *pso, FLONG fl)
{
    LOGDEBUG(("WOWFAX!DrvEndDoc, pso %X\n", pso));
    return  TRUE;
}

ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )

{
    return DCR_HALFTONE;
}

//***************************************************************************
// DrvEscape - Allows client side to get server side data.
//***************************************************************************

ULONG DrvEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    ULONG   cjIn,
    PVOID   *pvIn,
    ULONG   cjOut,
    PVOID   *pvOut
)
{
    LPFAXDEV lpSrvFaxDev;
    ULONG    ulRet = 0;

    LOGDEBUG(("WOWFAX!DrvEscape, pso %X, iEsc: %X\n", pso, iEsc));
    if (pso) {
        lpSrvFaxDev = (LPFAXDEV)pso->dhpdev;
        if (ValidateFaxDev(lpSrvFaxDev)) {
            LOGDEBUG(("WOWFAX!DrvEscape, lpSrvFaxDev: %X\n", lpSrvFaxDev));
            switch (iEsc) {
                case DRV_ESC_GET_DEVMODE_PTR:
                    return (ULONG) lpSrvFaxDev->pdevmode;

                case DRV_ESC_GET_FAXDEV_PTR:
                    return (ULONG) lpSrvFaxDev->lpClient;

                case DRV_ESC_GET_SURF_INFO:
                    if (pvOut) {
                        if (cjOut == sizeof(LONG)) {
                            (LONG) *pvOut = pso->lDelta;
                            return (ULONG) pso->cjBits;
                        }
                    }
                    break;

                case DRV_ESC_GET_BITMAP_BITS:
                    // Validate the buffer pointer and copy the bits.
                    if (pvOut) {
                        if (cjOut == pso->cjBits) {
                            RtlCopyMemory(pvOut, pso->pvBits, cjOut);
                            return cjOut;
                        }
                        LOGDEBUG(("WOWFAX!DrvEscape, bitmap size mismatch cjIn: %X, pso->cjBits: %X\n", cjIn, pso->cjBits));
                    }
                    break;

//                default:
                    LOGDEBUG(("WOWFAX!DrvEscape, unknown escape: %X\n", iEsc));
            } //switch
        }
    }
    LOGDEBUG(("WOWFAX!DrvEscape, failed\n"));

    return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfaxui\wfupgrad.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. User Interface helper
// functions which are called in WOWFAXUI.C, helpers used during upgrade.
//
// History:
//    14-mar-95   reedb      Created. These were moved from WOWFAXUI.C.
//
//************************************************************************

#include "windows.h"
#include "wowfaxui.h"
#include "winspool.h"

extern LPCRITICAL_SECTION lpCriticalSection;
extern HINSTANCE ghInst;

//************************************************************************
// AllocPathW - Helper for DrvUpgradePrinter and friends.
//************************************************************************

PWSTR AllocPathW(VOID)
{
    PWSTR   szTmp;

    szTmp = WFLOCALALLOC((MAX_PATH+1) * sizeof(TCHAR), L"AllocPathW");
    return(szTmp);
}

//************************************************************************
// BuildPathW - Helper for DrvUpgradePrinter and friends.
//************************************************************************

PWSTR BuildPathW(PWSTR szPath, PWSTR szFileName)
{
    PWSTR   szTmp;

    if ((szTmp = WFLOCALALLOC((MAX_PATH+1) * sizeof(TCHAR), L"BuildPathW")) != NULL) {
        wcscpy(szTmp, szPath);
        wcscat(szTmp, L"\\");
        wcscat(szTmp, szFileName);
        return(szTmp);
    }
    else {
        return(NULL);
    }
}

//************************************************************************
// MyGetFileTime - Helper for DrvUpgradePrinter and friends.
//************************************************************************

BOOL MyGetFileTime(PWSTR szDir, PWSTR szName, LPFILETIME lpFileTime)
{
    LPWIN32_FIND_DATA lpfd;
    HANDLE  hfd;
    PWSTR   szTmp;
    BOOL    bRet = FALSE;


    szTmp = BuildPathW(szDir, szName);
    lpfd  = WFLOCALALLOC(sizeof(WIN32_FIND_DATA), L"MyGetFileTime");

    if ((szTmp) && (lpfd)) {
        LOGDEBUG(1, (L"WOWFAXUI!GetFileTime, szTmp: %s\n", szTmp));
        if ((hfd = FindFirstFile(szTmp, lpfd)) != INVALID_HANDLE_VALUE) {
            memcpy(lpFileTime, &(lpfd->ftLastWriteTime), sizeof(FILETIME));
            FindClose(hfd);
            bRet = TRUE;
            LOGDEBUG(1, (L"WOWFAXUI!GetFileTime, FileTimeHi: %X  FileTimeLo: %X\n", lpFileTime->dwHighDateTime, lpFileTime->dwLowDateTime));
        }
        else {
            LOGDEBUG(0, (L"WOWFAXUI!GetFileTime, file not found: %s\n", szTmp));
        }
    }

    if (szTmp) {
        LocalFree(szTmp);
    }
    if (lpfd) {
        LocalFree(lpfd);
    }
    return(bRet);
}

//************************************************************************
// CheckForNewerFiles - Helper for DrvUpgradePrinter. Compares the date/time
//      of wowfaxui.dll and wowfax.dll in the two passed directories. Returns
//      FALSE if files in szOldDriverDir are the same or newer than those
//      in szSysDir. Otherwise returns non-zero.
//************************************************************************

BOOL CheckForNewerFiles(PWSTR szOldDriverDir, PWSTR szSysDir)
{
    FILETIME ftSourceDriver, ftCurrentDriver;
    BOOL     bRet = FALSE;

    if ((szOldDriverDir) && (szSysDir)) {
        if (MyGetFileTime(szOldDriverDir, L"wowfax.dll", &ftCurrentDriver)) {
            if (MyGetFileTime(szSysDir, L"wowfax.dll", &ftSourceDriver)) {
                // Check time/date to see if we need to update the drivers.
                if (CompareFileTime(&ftSourceDriver, &ftCurrentDriver) > 0) {
                    bRet = TRUE;
                }
            }
        }
        if (MyGetFileTime(szOldDriverDir, L"wowfaxui.dll", &ftCurrentDriver)) {
            if (MyGetFileTime(szSysDir, L"wowfaxui.dll", &ftSourceDriver)) {
                if (CompareFileTime(&ftSourceDriver, &ftCurrentDriver) > 0) {
                    bRet = TRUE;
                }
            }
        }
    }
    else {
        LOGDEBUG(0, (L"WOWFAXUI!CheckForNewerFiles: NULL directory parameters\n"));
    }

    return(bRet);
}

//************************************************************************
// DoUpgradePrinter - Called by DrvUpgradePrinter which is called in the
//      system context by the spooler.
//************************************************************************

BOOL DoUpgradePrinter(DWORD dwLevel, LPDRIVER_UPGRADE_INFO_1W lpDrvUpgradeInfo)
{
    static BOOL bDrvUpgradePrinterLock = FALSE;
    HANDLE hPrinter = NULL;
    DRIVER_INFO_2  DriverInfo, *pDriverInfo = NULL;
    DWORD dwNeeded = 0;
    PWSTR szSysDir  = NULL;
    PWSTR szDstDir  = NULL;
    PWSTR szSrcPath = NULL;
    PWCHAR pwc;
    BOOL  bRet = FALSE;
    TCHAR szName[WOWFAX_MAX_USER_MSG_LEN] = L"";

    // Check for correct level for upgrade.
    if (dwLevel != 1) {
        LOGDEBUG(0, (L"WOWFAXUI!DrvUpgradePrinter, Bad input Level\n"));
        SetLastError(ERROR_INVALID_LEVEL);
        goto DoUpgradePrinterExit;
    }

    szDstDir = AllocPathW();
    szSysDir = AllocPathW();
    if (!szDstDir || !szSysDir) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, work space allocation failed\n"));
        goto DoUpgradePrinterExit;
    }

    if (!GetSystemDirectory(szSysDir, MAX_PATH+1)) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, GetSystemDirectory failed\n"));
        goto DoUpgradePrinterExit;
    }

    if (!lpDrvUpgradeInfo->pPrinterName) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, pPrinterName is NULL\n"));
        goto DoUpgradePrinterExit;
    }

    // Get the paths to the old printer drivers.
    if (!OpenPrinter(lpDrvUpgradeInfo->pPrinterName, &hPrinter, NULL)) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, Unable to open: %s\n", lpDrvUpgradeInfo->pPrinterName));
        goto DoUpgradePrinterExit;
    }

    GetPrinterDriver(hPrinter, NULL, 2, (LPBYTE) pDriverInfo, 0, &dwNeeded);

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, GetPrinterDriver failed\n"));
        goto DoUpgradePrinterExit;
    }

    if ((pDriverInfo = WFLOCALALLOC(dwNeeded, L"DoUpgradePrinter")) == NULL) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, work space allocation failed\n"));
        goto DoUpgradePrinterExit;
    }

    if (!GetPrinterDriver(hPrinter, NULL, 2, (LPBYTE) pDriverInfo, dwNeeded, &dwNeeded)) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, GetPrinterDriver failed, GetLastError: %d\n", GetLastError()));
        goto DoUpgradePrinterExit;
    }
    ClosePrinter(hPrinter);

    // Strip off the file name.
    if ((pwc = wcsrchr(pDriverInfo->pDriverPath, L'\\')) == NULL) {
        LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, unable to strip file name\n"));
        goto DoUpgradePrinterExit;
    }
    *pwc = UNICODE_NULL;

    // Install new printer driver if it's more recent than the old one.
    if (CheckForNewerFiles(pDriverInfo->pDriverPath, szSysDir)) {
        LOGDEBUG(1, (L"WOWFAXUI!DoUpgradePrinter, Doing driver update\n"));
        memset(&DriverInfo,  0, sizeof(DRIVER_INFO_2));

        if (!GetPrinterDriverDirectory(NULL, NULL, 1, (LPBYTE) szDstDir, MAX_PATH, &dwNeeded)) {
            LOGDEBUG(0, (L"WOWFAXUI!DoUpgradePrinter, GetPrinterDriverDirectory failed\n"));
            goto DoUpgradePrinterExit;
        }
 
        // This is a dummy. We've no data file, but spooler won't take NULL.
        DriverInfo.pDataFile   = BuildPathW(szDstDir, WOWFAX_DLL_NAME);
        DriverInfo.pDriverPath = BuildPathW(szDstDir, WOWFAX_DLL_NAME);
        LOGDEBUG(1, (L"WOWFAXUI!DoUpgradePrinter, pDriverPath = %s\n", DriverInfo.pDataFile));
        if (DriverInfo.pDriverPath) {
            szSrcPath = BuildPathW(szSysDir, WOWFAX_DLL_NAME);
            if (szSrcPath) {
                CopyFile(szSrcPath, DriverInfo.pDriverPath, FALSE);
                LocalFree(szSrcPath);
            }
        }

        DriverInfo.pConfigFile = BuildPathW(szDstDir, WOWFAXUI_DLL_NAME);
        szSrcPath = BuildPathW(szSysDir, WOWFAXUI_DLL_NAME);
        if (DriverInfo.pConfigFile) {
            if (szSrcPath) {
                CopyFile(szSrcPath, DriverInfo.pConfigFile, FALSE);
                LocalFree(szSrcPath);
            }
        }

        // Install the printer driver.
        DriverInfo.cVersion = 1;
        if (LoadString(ghInst, WOWFAX_NAME_STR, szName, WOWFAX_MAX_USER_MSG_LEN)) {
            DriverInfo.pName = szName;
            if (AddPrinterDriver(NULL, 2, (LPBYTE) &DriverInfo) == FALSE) {
                bRet = (GetLastError() == ERROR_PRINTER_DRIVER_ALREADY_INSTALLED);
            }
            else {
                bRet = TRUE;
            }
        }
        if (DriverInfo.pDataFile) {
            LocalFree(DriverInfo.pDataFile);
        }
        if (DriverInfo.pDriverPath) {
            LocalFree(DriverInfo.pDriverPath);
        }
        if (DriverInfo.pConfigFile) {
            LocalFree(DriverInfo.pConfigFile);
        }
    }
    else {
        LOGDEBUG(1, (L"WOWFAXUI!DoUpgradePrinter, No driver update\n"));
        bRet = TRUE;
    }

DoUpgradePrinterExit:
    if (szDstDir) {
         LocalFree(szDstDir);
    }
    if (szSysDir) {
         LocalFree(szSysDir);
    }
    if (pDriverInfo) {
         LocalFree(pDriverInfo);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfaxui\wowfaxui.c ===
//************************************************************************
// Generic Win 3.1 fax printer driver support. User Interface functions
// which are called by WINSPOOL.
//
// I don't think performance is a big issue here.      - nandurir
//
// History:
//    02-jan-95   nandurir   created.
//    01-feb-95   reedb      Clean-up, support printer install and bug fixes.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//
//************************************************************************

#define WOWFAX_INC_COMMON_CODE

#include "windows.h"
#include "wowfaxui.h"
#include "winspool.h"

#define DEF_DRV_DOCUMENT_EVENT_DBG_STR
#include "gdispool.h"
#include "winddiui.h"

//************************************************************************
// Globals
//************************************************************************

HINSTANCE ghInst;
FAXDEV gdev;
WORD   gdmDriverExtra = sizeof(DEVMODEW);

DEVMODEW gdmDefaultDevMode;

CRITICAL_SECTION CriticalSection;
LPCRITICAL_SECTION lpCriticalSection = &CriticalSection;

//************************************************************************
// DllInitProc
//************************************************************************

BOOL DllInitProc(HMODULE hModule, DWORD Reason, PCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
    }
    InitializeCriticalSection(lpCriticalSection);
    ghInst = (HINSTANCE) hModule;

    return(TRUE);
}

//************************************************************************
// PrinterProperties
//************************************************************************

BOOL PrinterProperties(HWND hwnd, HANDLE hPrinter)
{
    TCHAR szMsg[WOWFAX_MAX_USER_MSG_LEN];
    TCHAR szTitle[WOWFAX_MAX_USER_MSG_LEN];

    if (LoadString(ghInst, WOWFAX_NAME_STR, szTitle, WOWFAX_MAX_USER_MSG_LEN)) {
        if (LoadString(ghInst, WOWFAX_SELF_CONFIG_STR, szMsg, WOWFAX_MAX_USER_MSG_LEN)) {
            MessageBox(hwnd, szMsg, szTitle, MB_OK);
        }
    }
    return TRUE;
}

//************************************************************************
// SetupFaxDev - Do some common FaxDev setup: Calculate the size of the
//      mapped file section for use by the inter-process communication
//      handler. Create and set the mapped section. Get the 16-bit driver
//      info from the registry and copy it into the mapped section. Build
//      pointers for variable length stuff we copied to the mapped section.
//      Return zero on failure, or current offset into mapped section.
//************************************************************************

UINT SetupFaxDev(PWSTR pDeviceName, LPFAXDEV lpdev)
{
    LPREGFAXDRVINFO16 lpRegFaxDrvInfo16;
    DWORD iOffset = 0;

    // Get the driver and port names from the registry where they were written
    // by the 16-bit fax driver install program using WriteProfileString.
    if ((lpRegFaxDrvInfo16 = Get16BitDriverInfoFromRegistry(pDeviceName))) {

        //
        // Count dmDriverExtra twice, once for each devmode. Use cached
        // gdmDriverExtra value. Normally winspool/common dialogs and others,
        // call the DocumentProperties with fMode = 0 to get the size. So we
        // update gdmDriverExtra when such a call is made. We leave extra
        // room to DWORD align both In and Out pointers.
        //

        lpdev->cbMapLow =  sizeof(FAXDEV);
        lpdev->cbMapLow += sizeof(DEVMODE) * 2;
        lpdev->cbMapLow += gdmDriverExtra  * 2;
        lpdev->cbMapLow += sizeof(DWORD)   * 2;  // Leave room for DWORD align.
        lpdev->cbMapLow += (lstrlen(lpRegFaxDrvInfo16->lpDriverName) + 1) * sizeof(TCHAR);
        lpdev->cbMapLow += (lstrlen(lpRegFaxDrvInfo16->lpPortName) + 1) * sizeof(TCHAR);

        lpdev->idMap = GetCurrentThreadId();

        if (InterProcCommHandler(lpdev, DRVFAX_CREATEMAP)) {
            if (InterProcCommHandler(lpdev, DRVFAX_SETMAPDATA)) {

                // Copy the printer/device name to the WOWFAXINFO struct.
                lstrcpy(lpdev->lpMap->szDeviceName,
                        lpRegFaxDrvInfo16->lpDeviceName);

                // Calculate the pointers into the mapped file section and copy
                // the variable length data to the mapped file section.

                // Printer driver and port names.
                iOffset = sizeof(*lpdev->lpMap);
                lpdev->lpMap->lpDriverName = (LPTSTR) iOffset;
                (PWSTR)iOffset += lstrlen(lpRegFaxDrvInfo16->lpDriverName) + 1;
                lstrcpy((PWSTR)((LPBYTE)lpdev->lpMap + (DWORD)lpdev->lpMap->lpDriverName), lpRegFaxDrvInfo16->lpDriverName);
                lpdev->lpMap->lpPortName = (LPTSTR) iOffset;
                (PWSTR)iOffset += lstrlen(lpRegFaxDrvInfo16->lpPortName) + 1;
                lstrcpy((PWSTR)((LPBYTE)lpdev->lpMap + (DWORD)lpdev->lpMap->lpPortName), lpRegFaxDrvInfo16->lpPortName);
            }
        }
        Free16BitDriverInfo(lpRegFaxDrvInfo16);
    }
    return iOffset;
}

//************************************************************************
// DrvDocumentProperties
//************************************************************************

LONG DrvDocumentProperties(HWND hwnd, HANDLE hPrinter, PWSTR pDeviceName,
                               PDEVMODE pdmOut, PDEVMODE pdmIn, DWORD fMode)
{
    FAXDEV dev = gdev;
    LPFAXDEV lpdev = &dev;
    LONG    lRet = -1;
    DWORD   iOffset;
    DWORD   cbT;
    DWORD   dwWowProcID, dwCallerProcID;
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;

    LOGDEBUG(1, (L"WOWFAXUI!DrvDocumentProperties, pdmOut: %X, pdmIn: %X, fMode: %X\n", pdmOut, pdmIn, fMode));

    // Check for get default devmode case, use spooler to get it if possible.
    if (!pdmIn && pdmOut && !(fMode & DM_IN_PROMPT)) {
        if (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) {
            if (pPrinterInfo2->pDevMode) {
                LOGDEBUG(1, (L"  Using spooler default devmode\n"));
                cbT = pPrinterInfo2->pDevMode->dmSize +
                        pPrinterInfo2->pDevMode->dmDriverExtra;

                memcpy(pdmOut, pPrinterInfo2->pDevMode, cbT);
                lRet = IDOK;
                goto LeaveDDP;
            }
        }
    }

    if (iOffset = SetupFaxDev(pDeviceName, lpdev)) {
        lpdev->lpMap->msg = WM_DDRV_EXTDMODE;

        // Calculate the pointers into the mapped file section and copy
        // the variable length data to the mapped file section.
        DRVFAX_DWORDALIGN(iOffset);
        lpdev->lpMap->lpIn = (LPDEVMODEW)((pdmIn) ? iOffset : 0);
        iOffset += sizeof(*pdmIn) + gdmDriverExtra;

        DRVFAX_DWORDALIGN(iOffset);
        lpdev->lpMap->lpOut = (LPDEVMODEW)((pdmOut) ? iOffset : 0);
        iOffset += sizeof(*pdmOut) + gdmDriverExtra;

        //
        // if Input is non-null copy the data even if fMode doesn't
        // have the appropriate flag.
        //

        if (pdmIn) {
            // apps don't pass DM_MODIFY even if they mean it - ie
            // pdmIn will be non-null but they won't or this flag.
            // The 32bit rasdd extracts data from pdmIn even if the
            // DM_MODIFY flag is not set. So we need to do the same

            if (fMode != 0) {
                fMode |= DM_IN_BUFFER;
            }

            iOffset = (DWORD)lpdev->lpMap + (DWORD)lpdev->lpMap->lpIn;
            RtlCopyMemory((LPVOID)iOffset, pdmIn,
               sizeof(*pdmIn) + min(gdmDriverExtra, pdmIn->dmDriverExtra));

            // reset dmDriverExtra in pdmIn.
            ((LPDEVMODE)iOffset)->dmDriverExtra =
                                 min(gdmDriverExtra, pdmIn->dmDriverExtra);
        }

        if (!(fMode & (DM_COPY | DM_OUT_BUFFER))) {
            lpdev->lpMap->lpOut = 0;
        }

        lpdev->lpMap->wCmd = (WORD)fMode;

        // valid size of this map
        lpdev->lpMap->cData = lpdev->cbMapLow;


        lpdev->lpMap->hwndui = hwnd;
        if (fMode & DM_IN_PROMPT) {
            GetWindowThreadProcessId(hwnd, &dwCallerProcID);
            GetWindowThreadProcessId(lpdev->lpMap->hwnd, &dwWowProcID);

            if (dwWowProcID == dwCallerProcID) {

                // If the calling process is the same as the 'wowfaxclass' window
                // (WOW/WOWEXEC) use CallWindow instead of SendMessage so we don't
                // deadlock WOW when trying to put up the 16-bit fax driver UI.

                InterProcCommHandler(lpdev, DRVFAX_CALLWOW);
            }
            else {
                InterProcCommHandler(lpdev, DRVFAX_SENDNOTIFYWOW);
            }
        }
        else {
            InterProcCommHandler(lpdev, DRVFAX_SENDTOWOW);
        }

        lRet = (lpdev->lpMap->status) ? (LONG)lpdev->lpMap->retvalue : lRet;
        if (lRet > 0) {
            if ((fMode & DM_OUT_BUFFER) && (lRet == IDOK) && pdmOut) {
                iOffset = (DWORD)lpdev->lpMap + (DWORD)lpdev->lpMap->lpOut;
                RtlCopyMemory(pdmOut, (LPDEVMODE)iOffset,
                               sizeof(*pdmOut)+ ((LPDEVMODE)iOffset)->dmDriverExtra);

                // LATER : what about the formname etc. fields - new on NT
            }
            else if (fMode == 0) {
                // update our dmDriverExtra
                gdmDriverExtra = (WORD)max(lRet, gdmDriverExtra);
            }
        }
        else {
            LOGDEBUG(0, (L"WOWFAXUI!DrvDocumentProperties failed, lpdev->lpMap->status: %X, lpdev->lpMap->retvalue: %X\n", lpdev->lpMap->status, (LONG)lpdev->lpMap->retvalue));
        }
        InterProcCommHandler(lpdev, DRVFAX_DESTROYMAP);
    }

LeaveDDP:
    if (pPrinterInfo2) {
        LocalFree(pPrinterInfo2);
    }

    LOGDEBUG(1, (L"WOWFAXUI!DrvDocumentProperties returning: %X, pdmOut: %X, pdmIn: %X\n", lRet, pdmOut, pdmIn));

    return(lRet);
}

//************************************************************************
// DrvAdvancedDocumentProperties
//************************************************************************

LONG DrvAdvancedDocumentProperties(HWND hwnd, HANDLE hPrinter, PWSTR pDeviceName,
                               PDEVMODE pdmOut, PDEVMODE pdmIn)
{
   // for 16bit drivers this is a NOP.

   return 0;
}

//************************************************************************
// DevQueryPrintEx
//************************************************************************

BOOL DevQueryPrintEx(PDEVQUERYPRINT_INFO pDQPInfo)
{
    return TRUE;
}

//************************************************************************
// DrvDeviceCapabilities
//************************************************************************

DWORD DrvDeviceCapabilities(HANDLE hPrinter, PWSTR pDeviceName,
                               WORD iDevCap, VOID *pOut, PDEVMODE pdmIn)
{
    FAXDEV   dev = gdev;
    LPFAXDEV lpdev = &dev;
    LONG     lRet = -1;
    DWORD    iOffset;
    LPBYTE   lpSrc;

    LOGDEBUG(1, (L"WOWFAXUI!DrvDeviceCapabilities, iDevCap: %X, pdmIn: %X\n", iDevCap, pdmIn));

    if (iDevCap == DC_SIZE) {
        return sizeof(DEVMODEW);
    }

    if (iOffset = SetupFaxDev(pDeviceName, lpdev)) {
        lpdev->lpMap->msg = WM_DDRV_DEVCAPS;

        // Calculate the pointers into the mapped file section and copy
        // the variable length data to the mapped file section.

        lpdev->lpMap->lpIn = (LPDEVMODEW)((pdmIn) ? iOffset : 0);
        iOffset += sizeof(*pdmIn) + gdmDriverExtra;

        // output in lpout: make this the last pointer in the
        // data so that we can use the rest of the mapped area for copy
        // on output.

        lpdev->lpMap->lpOut = (LPDEVMODEW)((pOut) ? iOffset : 0);
        iOffset += sizeof(*pdmIn) + gdmDriverExtra;


        if (pdmIn) {
            iOffset = (DWORD)lpdev->lpMap + (DWORD)lpdev->lpMap->lpIn;
            RtlCopyMemory((LPVOID)iOffset, pdmIn,
               sizeof(*pdmIn) + min(gdmDriverExtra, pdmIn->dmDriverExtra));

            // reset dmDriverExtra in pdmIn.
            ((LPDEVMODE)iOffset)->dmDriverExtra =
                                 min(gdmDriverExtra, pdmIn->dmDriverExtra);
        }

        lpdev->lpMap->wCmd = iDevCap;
        // valid size of this map
        lpdev->lpMap->cData = lpdev->cbMapLow;

        InterProcCommHandler(lpdev, DRVFAX_SENDTOWOW);
        lRet = (lpdev->lpMap->status) ? (LONG)lpdev->lpMap->retvalue : lRet;

        // on return cData is the number of bytes to copy

        if (lpdev->lpMap->lpOut && lpdev->lpMap->cData && lpdev->lpMap->retvalue) {
            lpSrc = (LPBYTE)lpdev->lpMap + (DWORD)lpdev->lpMap->lpOut;
            switch (lpdev->lpMap->wCmd) {
                case DC_PAPERSIZE:
                case DC_MINEXTENT:
                case DC_MAXEXTENT:
                    ((LPPOINT)pOut)->x = ((LPPOINTS)lpSrc)->x;
                    ((LPPOINT)pOut)->y = ((LPPOINTS)lpSrc)->y;
                    break;

                default:
                    RtlCopyMemory(pOut, lpSrc, lpdev->lpMap->cData);
                    break;
            }
        }
        InterProcCommHandler(lpdev, DRVFAX_DESTROYMAP);
    }

    if (lRet < 0) {
        LOGDEBUG(0, (L"WOWFAXUI!DrvDeviceCapabilities Failing\n"));
    }

    LOGDEBUG(1, (L"WOWFAXUI!DrvDeviceCapabilities, returning  pOut: %X\n", pOut));

    return(lRet);
}

//************************************************************************
// DrvUpgradePrinter - Called in the system context by the spooler.
//      Drivers will really only be updated the first time the spooler is
//      started after an upgrade. Calls DoUpgradePrinter to do the work.
//************************************************************************

BOOL DrvUpgradePrinter(DWORD dwLevel, LPBYTE lpDrvUpgradeInfo)
{
    static BOOL bDrvUpgradePrinterLock = FALSE;
    BOOL  bRet;

    LOGDEBUG(1, (L"WOWFAXUI!DrvUpgradePrinter, dwLevel: %X, lpDrvUpgradeInfo: %X\n", dwLevel, lpDrvUpgradeInfo));

    // DrvUpgradePrinter is called during AddPrinterDriver. Don't allow
    // recursion. Protect lock from other threads.
    EnterCriticalSection(lpCriticalSection);
    if (bDrvUpgradePrinterLock) {
        LeaveCriticalSection(lpCriticalSection);
        return(TRUE);
    }

    bDrvUpgradePrinterLock = TRUE;
    LeaveCriticalSection(lpCriticalSection);

    bRet = DoUpgradePrinter(dwLevel, (LPDRIVER_UPGRADE_INFO_1W)lpDrvUpgradeInfo);

    EnterCriticalSection(lpCriticalSection);
    bDrvUpgradePrinterLock = FALSE;
    LeaveCriticalSection(lpCriticalSection);

    return(bRet);
}

//************************************************************************
// DrvDocumentEvent - This exported function is used to hook the GDI
//      Display Driver functions. It unpacks and validates the parameters,
//      then dispatches to the appropriate handler, based on the passed
//      iEsc value. The following table provides a mapping of the
//      DrvDocumentEvent escapes to the server side display driver
//      callbacks, and gives the call time relative to the callback:
//
//      DOCUMENTEVENT_CREATEDCPRE       DrvEnablePDEV, before
//      DOCUMENTEVENT_CREATEDCPOST      DrvEnablePDEV, after
//      DOCUMENTEVENT_RESETDCPRE        DrvRestartPDEV, before
//      DOCUMENTEVENT_RESETDCPOST       DrvRestartPDEV, after
//      DOCUMENTEVENT_STARTDOC          DrvStartDoc, before
//      DOCUMENTEVENT_STARTPAGE         DrvStartPage, before
//      DOCUMENTEVENT_ENDPAGE           DrvSendPage, before
//      DOCUMENTEVENT_ENDDOC            DrvEndDoc, before
//      DOCUMENTEVENT_ABORTDOC          DrvEndDoc, before
//      DOCUMENTEVENT_DELETEDC          DrvDisablePDEV, before
//
//************************************************************************

int DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    int     iEsc,
    ULONG   cbIn,
    PULONG  pjIn,
    ULONG   cbOut,
    PULONG  pjOut
)
{
    int   iRet = DOCUMENTEVENT_FAILURE;

    if (iEsc < DOCUMENTEVENT_LAST) {
        LOGDEBUG(1, (L"WOWFAXUI!DrvDocumentEvent, iEsc: %s, hdc: %X\n", szDrvDocumentEventDbgStrings[iEsc], hdc));
    }

    // Validate HDC for some of the escapes.
    if ((iEsc >= DOCUMENTEVENT_HDCFIRST) && (iEsc < DOCUMENTEVENT_HDCLAST)) {
        if (hdc == NULL) {
            LOGDEBUG(0, (L"WOWFAXUI!DrvDocumentEvent NULL HDC for escape: %X\n", iEsc));
            return(iRet);
        }
    }

    switch (iEsc)
    {
        case DOCUMENTEVENT_CREATEDCPRE:
            iRet = DocEvntCreateDCpre((LPWSTR)*(pjIn+1),
                                       (DEVMODEW*)*(pjIn+2),
                                       (DEVMODEW**)pjOut);
            break;

        case DOCUMENTEVENT_CREATEDCPOST:
            iRet = DocEvntCreateDCpost(hdc, (DEVMODEW*)*pjIn);
            break;

        case DOCUMENTEVENT_RESETDCPRE:
            iRet = DocEvntResetDCpre(hdc, (DEVMODEW*)*(pjIn),
                                       (DEVMODEW**)pjOut);
            break;

        case DOCUMENTEVENT_RESETDCPOST:
            iRet = DocEvntResetDCpost(hdc, (DEVMODEW*)*pjIn);
            break;

        case DOCUMENTEVENT_STARTDOC:
            // WowFax (EasyFax Ver2.0) support.
            // Also Procomm+ 3 cover sheets.  Bug #305665
            iRet = DocEvntStartDoc(hdc, (DOCINFOW*)*pjIn);
            break;

        case DOCUMENTEVENT_DELETEDC:
            iRet = DocEvntDeleteDC(hdc);
            break;

        case DOCUMENTEVENT_ENDDOC:
            iRet = DocEvntEndDoc(hdc);
            break;

        case DOCUMENTEVENT_ENDPAGE:
            iRet = DocEvntEndPage(hdc);
            break;

        // The following require no client side processing:
        case DOCUMENTEVENT_ESCAPE:
        case DOCUMENTEVENT_ABORTDOC:
        case DOCUMENTEVENT_STARTPAGE:
            // No Client side processing needed.
            goto docevnt_unsupported;

        default :
            LOGDEBUG(0, (L"WOWFAXUI!DrvDocumentEvent unknown escape: %X\n", iEsc));
docevnt_unsupported:
            iRet = DOCUMENTEVENT_UNSUPPORTED;

    } // switch

    LOGDEBUG(1, (L"WOWFAXUI!DrvDocumentEvent return: %X\n", iRet));
    return(iRet);

}

//***************************************************************************
// DocEvntCreateDCpre - Allocate a DEVMODE which contains a FAXDEV as the
//      dmDriverExtra portion. This DEVMODE will be passed to the
//      DrvEnablePDEV function on the server side.
//***************************************************************************

int DocEvntCreateDCpre(
    LPWSTR      lpszDevice,
    DEVMODEW    *pDevModIn,
    DEVMODEW    **pDevModOut
)
{
    DWORD       iOffset = 0;
    LPFAXDEV    lpFaxDev;
    PGDIINFO    pGdiInfo;
    DEVMODEW    *pTmpDevMode;

    LPREGFAXDRVINFO16 lpRegFaxDrvInfo16;

    int iRet = DOCUMENTEVENT_FAILURE;

    if ((lpszDevice == NULL)  || (pDevModOut == NULL)) {
        LOGDEBUG(0, (L"WOWFAXUI!DocEvntCreateDCpre, failed, NULL parameters\n"));
        goto DocEvntCreateDCpreFailed;
    }

    LOGDEBUG(1, (L"WOWFAXUI!DocEvntCreateDCpre, Device: %s, pDevModIn: %X pDevModOut: %X\n", lpszDevice, pDevModIn, pDevModOut));

    // Use our global default devmode if a NULL devmode is passed in from the app.
    if (pDevModIn == NULL) {
        gdmDefaultDevMode.dmSize = sizeof(DEVMODEW);
        pDevModIn = &gdmDefaultDevMode;
    }

    pTmpDevMode = (DEVMODEW*)WFLOCALALLOC(sizeof(FAXDEV) + sizeof(DEVMODEW),
                                         L"DocEvntCreateDCpre");

    LOGDEBUG(2, (L"WOWFAXUI!DocEvntCreateDCpre,  pTmpDevMode: %X\n", pTmpDevMode));

    if (pTmpDevMode == NULL) {
        goto DocEvntCreateDCpreFailed;
    }

    // Copy pDevModIn to the new DEVMODE.
    RtlCopyMemory(pTmpDevMode, pDevModIn, sizeof(*pTmpDevMode));
    pTmpDevMode->dmDriverExtra = sizeof(FAXDEV);
    pTmpDevMode->dmSize = sizeof(DEVMODEW);

    // Setup some handy pointers.
    lpFaxDev = (LPFAXDEV) (pTmpDevMode + 1);
    pGdiInfo = &(lpFaxDev->gdiinfo);

    lpFaxDev->id =  FAXDEV_ID;

    // Save a client side pointer to the new DEVMODE and it's embeded FAXDEV.
    // We'll use ExtEscape to get these pointers back any time we need to
    // associate driver context with an HDC.

    lpFaxDev->pdevmode = pTmpDevMode;
    lpFaxDev->lpClient = lpFaxDev;

    // Get the driver and port names from the registry where they were written
    // by the 16-bit fax driver install program using WriteProfileString.

    if ((lpRegFaxDrvInfo16 = Get16BitDriverInfoFromRegistry(lpszDevice)) == NULL) {
        goto DocEvntCreateDCpreFailed;
    }

    if ((lpFaxDev->hwnd = FindWowFaxWindow()) == NULL) {
        goto DocEvntCreateDCpreFailed;
    }
    lpFaxDev->tid   = GetWindowThreadProcessId(lpFaxDev->hwnd, 0);
    lpFaxDev->idMap = (DWORD)lpFaxDev;

    // Calculate the size of the mapped file section for inter process communication.
    lpFaxDev->cbMapLow = sizeof(DWORD) +          // leave room for DWORD align
                            sizeof(*lpFaxDev->lpMap) +
                            sizeof(GDIINFO) +
                            (lstrlen(lpRegFaxDrvInfo16->lpDriverName) + 1) * sizeof(TCHAR) +
                            (lstrlen(lpRegFaxDrvInfo16->lpPortName) + 1) * sizeof(TCHAR) +
                            sizeof(*pDevModIn) +
                            ((pDevModIn) ? pDevModIn->dmDriverExtra : 0);
    DRVFAX_DWORDALIGN(lpFaxDev->cbMapLow);

    InterProcCommHandler(lpFaxDev, DRVFAX_CREATEMAP);

    if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
        lpFaxDev->lpMap->msg = WM_DDRV_ENABLE;

        // Copy the printer/device name to the WOWFAXINFO struct.
        lstrcpy(lpFaxDev->lpMap->szDeviceName, lpszDevice);

        // Calculate the pointers into the mapped file section and copy
        // the variable length data to the mapped file section.

        // output :  gdiinfo

        lpFaxDev->lpMap->lpOut = (LPDEVMODE)(sizeof(*lpFaxDev->lpMap));
        iOffset = sizeof(*lpFaxDev->lpMap) + sizeof(GDIINFO);

        // Device (printer) and port names.

        lpFaxDev->lpMap->lpDriverName = (LPSTR) iOffset;
        (PWSTR)iOffset += lstrlen(lpRegFaxDrvInfo16->lpDriverName) + 1;
        lstrcpy((PWSTR)((LPBYTE)lpFaxDev->lpMap + (DWORD)lpFaxDev->lpMap->lpDriverName), lpRegFaxDrvInfo16->lpDriverName);
        lpFaxDev->lpMap->lpPortName = (LPVOID) iOffset;
        (PWSTR)iOffset += lstrlen(lpRegFaxDrvInfo16->lpPortName) + 1;
        lstrcpy((PWSTR)((LPBYTE)lpFaxDev->lpMap + (DWORD)lpFaxDev->lpMap->lpPortName), lpRegFaxDrvInfo16->lpPortName);

        // input:  devmode

        DRVFAX_DWORDALIGN(iOffset);
        lpFaxDev->lpMap->lpIn = (LPDEVMODE)((pDevModIn) ? iOffset : 0);
        iOffset += ((pDevModIn) ? sizeof(*pDevModIn) + pDevModIn->dmDriverExtra : 0);

        if (pDevModIn) {
            RtlCopyMemory((LPBYTE)lpFaxDev->lpMap + (DWORD)lpFaxDev->lpMap->lpIn,
                            pDevModIn, sizeof(*pDevModIn) + pDevModIn->dmDriverExtra);
        }

        // set the total byte count of data.

        lpFaxDev->lpMap->cData = iOffset;

        // all done - switch to wow
        InterProcCommHandler(lpFaxDev, DRVFAX_SENDTOWOW);
        // values returned from wow.
        lpFaxDev->lpinfo16 = (DWORD)lpFaxDev->lpMap->lpinfo16;
        iRet = lpFaxDev->lpMap->status && lpFaxDev->lpMap->retvalue;
        if (iRet) {
            // Copy GDIINFO from WOW to the client side FAXDEV.
            RtlCopyMemory(pGdiInfo,
                          (LPBYTE)lpFaxDev->lpMap + (DWORD)lpFaxDev->lpMap->lpOut,
                          sizeof(GDIINFO));

            // Fill in some misc. fields in the client FAXDEV.
            pGdiInfo->ulHTPatternSize = HT_PATSIZE_DEFAULT;
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_1BPP;

            lpFaxDev->bmWidthBytes = pGdiInfo->szlPhysSize.cx / 0x8;
            DRVFAX_DWORDALIGN(lpFaxDev->bmWidthBytes);

            lpFaxDev->bmFormat = BMF_1BPP;
            lpFaxDev->cPixPerByte = 0x8;

            // Here if success, make pDevModOut point to the new DEVMODE.
            *pDevModOut = pTmpDevMode;

        }
        else {
            LOGDEBUG(0, (L"WOWFAXUI!DocEvntCreateDCpre, WOW returned error\n"));
        }
    }

    if (iRet) {
        goto DocEvntCreateDCpreSuccess;
    }
    else {
        iRet = DOCUMENTEVENT_FAILURE;
    }

DocEvntCreateDCpreFailed:
    LOGDEBUG(0, (L"WOWFAXUI!DocEvntCreateDCpre, failed!\n"));

DocEvntCreateDCpreSuccess:
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntCreateDCpre, iRet: %X\n", iRet));
    Free16BitDriverInfo(lpRegFaxDrvInfo16);
    return(iRet);
}

//***************************************************************************
// DocEvntResetDCpre -
//***************************************************************************

int DocEvntResetDCpre(
    HDC         hdc,
    DEVMODEW    *pDevModIn,
    DEVMODEW    **pDevModOut
)
{
    return(DOCUMENTEVENT_FAILURE);
}

//***************************************************************************
// DocEvntResetDCpost -
//***************************************************************************

int DocEvntResetDCpost(
    HDC         hdc,
    DEVMODEW    *pDevModIn
)
{
    return(DOCUMENTEVENT_SUCCESS);
}

//***************************************************************************
// DocEvntCreateDCpost -
//***************************************************************************

int DocEvntCreateDCpost(
    HDC         hdc,
    DEVMODEW    *pDevModIn
)
{
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntCreateDCpost, hdc: %X, pDevModIn: %X\n", hdc, pDevModIn));

    // hdc was zero indicates DrvEnablePDEV failed. Cleanup.
    if (hdc == NULL) {
        if (pDevModIn) {
            LocalFree(pDevModIn);
            LOGDEBUG(1, (L"WOWFAXUI!DocEvntCreateDCpost, Cleaning up\n"));
        }
    }
    return(DOCUMENTEVENT_SUCCESS);
}

//***************************************************************************
// DocEvntStartDoc - hdc was validated by DrvDocumentEvent.
//***************************************************************************

int DocEvntStartDoc(
HDC       hdc,
DOCINFOW *pDocInfoW
)
{
    LPFAXDEV lpFaxDev = 0;
    HBITMAP  hbm = 0;
    DWORD    cbOld;
    int      iRet = 0;

    lpFaxDev = (LPFAXDEV)ExtEscape(hdc, DRV_ESC_GET_FAXDEV_PTR, 0, NULL, 0, NULL);
    if (ValidateFaxDev(lpFaxDev)) {
        if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
            lpFaxDev->lpMap->msg = WM_DDRV_STARTDOC;

            // WowFax (EasyFax Ver2.0) support.
            // Also Procomm+ 3 cover sheets.  Bug #305665.
            if (pDocInfoW && pDocInfoW->lpszDocName)
                lstrcpyW(lpFaxDev->lpMap->szDocName,pDocInfoW->lpszDocName);
            else
                lstrcpyW(lpFaxDev->lpMap->szDocName,L"");

            InterProcCommHandler(lpFaxDev, DRVFAX_SENDNOTIFYWOW);

            iRet = ((LONG)lpFaxDev->lpMap->retvalue > 0);

            // Calculate new mapsize - the bitmap bits will be written into
            // this map with a call to ExtEscape - thus allowing easy access
            // to the bits from WOW.

            cbOld = lpFaxDev->cbMapLow;
            lpFaxDev->cbMapLow += lpFaxDev->bmWidthBytes *
                                    lpFaxDev->gdiinfo.szlPhysSize.cy;
            if (InterProcCommHandler(lpFaxDev, DRVFAX_CREATEMAP)) {
                lpFaxDev->offbits = cbOld;
                goto DocEvntStartDocSuccess;
            }
        }
    }
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntStartDoc, failed\n"));

DocEvntStartDocSuccess:
    if (iRet == 0) {
        iRet = DOCUMENTEVENT_FAILURE;
    }
    return iRet;
}

//***************************************************************************
// DocEvntDeleteDC - hdc was validated by DrvDocumentEvent.
//***************************************************************************

int DocEvntDeleteDC(
    HDC hdc
)
{
    LPFAXDEV lpFaxDev;
    DEVMODEW *lpDevMode;

    int      iRet = DOCUMENTEVENT_FAILURE;

    lpFaxDev = (LPFAXDEV)ExtEscape(hdc, DRV_ESC_GET_FAXDEV_PTR, 0, NULL, 0, NULL);
    if (ValidateFaxDev(lpFaxDev)) {
        // Validate 16-bit FaxWndProc window handle before sending a message.
        if (lpFaxDev->tid == GetWindowThreadProcessId(lpFaxDev->hwnd, 0)) {
            if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
                lpFaxDev->lpMap->msg = WM_DDRV_DISABLE;
                InterProcCommHandler(lpFaxDev, DRVFAX_SENDTOWOW);
            }
        }
        else {
            LOGDEBUG(0, (L"WOWFAXUI!DocEvntDeleteDC, unable to validate FaxWndProc\n"));
        }

        InterProcCommHandler(lpFaxDev, DRVFAX_DESTROYMAP);
    }
    else {
        LOGDEBUG(0, (L"WOWFAXUI!DocEvntDeleteDC, unable to get lpFaxDev\n"));
    }

    lpDevMode = (DEVMODEW*)ExtEscape(hdc, DRV_ESC_GET_DEVMODE_PTR, 0, NULL, 0, NULL);
    if (lpDevMode) {
        LocalFree(lpDevMode);
        iRet = DOCUMENTEVENT_SUCCESS;
    }
    else {
        LOGDEBUG(0, (L"WOWFAXUI!DocEvntDeleteDC, unable to get lpDevMode\n"));
    }

    return iRet;
}

//***************************************************************************
// DocEvntEndDoc - hdc was validated by DrvDocumentEvent.
//***************************************************************************

int DocEvntEndDoc(
HDC hdc
)
{
    LPFAXDEV lpFaxDev;
    DEVMODEW *lpDevMode;

    int      iRet = DOCUMENTEVENT_FAILURE;

    lpFaxDev = (LPFAXDEV)ExtEscape(hdc, DRV_ESC_GET_FAXDEV_PTR, 0, NULL, 0, NULL);
    if (ValidateFaxDev(lpFaxDev)) {
        if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
            lpFaxDev->lpMap->msg = WM_DDRV_ENDDOC;
            InterProcCommHandler(lpFaxDev, DRVFAX_SENDTOWOW);
            iRet = lpFaxDev->lpMap->status && ((LONG)lpFaxDev->lpMap->retvalue > 0);
            goto DocEvntEndDocSuccess;
        }
    }
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntEndDoc, failed\n"));

DocEvntEndDocSuccess:
    if (iRet == 0) {
        iRet = DOCUMENTEVENT_FAILURE;
    }
    return  iRet;
}

//***************************************************************************
// DocEvntEndPage - hdc was validated by DrvDocumentEvent.
//***************************************************************************

int DocEvntEndPage(
    HDC hdc
)
{
    LPFAXDEV lpFaxDev;
    LONG     lDelta;
    ULONG    cjBits;
    int      iRet = DOCUMENTEVENT_FAILURE;

    lpFaxDev = (LPFAXDEV)ExtEscape(hdc, DRV_ESC_GET_FAXDEV_PTR, 0, NULL, 0, NULL);
    if (ValidateFaxDev(lpFaxDev)) {
        if (InterProcCommHandler(lpFaxDev, DRVFAX_SETMAPDATA)) {
            lpFaxDev->lpMap->msg = WM_DDRV_PRINTPAGE;

            // Get Surface info, cjBits and lDelta.
            cjBits = ExtEscape(hdc, DRV_ESC_GET_SURF_INFO, 0, NULL,
                                4, (PVOID)&lDelta);
            if (cjBits) {
                lpFaxDev->lpMap->bmWidthBytes = lDelta;
                lpFaxDev->lpMap->bmHeight = cjBits / lDelta;
                lpFaxDev->lpMap->bmPixPerByte = lpFaxDev->cPixPerByte;
                (DWORD)lpFaxDev->lpMap->lpbits = lpFaxDev->offbits;
                if (ExtEscape(hdc, DRV_ESC_GET_BITMAP_BITS, 0, NULL, cjBits,
                                (LPBYTE)lpFaxDev->lpMap + lpFaxDev->offbits)) {
                    InterProcCommHandler(lpFaxDev, DRVFAX_SENDTOWOW);
                    iRet = lpFaxDev->lpMap->status &&
                            ((LONG)lpFaxDev->lpMap->retvalue > 0);
                }
                goto DocEvntEndPageSuccess;
            }
        }
    }
    LOGDEBUG(1, (L"WOWFAXUI!DocEvntEndPage, failed\n"));

DocEvntEndPageSuccess:
    if (iRet == 0) {
        iRet = DOCUMENTEVENT_FAILURE;
    }
    return  iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\fax\wowfaxui\wowfaxui.h ===
//****************************************************************************
// Generic Win 3.1 fax printer driver support
//
//    02-jan-95   nandurir   created.
//    14-mar-95   reedb      Use GDI hooks to move most functionality to UI.
//    16-aug-95   reedb      Move to kernel mode. Many declarations and
//                              definitions moved from FAXCOMM.H to this file.
//
//****************************************************************************

#include "stddef.h"
#include "windows.h"
#include "winddi.h"

#include "faxcomm.h"
#include "winspool.h"

// The following include is to pickup the definitions for
// the DrvUpgradePrinter private API. These definitions should be in public.

#include <splapip.h>

// WOWFAX component file names.
#define WOWFAX_DLL_NAME L"WOWFAX.DLL"
#define WOWFAXUI_DLL_NAME L"WOWFAXUI.DLL"

// String table constants:
#define WOWFAX_MAX_USER_MSG_LEN 256
 
#define WOWFAX_UNKNOWN_PROB_STR  0x100
#define WOWFAX_NAME_STR          0x101
#define WOWFAX_NOWOW_STR         0x102
#define WOWFAX_SELF_CONFIG_STR   0x103
#define WOWFAX_ENABLE_CONFIG_STR 0x104

// Dialog constants:
#define IDD_NULLPROP            0x200
#define IDD_DOCPROP             0x201

// Text control constants:
#define IDC_STATIC                 -1
#define IDC_FEEDBACK            0x300

// InterProcCommHandler command constants
#define DRVFAX_SETMAPDATA    0x1
#define DRVFAX_SENDTOWOW     0x2
#define DRVFAX_SENDNOTIFYWOW 0x3
#define DRVFAX_CREATEMAP     0x4
#define DRVFAX_DESTROYMAP    0x5
#define DRVFAX_CALLWOW       0x6

// Logging macros
/* XLATOFF */
// #define IFLOG(l)    if (l==iFaxLogLevel && (iFaxLogLevel&1) || l<=iFaxLogLevel && !(iFaxLogLevel&1) || l == 0)

#undef  LOG
#ifdef  NOLOG
#define LOG(l,args)
#define SETREQLOG(l)
#else
#define SETREQLOG(l) iReqFaxLogLevel = l
#define LOG(l,args)  {SETREQLOG(l) ; faxlogprintf args;}
#endif

#if  DBG
extern INT iReqFaxLogLevel;
#define LOGDEBUG(l,args) LOG(l,args)
#else
#define LOGDEBUG(l,args)
#endif
/* XLATON */


//
// This structure is used to hold 16-bit fax driver data  stored
// in the registry.
//

typedef  struct _REGFAXDRVINFO16 {
    LPTSTR lpDeviceName;
    LPTSTR lpDriverName;
    LPTSTR lpPortName;
} REGFAXDRVINFO16, *LPREGFAXDRVINFO16;

// The the escapes in the following escape range all need a valid HDC.
// Range is inclusive lower, exclusive upper bound. See GDISPOOL.H for
// the actual escape definitions.

#define DOCUMENTEVENT_HDCFIRST      5
#define DOCUMENTEVENT_HDCLAST      11

// Prototypes for public functions implemented in WFSHEETS.C:
PVOID MyGetPrinter(HANDLE hPrinter, DWORD level);

// Prototypes for public functions implemented in WFUPGRAD.C:

BOOL DoUpgradePrinter(DWORD dwLevel, LPDRIVER_UPGRADE_INFO_1W lpDrvUpgradeInfo);

// Prototypes for public functions implemented in WFHELPERS.C:

LPREGFAXDRVINFO16 Get16BitDriverInfoFromRegistry(PWSTR pDeviceName);

VOID   faxlogprintf(LPTSTR pszFmt, ...);
VOID   LogFaxDev(LPTSTR pszTitle, LPFAXDEV lpFaxDev);
VOID   LogWowFaxInfo(LPWOWFAXINFO lpWowFaxInfo);
BOOL   ValidateFaxDev(LPFAXDEV lpFaxDev);
VOID   Free16BitDriverInfo(LPREGFAXDRVINFO16 lpRegFaxDrvInfo16);
BOOL   FaxMapHandler(LPFAXDEV lpdev, UINT iAction);
BOOL   InterProcCommHandler(LPFAXDEV lpdev, UINT iAction);
LPVOID WFHeapAlloc(DWORD dwBytes, LPWSTR lpszWhoCalled);
LPVOID WFLocalAlloc(DWORD dwBytes, LPWSTR lpszWhoCalled);
HWND   FindWowFaxWindow(void);
LPTSTR DupTokenW(LPTSTR lpTok);

// Prototypes for functions which DrvDocumentEvent dispatches,
// implemented in WOWFAXUI.C:

int DocEvntCreateDCpre(
    LPWSTR      lpszDevice,
    DEVMODEW    *pDevModIn,
    DEVMODEW    **pDevModOut
);

int DocEvntResetDCpre(
    HDC         hdc,
    DEVMODEW    *pDevModIn,
    DEVMODEW    **pDevModOut
);

int DocEvntCreateDCpost(
    HDC         hdc,
    DEVMODEW    *pDevModIn
);

int DocEvntResetDCpost(
    HDC         hdc,
    DEVMODEW    *pDevModIn
);

int DocEvntStartDoc(
    HDC      hdc,
    DOCINFOW *pDocInfoW
);

int DocEvntDeleteDC(
    HDC hdc
);

int DocEvntEndPage(
    HDC hdc
);

int DocEvntEndDoc(
HDC hdc
);

//
// Memory allocation macro.
//

#if  DBG
#define WFLOCALALLOC(dwBytes, lpszWhoCalled) WFLocalAlloc(dwBytes, lpszWhoCalled)
#else
#define WFLOCALALLOC(dwBytes, lpszWhoCalled) LocalAlloc(LPTR, dwBytes)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\apistruc.h ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1990               **/
/*****************************************************************/
/***    apistruc.h
 *
 *      This file contains the structure definitions used to pass parameters
 *      to the loadable APIs in the REDIR 1.5 project
 *
 *      CONTENTS        tr_packet
 *                      NetWkstaSetUIDStruc
 *                      NetWkstaLogonStruc
 *                      NetWkstaReLogonStruc
 *                      NetSpecialSMBStruc
 *                      NetRemoteCopyStruc
 *                      NetMessageBufferSendStruc
 *                      NetMessageNameGetInfoStruc
 *                      NetServiceControlStruc
 *                      NetUseGetInfoStruc
 */

struct tr_packet {
        char FAR *      tr_name;        /* UNC Machine/Transaction name */
        char FAR *      tr_passwd;      /* password */
        char FAR *      tr_spbuf;       /* Send parameter buffer address */
        char FAR *      tr_sdbuf;       /* Send data buffer address */
        char FAR *      tr_rsbuf;       /* Receive set up buffer address */
        char FAR *      tr_rpbuf;       /* Receive parameter buffer address */
        char FAR *      tr_rdbuf;       /* Receive data buffer address */
        unsigned short  tr_splen;       /* Number of send parameter bytes */
        unsigned short  tr_sdlen;       /* Number of send data bytes */
        unsigned short  tr_rplen;       /* Number of receive parameter bytes */
        unsigned short  tr_rdlen;       /* Number of receive data bytes */
        unsigned short  tr_rslen;       /* Number of receive set up bytes */
        unsigned short  tr_flags;       /* Flags */
        unsigned long   tr_timeout;     /* Timeout */
        unsigned short  tr_resvd;       /* RESERVED (MBZ) */
        unsigned short  tr_sslen;       /* Number of send set up bytes */
};/* tr_packet */

/* data structure to simulate Transaction2 SMB.
 */
struct tr2_packet {
        char FAR *      tr2_name;       /* UNC Machine/Transaction name */
        char FAR *      tr2_passwd;     /* password */
        char FAR *      tr2_spbuf;      /* Send parameter buffer address */
        char FAR *      tr2_sdbuf;      /* Send data buffer address */
        char FAR *      tr2_rsbuf;      /* Receive set up buffer address */
        char FAR *      tr2_rpbuf;      /* Receive parameter buffer address */
        char FAR *      tr2_rdbuf;      /* Receive data buffer address */
        unsigned short  tr2_splen;      /* Number of send parameter bytes */
        unsigned short  tr2_sdlen;      /* Number of send data bytes */
        unsigned short  tr2_rplen;      /* Number of receive parameter bytes */
        unsigned short  tr2_rdlen;      /* Number of receive data bytes */
        unsigned short  tr2_rslen;      /* Number of receive set up bytes */
        unsigned short  tr2_flags;      /* Flags */
        unsigned long   tr2_timeout;    /* Timeout */
        unsigned short  tr2_resvd;      /* RESERVED (MBZ) */
        unsigned short  tr2_sslen;      /* Number of send set up bytes */
        unsigned short  tr2_trancode;   /* Transaction code for T2 SMB */
};/* tr2_packet */

struct NetWkstaSetUIDStruc {
        const char FAR *        su_username; /* username to log on/off */
        const char FAR *        su_password; /* password */
        const char FAR *        su_parms; /* OEM-specific parameter string */
};/* NetWkstaSetUIDStruc */

struct NetWkstaLogonStruc {
        char FAR *      ln_username;    /* new user name */
        char FAR *      ln_password;    /* new password */
        char FAR *      ln_parms;       /* OEM-specific parameter string */
        long FAR *      ln_uid;         /* UID returned here */
        char FAR *      ln_buffer;      /* buffer for passkey */
        unsigned short  ln_buflen;      /* length of passkey buffer */
};/* NetWkstaLogonStruc */

struct NetWkstaReLogonStruc {
        char FAR *      rl_username;    /* user name to re-log on */
        char FAR *      rl_password;    /* password to use in re-log on */
        char FAR *      rl_parms;       /* OEM-specific parameters */
        char FAR *      rl_buffer;      /* passkey buffer */
        unsigned short  rl_buflen;      /* length of passkey */
};/* NetWkstaReLogonStruc */

struct NetSpecialSMBStruc {
        char FAR *      sp_uncname;     /* UNC session name for SMB */
        char FAR *      sp_reqbuf;      /* Send SMB request buffer */
        unsigned short  sp_reqlen;      /* Length of send buffer */
        char FAR *      sp_rspbuf;      /* Receive SMB response buffer */
        unsigned short  sp_rsplen;      /* Length of receive buffer */
};/* NetSpecialSMBStruc */

struct NetRemoteCopyStruc {
        char FAR *      sourcepath;     /* ASCIIZ fully specified source path */
        char FAR *      destpath;       /* ASCIIZ fully specified dest path */
        char FAR *      sourcepass;     /* password for source path (NULL for default) */
        char FAR *      destpass;       /* password for dest path (NULL for default) */
        unsigned short  openflags;      /* flags for open of destpath */
        unsigned short  copyflags;      /* flags to control the copy */
        char FAR *      buf;            /* buffer to return error text in */
        unsigned short  buflen;         /* size of buffer on call */
};/* NetRemoteCopyStruc */


struct NetMessageBufferSendStruc {
    char FAR *          NMBSS_NetName;  /* asciz net name. */
    char FAR *          NMBSS_Buffer;   /* pointer to buffer. */
    unsigned int        NMBSS_BufSize;  /* size of buffer. */

}; /* NetMessageBufferSendStruc */

struct NetMessageNameGetInfoStruc {
    const char FAR *    NMNGIS_NetName; /* ASCIZ net name */
    char FAR *          NMNGIS_Buffer;  /* Pointer to buffer */
    unsigned int        NMNGIS_BufSize; /* Buffer size */
}; /* NetMessageNameGetInfoStruc */

struct NetServiceControlStruc {
    char FAR *          NSCS_Service;   /* Service name */
    unsigned short      NSCS_BufLen;    /* Buffer length */
    char FAR *          NSCS_BufferAddr;/* Buffer address */
};      /* NetServiceControlStruc */

struct NetUseGetInfoStruc {
        const char FAR* NUGI_usename;   /* ASCIZ redirected device name */
        short           NUGI_level;     /* level of info */
        char FAR*       NUGI_buffer;    /* buffer for returned info */
        unsigned short  NUGI_buflen;    /* size of buffer */
}; /* NetUseGetInfoStruc */

struct  DosWriteMailslotStruct {
    unsigned long DWMS_Timeout;         /* Timeout value of search */
    const char FAR *DWMS_Buffer;        /* Buffer address for mailslot write*/
}; /* DosWriteMailslotStruct */

struct  NetServerEnum2Struct {
    short          NSE_level;   /* level of information to be returned */
    char FAR      *NSE_buf;     /* buffer to contain returned info */
    unsigned short NSE_buflen;  /* number of bytes available in buffer */
    unsigned long  NSE_type;    /* bitmask of types to find */
    char FAR      *NSE_domain;  /* return servers in this domain */
}; /* NetServerEnum2Struct */

struct I_CDNames {
    char FAR      *CDN_pszComputer;
    char FAR      *CDN_pszPrimaryDomain;
    char FAR      *CDN_pszLogonDomain;
}; /* I_CDNames */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\bop.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    BOP.H

Abstract:

    This module contains macro support for use of Bops in C code.

Author:

    Dave Hastings (daveh) 25-Apr-1991

Revision History:

--*/

//
// Assigned Bop Numbers
//

#define BOP_DOS              0x50
#define BOP_WOW              0x51
#define BOP_XMS              0x52
#define BOP_DPMI             0x53
#define BOP_CMD              0x54
#define BOP_DEBUGGER         0x56
#define BOP_REDIR            0x57    // used to be 55, now goes to MS_bop_7()
#define BOP_NOSUPPORT        0x59    // host warning dialog box
#define BOP_WAITIFIDLE       0x5A    // idle bop
#define BOP_DBGBREAKPOINT    0x5B    // does a 32 bit DbgBreakPoint
#define BOP_KBD              0x5C    // BUGBUG temporary
#define BOP_VIDEO            0x5D    // BUGBUG temporary
#define BOP_NOTIFICATION     0x5E    // 16bits to 32 bits notification
#define BOP_UNIMPINT         0x5F    // BUGBUG temporary
#define BOP_SWITCHTOREALMODE 0xFD
#define BOP_UNSIMULATE       0xFE    // end execution of code in a vdm

#define BOP_SIZE         3       // # of bytes in a bop instruction
//
// Bop Macro
//

/* XLATOFF */

#define BOP(BopNumber) _asm db 0xC4, 0xC4, BopNumber

/* XLATON */

/* ASM
BOP macro BopNumber
    db  0C4h, 0C4h, BopNumber
        endm

IFNDEF WOW_x86
FBOP macro BopNumber,BopMinorNumber,FastBopEntry
    BOP BopNumber
ifnb <BopMinorNumber>
    db  BopMinorNumber
endif
    endm
ELSE
FBOP macro BopNumber,BopMinorNumber,FastBopEntry
    local fb10,fb20
    test    word ptr [FastBopEntry + 4],0FFFFh
    jz  fb10
.386p
    push    ds
    push    40h
    pop     ds
    test    ds:[FIXED_NTVDMSTATE_REL40],RM_BIT_MASK
    pop     ds
    jnz     short fb10
	call fword ptr [FastBopEntry]

    db BopNumber            ; indicates which bop
ifnb <BopMinorNumber>
    db BopMinorNumber
endif
	jmp short fb20

.286p
fb10:   BOP BopNumber
ifnb <BopMinorNumber>
    db  BopMinorNumber
endif
fb20:
    endm
endif
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\curdir.h ===
/*      BREAK <Current directory list structure>
 *
 *
 *       Microsoft Confidential
 *       Copyright (C) Microsoft Corporation 1991
 *       All Rights Reserved.
 *
 *
 *     CDS - Current Directory Structure
 *
 * CDS items are used bu the internal routines to store cluster numbers and
 * network identifiers for each logical name.  The ID field is used dually,
 * both as net ID and for a cluster number for local devices.  In the case
 * of local devices, the cluster number will be -1 if there is a potential
 * of the disk being changed or if the path must be recracked.
 *
 *       Some pathnames have special preambles, such as
 *
 *               \\machane\sharename\...
 *       For these pathnames we can't allow ".." processing to back us
 *       up into the special front part of the name.  The CURDIR_END field
 *       holds the address of the seperator character which marks
 *       the split between the special preamble and the regular
 *       path list; ".." processing isn't allowed to back us up past
 *       (i.e., before) CURDIR_END
 *       For the root, it points at the leading /.  For net
 *       assignments it points at the end (nul) of the initial assignment:
 *       A:/     \\foo\bar           \\foo\bar\blech\bozo
 *         ^              ^                   ^
 */


#define DIRSTRLEN   64+3        // Max length in bytes of directory strings
#define TEMPLEN     DIRSTRLEN*2

/* XLATOFF */
#pragma pack(1)
/* XLATON */

typedef struct CURDIR_LIST {
    CHAR    CurDir_Text[DIRSTRLEN];         // text of assignment and curdir
    USHORT  CurDir_Flags;                   // various flags
    USHORT  CurDir_End;                     // index to ".." backup limit -
} CDS;                                      // see above

typedef CDS UNALIGNED *PCDS;

#define curdirLen   sizeof(CURDIR_LIST)     // Needed for
                                            // ASM87 which doesn't allow
                                            // Size directive as a macro
                                            // argument

typedef struct CURDIR_LIST_JPN {
    CHAR    CurDirJPN_Text[DIRSTRLEN];      // text of assignment and curdir
    USHORT  CurDirJPN_Flags;                // various flags
    USHORT  CurDirJPN_End;                  // index to ".." backup limit -
    CHAR    CurDirJPN_Reserve[17];          // Reserved for application compatibility.
                                            // Ichitaro ver5 checks drive type by this structure size.
} CDS_JPN;                                  // see above

typedef CDS_JPN UNALIGNED *PCDS_JPN;

#define curdirLen_Jpn   sizeof(CURDIR_LIST_JPN)     // Needed for
                                                    // ASM87 which doesn't allow
                                                    // Size directive as a macro
                                                    // argument

// Flag values for CURDIR_FLAGS

#define CURDIR_ISNET    0x8000
#define CURDIR_ISIFS    0x8000
#define CURDIR_INUSE    0x4000
#define CURDIR_SPLICE   0x2000
#define CURDIR_LOCAL    0x1000

#define CURDIR_TOSYNC   0x0800              // Directory path to be sync added
#define CURDIR_NT_FIX   0x0400              // fixed disk (includes NETWORK
                                            // drives. Used in $Current_dir perf
                                            // work.



/* XLATOFF */
typedef CDS     UNALIGNED *PCDS;
typedef CDS_JPN UNALIGNED *PCDS_JPN;
/* XLATON */

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\dbginfo.h ===
typedef struct _vdminternalinfo {
    DWORD           dwLdtBase;
    DWORD           dwLdtLimit;
    DWORD           dwIntelBase;
    DWORD           dwReserved;
    WORD            wKernelSeg;
    DWORD           dwOffsetTHHOOK;
    LPVOID          vdmContext;
    LPVOID          lpRemoteAddress;
    DWORD           lpRemoteBlock;
    BOOL            f386;
    LPVOID          lpNtvdmState;
    LPVOID          lpVdmDbgFlags;
    LPVOID          lpNtCpuInfo;
    LPVOID          lpVdmBreakPoints;
} VDMINTERNALINFO;
typedef VDMINTERNALINFO *LPVDMINTERNALINFO;


#define MAX_VDM_BREAKPOINTS 16
#define VDM_TEMPBP 0
typedef struct _VDM_BREAKPOINT {   /* VDMBP */
    BYTE  Flags;
    BYTE  Opcode;
    WORD  Count;
    WORD  Seg;
    DWORD Offset;
} VDM_BREAKPOINT;

//
// Bits defined in Flags
//
#define VDMBP_SET     0x01
#define VDMBP_ENABLED 0x02
#define VDMBP_FLUSH   0x04
#define VDMBP_PENDING 0x08
#define VDMBP_V86     0x10


typedef struct _com_header {
    DWORD           dwBlockAddress;
    DWORD           dwReturnValue;
    WORD            wArgsPassed;
    WORD            wArgsSize;
    WORD            wBlockLength;
    WORD            wSuccess;
} COM_HEADER;
typedef COM_HEADER FAR *LPCOM_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\dbgexp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991,1992 Microsoft Corporation
 *
 *  DBGEXP.H
 *  DBG exports
 *
 *  History:
 *  13-Jan-1992 Bob Day (bobday)
 *  Created.
--*/

extern BOOL DBGInit( int, char *[] );
extern VOID DBGDispatch( void );
extern VOID DBGNotifyNewTask( LPVOID pNTFrame, UINT uFrameSize );
extern VOID DBGNotifyRemoteThreadAddress( LPVOID lpAddress, DWORD lpBlock );
extern VOID DBGNotifyDebugged( BOOL fDebugged );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\cmdsvc.h ===
/* command.h - This file has all the defines and data structures nneded
 *	       for command.com/command.dll communication.
 *
 * Sudeepb 17-Sep-1991 Created
 */

/* ASM
include bop.inc

CMDSVC	macro	func
	BOP	BOP_CMD
	db	func
	endm
*/

#define SVC_CMDEXITVDM		0
#define SVC_CMDGETNEXTCMD	1
#define	SVC_CMDCOMSPEC		2
#define SVC_CMDSAVEWORLD	3
#define SVC_CMDGETCURDIR	4
#define SVC_CMDSETINFO          5
#define SVC_GETSTDHANDLE        6
#define SVC_CMDCHECKBINARY      7
#define SVC_CMDEXEC             8
#define SVC_CMDINITCONSOLE      9
#define SVC_EXECCOMSPEC32       10
#define SVC_RETURNEXITCODE      11
#define SVC_GETCONFIGSYS        12
#define SVC_GETAUTOEXECBAT      13
#define SVC_GETKBDLAYOUT        14
#define SVC_GETINITENVIRONMENT  15
#define SVC_GETSTARTINFO        16
#define SVC_SETWINTITLE         17
#define SVC_GETCURSORPOS        30
#define SVC_CMDLASTSVC          31

#define ALL_HANDLES	7
#define HANDLE_STDIN	0
#define HANDLE_STDOUT	1
#define HANDLE_STDERR	2
#define MASK_STDIN	1
#define MASK_STDOUT	2
#define MASK_STDERR     4


// define extention type for command.com.
// these value must be in sync with 16bits. Please refer to
// tmisc1.asm in mvdm\dos\v86\cmd\command
#define BAD_EXTENTION	    0	    // never returned from 32 bits
#define BAT_EXTENTION	    2
#define EXE_EXTENTION	    4
#define COM_EXTENTION	    8
#define MAX_STD_EXTENTION   COM_EXTENTION

// THIS VALUE IS VERY IMPORTANT.
// 0(zero) means there is no such a program file and command.com would spit out
// well-known "bad command or file name".
// Give it to any value larger than than MAX_STD_EXTENTION) makes command.com
// by-passing any other checking and passing down the program file as is
// to DOS which doesn't have tight executable file extention convention.
// The reason that we allow program file with "non-standard" extention to
// pass through command.com and reach DOS is we receive the program pathname
// from CreateProcess which doesn't limit any file extention.
//


#define UNKNOWN_EXTENTION   MAX_STD_EXTENTION + 1


/* XLATOFF */

typedef struct _SAVEWORLD {
    USHORT  ax;
    USHORT  bx;
    USHORT  cx;
    USHORT  dx;
    USHORT  cs;
    USHORT  ss;
    USHORT  ds;
    USHORT  es;
    USHORT  si;
    USHORT  di;
    USHORT  bp;
    USHORT  sp;
    USHORT  ip;
    USHORT  flag;
    ULONG   ImageSize;
} SAVEWORLD, *PSAVEWORLD;

extern BOOL CMDInit (int argc, char *argv[]);
extern BOOL CMDRebootVDM (void);

extern BOOL fEnableInt10;

/* XLATON */

/** CMDINFO - Communication record of command.com **/

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _CMDINFO {		/**/
    USHORT	EnvSeg;
    USHORT	EnvSize;
    USHORT	CurDrive;
    USHORT	NumDrives;
    USHORT	CmdLineSeg;
    USHORT	CmdLineOff;
    USHORT	CmdLineSize;
    USHORT	ReturnCode;
    USHORT      bStdHandles;
    ULONG       pRdrInfo;
    USHORT	CodePage;
    USHORT      fTSRExit;
    USHORT      fBatStatus;
    USHORT      ExecPathSeg;
    USHORT      ExecPathOff;
    USHORT      ExecPathSize;
    USHORT	ExecExtType;
} CMDINFO;
typedef CMDINFO UNALIGNED *PCMDINFO;

/* XLATOFF */
#pragma pack()
/* XLATON */


BOOL CmdDispatch (ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\dbgsvc.h ===
/** SVC Defines
 *
 *  Revision history:
 *
 *  bobday 13-Jan-1992 Created
 */


/* DBGSVC - DBG SVC calls.
 *
 *   This macro is used by Nlddebug.asm (where N=nothing or 2)
 *
 */

/* ASM
include bop.inc

dbgsvc  macro   func
    BOP BOP_DEBUGGER
    db  func
    endm
*/

//
// Debug event codes
// These need to match the public definition in sdk\inc\vdmdbg.h
//

#define DBG_SEGLOAD     0
#define DBG_SEGMOVE     1
#define DBG_SEGFREE     2
#define DBG_MODLOAD     3
#define DBG_MODFREE     4
#define DBG_SINGLESTEP  5
#define DBG_BREAK       6
#define DBG_GPFAULT     7
#define DBG_DIVOVERFLOW 8
#define DBG_INSTRFAULT  9
#define DBG_TASKSTART   10
#define DBG_TASKSTOP    11
#define DBG_DLLSTART    12
#define DBG_DLLSTOP     13
#define DBG_ATTACH      14
#define DBG_TOOLHELP    15
#define DBG_STACKFAULT  16
#define DBG_WOWINIT     17
#define DBG_TEMPBP      18
#define DBG_MODMOVE     19
#define DBG_INIT        20
#define DBG_GPFAULT2    21

//
// Flags used by DemIsDebug
//
#define ISDBG_DEBUGGEE 1
#define ISDBG_SHOWSVC  2


void
DbgSegmentNotice(
    WORD wType,
    WORD  wModuleSeg,
    WORD  wLoadSeg,
    WORD  wNewSeg,
    LPSTR lpModuleName,
    LPSTR lpModulePath,
    DWORD dwImageLen
    );

BOOL
DbgIsDebuggee(
    void
    );

BOOL
DbgInit(
    void
    );

VOID DbgDosAppStart(WORD, WORD);
BOOL DbgBPInt(VOID);
BOOL DbgTraceInt(VOID);
BOOL DbgFault(ULONG);
VOID VdmPrompt(ULONG, ULONG);
VOID VdmTraceEvent(USHORT, USHORT, ULONG);

/* XLATOFF */
#if DBG

#define DBGTRACE(Type, wData, lData) VdmTraceEvent(Type, wData, lData)

#else

#define DBGTRACE(Type, wData, lData) {}

#endif

/* XLATON */

//
// Events for DbgPrompt()
//
#define DBG_EVENT_HW_INT    1
#define DBG_EVENT_SW_INT    2

//
// Definitions for VdmTraceEvent major code types
//

#define VDMTR_TYPE_KERNEL   0
#define VDMTR_TYPE_DPMI     0x100
#define VDMTR_TYPE_DPMI_SF  0x200
#define VDMTR_TYPE_DPMI_SI  0x300
#define VDMTR_TYPE_DEM      0x400
#define VDMTR_TYPE_WOW      0x500
#define VDMTR_TYPE_VSBD     0x600
#define VDMTR_TYPE_DBG      0x700
#define VDMTR_TYPE_MONITOR  0x800


//
// Definitions for VdmTraceEvent minor code types
//

#define DPMI_SWITCH_STACKS          1
#define DPMI_GENERIC                2
#define DPMI_DISPATCH_INT           3
#define DPMI_HW_INT                 4
#define DPMI_SW_INT                 5
#define DPMI_INT_IRET16             6
#define DPMI_INT_IRET32             7
#define DPMI_FAULT                  8
#define DPMI_DISPATCH_FAULT         9
#define DPMI_FAULT_IRET             10
#define DPMI_OP_EMULATION           11
#define DPMI_DISPATCH_ENTRY         12
#define DPMI_IN_PM                  13
#define DPMI_IN_V86                 14
#define DPMI_DISPATCH_EXIT          15
#define DPMI_REFLECT_TO_V86         16
#define DPMI_REFLECT_TO_PM          17

#define DEM_EVENT_DISPATCH          1
#define DEM_EVENT_DISPATCH_EXIT     2

#define MONITOR_EVENT_IO            1
#define MONITOR_EVENT_STRING_IO     2
#define MONITOR_EVENT_MEM_ACCESS    3
#define MONITOR_EVENT_INT_ACK       4
#define MONITOR_EVENT_BOP           5
#define MONITOR_EVENT_ERROR         6
#define MONITOR_EVENT_IRQ_13        7
#define MONITOR_CPU_SIMULATE        8
#define MONITOR_CPU_UNSIMULATE      9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\dossvc.h ===
/** SVC Defines
 *
 *  Revision history:
 *
 *  sudeepb 27-Feb-1991 Created
 */

/* VHE - Virtual Hard Error packet.
 *
 *   DEM makes fbInt24 to true if an hard error happens.
 */

typedef struct vhe_s {
    char  vhe_fbInt24;      // Was there a hard error?
    char  vhe_HrdErrCode;   // If hard error then this is the error code
    char  vhe_bDriveNum;    // If so on which drive
} VHE;

typedef VHE *PVHE;

/* DEMEXTERR - Extended Error structure. The following structure contains the
 * DOS extended error elements which are loosely coupled in the DOS data
 * segment
 *
 */

/* XLATOFF */
#include <packon.h>

typedef struct _DEMEXTERR {
    UCHAR   ExtendedErrorLocus;
    USHORT  ExtendedError;
    UCHAR   ExtendedErrorAction;
    UCHAR   ExtendedErrorClass;
    PUCHAR  ExtendedErrorPointer;
} DEMEXTERR;

typedef DEMEXTERR* PDEMEXTERR;


/* SYSDEV - Device chain node
 */

typedef struct _SYSDEV {

    ULONG   sdevNext;       // REAL mode pointer to next device.  -1 for end of chain.
    char    sdevIgnore[6];
    UCHAR   sdevDevName[8]; // device name

} SYSDEV;

typedef SYSDEV UNALIGNED *PSYSDEV;

#ifndef _DEMINCLUDED_
extern DECLSPEC_IMPORT PSYSDEV pDeviceChain;
#else
extern PSYSDEV pDeviceChain;
#endif


/* XLATON */

/* XLATOFF */
#include <packoff.h>
/* XLATON */

/* Note : To add a new SVC:
 *      New SVC gets the current value of SVC_LASTSVC. Increment
 *      the SVC_LASTSVC value. Add the appropriate SVC handler
 *      in apfnSVC (file dem\demdisp.c) at the end.
 *    To delete a SVC :
 *      Move each SVC one level up. Appropriatly adjust the
 *      apfnSVC (file dem\demdisp.c).
 */

/* SVC - Supervisory Call macro.
 *
 *   This macro is used by NTDOS and NTBIO to call DEM.
 *
 */

#define NTVDMDBG 1

/* ASM
include bop.inc

svc macro   func
    BOP BOP_DOS
    db  func
    endm
*/
#define SVC_DEMCHGFILEPTR               0x00
#define SVC_DEMCHMOD            0x01
#define SVC_DEMCLOSE            0x02
#define SVC_DEMCREATE           0x03
#define SVC_DEMCREATEDIR        0x04
#define SVC_DEMDELETE           0x05
#define SVC_DEMDELETEDIR        0x06
#define SVC_DEMDELETEFCB        0x07
#define SVC_DEMFILETIMES        0x08
#define SVC_DEMFINDFIRST        0x09
#define SVC_DEMFINDFIRSTFCB     0x0a
#define SVC_DEMFINDNEXT         0x0b
#define SVC_DEMFINDNEXTFCB      0x0c
#define SVC_DEMGETBOOTDRIVE     0x0d
#define SVC_DEMGETDRIVEFREESPACE    0x0e
#define SVC_DEMGETDRIVES        0x0f
#define SVC_DEMGSETMEDIAID      0x10
#define SVC_DEMLOADDOS          0x11
#define SVC_DEMOPEN         0x12
#define SVC_DEMQUERYCURRENTDIR      0x13
#define SVC_DEMQUERYDATE        0x14
#define SVC_DEMQUERYTIME        0x15
#define SVC_DEMREAD         0x16
#define SVC_DEMRENAME           0x17
#define SVC_DEMSETCURRENTDIR        0x18
#define SVC_DEMSETDATE          0x19
#define SVC_DEMSETDEFAULTDRIVE      0x1a
#define SVC_DEMSETDTALOCATION       0x1b
#define SVC_DEMSETTIME          0x1c
#define SVC_DEMSETV86KERNELADDR     0x1d
#define SVC_DEMWRITE            0x1e
#define SVC_GETDRIVEINFO        0x1f
#define SVC_DEMRENAMEFCB        0x20
#define SVC_DEMIOCTL            0x21
#define SVC_DEMCREATENEW        0x22
#define SVC_DEMDISKRESET        0x23
#define SVC_DEMSETDPB           0x24
#define SVC_DEMGETDPB           0x25
#define SVC_DEMSLEAZEFUNC       0x26
#define SVC_DEMCOMMIT           0x27
#define SVC_DEMEXTHANDLE        0x28
#define SVC_DEMABSDRD           0x29
#define SVC_DEMABSDWRT          0x2a
#define SVC_DEMGSETCDPG         0x2b
#define SVC_DEMCREATEFCB        0x2c
#define SVC_DEMOPENFCB          0x2d
#define SVC_DEMCLOSEFCB         0x2e
#define SVC_DEMFCBIO            0x2f
#define SVC_DEMDATE16           0x30
#define SVC_DEMGETFILEINFO      0x31
#define SVC_DEMSETHARDERRORINFO     0x32
#define SVC_DEMRETRY            0x33
#define SVC_DEMLOADDOSAPPSYM        0x34
#define SVC_DEMFREEDOSAPPSYM        0x35
#define SVC_DEMENTRYDOSAPP              0x36
#define SVC_DEMDOSDISPCALL              0x37
#define SVC_DEMDOSDISPRET               0x38
#define SVC_OUTPUT_STRING               0x39
#define SVC_INPUT_STRING        0x3A
#define SVC_ISDEBUG         0x3B
#define SVC_PDBTERMINATE        0x3C
#define SVC_DEMEXITVDM          0x3D
#define SVC_DEMWOWFILES         0x3E
#define SVC_DEMLOCKOPER         0x3F
#define SVC_DEMDRIVEFROMHANDLE  0x40
#define SVC_DEMGETCOMPUTERNAME  0x41
#define SVC_DEMFASTREAD         0x42
#define SVC_DEMFASTWRITE        0x43
#define SVC_DEMCHECKPATH        0x44
#define SVC_DEMSYSTEMSYMBOLOP   0x45
#define SVC_DEMGETDPBLIST       0x46

#define SVC_DEMPIPEFILEDATAEOF  0x47
#define SVC_DEMPIPEFILEEOF      0x48
#define SVC_DEMLFNENTRY         0x49
#define SVC_SETDOSVARLOCATION   0x4A
#define SVC_DEMLASTSVC          0x4B


/*
 *   Equates used in the DEMxxxSYSTEMxxx calls
 */
#define SYMOP_LOAD 1
#define SYMOP_FREE 2
#define SYMOP_MOVE 3
#define SYMOP_CLEANUP 0x80

#define ID_NTIO 1
#define ID_NTDOS 2

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\doswow.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  DOSWOW.H
 *  Shared structures between NTDOS, DEM and WOW32
 *
 *  History:
 *  Created 03-Dec-1993 by Neil Sandlin (neilsa)
--*/

/* XLATOFF */

#pragma pack(2)

/* XLATON */

/*
 * The following structure is used by some of the WOW functions to
 * point to internal DOS data. This is done to emulate some of the more
 * involved functions in WOW32, while still maintaining DOS data integrity.
 */
typedef struct _DOSWOWDATA {           /* DWD */
    DWORD lpCDSCount;
    DWORD lpCDSFixedTable;
    DWORD lpCDSBuffer;
    DWORD lpCurDrv;
    DWORD lpCurPDB;
    DWORD lpDrvErr;
    DWORD lpExterrLocus; // byte
    DWORD lpSCS_ToSync;
    DWORD lpSftAddr;
    DWORD lpExterr;  // word
    DWORD lpExterrActionClass; // 2 bytes -- action and class
} DOSWOWDATA;
typedef DOSWOWDATA UNALIGNED *PDOSWOWDATA;


/* XLATOFF */

#pragma pack(1)

typedef struct _DOSPDB {                        // DOS Process Data Block
    CHAR   PDB_Not_Interested[44];      // Fields we are not interested in
    USHORT PDB_environ;             // segment of environment
    DWORD  PDB_User_stack;
    USHORT PDB_JFN_Length;          // JFT length
    ULONG  PDB_JFN_Pointer;         // JFT pointer
} DOSPDB, *PDOSPDB;


typedef struct _DOSSF {             // DOS header for SFT chain
    ULONG  SFLink;                  // Link to next SF
    USHORT SFCount;                 // number of entries
    USHORT SFTable;                 // beginning of array of the SFTs
} DOSSF;
typedef DOSSF UNALIGNED *PDOSSF;


#define SFT_NAMED_PIPE 0x2000       // named pipe flag

typedef struct _DOSSFT {            // DOS SFT
    USHORT  SFT_Ref_Count;          // Howmany tasks using it
    USHORT  SFT_Mode;               // Mode of access
    UCHAR   SFT_Attr;               // Attribute of file
    USHORT  SFT_Flags;              // Bit 15 = 1 if remote file
                                    //        = 0 if local or device
    ULONG   SFT_Devptr;             // Device pointer
    USHORT  SFT_Time;
    USHORT  SFT_Date;
    ULONG   SFT_Size;
    ULONG   SFT_Position;
    ULONG   SFT_Chain;
    USHORT  SFT_PID;
    ULONG   SFT_NTHandle;           // NT File Handle
} DOSSFT;
typedef DOSSFT UNALIGNED *PDOSSFT;

// execblock
typedef struct _DOSEXECBLOCK {
   USHORT envseg;   // env segment
   ULONG  lpcmdline; // command line tail
   ULONG  lpfcb1;    // fcb1
   ULONG  lpfcb2;    // fcb2
}  DOSEXECBLOCK, UNALIGNED *PDOSEXECBLOCK;

#define NE_FLAGS_OFFSET 0xc
#define NEPROT 0x8   // runs in prot mode only


#define SF_NT_SEEK 0x0200

#pragma pack()

// these are demLFN structures that work with wow and dem

typedef VOID (*PDOSWOWUPDATETDBDIR)(UCHAR, LPSTR);
typedef BOOL (*PDOSWOWGETTDBDIR)(UCHAR Drive, LPSTR pCurrentDirectory);
typedef BOOL (*PDOSWOWDODIRECTHDPOPUP)(VOID);
typedef BOOL (*PDOSWOWGETCOMPATFLAGS)(LPDWORD lpdwCF, LPDWORD lpdwCFEx);


typedef struct tagWOWLFNInit {
   PDOSWOWUPDATETDBDIR pDosWowUpdateTDBDir;
   PDOSWOWGETTDBDIR pDosWowGetTDBDir;
   PDOSWOWDODIRECTHDPOPUP pDosWowDoDirectHDPopup;
#if 0
   PDOSWOWGETCOMPATFLAGS pDosWowGetCompatFlags;
#endif
}  WOWLFNINIT, *PWOWLFNINIT;


/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\dpmi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dpmi.h

Abstract:

    This file contains code to implement support for the DPMI bops

Author:

    Dave Hastings (daveh) 27-Jun-1991

Revision History:


--*/

/* ASM
ifdef WOW_x86
include vint.inc
endif
include bop.inc
*/
#define LDT_SIZE 0x1FFF

// DPMI Bop Sub Functions

#define InitDosxRM                  0
#define InitDosx                    1
#define InitLDT                     2
#define GetFastBopAddress           3
#define InitIDT                     4
#define InitExceptionHandlers       5
#define InitApp                     6
#define TerminateApp                7
#define DpmiInUse                   8
#define DpmiNoLongerInUse           9

#define DPMISwitchToProtectedMode   10 /* prefix necessary */
#define DPMISwitchToRealMode        11
#define SetAltRegs                  12

#define IntHandlerIret              13
#define IntHandlerIretd             14
#define FaultHandlerIret            15
#define FaultHandlerIretd           16
#define DpmiUnhandledException      17

#define RMCallBackCall              18
#define ReflectIntrToPM             19
#define ReflectIntrToV86            20

#define InitPmStackInfo             21
#define VcdPmSvcCall32              22
#define SetDescriptorTableEntries   23
#define ResetLDTUserBase            24

#define XlatInt21Call               25
#define Int31Entry                  26
#define Int31Call                   27

#define HungAppIretAndExit          28

#define MAX_DPMI_BOP_FUNC HungAppIretAndExit + 1

/* ASM
DPMIBOP macro SubFun
    BOP BOP_DPMI
    db SubFun
    endm
*/


//
// Definitions for real mode call backs
//

/* XLATOFF */
typedef struct _RMCB_INFO {
    BOOL bInUse;
    USHORT StackSel;
    USHORT StrucSeg;
    ULONG  StrucOffset;
    USHORT ProcSeg;
    ULONG  ProcOffset;
} RMCB_INFO;

// 16 is the minimum defined in the dpmi spec
#define MAX_RMCBS 16


typedef struct _MEM_DPMI {
    PVOID Address;
    ULONG Length;
    struct _MEM_DPMI * Prev;
    struct _MEM_DPMI * Next;
    WORD Owner;
    WORD Sel;
    WORD SelCount;
} MEM_DPMI, *PMEM_DPMI;

VOID
SetShadowDescriptorEntries(
    USHORT SelStart,
    USHORT SelCount
    );

/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\demexp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  DEMEXP.H
 *  DOS emulation exports
 *
 *  History:
 *  22-Apr-1991 Sudeep Bharati (sudeepb)
 *  Created.
--*/

BOOL DemInit (int argc, char *argv[]);
BOOL DemDispatch(ULONG iSvc);
VOID demCloseAllPSPRecords (VOID);
DWORD demFileDelete (LPSTR lpFile);
DWORD demFileFindFirst (PVOID pDTA, LPSTR lpFile, USHORT usSearchAttr);
DWORD demFileFindNext (PVOID pDTA);
ULONG demClientErrorEx (HANDLE hFile, CHAR chDrive, BOOL bSetRegs);
UCHAR demGetPhysicalDriveType(UCHAR DriveNum);
ULONG demWOWLFNEntry(PVOID pUserFrame);

#define SIZEOF_DOSSRCHDTA 43

#if DEVL
// bit masks to control trace info
#define DEMDOSAPPBREAK 0x80000000
#define DEMDOSDISP     0x40000000
#define DEMFILIO       0x20000000
#define DEMSVCTRACE    0x10000000
#define KEEPBOOTFILES  0x01000000  // if set, no delete temp boot files
#define DEM_ABSDRD     0x02000000
#define DEM_ABSWRT     0x04000000
#define DEMERROR       0x08000000

extern DWORD  fShowSVCMsg;
#endif

#ifdef FE_SB
#define NTIO_411 "\\ntio411.sys"        // LANG_JAPANESE
#define NTIO_409 "\\ntio.sys"           //
#define NTIO_804 "\\ntio804.sys"        // LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED or SUBLANG_CHINESE_HONGKONG
#define NTIO_404 "\\ntio404.sys"        // LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL
#define NTIO_412 "\\ntio412.sys"        // LANG_KOREAN

#define NTDOS_411 "\\ntdos411.sys"      // LANG_JAPANESE
#define NTDOS_409 "\\ntdos.sys"         //
#define NTDOS_804 "\\ntdos804.sys"      // LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED or SUBLANG_CHINESE_HONGKONG
#define NTDOS_404 "\\ntdos404.sys"      // LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL
#define NTDOS_412 "\\ntdos412.sys"      // LANG_KOREAN
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\enumapis.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1990		**/ 
/*****************************************************************/ 
/***	enumapis.h
 *
 *	This file contains the subfunctions for the loadable APIs in the
 *	REDIR 1.5 project
 */

#define REDIRBASEFUNCTION		0x5f00
#define BADFUNCTION			0xFFFF
#define UseWkstaPass			0x80

#define Local_API_ReturnMode			0x00
#define Local_API_SetMode			0x01
#define Local_API_GetAsgList			0x02
#define Local_API_Define			0x03
#define Local_API_BREAK_MAC			0x04
#define Local_API_GetAsgList2			0x05

#define Local_API_RedirGetVersion		0x30
#define Local_API_NetWkstaSetUID		0x31
#define Local_API_DosQNmPipeInfo		0x32
#define Local_API_DosQNmPHandState		0x33
#define Local_API_DosSetNmPHandState		0x34
#define Local_API_DosPeekNmPipe 		0x35
#define Local_API_DosTransactNmPipe		0x36
#define Local_API_DosCallNmPipe 		0x37
#define Local_API_DosWaitNmPipe 		0x38
#define Local_API_DosRawReadNmPipe		0x39
#define Local_API_DosRawWriteNmPipe		0x3a
#define Local_API_NetHandleSetInfo		0x3b
#define Local_API_NetHandleGetInfo		0x3c
#define Local_API_NetTransact			0x3d
#define Local_API_NetSpecialSMB 		0x3e
#define Local_API_NetIRemoteAPI 		0x3f
#define Local_API_NetMessageBufferSend		0x40
#define Local_API_NetServiceEnum		0x41
#define Local_API_NetServiceControl		0x42
#define Local_API_DosPrintJobGetID		0x43
#define Local_API_NetWkstaGetInfo		0x44
#define Local_API_NetWkstaSetInfo		0x45
#define Local_API_NetUseEnum			0x46
#define Local_API_NetUseAdd			0x47
#define Local_API_NetUseDel			0x48
#define Local_API_NetUseGetInfo 		0x49
#define Local_API_NetRemoteCopy 		0x4a
#define Local_API_NetRemoteMove 		0x4b
#define Local_API_NetServerEnum 		0x4c
#define Local_API_DosMakeMailslot		0x4d
#define Local_API_DosDeleteMailslot		0x4e
#define Local_API_DosMailslotInfo		0x4f
#define Local_API_DosReadMailslot		0x50
#define Local_API_DosPeekMailslot		0x51
#define Local_API_DosWriteMailslot		0x52
#define Local_API_NetServerEnum2		0x53
#define	Local_API_NullTransact			0x54

/*	NOTE:: Remove_Network_Connections is a private call to allow the
 *	NetSetUserName INT 2F to remove network connections.
 */

#define	Local_API_Remove_Network_Connections	0x55

/*	NOTE:: Process_Interrogate is a private call to allow the
 *	redirector to kick itself from INT 28 and INT 8 to process relogon
 *	requests.
 */
#define	Local_API_Periodic_View_Tasks		0x56
#define Local_API_Set_LongName			0x57
#define Local_API_Start_Redir_On_Net		0x58
#define Local_API_Stop_Redir_per_Net		0x59
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\exterr.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    exterr.h

Abstract:

    Taken from mvdm\dos\v86\inc\error.inc

Author:

    Richard L Firth (rfirth) 17-Oct-1992

Revision History:

--*/

/** ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX. If an error occurred then
;    the carry bit will be set and the error code is in AX. If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action.   The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.
*/

//  2.0 error codes

#define error_invalid_function      1
#define error_file_not_found        2
#define error_path_not_found        3
#define error_too_many_open_files   4
#define error_access_denied         5
#define error_invalid_handle        6
#define error_arena_trashed         7
#define error_not_enough_memory     8
#define error_invalid_block         9
#define error_bad_environment       10
#define error_bad_format            11
#define error_invalid_access        12
#define error_invalid_data          13
/**** reserved          EQU 14  ; *****/
#define error_invalid_drive         15
#define error_current_directory     16
#define error_not_same_device       17
#define error_no_more_files         18

//  These are the universal int 24 mappings for the old INT 24 set of errors

#define error_write_protect         19
#define error_bad_unit              20
#define error_not_ready             21
#define error_bad_command           22
#define error_CRC                   23
#define error_bad_length            24
#define error_Seek                  25
#define error_not_DOS_disk          26
#define error_sector_not_found      27
#define error_out_of_paper          28
#define error_write_fault           29
#define error_read_fault            30
#define error_gen_failure           31

//  the new 3.0 error codes reported through INT 24

#define error_sharing_violation     32
#define error_lock_violation        33
#define error_wrong_disk            34
#define error_FCB_unavailable       35
#define error_sharing_buffer_exceeded   36
#define error_Code_Page_Mismatched  37    // DOS 4.00           ;AN000;
#define error_handle_EOF            38    // DOS 4.00           ;AN000;
#define error_handle_Disk_Full      39    // DOS 4.00           ;AN000;

//  New OEM network-related errors are 50-79

#define error_not_supported         50

#define error_net_access_denied     65    //M028

//  End of INT 24 reportable errors

#define error_file_exists           80
#define error_DUP_FCB               81  // *****
#define error_cannot_make           82
#define error_FAIL_I24              83

//  New 3.0 network related error codes

#define error_out_of_structures     84
#define error_Already_assigned      85
#define error_invalid_password      86
#define error_invalid_parameter     87
#define error_NET_write_fault       88
#define error_sys_comp_not_loaded   90    // DOS 4.00               ;AN000;



//  BREAK <Interrupt 24 error codes>

/** Int24 Error Codes **/

#define error_I24_write_protect     0
#define error_I24_bad_unit          1
#define error_I24_not_ready         2
#define error_I24_bad_command       3
#define error_I24_CRC               4
#define error_I24_bad_length        5
#define error_I24_Seek              6
#define error_I24_not_DOS_disk      7
#define error_I24_sector_not_found  8
#define error_I24_out_of_paper      9
#define error_I24_write_fault       0xA
#define error_I24_read_fault        0xB
#define error_I24_gen_failure       0xC
// NOTE: Code 0DH is used by MT-DOS.
#define error_I24_wrong_disk        0xF


//  THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
//
//  NOTE: ABORT is ALWAYS allowed

#define Allowed_FAIL        0x08    // 00001000B
#define Allowed_RETRY       0x10    // 00010000B
#define Allowed_IGNORE      0x20    // 00100000B

#define I24_operation       0x01    // 00000001B    ;Z if READ,NZ if Write
#define I24_area            0x60    // 00000110B    ; 00 if DOS
                                    //              ; 01 if FAT
                                    //              ; 10 if root DIR
                                    //              ; 11 if DATA
#define I24_class           0x80    // 10000000B    ;Z if DISK, NZ if FAT or char


//  BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>

/** The GetExtendedError call takes an error code and returns CLASS,
;   ACTION and LOCUS codes to help programs determine the proper action
;   to take for error codes that they don't explicitly understand.
*/

//  Values for error CLASS

#define errCLASS_OutRes     1   // Out of Resource
#define errCLASS_TempSit    2   // Temporary Situation
#define errCLASS_Auth       3   // Permission problem
#define errCLASS_Intrn      4   // Internal System Error
#define errCLASS_HrdFail    5   // Hardware Failure
#define errCLASS_SysFail    6   // System Failure
#define errCLASS_Apperr     7   // Application Error
#define errCLASS_NotFnd     8   // Not Found
#define errCLASS_BadFmt     9   // Bad Format
#define errCLASS_Locked     10  // Locked
#define errCLASS_Media      11  // Media Failure
#define errCLASS_Already    12  // Collision with Existing Item
#define errCLASS_Unk        13  // Unknown/other

//  Values for error ACTION

#define errACT_Retry        1   // Retry
#define errACT_DlyRet       2   // Delay Retry, retry after pause
#define errACT_User         3   // Ask user to regive info
#define errACT_Abort        4   // abort with clean up
#define errACT_Panic        5   // abort immediately
#define errACT_Ignore       6   // ignore
#define errACT_IntRet       7   // Retry after User Intervention

//  Values for error LOCUS

#define errLOC_Unk          1   // No appropriate value
#define errLOC_Disk         2   // Random Access Mass Storage
#define errLOC_Net          3   // Network
#define errLOC_SerDev       4   // Serial Device
#define errLOC_Mem          5   // Memory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\intapi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    intapi.h

Abstract:

    This header defines the function prototypes for the interrupt
    handler support routines in the 486 emulator.

Author:

    Neil Sandlin (neilsa)

Notes:

    
Revision History:


--*/

NTSTATUS
VdmInstallHardwareIntHandler(
    PVOID HwIntHandler
    );

NTSTATUS
VdmInstallSoftwareIntHandler(
    PVOID SwIntHandler
    );

NTSTATUS
VdmInstallFaultHandler(
    PVOID FaultHandler
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\memapi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    memapi.h

Abstract:

    This header defines the function prototypes for the memory
    manipulation routines in the 486 emulator.

Author:

    Neil Sandlin (neilsa)

Notes:

    
Revision History:


--*/

NTSTATUS
VdmAllocateVirtualMemory(
    PULONG Address,
    ULONG Size,
    BOOLEAN Commit
    );

NTSTATUS 
VdmFreeVirtualMemory(
    ULONG Address
    );

NTSTATUS
VdmCommitVirtualMemory(
    ULONG Address,
    ULONG Size
    );

NTSTATUS
VdmDeCommitVirtualMemory(
    ULONG Address,
    ULONG Size
    );

NTSTATUS
VdmQueryFreeVirtualMemory(
    PULONG FreeBytes,
    PULONG LargestFreeBlock
    );

NTSTATUS
VdmReallocateVirtualMemory(
    ULONG OldAddress,
    PULONG NewAddress,
    ULONG NewSize
    );

NTSTATUS
VdmAddVirtualMemory(
    ULONG HostAddress,
    ULONG Size,
    PULONG IntelAddress
    );

NTSTATUS
VdmRemoveVirtualMemory(
    ULONG IntelAddress
    );


BOOL
VdmAddDescriptorMapping(
    USHORT SelectorStart,
    USHORT SelectorCount,
    ULONG LdtBase,
    ULONG Flat
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\monregs.h ===
extern CONTEXT IntelRegisters;
extern ULONG IntelMSW;
// Flag Register constants

#define FLG_CARRY           0x00000001
#define FLG_CARRY_BIT       0x00000000
#define FLG_PARITY          0x00000004
#define FLG_PARITY_BIT      0x00000003
#define FLG_AUXILIARY       0x00000010
#define FLG_AUXILIARY_BIT   0x00000005
#define FLG_ZERO            0x00000040
#define FLG_ZERO_BIT        0x00000006
#define FLG_SIGN            0x00000080
#define FLG_SIGN_BIT        0x00000007
#define FLG_INTERRUPT       0x00000200
#define FLG_INTERRUPT_BIT   0x00000009
#define FLG_DIRECTION       0x00000400
#define FLG_DIRECTION_BIT   0x0000000A
#define FLG_OVERFLOW        0x00000800
#define FLG_OVERFLOW_BIT    0x0000000B
extern ULONG  getEAX(VOID);
extern USHORT getAX(VOID);
extern UCHAR  getAL(VOID);
extern UCHAR  getAH(VOID);
extern ULONG  getEBX(VOID);
extern USHORT getBX(VOID);
extern UCHAR  getBL(VOID);
extern UCHAR  getBH(VOID);
extern ULONG  getECX(VOID);
extern USHORT getCX(VOID);
extern UCHAR  getCL(VOID);
extern UCHAR  getCH(VOID);
extern ULONG  getEDX(VOID);
extern USHORT getDX(VOID);
extern UCHAR  getDL(VOID);
extern UCHAR  getDH(VOID);
extern ULONG  getESP(VOID);
extern USHORT getSP(VOID);
extern ULONG  getEBP(VOID);
extern USHORT getBP(VOID);
extern ULONG  getESI(VOID);
extern USHORT getSI(VOID);
extern ULONG  getEDI(VOID);
extern USHORT getDI(VOID);
extern ULONG  getEIP(VOID);
extern USHORT getIP(VOID);
extern USHORT getCS(VOID);
extern USHORT getSS(VOID);
extern USHORT getDS(VOID);
extern USHORT getES(VOID);
extern USHORT getFS(VOID);
extern USHORT getGS(VOID);
extern ULONG  getCF(VOID);
extern ULONG  getPF(VOID);
extern ULONG  getAF(VOID);
extern ULONG  getZF(VOID);
extern ULONG  getSF(VOID);
extern ULONG  getIF(VOID);
extern ULONG  getDF(VOID);
extern ULONG  getOF(VOID);
extern USHORT getMSW(VOID);

extern VOID setEAX(ULONG);
extern VOID setAX(USHORT);
extern VOID setAH(UCHAR);
extern VOID setAL(UCHAR);
extern VOID setEBX(ULONG);
extern VOID setBX(USHORT);
extern VOID setBH(UCHAR);
extern VOID setBL(UCHAR);
extern VOID setECX(ULONG);
extern VOID setCX(USHORT);
extern VOID setCH(UCHAR);
extern VOID setCL(UCHAR);
extern VOID setEDX(ULONG);
extern VOID setDX(USHORT);
extern VOID setDH(UCHAR);
extern VOID setDL(UCHAR);
extern VOID setESP(ULONG);
extern VOID setSP(USHORT);
extern VOID setEBP(ULONG);
extern VOID setBP(USHORT);
extern VOID setESI(ULONG);
extern VOID setSI(USHORT);
extern VOID setEDI(ULONG);
extern VOID setDI(USHORT);
extern VOID setEIP(ULONG);
extern VOID setIP(USHORT);
extern VOID setCS(USHORT);
extern VOID setSS(USHORT);
extern VOID setDS(USHORT);
extern VOID setES(USHORT);
extern VOID setFS(USHORT);
extern VOID setGS(USHORT);
extern VOID setCF(ULONG);
extern VOID setPF(ULONG);
extern VOID setAF(ULONG);
extern VOID setZF(ULONG);
extern VOID setSF(ULONG);
extern VOID setIF(ULONG);
extern VOID setDF(ULONG);
extern VOID setOF(ULONG);
extern VOID setMSW(USHORT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\rdrexp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rdrexp.h

Abstract:

    Definition of Vdm Redir BOP dispatcher

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

--*/



BOOL
VrDispatch(
    IN  ULONG   SvcCode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\rdrsvc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rdrsvc.h

Abstract:

    Contains BOP codes for Vdm Redir (Vr) BOP dispatcher

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

--*/



/* ASM
include bop.inc

SVC     macro   SvcNum
        BOP     BOP_REDIR
        db      SvcNum
endm

*/



//
// Note: the order has no bearing on the order of the 5f dispatch table or
// vice versa. However, the order must be contiguous
//

#define SVC_RDRINITIALIZE       0x00    // redir loaded
#define SVC_RDRUNINITIALIZE     0x01    // redir unloaded
#define SVC_RDRQNMPIPEINFO      0x02    // DosQNmPipeInfo
#define SVC_RDRQNMPHANDSTATE    0x03    // DosQNmpHandState
#define SVC_RDRSETNMPHANDSTATE  0x04    // DosSetNmpHandState
#define SVC_RDRPEEKNMPIPE       0x05    // DosPeekNmPipe
#define SVC_RDRTRANSACTNMPIPE   0x06    // DosTransactNmPipe
#define SVC_RDRCALLNMPIPE       0x07    // DosCallNmPipe
#define SVC_RDRWAITNMPIPE       0x08    // DosWaitNmPipe
#define SVC_RDRDELETEMAILSLOT   0x09    // DosDeleteMailslot
#define SVC_RDRGETMAILSLOTINFO  0x0a    // DosMailslotInfo
#define SVC_RDRMAKEMAILSLOT     0x0b    // DosMakeMailslot
#define SVC_RDRPEEKMAILSLOT     0x0c    // DosPeekMailslot
#define SVC_RDRREADMAILSLOT     0x0d    // DosReadMailslot
#define SVC_RDRWRITEMAILSLOT    0x0e    // DosWriteMailslot
#define SVC_RDRTERMINATE        0x0f    // NetResetEnvironment for mailslots
#define SVC_RDRTRANSACTAPI      0x10    // NetTransactAPI
#define SVC_RDRIREMOTEAPI       0x11    // NetIRemoteAPI
#define SVC_RDRNULLTRANSACTAPI  0x12    // NetTransactAPI
#define SVC_RDRSERVERENUM       0x13    // NetServerEnum (remoted)
#define SVC_RDRUSEADD           0x14    // NetUseAdd (local)
#define SVC_RDRUSEDEL           0x15    // NetUseDel (local)
#define SVC_RDRUSEENUM          0x16    // NetUseEnum (local)
#define SVC_RDRUSEGETINFO       0x17    // NetUseGetInfo (local)
#define SVC_RDRWKSTAGETINFO     0x18    // NetWkstaGetInfo (local)
#define SVC_RDRWKSTASETINFO     0x19    // NetWkstaSetInfo (local)
#define SVC_RDRMESSAGEBUFFERSEND 0x1a    // NetMessageBufferSend (local)
#define SVC_RDRGETCDNAMES       0x1b    // NetGetEnumInfo.CDNames
#define SVC_RDRGETCOMPUTERNAME  0x1c    // NetGetEnumInfo.ComputerName
#define SVC_RDRGETUSERNAME      0x1d    // NetGetEnumInfo.UserName
#define SVC_RDRGETDOMAINNAME    0x1e    // NetGetEnumInfo.DomainName
#define SVC_RDRGETLOGONSERVER   0x1f    // NetGetEnumInfo.LogonServer
#define SVC_RDRHANDLEGETINFO    0x20    // NetHandleGetInfo
#define SVC_RDRHANDLESETINFO    0x21    // NetHandleSetInfo
#define SVC_RDRGETDCNAME        0x22    // NetGetDCName
#define SVC_RDRREADASYNCNMPIPE  0x23    // DosReadAsyncNmPipe
#define SVC_RDRWRITEASYNCNMPIPE 0x24    // DosWriteAsyncNmPipe
#define SVC_NETBIOS5C           0x25    // Netbios request handler
#define SVC_NETBIOS5CINTERRUPT  0x26    // Netbios/Dlc post routine request
#define SVC_DLC_5C              0x27    // Dlc request handler
#define SVC_VDM_WINDOW_INIT     0x28    // Inits memory window
#define SVC_RDRRETURN_MODE      0x29    // returns pause/continue state
#define SVC_RDRSET_MODE         0x2a    // sets pause/continue state
#define SVC_RDRGET_ASG_LIST     0x2b    // old NetUseGetInfo
#define SVC_RDRDEFINE_MACRO     0x2c    // old NetUseAdd
#define SVC_RDRBREAK_MACRO      0x2d    // old NetUseDel
#define SVC_RDRSERVICECONTROL   0x2e    // NetServiceControl
#define SVC_RDRINTACK           0x2f    // VrDismissInterrupt
#define SVC_RDRINTACK2          0x30    // VrDismissInterrupt2
#define SVC_NETBIOSCHECK        0x31    // VrCheckPmNetbiosAnr

#define MAX_REDIR_SVC           SVC_NETBIOSCHECK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\oemuni.h ===
/*
 *  OemUnicode win32 thunk prototypes
 *
 *  14-Jan-1993 Jonle, created
 *
 *  Should be identical to ansi form with "Oem" appended
 *  instead of "A"
 */

HANDLE
WINAPI
CreateFileOem(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

BOOL
APIENTRY
SetFileAttributesOem(
    LPSTR lpFileName,
    DWORD dwFileAttributes
    );

DWORD
APIENTRY
GetFileAttributesOem(
    LPSTR lpFileName
    );

BOOL
APIENTRY
DeleteFileOem(
    LPSTR lpFileName
    );

BOOL
APIENTRY
MoveFileOem(
    LPSTR lpExistingFileName,
    LPSTR lpNewFileName
    );

BOOL
APIENTRY
MoveFileExOem(
    LPSTR lpExistingFileName,
    LPSTR lpNewFileName,
    DWORD fdwFlags
    );

HANDLE
APIENTRY
FindFirstFileOem(
    LPSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    );

BOOL
APIENTRY
FindNextFileOem(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    );

DWORD
APIENTRY
GetFullPathNameOem(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

DWORD
APIENTRY
GetCurrentDirectoryOem(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

BOOL
APIENTRY
SetCurrentDirectoryOem(
    LPSTR lpPathName
    );

BOOL
APIENTRY
CreateDirectoryOem(
    LPSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
APIENTRY
RemoveDirectoryOem(
    LPSTR lpPathName
    );

UINT
APIENTRY
GetSystemDirectoryOem(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT
APIENTRY
GetWindowsDirectoryOem(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT
APIENTRY
GetDriveTypeOem(
    LPSTR lpRootPathName
    );

DWORD
APIENTRY
SearchPathOem (
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

DWORD
APIENTRY
GetTempPathOem(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

UINT
APIENTRY
GetTempFileNameOem(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    );

BOOL
APIENTRY
GetDiskFreeSpaceOem(
    LPSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );

BOOL
APIENTRY
GetVolumeInformationOem(
    LPSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );

BOOL
WINAPI
CreateProcessOem(
    LPCSTR lpApplicationName,
    LPCSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

DWORD
WINAPI
GetEnvironmentVariableOem(
    LPSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );

BOOL
WINAPI
SetEnvironmentVariableOem(
    LPSTR lpName,
    LPSTR lpValue
    );

DWORD
WINAPI
ExpandEnvironmentStringsOem(
    LPSTR lpSrc,
    LPSTR lpDst,
    DWORD cchDst
    );



VOID
APIENTRY
OutputDebugStringOem(
    LPCSTR lpOutputString
    );

BOOL
WINAPI
GetComputerNameOem (
    LPSTR   lpComputerName,
    LPDWORD BufferSize
    );

BOOL
WINAPI
RemoveFontResourceOem(
    LPSTR   lpFileName
    );

UINT
WINAPI
GetShortPathNameOem(
    LPSTR lpSrc,
    LPSTR lpDst,
    DWORD cchDst
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\mvdm.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  MVDM.H
 *  Constants, macros, and types common to all of MVDM
 *
 *  History:
 *  Created 14-May-1991 by Jeff Parsons (jeffpar)
--*/


/* Common constants, not defined in NT/WIN32
 */
#define K		1024L


/* Common types, not defined in NT/WIN32
 */
#ifdef H2INC
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;
typedef char CHAR;
typedef short SHORT;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef char *PSZ;
typedef void *PVOID;
typedef ULONG *PULONG;
typedef WORD ATOM;
#endif

// typedef int INT;
// typedef DWORD UINT;
typedef short FAR *LPSHORT;
typedef char SZ[];
typedef char FAR *LPSZ;
typedef PBYTE *PPBYTE;
typedef PWORD *PPWORD;
typedef PDWORD *PPDWORD;
// typedef UINT *PUINT;


// unaligned typedefs

typedef WORD  UNALIGNED *PWORD16;
typedef SHORT UNALIGNED *PSHORT16;
typedef DWORD UNALIGNED *PDWORD16;

#define WORDOF16(i,n)	(((PWORD16)&(i))[n])
#define LOW16(l)		WORDOF16(l,0)
#define HIW16(l)		WORDOF16(l,1)

/* Common macros, not defined in NT/WIN32
 */
#define BYTEOF(i,n)	(((PBYTE)&(i))[n])
#define LOB(i)		BYTEOF(i,0)
#define HIB(i)		BYTEOF(i,1)
#define WORDOF(i,n)	(((PWORD)&(i))[n])
#define LOW(l)		WORDOF(l,0)
#define HIW(l)		WORDOF(l,1)
#define INTOF(i,n)	(((PINT)&(i))[n])
#define UINTOF(i,n)	(((PUINT)&(i))[n])
#ifndef MAKEWORD
#define MAKEWORD(l,h)	((WORD)((BYTE)(l)|((BYTE)(h)<<8)))
#endif
#define MAKEDWORD(l0,h0,l1,h1)	((DWORD)MAKEWORD(l0,h0)|((DWORD)MAKEWORD(l1,h1)<<16))
#define GETBYTE(p)	*((PBYTE)p)++
#ifdef	i386
#define FETCHWORD(s)	((WORD)(s))
#define FETCHDWORD(s)	((DWORD)(s))
#define STOREWORD(d,s)	(WORD)d=(WORD)s
#define STOREDWORD(d,s) (DWORD)d=(DWORD)s
#else
#define FETCHWORD(s)  (*(UNALIGNED WORD *)&(s))
#define FETCHDWORD(s) (*(UNALIGNED DWORD *)&(s))
#define STOREWORD(d,s)  *(UNALIGNED WORD *)&(d)=(WORD)s
#define STOREDWORD(d,s) *(UNALIGNED DWORD *)&(d)=(DWORD)s
#endif
#define FETCHSHORT(s)	((SHORT)(FETCHWORD(s)))
#define FETCHLONG(s)	((LONG)(FETCHDWORD(s)))
#define STORESHORT(d,s) STOREWORD(d,s)
#define STORELONG(d,s)	STOREDWORD(d,s)

#define NUMEL(a)	((sizeof a)/(sizeof a[0]))
#define OFFSETOF(t,f)	((INT)&(((t *)0)->f))

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\netb.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnetb.h

Abstract:

    Contains prototypes and definitions for Vdm netbios support routines

Author:

    Colin Watson (colinw) 09-Dec-1991

Revision History:

    09-Dec-1991 colinw
        Created

--*/

//
//  Internal version of the ncb layout for mvdm.
//

#include <packon.h>

//
//  Use packing to ensure that the cu union is not forced to word alignment.
//  All elements of this structure are naturally aligned.
//

typedef struct _NCBW {
    UCHAR   ncb_command;            /* command code                   */
    volatile UCHAR   ncb_retcode;   /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    union {
        UCHAR   ncb_callname[NCBNAMSZ];/* blank-padded name of remote */
        struct _CHAIN_SEND {
            WORD ncb_length2;
            PUCHAR ncb_buffer2;
        } ncb_chain;
    } cu;
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (*ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    volatile UCHAR   ncb_cmd_cplt;  /* 0xff => commmand pending       */

    // Make driver specific use of the reserved area of the NCB.
    WORD    ncb_reserved;           /* return to natural alignment    */
    union {
        LIST_ENTRY      ncb_next;   /* queued to worker thread        */
        IO_STATUS_BLOCK ncb_iosb;   /* used for Nt I/O interface      */
    } u;

    HANDLE          ncb_event;      /* HANDLE to Win32 event          */

    //  Extra workspace utilized by the mvdm component.

    WORD ncb_es;                    /* 16 bit address of the real NCB */
    WORD ncb_bx;

    PNCB ncb_original_ncb;          /* 32 bit address of the real NCB */
    DWORD ProtectModeNcb;           /* TRUE if NCB originated in PM   */

    } NCBW, *PNCBW;

#include <packoff.h>

VOID
VrNetbios5c(
    VOID
    );


VOID
VrNetbios5cInterrupt(
    VOID
    );

VOID
VrNetbios5cInitialize(
    VOID
    );

BOOLEAN
IsPmNcbAtQueueHead(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\pif.h ===
/*
 * Structure and equates of PIF files
 */

#define PIFEDITMAXPIF		1024	 /* maximum PIF file size we support */
#define PIFEDITMAXPIFL		1024L

#define PIFNAMESIZE		30
#define PIFSTARTLOCSIZE 	63
#define PIFDEFPATHSIZE		64
#define PIFPARAMSSIZE		64
#define PIFSHPROGSIZE		64
#define PIFSHDATASIZE		64

#define PIFEXTSIGSIZE		16

#define PIFSIZE 		367 /* two bytes less, this is used for checksum */

#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    char unknown;
    char id;
    char name[PIFNAMESIZE];
    short maxmem;
    short minmem;
    char startfile[PIFSTARTLOCSIZE];
    char MSflags;
    char reserved;
    char defpath[PIFDEFPATHSIZE];
    char params[PIFPARAMSSIZE];
    char screen;
    char cPages;
    unsigned char lowVector;
    unsigned char highVector;
    char rows;
    char cols;
    char rowoff;
    char coloff;
    unsigned short sysmem;
    char shprog[PIFSHPROGSIZE];
    char shdata[PIFSHDATASIZE];
    unsigned char behavior;
    unsigned char sysflags;
    } PIFOLD286STR;
#ifndef RC_INVOKED
#pragma pack()
#endif

#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    char extsig[PIFEXTSIGSIZE];
    unsigned short extnxthdrfloff;
    unsigned short extfileoffset;
    unsigned short extsizebytes;
    } PIFEXTHEADER;
#ifndef RC_INVOKED
#pragma pack()
#endif

#define LASTHEADERPTR		0xFFFF
#define STDHDRSIG		"MICROSOFT PIFEX"

#define W386HDRSIG		"WINDOWS 386 3.0"
#define W286HDRSIG30		"WINDOWS 286 3.0"
#define WNTHDRSIG31		"WINDOWS NT  3.1"
/*
 *#define W286HDRSIG31		  "WINDOWS 286 3.1"
 */

#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    char unknown;
    char id;
    char name[PIFNAMESIZE];
    short maxmem;
    short minmem;
    char startfile[PIFSTARTLOCSIZE];
    char MSflags;
    char reserved;
    char defpath[PIFDEFPATHSIZE];
    char params[PIFPARAMSSIZE];
    char screen;
    char cPages;
    unsigned char lowVector;
    unsigned char highVector;
    char rows;
    char cols;
    char rowoff;
    char coloff;
    unsigned short sysmem;
    char shprog[PIFSHPROGSIZE];
    char shdata[PIFSHDATASIZE];
    unsigned char behavior;
    unsigned char sysflags;
    PIFEXTHEADER stdpifext;
    } PIFNEWSTRUCT;
#ifndef RC_INVOKED
#pragma pack()
#endif

/*
 * Windows/386 PIF file extension
 *
 */
#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    short maxmem;
    short minmem;
    unsigned short PfFPriority;
    unsigned short PfBPriority;
    short PfMaxEMMK;
    unsigned short PfMinEMMK;
    short PfMaxXmsK;
    unsigned short PfMinXmsK;
    unsigned long PfW386Flags;
    unsigned long PfW386Flags2;
    unsigned short PfHotKeyScan;
    unsigned short PfHotKeyShVal;
    unsigned short PfHotKeyShMsk;
    unsigned char PfHotKeyVal;
    unsigned char PfHotKeyPad[9];
    char params[PIFPARAMSSIZE];
    } PIF386EXT;
#ifndef RC_INVOKED
#pragma pack()
#endif

/* Bits of PfW386Flags */
#define fEnableClose		0x00000001L
#define fBackground		0x00000002L
#define fExclusive		0x00000004L
#define fFullScreen		0x00000008L
#define fALTTABdis		0x00000020L
#define fALTESCdis		0x00000040L
#define fALTSPACEdis		0x00000080L
#define fALTENTERdis		0x00000100L
#define fALTPRTSCdis		0x00000200L
#define fPRTSCdis		0x00000400L
#define fCTRLESCdis		0x00000800L
#define fPollingDetect		0x00001000L
#define fNoHMA			0x00002000L
#define fHasHotKey		0x00004000L
#define fEMSLocked		0x00008000L
#define fXMSLocked		0x00010000L
#define fINT16Paste		0x00020000L
#define fVMLocked		0x00040000L

/* Bits of PfW386Flags2 */
/*
 *  NOTE THAT THE LOW 16 BITS OF THIS DWORD ARE VDD RELATED!!!!!!!!
 *
 *	You cannot monkey with these bits locations without breaking
 *	all VDDs as well as all old PIF files. SO DON'T MESS WITH THEM.
 *
 */
#define fVidTxtEmulate		0x00000001L
#define fVidNoTrpTxt		0x00000002L
#define fVidNoTrpLRGrfx 	0x00000004L
#define fVidNoTrpHRGrfx 	0x00000008L
#define fVidTextMd		0x00000010L
#define fVidLowRsGrfxMd 	0x00000020L
#define fVidHghRsGrfxMd 	0x00000040L
#define fVidRetainAllo		0x00000080L
/* NOTE THAT ALL OF THE LOW 16 BITS ARE RESERVED FOR VIDEO BITS */


/*
 * Windows/286 PIF file extension
 *
 *
 * Windows 3.00 extension format
 *
 */
#ifndef RC_INVOKED
#pragma pack(1)
#endif
typedef struct {
    short PfMaxXmsK;
    unsigned short PfMinXmsK;
    unsigned short PfW286Flags;
    } PIF286EXT30;
#ifndef RC_INVOKED
#pragma pack()
#endif

/* Bits of PfW286Flags */
#define fALTTABdis286		0x0001
#define fALTESCdis286		0x0002
#define fALTPRTSCdis286 	0x0004
#define fPRTSCdis286		0x0008
#define fCTRLESCdis286		0x0010
/*
 * Following bit is version >= 3.10 specific
 */
#define fNoSaveVid286		0x0020

#define fCOM3_286		0x4000
#define fCOM4_286		0x8000

/*
 *
 * NEW Windows 3.10 extension format
 *
 *#ifndef RC_INVOKED
 *#pragma pack(1)
 *#endif
 *typedef struct {
 *    short PfMaxEmsK;
 *    unsigned short PfMinEmsK;
 *    } PIF286EXT31;
 *#ifndef RC_INVOKED
 *#pragma pack()
 *#endif
 */

/* Windows NT extension format */
#ifndef RC_INVOKED
#pragma pack (1)                          
#endif
typedef struct                            
   {                                      
   DWORD dwWNTFlags;                      
   DWORD dwRes1;                          
   DWORD dwRes2;                          
   char  achConfigFile[PIFDEFPATHSIZE];   
   char  achAutoexecFile[PIFDEFPATHSIZE]; 
   } PIFWNTEXT;                           
#ifndef RC_INVOKED
#pragma pack()                            
#endif
#define PIFWNTEXTSIZE sizeof(PIFWNTEXT)


// equates for dwWNTFlags
#define NTPIF_SUBSYSMASK        0x0000000F      // sub system type mask
#define SUBSYS_DEFAULT          0
#define SUBSYS_DOS              1
#define SUBSYS_WOW              2
#define SUBSYS_OS2              3
#define COMPAT_TIMERTIC         0x10




/* behavior and sysflags */
#define SWAPS			0x20
#define SWAPMASK		0x20
#define NOTSWAPMASK		0xdf

#define PARMS			0x40
#define PARMMASK		0x40
#define NOTPARMMASK		0xbf

#define SCR			0xC0
#define SCRMASK 		0xC0
#define NOTSCRMASK		0x3f

#define MASK8087		0x20
#define NOTMASK8087		0xdf
#define KEYMASK 		0x10
#define NOTKEYMASK		0xef

/* Microsoft PIF flags */
#define MEMMASK 		0x01
#define NOTMEMMASK		0xfe

#define GRAPHMASK		0x02
#define TEXTMASK		0xfd

#define PSMASK			0x04
#define NOTPSMASK		0xfb

#define SGMASK			0x08
#define NOTSGMASK		0xf7

#define EXITMASK		0x10
#define NOTEXITMASK		0xef

#define DONTUSE 		0x20

#define COM2MASK		0x40
#define NOTCOM2MASK		0xbf

#define COM1MASK		0x80
#define NOTCOM1MASK             0x7f




/*
 *  The pif file formats have been substantially updated since NT4.
 *  The current pif properties is defined in nt\shell\published\inc,
 *  and should be used instead of mvdm\inc\pif.h. Its too late to switch
 *  for XP, do this for next product. For now copy the needed data
 *  structures.
 *
 *  01-Jun-2001 Jonle
 *
 */
#define WENHHDRSIG40     "WINDOWS VMM 4.0"
#define PIFDEFFILESIZE  80

#ifndef LF_FACESIZE
#define LF_FACESIZE     32
#endif

typedef struct tagPIFRECT {
    WORD left;
    WORD top;
    WORD right;
    WORD bottom;
} PIFRECT;
typedef PIFRECT *PPIFRECT;
typedef PIFRECT FAR *LPPIFRECT;


typedef struct PROPTSK {                    /* tsk */
    WORD    flTsk;                          // see TSK_ flags
    WORD    flTskInit;                      // see TSKINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    wReserved4;                     // (reserved, must be zero)
    WORD    wIdleSensitivity;               // %, also affects PfW386Flags & fPollingDetect
} PROPTSK;
typedef UNALIGNED PROPTSK *PPROPTSK;
typedef UNALIGNED PROPTSK FAR *LPPROPTSK;

typedef struct PROPVID {                    /* vid */
    WORD    flVid;                          // see VID_ flags
    WORD    flVidInit;                      // see VIDINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    cScreenLines;                   // ([NonWindowsApp]:ScreenLines)
} PROPVID;
typedef UNALIGNED PROPVID *PPROPVID;
typedef UNALIGNED PROPVID FAR *LPPROPVID;

typedef struct PROPKBD {                    /* kbd */
    WORD    flKbd;                          // see KBD_ flags
    WORD    flKbdInit;                      // see KBDINIT_ flags
    WORD    msAltDelay;                     // ([386Enh]:AltKeyDelay)
    WORD    msAltPasteDelay;                // ([386Enh]:AltPasteDelay)
    WORD    msPasteDelay;                   // ([386Enh]:KeyPasteDelay)
    WORD    msPasteFullDelay;               // ([386Enh]:KeyBufferDelay)
    WORD    msPasteTimeout;                 // ([386Enh]:KeyPasteTimeOut)
    WORD    cPasteSkip;                     // ([386Enh]:KeyPasteSkipCount)
    WORD    cPasteCRSkip;                   // ([386Enh]:KeyPasteCRSkipCount)
} PROPKBD;
typedef UNALIGNED PROPKBD *PPROPKBD;
typedef UNALIGNED PROPKBD FAR *LPPROPKBD;

typedef struct PROPMSE {                    /* mse */
    WORD    flMse;                          // see MSE_ flags
    WORD    flMseInit;                      // see MSEINIT_ flags
} PROPMSE;
typedef UNALIGNED PROPMSE *PPROPMSE;
typedef UNALIGNED PROPMSE FAR *LPPROPMSE;

typedef struct PROPSND {                    /* snd */                       /* ;Internal */
    WORD    flSnd;                          // see SND_ flags               /* ;Internal */
    WORD    flSndInit;                      // see SNDINIT_ flags           /* ;Internal */
} PROPSND;                                                                  /* ;Internal */
typedef UNALIGNED PROPSND *PPROPSND;                                        /* ;Internal */
typedef UNALIGNED PROPSND FAR *LPPROPSND;                                   /* ;Internal */

typedef struct PROPFNT {                    /* fnt */
    WORD    flFnt;                          // see FNT_ flags
    WORD    flFntInit;                      // see FNTINIT_ flags
    WORD    cxFont;                         // width of desired font
    WORD    cyFont;                         // height of desired font
    WORD    cxFontActual;                   // actual width of desired font
    WORD    cyFontActual;                   // actual height of desired font
    CHAR    achRasterFaceName[LF_FACESIZE]; // name to use for raster font
    CHAR    achTTFaceName[LF_FACESIZE];     // name to use for tt font
    WORD    wCurrentCP;                     // Current Codepage
} PROPFNT;
typedef UNALIGNED PROPFNT *PPROPFNT;
typedef UNALIGNED PROPFNT FAR *LPPROPFNT;

typedef struct PROPWIN {                    /* win */
    WORD    flWin;                          // see WIN_ flags
    WORD    flWinInit;                      // see WININIT flags
    WORD    cxCells;                        // width in cells
    WORD    cyCells;                        // height in cells
    WORD    cxClient;                       // width of client window
    WORD    cyClient;                       // height of client window
    WORD    cxWindow;                       // width of entire window
    WORD    cyWindow;                       // height of entire window
    WORD    wLength;
    WORD    wShowFlags;
    WORD    wShowCmd;
    WORD    xMinimize;
    WORD    yMinimize;
    WORD    xMaximize;
    WORD    yMaximize;
    PIFRECT rcNormal;
} PROPWIN;
typedef UNALIGNED PROPWIN *PPROPWIN;
typedef UNALIGNED PROPWIN FAR *LPPROPWIN;


typedef struct PROPENV {                    /* env */
    WORD    flEnv;                          // see ENV_ flags
    WORD    flEnvInit;                      // see ENVINIT_ flags
    CHAR    achBatchFile[PIFDEFFILESIZE];   //
    WORD    cbEnvironment;                  // ([386Enh]:CommandEnvSize)
    WORD    wMaxDPMI;                       // (NEW)
} PROPENV;
typedef UNALIGNED PROPENV *PPROPENV;
typedef UNALIGNED PROPENV FAR *LPPROPENV;


typedef struct WENHPIF40 {                  /* enh */                       /* ;Internal */
    DWORD   dwEnhModeFlagsProp;             // PROPPRG data (subset)        /* ;Internal */
    DWORD   dwRealModeFlagsProp;            // PROPPRG data (subset)        /* ;Internal */
    CHAR    achOtherFileProp[PIFDEFFILESIZE];//PROPPRG data (subset)        /* ;Internal */
    CHAR    achIconFileProp[PIFDEFFILESIZE];// PROPPRG data (subset)        /* ;Internal */
    WORD    wIconIndexProp;                 // PROPPRG data (subset)        /* ;Internal */
    PROPTSK tskProp;                        // PROPTSK data                 /* ;Internal */
    PROPVID vidProp;                        // PROPVID data                 /* ;Internal */
    PROPKBD kbdProp;                        // PROPKBD data                 /* ;Internal */
    PROPMSE mseProp;                        // PROPMSE data                 /* ;Internal */
    PROPSND sndProp;                        // PROPSND data                 /* ;Internal */
    PROPFNT fntProp;                        // PROPFNT data                 /* ;Internal */
    PROPWIN winProp;                        // PROPWIN data                 /* ;Internal */
    PROPENV envProp;                        // PROPENV data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WENHPIF40 version   /* ;Internal */
} WENHPIF40;                                                                /* ;Internal */
typedef UNALIGNED WENHPIF40 *PWENHPIF40;                                    /* ;Internal */
typedef UNALIGNED WENHPIF40 FAR *LPWENHPIF40;                               /* ;Internal */




#if defined(NEC_98)
#ifndef _PIFNT_NEC98_
#define _PIFNT_NEC98_
/*****************************************************************************/
/*   Windows 3.1 PIF file extension for NEC PC-9800                          */
/*****************************************************************************/
/* For Header signature. */

#define W30NECHDRSIG "WINDOWS NEC 3.0"

/* Real Extended Structire for NEC PC-9800 */

#ifndef RC_INVOKED
#pragma pack (1) 
#endif
typedef struct {
    BYTE cPlaneFlags;     
    BYTE cNecFlags;       // +1
    BYTE cVCDFlags;       // +2
    BYTE EnhExtBit;       // +3
    BYTE Extcont;         // +4 byte
    BYTE cReserved[27];   // reserved
    } PIFNECEXT;          // all = 32bytes
#ifndef RC_INVOKED
#pragma pack() 
#endif
#define PIFNECEXTSIZE sizeof(PIFNECEXT)
/*-----------------------------------------------------------------------------
  cPlaneFlags (8 bit)

         0 0 0 0 X X X X
         | | | | | | | +-- Plane 0{On/Off}
         | | | | | | +---- Plane 1{On/Off}
         | | | | | +------ Plane 2{On/Off}
         | | | | +-------- Plane 3{On/Off}
         +-+-+-+---------- Reserved for 256 color

-----------------------------------------------------------------------------*/

#define P0MASK 0x01                   /* plane 1 <ON>   */
#define NOTP0MASK 0xfe                /* plane 1 <OFF>  */

#define P1MASK 0x02                   /* plane 2 <ON>   */
#define NOTP1MASK 0xfd                /* plane 2 <OFF>  */

#define P2MASK 0x04                   /* plane 3 <ON>   */
#define NOTP2MASK 0xfb                /* plane 3 <OFF>  */

#define P3MASK 0x08                   /* plane 4 <ON>   */
#define NOTP3MASK 0xf7                /* plane 4 <OFF>  */

/*-----------------------------------------------------------------------------
    cNECFLAGS (8 bit)
 
         X 0 0 X X X X X
         | | | | | | | +-- CRTC tracer
         | | | | | | +---- screen info trans.o0:text /1:graph or textp
         | | | | | +------ N/H Dynamic1 (N?H:0 H/N:1)
         | | | | +-------- N/H Dynamic2 (H:0 N:1)
         | | | +---------- graph on window
         | +-+------------ Reserved
         +---------------- EMM large page frame
-----------------------------------------------------------------------------*/

#define CRTCMASK 0x01           /* CRTC <ON>        */
#define NOTCRTCMASK 0xfe        /* CRTC <OFF>        */

#define EXCHGMASK 0x02          /* Screen Exchange <GRPH ON>  */
#define NOTEXCHGMASK 0xfd       /* Screen Exchange <GRPH OFF> */

#define EMMLGPGMASK 0x80        /* EMM Large Page Frame <ON>  */
#define NOTEMMLGPGMASK 0x7f     /* EMM Large Page Frame <OFF> */

#define NH1MASK 0x04            /* N/H Dynamic1  <N/H> (UpdateNECScreen)*/
#define NOTNH1MASK 0xfb         /* N/H Dynamic1  <N?H> (UpdateNECScreen)*/

#define NH2MASK 0x08            /* N/H Dynamic2  < N > (UpdateNECScreen)*/
#define NOTNH2MASK 0xf7         /* N/H Dynamic2  < H > (UpdateNECScreen)*/

#define WINGRPMASK 0x10         /* door mado 1992 9 14 */
#define NOTWINGRPMASK 0xef      /*                     */

/*-----------------------------------------------------------------------------
  cVCDFlags (8 bit)

         0 0 0 0 X X X X
         | | | | | | | +-- 0/1 RS / CS
         | | | | | | +---- 0/1 Xon / Xoff
         | | | | | +------ 0/1 ER/DR
         | | | | +-------- Port(Reserved)
         | | | +---------- Port(Reserved)
         +-+-+-+---------- Reserved

------------------------------------------------------------------------------*/
#define VCDRSCSMASK 0x001                /* 0/1 RS/CS   handshake */
#define NOTVCDRSCSMASK 0xfe

#define VCDXONOFFMASK 0x02               /* 0/1 Xon/off handshake */
#define NOTVCDXONOFFMASK 0xfd

#define VCDERDRMASK 0x04                 /* 0/1 ER/DR   handshake */
#define NOTVCDERDRMASK 0xfb

/* Now Only Reserved */
                                         /* port assign */
#define VCDPORTASMASK 0x18               /* 00:none                */
#define NOTVCDPORTASMASK 0xe7            /* 01:port1port2        */
                                         /* 10:port1port3        */
                                         /* 11:unused              */

/*-----------------------------------------------------------------------------
  EnhExtBit (8 bit)

         X 0 0 X X X X X
         | | | | | | | +-- Mode F/F (Yes:0 No:1)
         | | | | | | +---- Display/Draw (Yes:0 No:1)
         | | | | | +------ ColorPallett (Yes:0 No:1)
         | | | | +-------- GDC (Yes:0 No:1)
         | | | +---------- Font (Yes:0 No:1)
         | +-+-+---------- Reserved
         +---------------- All is set/not(Set:1 No:0)

------------------------------------------------------------------------------*/
#define MODEFFMASK  0x01
#define NOTMODEFFMASK 0xfe

#define DISPLAYDRAWMASK 0x02            /* 0/1 Xon/off handhshake */
#define NOTDISPLAYDRAWMASK 0xfd

#define COLORPALLETTMASK 0x04           /* 0/1 ER/DR   handshake */
#define NOTCOLORPALLETTMASK 0xfb

#define GDCMASK 0x08
#define NOTGDCMASK 0xf7

#define FONTMASK 0x10
#define NOTFONTMASK 0xef

#define VDDMASK  0x80
#define NOTVDDMASK  0x7f

/*-----------------------------------------------------------------------------
  Extcont (8 bit)

        0 0 0 0 X X X X
        | | | | | | | +-- Mode F/F (8Color:0 16Color:1)
        | | | | | | +---- Reserved
        | | | | | +------ GDC TEXT (ON:1 OFF:0)
        | | | | +-------- GDC GRPH (ON:1 OFF:0)
        +-+-+-+---------- Reserved

------------------------------------------------------------------------------*/
#define  MODEFF16   0x01
#define  MODEFF8    0xfe

#define  GDCTEXTMASK    0x04
#define  NOTGDCTEXTMASK  0xfb

#define GDCGRPHMASK    0x08
#define NOTGDCGRPHMASK  0xf7

/*-----------------------------------------------------------------------------
    Reserved(8 bit)
 
         0 0 0 0 0 0 0 0
         | | | | | | | |
         +-+-+-+-+-+-+-+-- Reserved

-----------------------------------------------------------------------------*/
/*        unused        */

/*****************************************************************************/
/*  Windows NT 3.1 PIF file extension for NEC PC-9800                        */
/*****************************************************************************/
/*  For Header signature.  */

#define WNTNECHDRSIG   "WINDOWS NT31NEC"

/* Real Extended Structire for NEC PC-9800 */

#ifndef RC_INVOKED
#pragma pack (1)   
#endif
typedef struct {
 BYTE   cFontFlags;
 BYTE   cReserved[31];   // reserved
 } PIFNTNECEXT;   // all = 32bytes
#ifndef RC_INVOKED
#pragma pack()        
#endif
#define PIFNTNECEXTSIZE sizeof(PIFNTNECEXT)
/*-----------------------------------------------------------------------------
    cFontFlags (8 bit)
 
         0 0 0 0 0 0 0 X
         | | | | | | | +-- N mode compatible font(default:FALSE)
         +-+-+-+-+-+-+---- Reserved
-----------------------------------------------------------------------------*/

#define NECFONTMASK  0x01  /* NEC Font <ON>  */
#define NONECFONTMASK  0xfe  /* NEC Font <OFF>  */

/*-----------------------------------------------------------------------------
    Reserved(8 bit)[31]
 
         0 0 0 0 0 0 0 0
         | | | | | | | |
         +-+-+-+-+-+-+-+-- Reserved

-----------------------------------------------------------------------------*/
/*        unused        */

#endif // !_PIFNT_NEC98_
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

# Make sure this is done before continuing on.
SYNCHRONIZE_BLOCK=1

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\sharewow.h ===
// Some nice shared memory macros
//
// Changed by DaveHart 25-Feb-96 so that the shared memory
// is kept open and mapped for the duration of the process.
// At the same time added needed synchronization.
//

#define LOCKSHAREWOW()           LockWowSharedMemory()
#define UNLOCKSHAREWOW()         ReleaseMutex(hSharedWOWMutex)

#define MAX_SHARED_OBJECTS  200

typedef struct _SHAREDTASKMEM {
    BOOL             fInitialized;
    DWORD            dwFirstProcess; // Offset into shared memory where 1st shared process struct begins
} SHAREDTASKMEM, *LPSHAREDTASKMEM;

typedef struct _SHAREDPROCESS {
    DWORD   dwType;
    DWORD   dwProcessId;
    DWORD   dwAttributes;           // WOW_SYSTEM for shared WOW
    DWORD   dwNextProcess;          // Offset into shared memory where next shared process struct begins
    DWORD   dwFirstTask;            // Offset into shared memory where 1st task for this process begins
    LPTHREAD_START_ROUTINE pfnW32HungAppNotifyThread;  // For VDMTerminateTaskWOW
} SHAREDPROCESS, *LPSHAREDPROCESS;

typedef struct _SHAREDTASK {
    DWORD   dwType;
    DWORD   dwThreadId;
    WORD    hTask16;
    WORD    hMod16;
    DWORD   dwNextTask;             // Offset into shared memory where next task for this process begins
    CHAR    szModName[9];           // null terminated
    CHAR    szFilePath[128];        // null terminated
} SHAREDTASK, *LPSHAREDTASK;

typedef union _SHAREDMEMOBJECT {
    SHAREDPROCESS   sp;
    SHAREDTASK      st;
    DWORD           dwType;
} SHAREDMEMOBJECT, *LPSHAREDMEMOBJECT;

#define SMO_AVAILABLE   0
#define SMO_PROCESS     1
#define SMO_TASK        2

#ifndef SHAREWOW_MAIN
extern HANDLE hSharedWOWMem;
extern LPSHAREDTASKMEM lpSharedWOWMem;
extern CHAR szWowSharedMemName[];
extern HANDLE hSharedWOWMutex;
LPSHAREDTASKMEM LockWowSharedMemory(VOID);
#else
HANDLE hSharedWOWMem = NULL;
LPSHAREDTASKMEM lpSharedWOWMem = NULL;
CHAR szWowSharedMemName[] = "msvdmdbg.wow";
CHAR szWowSharedMutexName[] = "msvdmdbg.mtx";
HANDLE hSharedWOWMutex = NULL;

#define MALLOC_SHAREWOW(cb) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)
#define FREE_SHAREWOW(addr) HeapFree(GetProcessHeap(), 0, addr)

BOOL WOWCreateSecurityDescriptor(PSECURITY_DESCRIPTOR* ppsd)
{
   SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
   PSID Anyone = NULL;
   ULONG AclSize;
   ACL* pAcl;
   PSECURITY_DESCRIPTOR psd = NULL;
   BOOL fSuccess = FALSE;

   // -- create world authority

   if (!AllocateAndInitializeSid(&WorldAuthority, 1, SECURITY_WORLD_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &Anyone)) {
      goto Fail;
   }

   // -- calc the size of the ACL (one ace)
   // 1 is one ACE, which includes a single ULONG from SID, since we add the size
   // of any Sids in -- we don't need to count the said ULONG twice
   AclSize = sizeof(ACL) + (1 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
             GetLengthSid(Anyone);

   psd = (PSECURITY_DESCRIPTOR)MALLOC_SHAREWOW(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
   if (NULL == psd) {
      goto Fail;
   }

   pAcl = (ACL*)((BYTE*)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);
   if (!InitializeAcl(pAcl, AclSize, ACL_REVISION)) {
      goto Fail;
   }


   if (!AddAccessAllowedAce(pAcl,
                           ACL_REVISION,
                           (SPECIFIC_RIGHTS_ALL|STANDARD_RIGHTS_ALL)
                               & ~(WRITE_DAC|WRITE_OWNER),
                           Anyone)) {
      goto Fail;
   }

   InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION);
   if (!SetSecurityDescriptorDacl(psd, TRUE, pAcl, FALSE)) {
      goto Fail;
   }

   *ppsd = psd;
   fSuccess = TRUE;

Fail:
   if (!fSuccess && NULL != psd) {
      FREE_SHAREWOW(psd);
   }
   if (NULL != Anyone) {
      FreeSid(Anyone);
   }
   return(fSuccess);
}




LPSHAREDTASKMEM LockWowSharedMemory(VOID)
{
    DWORD dwWaitResult;
    LPSHAREDTASKMEM RetVal = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_ATTRIBUTES sa;

    if (!WOWCreateSecurityDescriptor(&psd)) {
       goto Fail;
    }

    RtlZeroMemory(&sa, sizeof sa);
    sa.nLength = sizeof sa;
    sa.lpSecurityDescriptor = psd;

    if (! lpSharedWOWMem ) {

        if (!hSharedWOWMutex) {
           hSharedWOWMutex = OpenMutex(SYNCHRONIZE, FALSE, szWowSharedMutexName);
           if (!hSharedWOWMutex) {
              hSharedWOWMutex = CreateMutex(&sa, FALSE, szWowSharedMutexName);  // will open if exists
           }

           if (! hSharedWOWMutex) {
              goto Fail;
           }
        }

        if (! hSharedWOWMem) {
            hSharedWOWMem = OpenFileMapping(
                               FILE_MAP_WRITE,
                               FALSE,
                               szWowSharedMemName);
            if (!hSharedWOWMem) {
               hSharedWOWMem = CreateFileMapping(          // will open if it exists
                    (HANDLE)-1,
                    &sa,
                    PAGE_READWRITE,
                    0,
                    sizeof(SHAREDTASKMEM) +
                      (MAX_SHARED_OBJECTS *
                       sizeof(SHAREDMEMOBJECT)),
                    szWowSharedMemName);
            }

            if (! hSharedWOWMem) {
                goto Fail;
            }
        }

        lpSharedWOWMem = MapViewOfFile(hSharedWOWMem, FILE_MAP_WRITE, 0, 0, 0);
        if (! lpSharedWOWMem) {
            goto Fail;
        }
    }

    dwWaitResult = WaitForSingleObject(hSharedWOWMutex, INFINITE);

    if (dwWaitResult != WAIT_OBJECT_0 && dwWaitResult != WAIT_ABANDONED) {
        goto Fail;
    }

    RetVal = lpSharedWOWMem;
    goto Succeed;

Fail:
    if (! RetVal) {
        if (hSharedWOWMutex) {
            CloseHandle(hSharedWOWMutex);
            hSharedWOWMutex = NULL;
        }
        if (lpSharedWOWMem) {
            UnmapViewOfFile(lpSharedWOWMem);
            lpSharedWOWMem = NULL;
        }
        if (hSharedWOWMem) {
            CloseHandle(hSharedWOWMem);
            hSharedWOWMem = NULL;
        }
    }

Succeed:
    if (NULL != psd) {
       FREE_SHAREWOW(psd);
    }

    return RetVal;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\softpc.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    SOFTPC.H

Abstract:

    High-level include file for components interfacing to SoftPC

Author:

    Dave Hastings (daveh) 25-Apr-1991

Revision History:
    Sudeep Bharati        23-Aug-1991  Added SOFTPC_BLD
    Matt Felton            8-FEB-1992  Added getIntelRegistersPointer
    Jonle                 18-Sep-1992  Add popup for unsupported functionality
    Jonle                 21-Nov-1992  Add Standard Resource Error Dialog Box
                                           GetPIFConfigFiles

--*/


/********** COMMON STUFF FOR MIPS AND V86 *************/

/* XLATOFF */
#ifdef i386
#include "v86def.h"
#endif

#include <vdm.h>

extern VOID SbReinitialize(PCHAR, DWORD);

/* XLATON */
extern VOID nt_block_event_thread(ULONG);
extern VOID nt_resume_event_thread(VOID);
/* notification of PDB(Process Data Block, A.K.A PSP) termination */
extern VOID HostTerminatePDB(USHORT pdb);
/* disk subsystem reset notification. These functions will close all
 * outstanding opened handles for DASD(Direct AcceS Disk) */
extern VOID HostFloppyReset(VOID);
extern VOID HostFdiskReset(VOID);

#if defined(NEC_98)
extern USHORT nt_get_cursor_pos(VOID);
#endif

// unsupported services dialog box
extern VOID host_direct_access_error(ULONG);

extern VOID host_lpt_flush_initialize(VOID);

#define NOSUPPORT_FLOPPY      0
#define NOSUPPORT_HARDDISK    1
#define NOSUPPORT_DRIVER      2
#define NOSUPPORT_OLDPIF      3
#define NOSUPPORT_ILLBOP      4
#define NOSUPPORT_NOLIM       5
#define NOSUPPORT_MOUSEDRVR   6

// standard error dialog box using resources
void RcErrorDialogBox(USHORT wId, CHAR *msg1, CHAR *msg2);


/*
 *  RcMessageBox\EditBox stuff
 */
#define RMB_ABORT        1
#define RMB_RETRY        2
#define RMB_IGNORE       4
#define RMB_ICON_INFO    8
#define RMB_ICON_BANG   16
#define RMB_ICON_STOP   32
#define RMB_ICON_WHAT   64
#define RMB_EDIT       128
#define RMB_FLAGS_MASK 0x0000FFFF
#define RMB_EDITBUFFERSIZE_MASK 0xFFFF0000
// hiword of dwOptions is reserved for RMB_EDIT text buffer size

int RcMessageBox(USHORT wId, CHAR *msg1, CHAR *msg2, ULONG dwOptions);


// sudeepb 02-May-1993 these following defines are actually defined
// in host\inc\error.h and host\inc\nt_uis.h. this stuff needs
// major cleanup after product 1.0.

#define EG_MALLOC_FAILURE       7
#define EG_PIF_BAD_FORMAT      18
#define EG_PIF_STARTDIR_ERR    19
#define EG_PIF_STARTFILE_ERR   20
#define EG_PIF_CMDLINE_ERR     21
#define EG_PIF_ASK_CMDLINE     22
#define EG_ENVIRONMENT_ERR     23
#define EG_BAD_FAULT           27
#define EG_DOS_PROG_EXTENSION  28

#define ED_BADSYSFILE           336
#define ED_INITMEMERR           337
#define ED_INITTMPFILE          338


//
// SysErrorBox stuff -- duplicated in usersrv.h *and* kernel.inc
//
#define  SEB_OK         1  /* Button with "OK".     */
#define  SEB_CANCEL     2  /* Button with "Cancel"  */
#define  SEB_YES        3  /* Button with "&Yes"     */
#define  SEB_NO         4  /* Button with "&No"      */
#define  SEB_RETRY      5  /* Button with "&Retry"   */
#define  SEB_ABORT      6  /* Button with "&Abort"   */
#define  SEB_IGNORE     7  /* Button with "&Ignore"  */
#define  SEB_CLOSE      8  /* Button with "&Close"   */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

ULONG WOWSysErrorBox(
    LPSTR  szTitle,
    LPSTR  szMessage,
    USHORT wBtn1,
    USHORT wBtn2,
    USHORT wBtn3
    );

// Called by WOW to force VdmAllocateVirtualMemory to alloc blocks of
// memory with ever increasing linear address's.
VOID SetWOWforceIncrAlloc(
    BOOL iEnable
    );

// call out to softpc to get config.sys\autoexec.bat file names
#ifdef DBCS
VOID GetPIFConfigFiles(BOOL bConfig, char *pchFileName, BOOL bFreMem);
#else // !DBCS
VOID GetPIFConfigFiles(BOOL bConfig, char *pchFileName);
#endif // !DBCS

// exported interfaces
extern VOID    TerminateVDM (VOID);
extern ULONG   DosSessionId;

// VDD idle callouts
void WaitIfIdle(void);
void WakeUpNow(void);


//
// Constants
//
#define MSW_PE              0x1

/* XLATOFF */
#define ISPESET             (UCHAR) (getMSW() & MSW_PE ? 1 : 0)
/* XLATON */

//
// Macros
//

#define EXPORT

// Flag Register constants

#define FLG_CARRY           0x00000001
#define FLG_CARRY_BIT       0x00000000
#define FLG_PARITY          0x00000004
#define FLG_PARITY_BIT      0x00000003
#define FLG_AUXILIARY       0x00000010
#define FLG_AUXILIARY_BIT   0x00000005
#define FLG_ZERO            0x00000040
#define FLG_ZERO_BIT        0x00000006
#define FLG_SIGN            0x00000080
#define FLG_SIGN_BIT        0x00000007
#define FLG_TRAP            0x00000100

#define FLG_INTERRUPT       0x00000200
#define FLG_INTERRUPT_BIT   0x00000009
#define FLG_DIRECTION       0x00000400
#define FLG_DIRECTION_BIT   0x0000000A
#define FLG_OVERFLOW        0x00000800
#define FLG_OVERFLOW_BIT    0x0000000B

EXPORT
VOID
host_cpu_init(
     VOID
     );

//EXPORT
//VOID
//sas_init(
//    IN sys_addr Size
//    );

EXPORT
VOID
host_simulate(
    VOID
    );

HANDLE
host_CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

VOID
cpu_createthread(
    HANDLE   hThread,
    PVDM_TIB VdmTib
    );

VOID
host_ExitThread(
    DWORD dwExitCode
    );


EXPORT VOID host_com_close(int PortId);
EXPORT int SuspendTimerThread(VOID);
EXPORT int ResumeTimerThread(VOID);

void *ch_malloc(unsigned int NumBytes);


UCHAR *Sim32pGetVDMPointer(ULONG addr, UCHAR pm);
#define Sim32GetVDMPointer(Addr,Size,Mode) Sim32pGetVDMPointer(Addr,Mode)

#ifdef i386

/********** FOR V86 BUILD *************/

BOOL
ThreadSetDebugContext(
    PULONG pDebugRegisters
    );

BOOL
ThreadGetDebugContext(
    PULONG pDebugRegisters
    );

// external data

extern ULONG      IntelBase;        // used by memory access macros
extern X86CONTEXT IntelRegisters;   // used by register access macros
extern ULONG      VdmDebugLevel;    // used to control debugging
extern ULONG      VdmFeatureBits;


// Register access macros

#ifdef LINKED_INTO_MONITOR

#include <vdm.h>

#define DECLARE_LocalVdmContext VDM_TIB * _LocalVdmTib = (VDM_TIB *)(NtCurrentTeb()->Vdm); \
                                CONTEXT * _LocalVdmContext = &(*_LocalVdmTib).VdmContext

#ifndef FAST_VDM_REGISTERS

#define getEAX()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax)
#define getAX()     ((USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax))
#define getAL()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax))
#define getAH()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax >> 8))
#define getEBX()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx)
#define getBX()     ((USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx))
#define getBL()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx))
#define getBH()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx >> 8))
#define getECX()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx)
#define getCX()     ((USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx))
#define getCL()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx))
#define getCH()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx >> 8))
#define getEDX()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx)
#define getDX()     ((USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx))
#define getDL()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx))
#define getDH()     ((BYTE)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx >> 8))
#define getESP()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp)
#define getSP()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp)
#define getEBP()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp)
#define getBP()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp)
#define getESI()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi)
#define getSI()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi)
#define getEDI()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi)
#define getDI()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi)
#define getEIP()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip)
#define getIP()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip)
#define getCS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegCs)
#define getSS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegSs)
#define getDS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegDs)
#define getES()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegEs)
#define getFS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegFs)
#define getGS()     ((USHORT)(*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegGs)
#define getCF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_CARRY) ? 1 : 0)
#define getPF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_PARITY) ? 1 : 0)
#define getAF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_AUXILIARY) ? 1 : 0)
#define getZF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_ZERO) ? 1 : 0)
#define getSF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_SIGN) ? 1 : 0)
#define getTF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_TRAP) ? 1 : 0)
#define getIF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_INTERRUPT) ? 1 : 0)
#define getDF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_DIRECTION) ? 1 : 0)
#define getOF()     (((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & FLG_OVERFLOW) ? 1 : 0)
#define getMSW()    ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).IntelMSW)
#define getSTATUS() (USHORT)((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags)
#define getEFLAGS() ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags)

#define setEAX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax = val;}

#define setAX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setAH(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setAL(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eax & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setEBX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx = val ;}

#define setBX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setBH(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setBL(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebx & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setECX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx = val ;}

#define setCX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setCH(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setCL(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ecx & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setEDX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx = val ;}

#define setDX(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setDH(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setDL(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edx & 0xFFFFFF00) |                                ((ULONG)val & 0x000000FF);}

#define setESP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp = val ;}

#define setSP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esp & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setEBP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp = val;}

#define setBP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Ebp & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setESI(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi = val ;}

#define setSI(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Esi & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}
#define setEDI(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi = val ;}

#define setDI(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Edi & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setEIP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip = val ;}

#define setIP(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.Eip & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setCS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegCs = (ULONG) val & 0x0000FFFF ;}

#define setSS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegSs = (ULONG) val & 0x0000FFFF ;}

#define setDS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegDs = (ULONG) val & 0x0000FFFF ;}

#define setES(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegEs = (ULONG) val & 0x0000FFFF ;}

#define setFS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegFs = (ULONG) val & 0x0000FFFF ;}

#define setGS(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.SegGs = (ULONG) val & 0x0000FFFF ;}

#define setCF(val)  {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_CARRY) |                                (((ULONG)val << FLG_CARRY_BIT) & FLG_CARRY);}

#define setPF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_PARITY) |                                (((ULONG)val << FLG_PARITY_BIT) & FLG_PARITY);}

#define setAF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_AUXILIARY) |                                (((ULONG)val << FLG_AUXILIARY_BIT) & FLG_AUXILIARY);}

#define setZF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_ZERO) |                                (((ULONG)val << FLG_ZERO_BIT) & FLG_ZERO);}

#define setSF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_SIGN) |                                (((ULONG)val << FLG_SIGN_BIT) & FLG_SIGN);}

#define setIF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_INTERRUPT) |                                (((ULONG)val << FLG_INTERRUPT_BIT) & FLG_INTERRUPT);}

#define setDF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_DIRECTION) |                                (((ULONG)val << FLG_DIRECTION_BIT) & FLG_DIRECTION);}

#define setOF(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & ~FLG_OVERFLOW) |                                (((ULONG)val << FLG_OVERFLOW_BIT) & FLG_OVERFLOW);}

#define setMSW(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).IntelMSW = val ;}

#define setSTATUS(val) { (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags & 0xFFFF0000) | val;}

#define setEFLAGS(val) { (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).VdmContext.EFlags = val;}

#else // FAST_VDM_REGISTERS

#define getEAX()     (_LocalVdmContext->Eax)
#define getAX()     ((USHORT)(_LocalVdmContext->Eax))
#define getAL()     ((BYTE)(_LocalVdmContext->Eax))
#define getAH()     ((BYTE)(_LocalVdmContext->Eax >> 8))
#define getEBX()    (_LocalVdmContext->Ebx)
#define getBX()     ((USHORT)(_LocalVdmContext->Ebx))
#define getBL()     ((BYTE)(_LocalVdmContext->Ebx))
#define getBH()     ((BYTE)(_LocalVdmContext->Ebx >> 8))
#define getECX()    (_LocalVdmContext->Ecx)
#define getCX()     ((USHORT)(_LocalVdmContext->Ecx))
#define getCL()     ((BYTE)(_LocalVdmContext->Ecx))
#define getCH()     ((BYTE)(_LocalVdmContext->Ecx >> 8))
#define getEDX()    (_LocalVdmContext->Edx)
#define getDX()     ((USHORT)(_LocalVdmContext->Edx))
#define getDL()     ((BYTE)(_LocalVdmContext->Edx))
#define getDH()     ((BYTE)(_LocalVdmContext->Edx >> 8))
#define getESP()    (_LocalVdmContext->Esp)
#define getSP()     ((USHORT)_LocalVdmContext->Esp)
#define getEBP()    (_LocalVdmContext->Ebp)
#define getBP()     ((USHORT)_LocalVdmContext->Ebp)
#define getESI()    (_LocalVdmContext->Esi)
#define getSI()     ((USHORT)_LocalVdmContext->Esi)
#define getEDI()    (_LocalVdmContext->Edi)
#define getDI()     ((USHORT)_LocalVdmContext->Edi)
#define getEIP()    (_LocalVdmContext->Eip)
#define getIP()     ((USHORT)_LocalVdmContext->Eip)
#define getCS()     ((USHORT)_LocalVdmContext->SegCs)
#define getSS()     ((USHORT)_LocalVdmContext->SegSs)
#define getDS()     ((USHORT)_LocalVdmContext->SegDs)
#define getES()     ((USHORT)_LocalVdmContext->SegEs)
#define getFS()     ((USHORT)_LocalVdmContext->SegFs)
#define getGS()     ((USHORT)_LocalVdmContext->SegGs)
#define getCF()     ((_LocalVdmContext->EFlags & FLG_CARRY) ? 1 : 0)
#define getPF()     ((_LocalVdmContext->EFlags & FLG_PARITY) ? 1 : 0)
#define getAF()     ((_LocalVdmContext->EFlags & FLG_AUXILIARY) ? 1 : 0)
#define getZF()     ((_LocalVdmContext->EFlags & FLG_ZERO) ? 1 : 0)
#define getSF()     ((_LocalVdmContext->EFlags & FLG_SIGN) ? 1 : 0)
#define getTF()     ((_LocalVdmContext->EFlags & FLG_TRAP) ? 1 : 0)
#define getIF()     ((_LocalVdmContext->EFlags & FLG_INTERRUPT) ? 1 : 0)
#define getDF()     ((_LocalVdmContext->EFlags & FLG_DIRECTION) ? 1 : 0)
#define getOF()     ((_LocalVdmContext->EFlags & FLG_OVERFLOW) ? 1 : 0)
#define getMSW()     ((*(VDM_TIB *)(NtCurrentTeb()->Vdm)).IntelMSW)
#define getSTATUS() (USHORT)(_LocalVdmContext->EFlags)
#define getEFLAGS() (_LocalVdmContext->EFlags)

#define setEAX(val) {    _LocalVdmContext->Eax = val;}

#define setAX(val) {    _LocalVdmContext->Eax = (_LocalVdmContext->Eax & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setAH(val) {    _LocalVdmContext->Eax = (_LocalVdmContext->Eax & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setAL(val) {    _LocalVdmContext->Eax = (_LocalVdmContext->Eax & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setEBX(val) {    _LocalVdmContext->Ebx = val ;}

#define setBX(val) {    _LocalVdmContext->Ebx = (_LocalVdmContext->Ebx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setBH(val) {    _LocalVdmContext->Ebx = (_LocalVdmContext->Ebx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setBL(val) {    _LocalVdmContext->Ebx = (_LocalVdmContext->Ebx & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setECX(val) {    _LocalVdmContext->Ecx = val ;}

#define setCX(val) {    _LocalVdmContext->Ecx = (_LocalVdmContext->Ecx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setCH(val) {    _LocalVdmContext->Ecx = (_LocalVdmContext->Ecx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setCL(val) {    _LocalVdmContext->Ecx = (_LocalVdmContext->Ecx & 0xFFFFFF00) |                            ((ULONG)val & 0x000000FF);}

#define setEDX(val) {    _LocalVdmContext->Edx = val ;}

#define setDX(val) {    _LocalVdmContext->Edx = (_LocalVdmContext->Edx & 0xFFFF0000) |                            ((ULONG)val & 0x0000FFFF);}

#define setDH(val) {    _LocalVdmContext->Edx = (_LocalVdmContext->Edx & 0xFFFF00FF) |                            ((ULONG)(val << 8) & 0x0000FF00);}

#define setDL(val) {    _LocalVdmContext->Edx = (_LocalVdmContext->Edx & 0xFFFFFF00) |                                ((ULONG)val & 0x000000FF);}

#define setESP(val) {    _LocalVdmContext->Esp = val ;}

#define setSP(val) {    _LocalVdmContext->Esp = (_LocalVdmContext->Esp & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setEBP(val) {    _LocalVdmContext->Ebp = val;}

#define setBP(val) {    _LocalVdmContext->Ebp = (_LocalVdmContext->Ebp & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setESI(val) {    _LocalVdmContext->Esi = val ;}

#define setSI(val) {    _LocalVdmContext->Esi = (_LocalVdmContext->Esi & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}
#define setEDI(val) {    _LocalVdmContext->Edi = val ;}

#define setDI(val) {    _LocalVdmContext->Edi = (_LocalVdmContext->Edi & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setEIP(val) {    _LocalVdmContext->Eip = val ;}

#define setIP(val) {    _LocalVdmContext->Eip = (_LocalVdmContext->Eip & 0xFFFF0000) |                                ((ULONG)val & 0x0000FFFF);}

#define setCS(val) {    _LocalVdmContext->SegCs = (ULONG) val & 0x0000FFFF ;}

#define setSS(val) {    _LocalVdmContext->SegSs = (ULONG) val & 0x0000FFFF ;}

#define setDS(val) {    _LocalVdmContext->SegDs = (ULONG) val & 0x0000FFFF ;}

#define setES(val) {    _LocalVdmContext->SegEs = (ULONG) val & 0x0000FFFF ;}

#define setFS(val) {    _LocalVdmContext->SegFs = (ULONG) val & 0x0000FFFF ;}

#define setGS(val) {    _LocalVdmContext->SegGs = (ULONG) val & 0x0000FFFF ;}

#define setCF(val)  {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_CARRY) |                                (((ULONG)val << FLG_CARRY_BIT) & FLG_CARRY);}

#define setPF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_PARITY) |                                (((ULONG)val << FLG_PARITY_BIT) & FLG_PARITY);}

#define setAF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_AUXILIARY) |                                (((ULONG)val << FLG_AUXILIARY_BIT) & FLG_AUXILIARY);}

#define setZF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_ZERO) |                                (((ULONG)val << FLG_ZERO_BIT) & FLG_ZERO);}

#define setSF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_SIGN) |                                (((ULONG)val << FLG_SIGN_BIT) & FLG_SIGN);}

#define setIF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_INTERRUPT) |                                (((ULONG)val << FLG_INTERRUPT_BIT) & FLG_INTERRUPT);}

#define setDF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_DIRECTION) |                                (((ULONG)val << FLG_DIRECTION_BIT) & FLG_DIRECTION);}

#define setOF(val) {    _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & ~FLG_OVERFLOW) |                                (((ULONG)val << FLG_OVERFLOW_BIT) & FLG_OVERFLOW);}

#define setMSW(val) {    (*(VDM_TIB *)(NtCurrentTeb()->Vdm)).IntelMSW = val ;}

#define setSTATUS(val) { _LocalVdmContext->EFlags = (_LocalVdmContext->EFlags & 0xFFFF0000) | val;}

#define setEFLAGS(val) { _LocalVdmContext->EFlags = val;}

#endif  // FAST_VDM_REGISTERS

#else // not linked into monitor

extern ULONG  getEAX(VOID);
extern USHORT getAX(VOID);
extern UCHAR  getAL(VOID);
extern UCHAR  getAH(VOID);
extern ULONG  getEBX(VOID);
extern USHORT getBX(VOID);
extern UCHAR  getBL(VOID);
extern UCHAR  getBH(VOID);
extern ULONG  getECX(VOID);
extern USHORT getCX(VOID);
extern UCHAR  getCL(VOID);
extern UCHAR  getCH(VOID);
extern ULONG  getEDX(VOID);
extern USHORT getDX(VOID);
extern UCHAR  getDL(VOID);
extern UCHAR  getDH(VOID);
extern ULONG  getESP(VOID);
extern USHORT getSP(VOID);
extern ULONG  getEBP(VOID);
extern USHORT getBP(VOID);
extern ULONG  getESI(VOID);
extern USHORT getSI(VOID);
extern ULONG  getEDI(VOID);
extern USHORT getDI(VOID);
extern ULONG  getEIP(VOID);
extern USHORT getIP(VOID);
extern USHORT getCS(VOID);
extern USHORT getSS(VOID);
extern USHORT getDS(VOID);
extern USHORT getES(VOID);
extern USHORT getFS(VOID);
extern USHORT getGS(VOID);
extern ULONG  getCF(VOID);
extern ULONG  getPF(VOID);
extern ULONG  getAF(VOID);
extern ULONG  getZF(VOID);
extern ULONG  getSF(VOID);
extern ULONG  getIF(VOID);
extern ULONG  getDF(VOID);
extern ULONG  getOF(VOID);
extern USHORT getMSW(VOID);
extern USHORT getSTATUS(VOID);
extern ULONG  getEFLAGS(VOID);

extern VOID setEAX(ULONG);
extern VOID setAX(USHORT);
extern VOID setAH(UCHAR);
extern VOID setAL(UCHAR);
extern VOID setEBX(ULONG);
extern VOID setBX(USHORT);
extern VOID setBH(UCHAR);
extern VOID setBL(UCHAR);
extern VOID setECX(ULONG);
extern VOID setCX(USHORT);
extern VOID setCH(UCHAR);
extern VOID setCL(UCHAR);
extern VOID setEDX(ULONG);
extern VOID setDX(USHORT);
extern VOID setDH(UCHAR);
extern VOID setDL(UCHAR);
extern VOID setESP(ULONG);
extern VOID setSP(USHORT);
extern VOID setEBP(ULONG);
extern VOID setBP(USHORT);
extern VOID setESI(ULONG);
extern VOID setSI(USHORT);
extern VOID setEDI(ULONG);
extern VOID setDI(USHORT);
extern VOID setEIP(ULONG);
extern VOID setIP(USHORT);
extern VOID setCS(USHORT);
extern VOID setSS(USHORT);
extern VOID setDS(USHORT);
extern VOID setES(USHORT);
extern VOID setFS(USHORT);
extern VOID setGS(USHORT);
extern VOID setCF(ULONG);
extern VOID setPF(ULONG);
extern VOID setAF(ULONG);
extern VOID setZF(ULONG);
extern VOID setSF(ULONG);
extern VOID setIF(ULONG);
extern VOID setDF(ULONG);
extern VOID setOF(ULONG);
extern VOID setMSW(USHORT);
extern VOID setSTATUS(USHORT);
extern VOID setEFLAGS(ULONG);
#endif

//
// Sim32 macros
//

// no action is required for this macro.
#define Sim32FlushVDMPointer( address, size, buffer, mode ) TRUE

// no action is required for this macro.
#define Sim32FreeVDMPointer( address, size, buffer, mode) TRUE

#define Sim32GetVDMMemory( address, size, buffer, mode) (memcpy(  \
    buffer, Sim32pGetVDMPointer(address, mode), size), TRUE)

#define Sim32SetVDMMemory( address, size, buffer, mode) (memcpy( \
    Sim32pGetVDMPointer(address, mode), buffer, size), TRUE)

// Address conversion macros

#define RMOFF(address) (WORD)((ULONG)address & 0x0000FFFF)
#define RMSEG(address) (WORD)(((ULONG)address - ((ULONG)address & 0x0000FFFF)) >> 4)
#define RMSEGOFFTOLIN(seg, off) (PVOID)(IntelBase + ((ULONG)(seg) << 4) + (ULONG)(off))

// Debugging Macros

#define VDprint(value, arg) { if (value <= (VdmDebugLevel & VDP_LEVEL_MASK)) {\
                                         DbgPrint arg ; }}

#define VDbreak(value) { if (value <= (VDB_LEVEL_MASK & VdmDebugLevel)) {\
                                         DbgBreakPoint(); }}

#define VDP_LEVEL_MASK          0x0F
#define VDP_LEVEL_NONE          0x0
#define VDP_LEVEL_ERROR         0x2
#define VDP_LEVEL_WARNING       0x4
#define VDP_LEVEL_INFO          0x8

#define VDB_LEVEL_MASK          0xF0
#define VDB_LEVEL_NONE          0x00
#define VDB_LEVEL_ERROR         0x20
#define VDB_LEVEL_WARNING       0x40
#define VDB_LEVEL_INFO          0x80

//
//  Function prototypes
//

ULONG
DbgPrint(
    PCH Format,
    ...
    );

char *nt_fgets(char *buffer, int len, void *input_stream);
char *nt_gets(char *buffer);


#define GetVDMAddr(usSeg,usOff)  (((ULONG)usSeg << 4) + usOff)

PX86CONTEXT getIntelRegistersPointer(VOID);

#else

/*********************** FOR MIPS BUILD ***************************/


#define GetVDMAddr(usSeg,usOff) Sim32pGetVDMPointer((ULONG)(((ULONG)usSeg << 16) | usOff),FALSE)

#define RMSEGOFFTOLIN(seg, off) (PVOID)(((ULONG)(seg) << 4) + (ULONG)(off))

extern BOOL     Sim32FlushVDMPointer (ULONG, USHORT, PBYTE , BOOL);
extern BOOL     Sim32FreeVDMPointer (ULONG, USHORT, PBYTE , BOOL);
extern BOOL     Sim32GetVDMMemory (ULONG, USHORT, PBYTE , BOOL);
extern BOOL     Sim32SetVDMMemory (ULONG, USHORT, PBYTE , BOOL);
extern VOID     sas_overwrite_memory(PBYTE, ULONG);

extern UCHAR getAL(VOID);
extern UCHAR getCL(VOID);
extern UCHAR getDL(VOID);
extern UCHAR getBL(VOID);
extern UCHAR getAH(VOID);
extern UCHAR getCH(VOID);
extern UCHAR getDH(VOID);
extern UCHAR getBH(VOID);

extern VOID setAL(UCHAR val);
extern VOID setCL(UCHAR val);
extern VOID setDL(UCHAR val);
extern VOID setBL(UCHAR val);
extern VOID setAH(UCHAR val);
extern VOID setCH(UCHAR val);
extern VOID setDH(UCHAR val);
extern VOID setBH(UCHAR val);

extern USHORT getAX(VOID);
extern USHORT getCX(VOID);
extern USHORT getDX(VOID);
extern USHORT getBX(VOID);
extern USHORT getSP(VOID);
extern USHORT getBP(VOID);
extern USHORT getSI(VOID);
extern USHORT getDI(VOID);
extern USHORT getIP(VOID);

extern VOID setAX(USHORT val);
extern VOID setCX(USHORT val);
extern VOID setDX(USHORT val);
extern VOID setBX(USHORT val);
extern VOID setSP(USHORT val);
extern VOID setBP(USHORT val);
extern VOID setSI(USHORT val);
extern VOID setDI(USHORT val);
extern VOID setIP(USHORT val);

extern ULONG getEAX(VOID);
extern ULONG getECX(VOID);
extern ULONG getEDX(VOID);
extern ULONG getEBX(VOID);
extern ULONG getESP(VOID);
extern ULONG getEBP(VOID);
extern ULONG getESI(VOID);
extern ULONG getEDI(VOID);
extern ULONG getEIP(VOID);

extern VOID setEAX(ULONG val);
extern VOID setECX(ULONG val);
extern VOID setEDX(ULONG val);
extern VOID setEBX(ULONG val);
extern VOID setESP(ULONG val);
extern VOID setEBP(ULONG val);
extern VOID setESI(ULONG val);
extern VOID setEDI(ULONG val);
extern VOID setEIP(ULONG val);

extern USHORT getES(VOID);
extern USHORT getCS(VOID);
extern USHORT getSS(VOID);
extern USHORT getDS(VOID);
extern USHORT getFS(VOID);
extern USHORT getGS(VOID);

extern VOID setES(USHORT val);
extern VOID setCS(USHORT val);
extern VOID setSS(USHORT val);
extern VOID setDS(USHORT val);
extern VOID setFS(USHORT val);
extern VOID setGS(USHORT val);

extern ULONG getAF(VOID);
extern ULONG getCF(VOID);
extern ULONG getDF(VOID);
extern ULONG getIF(VOID);
extern ULONG getOF(VOID);
extern ULONG getPF(VOID);
extern ULONG getSF(VOID);
extern ULONG getTF(VOID);
extern ULONG getZF(VOID);
extern ULONG getIOPL(VOID);
extern ULONG getNT(VOID);
extern USHORT getSTATUS(VOID);
extern ULONG getEFLAGS(VOID);
extern USHORT getMSW(VOID);

extern VOID setAF(ULONG val);
extern VOID setCF(ULONG val);
extern VOID setDF(ULONG val);
extern VOID setIF(ULONG val);
extern VOID setOF(ULONG val);
extern VOID setPF(ULONG val);
extern VOID setSF(ULONG val);
extern VOID setTF(ULONG val);
extern VOID setZF(ULONG val);
extern VOID setIOPL(ULONG val);
extern VOID setNT(ULONG val);
extern VOID setSTATUS(USHORT val);
extern VOID setEFLAGS(ULONG val);
extern VOID setMSW(USHORT val);

extern ULONG getCR0(VOID);
extern VOID setCR0(ULONG val);
extern ULONG getSS_AR(VOID);
extern ULONG getSS_BASE(VOID);
extern VOID setSS_BASE_LIMIT_AR(ULONG base, ULONG limit, ULONG ar);
extern VOID setCPL(ULONG val);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vint.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    VINT.H

Abstract:

    This module contains macro support for manipulating virtual
    interrupt bit from v86 mode and 16bit protect mode. FCLI/FST/FIRET
    result in exact behavior of these instructions on the chip without
    trapping.

Author:

    Sudeepb 08-Dec-1992 Created

Revision History:
    sudeepb 16-Mar-1993 added FIRET

--*/

/*
See \nt\private\inc\vdm.h for a complete list
of the NTVDM state flag bit definitions

INTERRUPT_PENDING_BIT - set if interrupts pending
VIRTUAL_INTERRUPT_BIT - This bit always correctly reflects the interrupt
                        disbale/enable state of the vDM while in 16bit land.

MIPS_BIT_MASK         - tells whether VDM is running on x86/mips
EXEC_BIT_MASK         - tells if DOS is in int21/exec operation.
*/

#define  INTERRUPT_PENDING_BIT      0x0003
#define  VDM_INTS_HOOKED_IN_PM      0x0004
#define  VIRTUAL_INTERRUPT_BIT      0x0200

#define  MIPS_BIT_MASK              0x400
#define  EXEC_BIT_MASK              0x800
#define  RM_BIT_MASK                0x1000
#define  RI_BIT_MASK                0x2000

#if defined(NEC_98)
#define  FIXED_NTVDMSTATE_SEGMENT   0x60                          
#else  // !NEC_98
#define  FIXED_NTVDMSTATE_SEGMENT   0x70
#endif // !NEC_98
#define  FIXED_NTVDMSTATE_OFFSET    0x14
#define  FIXED_NTVDMSTATE_LINEAR    ((FIXED_NTVDMSTATE_SEGMENT << 4) + FIXED_NTVDMSTATE_OFFSET)
#if defined(NEC_98)
#define  FIXED_NTVDMSTATE_REL40     0x214                         
#else  // !NEC_98
#define  FIXED_NTVDMSTATE_REL40     0x314
#endif // !NEC_98

#define  FIXED_NTVDMSTATE_SIZE	    4
#if defined(NEC_98)
#define  NTIO_LOAD_SEGMENT          0x60                          
#else  // !NEC_98
#define  NTIO_LOAD_SEGMENT	    0x70
#endif // !NEC_98
#define  NTIO_LOAD_OFFSET           0
#define  pNtVDMState                ((PULONG)FIXED_NTVDMSTATE_LINEAR)

#define  VDM_TIMECHANGE             0x00400000

/* ASM
; FCLI macro should be used in v86mode/16bit  preotect mode code to replace
; costly cli's. Please note that this macro could destroy the Overflow
; bit in the flag.

FCLI	macro
    local a,b,c
    push    ds
    push    ax
    mov     ax,40h
    mov     ds,ax
    lahf
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b
    lock    and	word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
a:
    sahf
    pop     ax
    pop     ds
    jmp     short c
b:
    cli
    jmp     short a
c:
endm

;
; FSTI macro should be used in v86mode or 16bit protectmode code to replace
; costly sti's. Please note that this macro could destroy the Overflow bit
; in the flag.

FSTI   macro
    local a,b,c
    push    ds
    push    ax
    mov     ax,40h
    mov     ds,ax
    lahf
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, INTERRUPT_PENDING_BIT
    jnz     short b
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b
    lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
a:
    sahf
    pop     ax
    pop     ds
    jmp     short c
b:
    sti
    jmp     short a
c:
endm

FIRET MACRO
    local a,b,d,e,f,g,i,j,k
    push    ds
    push    ax

;; Do real IRET on MIPS or if interrupts are pending

    mov     ax,40h
    mov     ds,ax
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, MIPS_BIT_MASK OR RI_BIT_MASK
    jnz     short b

;; running on x86 can assume 386 or above instructions
    push    bp
    mov     bp,sp
    mov     ax,[bp+10]      ; get flags
    pop     bp
    test    ax,100h         ; test if trap flag is set
    jnz     short b         ; if so, do iret

    test    ax,200h         ; test if interrupt flag is set
    jz      short i         ; ZR -> flag image has IF not set
    lock    or word ptr ds:FIXED_NTVDMSTATE_REL40, VIRTUAL_INTERRUPT_BIT
    test    word ptr ds:FIXED_NTVDMSTATE_REL40, INTERRUPT_PENDING_BIT
    jnz     short b
j:
    xchg    ah,al           ; AH=low byte AL=high byte
    cld
    test    al,4            ; check direction flag
    jnz     short d         ;
e:
    test    al,8            ; check overflow flag
    jnz     short f         ; go to f if flag image has OF set
    jo      short k         ; go to k to reset OF
g:
    sahf                    ; set low byte of flags from ah
    pop     ax
    pop     ds
    retf    2               ; IRET and discard flags
i:
    lock    and word ptr ds:FIXED_NTVDMSTATE_REL40,NOT VIRTUAL_INTERRUPT_BIT
    jmp     short j
f:
    jo      short g         ; all OK if OF bit set in real flag
    ; set the overflow bit in real flag
    push    ax
    mov     al,127
    add     al,2            ; will set OF
    pop     ax
    jmp     short g

k:
    ; reset the OF
    push    ax
    xor     al,al           ; will reset OF
    pop     ax
    jmp     short g
d:
    std
    jmp     short e
b:
    pop     ax
    pop     ds
    iret
endm

 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\suballoc.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    suballoc.h

Abstract:

    This is the public include file for the suballocation
    package.

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1994

Revision History:


--*/

//
// Constants
//

//
// Minimum granularity for the commit routine
//   this is done as a constant rather than a parameter
//   to make defining data structures easier
//
#ifdef i386
#define COMMIT_GRANULARITY 4096
#else
#define COMMIT_GRANULARITY 65536
#endif

//
// Types
//
//
// Routine for committing a specific region of of the address
// space.  Although the return type is NTSTATUS, the only value
// that is checked is 0 (for STATUS_SUCCESS).  If STATUS_SUCCESS
// is returned, it is assumed that the function worked. If not,
// it is assumed that it failed.  No special meaning is attached to
// particular non-zero values.
//
typedef
NTSTATUS 
(*PSACOMMITROUTINE)(
    ULONG BaseAddress,
    ULONG Size
    );
    
//
// Routine for moving memory around in the address space.
// Note:  This routine MUST correctly handle overlapping
//        source and destination
//
typedef 
VOID
(*PSAMEMORYMOVEROUTINE)(
    ULONG Destination,
    ULONG Source,
    ULONG Size
    );

//
// Public prototypes
//
PVOID
SAInitialize(
    ULONG BaseAddress,
    ULONG Size,
    PSACOMMITROUTINE CommitRoutine,
    PSACOMMITROUTINE DecommitRoutine,
    PSAMEMORYMOVEROUTINE MemoryMoveRoutine
    );
    
BOOL 
SAQueryFree(
    PVOID SubAllocation,
    PULONG FreeBytes,
    PULONG LargestFreeBlock
    );
       
BOOL
SAAllocate(
    PVOID SubAllocation,
    ULONG Size,
    PULONG Address
    );
    
BOOL
SAFree(
    PVOID SubAllocation,
    ULONG Size,
    ULONG Address
    );
    
BOOL
SAReallocate(
    PVOID SubAllocation,
    ULONG OriginalSize,
    ULONG OriginalAddress,
    ULONG NewSize,
    PULONG NewAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vrdefld.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdefld.h

Abstract:

    Contains offsets in VDM redir code segment for deferred load address info

Author:

    Richard L Firth (rfirth) 21-Oct-1992

Revision History:

--*/

/* XLATOFF */
#include <packon.h>
/* XLATON */

typedef struct _VDM_LOAD_INFO { /* */
    DWORD   DlcWindowAddr;
    BYTE    VrInitialized;
} VDM_LOAD_INFO;

/* XLATOFF */
#include <packoff.h>
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\v86def.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    V86PC.H

Abstract:

    This file contains macros, function prototypes, and externs for the
    v86-mode NT version of SoftPC v3.0.

Author:

    Dave Hastings (daveh) 4-11-91

Revision History:

    Jeff Parsons (jeffpar) 14-May-1991
    Added X86CONTEXT, which is identical to CONTEXT when running on an
    x86 platform.

--*/


// Define X86CONTEXT structure

typedef CONTEXT X86CONTEXT, *PX86CONTEXT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\tdb16.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  TDB.H
 *  16-bit Kernel Task Data Block
 *
 *  History:
 *  Created 11-Feb-1992 by Matt Felton (mattfe) - from 16 bit tdb.inc
 *       7-apr-1992 mattfe updated to be win 3.1 compatible
 *
--*/

/*
 * NewExeHdr struct offsets. WOW32 uses these for getting expected winversion
 * directly from the exehdr.
 *
 */

#define NE_LOWINVER_OFFSET 0x3e
#define NE_HIWINVER_OFFSET 0x0c
#define FLAG_NE_PROPFONT   0x2000

/*
 * Task Data Block - 16 Bit Kernel Data Structure
 *
 *   Contains all 16 bit task specific data.
 *
 */

#define numTaskInts 7
#define THUNKELEM   8   // (62*8) = 512-16 (low arena overhead)
#define THUNKSIZE   8

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct TDB  {       /* tdb16 */

     WORD TDB_next    ;     // next task in dispatch queue
     WORD TDB_taskSP      ;     // Saved SS:SP for this task
     WORD TDB_taskSS      ;     //
     WORD TDB_nEvents     ;     // Task event counter
     BYTE TDB_priority    ;     // Task priority (0 is highest)
     BYTE TDB_thread_ordinal  ;     // ordinal number of this thread
     WORD TDB_thread_next   ;       // next thread
     WORD TDB_thread_tdb      ; // the real TDB for this task
     WORD TDB_thread_list   ;       // list of allocated thread structures
     WORD TDB_thread_free   ;       // free list of availble thread structures
     WORD TDB_thread_count  ;       // total count of tread structures
     WORD TDB_FCW         ; // Floating point control word
     BYTE TDB_flags   ;     // Task flags
     BYTE TDB_filler      ;     // keep word aligned
     WORD TDB_ErrMode     ;     // Error mode for this task
     WORD TDB_ExpWinVer   ;     // Expected Windows version for this task
     WORD TDB_Module      ;     // Task module handle to free in killtask
     WORD TDB_pModule     ;     // Pointer to the module database.
     WORD TDB_Queue   ;     // Task Event Queue pointer
     WORD TDB_Parent      ;     // TDB of the task that started this up
     WORD TDB_SigAction   ;     // Action for app task signal
     DWORD TDB_ASignalProc   ;      // App's Task Signal procedure address
     DWORD TDB_USignalProc   ;      // User's Task Signal procedure address
     DWORD TDB_GNotifyProc    ; // Task global discard notify proc.
     DWORD TDB_INTVECS[numTaskInts] ;   // Task specfic harare interrupts
     WORD TDB_CompatFlags ;     // Compatibility flags
     WORD TDB_CompatFlags2 ;        // Upper 16 bits
     WORD TDB_CompatHandle ;    // for dBase bug
     WORD TDB_WOWCompatFlagsEx ;     // More WOW Compatibility flags
     WORD TDB_WOWCompatFlagsEx2 ;        // Upper 16 bits
     BYTE TDB_Free[3] ;         // Filler to keep TDB size unchanged
     BYTE TDB_cLibrary    ;     // tracks  add/del of ALL libs in system EMS
     DWORD TDB_PHT        ; // (HANDLE:OFFSET) to private handle table
     WORD TDB_PDB         ; // MSDOS Process Data Block (PDB)
     DWORD TDB_DTA        ; // MSDOS Disk Transfer Address
     BYTE TDB_Drive  ;      // MSDOS current drive
     BYTE TDB_Directory[65] ;       // *** not used starting with win95
     WORD TDB_Validity    ;     // initial AX to be passed to a task
     WORD TDB_Yield_to    ;     // DirectedYield arg stored here
     WORD TDB_LibInitSeg      ; // segment address of libraries to init
     WORD TDB_LibInitOff      ; // MakeProcInstance thunks live here.
     WORD TDB_MPI_Sel     ;     // Code selector for thunks
     WORD TDB_MPI_Thunks[((THUNKELEM*THUNKSIZE)/2)]; //
     BYTE TDB_ModName[8] ;      // Name of Module.
     WORD TDB_sig         ; // Signature word to detect bogus code
     DWORD TDB_ThreadID   ;     // 32-Bit Thread ID for this Task (use TDB_Filler Above)
     DWORD TDB_hThread	  ;	// 32-bit Thread Handle for this task
     WORD  TDB_WOWCompatFlags;  // WOW Compatibility flags
     WORD  TDB_WOWCompatFlags2; // WOW Compatibility flags
#ifdef FE_SB
     WORD  TDB_WOWCompatFlagsJPN;  // WOW Compatibility flags for JAPAN
     WORD  TDB_WOWCompatFlagsJPN2; // WOW Compatibility flags for JAPAN
#endif // FE_SB
     DWORD TDB_vpfnAbortProc;   // printer AbortProc
     BYTE TDB_LFNDirectory[260]; // Long directory name

} TDB;
typedef TDB UNALIGNED *PTDB;

// This bit is defined for the TDB_Drive field
#define TDB_DIR_VALID 0x80
#define TDB_SIGNATURE 0x4454

#define TDBF_OS2APP   0x8
#define TDBF_WINOLDAP 0x1


// NOTE TDB_ThreadID MUST be DWORD aligned or else it will fail on MIPS

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vdmredir.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmredir.h

Abstract:

    Contains common defines, structures, macros, etc. for VdmRedir. This file
    contains macros to read and write the 3 basic data structures from/to VDM
    memory. We *must* use these macros because the MIPS processor does not like
    unaligned data: a DWORD must be read/written on a DWORD boundary (low two
    bits in address = 00), a WORD must be read/written on a WORD boundary (low
    two bits in address = X0) and a BYTE can be read/written to any address (low
    two bits in address = XX). It is illegal to access a WORD at an address
    whose LSB is not 0, and a DWORD at an address whose 2 least significant bits
    are not both 0. Dos programs don't care much about alignment (smart ones do
    because there is a performance penalty for unaligned data on x86, but it
    still works). So we have to assume the worst case for MIPS and break down
    the read/writes of WORDs and DWORDs in VDM memory into BYTE read/writes

    In order to improve efficiency of load/store to potentially unaligned
    addresses, the following data pointer types are made available from this
    include file:

        ULPBYTE     - unaligned byte pointer (same as LPBYTE)
        ULPWORD     - unaligned word pointer
        ULPDWORD    - unaligned dword pointer

    NB. Dependent upon mvdm.h

Author:

    Richard L Firth (rfirth) 16-Sep-1991

Revision History:

    16-Sep-1991 rfirth
        Created

--*/

#ifndef _VDMREDIR_
#define _VDMREDIR_

#include <softpc.h>

//
// PRIVATE - make a routine/data type inaccessible outside current module, but
// only if not DEBUG version
//

#if DBG
#define PRIVATE
#else
#define PRIVATE static
#endif

//
// unaligned data pointer types. These produce exactly the same code as memory
// accesses through 'aligned' pointers on x86, but generate code specific to
// unaligned read/writes on MIPS (& other RISCs)
//

#ifdef UNALIGNED_VDM_POINTERS
typedef BYTE UNALIGNED * ULPBYTE;
typedef WORD UNALIGNED * ULPWORD;
typedef DWORD UNALIGNED * ULPDWORD;
#else
typedef LPBYTE ULPBYTE;
typedef LPWORD ULPWORD;
typedef LPDWORD ULPDWORD;
#endif

//
// misc. defines
//

#define BITS_IN_A_BYTE      8
#define LOCAL_DEVICE_PREFIX "\\\\."

//
//  Define network interrupt to be on Irql 14.
//  If NETWORK_ICA changes to ICA_MASTER then vrnetb.c should only execute 1 eoi
//  If either change then NETWORK_INTERRUPT in int5c.inc must also change.
//

#if defined(NEC_98)
#define NETWORK_ICA     ICA_MASTER
#define NETWORK_LINE    5
#else
#define NETWORK_ICA     ICA_SLAVE
#define NETWORK_LINE    2
#endif

//
// helper macros
//

//
// MAKE_DWORD - converts 2 16-bit words into a 32-bit double word
//
#define MAKE_DWORD(h, l)                ((DWORD)(((DWORD)((WORD)(h)) << 16) | (DWORD)((WORD)(l))))

//
// DWORD_FROM_WORDS - converts two 16-bit words into a 32-bit dword
//
#define DWORD_FROM_WORDS(h, l)          MAKE_DWORD((h), (l))

//
// HANDLE_FROM_WORDS - converts a pair of 16-bit words into a 32-bit handle
//
#define HANDLE_FROM_WORDS(h, l)         ((HANDLE)(MAKE_DWORD((h), (l))))

//
// POINTER_FROM_WORDS - returns a flat 32-bit VOID pointer (in the VDM) OR the
// NULL macro, given the 16-bit real-mode segment & offset. On x86 this will
// return 0 if we pass in 0:0 because all GetVDMAddr does is seg << 4 + off.
// The MIPS version adds this to the start of the virtual DOS memory. The
// problem arises when we have a NULL pointer, and want to keep it NULL - we
// convert it to non-NULL on not x86
//
//#define POINTER_FROM_WORDS(seg, off)    ((LPVOID)GetVDMAddr((seg), (off)))
//#define POINTER_FROM_WORDS(seg, off)    (((((DWORD)(seg)) << 16) | (off)) ? ((LPVOID)GetVDMAddr((seg), (off))) : ((LPVOID)0))

#define POINTER_FROM_WORDS(seg, off)    _inlinePointerFromWords((WORD)(seg), (WORD)(off))

//
// LPSTR_FROM_WORDS - returns a 32-bit pointer to an ASCIZ string given the
// 16-bit real-mode segment & offset
//
#define LPSTR_FROM_WORDS(seg, off)      ((LPSTR)POINTER_FROM_WORDS((seg), (off)))

//
// LPBYTE_FROM_WORDS - returns a 32-bit byte pointer given the 16-bit
// real-mode segment & offset
//
#define LPBYTE_FROM_WORDS(seg, off)     ((LPBYTE)POINTER_FROM_WORDS((seg), (off)))

//
// READ_FAR_POINTER - read the pair of words in VDM memory, currently pointed at
// by a 32-bit flat pointer and convert them to a 32-bit flat pointer
//
#define READ_FAR_POINTER(addr)          ((LPVOID)(POINTER_FROM_WORDS(GET_SELECTOR(addr), GET_OFFSET(addr))))

//
// READ_BYTE - retrieve a single byte from VDM memory. Both x86 and MIPS can
// handle reading a single byte without pain
//
#define READ_BYTE(addr)                 (*((LPBYTE)(addr)))

//
// READ_WORD - read a single 16-bit little-endian word from VDM memory. x86 can
// handle unaligned data, MIPS (&other RISCs) must be broken down into individual
// BYTE reads & the WORD pieced together by shifting & oring. If we are using
// UNALIGNED pointers then the RISC processor can handle non-aligned data
//
#ifdef i386
#define READ_WORD(addr)                 (*((LPWORD)(addr)))
#else
#ifdef UNALIGNED_VDM_POINTERS
#define READ_WORD(addr)                 (*((ULPWORD)(addr)))
#else
#define READ_WORD(addr)                 (((WORD)READ_BYTE(addr)) | (((WORD)READ_BYTE((LPBYTE)(addr)+1)) << 8))
#endif  // UNALIGNED_VDM_POINTERS
#endif  // i386

//
// READ_DWORD - read a 4-byte little-endian double word from VDM memory. x86 can
// handle unaligned data, MIPS (&other RISCs) must be broken down into individual
// BYTE reads & the DWORD pieced together by shifting & oring. If we are using
// UNALIGNED pointers then the RISC processor can handle non-aligned data
//
#ifdef i386
#define READ_DWORD(addr)                (*((LPDWORD)(addr)))
#else
#ifdef UNALIGNED_VDM_POINTERS
#define READ_DWORD(addr)                (*((ULPDWORD)(addr)))
#else
#define READ_DWORD(addr)                (((DWORD)READ_WORD(addr)) | (((DWORD)READ_WORD((LPWORD)(addr)+1)) << 16))
#endif  // UNALIGNED_VDM_POINTERS
#endif  // i386

//
// WRITE_BYTE - write a single byte in VDM memory. Both x86 and MIPS (RISC) can
// write a single byte to a non-aligned address
//
#define WRITE_BYTE(addr, value) (*(LPBYTE)(addr) = (BYTE)(value))

//
// WRITE_WORD - write a 16-bit little-endian value into VDM memory. x86 can write
// WORD data to non-word-aligned address; MIPS (& other RISCs) cannot, so we
// break down the write into 2 byte writes. If we are using UNALIGNED pointers
// then the MIPS (&other RISCs) can generate code to handle this situation
//
#ifdef i386
#define WRITE_WORD(addr, value)         (*((LPWORD)(addr)) = (WORD)(value))
#else
#ifdef UNALIGNED_VDM_POINTERS
#define WRITE_WORD(addr, value)         (*((ULPWORD)(addr)) = (WORD)(value))
#else
#define WRITE_WORD(addr, value) \
            {\
                ((LPBYTE)(addr))[0] = LOBYTE(value); \
                ((LPBYTE)(addr))[1] = HIBYTE(value); \
            }
#endif  // UNALIGNED_VDM_POINTERS
#endif  // i386

//
// WRITE_DWORD - write a 32-bit DWORD value into VDM memory. x86 can write
// DWORD data to non-dword-aligned address; MIPS (& other RISCs) cannot, so we
// break down the write into 4 byte writes. If we are using UNALIGNED pointers
// then the MIPS (&other RISCs) can generate code to handle this situation
//
#ifdef i386
#define WRITE_DWORD(addr, value)        (*((LPDWORD)(addr)) = (DWORD)(value))
#else
#ifdef UNALIGNED_VDM_POINTERS
#define WRITE_DWORD(addr, value)        (*((ULPDWORD)(addr)) = (DWORD)(value))
#else
#define WRITE_DWORD(addr, value) \
            { \
                ((LPBYTE)(addr))[0] = LOBYTE(LOWORD((DWORD)(value))); \
                ((LPBYTE)(addr))[1] = HIBYTE(LOWORD((DWORD)(value))); \
                ((LPBYTE)(addr))[2] = LOBYTE(HIWORD((DWORD)(value))); \
                ((LPBYTE)(addr))[3] = HIBYTE(HIWORD((DWORD)(value))); \
            }
#endif  // UNALIGNED_VDM_POINTERS
#endif  // i386

//
// WRITE_FAR_POINTER - write a 16:16 pointer into VDM memory. This is the same
// as writing a DWORD
//
#define WRITE_FAR_POINTER(addr, ptr)    WRITE_DWORD((addr), (DWORD)(ptr))

//
// GET_SELECTOR - retrieves the selector word from the intel 32-bit far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//
#define GET_SELECTOR(pointer)           READ_WORD((LPWORD)(pointer)+1)

//
// GET_SEGMENT - same as GET_SELECTOR
//
#define GET_SEGMENT(pointer)            GET_SELECTOR(pointer)

//
// GET_OFFSET - retrieves the offset word from an intel 32-bit far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//
#define GET_OFFSET(pointer)             READ_WORD((LPWORD)(pointer))

//
// SET_SELECTOR - writes a word into the segment word of a real-mode far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//
#define SET_SELECTOR(pointer, word)     WRITE_WORD(((LPWORD)(pointer)+1), (word))

//
// SET_SEGMENT - same as SET_SELECTOR
//
#define SET_SEGMENT(pointer, word)      SET_SELECTOR(pointer, word)

//
// SET_OFFSET - writes a word into the offset word of a real-mode far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//
#define SET_OFFSET(pointer, word)       WRITE_WORD((LPWORD)(pointer), (word))

//
// POINTER_FROM_POINTER - read a segmented pointer in the VDM from an address
// pointed at by a flat 32-bit pointer. Convert the segmented pointer to a
// flat pointer. SAME AS READ_FAR_POINTER
//
#define POINTER_FROM_POINTER(pointer)   POINTER_FROM_WORDS(GET_SELECTOR(pointer), GET_OFFSET(pointer))

//
// LPSTR_FROM_POINTER - perform a POINTER_FROM_POINTER, casting the result to
// a string pointer. SAME AS READ_FAR_POINTER
//
#define LPSTR_FROM_POINTER(pointer)     ((LPSTR)POINTER_FROM_POINTER(pointer))

//
// LPBYTE_FROM_POINTER - perform a POINTER_FROM_POINTER, casting the result to
// a byte pointer. SAME AS READ_FAR_POINTER
//
#define LPBYTE_FROM_POINTER(pointer)    ((LPBYTE)POINTER_FROM_POINTER(pointer))

//
// SET_ERROR - sets the caller's AX register in the VDM context descriptor to
// the value given and sets the caller's VDM carry flag
//
#define SET_ERROR(err)                  {setAX(err); setCF(1);}

//
// SET_SUCCESS - sets the VDM caller's AX register to NERR_Success and clears
// the carry flag
//
#define SET_SUCCESS()                   {setAX(NERR_Success); setCF(0);}

//
// SET_OK - an explicit version of SET_SUCCESS wherein NERR_Success would be
// an inappropriate error, although the right value
//
#define SET_OK(value)                   {setAX(value); setCF(0);}



//
// Miscellaneous macros for working out sizes of things
//

//
// ARRAY_ELEMENTS - gives the number of elements of a particular type in an
// array
//

#define ARRAY_ELEMENTS(a)   (sizeof(a)/sizeof((a)[0]))

//
// LAST_ELEMENT - returns the index of the last element in array
//

#define LAST_ELEMENT(a)     (ARRAY_ELEMENTS(a)-1)

//
// BITSIN - returns the number of bits in a data type or structure. This is
// predicated upon the number of bits in a byte being 8 and all data types
// being composed of a collection of bytes (safe assumption?)
//
#define BITSIN(thing)                   (sizeof(thing) * BITS_IN_A_BYTE)

//
// Miscellaneous other macros
//

//
// IS_ASCII_PATH_SEPARATOR - returns TRUE if ch is / or \. ch is a single
// byte (ASCII) character
//
#define IS_ASCII_PATH_SEPARATOR(ch)     (((ch) == '/') || ((ch) == '\\'))

//
// macros for setting CF and ZF flags for return from hardware interrupt
// callback
//

#define SET_CALLBACK_NOTHING()  {setZF(0); setCF(0);}
#define SET_CALLBACK_NAMEPIPE() {setZF(0); setCF(1);}
#define SET_CALLBACK_DLC()      {setZF(1); setCF(0);}
#define SET_CALLBACK_NETBIOS()  {setZF(1); setCF(1);}

//
// DLC-specific macros etc.
//

extern LPVDM_REDIR_DOS_WINDOW   lpVdmWindow;

//
// setPostRoutine - if dw is not 0 then we write the (DOS segmented) address of
// the post routine into the dwPostRoutine field of the VDM_REDIR_DOS_WINDOW
// structure passed to us at redir DLC initialization. We also set the flags
// to indicate to the redir's hardware interrupt routine there is a DLC post
// routine to run. If dw is 0 then we set the flags to indicate that there is
// no post routine processing
//
#define setPostRoutine( dw )    if (dw) {\
                                    (lpVdmWindow->dwPostRoutine = (DWORD)(dw));\
                                    SET_CALLBACK_DLC();\
                                } else {\
                                    SET_CALLBACK_NOTHING();\
                                }

//
// VR_ASYNC_DISPOSITION - we maintain a serialized list of these structures.
// Used to dispose of VDM redir asynchronous completions in the order in which
// they occurred
//

typedef struct _VR_ASYNC_DISPOSITION {

    //
    // Next - maintains a singly-linked list of dispositions
    //

    struct _VR_ASYNC_DISPOSITION* Next;

    //
    // AsyncDispositionRoutine - pointer to VOID function taking no args which
    // will dispose of the next asynchronous completion - Netbios, named pipe
    // or DLC
    //

    VOID (*AsyncDispositionRoutine)(VOID);
} VR_ASYNC_DISPOSITION, *PVR_ASYNC_DISPOSITION;

//
// _inlinePointerFromWords - the POINTER_FROM_WORDS macro is inefficient if the
// arguments are calls to eg. getES(), getBX() - the calls are made twice if
// the pointer turns out to be non-zero. Use an inline function to achieve the
// same results, but only call function arguments once
//

#ifdef i386

__inline LPVOID _inlinePointerFromWords(WORD seg, WORD off) {

    WORD _seg = seg;
    WORD _off = off;

    return (_seg + _off) ? (LPVOID)GetVDMAddr(_seg, _off) : 0;
}

#else
LPVOID _inlinePointerFromWords(WORD seg, WORD off);
#endif

//
// CONVERT_ADDRESS - convert a segmented (real or protect-mode) address to a
// flat 32-bit address
//

//#define CONVERT_ADDRESS(seg, off, size, mode) !((WORD)(seg) | (WORD)(off)) ? 0 : Sim32GetVDMPointer((((DWORD)seg) << 16) + (DWORD)(off), (size), (mode))
#define CONVERT_ADDRESS(seg, off, size, mode) _inlineConvertAddress((WORD)(seg), (WORD)(off), (WORD)(size), (BOOLEAN)(mode))

#ifdef i386

__inline LPVOID _inlineConvertAddress(WORD Seg, WORD Off, WORD Size, BOOLEAN Pm) {

    WORD _seg = Seg;
    WORD _off = Off;

    return (_seg | _off) ? Sim32GetVDMPointer(((DWORD)_seg << 16) + _off, Size, Pm) : 0;
}

#else
extern LPVOID _inlineConvertAddress(WORD Seg, WORD Off, WORD Size, BOOLEAN Pm);
#endif

#endif  // _VDMREDIR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vrinit.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrinit.h

Abstract:

    Contains function prototypes for Vdm Redir init routines

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

--*/

BOOLEAN
VrInitialized(
    VOID
    );

BOOLEAN
VrInitialize(
    VOID
    );

VOID
VrUninitialize(
    VOID
    );

VOID
VrRaiseInterrupt(
    VOID
    );

VOID
VrDismissInterrupt(
    VOID
    );

VOID
VrQueueCompletionHandler(
    IN VOID (*AsyncDispositionRoutine)(VOID)
    );

VOID
VrHandleAsyncCompletion(
    VOID
    );

VOID
VrCheckPmNetbiosAnr(
    VOID
    );

VOID
VrEoiAndDismissInterrupt(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vrdlctab.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdlctab.h

Abstract:

    Contains structures which are shared between the VDM code and the DOS
    redir code. Separated from VDMREDIR.H

Author:

    Richard L Firth (rfirth) 13-May-1992

Revision History:

--*/

//
// manifests
//

#define DOS_DLC_STATUS_PERM_SLOTS   10
#define DOS_DLC_STATUS_TEMP_SLOTS   5
#define DOS_DLC_MAX_ADAPTERS        2

//
// EXTENDED_STATUS_PARMS - there is one of these per adapter
//

/* XLATOFF */
#pragma pack(1)
/* XLATON */

typedef struct _EXTENDED_STATUS_PARMS { /* */
    BYTE    cbSize;
    BYTE    cbPageFrameSize;
    WORD    wAdapterType;
    WORD    wCurrentFrameSize;
    WORD    wMaxFrameSize;
} EXTENDED_STATUS_PARMS;

typedef EXTENDED_STATUS_PARMS UNALIGNED * PEXTENDED_STATUS_PARMS;

//
// DOS_DLC_STATUS - there is one of these for each of the permanent and temporary
// connections
//

typedef struct _DOS_DLC_STATUS { /* */
    WORD    usStationId;
    WORD    usDlcStatusCode;
    BYTE    uchFrmrData[5];
    BYTE    uchAccessPriority;
    BYTE    uchRemoteNodeAddress[6];
    BYTE    uchRemoteSap;
    BYTE    auchReserved[3];
} DOS_DLC_STATUS;

typedef DOS_DLC_STATUS UNALIGNED * PDOS_DLC_STATUS;

//
// ADAPTER_STATUS_PARMS - In real DOS workstation, this is maintained by the
// adapter software, but is made available to applications through DIR.STATUS.
// Token Ring and Ethernet adapter have different adapter status parameters
//
// Note: some fields prefixed by Tr or Eth because the x86 assembler
// can't handle the same field name in different structures
//

typedef struct _TOKEN_RING_ADAPTER_STATUS_PARMS { /* */
    DWORD   PhysicalAddress;
    BYTE    UpstreamNodeAddress[6];
    DWORD   UpstreamPhysicalAddress;
    BYTE    LastPollAddress[6];
    WORD    AuthorizedEnvironment;
    WORD    TransmitAccessPriority;
    WORD    SourceClassAuthorization;
    WORD    LastAttentionCode;
    BYTE    TrLastSourceAddress[6];
    WORD    LastBeaconType;
    WORD    TrLastMajorVector;
    WORD    TrNetworkStatus;
    WORD    SoftError;
    WORD    FrontEndErrorCount;
    WORD    LocalRingNumber;
    WORD    MonitorErrorCode;
    WORD    BeaconTransmitType;
    WORD    BeaconReceiveType;
    WORD    TrFrameCorrelation;
    BYTE    BeaconingNaun[6];
    DWORD   Reserved;
    DWORD   BeaconingPhysicalAddress;
} TOKEN_RING_ADAPTER_STATUS_PARMS;

typedef TOKEN_RING_ADAPTER_STATUS_PARMS UNALIGNED * PTOKEN_RING_ADAPTER_STATUS_PARMS;

typedef struct _ETHERNET_ADAPTER_STATUS_PARMS { /* */
    BYTE    Reserved1[28];
    BYTE    EthLastSourceAddress[6];
    BYTE    Reserved2[2];
    WORD    EthLastMajorVector;
    WORD    EthNetworkStatus;
    WORD    ErrorReportTimerValue;
    WORD    ErrorReportTimerTickCounter;
    WORD    LocalBusNumber;
    BYTE    Reserved3[6];
    WORD    EthFrameCorrelation;
    BYTE    Reserved4[6];
    WORD    NetworkUtilizationSamples;
    WORD    NetworkBusySamples;
    BYTE    Reserved5[4];
} ETHERNET_ADAPTER_STATUS_PARMS;

typedef ETHERNET_ADAPTER_STATUS_PARMS UNALIGNED * PETHERNET_ADAPTER_STATUS_PARMS;

typedef union _ADAPTER_STATUS_PARMS { /* */
    TOKEN_RING_ADAPTER_STATUS_PARMS TokenRing;
    ETHERNET_ADAPTER_STATUS_PARMS Ethernet;
} ADAPTER_STATUS_PARMS;

typedef ADAPTER_STATUS_PARMS UNALIGNED * PADAPTER_STATUS_PARMS;

//
// VDM_REDIR_DOS_WINDOW - this structure is used by the MVDM DLC code to return
// information to the DOS DLC program via the redir. This is used mainly in
// asynchronous call-backs (aka ANRs, post-routines or DLC appendages). We let
// the redir code know if there is an ANR by setting dwPostRoutine
//

typedef struct _VDM_REDIR_DOS_WINDOW { /* */
    DWORD   dwPostRoutine;
    DWORD   dwDlcTimerTick;
    EXTENDED_STATUS_PARMS aExtendedStatus[DOS_DLC_MAX_ADAPTERS];
    ADAPTER_STATUS_PARMS AdapterStatusParms[DOS_DLC_MAX_ADAPTERS];
    DOS_DLC_STATUS aStatusTables[(DOS_DLC_STATUS_TEMP_SLOTS + DOS_DLC_STATUS_PERM_SLOTS)];
} VDM_REDIR_DOS_WINDOW;

typedef VDM_REDIR_DOS_WINDOW UNALIGNED * LPVDM_REDIR_DOS_WINDOW;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vrnetapi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnetapi.h

Abstract:

    Contains prototypes and definitions for Vdm Redir lanman support routines

Author:

    Richard L Firth (rfirth) 21-Oct-1991

Revision History:

    21-Oct-1991 rfirth
        Created

--*/

//
// the top bit of the api number (word) is used by the dosnet library to
// indicate whether certain APIs should be remoted over a null session
// (according to the code in the dos redir)
//

#define USE_NULL_SESSION_FLAG   0x8000



//
// prototypes
//

VOID
VrNetRemoteApi(
    VOID
    );

VOID
VrNetTransactApi(
    VOID
    );

VOID
VrNetNullTransactApi(
    VOID
    );

VOID
VrNetServerEnum(
    VOID
    );

VOID
VrNetUseAdd(
    VOID
    );

VOID
VrNetUseDel(
    VOID
    );

VOID
VrNetUseEnum(
    VOID
    );

VOID
VrNetUseGetInfo(
    VOID
    );

VOID
VrNetWkstaGetInfo(
    VOID
    );

VOID
VrNetWkstaSetInfo(
    VOID
    );

VOID
VrNetMessageBufferSend(
    VOID
    );

VOID
VrGetCDNames(
    VOID
    );

VOID
VrGetComputerName(
    VOID
    );

VOID
VrGetUserName(
    VOID
    );

VOID
VrGetDomainName(
    VOID
    );

VOID
VrGetLogonServer(
    VOID
    );

VOID
VrNetGetDCName(
    VOID
    );

VOID
VrReturnAssignMode(
    VOID
    );

VOID
VrSetAssignMode(
    VOID
    );

VOID
VrGetAssignListEntry(
    VOID
    );

VOID
VrDefineMacro(
    VOID
    );

VOID
VrBreakMacro(
    VOID
    );

VOID VrNetServiceControl(
    VOID
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vrmisc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrmisc.h

Abstract:

    Contains function prototypes for Vdm Redir miscellaneous routines

Author:

    Richard L Firth (rfirth) 01-Oct-1991

Revision History:

    01-Oct-1991 rfirth
        Created

--*/



VOID
VrTerminateDosProcess(
    VOID
    );

VOID
VrUnsupportedFunction(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vrmslot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrmslot.h

Abstract:

    Prototypes, definitions and structures for VdmRedir mailslot handlers

Author:

    Richard L Firth (rfirth) 16-Sep-1991

Revision History:

    16-Sep-1991 rfirth
        Created

--*/



//
// VDM Mailslot support routines. Prototypes
//

VOID
VrDeleteMailslot(
    VOID
    );

VOID
VrGetMailslotInfo(
    VOID
    );

VOID
VrMakeMailslot(
    VOID
    );

VOID
VrPeekMailslot(
    VOID
    );

VOID
VrReadMailslot(
    VOID
    );

VOID
VrWriteMailslot(
    VOID
    );

VOID
VrTerminateMailslots(
    IN WORD DosPdb
    );



//
// typedefs
//

//
// SELECTOR - in the absence of a standard SELECTOR type, 16-bit selector,
// doubles as SEGMENT (as in ADDRESS16)
//

typedef unsigned short SELECTOR;

//
// ADDRESS16 - an Intel architecture-specific 16:16 address, consisting of a
// 16-bit offset in the low word and a 16-bit segment (real mode) or selector
// (protect mode) in the high word. Both elements are little-endian
// Again, this exists in absence of Intel-specific DWORD structure which has
// correct endian-ness and views address as composed of two parts
//

typedef struct {
    unsigned short  Offset;
    SELECTOR        Selector;
} ADDRESS16;



//
// structures
//

//
// VR_MAILSLOT_INFO - the Dos mailslot subsystem needs some info which we do
// not keep, so we put it in this structure. The structure is linked into a
// list of active mailslot structures for every successful CreateMailslot
// call. The extra info we need is:
//
//      DosPdb          - the PDB (or PSP) of the Dos application. Used for
//                        consistency checks and removing mailslots when the
//                        app dies
//      Handle16        - the handle returned to the Dos app. We have to invent
//                        this
//      BufferAddress   - the Dos app tells us where its buffer is then wants
//                        us to confirm the address in a DosMailslotInfo call
//      Selector        - the Dos app needs a protect mode selector when
//                        running under Windows 3.0 enhanced mode
//      MessageSize     - maximum message size which can be read. Not the same
//                        thing as mailslot size
//
// We also need some information for our own internal wrangling:
//
//      NameLength      - the length of the significant part of the mailslot
//                        name (after \MAILSLOT\). We compare this before
//                        doing a strcmp() on names
//      Name            - the significant part of the mailslot name. When a
//                        mailslot is opened, we store the name after \MAILSLOT\
//                        because DosMailslotWrite uses the symbolic name, even
//                        when writing locally; we need a handle, so we have
//                        to map the name to open mailslot handle.
//
// This structure is allocated from the heap and the Name field will actually
// be large enough to hold the entire string. I put Name[2] because the Mips
// compiler doesn't know about Name[] (Microsoft C compiler extension). 2 at
// least keeps things even. Maybe it should be 4. Maybe it doesn't matter
//

typedef struct _VR_MAILSLOT_INFO *PVR_MAILSLOT_INFO;
typedef struct _VR_MAILSLOT_INFO {
    PVR_MAILSLOT_INFO   Next;       // linked list
    WORD        DosPdb;             // for consistency etc
    WORD        Handle16;           // Dos handle
    HANDLE      Handle32;           // Win32 handle (proper)
    ADDRESS16   BufferAddress;      // Dos app's message buffer
    SELECTOR    Selector;           // Win 3's buffer selector
    DWORD       MessageSize;        // max. message size
    DWORD       NameLength;         // length of name following:
    CHAR        Name[2];            // of mailslot, (after \\.\MAILSLOT\)
} VR_MAILSLOT_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vrnmpipe.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnmpipe.h

Abstract:

    Prototypes, definitions and structures for VdmRedir named pipe handlers

Author:

    Richard L Firth (rfirth) 10-Sep-1991

Revision History:

    10-Sep-1991 RFirth
        Created

--*/

//
// manifests
//

#define MAXIMUM_ASYNC_PIPES 32

//
// async named pipe request types
//

#define ANP_READ    0x86
#define ANP_READ2   0x90
#define ANP_WRITE   0x8f
#define ANP_WRITE2  0x91

//
// VDM Named Pipe support routines. Prototypes
//

VOID
VrGetNamedPipeInfo(
    VOID
    );

VOID
VrGetNamedPipeHandleState(
    VOID
    );

VOID
VrSetNamedPipeHandleState(
    VOID
    );

VOID
VrPeekNamedPipe(
    VOID
    );

VOID
VrTransactNamedPipe(
    VOID
    );

VOID
VrCallNamedPipe(
    VOID
    );

VOID
VrWaitNamedPipe(
    VOID
    );

VOID
VrNetHandleGetInfo(
    VOID
    );

VOID
VrNetHandleSetInfo(
    VOID
    );

VOID
VrReadWriteAsyncNmPipe(
    VOID
    );

BOOLEAN
VrNmPipeInterrupt(
    VOID
    );

VOID
VrTerminateNamedPipes(
    IN WORD DosPdb
    );

//
// VDM open/close and read/write intercept routines
//

#ifdef VDMREDIR_DLL

BOOL
VrAddOpenNamedPipeInfo(
    IN  HANDLE  Handle,
    IN  LPSTR   lpFileName
    );

BOOL
VrRemoveOpenNamedPipeInfo(
    IN  HANDLE  Handle
    );

BOOL
VrReadNamedPipe(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesRead,
    OUT LPDWORD Error
    );

BOOL
VrWriteNamedPipe(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesWritten
    );

VOID
VrCancelPipeIo(
    IN DWORD Thread
    );

#else

BOOL
(*VrAddOpenNamedPipeInfo)(
    IN  HANDLE  Handle,
    IN  LPSTR   lpFileName
    );

BOOL
(*VrRemoveOpenNamedPipeInfo)(
    IN  HANDLE  Handle
    );

BOOL
(*VrReadNamedPipe)(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesRead,
    OUT LPDWORD Error
    );

BOOL
(*VrWriteNamedPipe)(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesWritten
    );

VOID
(*VrCancelPipeIo)(
    IN DWORD Thread
    );

#endif

//
// VDM pipe name to NT pipe name helper routines
//

#ifdef VDMREDIR_DLL

BOOL
VrIsNamedPipeName(
    IN  LPSTR   Name
    );

BOOL
VrIsNamedPipeHandle(
    IN  HANDLE  Handle
    );

LPSTR
VrConvertLocalNtPipeName(
    OUT LPSTR   Buffer OPTIONAL,
    IN  LPSTR   Name
    );

#else

BOOL
(*VrIsNamedPipeName)(
    IN  LPSTR   Name
    );

BOOL
(*VrIsNamedPipeHandle)(
    IN  HANDLE  Handle
    );

LPSTR
(*VrConvertLocalNtPipeName)(
    OUT LPSTR   Buffer OPTIONAL,
    IN  LPSTR   Name
    );

#endif

//
// structures
//

//typedef struct {
//    PDOSNMPINFO Next;           // pointer to next info structure in list
//    WORD    DosPdb;
//    WORD    Handle16;
//    HANDLE  Handle32;           // handle returned from CreateFile call
//    DWORD   NameLength;         // length of ASCIZ pipe name
//    LPSTR   Name;               // ASCIZ pipe name
//    DWORD   Instances;          // current instances
//} DOSNMPINFO, *PDOSNMPINFO;

//
// OPEN_NAMED_PIPE_INFO - this structure contains information recorded when a
// named pipe is opened on behalf of the VDM. DosQNmPipeInfo wants the name
// of the pipe
//

typedef struct _OPEN_NAMED_PIPE_INFO* POPEN_NAMED_PIPE_INFO;
typedef struct _OPEN_NAMED_PIPE_INFO {
    POPEN_NAMED_PIPE_INFO Next; // linked list
    HANDLE  Handle;             // open named pipe handle
    DWORD   NameLength;         // including terminating 0
    WORD    DosPdb;             // the process which owns this named pipe
    CHAR    Name[2];            // full pipe name
} OPEN_NAMED_PIPE_INFO;

//
// DOS_ASYNC_NAMED_PIPE_INFO - in this structure we keep all the information
// required to complete an asynchronous named pipe operation
//

typedef struct _DOS_ASYNC_NAMED_PIPE_INFO {
    struct _DOS_ASYNC_NAMED_PIPE_INFO* Next;  // linked list
    OVERLAPPED Overlapped;      // contains 32-bit event handle
    BOOL    Type2;              // TRUE if request is Read2 or Write2
    BOOL    Completed;          // TRUE if this request has completed
    HANDLE  Handle;             // 32-bit named pipe handle
    DWORD   Buffer;             // 16:16 address of buffer
    DWORD   BytesTransferred;   // actual number of bytes read/written
    LPWORD  pBytesTransferred;  // flat-32 pointer to returned read/write count in VDM
    LPWORD  pErrorCode;         // flat-32 pointer to returned error code in VDM
    DWORD   ANR;                // 16:16 address of ANR
    DWORD   Semaphore;          // 16:16 address of 'semaphore' in VDM
#if DBG
    DWORD   RequestType;
#endif
} DOS_ASYNC_NAMED_PIPE_INFO, *PDOS_ASYNC_NAMED_PIPE_INFO;

//
// DOS_CALL_NAMED_PIPE_STRUCT - this structure is created and handed to the DOS
// CallNmPipe routine because there is too much information to get into a 286's
// registers. This structure should be in apistruc.h, but it aint
//

//#include <packon.h>
#pragma pack(1)
typedef struct {
    DWORD   Timeout;            // Time to wait for pipe to become available
    LPWORD  lpBytesRead;        // pointer to returned bytes read
    WORD    nOutBufferLen;      // size of send data
    LPBYTE  lpOutBuffer;        // pointer to send data
    WORD    nInBufferLen;       // size of receive buffer
    LPBYTE  lpInBuffer;         // pointer to receive buffer
    LPSTR   lpPipeName;         // pointer to pipe name
} DOS_CALL_NAMED_PIPE_STRUCT, *PDOS_CALL_NAMED_PIPE_STRUCT;
//#include <packoff.h>
#pragma pack()

//
// DOS_ASYNC_NAMED_PIPE_STRUCT - as with the above, this structure is used
// to pass all the info to DosReadAsyncNmPipe which won't fit into registers.
// Used for read and write operations. Should be defined in apistruc.h
//

//#include <packon.h>
#pragma pack(1)
typedef struct {
    LPWORD  lpBytesRead;        // pointer to returned bytes read/written
    WORD    BufferLength;       // size of caller's buffer
    LPBYTE  lpBuffer;           // pointer to caller's buffer
    LPWORD  lpErrorCode;        // pointer to returned error code
    LPVOID  lpANR;              // pointer to Asynchronous Notification Routine
    WORD    PipeHandle;         // named pipe handle
    LPBYTE  lpSemaphore;        // pointer to caller's 'semaphore'
} DOS_ASYNC_NAMED_PIPE_STRUCT, *PDOS_ASYNC_NAMED_PIPE_STRUCT;
//#include <packoff.h>
#pragma pack()

//
// The following selectively copied from BSEDOS.H and other Lanman include
// files
//

/*** Data structures and equates used with named pipes ***/

//#include <packon.h>
#pragma pack(1)
typedef struct _PIPEINFO { /* nmpinf */
    USHORT cbOut;
    USHORT cbIn;
    BYTE   cbMaxInst;
    BYTE   cbCurInst;
    BYTE   cbName;
    CHAR   szName[1];
} PIPEINFO;
//#include <packoff.h>
#pragma pack()
typedef PIPEINFO FAR *PPIPEINFO;

/* defined bits in pipe mode */
#define NP_NBLK         0x8000 /* non-blocking read/write */
#define NP_SERVER       0x4000 /* set if server end   */
#define NP_WMESG        0x0400 /* write messages      */
#define NP_RMESG        0x0100 /* read as messages    */
#define NP_ICOUNT       0x00FF /* instance count field    */


/*  Named pipes may be in one of several states depending on the actions
 *  that have been taken on it by the server end and client end.  The
 *  following state/action table summarizes the valid state transitions:
 *
 *  Current state       Action          Next state
 *
 *   <none>         server DosMakeNmPipe    DISCONNECTED
 *   DISCONNECTED       server connect      LISTENING
 *   LISTENING      client open         CONNECTED
 *   CONNECTED      server disconn      DISCONNECTED
 *   CONNECTED      client close        CLOSING
 *   CLOSING        server disconn      DISCONNECTED
 *   CONNECTED      server close        CLOSING
 *   <any other>        server close        <pipe deallocated>
 *
 *  If a server disconnects his end of the pipe, the client end will enter a
 *  special state in which any future operations (except close) on the file
 *  descriptor associated with the pipe will return an error.
 */

/*
 *  Values for named pipe state
 */

#define NP_DISCONNECTED     1 /* after pipe creation or Disconnect */
#define NP_LISTENING        2 /* after DosNmPipeConnect        */
#define NP_CONNECTED        3 /* after Client open             */
#define NP_CLOSING      4 /* after Client or Server close      */

/* DosMakeNmPipe open modes */

#define NP_ACCESS_INBOUND   0x0000
#define NP_ACCESS_OUTBOUND  0x0001
#define NP_ACCESS_DUPLEX    0x0002
#define NP_INHERIT      0x0000
#define NP_NOINHERIT        0x0080
#define NP_WRITEBEHIND      0x0000
#define NP_NOWRITEBEHIND    0x4000

/* DosMakeNmPipe and DosQNmPHandState state */

#define NP_READMODE_BYTE    0x0000
#define NP_READMODE_MESSAGE 0x0100
#define NP_TYPE_BYTE        0x0000
#define NP_TYPE_MESSAGE     0x0400
#define NP_END_CLIENT       0x0000
#define NP_END_SERVER       0x4000
#define NP_WAIT         0x0000
#define NP_NOWAIT       0x8000
#define NP_UNLIMITED_INSTANCES  0x00FF

typedef struct _AVAILDATA   {   /* PeekNMPipe Bytes Available record */
    USHORT  cbpipe;     /* bytes left in the pipe        */
    USHORT  cbmessage;  /* bytes left in current message     */
} AVAILDATA;
typedef AVAILDATA FAR *PAVAILDATA;

//
// handle info level 1 - this is different to the structure in lmchdev.h
//

//#include <packon.h>
#pragma pack(1)
typedef struct _VDM_HANDLE_INFO_1 {
    ULONG   CharTime;
    USHORT  CharCount;
} VDM_HANDLE_INFO_1, *LPVDM_HANDLE_INFO_1;
#pragma pack()
//#include <packoff.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowclip.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWCLIP.H
 *
 *  History:
 *  09-22-92 Craig Jones (v-cjones)
 *  Created.
--*/

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct tagMETAFILEPICT16 {    /* mfp16wow32 */
    WORD    mm;
    WORD    xExt;
    WORD    yExt;
    HMEM16  hMF;
} METAFILEPICT16;
typedef METAFILEPICT16 UNALIGNED *LPMETAFILEPICT16;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowcmpat.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWCMPAT.H
 *  WOW compatibility flags
 *
 *  History:
 *  11-June-1993 Neil Sandlin (neilsa)
 *  Created.
--*/

////////// NOTE ////////// NOTE ////////// NOTE ////////// NOTE ////////// NOTE
//
// N   N       t
// NN  N  oo  ttt  ee
// N N N o  o  t  eeee  o
// N  NN o  o  t  e        Make sure you update both the string table entry and
// N   N  oo   tt  eee  o  the #define constant if you modify this file!!!
//
////////// NOTE ////////// NOTE ////////// NOTE ////////// NOTE ////////// NOTE


// These string tables only get included by mvdm\vdmexts\wow.c
// See NOTE above about adding anything to these tables!!!!
#ifdef _VDMEXTS_CFLAGS   // this is defined in mvdm\vdmexts\wow.c


// Original WOW compatibility flags.
// Kept in CURRENTPTD->dwWOWCompatFlags.

#ifdef _VDMEXTS_CF
{"WOWCF_GRAINYTICS",             0x80000000},
{"WOWCF_FAKEJOURNALRECORDHOOK",  0x40000000},
{"WOWCF_EDITCTRLWNDWORDS",       0x20000000},
{"WOWCF_SYNCHRONOUSDOSAPP",      0x10000000},

{"WOWCF_NOTDOSSPAWNABLE",        0x08000000},
{"WOWCF_RESETPAPER29ANDABOVE",   0x04000000},
{"WOWCF_4PLANECONVERSION",       0x02000000},
{"WOWCF_MGX_ESCAPES",            0x01000000},

{"WOWCF_CREATEBOGUSHWND",        0x00800000},
{"WOWCF_SANITIZEDOTWRSFILES",    0x00400000},
{"WOWCF_SIMPLEREGION",           0x00200000},
{"WOWCF_NOWAITFORINPUTIDLE",     0x00100000},

{"WOWCF_DSBASEDSTRINGPOINTERS",  0x00080000},
{"WOWCF_LIMIT_MEM_FREE_SPACE",   0x00040000},
{"WOWCF_DONTRELEASECACHEDDC",    0x00020000},
{"WOWCF_FORCETWIPSESCAPE",       0x00010000},

{"WOWCF_LB_NONNULLLPARAM",       0x00008000},
{"WOWCF_FORCENOPOSTSCRIPT",      0x00004000},
{"WOWCF_SETNULLMESSAGE",         0x00002000},
{"WOWCF_GWLINDEX2TO4",           0x00001000},

{"WOWCF_NEEDSTARTPAGE",          0x00000800},
{"WOWCF_NEEDIGNORESTARTPAGE",    0x00000400},
{"WOWCF_NOPC_RECTANGLE",         0x00000200},
{"WOWCF_NOFIRSTSAVE",            0x00000100},

{"WOWCF_ADD_MSTT",               0x00000080},
{"WOWCF_UNLOADNETFONTS",         0x00000040},
{"WOWCF_GETDUMMYDC",             0x00000020},
{"WOWCF_DBASEHANDLEBUG",         0x00000010},

{"WOWCF_NOCBDIRTHUNK",           0x00000008},
{"WOWCF_WMMDIACTIVATEBUG",       0x00000004},
{"WOWCF_UNIQUEHDCHWND",          0x00000002},
{"WOWCF_GWLCLRTOPMOST",          0x00000001},
#endif _VDMEXTS_CF




// Extra WOW compatibility flags bit definitions (WOWCFEX_).
// Kept in CURRENTPTD->dwWOWCompatFlagsEx.
#ifdef _VDMEXTS_CFEX
{"WOWCFEX_SENDPOSTEDMSG",        0x80000000},
{"WOWCFEX_BOGUSPOINTER",         0x40000000},
{"WOWCFEX_GETVERSIONHACK",       0x20000000},
{"WOWCFEX_FIXDCFONT4MENUSIZE",   0x10000000},

{"WOWCFEX_RESTOREEXPLORER",      0x08000000},
{"WOWCFEX_LONGWINEXECTAIL",      0x04000000},
{"WOWCFEX_FORCEINCDPMI",         0x02000000},
{"WOWCFEX_SETCAPSTACK",          0x01000000},

{"WOWCFEX_NODIBSHERE",           0x00800000},
{"WOWCFEX_PIXELMETRICS",         0x00400000},
{"WOWCFEX_DEFWNDPROCNCCALCSIZE", 0x00200000},
{"WOWCFEX_DIBDRVIMAGESIZEZERO",  0x00100000},

{"WOWCFEX_GLOBALDELETEATOM",     0x00080000},
{"WOWCFEX_IGNORECLIENTSHUTDOWN", 0x00040000},
{"WOWCFEX_ZAPGPPSDEFBLANKS",     0x00020000},
{"WOWCFEX_FAKECLASSINFOFAIL",    0x00010000},

{"WOWCFEX_SAMETASKFILESHARE",    0x00008000},
{"WOWCFEX_SAYITSNOTTHERE",       0x00004000},
{"WOWCFEX_BROKENFLATPOINTER",    0x00002000},
{"WOWCFEX_USEMCIAVI16",          0x00001000},

{"WOWCFEX_SAYNO2DRAWPATTERNRECT",0x00000800},
{"WOWCFEX_FAKENOTAWINDOW",       0x00000400},
{"WOWCFEX_NODIRECTHDPOPUP",      0x00000200},
{"WOWCFEX_ALLOWLFNDIALOGS",      0x00000100},

{"WOWCFEX_THUNKLBSELITEMRANGEEX",0x00000080},
{"WOWCFEX_LIMITFINDFIRSTLEN",    0x00000040},
{"WOWCFEX_USEWINHELP32",         0x00000020},
{"WOWCFEX_PLATFORMVERSIONLIE",   0x00000010},

{"WOWCFEX_SP2CSDVERSIONLIE",     0x00000008},
{"WOWCFEX_EATDEVMODEMSG",        0x00000004},
{"WOWCFEX_DISPMODE256",          0x00000002},
{"WOWCFEX_FORMFEEDHACK",         0x00000001},
#endif _VDMEXTS_CFEX

// Extra WOW User compatibility flags bit definitions (WOWCF_USER).
// Kept in CURRENTPTD->dwUserWOWCompatFlags.
#ifdef _VDMEXTS_USER
{"WOWCF_USER_DDENOSYNC",         0x00040000},
#endif

// Extra WOW2 compatibility flags bit definitions (WOWCF2_).
// Kept in CURRENTPTD->dwUserWOWCompatFlags2.
#ifdef _VDMEXTS_CF2
{"WOWCF2_HACKWINFLAGS",          0x80000000},
{"WOWCF2_SETFOREGROUND",         0x40000000},
{"WOWCF2_SYNCSYSFILE",           0x20000000},
{"WOWCF2_RESETCURDIR",           0x10000000},

{"WOWCF2_DELAYTIMEGETTIME",      0x08000000},
{"WOWCF2_FIXLUNATRAYRECT",       0x04000000}
#endif



// Win3.1/Win95/User32 compatibility bits (GACF_).
// Kept in CURRENTPTD->dwCompatFlags.
#ifdef _VDMEXTS_CF31
{"GACF_IGNORENODISCARD",        0x00000001},
{"GACF_FORCETEXTBAND",          0x00000002},
{"GACF_USEPRINTINGESCAPES"
 " aka GACF_ONELANDGRXBAND",    0x00000004},      // re-use GACF_ONELANDGRXBAND
{"GACF_IGNORETOPMOST",          0x00000008},
{"GACF_CALLTTDEVICE",           0x00000010},
{"GACF_MULTIPLEBANDS",          0x00000020},
{"GACF_ALWAYSSENDNCPAINT",      0x00000040},
{"GACF_EDITSETTEXTMUNGE",       0x00000080},
{"GACF_MOREEXTRAWNDWORDS",      0x00000100},
{"GACF_TTIGNORERASTERDUPE",     0x00000200},
{"GACF_HACKWINFLAGS",           0x00000400},
{"GACF_DELAYHWHNDSHAKECHK",     0x00000800},
{"GACF_ENUMHELVNTMSRMN",        0x00001000},
{"GACF_ENUMTTNOTDEVICE",        0x00002000},
{"GACF_SUBTRACTCLIPSIBS",       0x00004000},
{"GACF_FORCERASTERMODE"
    " aka GACF_FORCETTGRAPHICS",0x00008000},      // re-use GACF_FORCETTGRAPHICS
{"GACF_NOHRGN1",                0x00010000},
{"GACF_NCCALCSIZEONMOVE",       0x00020000},
{"GACF_SENDMENUDBLCLK",         0x00040000},
{"GACF_30AVGWIDTH",             0x00080000},
{"GACF_GETDEVCAPSNUMLIE",       0x00100000},

{"GACF_WINVER31",               0x00200000},      //
{"GACF_INCREASESTACK"
 " aka GACF_HEAPSLACK",         0x00400000},      //
{"GACF_FORCEWIN31DEVMODESIZE"
 " aka GACF_PEEKMESSAGEIDLE",   0x00800000},      // (replaces PEEKMESSAGEIDLE)
{"GACF_DISABLEFONTASSOC"
 " aka GACF_JAPANESCAPEMENT",   0x01000000},      // Used in FE only aka GACF_JAPANESCAPEMENT
{"GACF_IGNOREFAULTS",           0x02000000},      //
{"GACF_NOEMFSPOOLING",          0x04000000},      //
{"GACF_RANDOM3XUI",             0x08000000},      //
{"GACF_DONTJOURNALATTACH",      0x10000000},      //
{"GACF_NOBRUSHCACHE"
 " aka GACF_DISABLEDBCSPROPTT", 0x20000000},      // re-use GACF_DISABLEDBCSPROPTT
#endif _VDMEXTS_CF31




#ifdef FE_SB

// Extra WOW compatibility flags for DBCS.
// Kept in CURRENTPTD->dwWOWCompatFlagsFE.
#ifdef _VDMEXTS_CF_IME
{"WOWCF_FE_AMIPRO_PM4J_IME",         0x00000001},
{"WOWCF_FE_FORCEREGQRYLEN",          0x00000002},
{"WOWCF_FE_AUDITNOTEPAD",            0x00000004},
{"WOWCF_FE_USEUPPER",                0x00000008},

{"WOWCF_FE_ASWHELPER",               0x00000010},
{"WOWCF_FE_PPT4J_IME_GETVERSION",    0x00000020},
{"WOWCF_FE_WORDJ_IME_GETVERSION",    0x00000040},
{"WOWCF_FE_FLW2_PRINTING_PS",        0x00000080},

{"WOWCF_FE_ARIRANG20_PRNDLG",        0x00000100},
{"WOWCF_FE_BCW45J_COMMDLG",          0x00000200},
{"WOWCF_FE_DIRECTOR_START",          0x00000400},
{"WOWCF_FE_QPW_FIXINVALIDWINHANDLE", 0x00000800},

{"WOWCF_FE_ICHITARO_ITALIC",         0x00001000},
#endif _VDMEXTS_CF_IME

#endif  // FE_SB


#else  // ! _VDMEXTS_CFLAGS
       // -- end the string tables included by mvdm\vdmexts\wow.c



//
// This part gets included by everything else
//


// Original WOW compatibility flags
// Kept in CURRENTPTD->dwWOWCompatFlags.
#define WOWCF_GRAINYTICS              0x80000000   // For apps that don't trust small GetTickCount deltas
#define WOWCF_FAKEJOURNALRECORDHOOK   0x40000000   // Used for MS Mail's MAILSPL
#define WOWCF_EDITCTRLWNDWORDS        0x20000000   // Used for Clip-Art Window Shopper SHOPPER
#define WOWCF_SYNCHRONOUSDOSAPP       0x10000000   // Used for BeyondMail installation
#define WOWCF_NOTDOSSPAWNABLE         0x08000000   // For apps that can't be spawned by dos as wowapps
#define WOWCF_RESETPAPER29ANDABOVE    0x04000000   // Used for WordPerfect DC_PAPERS
#define WOWCF_4PLANECONVERSION        0x02000000   // Used for PhotoShop 4pl-1bpp to 1pl-4bpp
#define WOWCF_MGX_ESCAPES             0x01000000   // Used for MicroGraphax Escapes
#define WOWCF_CREATEBOGUSHWND         0x00800000   // Explorapedia People has problems with handle recycling -- see bug #189004
#define WOWCF_SANITIZEDOTWRSFILES     0x00400000   // For WordPerfect printing on CONNECTED printers
#define WOWCF_SIMPLEREGION            0x00200000   // used to force simple region from GetClipBox
#define WOWCF_NOWAITFORINPUTIDLE      0x00100000   // InstallShield setup toolkit 3.00.077?.0 - 3.00.099.0 deadlock without this
#define WOWCF_DSBASEDSTRINGPOINTERS   0x00080000   // used for winworks2.0a so that it gets DS based string pointers
#define WOWCF_LIMIT_MEM_FREE_SPACE    0x00040000   // For apps that can't handle huge values returned by GetFreeSpace() (Automap Streets)
#define WOWCF_DONTRELEASECACHEDDC     0x00020000   // improv chart tool uses a released dc to get text extents, the dc is still usable on win3.1

// note: this is no longer set in the registry for PM5APP but users of older
//       versions of PM5 may need to set it manually - a-craigj
#define WOWCF_FORCETWIPSESCAPE        0x00010000   // PM5, force twips in Escape() of DOWNLOADFACE, GETFACENAME
#define WOWCF_LB_NONNULLLPARAM        0x00008000   // SuperProject: sets lParam of LB_GETTEXLEN message
#define WOWCF_FORCENOPOSTSCRIPT       0x00004000   // GetTechnology wont say PostScript.
#define WOWCF_SETNULLMESSAGE          0x00002000   // Winproj Tutorial: sets lpmsg->message = 0 in peekmessage
#define WOWCF_GWLINDEX2TO4            0x00001000   // PowerBuild30 uses index 2 on [S/G]etWindowLong for LISTBOXs, change it to 4 for NT. This is because, it is 16 bits on Win 31. and 32 bits on NT.
#define WOWCF_NEEDSTARTPAGE           0x00000800   // PhotoShop needs it
#define WOWCF_NEEDIGNORESTARTPAGE     0x00000400   // XPress needs it
#define WOWCF_NOPC_RECTANGLE          0x00000200   // QP draws bad if GetDeviceCaps(POLYGONALCAPS) sets PC_RECTANGLE
#define WOWCF_NOFIRSTSAVE             0x00000100   // Wordperfect needs it for meta files
#define WOWCF_ADD_MSTT                0x00000080   // FH4.0 needs to print on PS drivers
#define WOWCF_UNLOADNETFONTS          0x00000040   // Need to track an unload font loaded over net
#define WOWCF_GETDUMMYDC              0x00000020   // Corel Draw passes a NULL hDC to EnumMetaFile, we'll create a dummy to keep GDI32 happy.
#define WOWCF_DBASEHANDLEBUG          0x00000010   // Borland dBase handle bug
#define WOWCF_NOCBDIRTHUNK            0x00000008   // don't thunk CB_DIR lParam when sent to a subclassed window in PagePlus 3.0
#define WOWCF_WMMDIACTIVATEBUG        0x00000004   // Corel Chart doesn't pass correct params for WM_MDIACTIVATE (see ThunkWMMsg16())
#define WOWCF_UNIQUEHDCHWND           0x00000002   // For apps that assume that an hDC != hWnd
#define WOWCF_GWLCLRTOPMOST           0x00000001   // Lotus Approach needs the WS_EX_TOPMOST bit cleared on GWL of NETDDE AGENT window



// Extra WOW compatibility flags bit definitions (WOWCFEX_).  These flags
// are kept in CURRENTPTD->dwWOWCompatFlagsEx.
//
#define WOWCFEX_SENDPOSTEDMSG         0x80000000   // Lotus MM Reader.exe has message synchronization problem -- used to convert PostMessage() calls to SendMessage()
#define WOWCFEX_BOGUSPOINTER          0x40000000   // QuarkExpress v3.31 passes a hard coded 7FFF:0000 as the pointer to a RECT struct in an EM_GETRECT message
#define WOWCFEX_GETVERSIONHACK        0x20000000   // Set for programs we *may* wish to return 3.95 from GetVersion for.  WK32WowShouldWeSayWin95 restricts this further.
#define WOWCFEX_FIXDCFONT4MENUSIZE    0x10000000   // WP tutorial assumes that the font used to draw the menus is the same as the font selected into the hDc for the desktop window (hwnd == 0). This hack forces the use of the correct hDC.
#define WOWCFEX_RESTOREEXPLORER       0x08000000   // Symantec Q&A Install "restores" shell= by restoring saved copy of system.ini, fix it to explorer.exe
#define WOWCFEX_LONGWINEXECTAIL       0x04000000   // Intergraph Transcend setup uses too-long command tail with WinExec, don't fail if this flag is set.
#define WOWCFEX_FORCEINCDPMI          0x02000000   // Power Builder 4.0 needs to see DPMI alloc's with ever increasing linear address's. This is needed by Peachtree's WBT32 engine as well
#define WOWCFEX_SETCAPSTACK           0x01000000   // MS Works has unintialized variable. Hack stack to work around it.
#define WOWCFEX_NODIBSHERE            0x00800000   // PhotoShop 2.5 has bug getting DIB's from clipboard
#define WOWCFEX_PIXELMETRICS          0x00400000   // Freelance Tutorial, BorderWidth: winini metrics should be returned as pixels, not TWIPS
#define WOWCFEX_DEFWNDPROCNCCALCSIZE  0x00200000   // Pass WM_NCCALCSIZE to DefWindowProc for Mavis Beacon so USER 32 will set corect window flags.
#define WOWCFEX_DIBDRVIMAGESIZEZERO   0x00100000   // Return memory DC for dib.drv biSizeImage == 0  - Director 4.01
#define WOWCFEX_GLOBALDELETEATOM      0x00080000   // For Envoy viewer that ships with Word perfect office
#define WOWCFEX_IGNORECLIENTSHUTDOWN  0x00040000   // TurboCAD picks up saved 32-bit FS (x3b) and passes it as msg to DefFrameProc
#define WOWCFEX_ZAPGPPSDEFBLANKS      0x00020000   // Peachtree Accounting depends on GetPrivateProfileString zapping trailing blanks in caller's lpszDefault.
#define WOWCFEX_FAKECLASSINFOFAIL     0x00010000   // A bug in PageMaker 50a depends on the GetClassInfo failing in Win3.1 where it succeeds on NT
#define WOWCFEX_SAMETASKFILESHARE     0x00008000   // Broderbund Living Books install opens "install.txt" DENY ALL, and then tries to open it again
#define WOWCFEX_SAYITSNOTTHERE        0x00004000   // CrossTalk 2.2 hangs if it finds Printer/Device entry in xtalk.ini
#define WOWCFEX_BROKENFLATPOINTER     0x00002000   // Adobe Premiere 4.0 has a bug in its aliasing code which can touch unallocated memory
#define WOWCFEX_USEMCIAVI16           0x00001000   // Use 16-bit mciavi.drv for max compatibility
#define WOWCFEX_SAYNO2DRAWPATTERNRECT 0x00000800   // Many apps either don't handle DRP correctly or can't handle the 32-bit ones.
#define WOWCFEX_FAKENOTAWINDOW        0x00000400   // bug #235916 fail IsWindow calls for apps that get burned by handle recycling
#define WOWCFEX_NODIRECTHDPOPUP       0x00000200   // Indicates that we should not do a direct hardware popup for the app
#define WOWCFEX_ALLOWLFNDIALOGS       0x00000100   // Indicates that GetOpenFilename should support LFN
#define WOWCFEX_THUNKLBSELITEMRANGEEX 0x00000080   // Indicates that we should thunk the LB_SELITEMRANGEEX message (LB_ADDSTRING+3 in wow land)
#define WOWCFEX_LIMITFINDFIRSTLEN     0x00000040   // Indicates that we should limit length of findfirst to 64 bytes
#define WOWCFEX_USEWINHELP32          0x00000020   // Forces an app to use Winhlp32 instead of winhelp.
#define WOWCFEX_PLATFORMVERSIONLIE    0x00000010   // Version Lies to the application by returning the value 1 (for Win95, 98, and ME) as the Platform.
#define WOWCFEX_SP2CSDVERSIONLIE      0x00000008   // Service Pack Version Lie by replacing the szCSDVersion param in the OSVERSIONINFO structure
#define WOWCFEX_EATDEVMODEMSG         0x00000004   // Some apps (access2.0 one of them) need to have wm_devmodechange blocked bug 189703
#define WOWCFEX_DISPMODE256           0x00000002   // Some apps need 256 color mode to work
// Note: This was put at 0x00000001 because it was back ported to 3.51 SP5
#define WOWCFEX_FORMFEEDHACK          0x00000001   // For apps that send a final form feed char to printer via Escape(PASSTHROUGH)


// Extra WOW User compatibility flags bit definitions (WOWCF_USER).
// Kept in CURRENTPTD->dwUserWOWCompatFlags.

#define WOWCF_USER_DDENOSYNC          0x00040000   // Winfax doesn't wait for DDE_ACK before sending dde messages

// Extra WOW2 compatibility flags bit definitions (WOWCF2_).
// Kept in CURRENTPTD->dwUserWOWCompatFlags2.
#define WOWCF2_HACKWINFLAGS           0x80000000   // GACF_HACKWINFLAGS is set if this is set
#define WOWCF2_SETFOREGROUND          0x40000000   // wow calls SetForegroundWindow during showwindow if set
#define WOWCF2_SYNCSYSFILE            0x20000000   // wow redirects file open calls for system\user.exe to system32\user.exe
#define WOWCF2_RESETCURDIR            0x10000000   // some apps need to start from exe file's directory
#define WOWCF2_DELAYTIMEGETTIME       0x08000000   // for apps that don't check if TimeGetTime diff is 0 
#define WOWCF2_FIXLUNATRAYRECT        0x04000000   // adjust the Luna tray rect to match Classic tray rect more closely
#ifdef FE_SB

// Extra WOW compatibility flags for DBCS  These flags
// are kept in CURRENTPTD->dwWOWCompatFlagsFE.
//

#define WOWCF_FE_AMIPRO_PM4J_IME         0x00000001   // AMIPRO, set sizeof(DEVMODE of Win3.1) into dmSize , ExtDeviceMode; selectively ignore IME_SETCONVERSIONWINDOW MCW_DEFAULT
                                                   // PM4J, don't pass MCW_DEFAULT to prevent display timing problem
#define WOWCF_FE_FORCEREGQRYLEN          0x00000002   // Lotus 123, set 80 into *lpcb , RegQueryValue
#define WOWCF_FE_AUDITNOTEPAD            0x00000004   // Lotus Freelance Instration program, audit to exit notepad - read.me
#define WOWCF_FE_USEUPPER                0x00000008   // Used for WinWrite "Key name"
#define WOWCF_FE_ASWHELPER               0x00000010   // AutherWare Start, call SetMenu when called AppendMenu( MF_POPUP ) : MSKKBUG 3203
#define WOWCF_FE_PPT4J_IME_GETVERSION    0x00000020   // PPT4J has a bug, expects the ime version to be 3.1 not greater.
// WARNING: For DaytonaJ RC1 Only.  Steal the following US bit for WinwordJ's TrueInLine hangup
#define WOWCF_FE_WORDJ_IME_GETVERSION    0x00000040   // Used for Telling Winword we have OldVersion IME
#define WOWCF_FE_FLW2_PRINTING_PS        0x00000080   // Lotus Freelance printing with PostScript.
                                                   // Between ESCAPE( BEGIN_PATH, CLIP_TO_PATH, END_PATH ), writing POLYGON with NULL_BRUSH
#define WOWCF_FE_ARIRANG20_PRNDLG        0x00000100   // ARiRang word processor print dialg and print setup dialog problem : Korea
#define WOWCF_FE_BCW45J_COMMDLG          0x00000200   // Boland C++ 4.5J, does not open common dialog : Japan
#define WOWCF_FE_DIRECTOR_START          0x00000400   // Director 4.0J, does not start : Japan
#define WOWCF_FE_QPW_FIXINVALIDWINHANDLE 0x00000800   // Quattro Pro Window use null window handle when it call Hanja conversion : Korea
#define WOWCF_FE_ICHITARO_ITALIC         0x00001000   // map System Mincho to MS Mincho instead of Ms P Mincho
#endif // FE_SB





// Win3.1/Win95/User32 compatibility bits (GACF_).  These flags
// are kept in CURRENTPTD->dwCompatFlags, the 16-bit TDB,
// and over in user.
//
#ifndef _WINGDIP_         // these are defined by wingdip.h as well.


#define GACF_IGNORENODISCARD        0x00000001
#define GACF_FORCETEXTBAND          0x00000002
#define GACF_USEPRINTINGESCAPES     0x00000004      // re-use GACF_ONELANDGRXBAND
#define GACF_IGNORETOPMOST          0x00000008
#define GACF_CALLTTDEVICE           0x00000010
#define GACF_MULTIPLEBANDS          0x00000020
#define GACF_ALWAYSSENDNCPAINT      0x00000040
#define GACF_EDITSETTEXTMUNGE       0x00000080
#define GACF_MOREEXTRAWNDWORDS      0x00000100
#define GACF_TTIGNORERASTERDUPE     0x00000200
#define GACF_HACKWINFLAGS           0x00000400
#define GACF_DELAYHWHNDSHAKECHK     0x00000800
#define GACF_ENUMHELVNTMSRMN        0x00001000
#define GACF_ENUMTTNOTDEVICE        0x00002000
#define GACF_SUBTRACTCLIPSIBS       0x00004000
#define GACF_FORCERASTERMODE        0x00008000      // re-use GACF_FORCETTGRAPHICS
#define GACF_NOHRGN1                0x00010000
#define GACF_NCCALCSIZEONMOVE       0x00020000
#define GACF_SENDMENUDBLCLK         0x00040000
#define GACF_30AVGWIDTH             0x00080000
#define GACF_GETDEVCAPSNUMLIE       0x00100000

#define GACF_WINVER31               0x00200000      //
#define GACF_INCREASESTACK          0x00400000      //
#define GACF_FORCEWIN31DEVMODESIZE  0x00800000      // (replaces PEEKMESSAGEIDLE)
#define GACF_DISABLEFONTASSOC       0x01000000      // Used in FE only aka GACF_JAPANESCAPEMENT
#define GACF_IGNOREFAULTS           0x02000000      //
#define GACF_NOEMFSPOOLING          0x04000000      //
#define GACF_RANDOM3XUI             0x08000000      //
#define GACF_DONTJOURNALATTACH      0x10000000      //
#define GACF_NOBRUSHCACHE           0x20000000      // re-use GACF_DISABLEDBCSPROPTT
#define GACF_MIRRORREGFONTS         0x40000000      //


#endif // _WINGDIP_


#endif // ! _VDMEXTS_CFLAGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowcomm.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWCOMM.H
 *  Constants, macros, etc common to WOW16/WOW32
 *
 *  History:
 *  Created 28-Apr-1993 by Craig Jones (v-cjones)
 *
--*/
#ifndef __WOWCOMM__  // has this been included before?
#define __WOWCOMM__

#ifndef UNALIGNED    // this makes UNALIGNED visible only to 32-bit stuff
#define UNALIGNED    // and invisible to 16-bit stuff
#endif

/* XLATOFF */
#pragma pack(1)
/* XLATON */

// COMDEB - Communications Device Equipment Block.  (copied from ibmcom.inc)
//
// This is essentially a superset of the DCB used outside of this
// module. The DCB is contained within the DEB as the first fields.
// The fields which follow are data and status fields which
// are unique to this implementation.
//
// AltQInAddr and AltQOutAddr are alternate queue pointers which are used when
// in "supervisor" mode.  Supervisor mode is a processor mode other than the
// one which Windows normally runs in.  In standard mode Windows, supervisor
// mode is REAL mode.  In enhanced mode Windows, supervisor mode is RING 0
// protected mode.  For more details see comments in IBMINT.ASM.

// RS232 Data Equip Block
typedef struct _COMDEB16 {  /* cdeb16 */
  BYTE   ComDCB;          // size of this struct
  WORD   ComErr;          // Non-zero if I/O error
  WORD   Port;            // Base I/O Address
  WORD   NotifyHandle;
  WORD   NotifyFlags;
  WORD   RecvTrigger;     // char count threshold for calling
  WORD   SendTrigger;     // char count threshold for calling

// The following fields are specific to com ports only
  WORD   IRQhook;         // ptr to IRQ_Hook_Struc
  WORD   NextDEB;         // ptr to next DEB that is sharing IRQ
  WORD   XOffPoint;       // Q count where XOff is sent
  WORD   EvtMask;         // Mask of events to check for
  WORD   EvtWord;         // Event flags
  DWORD  QInAddr;         // Address of the queue
  DWORD  AltQInAddr;      // Addr of queue in "supervisor" mode
  WORD   QInSize;         // Length of queue in bytes
  DWORD  QOutAddr;        // Address of the queue
  DWORD  AltQOutAddr;     // Addr of queue in "supervisor" mode
  WORD   QOutSize;        // Length of queue in bytes
  WORD   QInCount;        // Number of bytes currently in queue
  WORD   QInGet;          // Offset into queue to get bytes from
  WORD   QInPut;          // Offset into queue to put bytes in
  WORD   QOutCount;       // Number of bytes currently in queue
  WORD   QOutGet;         // Offset into queue to get bytes from
  WORD   QOutPut;         // Offset into queue to put bytes in
  BYTE   EFlags;          // Extended flags
  BYTE   MSRShadow;       // Modem Status Register Shadow
  BYTE   ErrorMask;       // Default error-checking mask
  BYTE   RxMask;          // Character mask
  BYTE   ImmedChar;       // Char to be transmitted immediately
  BYTE   HSFlag;          // Handshake flag
  BYTE   HHSLines;        // 8250 DTR/RTS bits for handshaking
  BYTE   OutHHSLines;     // Lines that must be high to output
  BYTE   MSRMask;         // Mask of Modem Lines to check
  BYTE   MSRInfinite;     // Mask of MSR lines that must be high
  BYTE   IntVecNum;       // Interrupt vector number
  BYTE   LSRShadow;       // Line Status Register shadow
  WORD   QOutMod;         // Characters sent mod xOnLim ENQ/ETX [rkh]
  DWORD  VCD_data;
  BYTE   VCDflags;
  BYTE   MiscFlags;       // still more flags
} COMDEB16;
typedef COMDEB16 UNALIGNED *PCOMDEB16;

// In 3.0 MSRShadow had this relationship to EvtWord and major COM apps all
// use this offset of 35 to get to MSRShadow so that they can determine the
// current status of the Modem Status bits.  We need to maintain this offset
// so that these apps will continue to run.

/* XLATOFF */
#pragma pack()
/* XLATON */

#endif // __WOWCOMM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wow.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOW.H
 *  Constants, macros, etc common to WOW16/WOW32
 *
 *  History:
 *  Created 25-Jan-1991 by Jeff Parsons (jeffpar)
 *  Added SHELL defines 14-April-92 Chandan Chauhan (ChandanC)
 *   and Win 31 parameter validation support.
 *  Modified 12-May-1992 by Mike Tricker (MikeTri) Added MultiMedia declarations
 *                                                 and callback support
 *
--*/


#define WIN31

#include <mvdm.h>
#include <bop.h>
#ifndef NOEXTERNS
#include <softpc.h>
#endif
#include <wownt32.h>

#ifdef i386
#ifndef DEBUG     // should be DEBUG_OR_WOWPROFILE, but
                  // that won't work for assembler as things are.

//
// Flag to control enable/disable W32TryCall function.
//

#define NO_W32TRYCALL 1
#endif
#endif

/* WOW constants
 */
#define MAX_VDMFILENAME 144 // must be >= 144 (see GetTempFileName)
#define GRAINYTIC_RES   0x3f // will truncate to lower multiple of 64


/* Logging/debugging macros
 */
/* XLATOFF */
#define GRAINYTICS(dwordtickcount)  ((dwordtickcount) & (~GRAINYTIC_RES))
#define IFLOG(l)    if (l==iLogLevel && (iLogLevel&1) || l<=iLogLevel && !(iLogLevel&1) || l == 0)

#define OPENLOG()   (hfLog != (HANDLE)-1?hfLog:(hfLog=CreateFile("log",GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,0,NULL)))
#define APPENDLOG() if (hfLog == (HANDLE)-1) {hfLog=CreateFile("log",GENERIC_WRITE,FILE_SHARE_READ,NULL,OPEN_ALWAYS,0,NULL) ; SetFilePointer (hfLog,0,NULL,FILE_END); }
#define CLOSELOG()  if (hfLog != (HANDLE)-1) {CloseHandle(hfLog); hfLog=(HANDLE)-1;}

#undef  LOG
#ifdef  NOLOG
#define LOG(l,args)
#define SETREQLOG(l)
#else
#define SETREQLOG(l) iReqLogLevel = (l)
#define LOG(l,args)  {SETREQLOG(l) ; logprintf args;}
#endif
#define MODNAME(module)

#ifdef  DEBUG
#define STATIC
#define INT3()      _asm int 3
#define IFDEBUG(f)  if (f)
#define ELSEDEBUG   else
#define LOGDEBUG(l,args) LOG(l,args)
#else
#define STATIC static
#define INT3()
#define IFDEBUG(f)
#define ELSEDEBUG
#define LOGDEBUG(l,args)
#endif
/* XLATON */


/* 16-bit Windows constants
 */
#define CW_USEDEFAULT16 ((SHORT)0x8000)


/* 16-bit Windows types
 */
typedef WORD    HAND16;
typedef WORD    HTASK16;
typedef WORD    HINST16;
typedef WORD    HMOD16;
typedef WORD    HRES16;
typedef WORD    HRESI16;
typedef WORD    HRESD16;
typedef WORD    HWND16;
typedef WORD    HMENU16;
typedef WORD    HDC16;
typedef WORD    HRGN16;
typedef WORD    HICON16;
typedef WORD    HCUR16;
typedef WORD    HBRSH16;
typedef WORD    HPAL16;
typedef WORD    HBM16;
typedef WORD    HFONT16;
typedef WORD    HMEM16;
typedef DWORD   HHOOK16;

typedef WORD    HMMIO16;  // for MultiMedia - MikeTri 12-May-1992
typedef WORD    HMIDIIN16;
typedef WORD    HMIDIOUT16;
typedef WORD    HWAVEIN16;
typedef WORD    HWAVEOUT16;
typedef WORD    HDRVR16;
typedef DWORD   HPSTR16;

typedef SHORT   INT16;
typedef SHORT   BOOL16;

/* 16-bit pointer types (VP == VDM Ptr)
 */
typedef DWORD   VPVOID;     // VDM address (seg:off)
typedef VPVOID  VPBYTE;     //
typedef VPVOID  VPWORD;     //
typedef VPVOID  VPDWORD;    //
typedef VPVOID  VPSHORT;    //
typedef VPVOID  VPLONG;     //
typedef VPVOID  VPSTR;      // should use VPSZ or VPBYTE instead, as approp.
typedef VPVOID  VPSZ;       //
typedef VPVOID  VPPROC;     //
typedef VPVOID  VPWNDPROC;  //
typedef VPVOID  VPINT16;    //
typedef VPVOID  VPBOOL16;   //
typedef VPVOID  *PVPVOID;   // pointer to VDM address

typedef VPVOID  VPCSTR;     // MultiMedia Extensions - MikeTri 12-May-1992
typedef VPVOID  VPMMIOPROC16;
typedef VPVOID  VPHMIDIIN16;
typedef VPVOID  VPHMIDIOUT16;
typedef VPVOID  VPPATCHARRAY16;
typedef VPVOID  VPKEYARRAY16;
typedef VPVOID  VPHWAVEIN16;
typedef VPVOID  VPHWAVEOUT16;
typedef VPVOID  VPTIMECALLBACK16;
typedef VPVOID  VPTASKCALLBACK16;

/* Types
 */
typedef ULONG   (FASTCALL *LPFNW32)(PVDMFRAME);

/* Dispatch table entry
**
 */
typedef struct _W32 {   /* w32 */
    LPFNW32 lpfnW32;    // function address
#ifdef DEBUG_OR_WOWPROFILE
    LPSZ    lpszW32;    // function name (DEBUG version only)
    DWORD   cbArgs;     // # of bytes of arguments (DEBUG version only)
    DWORD   cCalls;     // # of times this API called
    DWORD   cTics;      // sum total # of tics ellapsed for all invocations
#endif // DEBUG_OR_WOWPROFILE
} W32, *PW32;

/* XLATOFF */
#pragma pack(1)
/* XLATON */

/* Window proc/dialog box callback function parameter format
 */
typedef struct _PARMWP {    /* wp */
    LONG    lParam;     //
    WORD    wParam;     //
    WORD    wMsg;       //
    WORD    hwnd;       //
    WORD    hInst;      // hInstance of window that we are returning to
} PARMWP;


/* EnumPropsProc callback function parameter format
 */
typedef struct _PARMEPP {   /* epp */
    HAND16  hData;
    VPVOID  vpString;
    HWND16  hwnd;
} PARMEPP;


/* EnumWindows/EnumChildWindows/EnumTaskWindows callback function parameter format
 */
typedef struct _PARMEWP {       /* ewp */
    LONG    lParam;             // app-defined data
    HWND16  hwnd;               // 16-bit window handle
} PARMEWP;


/* EnumFonts callback function parameter format
 */
typedef struct _PARMEFP {       /* efp */
    VPVOID  vpData;     // app-defined data
    SHORT   nFontType;      //
    VPVOID  vpTextMetric;   // pointer to TEXTMETRIC16
    VPVOID  vpLogFont;      // pointer to LOGFONT16
} PARMEFP;


/* EnumObj callback function parameter format
 */
typedef struct _PARMEOP {       /* eop */
    VPVOID  vpData;     // app-defined data
    VPVOID  vpLogObject;
} PARMEOP;


/* EnumMetaFile callback function parameter format
 */
typedef struct _PARMEMP {       /* emp */
    VPVOID  vpData;     // app-defined data
    SHORT   nObjects;       // # objects
    VPVOID  vpMetaRecord;   // pointer to METARECORD16
    VPVOID  vpHandleTable;  // pointer to HANDLETABLE16
    HDC16   hdc;        // hdc
} PARMEMP;

/* Hook Callback function parameter format
 */
typedef struct _PARMHKP {       /* hkp */
    VPVOID  lParam;
    SHORT   wParam;
    SHORT   nCode;          // action code
} PARMHKP;

/* Subclass Callback function parameter format
 */
typedef struct _PARMSCP {       /* scp */
    SHORT    iOrdinal;          // oridnal number;
} PARMSCP;

/* LineDDA Callback function parameter format
 */
typedef struct _PARMDDA {   /* dda */
    VPVOID vpData;
    SHORT  y;
    SHORT  x;
} PARMDDA;

/* Graystring callback function parameter format
 */
typedef struct _PARMGST {   /* gst */
    SHORT n;
    DWORD data;
    HDC16 hdc;
} PARMGST;


typedef struct _PARMDIR { /* cdir */
    SHORT wDrive;
    VPSZ  vpDir;  // directory name
} PARMDIR;

typedef struct _PARMSAP { /* sap */
    SHORT  code;    //
    HAND16 hPr;
} PARMSAP;


/* WordBreakProc callback function parameter format
 */
typedef struct _PARMWBP {       /* wbp */
    SHORT   action;
    SHORT   cbEditText;
    SHORT   ichCurrentWord;
    VPVOID  lpszEditText;
} PARMWBP;


/*++

  MultiMedia callback definitions added, and also to _PARM16 - MikeTri

--*/

/* midiInOpen (MidiInFunc) Callback function parameter format
 */

typedef struct _PARMMIF {       /* mif */
    DWORD     dwParam2;
    DWORD     dwParam1;
    DWORD     dwInstance;
    WORD      wMsg;
    HMIDIIN16 hMidiIn;
} PARMMIF;

/* midiOutOpen (MidiOutFunc) Callback function parameter format
 */

typedef struct _PARMMOF {       /* mof */
    DWORD      dwParam2;
    DWORD      dwParam1;
    DWORD      dwInstance;
    WORD       wMsg;
    HMIDIOUT16 hMidiOut;
} PARMMOF;

/* mmioInstallIOProc (IOProc) Callback function parameter format
 */

typedef struct _PARMIOP {      /* iop */
    LONG      lParam2;
    LONG      lParam1;
    WORD      wMsg;
    VPVOID    lpmmioinfo;
} PARMIOP;

/* timeSetEvent (TimeFunc) Callback function parameter format
 */

typedef struct _PARMTIF {       /* tif */
    DWORD     dw2;
    DWORD     dw1;
    DWORD     dwUser;
    WORD      wMsg;
    WORD      wID;
} PARMTIF;

/* waveInOpen (WaveInFunc) Callback function parameter format
 */

typedef struct _PARMWIF {       /* wif */
    DWORD     dwParam2;
    DWORD     dwParam1;
    DWORD     dwInstance;
    WORD      wMsg;
    HWAVEIN16 hWaveIn;
} PARMWIF;

/* waveOutOpen (WaveOutFunc) Callback function parameter format
 */

typedef struct _PARMWOF {       /* wof */
    DWORD      dwParam2;
    DWORD      dwParam1;
    DWORD      dwInstance;
    WORD       wMsg;
    HWAVEOUT16 hWaveOut;
} PARMWOF;

/* WOWCallback16 function parameter format
 */

typedef struct _PARMWCB16 {       /* wcb16 */
    WORD       wArgs[8];
} PARMWCB16;

typedef struct _PARMLSTRCMP {     /* lstrcmp16 */
    VPVOID     lpstr1;
    VPVOID     lpstr2;
} PARMLSTRCMP;

/* PARM16 is the union of all the callback parameter structures
 */
typedef union _PARM16 {     /* parm16 */
    PARMWP  WndProc;        // for window procs
    PARMEWP EnumWndProc;        // for window enum functions
    PARMEFP EnumFontProc;       // for font enum functions
    PARMEOP EnumObjProc;       // for obj enum functions
    PARMEMP EnumMetaProc;       // for metafile enum functions
    PARMEPP EnumPropsProc;  // for properties
    PARMHKP HookProc;           // for Hooks
    PARMSCP SubClassProc;   // for subclass thunks
    PARMDDA LineDDAProc;    // for LineDDA
    PARMGST GrayStringProc; // for GrayString
    PARMDIR CurDir;
    PARMSAP SetAbortProc;   // for SetAbortProc
    PARMMIF MidiInFunc;         // for midiInOpen functions - MikeTri 27-Mar-1992
    PARMMOF MidiOutFunc;        // for midiOutOpen functions
    PARMIOP IOProc;             // for mmioInstallIOProc functions
    PARMTIF TimeFunc;           // for timeSetEvent functions
    PARMWIF WaveInFunc;         // for waveInOpen functions
    PARMWOF WaveOutFunc;        // for waveOutOpen functions
    PARMWBP WordBreakProc;      // for WordBreakProc
    PARMWCB16 WOWCallback16;    // for WOWCallback16
    PARMLSTRCMP lstrcmpParms;   // for WOWlstrcmp16 (pfnWowIlstrsmp to user32)
} PARM16, *PPARM16;


/* VDMFRAME is built by wow16cal.asm in the kernel, and is utilized
 * by all the WOW32 thunks
 */
typedef struct _VDMFRAME {  /* vf */
    WORD    wTDB;       // 16-bit kernel handle for calling task
    WORD    wRetID;     // internal call-back function ID Do NOT Move
    WORD    wLocalBP;   //
    WORD    wDI;        //
    WORD    wSI;        //
    WORD    wAX;        //
    WORD    wDX;        // keep DX right after AX!!!
    WORD    wAppDS;     // app DS at time of call
    WORD    wGS;
    WORD    wFS;
    WORD    wCX;        // REMOVE LATER
    WORD    wES;        // REMOVE LATER
    WORD    wBX;        // REMOVE LATER
    WORD    wBP;        // BP Chain +1
    VPVOID  wThunkCSIP; // ret addr of THUNK - update wowtd.h if you move it
    DWORD   wCallID;    // internal WOW16 module/function ID
    WORD    cbArgs;     // byte count of args pushed
    VPVOID  vpCSIP;     // far return address to app
    BYTE    bArgs;      // start of arguments from app
} VDMFRAME;
typedef VDMFRAME UNALIGNED *PVDMFRAME;

/* CBVDMFRAME is built by callback16 in wow32.dll and in wow16cal.asm
 * the definition of VDMFRAME and CBACKVDMFRAME must be in sync
 */

typedef struct _CBVDMFRAME {  /* cvf */
    WORD    wTDB;       // must match VDMFRAME
    WORD    wRetID;     // must match VDMFRAME
    WORD    wLocalBP;   // must match VDMFRAME
    PARM16  Parm16;     // space for window/enum proc parameters
    VPVOID  vpfnProc;   // address of window/enum proc
    DWORD   vpStack;    // orginal ss:sp. used in callback16
    WORD    wAX;        //
    WORD    wDX;        // keep DX right after AX!!!
    WORD    wGenUse1;   // extra words for general use. for convenience
    WORD    wGenUse2;   // extra words for general use. for convenience
} CBVDMFRAME;
typedef CBVDMFRAME UNALIGNED *PCBVDMFRAME;

typedef struct _POINT16 {       /* pt16 */
    SHORT   x;
    SHORT   y;
} POINT16;
typedef POINT16 UNALIGNED *PPOINT16;
typedef VPVOID VPPOINT16;

/* POINTL16 is new for Win95 and is identical to Win32 POINT/POINTL structures */

typedef struct _POINTL16 {       /* ptl16 */
    LONG   x;
    LONG   y;
} POINTL16;
typedef POINTL16 UNALIGNED *PPOINTL16;
typedef VPVOID VPPOINTL16;

typedef struct _RASTERIZER_STATUS16 {  /* rs16 */
    INT16   nSize;
    INT16   wFlags;
    INT16   nLanguageID;
} RASTERIZER_STATUS16;
typedef RASTERIZER_STATUS16 UNALIGNED *PRASTERIZER_STATUS16;
typedef VPVOID VPRASTERIZER_STATUS16;

typedef struct _GLYPHMETRICS16 {  /*glyph16 */
    WORD    gmBlackBoxX;
    WORD    gmBlackBoxY;
    POINT16 gmptGlyphOrigin;
    INT16   gmCellIncX;
    INT16   gmCellIncY;
} GLYPHMETRICS16;
typedef GLYPHMETRICS16 UNALIGNED *PGLYPHMETRICS16;
typedef VPVOID VPGLYPHMETRICS16;

typedef struct _ABC16 {        /* abc16 */
    INT16   abcA;
    WORD    abcB;
    INT16   abcC;
} ABC16;
typedef ABC16 UNALIGNED *PABC16;
typedef VPVOID VPABC16;

typedef struct _FIXED16 {        /* fxd16 */
    WORD    fract;
    INT16   value;
} FIXED16;
typedef FIXED16 UNALIGNED *PFIXED16;
typedef VPVOID VPFIXED16;

typedef struct _MAT216 {        /* mat216 */
    FIXED16 eM11;
    FIXED16 eM12;
    FIXED16 eM21;
    FIXED16 eM22;
} MAT216;
typedef MAT216 UNALIGNED *PMAT216;
typedef VPVOID VPMAT216;


/* 16-bit API structures, and their pointers
 */
typedef struct _RECT16 {        /* rc16 */
    SHORT   left;
    SHORT   top;
    SHORT   right;
    SHORT   bottom;
} RECT16;
typedef RECT16 UNALIGNED *PRECT16;
typedef VPVOID VPRECT16;

/* RECTL16 is new for Win95 and is identical to Win32 RECTL structure */

typedef struct _RECTL16 {        /* rcl16 */
    LONG   left;
    LONG   top;
    LONG   right;
    LONG   bottom;
} RECTL16;
typedef RECTL16 UNALIGNED *PRECTL16;
typedef VPVOID VPRECTL16;

typedef struct _KERNINGPAIR16 {        /* k16 */
    WORD   wFirst;
    WORD   wSecond;
    INT16  iKernAmount;
} KERNINGPAIR16;
typedef KERNINGPAIR16 UNALIGNED *PKERNINGPAIR16;
typedef VPVOID VPKERNINGPAIR16;




typedef struct _MSG16 {         /* msg16 */
    HWND16  hwnd;
    WORD    message;
    WORD    wParam;
    LONG    lParam;
    DWORD   time;
    POINT16 pt;
} MSG16;
typedef MSG16 UNALIGNED *PMSG16;
typedef VPVOID VPMSG16;

typedef struct _PAINTSTRUCT16 {     /* ps16 */
    HDC16   hdc;
    BOOL16  fErase;
    RECT16  rcPaint;
    BOOL16  fRestore;
    BOOL16  fIncUpdate;
    BYTE    rgbReserved[16];
} PAINTSTRUCT16;
typedef PAINTSTRUCT16 UNALIGNED *PPAINTSTRUCT16;
typedef VPVOID VPPAINTSTRUCT16;

typedef struct _WNDCLASS16 {        /* wc16 */
    WORD    style;
    VPWNDPROC vpfnWndProc;
    SHORT   cbClsExtra;
    SHORT   cbWndExtra;
    HAND16  hInstance;
    HICON16 hIcon;
    HCUR16  hCursor;
    HBRSH16 hbrBackground;
    VPSZ    vpszMenuName;
    VPSZ    vpszClassName;
} WNDCLASS16;
typedef WNDCLASS16 UNALIGNED *PWNDCLASS16;
typedef VPVOID VPWNDCLASS16;

typedef struct _PALETTEENTRY16 {    /* pe16 */
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY16;
typedef PALETTEENTRY16 UNALIGNED *PPALETTEENTRY16;
typedef VPVOID VPPALETTEENTRY16;

typedef struct _RGBTRIPLE16 {       /* rgbt16 */
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE16;

typedef struct  _BITMAPCOREHEADER16 { /* bmch16 */
    DWORD   bcSize;
    WORD    bcWidth;
    WORD    bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER16;
typedef BITMAPCOREHEADER16 UNALIGNED *PBITMAPCOREHEADER16;

typedef struct  _BITMAPCOREINFO16 {   /* bmci16 */
    BITMAPCOREHEADER16 bmciHeader;
    RGBTRIPLE16 bmciColors[1];
} BITMAPCOREINFO16;
typedef BITMAPCOREINFO16 UNALIGNED *PBITMAPCOREINFO16;


typedef struct  _CLIENTCREATESTRUCT16 { /* ccs16 */
    HMENU16 hWindowMenu;
    WORD    idFirstChild;
} CLIENTCREATESTRUCT16;
typedef CLIENTCREATESTRUCT16 UNALIGNED *PCLIENTCREATESTRUCT16;



typedef struct _LOGPALETTE16 {      /* logpal16 */
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY16 palPalEntry[1];
} LOGPALETTE16;
typedef LOGPALETTE16 UNALIGNED *PLOGPALETTE16;
typedef VPVOID VPLOGPALETTE16;

typedef SHORT CATCHBUF16[9];        /* cb16 */
typedef VPSHORT VPCATCHBUF16;

typedef struct _OFSTRUCT16 {        /* of16 */
    BYTE    cBytes;
    BYTE    fFixedDisk;
    WORD    nErrCode;
    BYTE    reserved[4];
    BYTE    szPathName[128];
} OFSTRUCT16;
typedef OFSTRUCT16 UNALIGNED *POFSTRUCT16;
typedef VPVOID VPOFSTRUCT16;

typedef struct _DCB16 {         /* dcb16 */
    BYTE    Id;             // Internal Device ID
    WORD    BaudRate;           // Baudrate at which runing
    BYTE    ByteSize;           // Number of bits/byte, 4-8
    BYTE    Parity;         // 0-4=None,Odd,Even,Mark,Space
    BYTE    StopBits;           // 0,1,2 = 1, 1.5, 2
    WORD    RlsTimeout;         // Timeout for RLSD to be set
    WORD    CtsTimeout;         // Timeout for CTS to be set
    WORD    DsrTimeout;         // Timeout for DSR to be set
    WORD    wFlags;             // Bitfield flags
  /*+++ These are the bitfield definitions in wFlags above --
    BYTE    fBinary: 1;         // Binary Mode (skip EOF check
    BYTE    fRtsDisable:1;      // Don't assert RTS at init time
    BYTE    fParity: 1;         // Enable parity checking
    BYTE    fOutxCtsFlow:1;     // CTS handshaking on output
    BYTE    fOutxDsrFlow:1;     // DSR handshaking on output
    BYTE    fDummy: 2;          // Reserved
    BYTE    fDtrDisable:1;      // Don't assert DTR at init time

    BYTE    fOutX: 1;           // Enable output X-ON/X-OFF
    BYTE    fInX: 1;            // Enable input X-ON/X-OFF
    BYTE    fPeChar: 1;         // Enable Parity Err Replacement
    BYTE    fNull: 1;           // Enable Null stripping
    BYTE    fChEvt: 1;          // Enable Rx character event.
    BYTE    fDtrflow: 1;        // DTR handshake on input
    BYTE    fRtsflow: 1;        // RTS handshake on input
    BYTE    fDummy2: 1;         //
  ---*/
    CHAR    XonChar;            // Tx and Rx X-ON character
    CHAR    XoffChar;           // Tx and Rx X-OFF character
    WORD    XonLim;             // Transmit X-ON threshold
    WORD    XoffLim;            // Transmit X-OFF threshold
    CHAR    PeChar;             // Parity error replacement char
    CHAR    EofChar;            // End of Input character
    CHAR    EvtChar;            // Recieved Event character
    WORD    TxDelay;            // Amount of time between chars
} DCB16;
typedef DCB16 UNALIGNED *PDCB16;
typedef VPVOID VPDCB16;

typedef struct _COMSTAT16 {     /* cs16 */
    BYTE    status;
  /*+++ These are bitfield definitions defined in status above --
    BYTE    fCtsHold: 1;        // transmit is on CTS hold
    BYTE    fDsrHold: 1;        // transmit is on DSR hold
    BYTE    fRlsdHold: 1;       // transmit is on RLSD hold
    BYTE    fXoffHold: 1;       // received handshake
    BYTE    fXoffSent: 1;       // issued handshake
    BYTE    fEof: 1;            // end of file character found
    BYTE    fTxim: 1;           // character being transmitted
  ---*/
    WORD    cbInQue;            // count of characters in Rx Queue
    WORD    cbOutQue;           // count of characters in Tx Queue
} COMSTAT16;
typedef COMSTAT16 UNALIGNED *PCOMSTAT16;
typedef VPVOID VPCOMSTAT16;

#ifdef FE_SB                     // wowfax support for Japanese
typedef struct _DEV_BITMAP16 {      /* devbm16 */
    SHORT   bmType;
    SHORT   bmWidth;
    SHORT   bmHeight;
    SHORT   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    VPBYTE  bmBits;
    LONG    bmWidthPlanes;
    LONG    bmlpPDevice;
    SHORT   bmSegmentIndex;
    SHORT   bmScanSegment;
    SHORT   bmFillBytes;
    SHORT   reserved1;
    SHORT   reserved2;
} DEV_BITMAP16;
typedef DEV_BITMAP16 UNALIGNED *PDEV_BITMAP16;
typedef VPVOID VPDEV_BITMAP16;
#endif // FE_SB

typedef struct _BITMAP16 {      /* bm16 */
    SHORT   bmType;
    SHORT   bmWidth;
    SHORT   bmHeight;
    SHORT   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    VPBYTE  bmBits;
} BITMAP16;
typedef BITMAP16 UNALIGNED *PBITMAP16;
typedef VPVOID VPBITMAP16;

typedef struct _LOGBRUSH16 {        /* lb16 */
    WORD    lbStyle;
    DWORD   lbColor;
    SHORT   lbHatch;
} LOGBRUSH16;
typedef LOGBRUSH16 UNALIGNED *PLOGBRUSH16;
typedef VPVOID VPLOGBRUSH16;

/* ASM
LF_FACESIZE equ 32
 */
typedef struct _LOGFONT16 {     /* lf16 */
    SHORT   lfHeight;
    SHORT   lfWidth;
    SHORT   lfEscapement;
    SHORT   lfOrientation;
    SHORT   lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    BYTE    lfFaceName[LF_FACESIZE];
} LOGFONT16;
typedef LOGFONT16 UNALIGNED *PLOGFONT16;
typedef VPVOID VPLOGFONT16;

/* ASM
LF_FULLFACESIZE equ 64
 */
/* Structure passed to FONTENUMPROC */
typedef struct _ENUMLOGFONT16 { /* elp16 */
    LOGFONT16   elfLogFont;
    char        elfFullName[LF_FULLFACESIZE];
    char        elfStyle[LF_FACESIZE];
} ENUMLOGFONT16;
typedef ENUMLOGFONT16 UNALIGNED *PENUMLOGFONT16;
typedef VPVOID VPENUMLOGFONT16;

typedef struct _LOGPEN16 {      /* lp16 */
    WORD    lopnStyle;
    POINT16 lopnWidth;
    DWORD   lopnColor;
} LOGPEN16;
typedef LOGPEN16 UNALIGNED *PLOGPEN16;
typedef VPVOID VPLOGPEN16;

typedef struct _RGBQUAD16 {      /* rgbq16 */
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD16;
typedef RGBQUAD16 UNALIGNED *PRGBQUAD16;
typedef VPVOID VPRGBQUAD16;

typedef BITMAPINFOHEADER BITMAPINFOHEADER16;
typedef BITMAPINFOHEADER16 UNALIGNED *PBITMAPINFOHEADER16;
typedef VPVOID VPBITMAPINFOHEADER16;

typedef BITMAPINFO BITMAPINFO16;
typedef BITMAPINFO16 UNALIGNED *PBITMAPINFO16;
typedef VPVOID VPBITMAPINFO16;

typedef struct _TEXTMETRIC16 {      /* tm16 */
    SHORT   tmHeight;
    SHORT   tmAscent;
    SHORT   tmDescent;
    SHORT   tmInternalLeading;
    SHORT   tmExternalLeading;
    SHORT   tmAveCharWidth;
    SHORT   tmMaxCharWidth;
    SHORT   tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    SHORT   tmOverhang;
    SHORT   tmDigitizedAspectX;
    SHORT   tmDigitizedAspectY;
} TEXTMETRIC16;
typedef TEXTMETRIC16 UNALIGNED *PTEXTMETRIC16;
typedef VPVOID VPTEXTMETRIC16;

typedef struct _NEWTEXTMETRIC16 {      /* ntm16 */
    SHORT   tmHeight;
    SHORT   tmAscent;
    SHORT   tmDescent;
    SHORT   tmInternalLeading;
    SHORT   tmExternalLeading;
    SHORT   tmAveCharWidth;
    SHORT   tmMaxCharWidth;
    SHORT   tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    SHORT   tmOverhang;
    SHORT   tmDigitizedAspectX;
    SHORT   tmDigitizedAspectY;
    DWORD   ntmFlags;
    WORD    ntmSizeEM;
    WORD    ntmCellHeight;
    WORD    ntmAvgWidth;
} NEWTEXTMETRIC16;
typedef NEWTEXTMETRIC16 UNALIGNED *PNEWTEXTMETRIC16;
typedef VPVOID VPNEWTEXTMETRIC16;

typedef struct _PANOSE16 {              /* pan16 */
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE16;
typedef PANOSE16 UNALIGNED *PPANOSE16;

typedef struct _OUTLINETEXTMETRIC16 {   /* otm16 */
    WORD            otmSize;
    TEXTMETRIC16    otmTextMetrics;
    BYTE            otmFiller;
    PANOSE16        otmPanoseNumber;
    WORD            otmfsSelection;
    WORD            otmfsType;
    SHORT           otmsCharSlopeRise;
    SHORT           otmsCharSlopeRun;
    SHORT           otmItalicAngle;
    WORD            otmEMSquare;
    SHORT           otmAscent;
    SHORT           otmDescent;
    WORD            otmLineGap;
    WORD            otmsCapEmHeight;
    WORD            otmsXHeight;
    RECT16          otmrcFontBox;
    SHORT           otmMacAscent;
    SHORT           otmMacDescent;
    WORD            otmMacLineGap;
    WORD            otmusMinimumPPEM;
    POINT16         otmptSubscriptSize;
    POINT16         otmptSubscriptOffset;
    POINT16         otmptSuperscriptSize;
    POINT16         otmptSuperscriptOffset;
    WORD            otmsStrikeoutSize;
    SHORT           otmsStrikeoutPosition;
    SHORT           otmsUnderscorePosition;
    SHORT           otmsUnderscoreSize;
    WORD            otmpFamilyName;
    WORD            otmpFaceName;
    WORD            otmpStyleName;
    WORD            otmpFullName;
} OUTLINETEXTMETRIC16;
typedef OUTLINETEXTMETRIC16 UNALIGNED *POUTLINETEXTMETRIC16;
typedef VPVOID VPOUTLINETEXTMETRIC16;

typedef struct _HANDLETABLE16 {     /* ht16 */
    HAND16  objectHandle[1];
} HANDLETABLE16;
typedef HANDLETABLE16 UNALIGNED *PHANDLETABLE16;
typedef VPVOID VPHANDLETABLE16;

typedef struct _METARECORD16 {      /* mr16 */
    DWORD   rdSize;
    WORD    rdFunction;
    WORD    rdParm[1];
} METARECORD16;
typedef METARECORD16 UNALIGNED *PMETARECORD16;
typedef VPVOID VPMETARECORD16;

typedef struct _DEVMODE16 {     /* dm16 */
    CHAR    dmDeviceName[32];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    SHORT   dmOrientation;
    SHORT   dmPaperSize;
    SHORT   dmPaperLength;
    SHORT   dmPaperWidth;
    SHORT   dmScale;
    SHORT   dmCopies;
    SHORT   dmDefaultSource;
    SHORT   dmPrintQuality;
    SHORT   dmColor;
    SHORT   dmDuplex;
} DEVMODE16;
typedef DEVMODE16 UNALIGNED *PDEVMODE16;
typedef VPVOID VPDEVMODE16;

typedef struct _DEVMODE31 {     /* dm31 */
    CHAR    dmDeviceName[32];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    SHORT   dmOrientation;
    SHORT   dmPaperSize;
    SHORT   dmPaperLength;
    SHORT   dmPaperWidth;
    SHORT   dmScale;
    SHORT   dmCopies;
    SHORT   dmDefaultSource;
    SHORT   dmPrintQuality;
    SHORT   dmColor;
    SHORT   dmDuplex;
    SHORT   dmYResolution;
    SHORT   dmTTOption;
} DEVMODE31;
typedef DEVMODE31 UNALIGNED *PDEVMODE31;
typedef VPVOID VPDEVMODE31;

typedef struct _CREATESTRUCT16 {    /* cws16 */
    VPBYTE  vpCreateParams;
    HAND16  hInstance;
    HMENU16 hMenu;
    HWND16  hwndParent;
    SHORT   cy;
    SHORT   cx;
    SHORT   y;
    SHORT   x;
    DWORD   dwStyle;
    VPSZ    vpszWindow;
    VPSZ    vpszClass;
    DWORD   dwExStyle;
} CREATESTRUCT16;
typedef CREATESTRUCT16 UNALIGNED *PCREATESTRUCT16;
typedef VPVOID VPCREATESTRUCT16;

typedef struct _DRAWITEMSTRUCT16 {  /* dis16 */
    WORD    CtlType;
    WORD    CtlID;
    WORD    itemID;
    WORD    itemAction;
    WORD    itemState;
    HWND16  hwndItem;
    HDC16   hDC;
    RECT16  rcItem;
    DWORD   itemData;
} DRAWITEMSTRUCT16;
typedef DRAWITEMSTRUCT16 UNALIGNED *PDRAWITEMSTRUCT16;
typedef VPVOID VPDRAWITEMSTRUCT16;

typedef struct _MEASUREITEMSTRUCT16 {   /* mis16 */
    WORD    CtlType;
    WORD    CtlID;
    WORD    itemID;
    WORD    itemWidth;
    WORD    itemHeight;
    DWORD   itemData;
} MEASUREITEMSTRUCT16;
typedef MEASUREITEMSTRUCT16 UNALIGNED *PMEASUREITEMSTRUCT16;
typedef VPVOID VPMEASUREITEMSTRUCT16;

typedef struct _DELETEITEMSTRUCT16 {    /* des16 */
    WORD    CtlType;
    WORD    CtlID;
    WORD    itemID;
    HWND16  hwndItem;
    DWORD   itemData;
} DELETEITEMSTRUCT16;
typedef DELETEITEMSTRUCT16 UNALIGNED *PDELETEITEMSTRUCT16;
typedef VPVOID VPDELETEITEMSTRUCT16;

typedef struct _COMPAREITEMSTRUCT16 {   /* cis16 */
    WORD    CtlType;
    WORD    CtlID;
    HWND16  hwndItem;
    WORD    itemID1;
    DWORD   itemData1;
    WORD    itemID2;
    DWORD   itemData2;
} COMPAREITEMSTRUCT16;
typedef COMPAREITEMSTRUCT16 UNALIGNED *PCOMPAREITEMSTRUCT16;
typedef VPVOID VPCOMPAREITEMSTRUCT16;

typedef struct _MDICREATESTRUCT16 {     /* mcs16 */
    VPSZ    vpszClass;
    VPSZ    vpszTitle;
    HTASK16 hOwner;
    SHORT   x;
    SHORT   y;
    SHORT   cx;
    SHORT   cy;
    LONG    style;
    LONG    lParam;                     // app-defined stuff
} MDICREATESTRUCT16;
typedef MDICREATESTRUCT16 UNALIGNED *PMDICREATESTRUCT16;
typedef VPVOID VPMDICREATESTRUCT16;


typedef struct _WINDOWPOS16 {     /* wp16 */
    HAND16  hwnd;
    HAND16  hwndInsertAfter;
    SHORT   x;
    SHORT   y;
    SHORT   cx;
    SHORT   cy;
    WORD    flags;
} WINDOWPOS16;
typedef WINDOWPOS16 UNALIGNED *PWINDOWPOS16;
typedef VPVOID VPWINDOWPOS16;

typedef struct _NCCALCSIZE_PARAMS16 {    /* nccsz16 */
    RECT16        rgrc[3];
    WINDOWPOS16 UNALIGNED FAR *lppos;
} NCCALCSIZE_PARAMS16;
typedef NCCALCSIZE_PARAMS16 UNALIGNED *PNCCALCSIZE_PARAMS16;
typedef VPVOID VPNCCALCSIZE_PARAMS16;

/*
 * Used by Hook Procs.
 */

typedef struct _EVENTMSG16 {  /* evmsg16 */
    WORD    message;
    WORD    paramL;
    WORD    paramH;
    DWORD   time;
} EVENTMSG16;
typedef EVENTMSG16 UNALIGNED *PEVENTMSG16;
typedef VPVOID VPEVENTMSG16;

typedef struct _DEBUGHOOKINFO16 {   /*dbgi16 */
    HTASK16 hModuleHook;
    DWORD   reserved;
    DWORD   lParam;
    WORD    wParam;
    SHORT   code;
} DEBUGHOOKINFO16;
typedef DEBUGHOOKINFO16 UNALIGNED *PDEBUGHOOKINFO16;
typedef VPVOID VPDEBUGHOOKINFO16;

typedef struct _MOUSEHOOKSTRUCT16 { /* mhs16 */
    POINT16 pt;
    HWND16  hwnd;
    WORD    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT16;
typedef MOUSEHOOKSTRUCT16 UNALIGNED *PMOUSEHOOKSTRUCT16;
typedef VPVOID VPMOUSEHOOKSTRUCT16;

typedef struct _CWPSTRUCT16 {    /* cwps16 */
    LONG    lParam;     //
    WORD    wParam;     //
    WORD    message;    //
    WORD    hwnd;       //
} CWPSTRUCT16;
typedef CWPSTRUCT16 UNALIGNED *PCWPSTRUCT16;
typedef VPVOID VPCWPSTRUCT16;

typedef struct _CBT_CREATEWND16 {  /* cbtcw16 */
    VPCREATESTRUCT16 vpcs;
    HWND16           hwndInsertAfter;
} CBT_CREATEWND16;
typedef CBT_CREATEWND16 UNALIGNED *PCBT_CREATEWND16;
typedef VPVOID VPCBT_CREATEWND16;

typedef struct _CBTACTIVATESTRUCT16 { /* cbtas16 */
    BOOL16    fMouse;
    HWND16    hWndActive;
} CBTACTIVATESTRUCT16;
typedef CBTACTIVATESTRUCT16 UNALIGNED *PCBTACTIVATESTRUCT16;
typedef VPVOID VPCBTACTIVATESTRUCT16;


/* 16-bit resource structures, and their pointers
 *
 * Note that some are the same as the 32-bit definition (eg, menus)
 */

typedef MENUITEMTEMPLATEHEADER     MENUITEMTEMPLATEHEADER16;
typedef MENUITEMTEMPLATE       MENUITEMTEMPLATE16;
typedef MENUITEMTEMPLATEHEADER16 *PMENUITEMTEMPLATEHEADER16;
typedef MENUITEMTEMPLATE16   *PMENUITEMTEMPLATE16;

typedef struct _DLGTEMPLATE16 {     /* dt16 */
    DWORD   style;          //
    BYTE    cdit;           // this is a WORD in WIN32
    WORD    x;              //
    WORD    y;              //
    WORD    cx;             //
    WORD    cy;             //
 // CHAR    szMenuName[];       // potential pad byte in WIN32
 // CHAR    szClassName[];      // potential pad byte in WIN32
 // CHAR    szCaptionText[];        // potential pad byte in WIN32
} DLGTEMPLATE16;
typedef DLGTEMPLATE16 UNALIGNED *PDLGTEMPLATE16;
typedef VPVOID VPDLGTEMPLATE16;

typedef struct _FONTINFO16 {        /* fi16 */
    SHORT   cPoints;            // present if DS_SETFONT in dt16.style
 // CHAR    szTypeFace[];       // potential pad byte in WIN32
} FONTINFO16;
typedef FONTINFO16 UNALIGNED *PFONTINFO16;
typedef VPVOID VPFONTINFO16;

typedef struct _DLGITEMTEMPLATE16 { /* dit16 */
    WORD    x;              // structure dword-aligned in WIN32
    WORD    y;              //
    WORD    cx;             //
    WORD    cy;             //
    WORD    id;             //
    DWORD   style;          // this was moved to the top in WIN32
 // CHAR    szClass[];          // potential pad byte in WIN32
 // CHAR    szText[];           // potential pad byte in WIN32
 // BYTE    cbExtra;            //
 // BYTE    abExtra[];          //
} DLGITEMTEMPLATE16;
typedef DLGITEMTEMPLATE16 UNALIGNED *PDLGITEMTEMPLATE16;
typedef VPVOID VPDLGITEMTEMPLATE16;

typedef struct _RESDIRHEADER16 {    /* hdir16 */
    WORD    reserved;           //
    WORD    rt;             //
    WORD    cResources;         // pad word in WIN32 (for size == 8)
} RESDIRHEADER16;
typedef RESDIRHEADER16 UNALIGNED *PRESDIRHEADER16;
typedef VPVOID VPRESDIRHEADER16;

typedef struct _ICONDIR16 {     /* idir16 */
    BYTE    Width;          // 16, 32, 64
    BYTE    Height;         // 16, 32, 64
    BYTE    ColorCount;         // 2, 8, 16
    BYTE    reserved;           //
} ICONDIR16;
typedef ICONDIR16 UNALIGNED *PICONDIR16;
typedef VPVOID VPICONDIR16;

typedef struct _CURSORDIR16 {       /* cdir16 */
    WORD    Width;          //
    WORD    Height;         //
} CURSORDIR16;
typedef CURSORDIR16 UNALIGNED *PCURSORDIR16;
typedef VPVOID VPCURSORDIR16;

/* XLATOFF */
typedef struct _RESDIR16 {      /* rdir16 */
    union {             //
    ICONDIR16   Icon;       //
    CURSORDIR16 Cursor;     //
    } ResInfo;              //
    WORD    Planes;         //
    WORD    BitCount;           //
    DWORD   BytesInRes;         //
    WORD    idIcon;         // pad word in WIN32 (for size == 16)
} RESDIR16;
typedef RESDIR16 UNALIGNED *PRESDIR16;
typedef VPVOID VPRESDIR16;

typedef struct _COPYDATASTRUCT16 {
    DWORD dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT16;
typedef COPYDATASTRUCT16 UNALIGNED *PCOPYDATASTRUCT16;
typedef VPVOID VPCOPYDATASTRUCT16;

typedef struct _DROPSTRUCT16 {
    HWND16  hwndSource;
    HWND16  hwndSink;
    WORD    wFmt;
    DWORD   dwData;
    POINT16 ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT16;
typedef DROPSTRUCT16 UNALIGNED *PDROPSTRUCT16;
typedef VPVOID VPDROPSTRUCT16;

typedef struct _DROPFILESTRUCT16 {
    WORD pFiles;
    SHORT x;
    SHORT y;
    BOOL16 fNC;
} DROPFILESTRUCT16;
typedef DROPFILESTRUCT16 UNALIGNED *PDROPFILESTRUCT16;
typedef VPVOID VPDROPFILESTRUCT16;


typedef BITMAPINFOHEADER ICONRESOURCE;
typedef ICONRESOURCE *PICONRESOURCE;
typedef BITMAPINFOHEADER16 ICONRESOURCE16;
typedef ICONRESOURCE16 UNALIGNED *PICONRESOURCE16;
typedef VPVOID VPICONRESOURCE16;

typedef struct _CURSORRESOURCE {    /* cres */
    WORD xHotspot;
    WORD yHotspot;
    BITMAPINFOHEADER bmih;
} CURSORRESOURCE;
typedef CURSORRESOURCE UNALIGNED *PCURSORRESOURCE;

typedef CURSORRESOURCE CURSORRESOURCE16;
typedef CURSORRESOURCE16 UNALIGNED *PCURSORRESOURCE16;
typedef VPVOID VPCURSORRESOURCE16;

// This describes the header of the old 2.x cursor/icon resource format;
// the header should be followed by an AND mask and then an XOR mask, where:
//
//      Bit value   Bit value   Bit value   Bit value
//  AND Mask        0       0       1       1
//  XOR Mask        0       1       0       1
//  ---------------------------------------------------------
//  Result  Black       White   Transparent Inverted
//
// Note that we wouldn't have to worry about this old resource format if apps
// like WinWord (which apparently weren't fully converted to 3.x) didn't use it! -JTP

typedef struct _OLDCURSORICONRESOURCE16 { /* oci16 */
    BYTE    bFigure;            // 1: cursor, 2: bitmap, 3: icon
    BYTE    bIndependent;       // 0: device-dependent, 1: independent
    SHORT   xHotspot;           //
    SHORT   yHotspot;           //
    SHORT   cx;             // x-extent
    SHORT   cy;             // y-extent
    SHORT   cbWidth;            // bytes per row (rows are word-aligned)
    SHORT   clr;            // # color planes (should always be 0)
} OLDCURSORICONRESOURCE16;
typedef OLDCURSORICONRESOURCE16 UNALIGNED *POLDCURSORICONRESOURCE16;
typedef VPVOID VPOLDCURSORICONRESOURCE16;
/* XLATON */

/* XLATOFF */
#pragma pack()
/* XLATON */


/* Undocumented(?) window messages
 */
#define WM_SETVISIBLE       0x0009
#define WM_ALTTABACTIVE     0x0029
#define WM_ISACTIVEICON     0x0035
#define WM_QUERYPARKICON    0x0036
#define WM_SYNCPAINT        0x0088
#define WM_SYSTIMER     0x0118
#define WM_LBTRACKPOINT     0x0131
#define WM_ENTERMENULOOP    0x0211
#define WM_EXITMENULOOP     0x0212
#define WM_NEXTMENU     0x0213
#define WM_DROPOBJECT       0x022A
#define WM_QUERYDROPOBJECT  0x022B
#define WM_BEGINDRAG        0x022C
#define WM_DRAGLOOP     0x022D
#define WM_DRAGSELECT       0x022E
#define WM_DRAGMOVE     0x022F
#define WM_ENTERSIZEMOVE    0x0231
#define WM_EXITSIZEMOVE     0x0232


/* Old window messages (changed from Win 3.x)
 */
#ifndef WM_USER
#define WM_USER 0x0400
#endif

#define OLDEM_GETSEL            (WM_USER+0)
#define OLDEM_SETSEL            (WM_USER+1)
#define OLDEM_GETRECT           (WM_USER+2)
#define OLDEM_SETRECT           (WM_USER+3)
#define OLDEM_SETRECTNP         (WM_USER+4)
#define OLDEM_SCROLL            (WM_USER+5)
#define OLDEM_LINESCROLL        (WM_USER+6)
#define OLDEM_GETMODIFY         (WM_USER+8)
#define OLDEM_SETMODIFY         (WM_USER+9)
#define OLDEM_GETLINECOUNT      (WM_USER+10)
#define OLDEM_LINEINDEX         (WM_USER+11)
#define OLDEM_SETHANDLE         (WM_USER+12)
#define OLDEM_GETHANDLE         (WM_USER+13)
#define OLDEM_GETTHUMB          (WM_USER+14)
#define OLDEM_LINELENGTH        (WM_USER+17)
#define OLDEM_REPLACESEL        (WM_USER+18)
#define OLDEM_SETFONT           (WM_USER+19)
#define OLDEM_GETLINE           (WM_USER+20)
#define OLDEM_LIMITTEXT         (WM_USER+21)
#define OLDEM_CANUNDO           (WM_USER+22)
#define OLDEM_UNDO          (WM_USER+23)
#define OLDEM_FMTLINES          (WM_USER+24)
#define OLDEM_LINEFROMCHAR      (WM_USER+25)
#define OLDEM_SETWORDBREAK      (WM_USER+26)
#define OLDEM_SETTABSTOPS       (WM_USER+27)
#define OLDEM_SETPASSWORDCHAR       (WM_USER+28)
#define OLDEM_EMPTYUNDOBUFFER       (WM_USER+29)
#ifndef WIN31
#define OLDEM_MSGMAX            (WM_USER+30)
#else
#define OLDEM_GETFIRSTVISIBLELINE (WM_USER+30)
#define OLDEM_SETREADONLY       (WM_USER+31)
#define OLDEM_SETWORDBREAKPROC  (WM_USER+32)
#define OLDEM_GETWORDBREAKPROC  (WM_USER+33)
#define OLDEM_GETPASSWORDCHAR   (WM_USER+34)
#define OLDEM_MSGMAX            (WM_USER+35)
#endif

#define OLDBM_GETCHECK          (WM_USER+0)
#define OLDBM_SETCHECK          (WM_USER+1)
#define OLDBM_GETSTATE          (WM_USER+2)
#define OLDBM_SETSTATE          (WM_USER+3)
#define OLDBM_SETSTYLE          (WM_USER+4)

#define OLDCB_GETEDITSEL        (WM_USER+0)
#define OLDCB_LIMITTEXT         (WM_USER+1)
#define OLDCB_SETEDITSEL        (WM_USER+2)
#define OLDCB_ADDSTRING         (WM_USER+3)
#define OLDCB_DELETESTRING      (WM_USER+4)
#define OLDCB_DIR           (WM_USER+5)
#define OLDCB_GETCOUNT          (WM_USER+6)
#define OLDCB_GETCURSEL         (WM_USER+7)
#define OLDCB_GETLBTEXT         (WM_USER+8)
#define OLDCB_GETLBTEXTLEN      (WM_USER+9)
#define OLDCB_INSERTSTRING      (WM_USER+10)
#define OLDCB_RESETCONTENT      (WM_USER+11)
#define OLDCB_FINDSTRING        (WM_USER+12)
#define OLDCB_SELECTSTRING      (WM_USER+13)
#define OLDCB_SETCURSEL         (WM_USER+14)
#define OLDCB_SHOWDROPDOWN      (WM_USER+15)
#define OLDCB_GETITEMDATA       (WM_USER+16)
#define OLDCB_SETITEMDATA       (WM_USER+17)
#define OLDCB_GETDROPPEDCONTROLRECT (WM_USER+18)
#ifndef WIN31
#define OLDCB_MSGMAX            (WM_USER+19)
#else
#define OLDCB_SETITEMHEIGHT     (WM_USER+19)
#define OLDCB_GETITEMHEIGHT     (WM_USER+20)
#define OLDCB_SETEXTENDEDUI     (WM_USER+21)
#define OLDCB_GETEXTENDEDUI     (WM_USER+22)
#define OLDCB_GETDROPPEDSTATE   (WM_USER+23)
#define OLDCB_FINDSTRINGEXACT   (WM_USER+24)
#define OLDCB_MSGMAX            (WM_USER+25)    /* ;Internal */
#define OLDCBEC_SETCOMBOFOCUS   (WM_USER+26)    /* ;Internal */
#define OLDCBEC_KILLCOMBOFOCUS  (WM_USER+27)    /* ;Internal */
#endif

#define OLDLB_ADDSTRING         (WM_USER+1)
#define OLDLB_INSERTSTRING      (WM_USER+2)
#define OLDLB_DELETESTRING      (WM_USER+3)
#define OLDLB_RESETCONTENT      (WM_USER+5)
#define OLDLB_SETSEL            (WM_USER+6)
#define OLDLB_SETCURSEL         (WM_USER+7)
#define OLDLB_GETSEL            (WM_USER+8)
#define OLDLB_GETCURSEL         (WM_USER+9)
#define OLDLB_GETTEXT           (WM_USER+10)
#define OLDLB_GETTEXTLEN        (WM_USER+11)
#define OLDLB_GETCOUNT          (WM_USER+12)
#define OLDLB_SELECTSTRING      (WM_USER+13)
#define OLDLB_DIR           (WM_USER+14)
#define OLDLB_GETTOPINDEX       (WM_USER+15)
#define OLDLB_FINDSTRING        (WM_USER+16)
#define OLDLB_GETSELCOUNT       (WM_USER+17)
#define OLDLB_GETSELITEMS       (WM_USER+18)
#define OLDLB_SETTABSTOPS       (WM_USER+19)
#define OLDLB_GETHORIZONTALEXTENT   (WM_USER+20)
#define OLDLB_SETHORIZONTALEXTENT   (WM_USER+21)
#define OLDLB_SETCOLUMNWIDTH        (WM_USER+22)
#define OLDLB_ADDFILE           (WM_USER+23)    /* ;Internal */
#define OLDLB_SETTOPINDEX       (WM_USER+24)
#define OLDLB_GETITEMRECT       (WM_USER+25)
#define OLDLB_GETITEMDATA       (WM_USER+26)
#define OLDLB_SETITEMDATA       (WM_USER+27)
#define OLDLB_SELITEMRANGE      (WM_USER+28)
#define OLDLB_SETANCHORINDEX        (WM_USER+29)    /* ;Internal */
#define OLDLB_GETANCHORINDEX        (WM_USER+30)    /* ;Internal */
#ifndef WIN31
#define OLDLB_MSGMAX            (WM_USER+33)
#else
#define OLDLB_SETCARETINDEX     (WM_USER+31)
#define OLDLB_GETCARETINDEX     (WM_USER+32)
#define OLDLB_SETITEMHEIGHT     (WM_USER+33)
#define OLDLB_GETITEMHEIGHT     (WM_USER+34)
#define OLDLB_FINDSTRINGEXACT   (WM_USER+35)
#define OLDLBCB_CARETON         (WM_USER+36)     /* ;Internal */
#define OLDLBCB_CARETOFF        (WM_USER+37)     /* ;Internal */
#define OLDLB_MSGMAX            (WM_USER+38)     /* ;Internal */
#endif

#define OLDSBM_SETPOS           (WM_USER+0)
#define OLDSBM_GETPOS           (WM_USER+1)
#define OLDSBM_SETRANGE         (WM_USER+2)
#define OLDSBM_GETRANGE         (WM_USER+3)
#define OLDSBM_ENABLEARROWS     (WM_USER+4)

/* WOW Return IDs - Ordering must match wow16cal.asm table
 */
#define RET_RETURN       0  // return to app

#define RET_DEBUGRETURN      1  // return to app after breakpoint

#define RET_DEBUG        2  // execute breakpoint, return to WOW

#define RET_WNDPROC      3  // IN:all
                // OUT:DX:AX=wndproc return code

#define RET_ENUMFONTPROC     4  // IN:all
                // OUT:DX:AX=wndproc return code

#define RET_ENUMWINDOWPROC   5  // IN:all
                // OUT:DX:AX=wndproc return code

#define RET_LOCALALLOC       6  // IN:wParam=wFlags, lParam=wBytes
                // OUT:AX=hMem (zero if error)

#define RET_LOCALREALLOC     7  // IN:wMsg=hMem, wParam=wFlags, lParam=wBytes
                // OUT:AX=hMem (zero if error)

#define RET_LOCALLOCK        8  // IN:wParam=hMem
                // OUT:DX:AX=address (zero if error), CX=size

#define RET_LOCALUNLOCK      9  // IN:wParam=hMem
                // OUT:AX=TRUE (FALSE if error)

#define RET_LOCALSIZE        10 // IN:wParam=hMem
                // OUT:AX=size (zero if error)

#define RET_LOCALFREE        11 // IN:wParam=hMem
                // OUT:AX=TRUE (FALSE if error)

#define RET_GLOBALALLOCLOCK  12 // IN:wParam=wFlags, lParam=dwBytes
                // OUT:DX:AX=address (zero if error), BX=hMem

#define RET_GLOBALLOCK       13 // IN:wParam=hMem
                // OUT:DX:AX=address (zero if error), CX=size

#define RET_GLOBALUNLOCK     14 // IN:wParam=hMem
                // OUT:AX=TRUE (FALSE if error)

#define RET_GLOBALUNLOCKFREE 15 // IN:lParam=address
                // OUT:AX=TRUE (FALSE if error)

#define RET_FINDRESOURCE     16 // IN:wParam=hTask, lParam=vpName, hwnd/wMsg=vpType
                // OUT:AX=hResInfo (zero if not found)

#define RET_LOADRESOURCE     17 // IN:wParam=hTask, lParam=hResInfo
                // OUT:AX=hResData

#define RET_FREERESOURCE     18 // IN:wParam=hResData
                // OUT:AX=TRUE (zero if failed)

#define RET_LOCKRESOURCE     19 // IN:wParam=hResData
                // OUT:DX:AX=address (zero if error), CX=size

#define RET_UNLOCKRESOURCE   20 // IN:wParam=hResData
                // OUT:AX=TRUE (zero if resource still locked)

#define RET_SIZEOFRESOURCE   21 // IN:wParam=hTask, lParam=hResInfo
                // OUT:DX:AX=size (zero if error)

#define RET_LOCKSEGMENT      22 // IN:wParam=wSeg
                // OUT:AX=TRUE (FALSE if error)

#define RET_UNLOCKSEGMENT    23 // IN:wParam=wSeg
                // OUT:AX=TRUE (zero if segment still locked)

#define RET_ENUMMETAFILEPROC 24 // IN:all
                                // OUT:DX:AX=wndproc return cod

#define RET_TASKSTARTED      25 // None

#define RET_HOOKPROC         26 // IN:all
                                // OUT:DX:AX=hookproc return code

#define RET_SUBCLASSPROC     27 // IN:None
                // OUT: DX:AX=thunkproc return code
#define RET_LINEDDAPROC      28

#define RET_GRAYSTRINGPROC   29

#define RET_FORCETASKEXIT    30 // IN:None
            // OUT: Does not return

#define RET_SETCURDIR        31 // IN:Current Dir
            // OUT: ax
#define RET_ENUMOBJPROC     32  // IN:all
        // OUT:DX:AX=wndproc return code

#define RET_SETCURSORICONFLAG        33 // IN: none

#define RET_SETABORTPROC    34

#define RET_ENUMPROPSPROC   35

#define RET_FORCESEGMENTFAULT 36 //  Make a segment present

#define RET_LSTRCMP          37 // for user32 listbox code

                                //  38 FREE
                                //  39 FREE
                                //  40 FREE
                                //  41 FREE

#define RET_GETEXEPTR        42 // Call KRNL286:GetExePtr

                                //  43 FREE

#define RET_FORCETASKFAULT   44 // Force a Fault
#define RET_GETEXPWINVER     45 // Call KRNL286:GetExpWinVer
#define RET_GETCURDIR        46 //

#define RET_GETDOSPDB        47 // IN:  nothing
                                // OUT: DX:AX = DOS Win_PDB
#define RET_GETDOSSFT        48 // IN:  nothing
                                // OUT: DX:AX = DOS SFT (pFileTable)
#define RET_FOREGROUNDIDLE   49 // IN:  nothing
                                // OUT: NOTHING
#define RET_WINSOCKBLOCKHOOK 50 // IN:  nothing
                                // OUT: DX:AX = BOOL ret value
#define RET_WOWDDEFREEHANDLE 51

#define RET_CHANGESELECTOR   52 // IN: wParam = Segment

#define RET_GETMODULEFILENAME 53 // IN: wParam = hInst, lParam = 16:16 Buffer
                                 //     wMsg = cbBuffer
                                 // OUT: AX = length of returned modulename

#define RET_SETWORDBREAKPROC 54 //

#define RET_WINEXEC          55

#define RET_WOWCALLBACK16    56 // Used by public WOWCallback16 routine

#define RET_GETDIBSIZE       57

#define RET_GETDIBFLAGS      58

#define RET_SETDIBSEL        59

#define RET_FREEDIBSEL       60

#ifdef FE_SB
#define RET_SETFNOTEPAD      61 // sync GetModuleUsage16 API for Lotus FLW
#define RET_MAX              61
#else // !FE_SB
#define RET_MAX              60
#endif // !FE_SB




/* Module IDs
 *
 * Module IDs are OR'ed with API IDs to produce Call IDs
 */
#define MOD_MASK        0xF000
#define FUN_MASK        0x0FFF

#define MOD_KERNEL   0x0000
#define MOD_DKERNEL  0X0000   // for parameter validation layer
#define MOD_USER     0x1000   //
#define MOD_DUSER    0x1000   // for parameter validation layer
#define MOD_GDI      0x2000   //
#define MOD_DGDI     0x2000   // for parameter validation layer
#define MOD_KEYBOARD 0x3000
#define MOD_SOUND    0x4000
#define MOD_SHELL    0x5000   // SHELL APIs
#define MOD_WINSOCK  0x6000
#define MOD_TOOLHELP 0x7000
#define MOD_MMEDIA   0x8000
#define MOD_COMMDLG  0x9000
#ifdef FE_SB
#define MOD_WINNLS   0xA000
#define MOD_WIFEMAN  0xB000
#define MOD_LAST     0xC000   // Add New Module ID before this one
#else // !FE_SB
#define MOD_LAST     0xA000   // Add New Module ID before this one
#endif // !FE_SB


/* Special Function IDs
 *
 * This is used by WIN16 whenever we are returning from a window proc;
 * see the various include files (wowkrn.h, wowgdi.h, etc) for all the other
 * function IDs.
 */
#define FUN_RETURN      0

/*
 * hiword of wcallID in VDMFRAME -
 */

#define HI_WCALLID     0x0000

/* Macros for WOW16 DLLs
 *
 * Note for GDIThunk args is the metafile function number
 * and val denotes if function has a DC
 *
 */

/* ASM
Thunk       macro   mod,func,callfirst,args,val,emptybuf
    ifidni  <args>,<abs>
    public func
    ifb    <val>
        func = 0
    else
        func = val
    endif
    else
    externA  __MOD_KERNEL
    externA  __MOD_DKERNEL
    externA  __MOD_USER
    externA  __MOD_DUSER
    externA  __MOD_GDI
    externA  __MOD_DGDI
    externA  __MOD_KEYBOARD
    externA  __MOD_SOUND
    externA  __MOD_SHELL
    externA  __MOD_WINSOCK
    externA  __MOD_TOOLHELP
    externA  __MOD_MMEDIA
    externA  __MOD_COMMDLG
ifdef FE_SB
    externA  __MOD_WINNLS
    externA  __MOD_WIFEMAN
endif ; FE_SB



    ifidni <mod>,<USER>
        cProc I&func,<PUBLIC,FAR,PASCAL,NODATA,WIN>

        cBegin <nogen>
    else
        ifidni <mod>,<GDI>
        cProc I&func,<PUBLIC,FAR,PASCAL,NODATA,WIN>

        cBegin <nogen>
        else
        ifidni <mod>,<KERNEL>
            cProc I&func,<PUBLIC,FAR,PASCAL,NODATA,WIN>

            cBegin <nogen>
        else
            cProc func,<PUBLIC,FAR,PASCAL,NODATA,WIN>

            cBegin <nogen>
        endif
        endif
    endif

    ; Make the passed in buffer into an empty string by writing null
    ; to the first position. Win 3.1 IGetWindowText does this, and
    ; WinFax Pro depends on this behaviour.
    ifnb   <emptybuf>
        push    bp
        mov     bp, sp
        mov     bx, [bp+8]
        mov     es, [bp+0Ah]
        mov     byte ptr es:[bx], 0
        pop     bp
    endif

    ifdifi <callfirst>,<0>
    call    callfirst
    endif

    ifnb   <args>
        push    args
    else
        ifdef func&16
        push    size func&16
        else
        if1
            %out     Warning: assuming null arg frame for &mod:&func
        endif
        push  0
        endif
    endif
        t_&func:


            push    word ptr HI_WCALLID
            push    __MOD_&mod + FUN_&func
            call   WOW16Call

        ; assert that this is constant size code. 5bytes for 'call wow16call'
        ; and 3bytes each for the 'push ...'. We use this info in wow32
        ; to patchcodewithlpfnw32.

        .erre (($ - t_&func) EQ (05h + 03h + 03h))

    cEnd <nogen>
    endif
endm

KernelThunk macro func,args,val
    Thunk   KERNEL,func,0,args,val
endm

DKernelThunk macro func,args,val
    Thunk   DKERNEL,func,0,args,val
endm

PKernelThunk macro func,callfirst,args,val
    Thunk   KERNEL,func,callfirst,args,val
endm

UserThunk   macro func,args,val
    Thunk   USER,func,0,args,val
endm

DUserThunk  macro func,args,val
    Thunk   DUSER,func,0,args,val
endm

PUserThunk  macro func,callfirst,args,val
    Thunk   USER,func,callfirst,args,val
endm

PDUserThunk  macro func,callfirst,args,val
    Thunk   DUSER,func,callfirst,args,val
endm

EUserThunk  macro func,args,val
    Thunk   USER,func,0,args,val,0
endm

GDIThunk    macro func,args,val
    Thunk   GDI,func,0,args,val
endm

DGDIThunk   macro func,args,val
    Thunk   DGDI,func,0,args,val
endm

PGDIThunk   macro func,callfirst,args,val
    Thunk   GDI,func,callfirst,args,val
endm

KbdThunk    macro func,args,val
    Thunk   KEYBOARD,func,0,args,val
endm

SoundThunk  macro func,args,val
    Thunk   SOUND,func,0,args,val
endm

SHELLThunk  macro func,args,val
    Thunk   SHELL,func,0,args,val
endm

MMediaThunk macro func,args,val
    Thunk   MMEDIA,func,0,args,val
endm

WinsockThunk macro func,args,val
    Thunk   WINSOCK,func,0,args,val
endm

ToolHelpThunk macro func,args,val
    Thunk   TOOLHELP,func,0,args,val
endm

CommdlgThunk macro func,args,val
    Thunk   COMMDLG,func,SetWowCommDlg,args,val
endm

ifdef FE_SB
WINNLSThunk macro func,args,val
    Thunk   WINNLS,func,0,args,val
endm

WifeManThunk macro func,args,val
    Thunk   WIFEMAN,func,0,args,val
endm
endif ; FE_SB

 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\vrremote.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrremote.h

Abstract:

    Prototypes for vrremote module

Author:

    Richard L Firth (rfirth) 28-Oct-1991

Revision History:

    29-Oct-1991 rfirth
        Created

--*/

NET_API_STATUS
VrTransaction(
    IN      LPSTR   ServerName,
    IN      LPBYTE  SendParmBuffer,
    IN      DWORD   SendParmBufLen,
    IN      LPBYTE  SendDataBuffer,
    IN      DWORD   SendDataBufLen,
    OUT     LPBYTE  ReceiveParmBuffer,
    IN      DWORD   ReceiveParmBufLen,
    IN      LPBYTE  ReceiveDataBuffer,
    IN OUT  LPDWORD ReceiveDataBufLen,
    IN      BOOL    NullSessionFlag
    );

NET_API_STATUS
VrRemoteApi(
    IN  DWORD   ApiNumber,
    IN  LPBYTE  ServerNamePointer,
    IN  LPSTR   ParameterDescriptor,
    IN  LPSTR   DataDescriptor,
    IN  LPSTR   AuxDescriptor OPTIONAL,
    IN  BOOL    NullSessionFlag
    );

//
// private routine prototypes
//

DWORD
VrpGetStructureSize(
    IN  LPSTR   Descriptor,
    IN  LPDWORD AuxOffset
    );

DWORD
VrpGetArrayLength(
    IN  LPSTR   type_ptr,
    IN  LPSTR*  type_ptr_addr
    );

DWORD
VrpGetFieldSize(
    IN  LPSTR   Descriptor,
    IN  LPSTR*  pDescriptor
    );

VOID
VrpConvertReceiveBuffer(
    IN  LPBYTE  ReceiveBuffer,
    IN  WORD    BufferSelector,
    IN  WORD    BufferOffset,
    IN  WORD    ConverterWord,
    IN  DWORD   NumberStructs,
    IN  LPSTR   DataDescriptor,
    IN  LPSTR   AuxDescriptor
    );

VOID
VrpConvertVdmPointer(
    IN  ULPWORD TargetPointer,
    IN  WORD    BufferSegment,
    IN  WORD    BufferOffset,
    IN  WORD    ConverterWord
    );

NET_API_STATUS
VrpPackSendBuffer(
    IN OUT  LPBYTE* SendBufferPtr,
    IN OUT  LPDWORD SendBufLenPtr,
    OUT     LPBOOL  BufferAllocFlagPtr,
    IN OUT  LPSTR   DataDescriptor,
    IN      LPSTR   AuxDescriptor,
    IN      DWORD   StructureSize,
    IN      DWORD   AuxOffset,
    IN      DWORD   AuxSize,
    IN      BOOL    SetInfoFlag,
    IN      BOOL    OkToModifyDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowcmdlg.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1993, Microsoft Corporation
 *
 *  WOWCMDLG.H
 *  16-bit Commdlg API argument structures
 *
 *  History:
 *      John Vert (jvert) 30-Dec-1992
 *          Created
--*/

//#include <windows.h>
//#include <winsock.h>

/* XLATOFF */
#pragma pack(2)
/* XLATON */

/*++
 *
 * Commdlg data structures
 *
--*/

typedef struct _FINDREPLACE16 {                         /* fr16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HAND16  hInstance;
    DWORD   Flags;
    VPSZ    lpstrFindWhat;
    VPSZ    lpstrReplaceWith;
    WORD    wFindWhatLen;
    WORD    wReplaceWithLen;
    LONG    lCustData;
    VPPROC  lpfnHook;
    VPCSTR  lpTemplateName;
} FINDREPLACE16;
typedef FINDREPLACE16 UNALIGNED *PFINDREPLACE16;
typedef VPVOID VPFINDREPLACE;

typedef struct _OPENFILENAME16 {                        /* of16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HAND16  hInstance;
    VPCSTR  lpstrFilter;
    VPSZ    lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    VPSZ    lpstrFile;
    DWORD   nMaxFile;
    VPSZ    lpstrFileTitle;
    DWORD   nMaxFileTitle;
    VPCSTR  lpstrInitialDir;
    VPCSTR  lpstrTitle;
    DWORD   Flags;
    USHORT  nFileOffset;
    USHORT  nFileExtension;
    VPCSTR  lpstrDefExt;
    LONG    lCustData;
    VPPROC  lpfnHook;
    VPCSTR  lpTemplateName;
} OPENFILENAME16;
typedef OPENFILENAME16 UNALIGNED *POPENFILENAME16;
typedef VPVOID VPOPENFILENAME;

typedef struct _CHOOSECOLORDATA16 {                     /* cc16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HAND16  hInstance;
    DWORD   rgbResult;
    VPDWORD lpCustColors;
    DWORD   Flags;
    LONG    lCustData;
    VPPROC  lpfnHook;
    VPCSTR  lpTemplateName;
} CHOOSECOLORDATA16;
typedef CHOOSECOLORDATA16 UNALIGNED *PCHOOSECOLORDATA16;
typedef VPVOID VPCHOOSECOLORDATA;

typedef struct _CHOOSEFONTDATA16 {                      /* cf16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HDC16   hDC;
    VPLOGFONT16 lpLogFont;
    SHORT   iPointSize;
    DWORD   Flags;
    DWORD   rgbColors;
    LONG    lCustData;
    VPPROC  lpfnHook;
    VPCSTR  lpTemplateName;
    HAND16  hInstance;
    VPSZ    lpszStyle;
    WORD    nFontType;
    SHORT   nSizeMin;
    SHORT   nSizeMax;
} CHOOSEFONTDATA16;
typedef CHOOSEFONTDATA16 UNALIGNED *PCHOOSEFONTDATA16;
typedef VPVOID VPCHOOSEFONTDATA;

typedef struct _PRINTDLGDATA16 {                        /* pd16 */
    DWORD   lStructSize;
    HWND16  hwndOwner;
    HAND16  hDevMode;
    HAND16  hDevNames;
    HDC16   hDC;
    DWORD   Flags;
    WORD    nFromPage;
    WORD    nToPage;
    WORD    nMinPage;
    WORD    nMaxPage;
    WORD    nCopies;
    HAND16  hInstance;
    LONG    lCustData;
    VPPROC  lpfnPrintHook;
    VPPROC  lpfnSetupHook;
    VPCSTR  lpPrintTemplateName;
    VPCSTR  lpSetupTemplateName;
    HAND16  hPrintTemplate;
    HAND16  hSetupTemplate;
} PRINTDLGDATA16;
typedef PRINTDLGDATA16 UNALIGNED *PPRINTDLGDATA16;
typedef VPVOID VPPRINTDLGDATA;

typedef struct _DEVNAMES16 {                            /* dn16 */
    WORD    wDriverOffset;
    WORD    wDeviceOffset;
    WORD    wOutputOffset;
    WORD    wDefault;
} DEVNAMES16;
typedef DEVNAMES16 UNALIGNED *PDEVNAMES16;
typedef VPVOID VPDEVNAMES;

/*++
 *
 * Commdlg API IDs (equal to ordinal numbers)
 *
--*/
#define FUN_GETOPENFILENAME         1
#define FUN_GETSAVEFILENAME         2
#define FUN_CHOOSECOLOR             5
#define FUN_FINDTEXT                11
#define FUN_REPLACETEXT             12
#define FUN_CHOOSEFONT              15
#define FUN_PRINTDLG                20
#define FUN_WOWCOMMDLGEXTENDEDERROR 26
#define FUN_GETFILETITLE            27


/*++

  Commdlg function prototypes - the seemingly unimportant number in the
  comment on each function MUST match the ones in the list above!!!

  !! BE WARNED !!

--*/

typedef struct _GETOPENFILENAME16 {                 /* cd1  */
    VPOPENFILENAME lpof;
} GETOPENFILENAME16;
typedef GETOPENFILENAME16 UNALIGNED *PGETOPENFILENAME16;

typedef struct _GETSAVEFILENAME16 {                 /* cd2  */
    VPOPENFILENAME lpcf;
} GETSAVEFILENAME16;
typedef GETSAVEFILENAME16 UNALIGNED *PGETSAVEFILENAME16;

typedef struct _CHOOSECOLOR16 {                     /* cd5  */
    VPCHOOSECOLORDATA lpcc;
} CHOOSECOLOR16;
typedef CHOOSECOLOR16 UNALIGNED *PCHOOSECOLOR16;

typedef struct _FINDTEXT16 {                        /* cd11 */
    VPFINDREPLACE lpfr;
} FINDTEXT16;
typedef FINDTEXT16 UNALIGNED *PFINDTEXT16;

typedef struct _REPLACETEXT16 {                       /* cd12 */
    VPFINDREPLACE lpfr;
} REPLACETEXT16;
typedef REPLACETEXT16 UNALIGNED *PREPLACETEXT16;

typedef struct _CHOOSEFONT16 {                      /* cd15 */
    VPCHOOSEFONTDATA lpcf;
} CHOOSEFONT16;
typedef CHOOSEFONT16 UNALIGNED *PCHOOSEFONT16;

typedef struct _PRINTDLG16 {                          /* cd20 */
    VPPRINTDLGDATA lppd;
} PRINTDLG16;
typedef PRINTDLG16 UNALIGNED *PPRINTDLG16;

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowexp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWEXP.H
 *  WOW32 exports
 *
 *  History:
 *  10-May-1991 Jeff Parsons (jeffpar)
 *  Created.
--*/

extern VOID FAR PASCAL W32Dispatch(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowddeml.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWDDEML.H
 *  16-bit DDEML API argument structures
 *
 *  History:
 *  Created 28-Dec-1992 by Chandan S. Chauhan (ChandanC)
 *
--*/

/* DDEML API IDs
 */
#define FUN_DDEINITIALIZE                   2
#define FUN_DDEUNINITIALIZE                 3
#define FUN_DDECONNECTLIST                  4
#define FUN_DDEQUERYNEXTSERVER              5
#define FUN_DDEDISCONNECTLIST               6
#define FUN_DDECONNECT                      7
#define FUN_DDEDISCONNECT                   8
#define FUN_DDEQUERYCONVINFO                9
#define FUN_DDESETUSERHANDLE                10
#define FUN_DDECLIENTTRANSACTION            11
#define FUN_DDEABANDONTRANSACTION           12
#define FUN_DDEPOSTADVISE                   13
#define FUN_DDECREATEDATAHANDLE             14
#define FUN_DDEADDDATA                      15
#define FUN_DDEGETDATA                      16
#define FUN_DDEACCESSDATA                   17
#define FUN_DDEUNACCESSDATA                 18
#define FUN_DDEFREEDATAHANDLE               19
#define FUN_DDEGETLASTERROR                 20
#define FUN_DDECREATESTRINGHANDLE           21
#define FUN_DDEFREESTRINGHANDLE             22
#define FUN_DDEQUERYSTRING                  23
#define FUN_DDEKEEPSTRINGHANDLE             24

#define FUN_DDEENABLECALLBACK               26
#define FUN_DDENAMESERVICE                  27

#define FUN_CLIENTWNDPROC                   28   ;Internal
#define FUN_SERVERWNDPROC                   29   ;Internal
#define FUN_SUBFRAMEWNDPROC                 30   ;Internal
#define FUN_DMGWNDPROC                      31   ;Internal
#define FUN_CONVLISTWNDPROC                 32   ;Internal
#define FUN_MONITORWNDPROC                  33   ;Internal
#define FUN_DDESENDHOOKPROC                 34   ;Internal
#define FUN_DDEPOSTHOOKPROC                 35   ;Internal

#define FUN_DDECMPSTRINGHANDLES             36
#define FUN_DDERECONNECT                    37

#define FUN_INITENUM                        38   ;Internal
#define FUN_TERMDLGPROC                     39   ;Internal
#define FUN_EmptyQTimerProc                 40   ;Internal


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _CONVCONTEXT16 {        /* di2 */
    WORD   cb;
    WORD   wFlags;
    WORD   wCountryID;
    INT16  iCodePage;
    DWORD  dwLangID;
    DWORD  dwSecurity;
} CONVCONTEXT16;
typedef CONVCONTEXT16 UNALIGNED *PCONVCONTEXT16;
typedef VPVOID VPCONVCONTEXT16;

typedef struct _DDEINITIALIZE16 {         /* d2 */
    DWORD   f4;
    DWORD   f3;
    VPVOID  f2;
    VPVOID  f1;
} DDEINITIALIZE16;
typedef DDEINITIALIZE16 UNALIGNED *PDDEINITIALIZE16;

typedef struct _DDEUNINITIALIZE16 {       /* d3 */
    DWORD   f1;
} DDEUNINITIALIZE16;
typedef DDEUNINITIALIZE16 UNALIGNED *PDDEUNINITIALIZE16;

typedef struct _DDECONNECTLIST16 {        /* d4 */
    VPVOID  f5;
    DWORD   f4;
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDECONNECTLIST16;
typedef DDECONNECTLIST16 UNALIGNED *PDDECONNECTLIST16;

typedef struct _DDEQUERYNEXTSERVER16 {    /* d5 */
    DWORD   f2;
    DWORD   f1;
} DDEQUERYNEXTSERVER16;
typedef DDEQUERYNEXTSERVER16 UNALIGNED *PDDEQUERYNEXTSERVER16;

typedef struct _DDEDISCONNECTLIST16 {    /* d6 */
    DWORD   f1;
} DDEDISCONNECTLIST16;
typedef DDEDISCONNECTLIST16 UNALIGNED *PDDEDISCONNECTLIST16;

typedef struct _DDECONNECT16 {           /* d7 */
    VPVOID  f4;
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDECONNECT16;
typedef DDECONNECT16 UNALIGNED *PDDECONNECT16;

typedef struct _DDEDISCONNECT16 {        /* d8 */
    DWORD   f1;
} DDEDISCONNECT16;
typedef DDEDISCONNECT16 UNALIGNED *PDDEDISCONNECT16;

typedef struct _DDEQUERYCONVINFO16 {     /* d9 */
    VPVOID  f3;
    DWORD   f2;
    DWORD   f1;
} DDEQUERYCONVINFO16;
typedef DDEQUERYCONVINFO16 UNALIGNED *PDDEQUERYCONVINFO16;

typedef struct _DDESETUSERHANDLE16 {     /* d10 */
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDESETUSERHANDLE16;
typedef DDESETUSERHANDLE16 UNALIGNED *PDDESETUSERHANDLE16;

typedef struct _DDECLIENTTRANSACTION16 {     /* d11 */
    VPVOID  f8;
    DWORD   f7;
    WORD    f6;
    WORD    f5;
    DWORD   f4;
    DWORD   f3;
    DWORD   f2;
    VPVOID  f1;
} DDECLIENTTRANSACTION16;
typedef DDECLIENTTRANSACTION16 UNALIGNED *PDDECLIENTTRANSACTION16;

typedef struct _DDEABANDONTRANSACTION16 {     /* d12 */
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDEABANDONTRANSACTION16;
typedef DDEABANDONTRANSACTION16 UNALIGNED *PDDEABANDONTRANSACTION16;

typedef struct _DDEPOSTADVISE16 {             /* d13 */
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDEPOSTADVISE16;
typedef DDEPOSTADVISE16 UNALIGNED *PDDEPOSTADVISE16;

typedef struct _DDECREATEDATAHANDLE16 {       /* d14 */
    WORD    f7;
    WORD    f6;
    DWORD   f5;
    DWORD   f4;
    DWORD   f3;
    VPVOID  f2;
    DWORD   f1;
} DDECREATEDATAHANDLE16;
typedef DDECREATEDATAHANDLE16 UNALIGNED *PDDECREATEDATAHANDLE16;

typedef struct _DDEADDDATA16 {                /* d15 */
    DWORD   f4;
    DWORD   f3;
    VPVOID  f2;
    DWORD  f1;
} DDEADDDATA16;
typedef DDEADDDATA16 UNALIGNED *PDDEADDDATA16;

typedef struct _DDEGETDATA16 {                /* d16 */
    DWORD   f4;
    DWORD   f3;
    VPVOID  f2;
    DWORD   f1;
} DDEGETDATA16;
typedef DDEGETDATA16 UNALIGNED *PDDEGETDATA16;

typedef struct _DDEACCESSDATA16 {             /* d17 */
    VPVOID  f2;
    DWORD   f1;
} DDEACCESSDATA16;
typedef DDEACCESSDATA16 UNALIGNED *PDDEACCESSDATA16;

typedef struct _DDEUNACCESSDATA16 {           /* d18 */
    DWORD   f1;
} DDEUNACCESSDATA16;
typedef DDEUNACCESSDATA16 UNALIGNED *PDDEUNACCESSDATA16;

typedef struct _DDEFREEDATAHANDLE16 {         /* d19 */
    DWORD   f1;
} DDEFREEDATAHANDLE16;
typedef DDEFREEDATAHANDLE16 UNALIGNED *PDDEFREEDATAHANDLE16;

typedef struct _DDEGETLASTERROR16 {           /* d20 */
    DWORD   f1;
} DDEGETLASTERROR16;
typedef DDEGETLASTERROR16 UNALIGNED *PDDEGETLASTERROR16;

typedef struct _DDECREATESTRINGHANDLE16 {     /* d21 */
    INT16   f3;
    VPVOID  f2;
    DWORD   f1;
} DDECREATESTRINGHANDLE16;
typedef DDECREATESTRINGHANDLE16 UNALIGNED *PDDECREATESTRINGHANDLE16;

typedef struct _DDEFREESTRINGHANDLE16 {       /* d22 */
    DWORD   f2;
    DWORD   f1;
} DDEFREESTRINGHANDLE16;
typedef DDEFREESTRINGHANDLE16 UNALIGNED *PDDEFREESTRINGHANDLE16;

typedef struct _DDEQUERYSTRING16 {            /* d23 */
    INT16   f5;
    DWORD   f4;
    VPVOID  f3;
    DWORD   f2;
    DWORD   f1;
} DDEQUERYSTRING16;
typedef DDEQUERYSTRING16 UNALIGNED *PDDEQUERYSTRING16;

typedef struct _DDEKEEPSTRINGHANDLE16 {       /* d24 */
    DWORD   f2;
    DWORD   f1;
} DDEKEEPSTRINGHANDLE16;
typedef DDEKEEPSTRINGHANDLE16 UNALIGNED *PDDEKEEPSTRINGHANDLE16;

typedef struct _DDEENABLECALLBACK16 {         /* d26 */
    WORD    f3;
    DWORD   f2;
    DWORD   f1;
} DDEENABLECALLBACK16;
typedef DDEENABLECALLBACK16 UNALIGNED *PDDEENABLECALLBACK16;

typedef struct _DDENAMESERVICE16 {            /* d27 */
    WORD    f4;
    DWORD   f3;
    DWORD   f2;
    DWORD   f1;
} DDENAMESERVICE16;
typedef DDENAMESERVICE16 UNALIGNED *PDDENAMESERVICE16;

typedef struct _DDECMPSTRINGHANDLES16 {       /* d36 */
    DWORD   f2;
    DWORD   f1;
} DDECMPSTRINGHANDLES16;
typedef DDECMPSTRINGHANDLES16 UNALIGNED *PDDECMPSTRINGHANDLES16;

typedef struct _DDERECONNECT16 {              /* d37 */
    DWORD   f1;
} DDERECONNECT16;
typedef DDERECONNECT16 UNALIGNED *PDDERECONNECT16;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowfax.h ===
//****************************************************************************
// WOW fax support. Common file. Conditionally shared between wow16, wow32,
// wowfax and wowfaxui
//
// 16bit structures are share between wow16 and wow32 only. Though they get
// included while compiling 32bit printdrivers wowfax and wowfaxui, yet they
// are incorrect and inaccessible from those dlls.
//
//
// History:
//    02-jan-95   nandurir   created.
//    01-feb-95   reedb      Clean-up, support printer install and bug fixes.
//
//****************************************************************************

//***************************************************************************
// WM_DDRV_ defines  - Common to wowexec,wow32,wowfax,wowfaxui. If you add
//                     a message, be sure to add it to the debug strings also.
//***************************************************************************

#define WM_DDRV_FIRST              (WM_USER+0x100+1) // begin DDRV range
#define WM_DDRV_LOAD               (WM_USER+0x100+1)
#define WM_DDRV_ENABLE             (WM_USER+0x100+2)
#define WM_DDRV_STARTDOC           (WM_USER+0x100+3)
#define WM_DDRV_PRINTPAGE          (WM_USER+0x100+4)
#define WM_DDRV_ESCAPE             (WM_USER+0x100+5)
#define WM_DDRV_DISABLE            (WM_USER+0x100+6)
#define WM_DDRV_INITFAXINFO16      (WM_USER+0x100+7)
#define WM_DDRV_ENDDOC             (WM_USER+0x100+8)
#define WM_DDRV_SUBCLASS           (WM_USER+0x100+9)
#define WM_DDRV_EXTDMODE           (WM_USER+0x100+10)
#define WM_DDRV_DEVCAPS            (WM_USER+0x100+11)
#define WM_DDRV_FREEFAXINFO16      (WM_USER+0x100+12)
#define WM_DDRV_UNLOAD             (WM_USER+0x100+20)
#define WM_DDRV_LAST               (WM_USER+0x100+20) // end DDRV range

#define CCHDOCNAME 128

#ifdef DEBUG
#ifdef DEFINE_DDRV_DEBUG_STRINGS
char *szWmDdrvDebugStrings[] =
{
    "WM_DDRV_LOAD",
    "WM_DDRV_ENABLE",
    "WM_DDRV_STARTDOC",
    "WM_DDRV_PRINTPAGE",
    "WM_DDRV_ESCAPE",
    "WM_DDRV_DISABLE",
    "WM_DDRV_INITFAXINFO16",
    "WM_DDRV_ENDDOC",
    "WM_DDRV_SUBCLASS",
    "WM_DDRV_EXTDMODE",
    "WM_DDRV_DEVCAPS",
    "WM_DDRV_FREEFAXINFO16",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "UNKNOWN MESSAGE",
    "WM_DDRV_UNLOAD"
};
#endif
#endif // #define(DEBUG)

// WOWFAX component file names. Unicode and ANSII
#define WOWFAX_DLL_NAME L"WOWFAX.DLL"
#define WOWFAXUI_DLL_NAME L"WOWFAXUI.DLL"
#define WOWFAX_DLL_NAME_A "WOWFAX.DLL"
#define WOWFAXUI_DLL_NAME_A "WOWFAXUI.DLL"

//***************************************************************************
//     wow16 ie  wowfax.c defines WOWFAX16 to include 16bit print.h etc
//
//***************************************************************************

#if  defined(_WOWFAX16_)

#include "..\..\..\mvdm\wow16\inc\print.h"
#include "..\..\..\mvdm\wow16\inc\gdidefs.inc"

#define LPTSTR              LPSTR
#define TEXT(x)             x
#define SRCCOPY             0x00CC0020L

//
// the following UNALIGNED definition is required because this file
// in included in wow16\test\shell\wowfax.h
//

#ifndef UNALIGNED

#if defined(MIPS) || defined(_ALPHA_) // winnt
#define UNALIGNED __unaligned         // winnt
#else                                 // winnt
#define UNALIGNED                     // winnt
#endif                                // winnt

#endif


#endif       // defined(wowfax16)

//***************************************************************************
// WOWFAXINFO16  common to wow16 and wow32
//      Struct cannot be accessed from 32bit wowfax/wowfaxui dlls
//***************************************************************************

#define WFINFO16_ENABLED           0x01

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _WOWFAXINFO16 {  /* winfo16 */
    WORD      hmem;
    WORD      flState;
    WORD      hInst;

    WORD (FAR PASCAL *lpEnable)(LPVOID,short,LPSTR,LPSTR,LPVOID);
    VOID (FAR PASCAL *lpDisable)(LPVOID);
    int (FAR PASCAL *lpControl)(LPVOID, short, LPVOID, LPVOID);
    BOOL (FAR PASCAL *lpBitblt)(LPVOID,WORD,WORD,LPVOID,
                              WORD,WORD,WORD,WORD,long,LPVOID,LPVOID);
    WORD (FAR PASCAL *lpExtDMode)(HWND, HANDLE, LPVOID, LPSTR, LPSTR,
                                               LPVOID, LPSTR , WORD);
    DWORD (FAR PASCAL *lpDevCaps)(LPSTR, LPSTR, WORD, LPSTR, LPVOID);

    WORD        hmemdevice;
    DWORD       cData;
    WORD        hwndui;
    DWORD       retvalue;
    WORD        wCmd;

    // The following pointers provide offsets into the mapped file
    // section used for inter process communication. They point to
    // objects which have a variable length.
    LPVOID      lpDevice;
    LPVOID      lpDriverName;
    LPVOID      lpPortName;
    LPVOID      lpIn;
    LPVOID      lpOut;

    // Since we have a max length (CCHDEVICENAME) we'll pass
    // the printer/device name in this fixed length buffer.
    char        szDeviceName[CCHDEVICENAME+1];
    char        szDocName[CCHDOCNAME+1];

} WOWFAXINFO16;

typedef WOWFAXINFO16 UNALIGNED FAR *LPWOWFAXINFO16;

//***************************************************************************
// GDIINFO16  common to wow16 and wow32
//        - this structure copied from wow16\inc\gdidefs.inc
//        - PTTYPE has been replaced with POINT
//
//      Struct cannot be accessed from 32bit wowfax/wowfaxui dlls. the
//      definition itself will be incorrect.
//
//***************************************************************************

#ifndef _DEF_WOW32_
#define POINT16             POINT
#endif

typedef struct _GDIINFO16{  /* gdii16 */
    short int dpVersion;
    short int dpTechnology;
    short int dpHorzSize;
    short int dpVertSize;
    short int dpHorzRes;
    short int dpVertRes;
    short int dpBitsPixel;
    short int dpPlanes;
    short int dpNumBrushes;
    short int dpNumPens;
    short int futureuse;
    short int dpNumFonts;
    short int dpNumColors;
    short int dpDEVICEsize;
    unsigned short int dpCurves;
    unsigned short int dpLines;
    unsigned short int dpPolygonals;
    unsigned short int dpText;
    unsigned short int dpClip;
    unsigned short int dpRaster;
    short int dpAspectX;
    short int dpAspectY;
    short int dpAspectXY;
    short int dpStyleLen;
    POINT16  dpMLoWin;
    POINT16  dpMLoVpt;
    POINT16  dpMHiWin;
    POINT16  dpMHiVpt;
    POINT16  dpELoWin;
    POINT16  dpELoVpt;
    POINT16  dpEHiWin;
    POINT16  dpEHiVpt;
    POINT16  dpTwpWin;
    POINT16  dpTwpVpt;
    short int dpLogPixelsX;
    short int dpLogPixelsY;
    short int dpDCManage;
    unsigned short int dpCaps1;
    short int futureuse4;
    short int futureuse5;
    short int futureuse6;
    short int futureuse7;
    WORD dpNumPalReg;
    WORD dpPalReserved;
    WORD dpColorRes;
} GDIINFO16;

typedef GDIINFO16 UNALIGNED FAR *LPGDIINFO16;


/* XLATOFF */
#pragma pack()
/* XLATON */

#ifndef _WOWFAX16_

//***************************************************************************
// WOWFAXINFO  - common to wow32,wowfax,wowfaxui. This defines the header of
//      shared memory section.
//
//***************************************************************************

typedef struct _WOWFAXINFO {   /* faxi */
    HWND    hwnd;
    DWORD   tid;
    WNDPROC proc16;
    LPBYTE  lpinfo16;

    UINT    msg;
    WPARAM  hdc;

    WORD    wCmd;
    DWORD   cData;
    HWND    hwndui;
    DWORD   retvalue;
    DWORD   status;

    // The following pointers provide offsets into the mapped file
    // section used for inter process communication. They point to
    // objects which have a variable length.
    LPVOID      lpDevice;
    LPVOID      lpDriverName;
    LPVOID      lpPortName;
    LPVOID      lpIn;
    LPVOID      lpOut;

    // Since we have a max length (CCHDEVICENAME) we'll pass
    // the printer/device name in this fixed length buffer.
    WCHAR       szDeviceName[CCHDEVICENAME+1];

    // EasyFax Ver2.0 support for JAPAN. 
    // Also needed for Procomm+ 3 cover sheets. Bug #305665
    WCHAR       szDocName[CCHDOCNAME+1];

    UINT    bmPixPerByte;
    UINT    bmWidthBytes;
    UINT    bmHeight;
    LPBYTE  lpbits;

} WOWFAXINFO, FAR *LPWOWFAXINFO;

#endif // _WOWFAX16_

#define WOWFAX_CLASS      TEXT("WOWFaxClass")

VOID GetFaxDataMapName(DWORD idMap, LPTSTR lpT);

//***************************************************************************
// Common functions for wow32, wowfax and wowfaxui.
//***************************************************************************

#ifdef WOWFAX_INC_COMMON_CODE

#define WOWFAX_MAPPREFIX  TEXT("wfm")
#define WOWFAX_HEXDIGITS  TEXT("0123456789abcdef")

//***************************************************************************
// GetFaxDataMapName - given idMap, generates the sharedmem Map Name.
//       A process can access the relevant data by opening the file
//       identified by idMap
//***************************************************************************

VOID GetFaxDataMapName(DWORD idMap, LPTSTR lpT)
{
    int i;
    int cb = lstrlen(WOWFAX_MAPPREFIX);
    LPBYTE lpid = (LPBYTE)&idMap;
    LPTSTR lphexT = WOWFAX_HEXDIGITS;

    lstrcpy(lpT, WOWFAX_MAPPREFIX);
    for (i = 0; i < sizeof(idMap)  ; i++) {
         lpT[(i * 2) + cb] = lphexT[lpid[i] & 0xf];
         lpT[(i * 2) + cb + 1] = lphexT[(lpid[i] & 0xf0) >> 4];
    }

    lpT[(i * 2) + cb] = 0;
}

#endif       // WOWFAX_INC_COMMON_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowinfo.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWINFO.H
 *  16-bit Kernel API argument structures
 *
 *  History:
 *  Created 1-jun-1992 by Matt Felton (mattfe)
--*/

// the following UNALIGNED definition is required because wowinfo.h is
// included in 'wowexec.c'
//
// these lines are from ntdef.h
//

#ifndef UNALIGNED

#if defined(MIPS) || defined(_ALPHA_) // winnt
#define UNALIGNED __unaligned // winnt
#else                         // winnt
#define UNALIGNED             // winnt
#endif                        // winnt

#endif

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _WOWINFO {               /**/
    LPSTR       lpCmdLine;
    LPSTR       lpAppName;
    LPSTR       lpEnv;
    DWORD       iTask;
    USHORT      CmdLineSize;
    USHORT      AppNameSize;
    USHORT      EnvSize;
    USHORT      CurDrive;
    LPSTR       lpCurDir;
    USHORT      CurDirSize;
    USHORT      wShowWindow;
} WOWINFO;
typedef WOWINFO UNALIGNED *PWOWINFO;

#define MAXENVIRONMENTSIZE	2048	// Max Size of Environment coped with.


/* XLATOFF */
#pragma pack()
/* XLATON */

#define WM_WOWEXECSTARTAPP         (WM_USER)    // also in windows\inc\vdmapi.h
#define WM_WOWEXECHEARTBEAT        (WM_USER+1)  // To deliver timer ticks
#define WM_WOWEXEC_START_TASK      (WM_USER+2)  // vdmdbg.dll sends this
#define WM_WOWEXECSTARTTIMER       (WM_USER+3)  // see WK32WowShutdownTimer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowgdi.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWGDI.H
 *  16-bit GDI API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
 *  Added Win 31 19-March-1992 Chandan S. Chauhan (ChandanC)
 *
--*/


/* GDI API IDs
 */
#define FUN_ADDFONTRESOURCE     119 //
#define FUN_ANIMATEPALETTE      367 //
#define FUN_ARC             23  //
#define FUN_BITBLT          34  //
#define FUN_BRUTE           213 // No proto
#define FUN_CHORD           348 //
#define FUN_CLOSEJOB            243 // No proto
#define FUN_CLOSEMETAFILE       126 //
#define FUN_COMBINERGN          47  //
#define FUN_COMPATIBLEBITMAP        157 // Internal
#define FUN_COPY            250 // Internal
#define FUN_COPYMETAFILE        151 //
#define FUN_CREATEBITMAP        48  //
#define FUN_CREATEBITMAPINDIRECT    49  //
#define FUN_CREATEBRUSHINDIRECT     50  //
#define FUN_CREATECOMPATIBLEBITMAP  51  //
#define FUN_CREATECOMPATIBLEDC      52  //
#define FUN_CREATEDC            53  //
#define FUN_CREATEDIBITMAP      442 //
#define FUN_CREATEDIBPATTERNBRUSH   445 //
#define FUN_CREATEDISCARDABLEBITMAP 156 //
#define FUN_CREATEELLIPTICRGN       54  //
#define FUN_CREATEELLIPTICRGNINDIRECT   55  //
#define FUN_CREATEFONT          56  //
#define FUN_CREATEFONTINDIRECT      57  //
#define FUN_CREATEHATCHBRUSH        58  //
#define FUN_CREATEIC            153 //
#define FUN_CREATEMETAFILE      125 //
#define FUN_CREATEPALETTE       360 //
#define FUN_CREATEPATTERNBRUSH      60  //
#define FUN_CREATEPEN           61  //
#define FUN_CREATEPENINDIRECT       62  //
#define FUN_CREATEPOLYGONRGN        63  //
#define FUN_CREATEPOLYPOLYGONRGN    451 //
#define FUN_CREATEPQ            230 // No proto
#define FUN_CREATEREALBITMAP        408 // Internal
#define FUN_CREATEREALBITMAPINDIRECT    406 // Internal
#define FUN_CREATERECTRGN       64  //
#define FUN_CREATERECTRGNINDIRECT   65  //
#define FUN_CREATEROUNDRECTRGN      444 //
#define FUN_CREATESOLIDBRUSH        66  //
#define FUN_CREATEUSERBITMAP        407 // Internal
#define FUN_CREATEUSERDISCARDABLEBITMAP 409 // Internal
#define FUN_DEATH           121 // Internal
#define FUN_DELETEABOVELINEFONTS    186 // Internal
#define FUN_DELETEDC            68  //
#define FUN_DELETEJOB           244 // No proto
#define FUN_DELETEMETAFILE      127 //
#define FUN_DELETEOBJECT        69  //
#define FUN_DELETEPQ            235 // No proto
#define FUN_DEVICECOLORMATCH        449 // Internal
#define FUN_DEVICEMODE          452 //
#define FUN_DMBITBLT            201 // No proto
#define FUN_DMCOLORINFO         202 // No proto
#define FUN_DMENUMDFONTS        206 // No proto
#define FUN_DMENUMOBJ           207 // No proto
#define FUN_DMOUTPUT            208 // No proto
#define FUN_DMPIXEL         209 // No proto
#define FUN_DMREALIZEOBJECT     210 // No proto
#define FUN_DMSCANLR            212 // No proto
#define FUN_DMSTRBLT            211 // No proto
#define FUN_DMTRANSPOSE         220 // No proto
#define FUN_DPTOLP          67  //
#define FUN_DPXLATE         138 // Internal
#define FUN_ELLIPSE         24  //
#define FUN_ENDSPOOLPAGE        247 // No proto
#define FUN_ENUMCALLBACK        158 // Internal
#define FUN_ENUMFONTS           70  //
#define FUN_ENUMMETAFILE        175 //
#define FUN_ENUMOBJECTS         71  //
#define FUN_EQUALRGN            72  //
#define FUN_ESCAPE          38  //
#define FUN_EXCLUDECLIPRECT     21  //
#define FUN_EXCLUDEVISRECT      73  // Internal
#define FUN_EXTDEVICEMODE       453 //
#define FUN_DEVICECAPABILITIES  454
//#define FUN_ADVANCEDSETUPDIALOG 455
#define FUN_EXTFLOODFILL        372 // Internal, proto
#define FUN_EXTRACTPQ           232 // No proto
#define FUN_EXTTEXTOUT          351 //
#define FUN_FASTWINDOWFRAME     400 // Internal
#define FUN_FILLRGN         40  //
#define FUN_FINALGDIINIT        405 // Internal
#define FUN_FLOODFILL           25  //
#define FUN_FRAMERGN            41  //
#define FUN_GDIFLUSH            263 // New Private
#define FUN_GDIINIT2            403 // Internal
#define FUN_GDIMOVEBITMAP       401 // Internal
#define FUN_GDIREALIZEPALETTE       362 // Internal
#define FUN_GDISELECTPALETTE        361 // Internal
#define FUN_GDI_WEP         0   // Export by name
#define FUN_GETASPECTRATIOFILTER    353 //
#define FUN_GETBITMAPBITS       74  //
#define FUN_GETBITMAPDIMENSION      162 //
#define FUN_GETBKCOLOR          75  //
#define FUN_GETBKMODE           76  //
#define FUN_GETBRUSHORG         149 //
#define FUN_GETCHARWIDTH        350 //
#define FUN_GETCLIPBOX          77  //
#define FUN_GETCLIPRGN          173 // Internal
#define FUN_GETCURLOGFONT       411 // Internal
#define FUN_GETCURRENTOBJECT        261 // New Private
#define FUN_GETCURRENTPOSITION      78  //
#define FUN_GETDCORG            79  //
#define FUN_GETDCSTATE          179 // Internal
#define FUN_GETDEVICECAPS       80  //
#define FUN_GETDIBITS           441 //
#define FUN_GETENVIRONMENT      133 //
#define FUN_GETMAPMODE          81  //
#define FUN_GETMETAFILE         124 //
#define FUN_GETMETAFILEBITS     159 //
#define FUN_GETNEARESTCOLOR     154 //
#define FUN_GETNEARESTPALETTEINDEX  370 //
#define FUN_GETOBJECT           82  //
#define FUN_GETOBJECTTYPE       260 // New Private
#define FUN_GETPALETTEENTRIES       363 //
#define FUN_GETPHYSICALFONTHANDLE   352 // Internal
#define FUN_GETPIXEL            83  //
#define FUN_GETPOLYFILLMODE     84  //
#define FUN_GETRELABS           86  // Internal
#define FUN_GETRGNBOX           134 //
#define FUN_GETROP2         85  //
#define FUN_GETSPOOLJOB         245 // No proto
#define FUN_GETSTOCKOBJECT      87  //
#define FUN_GETSTRETCHBLTMODE       88  //
#define FUN_GETSYSTEMPALETTEENTRIES 375 //
#define FUN_GETSYSTEMPALETTEUSE     374 //
#define FUN_GETTEXTALIGN        345 //
#define FUN_GETTEXTCHARACTEREXTRA   89  //
#define FUN_GETTEXTCOLOR        90  //
#define FUN_GETTEXTEXTENT       91  //
#define FUN_GETTEXTFACE         92  //
#define FUN_GETTEXTMETRICS      93  //
#define FUN_GETVIEWPORTEXT      94  //
#define FUN_GETVIEWPORTORG      95  //
#define FUN_GETWINDOWEXT        96  //
#define FUN_GETWINDOWORG        97  //
#define FUN_GSV             137 // Internal
#define FUN_INQUIREVISRGN       131 // Internal
#define FUN_INSERTPQ            233 // No proto
#define FUN_INTERNALCREATEDC        118 // Internal
#define FUN_INTERSECTCLIPRECT       22  //
#define FUN_INTERSECTVISRECT        98  // Internal
#define FUN_INVERTRGN           42  //
#define FUN_ISDCCURRENTPALETTE      412 // Internal
#define FUN_ISDCDIRTY           169 // Internal
#define FUN_ISVALIDMETAFILE     410 // Internal
#define FUN_LINEDDA         100 //
#define FUN_LINETO          19  //
#define FUN_LPTODP          99  //
#define FUN_LVBUNION            171 // Internal
#define FUN_MFDRAWTEXT          347 // Internal
#define FUN_MINPQ           231 // No proto
#define FUN_MOVETO          20  //
#define FUN_MULDIV          128 //
#define FUN_OFFSETCLIPRGN       32  //
#define FUN_OFFSETORG           143 // Internal
#define FUN_OFFSETRGN           101 //
#define FUN_OFFSETVIEWPORTORG       17  //
#define FUN_OFFSETVISRGN        102 // Internal
#define FUN_OFFSETWINDOWORG     15  //
#define FUN_OPENJOB         240 // No proto
#define FUN_PAINTRGN            43  //
#define FUN_PATBLT          29  //
#define FUN_PIE             26  //
#define FUN_PIXTOLINE           164 // Internal
#define FUN_PLAYMETAFILE        123 //
#define FUN_PLAYMETAFILERECORD      176 //
#define FUN_POLYGON         36  //
#define FUN_POLYLINE            37  //
#define FUN_POLYPOLYGON         450 //
#define FUN_POLYPOLYLINEWOW     487 //
#define FUN_PTINREGION          161 //
#define FUN_PTVISIBLE           103 //
#define FUN_QUERYABORT          155 // Internal
#define FUN_QUERYJOB            248 // Internal
#define FUN_RCOS            177 // Internal
#define FUN_REALIZEDEFAULTPALETTE   365 // Internal
#define FUN_RECTANGLE           27  //
#define FUN_RECTINREGION        181 //
#define FUN_RECTSTUFF           142 // Internal
#define FUN_RECTVISIBLE         104 //
#define FUN_REMOVEFONTRESOURCE      136 //
#define FUN_RESIZEPALETTE       368 //
#define FUN_RESTOREDC           39  //
#define FUN_RESTOREVISRGN       130 // Internal
#define FUN_RESURRECTION        122 // Internal
#define FUN_ROUNDRECT           28  //
#define FUN_RSIN            178 // Internal
#define FUN_SAVEDC          30  //
#define FUN_SAVEVISRGN          129 // Internal
#define FUN_SCALEEXT            140 // Internal
#define FUN_SCALEVIEWPORTEXT        18  //
#define FUN_SCALEWINDOWEXT      16  //
#define FUN_SCANLR          135 // Internal
#define FUN_SELECTCLIPRGN       44  //
#define FUN_SELECTOBJECT        45  //
#define FUN_SELECTVISRGN        105 // Internal
#define FUN_SETBITMAPBITS       106 //
#define FUN_SETBITMAPDIMENSION      163 //
#define FUN_SETBKCOLOR          1   //
#define FUN_SETBKMODE           2   //
#define FUN_SETBRUSHORG         148 //
#define FUN_SETDCORG            117 // Internal
#define FUN_SETDCSTATE          180 // Internal
#define FUN_SETDCSTATUS         170 // Internal
#define FUN_SETDIBITS           440 //
#define FUN_SETDIBITSTODEVICE       443 //
#define FUN_SETENVIRONMENT      132 //
#define FUN_SETMAPMODE          3   //
#define FUN_SETMAPPERFLAGS      349 //
#define FUN_SETMETAFILEBITS     160 //
#define FUN_SETPALETTEENTRIES       364 //
#define FUN_SETPIXEL            31  //
#define FUN_SETPOLYFILLMODE     6   //
#define FUN_SETRECTRGN          172 //
#define FUN_SETRELABS           5   // Internal
#define FUN_SETROP2         4   //
#define FUN_SETSTRETCHBLTMODE       7   //
#define FUN_SETSYSTEMPALETTEUSE     373 //
#define FUN_SETTEXTALIGN        346 //
#define FUN_SETTEXTCHARACTEREXTRA   8   //
#define FUN_SETTEXTCOLOR        9   //
#define FUN_SETTEXTJUSTIFICATION    10  //
#define FUN_SETVIEWPORTEXT      14  //
#define FUN_SETVIEWPORTORG      13  //
#define FUN_SETWINDOWEXT        12  //
#define FUN_SETWINDOWORG        11  //
#define FUN_SETWINVIEWEXT       139 // Internal
#define FUN_SHRINKGDIHEAP       354 // Internal
#define FUN_SIZEPQ          234 // No proto
#define FUN_STARTSPOOLPAGE      246 // No proto
#define FUN_STRETCHBLT          35  //
#define FUN_STRETCHDIBITS       439 //
#define FUN_STUFFINREGION       185 // Internal
#define FUN_STUFFVISIBLE        184 // Internal
#define FUN_TEXTOUT         33  //
#define FUN_UNREALIZEOBJECT     150 //
#define FUN_UPDATECOLORS        366 //
#define FUN_WORDSET         141 // Internal
#define FUN_WRITEDIALOG         242 // No proto
#define FUN_WRITESPOOL          241 // No proto
#define FUN_ABORTDOC            382
#define FUN_CREATESCALABLEFONTRESOURCE  310
#define FUN_ENDDOC          378
#define FUN_ENDPAGE         380
#define FUN_ENUMFONTFAMILIES        330
#define FUN_GETASPECTRATIOFILTEREX  486
#define FUN_GETBITMAPDIMENSIONEX    468
#define FUN_GETBOUNDSRECT       194
#define FUN_GETBRUSHORGEX       469
#define FUN_GETCHARABCWIDTHS        307
#define FUN_GETCURRENTPOSITIONEX    470
#define FUN_GETFONTDATA         311
#define FUN_GETGLYPHOUTLINE     309
#define FUN_GETOUTLINETEXTMETRICS   308
#define FUN_GETRASTERIZERCAPS       313
#define FUN_GETEXTEXTENTEX      188
#define FUN_GETEXTEXTENTPOINT       471
#define FUN_GETVIEWPORTEXTEX        472
#define FUN_GETVIEWPORTORGEX        473
#define FUN_GETWINDOWEXTEX      474
#define FUN_GETWINDOWORGEX      475
#define FUN_ISGDIOBJECT         462
#define FUN_MOVETOEX            483
#define FUN_OFFSETVIEWPORTORGEX     476
#define FUN_OFFSETWINDOWORGEX       477
#define FUN_QUERYABORT          155
#define FUN_RESETDC         376
#define FUN_SCALEVIEWPORTEXTEX      484
#define FUN_SCALEWINDOWEXTEX        485
#define FUN_SETABORTPROC        381
#define FUN_SETBITMAPDIMENSIONEX    478
#define FUN_SETBOUNDSRECT       193
#define FUN_SETMETAFILEBITSBETTER   196
#define FUN_SETVIEWPORTEXTEX        479
#define FUN_SETVIEWPORTORGEX        480
#define FUN_SETWINDOWEXTEX      481
#define FUN_SETWINDOWORGEX      482
#define FUN_SPOOLFILE           254
#define FUN_STARTDOC            377
#define FUN_STARTPAGE           379
#define FUN_BITMAPBITS          46
#define FUN_SETDCHOOK           190
#define FUN_GETDCHOOK           191
#define FUN_SETHOOKFLAGS        192
#define FUN_SELECTBITMAP        195
#define FUN_DMEXTTEXTOUT        214
#define FUN_DMGETCHARWIDTH      215
#define FUN_DMSTRETCHBLT        216
#define FUN_DMDIBBITS           217
#define FUN_DMSTRETCHDIBITS     218
#define FUN_DMSETDIBTODEV       219
#define FUN_DELETESPOOLPAGE     253
#define FUN_ENGINEENUMERATEFONT     300     // Internal
#define FUN_ENGINEDELETEFONT        301
#define FUN_ENGINEREALIZEFONT       302
#define FUN_ENGINEGETCHARWIDTH      303
#define FUN_ENGINESETFONTCONTEXT    304
#define FUN_ENGINEGETGLYPHBMP       305
#define FUN_ENGINEMAKEFONTDIR       306
#define FUN_ENGINEEXTTEXTOUT        314  // Internal
#define FUN_GETKERNINGPAIRS     332
#define FUN_FTRAPPING0          355  // Internal
#define FUN_GDISEEGDIDO         452
#define FUN_GDITASKTERMINATION      460
#define FUN_SETOBJECTOWNER      461
#define FUN_MAKEOBJECTPRIVATE       463
#define FUN_FIXUPBOGUSPUBLISHERMETAFILE 464
#define FUN_RECTVISIBLE_EHH     465
#define FUN_RECTINREGION_EHH        466
#define FUN_UNICODETOANSI       467  // Internal
#define FUN_CONVERTOUTLINEFONTFILE  312
#define FUN_GETTEXTEXTENTPOINT      471
#define FUN_CREATEDIBSECTION        489
#define FUN_SETDIBCOLORTABLE        602
#define FUN_GETDIBCOLORTABLE        603

#ifdef  FE_SB
// GetFontAssocStatus @488->459 for Taiwan, Prc and Korea
#define FUN_GETFONTASSOCSTATUS      459

/* EUDC/GAIJI escapes for FE */
#define TTYMODE                      2560
#define GAIJIFIRST                   TTYMODE+0x10
#define GAIJIFONTSIZE                GAIJIFIRST
#define GAIJIAREASIZE                GAIJIFIRST+1
#define GAIJISYSTEMGETFONT           GAIJIFIRST+2
#define GAIJISYSTEMSETFONT           GAIJIFIRST+3
#define GAIJIITOCODE                 GAIJIFIRST+4
#define GAIJILOCALOPEN               GAIJIFIRST+5
#define GAIJILOCALCLOSE              GAIJIFIRST+6
#define GAIJILOCALSETFONT            GAIJIFIRST+7
#define GAIJILOCALSAVE               GAIJIFIRST+8
#define GAIJILOCALRESTORE            GAIJIFIRST+9
#define GAIJIGETFILENAME             GAIJIFIRST+10
#define GAIJISETFILENAME             GAIJIFIRST+11
#define GAIJIGETDESCRIPTIONNAME      GAIJIFIRST+12
#define GAIJIPHYSICALFONTSIZE        GAIJIFIRST+13
#endif  // FE_SB

/* New for NT 5.0 Win95 compatibility */

#define FUN_ABORTPATH               511
#define FUN_ABORTPRINTER            271
#define FUN_ADDLPKTOGDI             614
#define FUN_BEGINPATH               512
#define FUN_BUILDINVERSETABLEDIB    617  // export 650
#define FUN_CLOSEENHMETAFILE        490
#define FUN_CLOSEFIGURE             513
#define FUN_CLOSEPRINTER            274
#define FUN_COPYENHMETAFILE         491
#define FUN_CREATEENHMETAFILE       492
#define FUN_CREATEHALFTONEPALETTE   529
#define FUN_DELETEENHMETAFILE       493
#define FUN_DRVGETPRINTERDATA       282
#define FUN_DRVSETPRINTERDATA       281
#define FUN_ENDDOCPRINTER           272
#define FUN_ENDPAGEPRINTER          270
#define FUN_ENDPATH                 514
#define FUN_ENGINEGETCHARWIDTHEX    299
#define FUN_ENGINEGETCHARWIDTHSTR   316
#define FUN_ENGINEGETGLYPHBMPEXT    305
#define FUN_ENGINEREALIZEFONTEXT    315
#define FUN_ENUMFONTFAMILIESEX      613
#define FUN_EXTCREATEPEN            523
#define FUN_EXTCREATEREGION         608
#define FUN_EXTSELECTCLIPRGN        508
#define FUN_FILLPATH                515
#define FUN_FLATTENPATH             516
#define FUN_GDICOMMENT              495
#define FUN___AVAILABLE_609         609
#define FUN_GDIPARAMETERSINFO       528
#define FUN_GDISIGNALPROC32         610
#define FUN_GETARCDIRECTION         524
#define FUN_GETCHARACTERPLACEMENT   615
#define FUN_GETENHMETAFILE          496
#define FUN_GETENHMETAFILEBITS      497
#define FUN_GETENHMETAFILEDESCRIPTION 498
#define FUN_GETENHMETAFILEHEADER    499
#define FUN_GETENHMETAFILEPALETTEENTRIES 501
#define FUN_GETFONTLANGUAGEINFO     616
#define FUN_GETMITERLIMIT           526
#define FUN_GETPATH                 517
#define FUN_GETRANDOMRGN            611
#define FUN_GETREALDRIVERINFO       280
#define FUN_GETREGIONDATA           607
#define FUN_GETTEXTCHARSET          612
#define FUN_GETTEXTEXTENTEX         188
#define FUN_GETTTGLYPHINDEXMAP      404
#define FUN_ICMCHECKCOLORSINGAMUT   622  // export 824
#define FUN_ICMCREATETRANSFORM      618  // export 820
#define FUN_ICMDELETETRANSFORM      619  // export 821
#define FUN_ICMTRANSLATERGB         620  // export 822
#define FUN_ICMTRANSLATERGBS        621  // export 823
#define FUN_OPENPRINTERA            266
#define FUN_PATHTOREGION            518
#define FUN_PLAYENHMETAFILERECORD   504
#define FUN_POLYBEZIER              502
#define FUN_POLYBEZIERTO            503
#define FUN_SELECTCLIPPATH          519
#define FUN_SETARCDIRECTION         525
#define FUN_SETENHMETAFILEBITS      505
#define FUN_SETMAGICCOLORS          606
#define FUN_SETMETARGN              506
#define FUN_SETMITERLIMIT           527
#define FUN_SETSOLIDBRUSH           604
#define FUN_STARTDOCPRINTERA        267
#define FUN_STARTPAGEPRINTER        268
#define FUN_STROKEANDFILLPATH       520
#define FUN_STROKEPATH              521
#define FUN_SYSDELETEOBJECT         605
#define FUN_WIDENPATH               522
#define FUN_WRITEPRINTER            269


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _ADDFONTRESOURCE16 {     /* g119 */
    VPSZ f1;
} ADDFONTRESOURCE16;
typedef ADDFONTRESOURCE16 UNALIGNED *PADDFONTRESOURCE16;

typedef struct _ANIMATEPALETTE16 {      /* g367 */
    VPPALETTEENTRY16 f4;
    WORD f3;
    WORD f2;
    HPAL16 f1;
} ANIMATEPALETTE16;
typedef ANIMATEPALETTE16 UNALIGNED *PANIMATEPALETTE16;

typedef struct _ARC16 {             /* g23 */
    SHORT f9;
    SHORT f8;
    SHORT f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} ARC16;
typedef ARC16 UNALIGNED *PARC16;

typedef struct _BITBLT16 {          /* g34 */
    DWORD f9;
    SHORT f8;
    SHORT f7;
    HDC16 f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} BITBLT16;
typedef BITBLT16 UNALIGNED *PBITBLT16;

typedef struct _CHORD16 {           /* g348 */
    SHORT f9;
    SHORT f8;
    SHORT f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} CHORD16;
typedef CHORD16 UNALIGNED *PCHORD16;

typedef struct _SETRELABS16 {      /* g5 */
    SHORT f2;
    HDC16 f1;
} SETRELABS16;
typedef SETRELABS16 UNALIGNED *PSETRELABS16;

typedef struct _GETRELABS16 {      /* g86 */
    HDC16 f1;
} GETRELABS16;
typedef GETRELABS16 UNALIGNED *PGETRELABS16;

typedef struct _CLOSEMETAFILE16 {  /* g126 */
    HAND16 f1;
} CLOSEMETAFILE16;
typedef CLOSEMETAFILE16 UNALIGNED *PCLOSEMETAFILE16;

typedef struct _COMBINERGN16 {          /* g47 */
    SHORT f4;
    HRGN16 f3;
    HRGN16 f2;
    HRGN16 f1;
} COMBINERGN16;
typedef COMBINERGN16 UNALIGNED *PCOMBINERGN16;

typedef struct _COPYMETAFILE16 {        /* g151 */
    VPSZ f2;
    HAND16 f1;
} COPYMETAFILE16;
typedef COPYMETAFILE16 UNALIGNED *PCOPYMETAFILE16;

typedef struct _CREATEBITMAP16 {        /* g48 */
    VPBYTE f5;
    WORD f4;
    WORD f3;
    SHORT f2;
    SHORT f1;
} CREATEBITMAP16;
typedef CREATEBITMAP16 UNALIGNED *PCREATEBITMAP16;

typedef struct _CREATEUSERBITMAP16 {        /* g407 */
    VPBYTE f5;
    WORD f4;
    WORD f3;
    SHORT f2;
    SHORT f1;
} CREATEUSERBITMAP16, *PCREATEUSERBITMAP16;

typedef struct _CREATEBITMAPINDIRECT16 {    /* g49 */
    VPBITMAP16 f1;
} CREATEBITMAPINDIRECT16;
typedef CREATEBITMAPINDIRECT16 UNALIGNED *PCREATEBITMAPINDIRECT16;

typedef struct _CREATEBRUSHINDIRECT16 {     /* g50 */
    VPLOGBRUSH16 f1;
} CREATEBRUSHINDIRECT16;
typedef CREATEBRUSHINDIRECT16 UNALIGNED *PCREATEBRUSHINDIRECT16;

typedef struct _CREATECOMPATIBLEBITMAP16 {  /* g51 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} CREATECOMPATIBLEBITMAP16;
typedef CREATECOMPATIBLEBITMAP16 UNALIGNED *PCREATECOMPATIBLEBITMAP16;

typedef struct _CREATECOMPATIBLEDC16 {      /* g52 */
    HDC16 f1;
} CREATECOMPATIBLEDC16;
typedef CREATECOMPATIBLEDC16 UNALIGNED *PCREATECOMPATIBLEDC16;

typedef struct _CREATEDC16 {            /* g53 */
    VPDEVMODE31 f4;
    VPSZ f3;
    VPSZ f2;
    VPSZ f1;
} CREATEDC16;
typedef CREATEDC16 UNALIGNED *PCREATEDC16;

typedef struct _CREATEDIBITMAP16 {      /* g442 */
    WORD f6;
    VPBITMAPINFO16 f5;
    VPBYTE f4;
    DWORD f3;
    VPBITMAPINFOHEADER16 f2;
    HDC16 f1;
} CREATEDIBITMAP16;
typedef CREATEDIBITMAP16 UNALIGNED *PCREATEDIBITMAP16;

typedef struct _CREATEDIBSECTION16 {      /* g489 */
    DWORD f6;
    DWORD f5;
    VPBYTE f4;
    WORD f3;
    VPBITMAPINFO16 f2;
    HDC16 f1;
} CREATEDIBSECTION16;
typedef CREATEDIBSECTION16 UNALIGNED *PCREATEDIBSECTION16;

typedef struct _GETDIBCOLORTABLE16 {      /* g603 */
    VPBYTE f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} GETDIBCOLORTABLE16;
typedef GETDIBCOLORTABLE16 UNALIGNED *PGETDIBCOLORTABLE16;

typedef struct _SETDIBCOLORTABLE16 {      /* g602 */
    VPBYTE f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} SETDIBCOLORTABLE16;
typedef SETDIBCOLORTABLE16 UNALIGNED *PSETDIBCOLORTABLE16;

typedef struct _CREATEDIBPATTERNBRUSH16 {   /* g445 */
    WORD f2;
    VPVOID f1;
} CREATEDIBPATTERNBRUSH16;
typedef CREATEDIBPATTERNBRUSH16 UNALIGNED *PCREATEDIBPATTERNBRUSH16;

typedef struct _CREATEDISCARDABLEBITMAP16 { /* g156 */
    SHORT height;
    SHORT width;
    HDC16 hdc;
} CREATEDISCARDABLEBITMAP16;
typedef CREATEDISCARDABLEBITMAP16 UNALIGNED *PCREATEDISCARDABLEBITMAP16;

typedef struct _CREATEELLIPTICRGN16 {       /* g54 */
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} CREATEELLIPTICRGN16;
typedef CREATEELLIPTICRGN16 UNALIGNED *PCREATEELLIPTICRGN16;

typedef struct _CREATEELLIPTICRGNINDIRECT16 {   /* g55 */
    VPRECT16 f1;
} CREATEELLIPTICRGNINDIRECT16;
typedef CREATEELLIPTICRGNINDIRECT16 UNALIGNED *PCREATEELLIPTICRGNINDIRECT16;

typedef struct _CREATEFONT16 {          /* g56 */
    VPSZ f14;
    WORD f13;
    WORD f12;
    WORD f11;
    WORD f10;
    WORD f9;
    WORD f8;
    WORD f7;
    WORD f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} CREATEFONT16;
typedef CREATEFONT16 UNALIGNED *PCREATEFONT16;

typedef struct _CREATEFONTINDIRECT16 {      /* g57 */
    VPLOGFONT16 f1;
} CREATEFONTINDIRECT16;
typedef CREATEFONTINDIRECT16 UNALIGNED *PCREATEFONTINDIRECT16;

typedef struct _CREATEHATCHBRUSH16 {        /* g58 */
    DWORD f2;
    SHORT f1;
} CREATEHATCHBRUSH16;
typedef CREATEHATCHBRUSH16 UNALIGNED *PCREATEHATCHBRUSH16;

typedef struct _CREATEIC16 {            /* g153 */
    VPDEVMODE31 f4;
    VPSZ f3;
    VPSZ f2;
    VPSZ f1;
} CREATEIC16;
typedef CREATEIC16 UNALIGNED *PCREATEIC16;

typedef struct _CREATEMETAFILE16 {      /* g125 */
    VPSZ f1;
} CREATEMETAFILE16;
typedef CREATEMETAFILE16 UNALIGNED *PCREATEMETAFILE16;

typedef struct _CREATEPALETTE16 {       /* g360 */
    VPLOGPALETTE16 f1;
} CREATEPALETTE16;
typedef CREATEPALETTE16 UNALIGNED *PCREATEPALETTE16;

typedef struct _CREATEPATTERNBRUSH16 {      /* g60 */
    HBM16 f1;
} CREATEPATTERNBRUSH16;
typedef CREATEPATTERNBRUSH16 UNALIGNED *PCREATEPATTERNBRUSH16;

typedef struct _CREATEPEN16 {           /* g61 */
    DWORD f3;
    SHORT f2;
    SHORT f1;
} CREATEPEN16;
typedef CREATEPEN16 UNALIGNED *PCREATEPEN16;

typedef struct _CREATEPENINDIRECT16 {       /* g62 */
    VPLOGPEN16 f1;
} CREATEPENINDIRECT16;
typedef CREATEPENINDIRECT16 UNALIGNED *PCREATEPENINDIRECT16;

typedef struct _CREATEPOLYGONRGN16 {        /* g63 */
    SHORT f3;
    SHORT f2;
    VPPOINT16 f1;
} CREATEPOLYGONRGN16;
typedef CREATEPOLYGONRGN16 UNALIGNED *PCREATEPOLYGONRGN16;

typedef struct _CREATEPOLYPOLYGONRGN16 {    /* g451 */
    SHORT f4;
    SHORT f3;
    VPSHORT f2;
    VPPOINT16 f1;
} CREATEPOLYPOLYGONRGN16;
typedef CREATEPOLYPOLYGONRGN16 UNALIGNED *PCREATEPOLYPOLYGONRGN16;

typedef struct _CREATERECTRGN16 {       /* g64 */
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} CREATERECTRGN16;
typedef CREATERECTRGN16 UNALIGNED *PCREATERECTRGN16;

typedef struct _CREATERECTRGNINDIRECT16 {   /* g65 */
    VPRECT16 f1;
} CREATERECTRGNINDIRECT16;
typedef CREATERECTRGNINDIRECT16 UNALIGNED *PCREATERECTRGNINDIRECT16;

typedef struct _CREATEROUNDRECTRGN16 {      /* g444 */
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} CREATEROUNDRECTRGN16;
typedef CREATEROUNDRECTRGN16 UNALIGNED *PCREATEROUNDRECTRGN16;

typedef struct _CREATESOLIDBRUSH16 {        /* g66 */
    DWORD f1;
} CREATESOLIDBRUSH16;
typedef CREATESOLIDBRUSH16 UNALIGNED *PCREATESOLIDBRUSH16;

typedef struct _DELETEDC16 {            /* g68 */
    HDC16 f1;
} DELETEDC16;
typedef DELETEDC16 UNALIGNED *PDELETEDC16;

typedef struct _DELETEMETAFILE16 {      /* g127 */
    HAND16 f1;
} DELETEMETAFILE16;
typedef DELETEMETAFILE16 UNALIGNED *PDELETEMETAFILE16;

typedef struct _DELETEOBJECT16 {        /* g69 */
    HAND16 f1;
} DELETEOBJECT16;
typedef DELETEOBJECT16 UNALIGNED *PDELETEOBJECT16;

typedef struct _DEVICEMODE16 {          /* g452 */
    VPSZ    f4;
    VPSZ    f3;
    HAND16  f2;
    HWND16  f1;
} DEVICEMODE16;
typedef DEVICEMODE16 UNALIGNED *PDEVICEMODE16;

typedef struct _EXTDEVICEMODE16 {       /* g453 */
    SHORT   f8;
    VPSZ    f7;
    VPDEVMODE31 f6;
    VPSZ    f5;
    VPSZ    f4;
    VPDEVMODE31 f3;
    HAND16  f2;
    HWND16  f1;
} EXTDEVICEMODE16;
typedef EXTDEVICEMODE16 UNALIGNED *PEXTDEVICEMODE16;

typedef struct _DEVICECAPABILITIES16 {  /* g454 */
    VPDEVMODE31 f5;
    VPSZ    f4;
    SHORT   f3;
    VPSZ    f2;
    VPSZ    f1;
} DEVICECAPABILITIES16;
typedef DEVICECAPABILITIES16 UNALIGNED *PDEVICECAPABILITIES16;

//typedef struct _ADVANCEDSETUPDIALOG16 {  /* g455 */
//    VPSZ    f4;
//    VPSZ    f3;
//    HAND16  f2;
//    HWND16  f1;
//} ADVANCEDSETUPDIALOG16;
//typedef ADVANCEDSETUPDIALOG16 UNALIGNED *PADVANCEDSETUPDIALOG16;

typedef struct _DPTOLP16 {          /* g67 */
    SHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} DPTOLP16;
typedef DPTOLP16 UNALIGNED *PDPTOLP16;

typedef struct _ELLIPSE16 {         /* g24 */
    SHORT y2;
    SHORT x2;
    SHORT y1;
    SHORT x1;
    HDC16 hdc;
} ELLIPSE16;
typedef ELLIPSE16 UNALIGNED *PELLIPSE16;

typedef struct _ENUMFONTS16 {           /* g70 */
    VPBYTE f4;
    VPPROC f3;
    VPSZ f2;
    HDC16 f1;
} ENUMFONTS16;
typedef ENUMFONTS16 UNALIGNED *PENUMFONTS16;

typedef struct _ENUMMETAFILE16 {        /* g175 */
    VPBYTE  f4;
    VPPROC f3;
    HAND16  f2;
    HDC16   f1;
} ENUMMETAFILE16;
typedef ENUMMETAFILE16 UNALIGNED *PENUMMETAFILE16;

typedef struct _ENUMOBJECTS16 {         /* g71 */
    VPBYTE f4;
    VPPROC f3;
    SHORT f2;
    HDC16 f1;
} ENUMOBJECTS16;
typedef ENUMOBJECTS16 UNALIGNED *PENUMOBJECTS16;

typedef struct _EQUALRGN16 {            /* g72 */
    HRGN16 f2;
    HRGN16 f1;
} EQUALRGN16;
typedef EQUALRGN16 UNALIGNED *PEQUALRGN16;

typedef struct _ESCAPE16 {          /* g38 */
    VPSTR f5;
    VPSTR f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} ESCAPE16;
typedef ESCAPE16 UNALIGNED *PESCAPE16;

typedef struct _EXCLUDECLIPRECT16 {     /* g21 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} EXCLUDECLIPRECT16;
typedef EXCLUDECLIPRECT16 UNALIGNED *PEXCLUDECLIPRECT16;

typedef struct _EXTFLOODFILL16 {        /* g372 */
    WORD f5;
    DWORD f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} EXTFLOODFILL16;
typedef EXTFLOODFILL16 UNALIGNED *PEXTFLOODFILL16;

typedef struct _EXTTEXTOUT16 {          /* g351 */
    VPSHORT f8;
    WORD f7;
    VPSTR f6;
    VPRECT16 f5;
    WORD f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} EXTTEXTOUT16;
typedef EXTTEXTOUT16 UNALIGNED *PEXTTEXTOUT16;

typedef struct _FILLRGN16 {         /* g40 */
    HBRSH16 f3;
    HRGN16 f2;
    HDC16 f1;
} FILLRGN16;
typedef FILLRGN16 UNALIGNED *PFILLRGN16;

typedef struct _FLOODFILL16 {           /* g25 */
    DWORD f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} FLOODFILL16;
typedef FLOODFILL16 UNALIGNED *PFLOODFILL16;

typedef struct _FRAMERGN16 {            /* g41 */
    SHORT f5;
    SHORT f4;
    HBRSH16 f3;
    HRGN16 f2;
    HDC16 f1;
} FRAMERGN16;
typedef FRAMERGN16 UNALIGNED *PFRAMERGN16;

typedef struct _GETASPECTRATIOFILTER16 {    /* g353 */
    HDC16 f1;
} GETASPECTRATIOFILTER16;
typedef GETASPECTRATIOFILTER16 UNALIGNED *PGETASPECTRATIOFILTER16;

typedef struct _GETASPECTRATIOFILTEREX16 {  /* g486 */
    VPVOID  f2;
    HDC16 f1;
} GETASPECTRATIOFILTEREX16;
typedef GETASPECTRATIOFILTEREX16 UNALIGNED *PGETASPECTRATIOFILTEREX16;

typedef struct _GETBITMAPBITS16 {       /* g74 */
    VPSTR f3;
    LONG f2;
    HBM16 f1;
} GETBITMAPBITS16;
typedef GETBITMAPBITS16 UNALIGNED *PGETBITMAPBITS16;

typedef struct _GETBITMAPDIMENSION16 {      /* g162 */
    HBM16 f1;
} GETBITMAPDIMENSION16;
typedef GETBITMAPDIMENSION16 UNALIGNED *PGETBITMAPDIMENSION16;

typedef struct _GETBKCOLOR16 {          /* g75 */
    HDC16 f1;
} GETBKCOLOR16;
typedef GETBKCOLOR16 UNALIGNED *PGETBKCOLOR16;

typedef struct _GETBKMODE16 {           /* g76 */
    HDC16 f1;
} GETBKMODE16;
typedef GETBKMODE16 UNALIGNED *PGETBKMODE16;

typedef struct _GETBRUSHORG16 {         /* g149 */
    HDC16 f1;
} GETBRUSHORG16;
typedef GETBRUSHORG16 UNALIGNED *PGETBRUSHORG16;

typedef struct _GETCHARWIDTH16 {        /* g350 */
    VPSHORT lpIntBuffer;
    WORD wLastChar;
    WORD wFirstChar;
    HDC16 hDC;
} GETCHARWIDTH16;
typedef GETCHARWIDTH16 UNALIGNED *PGETCHARWIDTH16;

typedef struct _GETCLIPBOX16 {          /* g77 */
    VPRECT16 f2;
    HDC16 f1;
} GETCLIPBOX16;
typedef GETCLIPBOX16 UNALIGNED *PGETCLIPBOX16;

typedef struct _GETCURRENTOBJECT16 {        /* g261 */
    WORD  f2;
    HDC16 f1;
} GETCURRENTOBJECT16;
typedef GETCURRENTOBJECT16 UNALIGNED *PGETCURRENTOBJECT16;

typedef struct _GETCURRENTPOSITION16 {      /* g78 */
    HDC16 f1;
} GETCURRENTPOSITION16;
typedef GETCURRENTPOSITION16 UNALIGNED *PGETCURRENTPOSITION16;

typedef struct _GETDCORG16 {            /* g79 */
    HDC16 f1;
} GETDCORG16;
typedef GETDCORG16 UNALIGNED *PGETDCORG16;

typedef struct _GETDEVICECAPS16 {       /* g80 */
    SHORT f2;
    HDC16 f1;
} GETDEVICECAPS16;
typedef GETDEVICECAPS16 UNALIGNED *PGETDEVICECAPS16;

typedef struct _GETDIBITS16 {           /* g441 */
    WORD f7;
    VPBITMAPINFO16 f6;
    VPSTR f5;
    WORD f4;
    WORD f3;
    HAND16 f2;
    HDC16 f1;
} GETDIBITS16;
typedef GETDIBITS16 UNALIGNED *PGETDIBITS16;

typedef struct _GETENVIRONMENT16 {      /* g133 */
    WORD f3;
    VPSTR f2;
    VPSTR f1;
} GETENVIRONMENT16;
typedef GETENVIRONMENT16 UNALIGNED *PGETENVIRONMENT16;

typedef struct _GETKERNINGPAIRS16 {      /* g332 */
    VPSTR f3;
    WORD f2;
    WORD f1;
} GETKERNINGPAIRS16;
typedef GETKERNINGPAIRS16 UNALIGNED *PGETKERNINGPAIRS16;


typedef struct _GETMAPMODE16 {          /* g81 */
    HDC16 f1;
} GETMAPMODE16;
typedef GETMAPMODE16 UNALIGNED *PGETMAPMODE16;

typedef struct _GETMETAFILE16 {         /* g124 */
    VPSTR f1;
} GETMETAFILE16;
typedef GETMETAFILE16 UNALIGNED *PGETMETAFILE16;

typedef struct _GETMETAFILEBITS16 {     /* g159 */
    HAND16 f1;
} GETMETAFILEBITS16;
typedef GETMETAFILEBITS16 UNALIGNED *PGETMETAFILEBITS16;

typedef struct _GETNEARESTCOLOR16 {     /* g154 */
    DWORD f2;
    HDC16 f1;
} GETNEARESTCOLOR16;
typedef GETNEARESTCOLOR16 UNALIGNED *PGETNEARESTCOLOR16;

typedef struct _GETNEARESTPALETTEINDEX16 {  /* g370 */
    DWORD f2;
    HPAL16 f1;
} GETNEARESTPALETTEINDEX16;
typedef GETNEARESTPALETTEINDEX16 UNALIGNED *PGETNEARESTPALETTEINDEX16;

typedef struct _GETOBJECT16 {           /* g82 */
    VPSTR f3;
    SHORT f2;
    HAND16 f1;
} GETOBJECT16;
typedef GETOBJECT16 UNALIGNED *PGETOBJECT16;

typedef struct _GETOBJECTTYPE16 {       /* g260 */
    HDC16 f1;
} GETOBJECTTYPE16;
typedef GETOBJECTTYPE16 UNALIGNED *PGETOBJECTTYPE16;

typedef struct _GETPALETTEENTRIES16 {       /* g363 */
    VPPALETTEENTRY16 f4;
    WORD f3;
    WORD f2;
    HPAL16 f1;
} GETPALETTEENTRIES16;
typedef GETPALETTEENTRIES16 UNALIGNED *PGETPALETTEENTRIES16;

typedef struct _GETPIXEL16 {            /* g83 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} GETPIXEL16;
typedef GETPIXEL16 UNALIGNED *PGETPIXEL16;

typedef struct _GETPOLYFILLMODE16 {     /* g84 */
    HDC16 f1;
} GETPOLYFILLMODE16;
typedef GETPOLYFILLMODE16 UNALIGNED *PGETPOLYFILLMODE16;

typedef struct _GETRGNBOX16 {           /* g134 */
    VPRECT16 f2;
    HRGN16 f1;
} GETRGNBOX16;
typedef GETRGNBOX16 UNALIGNED *PGETRGNBOX16;

typedef struct _GETROP216 {         /* g85 */
    HDC16 f1;
} GETROP216;
typedef GETROP216 UNALIGNED *PGETROP216;

typedef struct _GETSTOCKOBJECT16 {      /* g87 */
    SHORT f1;
} GETSTOCKOBJECT16;
typedef GETSTOCKOBJECT16 UNALIGNED *PGETSTOCKOBJECT16;

typedef struct _GETSTRETCHBLTMODE16 {       /* g88 */
    HDC16 f1;
} GETSTRETCHBLTMODE16;
typedef GETSTRETCHBLTMODE16 UNALIGNED *PGETSTRETCHBLTMODE16;

typedef struct _GETSYSTEMPALETTEENTRIES16 { /* g375 */
    VPPALETTEENTRY16 f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} GETSYSTEMPALETTEENTRIES16;
typedef GETSYSTEMPALETTEENTRIES16 UNALIGNED *PGETSYSTEMPALETTEENTRIES16;

typedef struct _GETSYSTEMPALETTEUSE16 {     /* g374 */
    HDC16 f1;
} GETSYSTEMPALETTEUSE16;
typedef GETSYSTEMPALETTEUSE16 UNALIGNED *PGETSYSTEMPALETTEUSE16;

typedef struct _GETTEXTALIGN16 {        /* g345 */
    HDC16 f1;
} GETTEXTALIGN16;
typedef GETTEXTALIGN16 UNALIGNED *PGETTEXTALIGN16;

typedef struct _GETTEXTCHARACTEREXTRA16 {   /* g89 */
    HDC16 f1;
} GETTEXTCHARACTEREXTRA16;
typedef GETTEXTCHARACTEREXTRA16 UNALIGNED *PGETTEXTCHARACTEREXTRA16;

typedef struct _GETTEXTCOLOR16 {        /* g90 */
    HDC16 f1;
} GETTEXTCOLOR16;
typedef GETTEXTCOLOR16 UNALIGNED *PGETTEXTCOLOR16;

typedef struct _GETTEXTEXTENT16 {       /* g91 */
    SHORT f3;
    VPSTR f2;
    HDC16 f1;
} GETTEXTEXTENT16;
typedef GETTEXTEXTENT16 UNALIGNED *PGETTEXTEXTENT16;

typedef struct _GETTEXTFACE16 {         /* g92 */
    VPSTR f3;
    SHORT f2;
    HDC16 f1;
} GETTEXTFACE16;
typedef GETTEXTFACE16 UNALIGNED *PGETTEXTFACE16;

typedef struct _GETTEXTMETRICS16 {      /* g93 */
    VPTEXTMETRIC16 f2;
    HDC16 f1;
} GETTEXTMETRICS16;
typedef GETTEXTMETRICS16 UNALIGNED *PGETTEXTMETRICS16;

typedef struct _GETVIEWPORTEXT16 {      /* g94 */
    HDC16 f1;
} GETVIEWPORTEXT16;
typedef GETVIEWPORTEXT16 UNALIGNED *PGETVIEWPORTEXT16;

typedef struct _GETVIEWPORTORG16 {      /* g95 */
    HDC16 f1;
} GETVIEWPORTORG16;
typedef GETVIEWPORTORG16 UNALIGNED *PGETVIEWPORTORG16;

typedef struct _GETWINDOWEXT16 {        /* g96 */
    HDC16 f1;
} GETWINDOWEXT16;
typedef GETWINDOWEXT16 UNALIGNED *PGETWINDOWEXT16;

typedef struct _GETWINDOWORG16 {        /* g97 */
    HDC16 f1;
} GETWINDOWORG16;
typedef GETWINDOWORG16 UNALIGNED *PGETWINDOWORG16;

typedef struct _INTERSECTCLIPRECT16 {       /* g22 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} INTERSECTCLIPRECT16;
typedef INTERSECTCLIPRECT16 UNALIGNED *PINTERSECTCLIPRECT16;

typedef struct _INVERTRGN16 {           /* g42 */
    HRGN16 f2;
    HDC16 f1;
} INVERTRGN16;
typedef INVERTRGN16 UNALIGNED *PINVERTRGN16;

typedef struct _LINEDDA16 {         /* g100 */
    VPSTR f6;
    VPPROC f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    SHORT f1;
} LINEDDA16;
typedef LINEDDA16 UNALIGNED *PLINEDDA16;

typedef struct _LINETO16 {          /* g19 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} LINETO16;
typedef LINETO16 UNALIGNED *PLINETO16;

typedef struct _LPTODP16 {          /* g99 */
    SHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} LPTODP16;
typedef LPTODP16 UNALIGNED *PLPTODP16;

typedef struct _MOVETO16 {          /* g20 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} MOVETO16;
typedef MOVETO16 UNALIGNED *PMOVETO16;

typedef struct _MULDIV16 {          /* g128 */
    SHORT f3;
    SHORT f2;
    SHORT f1;
} MULDIV16;
typedef MULDIV16 UNALIGNED *PMULDIV16;

typedef struct _OFFSETCLIPRGN16 {       /* g32 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETCLIPRGN16;
typedef OFFSETCLIPRGN16 UNALIGNED *POFFSETCLIPRGN16;

typedef struct _OFFSETRGN16 {           /* g101 */
    SHORT f3;
    SHORT f2;
    HRGN16 f1;
} OFFSETRGN16;
typedef OFFSETRGN16 UNALIGNED *POFFSETRGN16;

typedef struct _OFFSETVIEWPORTORG16 {       /* g17 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETVIEWPORTORG16;
typedef OFFSETVIEWPORTORG16 UNALIGNED *POFFSETVIEWPORTORG16;

typedef struct _OFFSETWINDOWORG16 {     /* g15 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETWINDOWORG16;
typedef OFFSETWINDOWORG16 UNALIGNED *POFFSETWINDOWORG16;

typedef struct _PAINTRGN16 {            /* g43 */
    HRGN16 f2;
    HDC16 f1;
} PAINTRGN16;
typedef PAINTRGN16 UNALIGNED *PPAINTRGN16;

typedef struct _PATBLT16 {          /* g29 */
    DWORD dwRop;
    SHORT nHeight;
    SHORT nWidth;
    SHORT y;
    SHORT x;
    HDC16 hdc;
} PATBLT16;
typedef PATBLT16 UNALIGNED *PPATBLT16;

typedef struct _PIE16 {             /* g26 */
    SHORT f9;
    SHORT f8;
    SHORT f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} PIE16;
typedef PIE16 UNALIGNED *PPIE16;

typedef struct _PLAYMETAFILE16 {        /* g123 */
    HAND16 f2;
    HDC16 f1;
} PLAYMETAFILE16;
typedef PLAYMETAFILE16 UNALIGNED *PPLAYMETAFILE16;

typedef struct _PLAYMETAFILERECORD16 {      /* g176 */
    WORD f4;
    VPMETARECORD16 f3;
    VPHANDLETABLE16 f2;
    HDC16 f1;
} PLAYMETAFILERECORD16;
typedef PLAYMETAFILERECORD16 UNALIGNED *PPLAYMETAFILERECORD16;

typedef struct _POLYGON16 {         /* g36 */
    SHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} POLYGON16;
typedef POLYGON16 UNALIGNED *PPOLYGON16;

typedef struct _POLYLINE16 {            /* g37 */
    SHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} POLYLINE16;
typedef POLYLINE16 UNALIGNED *PPOLYLINE16;

typedef struct _POLYPOLYGON16 {         /* g450 */
    SHORT f4;
    VPSHORT f3;
    VPPOINT16 f2;
    HDC16 f1;
} POLYPOLYGON16;
typedef POLYPOLYGON16 UNALIGNED *PPOLYPOLYGON16;

typedef struct _POLYPOLYLINEWOW16 {     /* g487 */
    DWORD f4;
    VPDWORD f3;
    VPDWORD f2;
    HDC16 f1;
} POLYPOLYLINEWOW16;
typedef POLYPOLYLINEWOW16 UNALIGNED *PPOLYPOLYLINEWOW16;

typedef struct _PTINREGION16 {          /* g161 */
    SHORT f3;
    SHORT f2;
    HRGN16 f1;
} PTINREGION16;
typedef PTINREGION16 UNALIGNED *PPTINREGION16;

typedef struct _PTVISIBLE16 {           /* g103 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} PTVISIBLE16;
typedef PTVISIBLE16 UNALIGNED *PPTVISIBLE16;

typedef struct _RECTANGLE16 {           /* g27 */
    SHORT y2;
    SHORT x2;
    SHORT y1;
    SHORT x1;
    HDC16 hdc;
} RECTANGLE16;
typedef RECTANGLE16 UNALIGNED *PRECTANGLE16;

typedef struct _RECTINREGION16 {        /* g181 */
    VPRECT16 f2;
    HRGN16 f1;
} RECTINREGION16;
typedef RECTINREGION16 UNALIGNED *PRECTINREGION16;

typedef struct _RECTVISIBLE16 {         /* g104 */
    VPRECT16 f2;
    HDC16 f1;
} RECTVISIBLE16;
typedef RECTVISIBLE16 UNALIGNED *PRECTVISIBLE16;

typedef struct _REMOVEFONTRESOURCE16 {      /* g136 */
    VPSTR f1;
} REMOVEFONTRESOURCE16;
typedef REMOVEFONTRESOURCE16 UNALIGNED *PREMOVEFONTRESOURCE16;

typedef struct _RESIZEPALETTE16 {       /* g368 */
    WORD f2;
    HPAL16 f1;
} RESIZEPALETTE16;
typedef RESIZEPALETTE16 UNALIGNED *PRESIZEPALETTE16;

typedef struct _RESTOREDC16 {           /* g39 */
    SHORT f2;
    HDC16 f1;
} RESTOREDC16;
typedef RESTOREDC16 UNALIGNED *PRESTOREDC16;

typedef struct _ROUNDRECT16 {           /* g28 */
    SHORT f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} ROUNDRECT16;
typedef ROUNDRECT16 UNALIGNED *PROUNDRECT16;

typedef struct _SAVEDC16 {          /* g30 */
    HDC16 f1;
} SAVEDC16;
typedef SAVEDC16 UNALIGNED *PSAVEDC16;

typedef struct _SCALEVIEWPORTEXT16 {        /* g18 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCALEVIEWPORTEXT16;
typedef SCALEVIEWPORTEXT16 UNALIGNED *PSCALEVIEWPORTEXT16;

typedef struct _SCALEWINDOWEXT16 {      /* g16 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCALEWINDOWEXT16;
typedef SCALEWINDOWEXT16 UNALIGNED *PSCALEWINDOWEXT16;

typedef struct _SELECTCLIPRGN16 {       /* g44 */
    HRGN16 f2;
    HDC16 f1;
} SELECTCLIPRGN16;
typedef SELECTCLIPRGN16 UNALIGNED *PSELECTCLIPRGN16;

typedef struct _SELECTOBJECT16 {        /* g45 */
    HAND16 f2;
    HDC16 f1;
} SELECTOBJECT16;
typedef SELECTOBJECT16 UNALIGNED *PSELECTOBJECT16;

typedef struct _SETBITMAPBITS16 {       /* g106 */
    VPSTR f3;
    DWORD f2;
    HBM16 f1;
} SETBITMAPBITS16;
typedef SETBITMAPBITS16 UNALIGNED *PSETBITMAPBITS16;

typedef struct _SETBITMAPDIMENSION16 {      /* g163 */
    SHORT f3;
    SHORT f2;
    HBM16 f1;
} SETBITMAPDIMENSION16;
typedef SETBITMAPDIMENSION16 UNALIGNED *PSETBITMAPDIMENSION16;

typedef struct _SETBKCOLOR16 {          /* g1 */
    DWORD f2;
    HDC16 f1;
} SETBKCOLOR16;
typedef SETBKCOLOR16 UNALIGNED *PSETBKCOLOR16;

typedef struct _SETBKMODE16 {           /* g2 */
    SHORT f2;
    HDC16 f1;
} SETBKMODE16;
typedef SETBKMODE16 UNALIGNED *PSETBKMODE16;

typedef struct _SETBRUSHORG16 {         /* g148 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETBRUSHORG16;
typedef SETBRUSHORG16 UNALIGNED *PSETBRUSHORG16;

typedef struct _SETDIBITS16 {           /* g440 */
    WORD f7;
    VPBITMAPINFO16 f6;
    VPSTR f5;
    WORD f4;
    WORD f3;
    HAND16 f2;
    HDC16 f1;
} SETDIBITS16;
typedef SETDIBITS16 UNALIGNED *PSETDIBITS16;

typedef struct _SETDIBITSTODEVICE16 {       /* g443 */
    WORD f12;
    VPBITMAPINFO16 f11;
    VPSTR f10;
    WORD f9;
    WORD f8;
    WORD f7;
    WORD f6;
    WORD f5;
    WORD f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} SETDIBITSTODEVICE16;
typedef SETDIBITSTODEVICE16 UNALIGNED *PSETDIBITSTODEVICE16;

typedef struct _SETENVIRONMENT16 {      /* g132 */
    WORD f3;
    VPSTR f2;
    VPSTR f1;
} SETENVIRONMENT16;
typedef SETENVIRONMENT16 UNALIGNED *PSETENVIRONMENT16;

typedef struct _SETMAPMODE16 {          /* g3 */
    SHORT f2;
    HDC16 f1;
} SETMAPMODE16;
typedef SETMAPMODE16 UNALIGNED *PSETMAPMODE16;

typedef struct _SETMAPPERFLAGS16 {      /* g349 */
    DWORD f2;
    HDC16 f1;
} SETMAPPERFLAGS16;
typedef SETMAPPERFLAGS16 UNALIGNED *PSETMAPPERFLAGS16;

typedef struct _SETMETAFILEBITS16 {     /* g160 */
    HAND16 f1;
} SETMETAFILEBITS16;
typedef SETMETAFILEBITS16 UNALIGNED *PSETMETAFILEBITS16;

typedef struct _SETPALETTEENTRIES16 {       /* g364 */
    VPPALETTEENTRY16 f4;
    WORD f3;
    WORD f2;
    HPAL16 f1;
} SETPALETTEENTRIES16;
typedef SETPALETTEENTRIES16 UNALIGNED *PSETPALETTEENTRIES16;

typedef struct _SETPIXEL16 {            /* g31 */
    DWORD f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETPIXEL16;
typedef SETPIXEL16 UNALIGNED *PSETPIXEL16;

typedef struct _SETPOLYFILLMODE16 {     /* g6 */
    SHORT f2;
    HDC16 f1;
} SETPOLYFILLMODE16;
typedef SETPOLYFILLMODE16 UNALIGNED *PSETPOLYFILLMODE16;

typedef struct _SETRECTRGN16 {          /* g172 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HRGN16 f1;
} SETRECTRGN16;
typedef SETRECTRGN16 UNALIGNED *PSETRECTRGN16;

typedef struct _SETROP216 {         /* g4 */
    SHORT f2;
    HDC16 f1;
} SETROP216;
typedef SETROP216 UNALIGNED *PSETROP216;

typedef struct _SETSTRETCHBLTMODE16 {       /* g7 */
    SHORT f2;
    HDC16 f1;
} SETSTRETCHBLTMODE16;
typedef SETSTRETCHBLTMODE16 UNALIGNED *PSETSTRETCHBLTMODE16;

typedef struct _SETSYSTEMPALETTEUSE16 {     /* g373 */
    WORD f2;
    HDC16 f1;
} SETSYSTEMPALETTEUSE16;
typedef SETSYSTEMPALETTEUSE16 UNALIGNED *PSETSYSTEMPALETTEUSE16;

typedef struct _SETTEXTALIGN16 {        /* g346 */
    WORD f2;
    HDC16 f1;
} SETTEXTALIGN16;
typedef SETTEXTALIGN16 UNALIGNED *PSETTEXTALIGN16;

typedef struct _SETTEXTCHARACTEREXTRA16 {   /* g8 */
    SHORT f2;
    HDC16 f1;
} SETTEXTCHARACTEREXTRA16;
typedef SETTEXTCHARACTEREXTRA16 UNALIGNED *PSETTEXTCHARACTEREXTRA16;

typedef struct _SETTEXTCOLOR16 {        /* g9 */
    DWORD f2;
    HDC16 f1;
} SETTEXTCOLOR16;
typedef SETTEXTCOLOR16 UNALIGNED *PSETTEXTCOLOR16;

typedef struct _SETTEXTJUSTIFICATION16 {    /* g10 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETTEXTJUSTIFICATION16;
typedef SETTEXTJUSTIFICATION16 UNALIGNED *PSETTEXTJUSTIFICATION16;

typedef struct _SETVIEWPORTEXT16 {      /* g14 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETVIEWPORTEXT16;
typedef SETVIEWPORTEXT16 UNALIGNED *PSETVIEWPORTEXT16;

typedef struct _SETVIEWPORTORG16 {      /* g13 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETVIEWPORTORG16;
typedef SETVIEWPORTORG16 UNALIGNED *PSETVIEWPORTORG16;

typedef struct _SETWINDOWEXT16 {        /* g12 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETWINDOWEXT16;
typedef SETWINDOWEXT16 UNALIGNED *PSETWINDOWEXT16;

typedef struct _SETWINDOWORG16 {        /* g11 */
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETWINDOWORG16;
typedef SETWINDOWORG16 UNALIGNED *PSETWINDOWORG16;

#ifdef NULLSTRUCT
typedef struct _SHRINKGDIHEAP16 {        /* g354 */
} SHRINKGDIHEAP16;
typedef SHRINKGDIHEAP16 UNALIGNED *PSHRINKGDIHEAP16;
#endif

typedef struct _STRETCHBLT16 {          /* g35 */
    DWORD f11;
    SHORT f10;
    SHORT f9;
    SHORT f8;
    SHORT f7;
    HDC16 f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} STRETCHBLT16;
typedef STRETCHBLT16 UNALIGNED *PSTRETCHBLT16;

typedef struct _STRETCHDIBITS16 {       /* g439 */
    DWORD f13;
    WORD f12;
    VPBITMAPINFO16 f11;
    VPSTR f10;
    WORD f9;
    WORD f8;
    WORD f7;
    WORD f6;
    WORD f5;
    WORD f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} STRETCHDIBITS16;
typedef STRETCHDIBITS16 UNALIGNED *PSTRETCHDIBITS16;

typedef struct _TEXTOUT16 {         /* g33 */
    SHORT f5;
    VPSTR f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} TEXTOUT16;
typedef TEXTOUT16 UNALIGNED *PTEXTOUT16;

typedef struct _UNREALIZEOBJECT16 {     /* g150 */
    HBRSH16 f1;
} UNREALIZEOBJECT16;
typedef UNREALIZEOBJECT16 UNALIGNED *PUNREALIZEOBJECT16;

typedef struct _UPDATECOLORS16 {        /* g366 */
    HDC16 f1;
} UPDATECOLORS16;
typedef UPDATECOLORS16 UNALIGNED *PUPDATECOLORS16;

// These are new functions for win 31

typedef struct _ABORTDOC16 {            /* g382 */
    HDC16 f1;
} ABORTDOC16;
typedef ABORTDOC16 UNALIGNED *PABORTDOC16;

typedef struct _CREATESCALABLEFONTRESOURCE16 {  /* g510 */
    VPSZ f4;
    VPSZ f3;
    VPSZ f2;
    WORD  f1;
} CREATESCALABLEFONTRESOURCE16;
typedef CREATESCALABLEFONTRESOURCE16 UNALIGNED *PCREATESCALABLEFONTRESOURCE16;

typedef struct _ENDDOC16 {          /* g378 */
    HDC16 f1;
} ENDDOC16;
typedef ENDDOC16 UNALIGNED *PENDDOC16;

typedef struct _ENDPAGE16 {         /* g380 */
    HDC16 f1;
} ENDPAGE16;
typedef ENDPAGE16 UNALIGNED *PENDPAGE16;

typedef struct _ENUMFONTFAMILIES16 {        /* g330 */
    VPBYTE f4;
    VPPROC f3;
    VPSZ f2;
    HDC16 f1;
} ENUMFONTFAMILIES16;
typedef ENUMFONTFAMILIES16 UNALIGNED *PENUMFONTFAMILIES16;

typedef struct _GETBITMAPDIMENSIONEX16 {            /* g468 */
    VPVOID f2;
    WORD f1;
} GETBITMAPDIMENSIONEX16;
typedef GETBITMAPDIMENSIONEX16 UNALIGNED *PGETBITMAPDIMENSIONEX16;

typedef struct _GETBOUNDSRECT16 {           /* g194 */
    WORD f3;
    VPRECT16 f2;
    HDC16 f1;
} GETBOUNDSRECT16;
typedef GETBOUNDSRECT16 UNALIGNED *PGETBOUNDSRECT16;

typedef struct _GETBRUSHORGEX16 {           /* g469 */
    VPPOINT16 f2;
    HDC16 f1;
} GETBRUSHORGEX16;
typedef GETBRUSHORGEX16 UNALIGNED *PGETBRUSHORGEX16;

typedef struct _GETCHARABCWIDTHS16 {        /* g307 */
    VPVOID f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} GETCHARABCWIDTHS16;
typedef GETCHARABCWIDTHS16 UNALIGNED *PGETCHARABCWIDTHS16;

typedef struct _GETCURRENTPOSITIONEX16 {            /* g470 */
    VPPOINT16 f2;
    HDC16 f1;
} GETCURRENTPOSITIONEX16;
typedef GETCURRENTPOSITIONEX16 UNALIGNED *PGETCURRENTPOSITIONEX16;

typedef struct _GETFONTDATA16 {     /* g311 */
    DWORD f5;
    VPVOID f4;
    DWORD f3;
    DWORD f2;
    HDC16 f1;
} GETFONTDATA16;
typedef GETFONTDATA16 UNALIGNED *PGETFONTDATA16;

typedef struct _GETGLYPHOUTLINE16 {     /* g309 */
    VPVOID f7;
    VPVOID f6;
    DWORD f5;
    VPVOID f4;
    WORD f3;
    WORD f2;
    HDC16 f1;
} GETGLYPHOUTLINE16;
typedef GETGLYPHOUTLINE16 UNALIGNED *PGETGLYPHOUTLINE16;

typedef struct _GETOULTLINETEXTMETRICS16 {  /* g1000 */
    VPVOID f3;
    WORD f2;
    HDC16 f1;
} GETOULTLINETEXTMETRICS16;
typedef GETOULTLINETEXTMETRICS16 UNALIGNED *PGETOULTLINETEXTMETRICS16;

typedef struct _GETRASTERIZERCAPS16 {   /* g313 */
    SHORT f2;
    VPVOID f1;
} GETRASTERIZERCAPS16;
typedef GETRASTERIZERCAPS16 UNALIGNED *PGETRASTERIZERCAPS16;

typedef struct _GETTEXTEXTENTPOINT16 {      /* gxx */
    VPVOID f4;
    SHORT f3;
    VPSZ f2;
    HDC16 f1;
} GETTEXTEXTENTPOINT16;
typedef GETTEXTEXTENTPOINT16 UNALIGNED *PGETTEXTEXTENTPOINT16;

typedef struct _GETVIEWPORTEXTEX16 {        /* g472 */
    VPVOID f2;
    HDC16 f1;
} GETVIEWPORTEXTEX16;
typedef GETVIEWPORTEXTEX16 UNALIGNED *PGETVIEWPORTEXTEX16;

typedef struct _GETVIEWPORTORGEX16 {        /* g473 */
    VPPOINT16 f2;
    HDC16 f1;
} GETVIEWPORTORGEX16;
typedef GETVIEWPORTORGEX16 UNALIGNED *PGETVIEWPORTORGEX16;

typedef struct _GETWINDOWEXTEX16 {      /* g474 */
    VPVOID f2;
    HDC16 f1;
} GETWINDOWEXTEX16;
typedef GETWINDOWEXTEX16 UNALIGNED *PGETWINDOWEXTEX16;

typedef struct _GETWINDOWORGEX16 {      /* g475 */
    VPPOINT16 f2;
    HDC16 f1;
} GETWINDOWORGEX16;
typedef GETWINDOWORGEX16 UNALIGNED *PGETWINDOWORGEX16;

typedef struct _ISGDIOBJECT16 {     /* g462 */
    WORD f1;
} ISGDIOBJECT16;
typedef ISGDIOBJECT16 UNALIGNED *PISGDIOBJECT16;

typedef struct _MOVETOEX16 {        /* g483 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} MOVETOEX16;
typedef MOVETOEX16 UNALIGNED *PMOVETOEX16;

typedef struct _OFFSETVIEWPORTORGEX16 {     /* g476 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETVIEWPORTORGEX16;
typedef OFFSETVIEWPORTORGEX16 UNALIGNED *POFFSETVIEWPORTORGEX16;

typedef struct _OFFSETWINDOWORGEX16 {       /* g477 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} OFFSETWINDOWORGEX16;
typedef OFFSETWINDOWORGEX16 UNALIGNED *POFFSETWINDOWORGEX16;

typedef struct _QUERTABORT16 {      /* gxxx */
    SHORT f2;
    HDC16 f1;
} QUERTABORT16;
typedef QUERTABORT16 UNALIGNED *PQUERTABORT16;

typedef struct _RESETDC16 {     /* g376 */
    VPVOID f2;
    HDC16 f1;
} RESETDC16;
typedef RESETDC16 UNALIGNED *PRESETDC16;

typedef struct _SCALEVIEWPORTEXTEX16 {      /* g484 */
    VPVOID f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCALEVIEWPORTEXTEX16;
typedef SCALEVIEWPORTEXTEX16 UNALIGNED *PSCALEVIEWPORTEXTEX16;

typedef struct _SCALEWINDOWEXTEX16 {        /* g485 */
    VPVOID f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCALEWINDOWEXTEX16;
typedef SCALEWINDOWEXTEX16 UNALIGNED *PSCALEWINDOWEXTEX16;

typedef struct _SETABORTPROC16 {        /* g381 */
    VPVOID f2;
    HDC16 f1;
} SETABORTPROC16;
typedef SETABORTPROC16 UNALIGNED *PSETABORTPROC16;

typedef struct _SETBITMAPDIMENSIONEX16 {        /* g478 */
    VPVOID f4;
    SHORT f3;
    SHORT f2;
    WORD f1;
} SETBITMAPDIMENSIONEX16;
typedef SETBITMAPDIMENSIONEX16 UNALIGNED *PSETBITMAPDIMENSIONEX16;

typedef struct _SETBOUNDSRECT16 {       /* g193 */
    WORD f3;
    VPRECT16 f2;
    HDC16 f1;
} SETBOUNDSRECT16;
typedef SETBOUNDSRECT16 UNALIGNED *PSETBOUNDSRECT16;

typedef struct _SETMETAFILEBITSBETTER16 {       /* g196 */
    WORD f1;
} SETMETAFILEBITSBETTER16;
typedef SETMETAFILEBITSBETTER16 UNALIGNED *PSETMETAFILEBITSBETTER16;

typedef struct _SETVIEWPORTEXTEX16 {        /* g479 */
    VPVOID f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETVIEWPORTEXTEX16;
typedef SETVIEWPORTEXTEX16 UNALIGNED *PSETVIEWPORTEXTEX16;

typedef struct _SETVIEWPORTORGEX16 {        /* g480 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETVIEWPORTORGEX16;
typedef SETVIEWPORTORGEX16 UNALIGNED *PSETVIEWPORTORGEX16;

typedef struct _SETWINDOWEXTEX16 {      /* g481 */
    VPVOID f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETWINDOWEXTEX16;
typedef SETWINDOWEXTEX16 UNALIGNED *PSETWINDOWEXTEX16;

typedef struct _SETWINDOWORGEX16 {      /* g482 */
    VPPOINT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SETWINDOWORGEX16;
typedef SETWINDOWORGEX16 UNALIGNED *PSETWINDOWORGEX16;

typedef struct _SPOOLFILE16 {       /* g254 */
    VPSZ f4;
    VPSZ f3;
    VPSZ f2;
    VPSZ f1;
} SPOOLFILE16;
typedef SPOOLFILE16 UNALIGNED *PSPOOLFILE16;

typedef struct _STARTDOC16 {        /* g377 */
    VPVOID f2;
    HDC16 f1;
} STARTDOC16;
typedef STARTDOC16 UNALIGNED *PSTARTDOC16;

typedef struct _STARTPAGE16 {       /* g379 */
    HDC16 f1;
} STARTPAGE16;
typedef STARTPAGE16 UNALIGNED *PSTARTPAGE16;

typedef struct _GETOUTLINETEXTMETRICS16 {       /* g308 */
    VPVOID f3;
    WORD f2;
    HDC16 f1;
} GETOUTLINETEXTMETRICS16;
typedef GETOUTLINETEXTMETRICS16 UNALIGNED *PGETOUTLINETEXTMETRICS16;

typedef struct _DOCINFO16 {                    /* di16wow32 */
    SHORT   cbSize;
    VPSZ    lpszDocName;
    VPSZ    lpszOutput;
} DOCINFO16;
typedef DOCINFO16 UNALIGNED *LPDOCINFO16;

typedef struct _SIZE16 {                       /* sz16wow32 */
    SHORT   cx;
    SHORT   cy;
} SIZE16;
typedef SIZE16 UNALIGNED *PSIZE16;
typedef VPVOID VPSIZE16;

typedef struct _INQUIREVISRGN16 {       /* g131 */
    HDC16 f1;
}INQUIREVISRGN16;
typedef INQUIREVISRGN16 UNALIGNED *PINQUIREVISRGN16;

typedef struct _GETCLIPRGN16 {       /* g173 */
    HDC16   f1;
}GETCLIPRGN16;
typedef GETCLIPRGN16 UNALIGNED *PGETCLIPRGN16;


typedef struct _OPENJOB16 {  /* g240 */
    WORD    f3;
    VPSZ    f2;
    VPSZ    f1;
} OPENJOB16;
typedef OPENJOB16 UNALIGNED *POPENJOB16;

typedef struct _STARTSPOOLPAGE16 {  /* g246 */
    HAND16 f1;
} STARTSPOOLPAGE16;
typedef STARTSPOOLPAGE16 UNALIGNED *PSTARTSPOOLPAGE16;

typedef struct _ENDSPOOLPAGE16 {  /* g247 */
    HAND16 f1;
} ENDSPOOLPAGE16;
typedef ENDSPOOLPAGE16 UNALIGNED *PENDSPOOLPAGE16;

typedef struct _CLOSEJOB16 {  /* g243 */
    HAND16 f1;
} CLOSEJOB16;
typedef CLOSEJOB16 UNALIGNED *PCLOSEJOB16;

typedef struct _WRITESPOOL16 {  /* g241 */
    WORD    f3;
    VPSZ    f2;
    HAND16  f1;
} WRITESPOOL16;
typedef WRITESPOOL16 UNALIGNED *PWRITESPOOL16;

typedef struct _DELETEJOB16 {  /* g244 */
    WORD    f2;
    HAND16  f1;
} DELETEJOB16;
typedef DELETEJOB16 UNALIGNED *PDELETEJOB16;

typedef struct _WRITEDIALOG16 {  /* g242 */
    WORD    f3;
    VPSZ    f2;
    HAND16  f1;
} WRITEDIALOG16;
typedef WRITEDIALOG16 UNALIGNED *PWRITEDIALOG16;

#ifdef FE_SB
// GetFontAssocStatus @488->459 for Taiwan, Prc and Korea
typedef struct _GETFONTASSOCSTATUS16 {          /* g459 */
    HDC16 f1;
} GETFONTASSOCSTATUS16;
typedef GETFONTASSOCSTATUS16 UNALIGNED *PGETFONTASSOCSTATUS16;
#endif  // FE_SB

typedef struct _DMBITBLT16 {  /* g201 */
    VPSZ    pdrawmode;
    VPSZ    pbrush;
    LONG    rop;
    WORD    exty;
    WORD    extx;
    WORD    srcy;
    WORD    srcx;
    VPSZ    pbitmapsrc;
    WORD    desty;
    WORD    destx;
    VPSZ    pbitmapdest;
} DMBITBLT16;
typedef DMBITBLT16 UNALIGNED *PDMBITBLT16;

typedef struct _GETCURLOGFONT16 {        /* g411 */
    HAND16 hDC;
} GETCURLOGFONT16;
typedef GETCURLOGFONT16 UNALIGNED *PGETCURLOGFONT16;


/* New for NT 5.0 Win95 compatibility */


typedef struct _ABORTPATH16 {        /* g511 */
    HDC16 hdc;
} ABORTPATH16;
typedef ABORTPATH16 UNALIGNED *PABORTPATH16;

typedef struct _ABORTPRINTER16 {        /* g271 */
    DWORD hPrinter;
} ABORTPRINTER16;
typedef ABORTPRINTER16 UNALIGNED *PABORTPRINTER16;

typedef struct _ADDLPKTOGDI16 {        /* g614 */
    WORD  iCharset;
    WORD  hlibLPK;
} ADDLPKTOGDI16;
typedef ADDLPKTOGDI16 UNALIGNED *PADDLPKTOGDI16;

typedef struct _BEGINPATH16 {        /* g512 */
    HDC16 hdc;
} BEGINPATH16;
typedef BEGINPATH16 UNALIGNED *PBEGINPATH16;

typedef struct _BUILDINVERSETABLEDIB16 {        /* g617 */
    DWORD  dwUniqueID;
    VPVOID lpbi;
} BUILDINVERSETABLEDIB16;
typedef BUILDINVERSETABLEDIB16 UNALIGNED *PBUILDINVERSETABLEDIB16;

typedef struct _CLOSEENHMETAFILE16 {        /* g490 */
    HDC16 hdc;
} CLOSEENHMETAFILE16;
typedef CLOSEENHMETAFILE16 UNALIGNED *PCLOSEENHMETAFILE16;

typedef struct _CLOSEFIGURE16 {        /* g513 */
    HDC16 hdc;
} CLOSEFIGURE16;
typedef CLOSEFIGURE16 UNALIGNED *PCLOSEFIGURE16;

typedef struct _CLOSEPRINTER16 {        /* g274 */
    DWORD  hPrinter;
} CLOSEPRINTER16;
typedef CLOSEPRINTER16 UNALIGNED *PCLOSEPRINTER16;

typedef struct _COPYENHMETAFILE16 {        /* g491 */
    VPSTR   lpszFile;
    HAND16  hemfSrc;
} COPYENHMETAFILE16;
typedef COPYENHMETAFILE16 UNALIGNED *PCOPYENHMETAFILE16;

typedef struct _CREATEENHMETAFILE16 {        /* g492 */
    VPSTR     lpszDescription;
    VPRECTL16 lprclFrame;
    VPSTR     lpszFile;
    HDC16     hdcRef;
} CREATEENHMETAFILE16;
typedef CREATEENHMETAFILE16 UNALIGNED *PCREATEENHMETAFILE16;

typedef struct _CREATEHALFTONEPALETTE16 {        /* g529 */
    HDC16 hdc;
} CREATEHALFTONEPALETTE16;
typedef CREATEHALFTONEPALETTE16 UNALIGNED *PCREATEHALFTONEPALETTE16;

typedef struct _DELETEENHMETAFILE16 {        /* g493 */
    HAND16 hemf;
} DELETEENHMETAFILE16;
typedef DELETEENHMETAFILE16 UNALIGNED *PDELETEENHMETAFILE16;

typedef struct _DRVGETPRINTERDATA16 {        /* g282 */
    VPDWORD   lpdwNeeded;
    DWORD     cbData;
    VPBYTE    lpData;
    VPDWORD   lpdwType;
    VPSTR     lpszValueName;
    VPSTR     lpszPrinter;
} DRVGETPRINTERDATA16;
typedef DRVGETPRINTERDATA16 UNALIGNED *PDRVGETPRINTERDATA16;

typedef struct _DRVSETPRINTERDATA16 {        /* g281 */
    DWORD     cbData;
    VPBYTE    lpData;
    VPDWORD   lpdwType;
    VPSTR     lpszValueName;
    VPSTR     lpszPrinter;
} DRVSETPRINTERDATA16;
typedef DRVSETPRINTERDATA16 UNALIGNED *PDRVSETPRINTERDATA16;

typedef struct _ENDDOCPRINTER16 {        /* g272 */
    DWORD     hPrinter;
} ENDDOCPRINTER16;
typedef ENDDOCPRINTER16 UNALIGNED *PENDDOCPRINTER16;

typedef struct _ENDPAGEPRINTER16 {        /* g270 */
    DWORD     hPrinter;
} ENDPAGEPRINTER16;
typedef ENDPAGEPRINTER16 UNALIGNED *PENDPAGEPRINTER16;

typedef struct _ENDPATH16 {        /* g514 */
    HDC16 hdc;
} ENDPATH16;
typedef ENDPATH16 UNALIGNED *PENDPATH16;

typedef struct _ENGINEGETCHARWIDTHEX16 {        /* g299 */
    VPWORD    lpwWidths;
    WORD      nLast;
    WORD      nFirst;
    VPVOID    lpEFont;
} ENGINEGETCHARWIDTHEX16;
typedef ENGINEGETCHARWIDTHEX16 UNALIGNED *PENGINEGETCHARWIDTHEX16;

typedef struct _ENGINEGETCHARWIDTHSTR16 {        /* g316 */
    VPWORD    lpwWidths;
    WORD      wCount;
    VPSTR     lpGlyphs;
    VPVOID    lpEFont;
} ENGINEGETCHARWIDTHSTR16;
typedef ENGINEGETCHARWIDTHSTR16 UNALIGNED *PENGINEGETCHARWIDTHSTR16;

typedef struct _ENGINEGETGLYPHBMPEXT16 {        /* g305 */
    VPVOID    lpBmpMetrics;
    DWORD     dwSizeBmp;
    VPVOID    lpBitmap;
    WORD      wQueryType;
    WORD      wChar;
    VPVOID    lpEFont;
    HDC16     hdc;
} ENGINEGETGLYPHBMPEXT16;
typedef ENGINEGETGLYPHBMPEXT16 UNALIGNED *PENGINEGETGLYPHBMPEXT16;

typedef struct _ENGINEREALIZEFONTEXT16 {        /* g315 */
    WORD        wFlags;
    VPVOID      lpFont;
    VPVOID      lpTextTransform;
    VPLOGFONT16 lpLogFont;
    HDC16       hdc;
} ENGINEREALIZEFONTEXT16;
typedef ENGINEREALIZEFONTEXT16 UNALIGNED *PENGINEREALIZEFONTEXT16;

typedef struct _ENUMFONTFAMILIESEX16 {        /* g613 */
    DWORD       dwFlags;
    VPVOID      lpClientData;
    VPPROC      lpfnCallBack;
    VPLOGFONT16 lpLogFont;
    HDC16       hdc;
} ENUMFONTFAMILIESEX16;
typedef ENUMFONTFAMILIESEX16 UNALIGNED *PENUMFONTFAMILIESEX16;

typedef struct _EXTCREATEPEN16 {        /* g523 */
    VPVOID    lpStyle;
    DWORD     dwStyleCount;
    VPVOID    lpntlb;
    DWORD     dwWidth;
    DWORD     dwPenStyle;
} EXTCREATEPEN16;
typedef EXTCREATEPEN16 UNALIGNED *PEXTCREATEPEN16;

typedef struct _EXTCREATEREGION16 {        /* g608 */
    VPVOID    lpRgnData;
    DWORD     dwCount;
    VPBYTE    lpReserved;
} EXTCREATEREGION16;
typedef EXTCREATEREGION16 UNALIGNED *PEXTCREATEREGION16;

typedef struct _EXTSELECTCLIPRGN16 {        /* g508 */
    SHORT     iMode;
    HRGN16    hrgn;
    HDC16     hdc;
} EXTSELECTCLIPRGN16;
typedef EXTSELECTCLIPRGN16 UNALIGNED *PEXTSELECTCLIPRGN16;

typedef struct _FILLPATH16 {        /* g515 */
    HDC16  hdc;
} FILLPATH16;
typedef FILLPATH16 UNALIGNED *PFILLPATH16;

typedef struct _FLATTENPATH16 {        /* g516 */
    HDC16  hdc;
} FLATTENPATH16;
typedef FLATTENPATH16 UNALIGNED *PFLATTENPATH16;

typedef struct _GDICOMMENT16 {        /* g495 */
    VPBYTE  lpData;
    DWORD   cbSize;
    HDC16   hdc;
} GDICOMMENT16;
typedef GDICOMMENT16 UNALIGNED *PGDICOMMENT16;

typedef struct _GDIPARAMETERSINFO16 {        /* g528 */
    WORD   flags;
    VPVOID lParam;
    WORD   wParam;
    WORD   wFlag;
} GDIPARAMETERSINFO16;
typedef GDIPARAMETERSINFO16 UNALIGNED *PGDIPARAMETERSINFO16;

typedef struct _GDISIGNALPROC3216 {        /* g610 */
    WORD  hTask16;
    DWORD dwFlags;
    DWORD dwID;
    DWORD dwSignalID;
} GDISIGNALPROC3216;
typedef GDISIGNALPROC3216 UNALIGNED *PGDISIGNALPROC3216;

typedef struct _GETARCDIRECTION16 {        /* g524 */
    HDC16 hdc;
} GETARCDIRECTION16;
typedef GETARCDIRECTION16 UNALIGNED *PGETARCDIRECTION16;

typedef struct _GCP_RESULTS16                /* gcp_r */
{
    DWORD lStructSize;
    VPSTR lpOutString;
    VPSTR lpOrder;
    VPSTR lpDx;
    VPSTR lpCaretPos;
    VPSTR lpClass;
    VPSTR lpGlyphs;
    SHORT nGlyphs;
    SHORT nMaxFit;
} GCP_RESULTS16;
typedef GCP_RESULTS16 UNALIGNED *PGCP_RESULTS16;

typedef struct _GETCHARACTERPLACEMENT16 {        /* g615 */
    DWORD  dwFlags;
    VPVOID lpResults;
    WORD   wMaxExtent;
    WORD   wCount;
    VPSTR  lpszText;
    HDC16  hdc;
} GETCHARACTERPLACEMENT16;
typedef GETCHARACTERPLACEMENT16 UNALIGNED *PGETCHARACTERPLACEMENT16;

typedef struct _GETENHMETAFILE16 {        /* g496 */
    VPSTR lpszFile;
} GETENHMETAFILE16;
typedef GETENHMETAFILE16 UNALIGNED *PGETENHMETAFILE16;

typedef struct _GETENHMETAFILEBITS16 {        /* g497 */
    VPBYTE  lpBuffer;
    DWORD   cbBuffer;
    HAND16  hemf;
} GETENHMETAFILEBITS16;
typedef GETENHMETAFILEBITS16 UNALIGNED *PGETENHMETAFILEBITS16;

typedef struct _GETENHMETAFILEDESCRIPTION16 {        /* g498 */
    VPSTR   lpszBuffer;
    DWORD   cbBuffer;
    HAND16  hemf;
} GETENHMETAFILEDESCRIPTION16;
typedef GETENHMETAFILEDESCRIPTION16 UNALIGNED *PGETENHMETAFILEDESCRIPTION16;

typedef struct _GETENHMETAFILEHEADER16 {        /* g499 */
    VPVOID  lpmrmf;
    DWORD   cbBuffer;
    HAND16  hemf;
} GETENHMETAFILEHEADER16;
typedef GETENHMETAFILEHEADER16 UNALIGNED *PGETENHMETAFILEHEADER16;

typedef struct _GETENHMETAFILEPALETTEENTRIES16 {        /* g501 */
    VPVOID  lpclr;
    DWORD   cEntries;
    HAND16  hemf;
} GETENHMETAFILEPALETTEENTRIES16;
typedef GETENHMETAFILEPALETTEENTRIES16 UNALIGNED *PGETENHMETAFILEPALETTEENTRIES16;

typedef struct _GETFONTLANGUAGEINFO16 {        /* g616 */
    HDC16 hdc;
} GETFONTLANGUAGEINFO16;
typedef GETFONTLANGUAGEINFO16 UNALIGNED *PGETFONTLANGUAGEINFO16;

typedef struct _GETMITERLIMIT16 {        /* g526 */
    VPLONG lpMiter;
    HDC16  hdc;
} GETMITERLIMIT16;
typedef GETMITERLIMIT16 UNALIGNED *PGETMITERLIMIT16;

typedef struct _GETPATH16 {        /* g517 */
    LONG       cptl;
    VPBYTE     lpby;
    VPPOINTL16 lpptl;
    HDC16      hdc;
} GETPATH16;
typedef GETPATH16 UNALIGNED *PGETPATH16;

typedef struct _GETRANDOMRGN16 {        /* g611 */
    WORD     iType;
    HRGN16   hrgn;
    HDC16    hdc;
} GETRANDOMRGN16;
typedef GETRANDOMRGN16 UNALIGNED *PGETRANDOMRGN16;

typedef struct _GETREALDRIVERINFO16 {        /* g280 */
    VPSTR lpszDriverPath;
    VPSTR lpszDeviceName;
    VPSTR lpszPrinterName;
} GETREALDRIVERINFO16;
typedef GETREALDRIVERINFO16 UNALIGNED *PGETREALDRIVERINFO16;

typedef struct _GETREGIONDATA16 {        /* g607 */
    VPVOID  lpRgnData;
    DWORD   dwCount;
    HDC16   hrgn;
} GETREGIONDATA16;
typedef GETREGIONDATA16 UNALIGNED *PGETREGIONDATA16;

typedef struct _GETTEXTCHARSET16 {        /* g612 */
    HDC16  hdc;
} GETTEXTCHARSET16;
typedef GETTEXTCHARSET16 UNALIGNED *PGETTEXTCHARSET16;

typedef struct _GETTEXTEXTENTEX16 {        /* g188 */
    WORD    wFlags;
    VPWORD  lpDx;
    VPWORD  lpnFit;
    WORD    wMaxExtent;
    WORD    wCount;
    VPSTR   lpszString;
    HDC16   hdc;
} GETTEXTEXTENTEX16;
typedef GETTEXTEXTENTEX16 UNALIGNED *PGETTEXTEXTENTEX16;

typedef struct _GETTTGLYPHINDEXMAP16 {        /* g404 */
    VPVOID  lpEFont;
    WORD    wCharSet;
} GETTTGLYPHINDEXMAP16;
typedef GETTTGLYPHINDEXMAP16 UNALIGNED *PGETTTGLYPHINDEXMAP16;

typedef struct _ICMCHECKCOLORSINGAMUT16 {        /* g622 */
    DWORD  f4;
    VPBYTE f3;
    VPVOID lpRGBQuad;
    DWORD  hcmTransform;
} ICMCHECKCOLORSINGAMUT16;
typedef ICMCHECKCOLORSINGAMUT16 UNALIGNED *PICMCHECKCOLORSINGAMUT16;

typedef struct _ICMCREATETRANSFORM16 {        /* g618 */
    VPBYTE lpdevchar;
    VPBYTE lpdevcharacter;
    VPBYTE lplogcolorspace;
} ICMCREATETRANSFORM16;
typedef ICMCREATETRANSFORM16 UNALIGNED *PICMCREATETRANSFORM16;

typedef struct _ICMDELETETRANSFORM16 {        /* g619 */
    DWORD     huh;
    VPDWORD   lpColorRef;
    RGBQUAD16 rgbQuad;
    DWORD     hcmTransform;
} ICMDELETETRANSFORM16;
typedef ICMDELETETRANSFORM16 UNALIGNED *PICMDELETETRANSFORM16;

typedef struct _ICMTRANSLATERGB16 {        /* g620 */
    DWORD     huh;
    VPDWORD   lpColorRef;
    RGBQUAD16 rgbQuad;
    DWORD     hcmTransform;
} ICMTRANSLATERGB16;
typedef ICMTRANSLATERGB16 UNALIGNED *PICMTRANSLATERGB16;

typedef struct _ICMTRANSLATERGBS16 {        /* g621 */
    DWORD     flags;
    DWORD     destflags;
    VPVOID    lpdest;
    DWORD     nsrcwrap;
    DWORD     nsrcheight;
    DWORD     hsrcwidth;
    DWORD     srcflags;
    VPVOID    lpsrc;
} ICMTRANSLATERGBS16;
typedef ICMTRANSLATERGBS16 UNALIGNED *PICMTRANSLATERGBS16;

typedef struct _OPENPRINTERA16 {        /* g266 */
    VPVOID  lppd;
    VPDWORD hPrinter;
    VPSTR   lpszPrinter;
} OPENPRINTERA16;
typedef OPENPRINTERA16 UNALIGNED *POPENPRINTERA16;

typedef struct _PATHTOREGION16 {        /* g518 */
    HDC16 hdc;
} PATHTOREGION16;
typedef PATHTOREGION16 UNALIGNED *PPATHTOREGION16;

typedef struct _PLAYENHMETAFILERECORD16 {        /* g504 */
    DWORD   dwHandles;
    VPVOID  lpemr;
    VPVOID  lpht;
    HDC16   hdc;
} PLAYENHMETAFILERECORD16;
typedef PLAYENHMETAFILERECORD16 UNALIGNED *PPLAYENHMETAFILERECORD16;

typedef struct _POLYBEZIER16 {        /* g502 */
    SHORT     f3;
    VPPOINT16 f2;
    HDC16     f1;
} POLYBEZIER16;
typedef POLYBEZIER16 UNALIGNED *PPOLYBEZIER16;

typedef struct _POLYBEZIERTO16 {        /* g503 */
    SHORT     f3;
    VPPOINT16 f2;
    HDC16     f1;
} POLYBEZIERTO16;
typedef POLYBEZIERTO16 UNALIGNED *PPOLYBEZIERTO16;

typedef struct _SELECTCLIPPATH16 {        /* g519 */
    SHORT     iMode;
    HDC16     hdc;
} SELECTCLIPPATH16;
typedef SELECTCLIPPATH16 UNALIGNED *PSELECTCLIPPATH16;

typedef struct _SETARCDIRECTION16 {        /* g525 */
    SHORT     iArcDirection;
    HDC16     hdc;
} SETARCDIRECTION16;
typedef SETARCDIRECTION16 UNALIGNED *PSETARCDIRECTION16;

typedef struct _SETENHMETAFILEBITS16 {        /* g505 */
    VPBYTE  lpBuffer;
    DWORD   cbBuffer;
} SETENHMETAFILEBITS16;
typedef SETENHMETAFILEBITS16 UNALIGNED *PSETENHMETAFILEBITS16;

typedef struct _SETMAGICCOLORS16 {        /* g606 */
    WORD   iColor;
    DWORD  c1;
    HDC16  hdc;
} SETMAGICCOLORS16;
typedef SETMAGICCOLORS16 UNALIGNED *PSETMAGICCOLORS16;

typedef struct _SETMETARGN16 {        /* g506 */
    HDC16  hdc;
} SETMETARGN16;
typedef SETMETARGN16 UNALIGNED *PSETMETARGN16;

typedef struct _SETMITERLIMIT16 {        /* g527 */
    VPLONG  lpeMiter;
    LONG    eMiter;
    HDC16   hdc;
} SETMITERLIMIT16;
typedef SETMITERLIMIT16 UNALIGNED *PSETMITERLIMIT16;

typedef struct _SETSOLIDBRUSH16 {        /* g604 */
    DWORD   rgbNewColor;
    HAND16  hbrush;
} SETSOLIDBRUSH16;
typedef SETSOLIDBRUSH16 UNALIGNED *PSETSOLIDBRUSH16;

typedef struct _STARTDOCPRINTERA16 {        /* g267 */
    VPVOID  lpDocInfo;
    DWORD   dwLevel;
    DWORD   hPrinter;
} STARTDOCPRINTERA16;
typedef STARTDOCPRINTERA16 UNALIGNED *PSTARTDOCPRINTERA16;

typedef struct _STARTPAGEPRINTER16 {        /* g268 */
    DWORD   hPrinter;
} STARTPAGEPRINTER16;
typedef STARTPAGEPRINTER16 UNALIGNED *PSTARTPAGEPRINTER16;

typedef struct _STROKEANDFILLPATH16 {        /* g520 */
    HDC16 hdc;
} STROKEANDFILLPATH16;
typedef STROKEANDFILLPATH16 UNALIGNED *PSTROKEANDFILLPATH16;

typedef struct _STROKEPATH16 {        /* g521 */
    HDC16 hdc;
} STROKEPATH16;
typedef STROKEPATH16 UNALIGNED *PSTROKEPATH16;

typedef struct _SYSDELETEOBJECT16 {        /* g605 */
    HAND16 h;
} SYSDELETEOBJECT16;
typedef SYSDELETEOBJECT16 UNALIGNED *PSYSDELETEOBJECT16;

typedef struct _WIDENPATH16 {        /* g522 */
    HDC16 hdc;
} WIDENPATH16;
typedef WIDENPATH16 UNALIGNED *PWIDENPATH16;

typedef struct _WRITEPRINTER16 {        /* g269 */
    VPDWORD lpdwWritten;
    DWORD   cbBuf;
    VPVOID  lpBuf;
    DWORD   hPrinter;
} WRITEPRINTER16;
typedef WRITEPRINTER16 UNALIGNED *PWRITEPRINTER16;



/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowkbd.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWKBD.H
 *  16-bit Keyboard API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
--*/


/* Keyboard API IDs
 */
#define FUN_ANSITOOEM           5   //
#define FUN_ANSITOOEMBUFF       134 //
#define FUN_DISABLE         3   // Internal
#define FUN_ENABLE          2   // Internal
#define FUN_ENABLEKBSYSREQ      136 // Internal
#define FUN_GETKBCODEPAGE       132 //
#define FUN_GETKEYBOARDTYPE     130 //
#define FUN_GETKEYNAMETEXT      133 //
#define FUN_GETTABLESEG         126 // Internal
#define FUN_INQUIRE         1   // Internal
#define FUN_KEYBOARD_WEP        0   // Export by name
#define FUN_MAPVIRTUALKEY       131 //
#define FUN_NEWTABLE            127 // Internal
#define FUN_OEMKEYSCAN          128 //
#define FUN_OEMTOANSI           6   //
#define FUN_OEMTOANSIBUFF       135 //
#define FUN_SCREENSWITCHENABLE      100 // Internal
#define FUN_SETSPEED            7   // Internal
#define FUN_TOASCII         4   //
#define FUN_VKKEYSCAN           129 //
#define FUN_GETBIOSKEYPROC      137 //


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _ANSITOOEM16 {           /* kb5 */
    VPSTR f2;
    VPSTR f1;
} ANSITOOEM16;
typedef ANSITOOEM16 UNALIGNED *PANSITOOEM16;

typedef struct _ANSITOOEMBUFF16 {       /* kb134 */
    SHORT f3;
    VPSTR f2;
    VPSTR f1;
} ANSITOOEMBUFF16;
typedef ANSITOOEMBUFF16 UNALIGNED *PANSITOOEMBUFF16;

#ifdef NULLSTRUCT
typedef struct _GETKBCODEPAGE16 {       /* kb132 */
} GETKBCODEPAGE16;
typedef GETKBCODEPAGE16 UNALIGNED *PGETKBCODEPAGE16;
#endif

typedef struct _GETKEYBOARDTYPE16 {     /* kb130 */
    SHORT f1;
} GETKEYBOARDTYPE16;
typedef GETKEYBOARDTYPE16 UNALIGNED *PGETKEYBOARDTYPE16;

typedef struct _GETKEYNAMETEXT16 {      /* kb133 */
    SHORT f3;
    VPSTR f2;
    LONG f1;
} GETKEYNAMETEXT16;
typedef GETKEYNAMETEXT16 UNALIGNED *PGETKEYNAMETEXT16;

typedef struct _MAPVIRTUALKEY16 {       /* kb131 */
    WORD f2;
    WORD f1;
} MAPVIRTUALKEY16;
typedef MAPVIRTUALKEY16 UNALIGNED *PMAPVIRTUALKEY16;

typedef struct _OEMKEYSCAN16 {          /* kb128 */
    WORD f1;
} OEMKEYSCAN16;
typedef OEMKEYSCAN16 UNALIGNED *POEMKEYSCAN16;

typedef struct _OEMTOANSI16 {           /* kb6 */
    VPSTR f2;
    VPSTR f1;
} OEMTOANSI16;
typedef OEMTOANSI16 UNALIGNED *POEMTOANSI16;

typedef struct _OEMTOANSIBUFF16 {       /* kb135 */
    SHORT f3;
    VPSTR f2;
    VPSTR f1;
} OEMTOANSIBUFF16;
typedef OEMTOANSIBUFF16 UNALIGNED *POEMTOANSIBUFF16;

typedef struct _TOASCII16 {         /* kb4 */
    WORD f5;
    VPVOID f4;
    VPSTR f3;
    WORD f2;
    WORD f1;
} TOASCII16;
typedef TOASCII16 UNALIGNED *PTOASCII16;

typedef struct _VKKEYSCAN16 {           /* kb129 */
    WORD f1;
} VKKEYSCAN16;
typedef VKKEYSCAN16 UNALIGNED *PVKKEYSCAN16;

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowkrn.h ===
/*++ BUILD Version: 0002
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWKRN.H
 *  16-bit Kernel API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
 *  01-May-91 Matt Felton (mattfe) added Private Callback CHECKLOADMODULEDRV
--*/


/* Kernel API IDs -- loosely based on kernel export ordinals, attempting to keep the table size
 * down.
 */

#define FUN_FATALEXIT                    1   //
#define FUN_EXITKERNEL                   2   // Internal
#define FUN_WRITEOUTPROFILES             3   // really 315 export 3 GetVersion not thunked
#define FUN_MAPSL                        4   // really 357 export 4 LocalInit not thunked
#define FUN_MAPLS                        5   // really 358 export 5 LocalAlloc not thunked
#define FUN_UNMAPLS                      6   // really 359 export 6 LocalReAlloc not thunked
#define FUN_OPENFILEEX                   7   // really 360 export 7 LocalFree not thunked
#define FUN_FASTANDDIRTYGLOBALFIX        8   // really 365 export 8 LocalLock not thunked
#define FUN_WRITEPRIVATEPROFILESTRUCT    9   // really 406 export 9 LocalUnlock not thunked
#define FUN_GETPRIVATEPROFILESTRUCT      10  // really 407 export 10 LocalSize not thunked
#define FUN_GETCURRENTDIRECTORY          11  // really 411 export 11 LocalHandle not thunked
#define FUN_SETCURRENTDIRECTORY          12  // really 412 export 12 LocalFlags not thunked
#define FUN_FINDFIRSTFILE                13  // really 413 export 13 LocalCompact not thunked
#define FUN_FINDNEXTFILE                 14  // really 414 export 14 LocalNotify not thunked
#define FUN_FINDCLOSE                    15  // really 415 export 15 GlobalAlloc not thunked
#define FUN_WRITEPRIVATEPROFILESECTION   16  // really 416 export 16 GlobalReAlloc not thunked
#define FUN_WRITEPROFILESECTION          17  // really 417 export 17 GlobalFree not thunked
#define FUN_GETPRIVATEPROFILESECTION     18  // really 418 export 18 GlobalLock not thunked
#define FUN_GETPROFILESECTION            19  // really 419 export 19 GlobalUnlock not thunked
#define FUN_GETFILEATTRIBUTES            20  // really 420 export 20 GlobalSize not thunked
#define FUN_SETFILEATTRIBUTES            21  // really 421 export 21 GlobalHandle not thunked
#define FUN_GETDISKFREESPACE             22  // really 422 export 22 GlobalFlags not thunked
#define FUN_ISPEFORMAT                   23  // really 431 export 23 LockSegment not thunked
#define FUN_FILETIMETOLOCALFILETIME      24  // really 432 export 24 UnlockSegment not thunked
#define FUN_UNITOANSI                    25  // really 434 export 25 GlobalCompact not thunked
#define FUN_GETVDMPOINTER32W             26  // really 516 export 26 GlobalFreeAll not thunked
#define FUN_CREATETHREAD                 27  // really 441 export 27 GetModuleName not thunked
#define FUN_ICALLPROC32W                 28  // really 517 export 28 GlobalMasterHandle not thunked
#define FUN_YIELD                        29  //
#define FUN_WAITEVENT                    30  // Internal
#define FUN_POSTEVENT                    31  // Internal
#define FUN_SETPRIORITY                  32  // Internal
#define FUN_LOCKCURRENTTASK              33  // Internal
#define FUN_LEAVEENTERWIN16LOCK          34  // really 447 export 34 formerly SetTaskQueue
#define FUN_REGLOADKEY32                 35  // really 232 export 35 GetTaskQueue not thunked
#define FUN_REGUNLOADKEY32               36  // really 233 export 36 GetCurrentTask not thunked
#define FUN_REGSAVEKEY32                 37  // really 234 export 37 GetCurrentPDB not thunked
#define FUN_GETWIN16LOCK                 38  // really 449 export 38 formerly SetTaskSignalProc
#define FUN_LOADLIBRARY32                39  // really 452 export 39 formerly SetTaskSwitchProc
#define FUN_GETPROCADDRESS32             40  // really 453 export 40 formerly SetTaskInterchange
#define FUN_WOWFINDFIRST                 41  // WOW internal export 41 EnableDOS not thunked
#define FUN_WOWFINDNEXT                  42  // WOW internal export 42 DisableDOS not thunked
#define FUN_CREATEWIN32EVENT             43  // really 457 export 43 formerly IsScreenGrab
#define FUN_SETWIN32EVENT                44  // really 458 export 44 formerly BuildPDB
#define FUN_WOWLOADMODULE                45  // reusing LoadModule export, not thunked to wow32
#define FUN_RESETWIN32EVENT              46  // really 459 export 46 FreeModule not thunked
#define FUN_GETMODULEHANDLE              47  //
#define FUN_WAITFORSINGLEOBJECT          48  // really 460 export 48 GetModuleUsage not thunked
#define FUN_GETMODULEFILENAME            49  //
#define FUN_WAITFORMULTIPLEOBJECTS       50  // really 461 export 50 GetProcAddress not thunked
#define FUN_GETCURRENTTHREADID           51  // really 462 export 51 MakeProcInstance not thunked
#define FUN_SETTHREADQUEUE               52  // really 463 export 52 FreeProcInstance not thunked
#define FUN_CONVERTTOGLOBALHANDLE        53  // really 476 export 53 CallProcInstance not thunked
#define FUN_GETTHREADQUEUE               54  // really 464 export 54 GetInstanceData not thunked
#define FUN_NUKEPROCESS                  55  // really 465 export 55 Catch not thunked
#define FUN_EXITPROCESS                  56  // really 466 export 56 Throw not thunked
#define FUN_GETPROFILEINT                57  //
#define FUN_GETPROFILESTRING             58  //
#define FUN_WRITEPROFILESTRING           59  //
#define FUN_GETCURRENTPROCESSID          60  // really 471 export 60 FindResource not thunked
#define FUN_MAPHINSTLS                   61  // really 472 export 61 LoadResource not thunked
#define FUN_MAPHINSTSL                   62  // really 473 export 62 LockResource not thunked
#define FUN_CLOSEWIN32HANDLE             63  // really 474 export 63 FreeResource not thunked
#define FUN_LOADSYSTEMLIBRARY32          64  // really 482 export 64 AccessResource not thunked
#define FUN_FREELIBRARY32                65  // really 486 export 65 ...Resource not thunked
#define FUN_GETMODULEFILENAME32          66  // really 487 export 66 AllocResource not thunked
#define FUN_GETMODULEHANDLE32            67  // really 488 export 67 SetResourceHandler not thunked
#define FUN_REGISTERSERVICEPROCESS       68  // really 491 export 68 InitAtomTable not thunked
#define FUN_CHANGEALLOCFIXEDBEHAVIOUR    69  // really 501 export 69 FindAtom not thunked
#define FUN_INITCB                       70  // really 560 export 70 AddAtom not thunked
#define FUN_GETSTDCBLS                   71  // really 561 export 71 DeleteAtom not thunked
#define FUN_GETSTDCBSL                   72  // really 562 export 72 GetAtomName not thunked
#define FUN_GETEXISTINGSTDCBLS           73  // really 563 export 73 GetAtomHandle not thunked
#define FUN_GETEXISTINGSTDCBSL           74  // really 564 export 74 OpenFile not thunked
#define FUN_GETFLEXCBSL                  75  // really 566 export 75 OpenPathName not thunked
#define FUN_GETSTDCBLSEX                 76  // really 567 export 76 DeletePathName not thunked
#define FUN_GETSTDCBSLEX                 77  // really 568 export 77 AnsiNext not thunked
#define FUN_CALLBACK2                    78  // really 802 export 78 AnsiPrev not thunked
#define FUN_CALLBACK4                    79  // really 804 export 79 AnsiUpper not thunked
#define FUN_CALLBACK6                    80  // really 806 export 80 AnsiLower not thunked
#define FUN_CALLBACK8                    81  // really 808 export 81 _lclose not thunked
#define FUN_CALLBACK10                   82  // really 810 export 82 _lread not thunked
#define FUN_CALLBACK12                   83  // really 812 export 83 _lcreat not thunked
#define FUN_CALLBACK14                   84  // really 814 export 84 _lseek not thunked
#define FUN_CALLBACK16                   85  // really 816 export 85 _lopen not thunked
#define FUN_CALLBACK18                   86  // really 818 export 86 _lwrite not thunked
#define FUN_CALLBACK20                   87  // really 820 export 87 lstroriginal not thunked
#define FUN_CALLBACK22                   88  // really 822 export 88 lstrcpy not thunked
#define FUN_CALLBACK24                   89  // really 824 export 89 lstrcat not thunked
#define FUN_CALLBACK26                   90  // really 826 export 90 lstrlen not thunked
#define FUN_CALLBACK28                   91  // really 828 export 91 InitTask not thunked
#define FUN_CALLBACK30                   92  // really 830 export 92 GetTempDrive not thunked
#define FUN_CALLBACK32                   93  // really 832 export 93 GetCodeHandle not thunked
#define FUN_CALLBACK34                   94  // really 834 export 94 DefineHandleTable not thunked
#define FUN_CALLBACK36                   95  // really 836 export 95 LoadLibrary not thunked
#define FUN_CALLBACK38                   96  // really 838 export 96 FreeLibrary not thunked
#define FUN_CALLBACK40                   97  // really 840 export 97 GetTempFilename not thunked
#define FUN_CALLBACK42                   98  // really 842 export 98 GetLastDiskChange not thunked
#define FUN_CALLBACK44                   99  // really 844 export 99 GetLPErrMode not thunked
#define FUN_CALLBACK46                   100 // really 846 export 100 ValidateCodeSegments not thunked
#define FUN_CALLBACK48                   101 // really 848 export 101 NoHookDosCall not thunked
#define FUN_CALLBACK50                   102 // really 850 export 102 Dos3Call not thunked
#define FUN_CALLBACK52                   103 // really 852 export 103 NetBiosCall not thunked
#define FUN_CALLBACK54                   104 // really 854 export 104 GetCodeInfo not thunked
#define FUN_CALLBACK56                   105 // really 856 export 105 GetExeVersion not thunked
#define FUN_CALLBACK58                   106 // really 858 export 106 SetSwapAreaSize not thunked
#define FUN_CALLBACK60                   107 // really 860 export 107 SetErrorMode not thunked
#define FUN_CALLBACK62                   108 // really 862 export 108 SwitchStackTo not thunked
#define FUN_CALLBACK64                   109 // really 864 export 109 SwitchStackBack not thunked
#define FUN_WOWKILLTASK                  110 // WOW internal export 110 PatchCodeHandle not thunked
#define FUN_WOWFILEWRITE                 111 // WOW internal export 111 GlobalWire not thunked
#define FUN_WOWGETNEXTVDMCOMMAND         112 // really 502 export 112 GlobalUnWire not thunked
#define FUN_WOWFILELOCK                  113 // WOW internal export 113 is data __AHSHIFT
#define FUN_WOWFREERESOURCE              114 // WOW internal export 114 is data __AHINCR
#define FUN_WOWOUTPUTDEBUGSTRING         115 // export 115 is OutputDebugString, not directly thunked.
#define FUN_WOWINITTASK                  116 // WOW internal export 116 InitLib not thunked
#define FUN_OLDYIELD                     117 //
#define FUN_WOWFILESETDATETIME           118 // WOW internal export 118 GetTaskQueueDS no longer exported
#define FUN_WOWFILECREATE                119 // WOW internal export 119 GetTaskQueueES no longer exported
#define FUN_WOWDOSWOWINIT                120 // WOW internal export 120 UndefDynLink not thunked
#define FUN_WOWCHECKUSERGDI              121 // WOW internal export 121 LocalShrink not thunked
#define FUN_WOWPARTYBYNUMBER             122 // really 273 export 122 IsTaskLocked not thunked
#define FUN_GETSHORTPATHNAME             123 // really 274 export 123 KbdRst not thunked
#define FUN_FINDANDRELEASEDIB            124 // WOW internal export 124 EnableKernel not thunked
#define FUN_WOWRESERVEHTASK              125 // WOW internal export 125 DisableKernel not thunked
#define FUN_WOWFILESETATTRIBUTES         126 // WOW internal export 126 MemoryFreed not thunked
#define FUN_GETPRIVATEPROFILEINT         127 //
#define FUN_GETPRIVATEPROFILESTRING      128 //
#define FUN_WRITEPRIVATEPROFILESTRING    129 //
#define FUN_WOWSETCURRENTDIRECTORY       130 // WOW internal export 130 FileCDR not thunked
#define FUN_WOWWAITFORMSGANDEVENT        131 // really 262 export 131 GetDosEnvironment not thunked
#define FUN_WOWMSGBOX                    132 // really 263 export 132 GetWinFlags not thunked
#define FUN_WOWGETFLATADDRESSARRAY       133 // WOW internal export 133 GetExePtr not thunked
#define FUN_WOWGETCURRENTDATE            134 // WOW internal export 134 GetWindowsDirectory not thunked
#define FUN_WOWDEVICEIOCTL               135 // WOW internal export 135 GetSystemDirectory not thunked
#define FUN_GETDRIVETYPE                 136 //
#define FUN_WOWFILEGETDATETIME           137 // WOW internal export 137 FatalAppExit not thunked
#define FUN_SETAPPCOMPATFLAGS            138 // WOW internal export 138 GetHeapSpaces not thunked
#define FUN_WOWREGISTERSHELLWINDOWHANDLE 139 // really 251 export 139 DoSignal not thunked
#define FUN_FREELIBRARY32W               140 // really 514 export 140 SetSigHandler not thunked
#define FUN_GETPROCADDRESS32W            141 // really 515 export 141 InitTask1 not thunked
#define FUN_GETPROFILESECTIONNAMES       142 //
#define FUN_GETPRIVATEPROFILESECTIONNAMES 143 //
#define FUN_CREATEDIRECTORY              144 //
#define FUN_REMOVEDIRECTORY              145 //
#define FUN_DELETEFILE                   146 //
#define FUN_SETLASTERROR                 147 //
#define FUN_GETLASTERROR                 148 //
#define FUN_GETVERSIONEX                 149 //
#define FUN_DIRECTEDYIELD                150 //
#define FUN_WOWFILEREAD                  151 // WOW internal export 151 WinOldApCall not thunked
#define FUN_WOWFILELSEEK                 152 // WOW internal export 152 GetNumTasks not thunked
#define FUN_WOWKERNELTRACE               153 // WOW internal export 153 DiscardCodeSegment no longer exported
#define FUN_LOADLIBRARYEX32W             154 // really 513 export 154 GlobalNotify not thunked
#define FUN_WOWQUERYPERFORMANCECOUNTER   155 // really 505 export 155 GetTaskDS not thunked
#define FUN_WOWCURSORICONOP              156 // really 507 export 156 LimitEMSPages not thunked
#define FUN_WOWFAILEDEXEC                157 // WOW internal export 157 GetCurPID not thunked
#define FUN_WOWGETFASTADDRESS            158 // WOW internal export 158 IsWinOldApTask not thunked
#define FUN_WOWCLOSECOMPORT              159 // really 509 export 159 GlobalHandleNoRIP not thunked
#define FUN_LOCAL32INIT                  160 // really 208 export 160 EMSCopy not thunked
#define FUN_LOCAL32ALLOC                 161 // really 209 export 161 LocalCountFree not thunked
#define FUN_LOCAL32REALLOC               162 // really 210 export 162 LocalHeapSize not thunked
#define FUN_LOCAL32FREE                  163 // really 211 export 163 GlobalLRUOldest not thunked
#define FUN_LOCAL32TRANSLATE             164 // really 213 export 164 GlobalLRUNewest not thunked
#define FUN_LOCAL32SIZE                  165 // really 214 export 165 A20Proc not thunked
#define FUN_LOCAL32VALIDHANDLE           166 // really 215 export 166 WinExec not thunked
#define FUN_REGENUMKEY32                 167 // really 216 export 167 GetExpWinVer not thunked
#define FUN_REGOPENKEY32                 168 // really 217 export 168 DirectResAlloc not thunked
#define FUN_REGCREATEKEY32               169 // really 218 export 169 GetFreeSpace not thunked
#define FUN_REGDELETEKEY32               170 // really 219 export 170 AllocCStoDSAlias not thunked
#define FUN_REGCLOSEKEY32                171 // really 220 export 171 AllocDStoCSAlias not thunked
#define FUN_REGSETVALUE32                172 // really 221 export 172 AllocAlias not thunked
#define FUN_REGDELETEVALUE32             173 // really 222 export 173 is data __ROMBIOS
#define FUN_REGENUMVALUE32               174 // really 223 export 174 is data __A000h
#define FUN_REGQUERYVALUE32              175 // really 224 export 175 AllocSelector not thunked
#define FUN_REGQUERYVALUEEX32            176 // really 225 export 176 FreeSelector not thunked
#define FUN_REGSETVALUEEX32              177 // really 226 export 177 PrestoChangoSelector not thunked
#define FUN_REGFLUSHKEY32                178 // really 227 export 178 is data __WINFLAGS
#define FUN_COMPUTEOBJECTOWNER           179 // really 228 export 179 is data __D000h
#define FUN_LOCAL32GETSEL                180 // really 229 export 180 LongPtrAdd not thunked
#define FUN_MAPPROCESSHANDLE             181 // really 483 export 181 is data __B000h
#define FUN_INVALIDATENLSCACHE           182 // really 235 export 182 is data __B800h
#define FUN_WOWDELFILE                   183 // WOW internal export 183 is data __0000h
#ifdef  RENAMEVIRTUAL
#define FUN_WOWVIRTUALALLOC              184 // WOW internal export 184 GlobalDOSAlloc not thunked
#define FUN_WOWVIRTUALFREE               185 // WOW internal export 185 GlobalDOSFree not thunked
#else   // RENAMEVIRTUAL
#define FUN_VIRTUALALLOC              184 // WOW internal export 184 GlobalDOSAlloc not thunked
#define FUN_VIRTUALFREE               185 // WOW internal export 185 GlobalDOSFree not thunked
#endif  // else RENAMEVIRTUAL
#define FUN_VIRTUALLOCK                  186 // WOW internal export 186 GetSelectorBase not thunked
#define FUN_VIRTUALUNLOCK                187 // WOW internal export 187 SetSelectorBase not thunked
#define FUN_GLOBALMEMORYSTATUS           188 // WOW internal export 188 GetSelectorLimit not thunked
#define FUN_WOWGETFASTCBRETADDRESS       189 // WOW internal export 189 SetSelectorLimit not thunked
#define FUN_WOWGETTABLEOFFSETS           190 // WOW internal export 190 is data __E000h
#define FUN_WOWKILLREMOTETASK            191 // really 511 export 191 GlobalPageLock not thunked
#define FUN_WOWNOTIFYWOW32               192 // WOW internal export 192 GlobalPageUnlock not thunked
#define FUN_WOWFILEOPEN                  193 // WOW internal export 193 is data __0040h
#define FUN_WOWFILECLOSE                 194 // WOW internal export 194 is data __F000h
#define FUN_WOWSETIDLEHOOK               195 // WOW internal export 195 is data __C000h
#define FUN_KSYSERRORBOX                 196 // WOW internal export 196 SelectorAccessRights not thunked
#define FUN_WOWISKNOWNDLL                197 // WOW internal export 197 GlobalFix not thunked
#define FUN_WOWDDEFREEHANDLE             198 // WOW internal export 198 GlobalUnfix not thunked
#define FUN_WOWFILEGETATTRIBUTES         199 // WOW internal export 199 SetHandleCount not thunked
#define FUN_WOWSETDEFAULTDRIVE           200 // WOW internal export 200 ValidateFreeSpaces not thunked
#define FUN_WOWGETCURRENTDIRECTORY       201 // WOW internal export 201 ReplaceInst not thunked
#define FUN_GETPRODUCTNAME               202 // really 236 export 202 RegisterPTrace not thunked
#define FUN_ISSAFEMODE                   203 // really 237 export 203 DebugBreak not thunked
#define FUN_WOWLFNENTRY                  204 // WOW internal export 204 SwapRecording not thunked
#define FUN_WOWSHUTDOWNTIMER             205 // WOW internal export 205 CVWBreak not thunked
#define FUN_WOWTRIMWORKINGSET            206 // WOW internal export 206 AllocSelectorArray not thunked

#ifdef FE_SB
#define FUN_GETSYSTEMDEFAULTLANGID       207 // really 521 export 207 ISDBCSLEADBYTE not thunked
#endif
#define FUN_TERMSRVGETWINDOWSDIR         208 // internal

// #define FUN_WOWGETCURRENTDIRECTORYLONG   209 // WOW internal export
#define FUN_WOWPASSENVIRONMENT           209 // internal pass_environment
//#define FUN_WOWLOADKERNEL32              210 // internal kernel loading
#define FUN_WOWSYNCTASK                  210 // internal parent/child sync
#define FUN_WOWVWIN32                    211 // internal VWIN32 mapper
#define FUN_WOWVXDCALL                   212 // internal VxDCall mapper
#define FUN_WOWINT2f                     213 // internal Int2f parser


//
// Note the following "special" FUN_ identifiers are not used as offsets
// in a thunk table, but rather as arguments to some WOW private APIs,
// WowCursorIconOp and FindAndReleaseDib.
//

#define FUN_GLOBALFREE                   1000
#define FUN_GLOBALREALLOC                1001
#define FUN_GLOBALLOCK                   1002
#define FUN_GLOBALUNLOCK                 1003


/* XLATOFF */
#pragma pack(2)
/* XLATON */


/* NOTE that the tag (like "/* k1 * /") on each typedef line is used by
 * h2inc when building wowkrn.inc, as a prefix for that structures
 * members, since our assembler has only a single flat namespace. */


typedef struct _FATALEXIT16 {                              /* k1 */
    SHORT f1;
} FATALEXIT16;
typedef FATALEXIT16 UNALIGNED *PFATALEXIT16;

typedef struct _EXITKERNEL16 {                             /* k2 */
    WORD wExitCode;
} EXITKERNEL16;
typedef EXITKERNEL16 UNALIGNED *PEXITKERNEL16;

#ifdef NULLSTRUCT
typedef struct _WRITEOUTPROFILES16 {                       /* k3 */
} WRITEOUTPROFILES16;
typedef WRITEOUTPROFILES16 UNALIGNED *PWRITEOUTPROFILES16;
#endif

typedef struct _MAPSL16 {                                  /* k4 */
    DWORD vp;
} MAPSL16;
typedef MAPSL16 UNALIGNED *PMAPSL16;

typedef struct _MAPLS16 {                                  /* k5 */
    PVOID p;
} MAPLS16;
typedef MAPLS16 UNALIGNED *PMAPLS16;

typedef struct _UNMAPLS16 {                                /* k6 */
    PVOID vp;
} UNMAPLS16;
typedef UNMAPLS16 UNALIGNED *PUNMAPLS16;

typedef struct _OPENFILEEX16 {                             /* k7 */
    WORD  wFlags;
    DWORD lpOFStructEx;
    DWORD lpSrcFile;
} OPENFILEEX16;
typedef OPENFILEEX16 UNALIGNED *POPENFILEEX16;

typedef struct _FASTANDDIRTYGLOBALFIX16 {                  /* k8 */
    WORD  selFix;
    WORD  wAction;
} FASTANDDIRTYGLOBALFIX16;
typedef FASTANDDIRTYGLOBALFIX16 UNALIGNED *PFASTANDDIRTYGLOBALFIX16;

typedef struct _WRITEPRIVATEPROFILESTRUCT16 {              /* k9 */
    DWORD lpszFile;
    WORD  cbStruct;
    DWORD lpStruct;
    DWORD lpszKey;
    DWORD lpszSection;
} WRITEPRIVATEPROFILESTRUCT16;
typedef WRITEPRIVATEPROFILESTRUCT16 UNALIGNED *PWRITEPRIVATEPROFILESTRUCT16;

typedef struct _GETPRIVATEPROFILESTRUCT16 {                /* k10 */
    DWORD lpszFile;
    WORD  cbStruct;
    DWORD lpStruct;
    DWORD lpszKey;
    DWORD lpszSection;
} GETPRIVATEPROFILESTRUCT16;
typedef GETPRIVATEPROFILESTRUCT16 UNALIGNED *PGETPRIVATEPROFILESTRUCT16;

typedef struct _GETCURRENTDIRECTORY16 {                    /* k11 */
    DWORD lpszDir;
    DWORD cchDir;
} GETCURRENTDIRECTORY16;
typedef GETCURRENTDIRECTORY16 UNALIGNED *PGETCURRENTDIRECTORY16;

typedef struct _SETCURRENTDIRECTORY16 {                    /* k12 */
    DWORD lpszDir;
} SETCURRENTDIRECTORY16;
typedef SETCURRENTDIRECTORY16 UNALIGNED *PSETCURRENTDIRECTORY16;

typedef struct _FINDFIRSTFILE16 {                          /* k13 */
    DWORD lpFindData;
    DWORD lpszSearchFile;
} FINDFIRSTFILE16;
typedef FINDFIRSTFILE16 UNALIGNED *PFINDFIRSTFILE16;

typedef struct _FINDNEXTFILE16 {                           /* k14 */
    DWORD lpFindData;
    DWORD hFindFile;
} FINDNEXTFILE16;
typedef FINDNEXTFILE16 UNALIGNED *PFINDNEXTFILE16;

typedef struct _FINDCLOSE16 {                              /* k15 */
    DWORD hFindFile;
} FINDCLOSE16;
typedef FINDCLOSE16 UNALIGNED *PFINDCLOSE16;

typedef struct _WRITEPRIVATEPROFILESECTION16 {             /* k16 */
    DWORD lpszFile;
    DWORD lpKeysAndValues;
    DWORD lpszSection;
} WRITEPRIVATEPROFILESECTION16;
typedef WRITEPRIVATEPROFILESECTION16 UNALIGNED *PWRITEPRIVATEPROFILESECTION16;

typedef struct _WRITEPROFILESECTION16 {                    /* k17 */
    DWORD lpKeysAndValues;
    DWORD lpszSection;
} WRITEPROFILESECTION16;
typedef WRITEPROFILESECTION16 UNALIGNED *PWRITEPROFILESECTION16;

typedef struct _GETPRIVATEPROFILESECTION16 {               /* k18 */
    DWORD lpszFile;
    WORD  cchResult;
    DWORD lpResult;
    DWORD lpszSection;
} GETPRIVATEPROFILESECTION16;
typedef GETPRIVATEPROFILESECTION16 UNALIGNED *PGETPRIVATEPROFILESECTION16;

typedef struct _GETPROFILESECTION16 {                      /* k19 */
    WORD  cchResult;
    DWORD lpResult;
    DWORD lpszSection;
} GETPROFILESECTION16;
typedef GETPROFILESECTION16 UNALIGNED *PGETPROFILESECTION16;

typedef struct _GETFILEATTRIBUTES16 {                      /* k20 */
    DWORD lpszFile;
} GETFILEATTRIBUTES16;
typedef GETFILEATTRIBUTES16 UNALIGNED *PGETFILEATTRIBUTES16;

typedef struct _SETFILEATTRIBUTES16 {                      /* k21 */
    DWORD dwFileAttributes;
    DWORD lpszFile;
} SETFILEATTRIBUTES16;
typedef SETFILEATTRIBUTES16 UNALIGNED *PSETFILEATTRIBUTES16;

typedef struct _GETDISKFREESPACE16 {                       /* k22 */
    DWORD lpdwClusters;
    DWORD lpdwFreeClusters;
    DWORD lpdwBytesPerSector;
    DWORD lpdwSectorsPerCluster;
    DWORD lpszRootPathName;
} GETDISKFREESPACE16;
typedef GETDISKFREESPACE16 UNALIGNED *PGETDISKFREESPACE16;

typedef struct _ISPEFORMAT16 {                             /* k23 */
    WORD  hFile;
    DWORD lpszFile;
} ISPEFORMAT16;
typedef ISPEFORMAT16 UNALIGNED *PISPEFORMAT16;

typedef struct _FILETIMETOLOCALFILETIME16 {                /* k24 */
    DWORD lpLocalFileTime;
    DWORD lpUTCFileTime;
} FILETIMETOLOCALFILETIME16;
typedef FILETIMETOLOCALFILETIME16 UNALIGNED *PFILETIMETOLOCALFILETIME16;

typedef struct _UNITOANSI16 {                              /* k25 */
    WORD  cch;
    DWORD pchDst;
    DWORD pchSrc;
} UNITOANSI16;
typedef UNITOANSI16 UNALIGNED *PUNITOANSI16;

typedef struct _GETVDMPOINTER32W16 {                       /* k26 */
    SHORT  fMode;
    VPVOID lpAddress;
} GETVDMPOINTER32W16;
typedef GETVDMPOINTER32W16 UNALIGNED *PGETVDMPOINTER32W16;

typedef struct _CREATETHREAD16 {                           /* k27 */
    DWORD lpThreadID;
    DWORD dwCreateFlags;
    DWORD lpParameter;
    DWORD lpStartAddress;
    DWORD dwStackSize;
    DWORD lpSecurityAttributes;
} CREATETHREAD16;
typedef CREATETHREAD16 UNALIGNED *PCREATETHREAD16;

typedef struct _ICALLPROC32W16 {                           /* k28 */
    WORD  rbp;
    DWORD retaddr;
    DWORD cParams;
    DWORD fAddressConvert;
    DWORD lpProcAddress;
    DWORD p1;
    DWORD p2;
    DWORD p3;
    DWORD p4;
    DWORD p5;
    DWORD p6;
    DWORD p7;
    DWORD p8;
    DWORD p9;
    DWORD p10;
    DWORD p11;
    DWORD p12;
    DWORD p13;
    DWORD p14;
    DWORD p15;
    DWORD p16;
    DWORD p17;
    DWORD p18;
    DWORD p19;
    DWORD p20;
    DWORD p21;
    DWORD p22;
    DWORD p23;
    DWORD p24;
    DWORD p25;
    DWORD p26;
    DWORD p27;
    DWORD p28;
    DWORD p29;
    DWORD p30;
    DWORD p31;
    DWORD p32;
} ICALLPROC32W16;
typedef ICALLPROC32W16 UNALIGNED *PICALLPROC32W16;

#define CPEX32_DEST_CDECL   0x8000L
#define CPEX32_SOURCE_CDECL 0x4000L

#ifdef NULLSTRUCT
typedef struct _YIELD16 {                                  /* k29 */
} YIELD16;
typedef YIELD16 UNALIGNED *PYIELD16;
#endif

typedef struct _WAITEVENT16 {                              /* k30 */
    WORD    wTaskID;
} WAITEVENT16;
typedef WAITEVENT16 UNALIGNED *PWAITEVENT16;

typedef struct _POSTEVENT16 {                              /* k31 */
    WORD    hTask16;
} POSTEVENT16;
typedef POSTEVENT16 UNALIGNED *PPOSTEVENT16;

typedef struct _SETPRIORITY16 {                            /* k32 */
    WORD    wPriority;
    WORD    hTask16;
} SETPRIORITY16;
typedef SETPRIORITY16 UNALIGNED *PSETPRIORITY16;

typedef struct _LOCKCURRENTTASK16 {                        /* k33 */
    WORD    fLock;
} LOCKCURRENTTASK16;
typedef LOCKCURRENTTASK16 UNALIGNED *PLOCKCURRENTTASK16;

#ifdef NULLSTRUCT
typedef struct _LEAVEENTERWIN16LOCK {                      /* k34 */
} LEAVEENTERWIN16LOCK;
typedef LEAVEENTERWIN16LOCK UNALIGNED *PLEAVEENTERWIN16LOCK;
#endif

typedef struct _REGLOADKEY3216 {                           /* k35 */
    VPSTR lpszFileName;
    VPSTR lpszSubkey;
    DWORD hKey;
} REGLOADKEY3216;
typedef REGLOADKEY3216 UNALIGNED *PREGLOADKEY3216;

typedef struct _REGUNLOADKEY3216 {                         /* k36 */
    VPSTR lpszSubkey;
    DWORD hKey;
} REGUNLOADKEY3216;
typedef REGUNLOADKEY3216 UNALIGNED *PREGUNLOADKEY3216;

typedef struct _REGSAVEKEY3216 {                           /* k37 */
    VPVOID lpSA;
    VPSTR  lpszSubkey;
    DWORD  hKey;
} REGSAVEKEY3216;
typedef REGSAVEKEY3216 UNALIGNED *PREGSAVEKEY3216;

#ifdef NULLSTRUCT
typedef struct _GETWIN16LOCK16 {                           /* k38 */
} GETWIN16LOCK16;
typedef GETWIN16LOCK16 UNALIGNED *PGETWIN16LOCK16;
#endif

typedef struct _LOADLIBRARY3216 {                          /* k39 */
    DWORD lpszLibrary;
} LOADLIBRARY3216;
typedef LOADLIBRARY3216 UNALIGNED *PLOADLIBRARY3216;

typedef struct _GETPROCADDRESS3216 {                       /* k40 */
    DWORD lpszProc;
    DWORD hLib;
} GETPROCADDRESS3216;
typedef GETPROCADDRESS3216 UNALIGNED *PGETPROCADDRESS3216;

typedef struct _WOWFINDFIRST16 {                           /* k41 */
    DWORD lpDTA;
    WORD  pszPathOffset;
    WORD  pszPathSegment;
    WORD  wAttributes;
} WOWFINDFIRST16;
typedef WOWFINDFIRST16 UNALIGNED *PWOWFINDFIRST16;

typedef struct _WOWFINDNEXT16 {                            /* k42 */
    DWORD lpDTA;
} WOWFINDNEXT16;
typedef WOWFINDNEXT16 UNALIGNED *PWOWFINDNEXT16;

typedef struct _CREATEWIN32EVENT16 {                       /* k43 */
    DWORD bInitialState;
    DWORD bManualReset;
} CREATEWIN32EVENT16;
typedef CREATEWIN32EVENT16 UNALIGNED *PCREATEWIN32EVENT16;

typedef struct _SETWIN32EVENT16 {                          /* k44 */
    DWORD hEvent;
} SETWIN32EVENT16;
typedef SETWIN32EVENT16 UNALIGNED *PSETWIN32EVENT16;

typedef struct _WOWLOADMODULE16 {                          /* k45 */
    VPSTR  lpWinOldAppCmd;
    VPVOID lpParameterBlock;
    VPSTR  lpModuleName;
} WOWLOADMODULE16;
typedef WOWLOADMODULE16 UNALIGNED *PWOWLOADMODULE16;

typedef struct _PARAMETERBLOCK16 {                         /* k45_2 */
    WORD    wEnvSeg;
    VPVOID  lpCmdLine;
    VPVOID  lpCmdShow;
    DWORD   dwReserved;
} PARAMETERBLOCK16;
typedef PARAMETERBLOCK16 UNALIGNED *PPARAMETERBLOCK16;

typedef struct _RESETWIN32EVENT16 {                        /* k46 */
    DWORD hEvent;
} RESETWIN32EVENT16;
typedef RESETWIN32EVENT16 UNALIGNED *PRESETWIN32EVENT16;

typedef struct _WOWGETMODULEHANDLE16 {                     /* k47 */
    VPSTR lpszModuleName;
} WOWGETMODULEHANDLE16;
typedef WOWGETMODULEHANDLE16 UNALIGNED *PWOWGETMODULEHANDLE16;

typedef struct _WAITFORSINGLEOBJECT16 {                    /* k48 */
    DWORD dwTimeout;
    DWORD h;
} WAITFORSINGLEOBJECT16;
typedef WAITFORSINGLEOBJECT16 UNALIGNED *PWAITFORSINGLEOBJECT16;

typedef struct _GETMODULEFILENAME16 {                      /* k49 */
    SHORT f3;
    VPSTR f2;
    HAND16 f1;
} GETMODULEFILENAME16;
typedef GETMODULEFILENAME16 UNALIGNED *PGETMODULEFILENAME16;

typedef struct _WAITFORMULTIPLEOBJECTS16 {                 /* k50 */
    DWORD dwTimeout;
    DWORD bWaitForAll;
    DWORD lphObjects;
    DWORD cObjects;
} WAITFORMULTIPLEOBJECTS16;
typedef WAITFORMULTIPLEOBJECTS16 UNALIGNED *PWAITFORMULTIPLEOBJECTS16;

#ifdef NULLSTRUCT
typedef struct _GETCURRENTTHREADID16 {                     /* k51 */
} GETCURRENTTHREADID16;
typedef GETCURRENTTHREADID16 UNALIGNED *PGETCURRENTTHREADID16;
#endif

typedef struct _SETTHREADQUEUE16 {                         /* k52 */
    WORD  NewQueueSel;
    DWORD dwThreadID;
} SETTHREADQUEUE16;
typedef SETTHREADQUEUE16 UNALIGNED *PSETTHREADQUEUE16;

typedef struct _CONVERTTOGLOBALHANDLE16 {                  /* k53 */
    DWORD dwHandle;
} CONVERTTOGLOBALHANDLE16;
typedef CONVERTTOGLOBALHANDLE16 UNALIGNED *PCONVERTTOGLOBALHANDLE16;

typedef struct _GETTHREADQUEUE16 {                         /* k54 */
    DWORD dwThreadID;
} GETTHREADQUEUE16;
typedef GETTHREADQUEUE16 UNALIGNED *PGETTHREADQUEUE16;

typedef struct _NUKEPROCESS16 {                            /* k55 */
    DWORD ulFlags;
    WORD  uExitCode;
    DWORD ppdb;
} NUKEPROCESS16;
typedef NUKEPROCESS16 UNALIGNED *PNUKEPROCESS16;

typedef struct _EXITPROCESS16 {                            /* k56 */
    WORD wStatus;
} EXITPROCESS16;
typedef EXITPROCESS16 UNALIGNED *PEXITPROCESS16;

typedef struct _GETPROFILEINT16 {                          /* k57 */
    SHORT f3;
    VPSTR f2;
    VPSTR f1;
} GETPROFILEINT16;
typedef GETPROFILEINT16 UNALIGNED *PGETPROFILEINT16;

typedef struct _GETPROFILESTRING16 {                       /* k58 */
    USHORT f5;
    VPSTR f4;
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} GETPROFILESTRING16;
typedef GETPROFILESTRING16 UNALIGNED *PGETPROFILESTRING16;

typedef struct _WRITEPROFILESTRING16 {                     /* k59 */
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} WRITEPROFILESTRING16;
typedef WRITEPROFILESTRING16 UNALIGNED *PWRITEPROFILESTRING16;

#ifdef NULLSTRUCT
typedef struct _GETCURRENTPROCESSID16 {                    /* k60 */
} GETCURRENTPROCESSID16;
typedef GETCURRENTPROCESSID16 UNALIGNED *PGETCURRENTPROCESSID16;
#endif

#ifdef NULLSTRUCT
typedef struct _MAPHINSTLS {                               /* k61 */
    /* NOTE if you implement this the interface is register-based */
} MAPHINSTLS;
typedef MAPHINSTLS UNALIGNED *PMAPHINSTLS;
#endif

#ifdef NULLSTRUCT
typedef struct _MAPHINSTSL {                               /* k62 */
    /* NOTE if you implement this the interface is register-based */
} MAPHINSTSL;
typedef MAPHINSTSL UNALIGNED *PMAPHINSTSL;
#endif

typedef struct _CLOSEWIN32HANDLE16 {                       /* k63 */
    DWORD h32;
} CLOSEWIN32HANDLE16;
typedef CLOSEWIN32HANDLE16 UNALIGNED *PCLOSEWIN32HANDLE16;

typedef struct _LOADSYSTEMLIBRARY3216 {                    /* k64 */
    VPSTR lpszLibrary;
} LOADSYSTEMLIBRARY3216;
typedef LOADSYSTEMLIBRARY3216 UNALIGNED *PLOADSYSTEMLIBRARY3216;

typedef struct _FREELIBRARY3216 {                          /* k65 */
    DWORD hModule;
} FREELIBRARY3216;
typedef FREELIBRARY3216 UNALIGNED *PFREELIBRARY3216;

typedef struct _GETMODULEFILENAME3216 {                    /* k66 */
    WORD    wBufferSize;
    VPSTR   lpBuffer;
    DWORD   hModule;
} GETMODULEFILENAME3216;
typedef GETMODULEFILENAME3216 UNALIGNED *PGETMODULEFILENAME3216;

typedef struct _GETMODULEHANDLE3216 {                      /* k67 */
    VPSTR lpszModule;
} GETMODULEHANDLE3216;
typedef GETMODULEHANDLE3216 UNALIGNED *PGETMODULEHANDLE3216;

typedef struct _REGISTERSERVICEPROCESS16 {                 /* k68 */
    DWORD dwServiceType;
    DWORD dwProcessID;
} REGISTERSERVICEPROCESS16;
typedef REGISTERSERVICEPROCESS16 UNALIGNED *PREGISTERSERVICEPROCESS16;

typedef struct _CHANGEALLOCFIXEDBEHAVIOUR16 {              /* k69 */
    WORD fWin31Behavior;
} CHANGEALLOCFIXEDBEHAVIOUR16;
typedef CHANGEALLOCFIXEDBEHAVIOUR16 UNALIGNED *PCHANGEALLOCFIXEDBEHAVIOUR16;

typedef struct _INITCB16 {                                 /* k70 */
    DWORD fnStdCBSLDispatch;
    DWORD fnStdCBLSDispatch;
} INITCB16;
typedef INITCB16 UNALIGNED *PINITCB16;

typedef struct _GETSTDCBLS16 {                             /* k71 */
    DWORD CBID;
    DWORD pfnTarg16;
} GETSTDCBLS16;
typedef GETSTDCBLS16 UNALIGNED *PGETSTDCBLS16;

typedef struct _GETSTDCBSL16 {                             /* k72 */
    DWORD CBID;
    DWORD pfnTarg32;
} GETSTDCBSL16;
typedef GETSTDCBSL16 UNALIGNED *PGETSTDCBSL16;

typedef struct _GETEXISTINGSTDCBLS16 {                     /* k73 */
    DWORD CBID;
    DWORD pfnTarg16;
} GETEXISTINGSTDCBLS16;
typedef GETEXISTINGSTDCBLS16 UNALIGNED *PGETEXISTINGSTDCBLS16;

typedef struct _GETEXISTINGSTDCBSL16 {                     /* k74 */
    DWORD CBID;
    DWORD pfnTarg32;
} GETEXISTINGSTDCBSL16;
typedef GETEXISTINGSTDCBSL16 UNALIGNED *PGETEXISTINGSTDCBSL16;

typedef struct _GETFLEXCBSL16 {                            /* k75 */
    DWORD pfnThunk;
    DWORD pfnTarg32;
} GETFLEXCBSL16;
typedef GETFLEXCBSL16 UNALIGNED *PGETFLEXCBSL16;

typedef struct _GETSTDCBLSEX16 {                           /* k76 */
    WORD  wOwner;
    DWORD CBID;
    DWORD pfnTarg16;
} GETSTDCBLSEX16;
typedef GETSTDCBLSEX16 UNALIGNED *PGETSTDCBLSEX16;

typedef struct _GETSTDCBSLEX16 {                           /* k77 */
    WORD  wOwner;
    DWORD CBID;
    DWORD pfnTarg32;
} GETSTDCBSLEX16;
typedef GETSTDCBSLEX16 UNALIGNED *PGETSTDCBSLEX16;

typedef struct _CALLBACK216 {                              /* k78 */
    WORD rgwArgs[1];
} CALLBACK216;
typedef CALLBACK216 UNALIGNED *PCALLBACK216;

typedef struct _CALLBACK416 {                              /* k79 */
    WORD rgwArgs[2];
} CALLBACK416;
typedef CALLBACK416 UNALIGNED *PCALLBACK416;

typedef struct _CALLBACK616 {                              /* k80 */
    WORD rgwArgs[3];
} CALLBACK616;
typedef CALLBACK616 UNALIGNED *PCALLBACK616;

typedef struct _CALLBACK816 {                              /* k81 */
    WORD rgwArgs[4];
} CALLBACK816;
typedef CALLBACK816 UNALIGNED *PCALLBACK816;

typedef struct _CALLBACK1016 {                             /* k82 */
    WORD rgwArgs[5];
} CALLBACK1016;
typedef CALLBACK1016 UNALIGNED *PCALLBACK1016;

typedef struct _CALLBACK1216 {                             /* k83 */
    WORD rgwArgs[6];
} CALLBACK1216;
typedef CALLBACK1216 UNALIGNED *PCALLBACK1216;

typedef struct _CALLBACK1416 {                             /* k84 */
    WORD rgwArgs[7];
} CALLBACK1416;
typedef CALLBACK1416 UNALIGNED *PCALLBACK1416;

typedef struct _CALLBACK1616 {                             /* k85 */
    WORD rgwArgs[8];
} CALLBACK1616;
typedef CALLBACK1616 UNALIGNED *PCALLBACK1616;

typedef struct _CALLBACK1816 {                             /* k86 */
    WORD rgwArgs[9];
} CALLBACK1816;
typedef CALLBACK1816 UNALIGNED *PCALLBACK1816;

typedef struct _CALLBACK2016 {                             /* k87 */
    WORD rgwArgs[10];
} CALLBACK2016;
typedef CALLBACK2016 UNALIGNED *PCALLBACK2016;

typedef struct _CALLBACK2216 {                             /* k88 */
    WORD rgwArgs[11];
} CALLBACK2216;
typedef CALLBACK2216 UNALIGNED *PCALLBACK2216;

typedef struct _CALLBACK2416 {                             /* k89 */
    WORD rgwArgs[12];
} CALLBACK2416;
typedef CALLBACK2416 UNALIGNED *PCALLBACK2416;

typedef struct _CALLBACK2616 {                             /* k90 */
    WORD rgwArgs[13];
} CALLBACK2616;
typedef CALLBACK2616 UNALIGNED *PCALLBACK2616;

typedef struct _CALLBACK2816 {                             /* k91 */
    WORD rgwArgs[14];
} CALLBACK2816;
typedef CALLBACK2816 UNALIGNED *PCALLBACK2816;

typedef struct _CALLBACK3016 {                             /* k92 */
    WORD rgwArgs[15];
} CALLBACK3016;
typedef CALLBACK3016 UNALIGNED *PCALLBACK3016;

typedef struct _CALLBACK3216 {                             /* k93 */
    WORD rgwArgs[16];
} CALLBACK3216;
typedef CALLBACK3216 UNALIGNED *PCALLBACK3216;

typedef struct _CALLBACK3416 {                             /* k94 */
    WORD rgwArgs[17];
} CALLBACK3416;
typedef CALLBACK3416 UNALIGNED *PCALLBACK3416;

typedef struct _CALLBACK3616 {                             /* k95 */
    WORD rgwArgs[18];
} CALLBACK3616;
typedef CALLBACK3616 UNALIGNED *PCALLBACK3616;

typedef struct _CALLBACK3816 {                             /* k96 */
    WORD rgwArgs[19];
} CALLBACK3816;
typedef CALLBACK3816 UNALIGNED *PCALLBACK3816;

typedef struct _CALLBACK4016 {                             /* k97 */
    WORD rgwArgs[20];
} CALLBACK4016;
typedef CALLBACK4016 UNALIGNED *PCALLBACK4016;

typedef struct _CALLBACK4216 {                             /* k98 */
    WORD rgwArgs[21];
} CALLBACK4216;
typedef CALLBACK4216 UNALIGNED *PCALLBACK4216;

typedef struct _CALLBACK4416 {                             /* k99 */
    WORD rgwArgs[22];
} CALLBACK4416;
typedef CALLBACK4416 UNALIGNED *PCALLBACK4416;

typedef struct _CALLBACK4616 {                             /* k100 */
    WORD rgwArgs[23];
} CALLBACK4616;
typedef CALLBACK4616 UNALIGNED *PCALLBACK4616;

typedef struct _CALLBACK4816 {                             /* k101 */
    WORD rgwArgs[24];
} CALLBACK4816;
typedef CALLBACK4816 UNALIGNED *PCALLBACK4816;

typedef struct _CALLBACK5016 {                             /* k102 */
    WORD rgwArgs[25];
} CALLBACK5016;
typedef CALLBACK5016 UNALIGNED *PCALLBACK5016;

typedef struct _CALLBACK5216 {                             /* k103 */
    WORD rgwArgs[26];
} CALLBACK5216;
typedef CALLBACK5216 UNALIGNED *PCALLBACK5216;

typedef struct _CALLBACK5416 {                             /* k104 */
    WORD rgwArgs[27];
} CALLBACK5416;
typedef CALLBACK5416 UNALIGNED *PCALLBACK5416;

typedef struct _CALLBACK5616 {                             /* k105 */
    WORD rgwArgs[28];
} CALLBACK5616;
typedef CALLBACK5616 UNALIGNED *PCALLBACK5616;

typedef struct _CALLBACK5816 {                             /* k106 */
    WORD rgwArgs[29];
} CALLBACK5816;
typedef CALLBACK5816 UNALIGNED *PCALLBACK5816;

typedef struct _CALLBACK6016 {                             /* k107 */
    WORD rgwArgs[30];
} CALLBACK6016;
typedef CALLBACK6016 UNALIGNED *PCALLBACK6016;

typedef struct _CALLBACK6216 {                             /* k108 */
    WORD rgwArgs[31];
} CALLBACK6216;
typedef CALLBACK6216 UNALIGNED *PCALLBACK6216;

typedef struct _CALLBACK6416 {                             /* k109 */
    WORD rgwArgs[32];
} CALLBACK6416;
typedef CALLBACK6416 UNALIGNED *PCALLBACK6416;

typedef struct _WOWFILEWRITE16 {                           /* k111 */
    DWORD lpSFT;
    DWORD lpPDB;
    DWORD  bufsize;
    DWORD lpBuf;
    WORD  fh;
} WOWFILEWRITE16;
typedef WOWFILEWRITE16 UNALIGNED *PWOWFILEWRITE16;

typedef struct _WOWGETNEXTVDMCOMMAND16 {                   /* k112 */
    VPVOID  lpWowInfo;
} WOWGETNEXTVDMCOMMAND16;
typedef WOWGETNEXTVDMCOMMAND16 UNALIGNED *PWOWGETNEXTVDMCOMMAND16;

typedef struct _WOWFILELOCK16 {                            /* k113 */
    DWORD lpSFT;
    DWORD lpPDB;
    DWORD cbRegionLength;
    DWORD cbRegionOffset;
    WORD  fh;
    WORD  ax;
} WOWFILELOCK16;
typedef WOWFILELOCK16 UNALIGNED *PWOWFILELOCK16;

typedef struct _WOWFREERESOURCE16 {                        /* k114 */
    HAND16 f1;
} WOWFREERESOURCE16;
typedef WOWFREERESOURCE16 UNALIGNED *PWOWFREERESOURCE16;

typedef struct _WOWOUTPUTDEBUGSTRING16 {                   /* k115 */
    VPSTR   vpString;
} WOWOUTPUTDEBUGSTRING16;
typedef WOWOUTPUTDEBUGSTRING16 UNALIGNED *PWOWOUTPUTDEBUGSTRING16;

typedef struct _WOWINITTASK16 {                            /* k116 */
    DWORD dwExpWinVer;
} WOWINITTASK16;
typedef WOWINITTASK16 UNALIGNED *PWOWINITTASK16;

typedef struct _WOWFILESETDATETIME16 {                     /* k118 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  date;
    WORD  time;
    WORD  fh;
} WOWFILESETDATETIME16;
typedef WOWFILESETDATETIME16 UNALIGNED *PWOWFILESETDATETIME16;

typedef struct _WOWFILECREATE16 {                          /* k119 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  pszPathOffset;
    WORD  pszPathSegment;
    WORD  wAttributes;
} WOWFILECREATE16;
typedef WOWFILECREATE16 UNALIGNED *PWOWFILECREATE16;

typedef struct _WOWDOSWOWINIT16 {                          /* k120 */
    VPVOID  lpDosWowData;
} WOWDOSWOWINIT16;
typedef WOWDOSWOWINIT16 UNALIGNED *PWOWDOSWOWINIT16;

typedef struct _WOWCHECKUSERGDI16 {                        /* k121 */
    WORD  pszPathOffset;
    WORD  pszPathSegment;
} WOWCHECKUSERGDI16;
typedef WOWCHECKUSERGDI16 UNALIGNED *PWOWCHECKUSERGDI16;

typedef struct _WOWPARTYBYNUMBER16 {                       /* k122 */
    VPSZ  psz;
    DWORD dw;
} WOWPARTYBYNUMBER16;
typedef WOWPARTYBYNUMBER16 UNALIGNED *PWOWPARTYBYNUMBER16;

typedef struct _GETSHORTPATHNAME16 {                       /* k123 */
    WORD  cchShortPath;
    VPSZ  pszShortPath;
    VPSZ  pszLongPath;
} GETSHORTPATHNAME16;
typedef GETSHORTPATHNAME16 UNALIGNED *PGETSHORTPATHNAME16;

typedef struct _FINDANDRELEASEDIB16 {                      /* k124 */
    WORD wFunId;
    HAND16 hdib;     /* handle which we are messing with */
} FINDANDRELEASEDIB16;
typedef FINDANDRELEASEDIB16 UNALIGNED *PFINDANDRELEASEDIB16;

typedef struct _WOWRESERVEHTASK16 {                        /* k125 */
    WORD  htask;
} WOWRESERVEHTASK16;
typedef WOWRESERVEHTASK16 UNALIGNED *PWOWRESERVEHTASK16;

typedef struct _WOWFILESETATTRIBUTES16 {                   /* k126 */
    WORD  pszPathOffset;
    WORD  pszPathSegment;
    WORD  wAttributes;
} WOWFILESETATTRIBUTES16;
typedef WOWFILESETATTRIBUTES16 UNALIGNED *PWOWFILESETATTRIBUTES16;

typedef struct _GETPRIVATEPROFILEINT16 {                   /* k127 */
    VPSTR f4;
    SHORT f3;
    VPSTR f2;
    VPSTR f1;
} GETPRIVATEPROFILEINT16;
typedef GETPRIVATEPROFILEINT16 UNALIGNED *PGETPRIVATEPROFILEINT16;

typedef struct _GETPRIVATEPROFILESTRING16 {                /* k128 */
    VPSTR f6;
    USHORT f5;
    VPSTR f4;
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} GETPRIVATEPROFILESTRING16;
typedef GETPRIVATEPROFILESTRING16 UNALIGNED *PGETPRIVATEPROFILESTRING16;

typedef struct _WRITEPRIVATEPROFILESTRING16 {              /* k129 */
    VPSTR f4;
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} WRITEPRIVATEPROFILESTRING16;
typedef WRITEPRIVATEPROFILESTRING16 UNALIGNED *PWRITEPRIVATEPROFILESTRING16;

typedef struct _WOWSETCURRENTDIRECTORY16 {                 /* k130 */
    DWORD lpCurDir;
} WOWSETCURRENTDIRECTORY16;
typedef WOWSETCURRENTDIRECTORY16 UNALIGNED *PWOWSETCURRENTDIRECTORY16;

typedef struct _WOWWAITFORMSGANDEVENT16 {                  /* k131 */
    HWND16 hwnd;
} WOWWAITFORMSGANDEVENT16;
typedef WOWWAITFORMSGANDEVENT16 UNALIGNED *PWOWWAITFORMSGANDEVENT16;

typedef struct _WOWMSGBOX16 {                              /* k132 */
    DWORD   dwOptionalStyle;
    VPSZ    pszTitle;
    VPSZ    pszMsg;
} WOWMSGBOX16;
typedef WOWMSGBOX16 UNALIGNED *PWOWMSGBOX16;

typedef struct _WOWDEVICEIOCTL16 {                         /* k135 */
    WORD  wCmd;
    WORD  wDriveNum;
} WOWDEVICEIOCTL16;
typedef WOWDEVICEIOCTL16 UNALIGNED *PWOWDEVICEIOCTL16;

typedef struct _GETDRIVETYPE16 {                           /* k136 */
    SHORT f1;
} GETDRIVETYPE16;
typedef GETDRIVETYPE16 UNALIGNED *PGETDRIVETYPE16;

typedef struct _WOWFILEGETDATETIME16 {                     /* k137 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  fh;
} WOWFILEGETDATETIME16;
typedef WOWFILEGETDATETIME16 UNALIGNED *PWOWFILEGETDATETIME16;

typedef struct _SETAPPCOMPATFLAGS16 {           /* k139 */
    WORD  TDB;
} SETAPPCOMPATFLAGS16;
typedef SETAPPCOMPATFLAGS16 UNALIGNED *PSETAPPCOMPATFLAGS16;

typedef struct _WOWREGISTERSHELLWINDOWHANDLE16 {           /* k139 */
    HWND16 hwndFax;
    VPWORD lpwCmdShow;
    HWND16 hwndShell;
} WOWREGISTERSHELLWINDOWHANDLE16;
typedef WOWREGISTERSHELLWINDOWHANDLE16 UNALIGNED *PWOWREGISTERSHELLWINDOWHANDLE16;

typedef struct _FREELIBRARY32W16 {                         /* k140 */
    DWORD  hLibModule;
} FREELIBRARY32W16;
typedef FREELIBRARY32W16 UNALIGNED *PFREELIBRARY32W16;

typedef struct _GETPROCADDRESS32W16 {                      /* k141 */
    VPVOID lpszProc;
    DWORD  hModule;
} GETPROCADDRESS32W16;
typedef GETPROCADDRESS32W16 UNALIGNED *PGETPROCADDRESS32W16;

typedef struct _GETPROFILESECTIONNAMES16 {                 /* k142 */
    WORD  cbBuffer;
    VPSTR lpszBuffer;
} GETPROFILESECTIONNAMES16;
typedef GETPROFILESECTIONNAMES16 UNALIGNED *PGETPROFILESECTIONNAMES16;

typedef struct _GETPRIVATEPROFILESECTIONNAMES16 {          /* k143 */
    VPSTR lpszFile;
    WORD  cbBuffer;
    VPSTR lpszBuffer;
} GETPRIVATEPROFILESECTIONNAMES16;
typedef GETPRIVATEPROFILESECTIONNAMES16 UNALIGNED *PGETPRIVATEPROFILESECTIONNAMES16;

typedef struct _CREATEDIRECTORY16 {                        /* k144 */
    VPVOID lpSA;
    VPSTR  lpszName;
} CREATEDIRECTORY16;
typedef CREATEDIRECTORY16 UNALIGNED *PCREATEDIRECTORY16;

typedef struct _REMOVEDIRECTORY16 {                        /* k145 */
    VPSTR  lpszName;
} REMOVEDIRECTORY16;
typedef REMOVEDIRECTORY16 UNALIGNED *PREMOVEDIRECTORY16;

typedef struct _DELETEFILE16 {                             /* k146 */
    VPSTR  lpszName;
} DELETEFILE16;
typedef DELETEFILE16 UNALIGNED *PDELETEFILE16;

typedef struct _SETLASTERROR16 {                           /* k147 */
    DWORD dwError;
} SETLASTERROR16;
typedef SETLASTERROR16 UNALIGNED *PSETLASTERROR16;

#ifdef NULLSTRUCT
typedef struct _GETLASTERROR16 {                           /* k148 */
} GETLASTERROR16;
typedef GETLASTERROR16 UNALIGNED *PGETLASTERROR16;
#endif

typedef struct _GETVERSIONEX16 {                           /* k149 */
    VPVOID lpVersionInfo;
} GETVERSIONEX16;
typedef GETVERSIONEX16 UNALIGNED *PGETVERSIONEX16;

typedef struct _DIRECTEDYIELD16 {                          /* k150 */
    WORD    hTask16;
} DIRECTEDYIELD16;
typedef DIRECTEDYIELD16 UNALIGNED *PDIRECTEDYIELD16;

typedef struct _WOWFILEREAD16 {                            /* k151 */
    DWORD lpSFT;
    DWORD lpPDB;
    DWORD bufsize;
    DWORD lpBuf;
    WORD  fh;
} WOWFILEREAD16;
typedef WOWFILEREAD16 UNALIGNED *PWOWFILEREAD16;

typedef struct _WOWFILELSEEK16 {                           /* k152 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  mode;
    DWORD fileOffset;
    WORD  fh;
} WOWFILELSEEK16;
typedef WOWFILELSEEK16 UNALIGNED *PWOWFILELSEEK16;

typedef struct _WOWKERNELTRACE16 {                         /* k153 */
    DWORD lpUserArgs;
    WORD  cParms;
    VPSTR lpRoutineName;
} WOWKERNELTRACE16;
typedef WOWKERNELTRACE16 UNALIGNED *PWOWKERNELTRACE16;

typedef struct _LOADLIBRARYEX32W16 {                       /* k154 */
    DWORD  dwFlags;
    DWORD  hFile;
    VPVOID lpszLibFile;
} LOADLIBRARYEX32W16;
typedef LOADLIBRARYEX32W16 UNALIGNED *PLOADLIBRARYEX32W16;

typedef struct _WOWQUERYPERFORMANCECOUNTER16 {             /* k155 */
    VPVOID lpPerformanceFrequency;
    VPVOID lpPerformanceCounter;
} WOWQUERYPERFORMANCECOUNTER16;
typedef WOWQUERYPERFORMANCECOUNTER16 UNALIGNED *PWOWQUERYPERFORMANCECOUNTER16;

typedef struct _WOWCURSORICONOP16 {                        /* k156 */
    WORD   wFuncId;
    WORD   h16;
} WOWCURSORICONOP16;
typedef WOWCURSORICONOP16 UNALIGNED *PWOWCURSORICONOP16;

typedef struct _WOWCLOSECOMPORT16 {                        /* k159 */
    WORD    wPortId;
} WOWCLOSECOMPORT16;
typedef WOWCLOSECOMPORT16 UNALIGNED *PWOWCLOSECOMPORT16;

typedef struct _LOCAL32INIT16 {                            /* k160 */
    DWORD dwFlags;
    DWORD dwcbMax;
    DWORD dwcbInit;
    WORD  wSel;
} LOCAL32INIT16;
typedef LOCAL32INIT16 UNALIGNED *PLOCAL32INIT16;

typedef struct _LOCAL32ALLOC16 {                           /* k161 */
    DWORD dwFlags;
    WORD  wType;
    DWORD dwcbRequest;
    WORD  wSel;
} LOCAL32ALLOC16;
typedef LOCAL32ALLOC16 UNALIGNED *PLOCAL32ALLOC16;

typedef struct _LOCAL32REALLOC16 {                         /* k162 */
    DWORD dwFlags;
    DWORD dwcbNew;
    WORD  wType;
    DWORD dwMem;
    DWORD dwLinHeader;
} LOCAL32REALLOC16;
typedef LOCAL32REALLOC16 UNALIGNED *PLOCAL32REALLOC16;

typedef struct _LOCAL32FREE16 {                            /* k163 */
    WORD  wType;
    DWORD dwMem;
    DWORD dwLinHeader;
} LOCAL32FREE16;
typedef LOCAL32FREE16 UNALIGNED *PLOCAL32FREE16;

typedef struct _LOCAL32TRANSLATE16 {                       /* k164 */
    WORD  wRetType;
    WORD  wMemType;
    DWORD dwMem;
    DWORD dwLinHeader;
} LOCAL32TRANSLATE16;
typedef LOCAL32TRANSLATE16 UNALIGNED *PLOCAL32TRANSLATE16;

typedef struct _LOCAL32SIZE16 {                            /* k165 */
    WORD  wType;
    DWORD dwMem;
    DWORD dwLinHeader;
} LOCAL32SIZE16;
typedef LOCAL32SIZE16 UNALIGNED *PLOCAL32SIZE16;

typedef struct _LOCAL32VALIDHANDLE16 {                     /* k166 */
    WORD  hMem;
    DWORD dwLinHeader;
} LOCAL32VALIDHANDLE16;
typedef LOCAL32VALIDHANDLE16 UNALIGNED *PLOCAL32VALIDHANDLE16;

typedef struct _REGENUMKEY3216 {                           /* k167 */
    DWORD  cchName;
    VPSTR  lpszName;
    DWORD  iSubKey;
    DWORD  hKey;
} REGENUMKEY3216;
typedef REGENUMKEY3216 UNALIGNED *PREGENUMKEY3216;

typedef struct _REGOPENKEY3216 {                           /* k168 */
    VPVOID  phkResult;
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGOPENKEY3216;
typedef REGOPENKEY3216 UNALIGNED *PREGOPENKEY3216;

typedef struct _REGCREATEKEY3216 {                         /* k169 */
    VPVOID  phkResult;
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGCREATEKEY3216;
typedef REGCREATEKEY3216 UNALIGNED *PREGCREATEKEY3216;

typedef struct _REGDELETEKEY3216 {                         /* k170 */
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGDELETEKEY3216;
typedef REGDELETEKEY3216 UNALIGNED *PREGDELETEKEY3216;

typedef struct _REGCLOSEKEY3216 {                          /* k171 */
    DWORD  hKey;
} REGCLOSEKEY3216;
typedef REGCLOSEKEY3216 UNALIGNED *PREGCLOSEKEY3216;

typedef struct _REGSETVALUE3216 {                          /* k172 */
    DWORD   cbValue;
    VPSTR   lpValue;
    DWORD   dwType;
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGSETVALUE3216;
typedef REGSETVALUE3216 UNALIGNED *PREGSETVALUE3216;

typedef struct _REGDELETEVALUE3216 {                       /* k173 */
    VPSTR   lpszValue;
    DWORD   hKey;
} REGDELETEVALUE3216;
typedef REGDELETEVALUE3216 UNALIGNED *PREGDELETEVALUE3216;

typedef struct _REGENUMVALUE3216 {                         /* k174 */
    VPVOID lpcbData;
    VPVOID lpbData;
    DWORD  lpdwType;
    DWORD  lpdwReserved;
    DWORD  lpcchValue;
    VPSTR  lpszValue;
    DWORD  iValue;
    DWORD  hKey;
} REGENUMVALUE3216;
typedef REGENUMVALUE3216 UNALIGNED *PREGENUMVALUE3216;

typedef struct _WOWLFNFRAMEPTR16 {                         /* k204 */
    VPVOID lpUserFrame;
} WOWLFNFRAMEPTR16;
typedef WOWLFNFRAMEPTR16 UNALIGNED *PWOWLFNFRAMEPTR16;

typedef struct _REGQUERYVALUE3216 {                        /* k175 */
    DWORD   cbValue;
    VPSTR   lpValue;
    VPSTR   lpszSubKey;
    DWORD   hKey;
} REGQUERYVALUE3216;
typedef REGQUERYVALUE3216 UNALIGNED *PREGQUERYVALUE3216;

typedef struct _REGQUERYVALUEEX3216 {                      /* k176 */
    DWORD   cbBuffer;
    VPSTR   lpBuffer;
    VPDWORD vpdwType;
    VPDWORD vpdwReserved;
    VPSTR   lpszValue;
    DWORD   hKey;
} REGQUERYVALUEEX3216;
typedef REGQUERYVALUEEX3216 UNALIGNED *PREGQUERYVALUEEX3216;

typedef struct _REGSETVALUEEX3216 {                        /* k177 */
    DWORD   cbBuffer;
    VPSTR   lpBuffer;
    DWORD   dwType;
    DWORD   dwReserved;
    VPSTR   lpszValue;
    DWORD   hKey;
} REGSETVALUEEX3216;
typedef REGSETVALUEEX3216 UNALIGNED *PREGSETVALUEEX3216;

typedef struct _REGFLUSHKEY3216 {                          /* k178 */
    DWORD   hKey;
} REGFLUSHKEY3216;
typedef REGFLUSHKEY3216 UNALIGNED *PREGFLUSHKEY3216;

typedef struct _COMPUTEOBJECTOWNER16 {                     /* k179 */
    WORD wSel;
} COMPUTEOBJECTOWNER16;
typedef COMPUTEOBJECTOWNER16 UNALIGNED *PCOMPUTEOBJECTOWNER16;

typedef struct _LOCAL32GETSEL16 {                          /* k180 */
    DWORD dwLinHeader;
} LOCAL32GETSEL16;
typedef LOCAL32GETSEL16 UNALIGNED *PLOCAL32GETSEL16;

typedef struct _MAPPROCESSHANDLE16 {                       /* k181 */
    DWORD dwHandle;
} MAPPROCESSHANDLE16;
typedef MAPPROCESSHANDLE16 UNALIGNED *PMAPPROCESSHANDLE16;

#ifdef NULLSTRUCT
typedef struct _INVALIDATENLSCACHE16 {                     /* k182 */
} INVALIDATENLSCACHE16;
typedef INVALIDATENLSCACHE16 UNALIGNED *PINVALIDATENLSCACHE16;
#endif

typedef struct _WOWDELFILE16 {                             /* k183 */
    VPSTR lpFile;
} WOWDELFILE16;
typedef WOWDELFILE16 UNALIGNED *PWOWDELFILE16;

#ifdef  RENAMEVIRTUAL

typedef struct _WOWVIRTUALALLOC16 {                        /* k184 */
    DWORD fdwProtect;
    DWORD fdwAllocationType;
    DWORD cbSize;
    DWORD lpvAddress;
} WOWVIRTUALALLOC16;
typedef WOWVIRTUALALLOC16 UNALIGNED *PWOWVIRTUALALLOC16;

typedef struct _WOWVIRTUALFREE16 {                         /* k185 */
    DWORD fdwFreeType;
    DWORD cbSize;
    DWORD lpvAddress;
} WOWVIRTUALFREE16;
typedef WOWVIRTUALFREE16 UNALIGNED *PWOWVIRTUALFREE16;

#else   // RENAMEVIRTUAL

typedef struct _VIRTUALALLOC16 {                        /* k184 */
    DWORD fdwProtect;
    DWORD fdwAllocationType;
    DWORD cbSize;
    DWORD lpvAddress;
} VIRTUALALLOC16;
typedef VIRTUALALLOC16 UNALIGNED *PVIRTUALALLOC16;

typedef struct _VIRTUALFREE16 {                         /* k185 */
    DWORD fdwFreeType;
    DWORD cbSize;
    DWORD lpvAddress;
} VIRTUALFREE16;
typedef VIRTUALFREE16 UNALIGNED *PVIRTUALFREE16;

#endif  // else renamevirtual

typedef struct _VIRTUALLOCK16 {                            /* k186 */
    DWORD cbSize;
    DWORD lpvAddress;
} VIRTUALLOCK16;
typedef VIRTUALLOCK16 UNALIGNED *PVIRTUALLOCK16;

typedef struct _VIRTUALUNLOCK16 {                          /* k187 */
    DWORD cbSize;
    DWORD lpvAddress;
} VIRTUALUNLOCK16;
typedef VIRTUALUNLOCK16 UNALIGNED *PVIRTUALUNLOCK16;

typedef struct _GLOBALMEMORYSTATUS16 {                     /* k188 */
    VPVOID lpmstMemStat;
} GLOBALMEMORYSTATUS16;
typedef GLOBALMEMORYSTATUS16 UNALIGNED *PGLOBALMEMORYSTATUS16;

typedef struct _WOWGETTABLEOFFSETS16 {                     /* k190 */
    VPVOID  vpThunkTableOffsets;
} WOWGETTABLEOFFSETS16;
typedef WOWGETTABLEOFFSETS16 UNALIGNED *PWOWGETTABLEOFFSETS16;

typedef struct _WOWKILLREMOTETASK16 {                      /* k191 */
    VPVOID  lpBuffer;
} WOWKILLREMOTETASK16;
typedef WOWKILLREMOTETASK16 UNALIGNED *PWOWKILLREMOTETASK16;

typedef struct _WOWNOTIFYWOW3216 {                         /* k192 */
    VPVOID  Int21Handler;
    VPVOID  lpnum_tasks;
    VPVOID  lpcurTDB;
    VPVOID  lpDebugWOW;
    VPVOID  lpLockTDB;
    VPVOID  lptopPDB;
    VPVOID  lpCurDirOwner;
} WOWNOTIFYWOW3216;
typedef WOWNOTIFYWOW3216 UNALIGNED *PWOWNOTIFYWOW3216;

typedef struct _WOWFILEOPEN16 {                            /* k193 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  wAccess;
    WORD  pszPathOffset;
    WORD  pszPathSegment;
} WOWFILEOPEN16;
typedef WOWFILEOPEN16 UNALIGNED *PWOWFILEOPEN16;

typedef struct _WOWFILECLOSE16 {                           /* k194 */
    DWORD lpSFT;
    DWORD lpPDB;
    WORD  hFile;
} WOWFILECLOSE16;
typedef WOWFILECLOSE16 UNALIGNED *PWOWFILECLOSE16;

typedef struct _KSYSERRORBOX16 {                           /* k196 */
    SHORT sBtn3;
    SHORT sBtn2;
    SHORT sBtn1;
    VPSZ  vpszCaption;
    VPSZ  vpszText;
} KSYSERRORBOX16;
typedef KSYSERRORBOX16 UNALIGNED *PKSYSERRORBOX16;

typedef struct _WOWISKNOWNDLL16 {                          /* k197 */
    VPVOID lplpszKnownDLLPath;
    VPVOID lpszPath;
} WOWISKNOWNDLL16;

typedef struct _WOWDDEFREEHANDLE16 {                       /* k198 */
    WORD   h16;
} WOWDDEFREEHANDLE16;
typedef WOWDDEFREEHANDLE16 UNALIGNED *PWOWDDEFREEHANDLE16;

typedef struct _WOWFILEGETATTRIBUTES16 {                   /* k199 */
    WORD  pszPathOffset;
    WORD  pszPathSegment;
} WOWFILEGETATTRIBUTES16;
typedef WOWFILEGETATTRIBUTES16 UNALIGNED *PWOWFILEGETATTRIBUTES16;

typedef struct _WOWSETDEFAULTDRIVE16 {                     /* k200 */
    WORD  wDriveNum;
} WOWSETDEFAULTDRIVE16;
typedef WOWSETDEFAULTDRIVE16 UNALIGNED *PWOWSETDEFAULTDRIVE16;

typedef struct _WOWGETCURRENTDIRECTORY16 {                 /* k201 */
    DWORD lpCurDir;
    WORD  wDriveNum;
} WOWGETCURRENTDIRECTORY16;
typedef WOWGETCURRENTDIRECTORY16 UNALIGNED *PWOWGETCURRENTDIRECTORY16;

typedef struct _GETPRODUCTNAME16 {                         /* k202 */
    WORD  cbBuffer;
    VPSTR lpBuffer;
} GETPRODUCTNAME16;
typedef GETPRODUCTNAME16 UNALIGNED *PGETPRODUCTNAME16;

#ifdef NULLSTRUCT
typedef struct _ISSAFEMODE16 {                             /* k203 */
} ISSAFEMODE16;
typedef ISSAFEMODE16 UNALIGNED *PISSAFEMODE16;
#endif

typedef struct _WOWSHUTDOWNTIMER16 {                       /* k205 */
    WORD fEnable;
} WOWSHUTDOWNTIMER16;
typedef WOWSHUTDOWNTIMER16 UNALIGNED *PWOWSHUTDOWNTIMER16;

#ifdef NULLSTRUCT
typedef struct _WOWTRIMWORKINGSET16 {                   /* k206 */
} WOWTRIMWORKINGSET16;
typedef WOWTRIMWORKINGSET16 UNALIGNED *PWOWTRIMWORKINGSET16;
#endif

#ifdef FE_SB
#ifdef NULLSTRUCT
typedef struct _GETSYSTEMDEFAULTLANGID16 {                   /* k207 */
} GETSYSTEMDEFAULTLANGID16;
typedef GETSYSTEMDEFAULTLANGID16 UNALIGNED *PGETSYSTEMDEFAULTLANGID16;
#endif
#endif

typedef struct _TERMSRVGETWINDIR16 {                            /* k208 */
    WORD  usPathLen;
    WORD  pszPathOffset;
    WORD  pszPathSegment;
} TERMSRVGETWINDIR16;
typedef TERMSRVGETWINDIR16 UNALIGNED *PTERMSRVGETWINDIR16;

/*
typedef struct _WOWGETCURRENTDIRECTORYLONG16 {             // k209
    DWORD lpCurDir;
    WORD  wDriveNum;
    WORD  cchDir;
} WOWGETCURRENTDIRECTORYLONG16;
typedef WOWGETCURRENTDIRECTORYLONG16 UNALIGNED *PWOWGETCURRENTDIRECTORYLONG16;
*/

typedef struct _WOWPASSENVIRONMENT16 {                        /* k209 */
    WORD   pExe;    // pointer to exe header
    DWORD  pParmBlk; // parameter block
    WORD   cur_DOS_PDB; // dos pdb
//     WORD   Win_PDB;  // windows pdb not necessary for now
} WOWPASSENVIRONMENT16;
typedef WOWPASSENVIRONMENT16 UNALIGNED *PWOWPASSENVIRONMENT16;

typedef struct _VWIN32 {                    /* k211 */
    DWORD  dwEDI;
    DWORD  dwESI;
    DWORD  dwEBP;
    DWORD  dwESP;
    DWORD  dwEBX;
    DWORD  dwEDX;
    DWORD  dwECX;
    DWORD  dwEAX;
    WORD   wSS;
    WORD   wUnused;
} VWIN32;
typedef VWIN32 UNALIGNED *PVWIN32;

typedef struct _STACKINT2F {                  /* k213 */
    DWORD  dwEDI;
    DWORD  dwESI;
    DWORD  dwEBP;
    DWORD  dwESP;
    WORD   wBX;
    WORD   wHBX;
    DWORD  dwEDX;
    DWORD  dwECX;
    BYTE   bAL;
    BYTE   bAH;
    WORD   wHAX;
    WORD   wES;
    WORD   wDS;
    WORD   wIP;
    WORD   wCS;
    WORD   wFlags;
} STACKINT2F;
typedef STACKINT2F UNALIGNED *PSTACKINT2F;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowint.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1992, Microsoft Corporation
 *
 *  WOWINT.H
 *  16-bit Internal API argument structures
 *
 *  History:
 *  Created 22-Apr-1992 by FritzS
 *
--*/

#define FUN_SETTABLE		 0 //


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _WOWSETTABLE16 { 	    /* i0 */
    VPSZ f1;
} WOWSETTABLE16, *PWOWSETTABLE16;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowmmcb.h ===
/* --------------------------------------------------------------------
** Module       : wowmmcb.h
**
** Description  : Interrupt callback stuff for Multi-Media.
**
** History:     : Created 09-Nov-1992 by StephenE
**
** --------------------------------------------------------------------
*/
#ifndef WOWMMCB_H
#define WOWMMCB_H

/*
** This header file will go through both 16 bit and 32 bit compilers.
** In 16 bit land UNALIGNED is not required, on 32 bit land UNALIGNED
** would have been #defined by the time this file was #included because
** this file is always included after wow32.h.  This means the following
** #define is always a no-op with 16 bit compilers and ignored with
** 32 bit compilers.
*/
#ifndef UNALIGNED
#define UNALIGNED
#endif

extern void call_ica_hw_interrupt(int, int, int);

/* --------------------------------------------------------------------
**  Hardware Interrupts:
**
**  IRQ:     Interrupt: ICA: Line: Description:
**  -------------------------------------------------------------------
**  IRQ0     0x08       0    0     Timer Tick every 18.2 times per second.
**  IRQ1     0x09       0    1     Keyboard service required.
**  IRQ2     0x0A       0    2     INT from slave 8259A.
**  IRQ8     0x70       1    0         Real time clock service.
**  IRQ9     0x71       1    1         Software redirected to IRQ2.
**  IRQ10    0x72       1    2         Reserved.
**  IRQ11    0x73       1    3         Reserved.
**  IRQ12    0x74       1    4         Reserved.
**  IRQ13    0x75       1    5         Numeric co-processor
**  IRQ14    0x76       1    6         Fixed disk controller
**  IRQ15    0x77       1    7         Reserved.
**  IRQ3     0x0B       0    3     Com2 service request.
**  IRQ4     0x0C       0    4     Com1 service request.
**  IRQ5     0x0D       0    5     Data request from LPT2:
**  IRQ6     0x0E       0    6     Floppy disk service required.
**  IRQ7     0x0F       0    7     Data request from LPT1:
**
** --------------------------------------------------------------------
*/

#ifdef  NEC_98
#define MULTIMEDIA_LINE         4
#define MULTIMEDIA_ICA          1
#define MULTIMEDIA_INTERRUPT    0x14
#else   // NEC_98
#define MULTIMEDIA_LINE         2
#define MULTIMEDIA_ICA          1
#define MULTIMEDIA_INTERRUPT    0x72
#endif  // NEC_98

#define CALLBACK_ARGS_SIZE      16

typedef struct _CALLBACK_ARGS {   /* cbargs */
    DWORD       dwFlags;        // Flags to identify the type of callback.
    DWORD       dwFunctionAddr; // 16:16 address of the function to be called
    WORD        wHandle;        // The handle or ID of the device
    WORD        wMessage;       // The message to be passed to function
    DWORD       dwInstance;     // User data
    DWORD       dwParam1;       // Device data 1
    DWORD       dwParam2;       // Device data 2
} CALLBACK_ARGS;

typedef struct _CALLBACK_DATA {   /* cbdata */
    WORD            wRecvCount;    // The number of interrupts received
    WORD            wSendCount;    // The number of interrupts sent
    CALLBACK_ARGS   args[CALLBACK_ARGS_SIZE];  // Interrupt arguments
    WORD            wIntsCount;    // The number of interrupts received
} CALLBACK_DATA;

typedef CALLBACK_DATA FAR *VPCALLBACK_DATA;         // 16:16 pointer type
typedef CALLBACK_ARGS FAR *VPCALLBACK_ARGS;         // 16:16 pointer type

typedef CALLBACK_DATA UNALIGNED *PCALLBACK_DATA;    //  0:32 pointer type
typedef CALLBACK_ARGS UNALIGNED *PCALLBACK_ARGS;    //  0:32 pointer type

VOID FAR PASCAL Notify_Callback_Data( VPCALLBACK_DATA vpCallbackData );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowmmed.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWMMED.H
 *  16-bit MultiMedia API argument structures
 *
 *  History:
 *  Created 21-Jan-1992 by Mike Tricker (MikeTri), based on the work by jeffpar
--*/
/*++

  General MultiMedia related information

  Moved all the typedefs for H* and VP* back to WOW.H  - MikeTri 090492

--*/

typedef WORD    MMVER16;      // major (high byte), minor (low byte)

#ifndef _INC_MMSYSTEM
typedef DWORD   FOURCC;         // a four character code
typedef LONG    LPARAM;
#endif

#define MAXPNAMELEN      32     // max product name length (including NULL)

/* XLATOFF */
#pragma pack(1)
/* XLATON */


/*
 * MultiMedia Data Structures - MikeTri 10-Feb-1992
 *
 */


typedef struct _AUXCAPS16 {           /* ac16 */
    WORD        wMid;
    WORD        wPid;
    MMVER16   vDriverVersion;
    char        szPname[MAXPNAMELEN];
    WORD        wTechnology;
    DWORD       dwSupport;
} AUXCAPS16;
typedef AUXCAPS16 UNALIGNED *PAUXCAPS16;
typedef VPVOID  VPAUXCAPS16;

typedef struct _DRVCONFIGINFO16 {        /* dci16 */
    DWORD   dwDCISize;
    VPCSTR  lpszDCISectionName;
    VPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO16;
typedef DRVCONFIGINFO16 UNALIGNED *PDRVCONFIGINFO16;
typedef VPVOID  VPDRVCONFIGINFO16;

typedef struct _JOYCAPS16 {              /* jc16 */
    WORD    wMid;
    WORD    wPid;
    char    szPname[MAXPNAMELEN];
    WORD    wXmin;
    WORD    wXmax;
    WORD    wYmin;
    WORD    wYmax;
    WORD    wZmin;
    WORD    wZmax;
    WORD    wNumButtons;
    WORD    wPeriodMin;
    WORD    wPeriodMax;
} JOYCAPS16;
typedef JOYCAPS16 UNALIGNED *PJOYCAPS16;
typedef VPVOID  VPJOYCAPS16;

typedef struct _JOYINFO16 {              /* ji16 */
    WORD    wXpos;
    WORD    wYpos;
    WORD    wZpos;
    WORD    wButtons;
} JOYINFO16;
typedef JOYINFO16 UNALIGNED *PJOYINFO16;
typedef VPVOID  VPJOYINFO16;

typedef struct _MCI_ANIM_OPEN_PARMS16 {  /* maop16 */
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    VPCSTR  lpstrDeviceType;
    VPCSTR  lpstrElementName;
    VPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND16  hWndParent;    // Keeps consistent, and is equivalent anyway
    WORD    wReserved1;
} MCI_ANIM_OPEN_PARMS16;
typedef MCI_ANIM_OPEN_PARMS16 UNALIGNED *PMCI_ANIM_OPEN_PARMS16;
typedef VPVOID  VPMCI_ANIM_OPEN_PARMS16;

typedef struct _MCI_ANIM_PLAY_PARMS16 {  /* mapp16 */
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS16;
typedef MCI_ANIM_PLAY_PARMS16 UNALIGNED *PMCI_ANIM_PLAY_PARMS16;
typedef VPVOID  VPMCA_ANIM_PLAY_PARMS16;

typedef struct _MCI_ANIM_RECT_PARMS16 {  /* marp16 */
    DWORD   dwCallback;
    RECT16  rc;
} MCI_ANIM_RECT_PARMS16;
typedef MCI_ANIM_RECT_PARMS16 UNALIGNED *PMCI_ANIM_RECT_PARMS16;
typedef VPVOID  VPMCI_ANIM_RECT_PARMS16;

typedef struct _MCI_ANIM_STEP_PARMS16 {  /* masp16 */
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS16;
typedef MCI_ANIM_STEP_PARMS16 UNALIGNED *PMCI_ANIM_STEP_PARMS16;
typedef VPVOID  VPMCI_ANIM_STEP_PARMS16;

typedef struct _MCI_ANIM_UPDATE_PARMS16 { /* maup16 */
    DWORD   dwCalback;
    RECT16  rc;
    HDC16   hDC;
} MCI_ANIM_UPDATE_PARMS16;
typedef MCI_ANIM_UPDATE_PARMS16 UNALIGNED *PMCI_ANIM_UPDATE_PARMS16;
typedef VPVOID  VPMCI_ANIM_UPDATE_PARMS16;

typedef struct _MCI_ANIM_WINDOW_PARMS16 { /* mawp16 */
    DWORD   dwCallabck;
    HWND16  hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    VPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS16;
typedef MCI_ANIM_WINDOW_PARMS16 UNALIGNED *PMCI_ANIM_WINDOW_PARMS16;
typedef VPVOID  VPMCI_ANIM_WINDOW_PARMS16;

typedef struct _MCI_BREAK_PARMS16 {       /* mbp16 */
    DWORD  dwCallback;
    INT16  nVirtKey;
    WORD   wReserved0;
    HWND16 hwndBreak;
    WORD   wReserved1;
} MCI_BREAK_PARMS16;
typedef MCI_BREAK_PARMS16 UNALIGNED *PMCI_BREAK_PARMS16;
typedef VPVOID  VPMCI_BREAK_PARMS16;

typedef struct _MCI_GENERIC_PARMS16 {     /* mgp16 */
    DWORD   dwCallback;
} MCI_GENERIC_PARMS16;
typedef MCI_GENERIC_PARMS16 UNALIGNED *PMCI_GENERIC_PARMS16;
typedef VPVOID  VPMCI_GENERIC_PARMS16;

typedef struct _MCI_GETDEVCAPS_PARMS16 {  /* mgdp16 */
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS16;
typedef MCI_GETDEVCAPS_PARMS16 UNALIGNED *PMCI_GETDEVCAPS_PARMS16;
typedef VPVOID  VPMCI_GETDEVCAPS_PARMS16;

typedef struct _MCI_INFO_PARMS16 {        /* mip16 */
    DWORD   dwCallback;
    VPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS16;
typedef MCI_INFO_PARMS16 UNALIGNED *PMCI_INFO_PARMS16;
typedef VPVOID  VPMCI_INFO_PARMS16;

typedef struct _MCI_LOAD_PARMS16 {        /* mlp16 */
    DWORD   dwCallback;
    VPCSTR  lpfilename;
} MCI_LOAD_PARMS16;
typedef MCI_LOAD_PARMS16 UNALIGNED *PMCI_LOAD_PARMS16;
typedef VPVOID  VPMCI_LOAD_PARMS16;

typedef struct _MCI_OPEN_PARMS16 {        /* mop16 */
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    VPCSTR  lpstrDeviceType;
    VPCSTR  lpstrElementName;
    VPCSTR  lpstrAlias;
} MCI_OPEN_PARMS16;
typedef MCI_OPEN_PARMS16 UNALIGNED *PMCI_OPEN_PARMS16;
typedef VPVOID  VPMCI_OPEN_PARMS16;

typedef struct _MCI_OVLY_LOAD_PARMS16 {   /* molp16 */
    DWORD   dwCallback;
    VPCSTR  lpfilename;
    RECT16  rc;
} MCI_OVLY_LOAD_PARMS16;
typedef MCI_OVLY_LOAD_PARMS16 UNALIGNED *PMCI_OVLY_LOAD_PARMS16;
typedef VPVOID  VPMCI_OVLY_LOAD_PARMS16;

typedef struct _MCI_OVLY_OPEN_PARMS16 {   /* moop16 */
    DWORD   dwCallabck;
    WORD    wDeviceID;
    WORD    wReserved0;
    VPCSTR  lpstrDeviceType;
    VPCSTR  lpstrElementName;
    VPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND16  hWndParent;  // The book is wrong
    WORD    wReserved1;
} MCI_OVLY_OPEN_PARMS16;
typedef MCI_OVLY_OPEN_PARMS16 UNALIGNED *PMCI_OVLY_OPEN_PARMS16;
typedef VPVOID  VPMCI_OVLY_OPEN_PARMS16;

typedef struct _MCI_OVLY_RECT_PARMS16 {   /* morp16 */
    DWORD   dwCallback;
    RECT16  rc;
} MCI_OVLY_RECT_PARMS16;
typedef MCI_OVLY_RECT_PARMS16 UNALIGNED *PMCI_OVLY_RECT_PARMS16;
typedef VPVOID  VPMCI_OVLY_RECT_PARMS16;

typedef struct _MCI_OVLY_SAVE_PARMS16 {   /* mosp16 */
    DWORD   dwCallback;
    VPCSTR  lpfilename;
    RECT16  rc;
} MCI_OVLY_SAVE_PARMS16;
typedef MCI_OVLY_SAVE_PARMS16 UNALIGNED *PMCI_OVLY_SAVE_PARMS16;
typedef VPVOID  VPMCI_OVLY_SAVE_PARMS16;

typedef struct _MCI_OVLY_WINDOW_PARMS16 { /* mowp16 */
    DWORD   dwCallabck;
    HWND16  hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    VPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS16;
typedef MCI_OVLY_WINDOW_PARMS16 UNALIGNED *PMCI_OVLY_WINDOW_PARMS16;
typedef VPVOID  VPMCI_OVLY_WINDOW_PARMS16;

typedef struct _MCI_PLAY_PARMS16 {        /* mplp16 */
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS16;
typedef MCI_PLAY_PARMS16 UNALIGNED *PMCI_PLAY_PARMS16;
typedef VPVOID  VPMCI_PLAY_PARMS16;

typedef struct _MCI_RECORD_PARMS16 {      /* mrecp16 */
    DWORD   dwCallabck;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS16;
typedef MCI_RECORD_PARMS16 UNALIGNED *PMCI_RECORD_PARMS16;
typedef VPVOID  VPMCI_RECORD_PARMS16;

typedef struct _MCI_SAVE_PARMS16 {        /* msavp16 */
    DWORD   dwCallback;
    VPCSTR  lpfilename;   // MMSYSTEM.H differs from the book
} MCI_SAVE_PARMS16;
typedef MCI_SAVE_PARMS16 UNALIGNED *PMCI_SAVE_PARMS16;
typedef VPVOID  VPMCI_SAVE_PARMS16;

typedef struct _MCI_SEEK_PARMS16 {        /* msep16 */
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS16;
typedef MCI_SEEK_PARMS16 UNALIGNED *PMCI_SEEK_PARMS16;
typedef VPVOID  VPMCI_SEEK_PARMS16;

typedef struct _MCI_SEQ_SET_PARMS16 {     /* mssp16 */
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS16;
typedef MCI_SEQ_SET_PARMS16 UNALIGNED *PMCI_SEQ_SET_PARMS16;
typedef VPVOID  VPMCI_SEQ_SET_PARMS16;

typedef struct _MCI_SET_PARMS16 {         /* msetp16 */
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS16;
typedef MCI_SET_PARMS16 UNALIGNED *PMCI_SET_PARMS16;
typedef VPVOID  VPMCI_SET_PARMS16;

typedef struct _MCI_SOUND_PARMS16 {       /* msoup16 */
    DWORD   dwCallback;
    VPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS16;
typedef MCI_SOUND_PARMS16 UNALIGNED *PMCI_SOUND_PARMS16;
typedef VPVOID  VPMCI_SOUND_PARMS16;

typedef struct _MCI_STATUS_PARMS16 {      /* mstp16 */
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS16;
typedef MCI_STATUS_PARMS16 UNALIGNED *PMCI_STATUS_PARMS16;
typedef VPVOID  VPMCI_STATUS_PARMS16;

typedef struct _MCI_SYSINFO_PARMS16 {     /* msyip16 */
    DWORD   dwCallback;
    VPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS16;
typedef MCI_SYSINFO_PARMS16 UNALIGNED *PMCI_SYSINFO_PARMS16;
typedef VPVOID  VPMCI_SYSINFO_PARMS16;

typedef struct _MCI_VD_ESCAPE_PARMS16 {   /* mvep16 */
    DWORD   dwCallback;
    VPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS16;
typedef MCI_VD_ESCAPE_PARMS16 UNALIGNED *PMCI_VD_ESCAPE_PARMS16;
typedef VPVOID  VPMCI_VD_ESCAPE_PARMS16;

typedef struct _MCI_VD_PLAY_PARMS16 {     /* mvpp16 */
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS16;
typedef MCI_VD_PLAY_PARMS16 UNALIGNED *PMCI_VD_PLAY_PARMS16;
typedef VPVOID  VPMCI_VD_PLAY_PARMS16;

typedef struct _MCI_VD_STEP_PARMS16 {     /* mvsp16 */
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS16;
typedef MCI_VD_STEP_PARMS16 UNALIGNED *PMCI_VD_STEP_PARMS16;
typedef VPVOID  VPMCI_VD_STEP_PARMS16;

typedef struct _MCI_VD_DELETE_PARMS16 {   /* mvdp16 */
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VD_DELETE_PARMS16;
typedef MCI_VD_DELETE_PARMS16 UNALIGNED *PMCI_VD_DELETE_PARMS16;
typedef VPVOID  VPMCI_VD_DELETE_PARMS16;

typedef struct _MCI_WAVE_OPEN_PARMS16 {   /* mwop16 */
    DWORD   dwCallback;
    WORD    wDeviceID;
    WORD    wReserved0;
    VPCSTR  lpstrDeviceType;
    VPCSTR  lpstrElementName;
    VPCSTR  lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS16;
typedef MCI_WAVE_OPEN_PARMS16 UNALIGNED *PMCI_WAVE_OPEN_PARMS16;
typedef VPVOID  VPMCI_WAVE_OPEN_PARMS16;

typedef struct _MCI_WAVE_SET_PARMS16 {    /* mwsp16 */
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSecond;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS16;
typedef MCI_WAVE_SET_PARMS16 UNALIGNED *PMCI_WAVE_SET_PARMS16;
typedef VPVOID  VPMCI_WAVE_SET_PARMS16;

typedef struct _MIDIHDR16 {               /* mhdr16 */
    VPSTR   lpData;
    DWORD   dwBufferLength;
    DWORD   dwBytesRecorded;
    DWORD   dwUser;
    DWORD   dwFlags;
    struct  _MIDIHDR16 far *lpNext;
    DWORD   reserved;
} MIDIHDR16;
typedef MIDIHDR16 UNALIGNED *PMIDIHDR16;
typedef VPVOID  VPMIDIHDR16;

typedef struct _MIDIINCAPS16 {            /* mic16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
} MIDIINCAPS16;
typedef MIDIINCAPS16 UNALIGNED *PMIDIINCAPS16;
typedef VPVOID  VPMIDIINCAPS16;

typedef struct _MIDIOUTCAPS16 {           /* moc16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    WORD    wTechnology;
    WORD    wVoices;
    WORD    wNotes;
    WORD    wChannelMask;
    DWORD   dwSupport;
} MIDIOUTCAPS16;
typedef MIDIOUTCAPS16 UNALIGNED *PMIDIOUTCAPS16;
typedef VPVOID VPMIDIOUTCAPS16;

typedef struct _MMCKINFO16 {              /* mcki16 */
    FOURCC  ckid;
    DWORD   cksize;
    FOURCC  fccType;
    DWORD   dwDataOffset;
    DWORD   dwFlags;
} MMCKINFO16;
typedef MMCKINFO16 UNALIGNED *PMMCKINFO16;
typedef VPVOID VPMMCKINFO16;

typedef struct _MMIOINFO16 {              /* mioi16 */
    DWORD   dwFlags;
    FOURCC  fccIOProc;
    VPMMIOPROC16  pIOProc;
    WORD    wErrorRet;
    HTASK16 htask;        // Header file MMSYSTEM.H differs from book
    LONG    cchBuffer;
    VPSTR   pchBuffer;
    VPSTR   pchNext;
    VPSTR   pchEndRead;
    VPSTR   pchEndWrite;
    LONG    lBufOffset;
    LONG    lDiskOffset;
    DWORD   adwInfo[3];   // The book says [4], MMSYSTEM.H doesn't
    DWORD   dwReserved1;
    DWORD   dwReserved2;
    HMMIO16 hmmio;
} MMIOINFO16;
typedef MMIOINFO16 UNALIGNED *PMMIOINFO16;
typedef VPVOID  VPMMIOINFO16;

typedef struct _MMPACTION16 {             /* mpa16 */
    BYTE    bMenuItem;
    BYTE    bActionCode;
    WORD    wTextOffset;
} MMPACTION16;
typedef MMPACTION16 UNALIGNED *PMMPACTION16;
typedef VPVOID  VPMMPACTION16;

typedef struct _MMPLABEL16 {              /* mpl16 */
    WORD    wFrameNum;
    WORD    wTextOffset;
} MMPLABEL16;
typedef MMPLABEL16 UNALIGNED *PMMPLABEL16;
typedef VPVOID  VPMMPLABEL16;

typedef struct _MMPMOVIEINFO16 {          /* mpmi16 */
    DWORD   dwFileVersion;
    DWORD   dwTotalFrames;
    DWORD   dwInitialFramesPerSecond;
    WORD    wPixelDepth;
    DWORD   dwMovieExtentX;
    DWORD   dwMovieExtentY;
    char    chFullMacName[128];
} MMPMOVIEINFO16;
typedef MMPMOVIEINFO16 UNALIGNED *PMMPMOVIEINFO16;
typedef VPVOID  VPMMPMOVIEINFO16;

/* XLATOFF */
typedef struct _MMTIME16 {                /* mmt16 */
    WORD    wType;
    union {
        DWORD   ms;
        DWORD   sample;
        DWORD   cb;
        struct {
            BYTE    hour;
            BYTE    min;
            BYTE    sec;
            BYTE    frame;
            BYTE    fps;
            BYTE    dummy;
        } smpte;
        struct {
            DWORD   songptrpos;
        } midi;
    } u;
} MMTIME16;
typedef MMTIME16 UNALIGNED *PMMTIME16;
/* XLATON */
typedef VPVOID  VPMMTIME16;

typedef struct _TIMECAPS16 {              /* timc16 */
    WORD    wPeriodMin;
    WORD    wPeriodMax;
} TIMECAPS16;
typedef TIMECAPS16 UNALIGNED *PTIMECAPS16;
typedef VPVOID  VPTIMECAPS16;

typedef struct _WAVEFORMAT16 {            /* wft16 */
    WORD    wFormatTag;
    WORD    nChannels;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
} WAVEFORMAT16;
typedef WAVEFORMAT16 UNALIGNED *PWAVEFORMAT16;
typedef VPVOID  VPWAVEFORMAT16;

typedef struct _PCMWAVEFORMAT16 {         /* pwf16 */
    WAVEFORMAT16  wf;
    WORD          wBitsPerSample;
} PCMWAVEFORMAT16;
typedef PCMWAVEFORMAT16 UNALIGNED *PPCMWAVEFORMAT16;
typedef VPVOID  VPPCMWAVEFORMAT16;

typedef struct _WAVEHDR16 {               /* whd16 */
    VPSTR   lpData;
    DWORD   dwBufferLength;
    DWORD   dwBytesRecorded;
    DWORD   dwUser;
    DWORD   dwFlags;
    DWORD   dwLoops;
    struct _WAVEHDR16 far *lpNext;
    DWORD   reserved;
} WAVEHDR16;
typedef WAVEHDR16 UNALIGNED *PWAVEHDR16;
typedef VPVOID  VPWAVEHDR16;

typedef struct _WAVEINCAPS16 {            /* wic16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    DWORD   dwFormats;
    WORD    wChannels;
} WAVEINCAPS16;
typedef WAVEINCAPS16 UNALIGNED *PWAVEINCAPS16;
typedef VPVOID  VPWAVEINCAPS16;

typedef struct _WAVEOUTCAPS16 {           /* woc16 */
    WORD    wMid;
    WORD    wPid;
    MMVER16 vDriverVersion;
    char    szPname[MAXPNAMELEN];
    DWORD   dwFormats;
    WORD    wChannels;
    DWORD   dwSupport;
} WAVEOUTCAPS16;
typedef WAVEOUTCAPS16 UNALIGNED *PWAVEOUTCAPS16;
typedef VPVOID  VPWAVEOUTCAPS16;

/* XLATOFF */
#pragma pack()
/* XLATON */

/*
 * MultiMedia Window messages - MikeTri 10-Feb-1992
 */

//#define MM_JOY1MOVE         0x03A0   // Joystick
//#define MM_JOY2MOVE         0x03A1
//#define MM_JOY1ZMOVE        0x03A2
//#define MM_JOY2ZMOVE        0x03A3
//#define MM_JOY1BUTTONDOWN   0x03B5
//#define MM_JOY2BUTTONDOWN   0x03B6
//#define MM_JOY1BUTTONUP     0x03B7
//#define MM_JOY2BUTTONUP     0x03B8

//#define MM_MCINOTIFY        0x03B9  // MCI
//#define MM_MCISYSTEM_STRING 0x03CA

//#define MM_WOM_OPEN         0x03BB  // Waveform Output
//#define MM_WOM_CLOSE        0x03BC
//#define MM_WOM_DONE         0x03BD

//#define MM_WIM_OPEN         0x03BE  // Waveform Input
//#define MM_WIM_CLOSE        0x03BF
//#define MM_WIM_DATA         0x03C0

//#define MM_MIM_OPEN         0x03C1  // MIDI Input
//#define MM_MIM_CLOSE        0x03C2
//#define MM_MIM_DATA         0x03C3
//#define MM_MIM_LONGDATA     0x03C4
//#define MM_MIM_ERROR        0x03C5
//#define MM_MIM_LONGERROR    0x03C6

//#define MM_MOM_OPEN         0x03C7  // MIDI Output
//#define MM_MOM_CLOSE        0x03C8
//#define MM_MOM_DONE         0x03C9

/*
 * End of MultiMedia Window messages - MikeTri
 */

/*++

  MultiMedia API IDs - start adding all the other APIs - Mike, 04-Feb-1992

  This is the complete exported list, in MMSYSTEM order

  Well, actually it isn't anymore - various ones have been removed which
  we aren't supporting, and because of the joys of H2INC I can't leave them
  here as comments. So - if they need to be added again check in the
  function prototypes below this list for the correct formats.

  Need to recheck the numbers before compiling this lot... - this raises the
  point that if we add any more they ought to go at the end of the list,
  otherwise we end up juggling numbers, which is a drag.

--*/


#define FUN_MMCALLPROC32                  2 //
#define FUN_MMSYSTEMGETVERSION            5 //

#define FUN_OUTPUTDEBUGSTR                30 //
#define FUN_DRIVERCALLBACK                31 //
#define FUN_NOTIFY_CALLBACK_DATA          32 //

#define FUN_JOYGETNUMDEVS                 101 //
#define FUN_JOYGETDEVCAPS                 102 //
#define FUN_JOYGETPOS                     103 //
#define FUN_JOYGETTHRESHOLD               104 //
#define FUN_JOYRELEASECAPTURE             105 //
#define FUN_JOYSETCAPTURE                 106 //
#define FUN_JOYSETTHRESHOLD               107 //
#define FUN_JOYSETCALIBRATION             109 //

#define FUN_MIDIOUTGETNUMDEVS             201 //
#define FUN_MIDIOUTGETDEVCAPS             202 //
#define FUN_MIDIOUTGETERRORTEXT           203 //
#define FUN_MIDIOUTOPEN                   204 //
#define FUN_MIDIOUTCLOSE                  205 //
#define FUN_MIDIOUTPREPAREHEADER32        206 //
#define FUN_MIDIOUTUNPREPAREHEADER32      207 //
#define FUN_MIDIOUTSHORTMSG               208 //
#define FUN_MIDIOUTLONGMSG                209 //
#define FUN_MIDIOUTRESET                  210 //
#define FUN_MIDIOUTGETVOLUME              211 //
#define FUN_MIDIOUTSETVOLUME              212 //
#define FUN_MIDIOUTCACHEPATCHES           213 //
#define FUN_MIDIOUTCACHEDRUMPATCHES       214 //
#define FUN_MIDIOUTGETID                  215 //
#define FUN_MIDIOUTMESSAGE32              216 //

#define FUN_MIDIINGETNUMDEVS              301 //
#define FUN_MIDIINGETDEVCAPS              302 //
#define FUN_MIDIINGETERRORTEXT            303 //
#define FUN_MIDIINOPEN                    304 //
#define FUN_MIDIINCLOSE                   305 //
#define FUN_MIDIINPREPAREHEADER32         306 //
#define FUN_MIDIINUNPREPAREHEADER32       307 //
#define FUN_MIDIINADDBUFFER               308 //
#define FUN_MIDIINSTART                   309 //
#define FUN_MIDIINSTOP                    310 //
#define FUN_MIDIINRESET                   311 //
#define FUN_MIDIINGETID                   312 //
#define FUN_MIDIINMESSAGE32               313 //

#define FUN_AUXGETNUMDEVS                 350 //
#define FUN_AUXGETDEVCAPS                 351 //
#define FUN_AUXGETVOLUME                  352 //
#define FUN_AUXSETVOLUME                  353 //
#define FUN_AUXOUTMESSAGE32               354 //

#define FUN_WAVEOUTGETNUMDEVS             401 //
#define FUN_WAVEOUTGETDEVCAPS             402 //
#define FUN_WAVEOUTGETERRORTEXT           403 //
#define FUN_WAVEOUTOPEN                   404 //
#define FUN_WAVEOUTCLOSE                  405 //
#define FUN_WAVEOUTPREPAREHEADER32        406 //
#define FUN_WAVEOUTUNPREPAREHEADER32      407 //
#define FUN_WAVEOUTWRITE                  408 //
#define FUN_WAVEOUTPAUSE                  409 //
#define FUN_WAVEOUTRESTART                410 //
#define FUN_WAVEOUTRESET                  411 //
#define FUN_WAVEOUTGETPOSITION            412 //
#define FUN_WAVEOUTGETPITCH               413 //
#define FUN_WAVEOUTSETPITCH               414 //
#define FUN_WAVEOUTGETVOLUME              415 //
#define FUN_WAVEOUTSETVOLUME              416 //
#define FUN_WAVEOUTGETPLAYBACKRATE        417 //
#define FUN_WAVEOUTSETPLAYBACKRATE        418 //
#define FUN_WAVEOUTBREAKLOOP              419 //
#define FUN_WAVEOUTGETID                  420 //
#define FUN_WAVEOUTMESSAGE32              421 //

#define FUN_WAVEINGETNUMDEVS              501 //
#define FUN_WAVEINGETDEVCAPS              502 //
#define FUN_WAVEINGETERRORTEXT            503 //
#define FUN_WAVEINOPEN                    504 //
#define FUN_WAVEINCLOSE                   505 //
#define FUN_WAVEINPREPAREHEADER32         506 //
#define FUN_WAVEINUNPREPAREHEADER32       507 //
#define FUN_WAVEINADDBUFFER               508 //
#define FUN_WAVEINSTART                   509 //
#define FUN_WAVEINSTOP                    510 //
#define FUN_WAVEINRESET                   511 //
#define FUN_WAVEINGETPOSITION             512 //
#define FUN_WAVEINGETID                   513 //
#define FUN_WAVEINMESSAGE32               514 //

#define FUN_TIMEGETSYSTEMTIME             601 //
#define FUN_TIMEGETTIME                   607 //
#define FUN_TIMESETEVENT                  602 //
#define FUN_TIMEKILLEVENT                 603 //
#define FUN_TIMEGETDEVCAPS                604 //
#define FUN_TIMEBEGINPERIOD               605 //
#define FUN_TIMEENDPERIOD                 606 //

#define FUN_MCISENDCOMMAND                701 //
#define FUN_MCISENDSTRING                 702 //
#define FUN_MCIGETDEVICEID                703 //
#define FUN_MCIGETERRORSTRING             706 //
#define FUN_MCIEXECUTE                    712 //
#define FUN_MCISETYIELDPROC               714 //
#define FUN_MCIGETDEVICEIDFROMELEMENTID   715 //
#define FUN_MCIGETYIELDPROC               716 //
#define FUN_MCIGETCREATORTASK             717 //

#define FUN_MMIOOPEN                      1210 //
#define FUN_MMIOCLOSE                     1211 //
#define FUN_MMIOREAD                      1212 //
#define FUN_MMIOWRITE                     1213 //
#define FUN_MMIOSEEK                      1214 //
#define FUN_MMIOGETINFO                   1215 //
#define FUN_MMIOSETINFO                   1216 //
#define FUN_MMIOSETBUFFER                 1217 //
#define FUN_MMIOFLUSH                     1218 //
#define FUN_MMIOADVANCE                   1219 //
#define FUN_MMIOSTRINGTOFOURCC            1220 //
#define FUN_MMIOINSTALLIOPROC             1221 //
#define FUN_MMIOSENDMESSAGE               1222 //

#define FUN_MMIODESCEND                   1223 //
#define FUN_MMIOASCEND                    1224 //
#define FUN_MMIOCREATECHUNK               1225 //
#define FUN_MMIORENAME                    1226 //

/* XLATOFF */
#pragma pack(2)
/* XLATON */

/*++

  Function prototypes - the seemingly unimportant number in the comment on
  each function MUST match the ones in the list above - otherwise you will
  turn into a frog, and 16 bit MultiMedia will wave its feet in the air...

  !! BE WARNED !!

--*/

typedef struct _MMCALLPROC3216 {    /* mm2 */
    DWORD fSetCurrentDirectory;     /* Set the current directory ? */
    DWORD lpProcAddress;            /* function to call */
    DWORD p1;                       /* dwParam2     */
    DWORD p2;                       /* dwParam1     */
    DWORD p3;                       /* dwInstance   */
    DWORD p4;                       /* uMsg         */
    DWORD p5;                       /* uDevId       */
} MMCALLPROC3216;
typedef MMCALLPROC3216 UNALIGNED *PMMCALLPROC3216;


#ifdef NULLSTRUCT
typedef struct _MMSYSTEMGETVERSION16 {         /* mm5 */
} MMSYSTEMGETVERSION16;
typedef MMSYSTEMGETVERSION16 UNALIGNED *PMMSYSTEMGETVERSION;
#endif

typedef struct _OUTPUTDEBUGSTR16 {             /* mm30 */
    VPSTR      f1;
} OUTPUTDEBUGSTR16;
typedef OUTPUTDEBUGSTR16 UNALIGNED *POUTPUTDEBUGSTR16;

typedef struct _DRIVERCALLBACK16 {             /* mm31 */
    DWORD      f7;
    DWORD      f6;
    DWORD      f5;
    DWORD      f4;
    HDRVR16    f3;
    DWORD      f2;
    DWORD      f1;
} DRIVERCALLBACK16;
typedef DRIVERCALLBACK16 UNALIGNED *PDRIVERCALLBACK16;


typedef struct _NOTIFY_CALLBACK_DATA16 {       /* mm32 */
    VPCALLBACK_DATA f1;
} NOTIFY_CALLBACK_DATA16;
typedef NOTIFY_CALLBACK_DATA16 UNALIGNED *PNOTIFY_CALLBACK_DATA16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef NULLSTRUCT
typedef struct _STACKLEAVE16 {                  mm33
} STACKLEAVE16;
typedef STACKLEAVE16 UNALIGNED *PSTACKLEAVE16;
#endif

------------------------------------------------------------------------------*/

#ifdef NULLSTRUCT
typedef struct _JOYGETNUMDEVS16 {              /* mm101 */
} JOYGETNUMDEVS16;
typedef JOYGETNUMDEVS16 UNALIGNED *PJOYGETNUMDEVS16;
#endif

typedef struct _JOYGETDEVCAPS16 {              /* mm102 */
    WORD         f3;
    VPJOYCAPS16  f2;
    WORD         f1;
} JOYGETDEVCAPS16;
typedef JOYGETDEVCAPS16 UNALIGNED *PJOYGETDEVCAPS16;

typedef struct _JOYGETPOS16 {                  /* mm103 */
    VPJOYINFO16  f2;
    WORD         f1;
} JOYGETPOS16;
typedef JOYGETPOS16 UNALIGNED *PJOYGETPOS16;

typedef struct _JOYGETTHRESHOLD16 {            /* mm104 */
    VPWORD     f2;
    WORD       f1;
} JOYGETTHRESHOLD16;
typedef JOYGETTHRESHOLD16 UNALIGNED *PJOYGETTHRESHOLD16;

typedef struct _JOYRELEASECAPTURE16 {          /* mm105 */
    WORD       f1;
} JOYRELEASECAPTURE16;
typedef JOYRELEASECAPTURE16 UNALIGNED *PJOYRELEASECAPTURE16;

typedef struct _JOYSETCAPTURE16 {              /* mm106 */
    BOOL16     f4;
    WORD       f3;
    WORD       f2;
    HWND16     f1;
} JOYSETCAPTURE16;
typedef JOYSETCAPTURE16 UNALIGNED *PJOYSETCAPTURE16;

typedef struct _JOYSETTHRESHOLD16 {            /* mm107 */
    WORD       f2;
    WORD       f1;
} JOYSETTHRESHOLD16;
typedef JOYSETTHRESHOLD16 UNALIGNED *PJOYSETTHRESHOLD16;

typedef struct _JOYSETCALIBRATION16 {          /* mm109 */
    VPWORD     f7;
    VPWORD     f6;
    VPWORD     f5;
    VPWORD     f4;
    VPWORD     f3;
    VPWORD     f2;
    WORD       f1;
} JOYSETCALIBRATION16;
typedef JOYSETCALIBRATION16 UNALIGNED *PJOYSETCALIBRATION16;

#ifdef NULLSTRUCT
typedef struct _MIDIOUTGETNUMDEVS16 {          /* mm201 */
} MIDIOUTGETNUMDEVS16;
typedef MIDIOUTGETNUMDEVS16 UNALIGNED *PMIDIOUTGETNUMDEVS16;
#endif

typedef struct _MIDIOUTGETDEVCAPS16 {          /* mm202 */
    WORD            f3;
    VPMIDIOUTCAPS16 f2;
    WORD            f1;
} MIDIOUTGETDEVCAPS16;
typedef MIDIOUTGETDEVCAPS16 UNALIGNED *PMIDIOUTGETDEVCAPS16;

typedef struct _MIDIOUTGETERRORTEXT16 {        /* mm203 */
    WORD       f3;
    VPSTR      f2;
    WORD       f1;
} MIDIOUTGETERRORTEXT16;
typedef MIDIOUTGETERRORTEXT16 UNALIGNED *PMIDIOUTGETERRORTEXT16;

typedef struct _MIDIOUTOPEN16 {                /* mm204 */
    DWORD         f5;
    DWORD         f4;
    DWORD         f3;
    WORD          f2;
    VPHMIDIOUT16  f1;
} MIDIOUTOPEN16;
typedef MIDIOUTOPEN16 UNALIGNED *PMIDIOUTOPEN16;

typedef struct _MIDIOUTCLOSE16 {               /* mm205 */
    HMIDIOUT16    f1;
} MIDIOUTCLOSE16;
typedef MIDIOUTCLOSE16 UNALIGNED *PMIDIOUTCLOSE16;

typedef struct _MIDIOUTPREPAREHEADER3216 {       /* mm206 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIOUT16   f1;
} MIDIOUTPREPAREHEADER3216;
typedef MIDIOUTPREPAREHEADER3216 UNALIGNED *PMIDIOUTPREPAREHEADER3216;

typedef struct _MIDIOUTUNPREPAREHEADER3216 {     /* mm207 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIOUT16   f1;
} MIDIOUTUNPREPAREHEADER3216;
typedef MIDIOUTUNPREPAREHEADER3216 UNALIGNED *PMIDIOUTUNPREPAREHEADER3216;

typedef struct _MIDIOUTSHORTMSG16 {            /* mm208 */
    DWORD      f2;
    HMIDIOUT16 f1;
} MIDIOUTSHORTMSG16;
typedef MIDIOUTSHORTMSG16 UNALIGNED *PMIDIOUTSHORTMSG16;

typedef struct _MIDIOUTLONGMSG16 {             /* mm209 */
    WORD        f3;
    VPMIDIHDR16 f2;
    HMIDIOUT16  f1;
} MIDIOUTLONGMSG16;
typedef MIDIOUTLONGMSG16 UNALIGNED *PMIDIOUTLONGMSG16;

typedef struct _MIDIOUTRESET16 {               /* mm210 */
    HMIDIOUT16  f1;
} MIDIOUTRESET16;
typedef MIDIOUTRESET16 UNALIGNED *PMIDIOUTRESET16;

typedef struct _MIDIOUTGETVOLUME16 {           /* mm211 */
    VPDWORD    f2;
    WORD       f1;
} MIDIOUTGETVOLUME16;
typedef MIDIOUTGETVOLUME16 UNALIGNED *PMIDIOUTGETVOLUME16;

typedef struct _MIDIOUTSETVOLUME16 {           /* mm212 */
    DWORD      f2;
    WORD       f1;
} MIDIOUTSETVOLUME16;
typedef MIDIOUTSETVOLUME16 UNALIGNED *PMIDIOUTSETVOLUME16;

typedef struct _MIDIOUTCACHEPATCHES16 {        /* mm213 */
    WORD            f4;
    VPPATCHARRAY16  f3;
    WORD            f2;
    HMIDIOUT16      f1;
} MIDIOUTCACHEPATCHES16;
typedef MIDIOUTCACHEPATCHES16 UNALIGNED *PMIDIOUTCACHEPATCHES16;

typedef struct _MIDIOUTCACHEDRUMPATCHES16 {    /* mm214 */
    WORD            f4;
    VPKEYARRAY16    f3;
    WORD            f2;
    HMIDIOUT16      f1;
} MIDIOUTCACHEDRUMPATCHES16;
typedef MIDIOUTCACHEDRUMPATCHES16 UNALIGNED *PMIDIOUTCACHEDRUMPATCHES16;

typedef struct _MIDIOUTGETID16 {               /* mm215 */
    VPWORD          f2;
    HMIDIOUT16      f1;
} MIDIOUTGETID16;
typedef MIDIOUTGETID16 UNALIGNED *PMIDIOUTGETID16;

typedef struct _MIDIOUTMESSAGE3216 {             /* mm216 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    HMIDIOUT16 f1;
} MIDIOUTMESSAGE3216;
typedef MIDIOUTMESSAGE3216 UNALIGNED *PMIDIOUTMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _MIDIINGETNUMDEVS16 {           /* mm301 */
} MIDIINGETNUMDEVS16;
typedef MIDIINGETNUMDEVS16 UNALIGNED *PMIDIINGETNUMDEVS16;
#endif

typedef struct _MIDIINGETDEVCAPS16 {           /* mm302 */
    WORD            f3;
    VPMIDIINCAPS16  f2;
    WORD            f1;
} MIDIINGETDEVCAPS16;
typedef MIDIINGETDEVCAPS16 UNALIGNED *PMIDIINGETDEVCAPS16;

typedef struct _MIDIINGETERRORTEXT16 {         /* mm303 */
    WORD       f3;
    VPSTR      f2;
    WORD       f1;
} MIDIINGETERRORTEXT16;
typedef MIDIINGETERRORTEXT16 UNALIGNED *PMIDIINGETERRORTEXT16;

typedef struct _MIDIINOPEN16 {                 /* mm304 */
    DWORD         f5;
    DWORD         f4;
    DWORD         f3;
    WORD          f2;
    VPHMIDIIN16   f1;
} MIDIINOPEN16;
typedef MIDIINOPEN16 UNALIGNED *PMIDIINOPEN16;

typedef struct _MIDIINCLOSE16 {                /* mm305 */
    HMIDIIN16  f1;
} MIDIINCLOSE16;
typedef MIDIINCLOSE16 UNALIGNED *PMIDIINCLOSE16;

typedef struct _MIDIINPREPAREHEADER3216 {        /* mm306 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIIN16    f1;
} MIDIINPREPAREHEADER3216;
typedef MIDIINPREPAREHEADER3216 UNALIGNED *PMIDIINPREPAREHEADER3216;

typedef struct _MIDIINUNPREPAREHEADER3216 {      /* mm307 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIIN16    f1;
} MIDIINUNPREPAREHEADER3216;
typedef MIDIINUNPREPAREHEADER3216 UNALIGNED *PMIDIINUNPREPAREHEADER3216;

typedef struct _MIDIINADDBUFFER16 {            /* mm308 */
    WORD         f3;
    VPMIDIHDR16  f2;
    HMIDIIN16    f1;
} MIDIINADDBUFFER16;
typedef MIDIINADDBUFFER16 UNALIGNED *PMIDIINADDBUFFER16;

typedef struct _MIDIINSTART16 {                /* mm309 */
    HMIDIIN16  f1;
} MIDIINSTART16;
typedef MIDIINSTART16 UNALIGNED *PMIDIINSTART16;

typedef struct _MIDIINSTOP16 {                 /* mm310 */
    HMIDIIN16  f1;
} MIDIINSTOP16;
typedef MIDIINSTOP16 UNALIGNED *PMIDIINSTOP16;

typedef struct _MIDIINRESET16 {                /* mm311 */
    HMIDIIN16  f1;
} MIDIINRESET16;
typedef MIDIINRESET16 UNALIGNED *PMIDIINRESET16;

typedef struct _MIDIINGETID16 {                /* mm312 */
    VPWORD     f2;
    HMIDIIN16  f1;
} MIDIINGETID16;
typedef MIDIINGETID16 UNALIGNED *PMIDIINGETID16;

typedef struct _MIDIINMESSAGE3216 {              /* mm313 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    HMIDIIN16  f1;
} MIDIINMESSAGE3216;
typedef MIDIINMESSAGE3216 UNALIGNED *PMIDIINMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _AUXGETNUMDEVS16 {              /* mm350 */
} AUXGETNUMDEVS16;
typedef AUXGETNUMDEVS16 UNALIGNED *PAUGGETNUMDEVS16;
#endif

typedef struct _AUXGETDEVCAPS16 {              /* mm351 */
    WORD         f3;
    VPAUXCAPS16  f2;
    WORD         f1;
} AUXGETDEVCAPS16;
typedef AUXGETDEVCAPS16 UNALIGNED *PAUXGETDEVCAPS16;

typedef struct _AUXGETVOLUME16 {               /* mm352 */
    VPDWORD    f2;
    WORD       f1;
} AUXGETVOLUME16;
typedef AUXGETVOLUME16 UNALIGNED *PAUXGETVOLUME16;

typedef struct _AUXSETVOLUME16 {               /* mm353 */
    DWORD      f2;
    WORD       f1;
} AUXSETVOLUME16;
typedef AUXSETVOLUME16 UNALIGNED *PAUXSETVOLUME16;

typedef struct _AUXOUTMESSAGE3216 {              /* mm354 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    WORD       f1;
} AUXOUTMESSAGE3216;
typedef AUXOUTMESSAGE3216 UNALIGNED *PAUXOUTMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _WAVEOUTGETNUMDEVS16 {          /* mm401 */
} WAVEOUTGETNUMDEVS16;
typedef WAVEOUTGETNUMDEVS16 UNALIGNED *PWAVEOUTGETNUMDEVS16;
#endif

typedef struct _WAVEOUTGETDEVCAPS16 {          /* mm402 */
    WORD             f3;
    VPWAVEOUTCAPS16  f2;
    WORD             f1;
} WAVEOUTGETDEVCAPS16;
typedef WAVEOUTGETDEVCAPS16 UNALIGNED *PWAVEOUTGETDEVCAPS16;

typedef struct _WAVEOUTGETERRORTEXT16 {        /* mm403 */
    WORD       f3;
    VPSTR      f2;
    WORD       f1;
} WAVEOUTGETERRORTEXT16;
typedef WAVEOUTGETERRORTEXT16 UNALIGNED *PWAVEOUTGETERRORTEXT16;

typedef struct _WAVEOUTOPEN16 {                /* mm404 */
    DWORD           f6;
    DWORD           f5;
    DWORD           f4;
    VPWAVEFORMAT16  f3;
    WORD            f2;
    VPHWAVEOUT16   f1;
} WAVEOUTOPEN16;
typedef WAVEOUTOPEN16 UNALIGNED *PWAVEOUTOPEN16;

typedef struct _WAVEOUTCLOSE16 {               /* mm405 */
    HWAVEOUT16 f1;
} WAVEOUTCLOSE16;
typedef WAVEOUTCLOSE16 UNALIGNED *PWAVEOUTCLOSE16;

typedef struct _WAVEOUTPREPAREHEADER3216 {       /* mm406 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEOUT16   f1;
} WAVEOUTPREPAREHEADER3216;
typedef WAVEOUTPREPAREHEADER3216 UNALIGNED *PWAVEOUTPREPAREHEADER3216;

typedef struct _WAVEOUTUNPREPAREHEADER3216 {     /* mm407 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEOUT16   f1;
} WAVEOUTUNPREPAREHEADER3216;
typedef WAVEOUTUNPREPAREHEADER3216 UNALIGNED *PWAVEOUTUNPREPAREHEADER3216;

typedef struct _WAVEOUTWRITE16 {               /* mm408 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEOUT16   f1;
} WAVEOUTWRITE16;
typedef WAVEOUTWRITE16 UNALIGNED *PWAVEOUTWRITE16;

typedef struct _WAVEOUTPAUSE16 {               /* mm409 */
    HWAVEOUT16   f1;
} WAVEOUTPAUSE16;
typedef WAVEOUTPAUSE16 UNALIGNED *PWAVEOUTPAUSE16;

typedef struct _WAVEOUTRESTART16 {             /* mm410 */
    HWAVEOUT16   f1;
} WAVEOUTRESTART16;
typedef WAVEOUTRESTART16 UNALIGNED *PWAVEOUTRESTART16;

typedef struct _WAVEOUTRESET16 {               /* mm411 */
    HWAVEOUT16   f1;
} WAVEOUTRESET16;
typedef WAVEOUTRESET16 UNALIGNED *PWAVEOUTRESET16;

typedef struct _WAVEOUTGETPOSITION16 {         /* mm412 */
    WORD         f3;
    VPMMTIME16   f2;
    HWAVEOUT16   f1;
} WAVEOUTGETPOSITION16;
typedef WAVEOUTGETPOSITION16 UNALIGNED *PWAVEOUTGETPOSITION16;

typedef struct _WAVEOUTGETPITCH16 {            /* mm413 */
    VPDWORD      f2;
    HWAVEOUT16   f1;
} WAVEOUTGETPITCH16;
typedef WAVEOUTGETPITCH16 UNALIGNED *PWAVEOUTGETPITCH16;

typedef struct _WAVEOUTSETPITCH16 {            /* mm414 */
    DWORD        f2;
    HWAVEOUT16   f1;
} WAVEOUTSETPITCH16;
typedef WAVEOUTSETPITCH16 UNALIGNED *PWAVEOUTSETPITCH16;

typedef struct _WAVEOUTGETVOLUME16 {           /* mm415 */
    VPDWORD    f2;
    WORD       f1;
} WAVEOUTGETVOLUME16;
typedef WAVEOUTGETVOLUME16 UNALIGNED *PWAVEOUTGETVOLUME16;

typedef struct _WAVEOUTSETVOLUME16 {           /* mm416 */
    DWORD      f2;
    WORD       f1;
} WAVEOUTSETVOLUME16;
typedef WAVEOUTSETVOLUME16 UNALIGNED *PWAVEOUTSETVOLUME16;

typedef struct _WAVEOUTGETPLAYBACKRATE16 {     /* mm417 */
    VPDWORD      f2;
    HWAVEOUT16   f1;
} WAVEOUTGETPLAYBACKRATE16;
typedef WAVEOUTGETPLAYBACKRATE16 UNALIGNED *PWAVEOUTGETPLAYBACKRATE16;

typedef struct _WAVEOUTSETPLAYBACKRATE16 {     /* mm418 */
    DWORD        f2;
    HWAVEOUT16   f1;
} WAVEOUTSETPLAYBACKRATE16;
typedef WAVEOUTSETPLAYBACKRATE16 UNALIGNED *PWAVEOUTSETPLAYBACKRATE16;

typedef struct _WAVEOUTBREAKLOOP16 {           /* mm419 */
    HWAVEOUT16   f1;
} WAVEOUTBREAKLOOP16;
typedef WAVEOUTBREAKLOOP16 UNALIGNED *PWAVEOUTBREAKLOOP16;

typedef struct _WAVEOUTGETID16 {               /* mm420 */
    VPWORD       f2;
    HWAVEOUT16   f1;
} WAVEOUTGETID16;
typedef WAVEOUTGETID16 UNALIGNED *PWAVEOUTGETID16;

typedef struct _WAVEOUTMESSAGE3216 {             /* mm421 */
    DWORD        f4;
    DWORD        f3;
    WORD         f2;
    HWAVEOUT16   f1;
} WAVEOUTMESSAGE3216;
typedef WAVEOUTMESSAGE3216 UNALIGNED *PWAVEOUTMESSAGE3216;

#ifdef NULLSTRUCT
typedef struct _WAVEINGETNUMDEVS16 {           /* mm501 */
} WAVEINGETNUMDEVS16;
typedef WAVEINGETNUMDEVS16 UNALIGNED *PWAVEINGETNUMDEVS16;
#endif

typedef struct _WAVEINGETDEVCAPS16 {           /* mm502 */
    WORD            f3;
    VPWAVEINCAPS16  f2;
    WORD            f1;
} WAVEINGETDEVCAPS16;
typedef WAVEINGETDEVCAPS16 UNALIGNED *PWAVEINGETDEVCAPS16;

typedef struct _WAVEINGETERRORTEXT16 {         /* mm503 */
    WORD       f3;
    VPSTR      f2;
    WORD       f1;
} WAVEINGETERRORTEXT16;
typedef WAVEINGETERRORTEXT16 UNALIGNED *PWAVEINGETERRORTEXT16;

typedef struct _WAVEINOPEN16 {                 /* mm504 */
    DWORD           f6;
    DWORD           f5;
    DWORD           f4;
    VPWAVEFORMAT16  f3;
    WORD            f2;
    VPHWAVEIN16    f1;
} WAVEINOPEN16;
typedef WAVEINOPEN16 UNALIGNED *PWAVEINOPEN16;

typedef struct _WAVEINCLOSE16 {                /* mm505 */
    HWAVEIN16  f1;
} WAVEINCLOSE16;
typedef WAVEINCLOSE16 UNALIGNED *PWAVEINCLOSE16;

typedef struct _WAVEINPREPAREHEADER3216 {        /* mm506 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEIN16    f1;
} WAVEINPREPAREHEADER3216;
typedef WAVEINPREPAREHEADER3216 UNALIGNED *PWAVEINPREPAREHEADER3216;

typedef struct _WAVEINUNPREPAREHEADER3216 {      /* mm507 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEIN16    f1;
} WAVEINUNPREPAREHEADER3216;
typedef WAVEINUNPREPAREHEADER3216 UNALIGNED *PWAVEINUNPREPAREHEADER3216;

typedef struct _WAVEINADDBUFFER16 {            /* mm508 */
    WORD         f3;
    VPWAVEHDR16  f2;
    HWAVEIN16    f1;
} WAVEINADDBUFFER16;
typedef WAVEINADDBUFFER16 UNALIGNED *PWAVEINADDBUFFER16;

typedef struct _WAVEINSTART16 {                /* mm509 */
    HWAVEIN16    f1;
} WAVEINSTART16;
typedef WAVEINSTART16 UNALIGNED *PWAVEINSTART16;

typedef struct _WAVEINSTOP16 {                 /* mm510 */
    HWAVEIN16    f1;
} WAVEINSTOP16;
typedef WAVEINSTOP16 UNALIGNED *PWAVEINSTOP16;

typedef struct _WAVEINRESET16 {                /* mm511 */
    HWAVEIN16    f1;
} WAVEINRESET16;
typedef WAVEINRESET16 UNALIGNED *PWAVEINRESET16;

typedef struct _WAVEINGETPOSITION16 {          /* mm512 */
    WORD       f3;
    VPMMTIME16 f2;
    HWAVEIN16  f1;
} WAVEINGETPOSITION16;
typedef WAVEINGETPOSITION16 UNALIGNED *PWAVEINGETPOSITION16;

typedef struct _WAVEINGETID16 {                /* mm513 */
    VPWORD     f2;
    HWAVEIN16  f1;
} WAVEINGETID16;
typedef WAVEINGETID16 UNALIGNED *PWAVEINGETID16;

typedef struct _WAVEINMESSAGE3216 {              /* mm514 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    HWAVEIN16  f1;
} WAVEINMESSAGE3216;
typedef WAVEINMESSAGE3216 UNALIGNED *PWAVEINMESSAGE3216;

typedef struct _TIMEGETSYSTEMTIME16 {          /* mm601 */
    WORD       f2;
    VPMMTIME16 f1;
} TIMEGETSYSTEMTIME16;
typedef TIMEGETSYSTEMTIME16 UNALIGNED *PTIMEGETSYSTEMTIME16;

#ifdef NULLSTRUCT
typedef struct _TIMEGETTIME16 {                /* mm607 */
} TIMEGETTIME16;
typedef TIMEGETTIME16 UNALIGNED *PTIMEGETTIME16;
#endif

typedef struct _TIMESETEVENT16 {               /* mm602 */
    WORD              f5;
    DWORD             f4;
    VPTIMECALLBACK16  f3;
    WORD              f2;
    WORD              f1;
} TIMESETEVENT16;
typedef TIMESETEVENT16 UNALIGNED *PTIMESETEVENT16;

typedef struct _TIMEKILLEVENT16 {              /* mm603 */
    WORD       f1;
} TIMEKILLEVENT16;
typedef TIMEKILLEVENT16 UNALIGNED *PTIMEKILLEVENT16;

typedef struct _TIMEGETDEVCAPS16 {             /* mm604 */
    WORD          f2;
    VPTIMECAPS16  f1;
} TIMEGETDEVCAPS16;
typedef TIMEGETDEVCAPS16 UNALIGNED *PTIMEGETDEVCAPS16;

typedef struct _TIMEBEGINPERIOD16 {            /* mm605 */
    WORD       f1;
} TIMEBEGINPERIOD16;
typedef TIMEBEGINPERIOD16 UNALIGNED *PTIMEBEGINPERIOD16;

typedef struct _TIMEENDPERIOD16 {              /* mm606 */
    WORD       f1;
} TIMEENDPERIOD16;
typedef TIMEENDPERIOD16 UNALIGNED *PTIMEENDPERIOD16;

typedef struct _MCISENDCOMMAND16 {             /* mm701 */
    DWORD      f4;
    DWORD      f3;
    WORD       f2;
    WORD       f1;
} MCISENDCOMMAND16;
typedef MCISENDCOMMAND16 UNALIGNED *PMCISENDCOMMAND16;

typedef struct _MCISENDSTRING16 {              /* mm702 */
    HWND16     f4;
    WORD       f3;
    VPSTR      f2;
    VPCSTR     f1;
} MCISENDSTRING16;
typedef MCISENDSTRING16 UNALIGNED *PMCISENDSTRING16;

typedef struct _MCIGETDEVICEID16 {             /* mm703 */
    VPCSTR     f1;
} MCIGETDEVICEID16;
typedef MCIGETDEVICEID16 UNALIGNED *PMCIGETDEVICEID16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct _MCIPARSECOMMAND16 {            mm704
    BOOL16     f6;
    VPWORD     f5;
    VPSTR      f4;
    VPCSTR     f3;
    VPSTR      f2;
    WORD       f1;
} MCIPARSECOMMAND16;
typedef MCIPARSECOMMAND16 UNALIGNED *PMCIPARSECOMMAND16;

typedef struct _MCILOADCOMMANDRESOURCE16 {     mm705
    WORD       f3;
    VPCSTR     f2;
    HAND16     f1;
} MCILOADCOMMANDRESOURCE16;
typedef MCILOADCOMMANDRESOURCE16 UNALIGNED *PMCILOADCOMMANDRESOURCE16;

------------------------------------------------------------------------------*/

typedef struct _MCIGETERRORSTRING16 {          /* mm706 */
    WORD       f3;
    VPSTR      f2;
    DWORD      f1;
} MCIGETERRORSTRING16;
typedef MCIGETERRORSTRING16 UNALIGNED *PMCIGETERRORSTRING16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct _MCISETDRIVERDATA16 {           mm707
    DWORD      f2;
    WORD       f1;
} MCISETDRIVERDATA16;
typedef MCISETDRIVERDATA16 UNALIGNED *PMCISETDRIVERDATA16;

typedef struct _MCIGETDRIVERDATA16 {           mm708
    WORD       f1;
} MCIGETDRIVERDATA16;
typedef MCIGETDRIVERDATA16 UNALIGNED *PMCIGETDRIVERDATA16;

typedef struct _MCIDRIVERYIELD16 {             mm710
    WORD       f1;
} MCIDRIVERYIELD16;
typedef MCIDRIVERYIELD16 UNALIGNED *PMCIDRIVERYIELD16;

typedef struct _MCIDRIVERNOTIFY16 {            mm711
    WORD       f3;
    WORD       f2;
    HWND16     f1;
} MCIDRIVERNOTIFY16;
typedef MCIDRIVERNOTIFY16 UNALIGNED *PMCIDRIVERNOTIFY16;

------------------------------------------------------------------------------*/

typedef struct _MCIEXECUTE16 {                 /* mm712 */
    VPCSTR     f1;
} MCIEXECUTE16;
typedef MCIEXECUTE16 UNALIGNED *PMCIEXECUTE16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

typedef struct _MCIFREECOMMANDRESOURCE16 {     mm713
    WORD       f1;
} MCIFREECOMMANDRESOURCE16;
typedef MCIFREECOMMANDRESOURCE16 UNALIGNED *PMCIFREECOMMANDRESOURCE16;

------------------------------------------------------------------------------*/

typedef struct _MCISETYIELDPROC16 {          /* mm714 */
    DWORD      f3;
    DWORD      f2; //YIELDPROC
    WORD       f1;
} MCISETYIELDPROC16;
typedef MCISETYIELDPROC16 UNALIGNED *PMCISETYIELDPROC16;


typedef struct _MCIGETDEVICEIDFROMELEMENTID16 {     /* mm715 */
    VPCSTR     f2;
    DWORD      f1;
} MCIGETDEVICEIDFROMELEMENTID16;
typedef MCIGETDEVICEIDFROMELEMENTID16 UNALIGNED *PMCIGETDEVICEIDFROMELEMENTID16;

typedef struct _MCIGETYIELDPROC16 {            /* mm716 */
    VPDWORD    f2;
    WORD       f1;
} MCIGETYIELDPROC16;
typedef MCIGETYIELDPROC16 UNALIGNED *PMCIGETYIELDPROC16;


typedef struct _MCIGETCREATORTASK16 {          /* mm717 */
    WORD       f1;
} MCIGETCREATORTASK16;
typedef MCIGETCREATORTASK16 UNALIGNED *PMCIGETCREATORTASK16;

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  The following calls have all been zapped for the time being.

typedef struct _MMTASKCREATE16 {               mm900
    DWORD             f3;
    HAND16            f2;
    VPTASKCALLBACK16  f1;
} MMTASKCREATE16;
typedef MMTASKCREATE16 UNALIGNED *PMMTASKCREATE16;

typedef struct _MMTASKBLOCK16 {                mm902
    HAND16     f1;
} MMTASKBLOCK16;
typedef MMTASKBLOCK16 UNALIGNED *PMMTASKBLOCK16;

typedef struct _MMTASKSIGNAL16 {               mm903
    HAND16     f1;
} MMTASKSIGNAL16;
typedef MMTASKSIGNAL16 UNALIGNED *PMMTASKSIGNAL16;

#ifdef NULLSTRUCT
typedef struct _MMGETCURRENTTASK16 {           mm904
} MMGETCURRENTTASK16;
typedef MMGETCURRENTTASK16 UNALIGNED *PMMGETCURRENTTASK16;
#endif

#ifdef NULLSTRUCT
typedef struct _MMTASKYIELD16 {                mm905
} MMTASKYIELD16;
typedef MMTASKYIELD16 UNALIGNED *PMMTASKYIELD16;
#endif

typedef struct _DRVCLOSE16 {                   mm1100
    DWORD         f3;
    DWORD         f2;
    HDRVR16       f1;
} DRVCLOSE16;
typedef DRVCLOSE16 UNALIGNED *PDRVCLOSE16;

typedef struct _DRVOPEN16 {                    mm1101
    DWORD         f3;
    VPSTR         f2;
    VPSTR         f1;
} DRVOPEN16;
typedef DRVOPEN16 UNALIGNED *PDRVOPEN16;

typedef struct _DRVSENDMESSAGE16 {             mm1102
    DWORD         f4;
    DWORD         f3;
    WORD          f2;
    HDRVR16       f1;
} DRVSENDMESSAGE16;
typedef DRVSENDMESSAGE16 UNALIGNED *PDRVSENDMESSAGE16;

typedef struct _DRVGETMODULEHANDLE16 {         mm1103
    HDRVR16       f1;
} DRVGETMODULEHANDLE16;
typedef DRVGETMODULEHANDLE16 UNALIGNED *PDRVGETMODULEHANDLE;

#ifdef NULLSTRUCT
typedef struct _DRVDEFDRIVERPROC16{            mm1104
} DRVDEFDRIVERPROC16;
typedef DRVDEFDRIVERPROC16 UNALIGNED *PDRVDEFDRIVERPROC;
#endif

------------------------------------------------------------------------------*/

typedef struct _MMIOOPEN16 {                   /* mm1210 */
    DWORD         f3;
    VPMMIOINFO16  f2;
    VPSTR         f1;
} MMIOOPEN16;
typedef MMIOOPEN16 UNALIGNED *PMMIOOPEN16;

typedef struct _MMIOCLOSE16 {                  /* mm1211 */
    WORD       f2;
    HMMIO16    f1;
} MMIOCLOSE16;
typedef MMIOCLOSE16 UNALIGNED *PMMIOCLOSE16;

typedef struct _MMIOREAD16 {                   /* mm1212 */
    LONG       f3;
    HPSTR16    f2;
    HMMIO16    f1;
} MMIOREAD16;
typedef MMIOREAD16 UNALIGNED *PMMIOREAD16;

typedef struct _MMIOWRITE16 {                  /* mm1213 */
    LONG       f3;
    HPSTR16    f2;
    HMMIO16    f1;
} MMIOWRITE16;
typedef MMIOWRITE16 UNALIGNED *PMMIOWRITE16;

typedef struct _MMIOSEEK16 {                   /* mm1214 */
    INT16      f3;
    LONG       f2;
    HMMIO16    f1;
} MMIOSEEK16;
typedef MMIOSEEK16 UNALIGNED *PMMIOSEEK16;

typedef struct _MMIOGETINFO16 {                /* mm1215 */
    WORD          f3;
    VPMMIOINFO16  f2;
    HMMIO16       f1;
} MMIOGETINFO16;
typedef MMIOGETINFO16 UNALIGNED *PMMIOGETINFO16;

typedef struct _MMIOSETINFO16 {                /* mm1216 */
    WORD          f3;
    VPMMIOINFO16  f2;
    HMMIO16       f1;
} MMIOSETINFO16;
typedef MMIOSETINFO16 UNALIGNED *PMMIOSETINFO16;

typedef struct _MMIOSETBUFFER16 {              /* mm1217 */
    WORD       f4;
    LONG       f3;
    VPSTR      f2;
    HMMIO16    f1;
} MMIOSETBUFFER16;
typedef MMIOSETBUFFER16 UNALIGNED *PMMIOSETBUFFER16;

typedef struct _MMIOFLUSH16 {                  /* mm1218 */
    WORD       f2;
    HMMIO16    f1;
} MMIOFLUSH16;
typedef MMIOFLUSH16 UNALIGNED *PMMIOFLUSH16;

typedef struct _MMIOADVANCE16 {                /* mm1219 */
    WORD          f3;
    VPMMIOINFO16  f2;
    HMMIO16       f1;
} MMIOADVANCE16;
typedef MMIOADVANCE16 UNALIGNED *PMMIOADVANCE16;

typedef struct _MMIOSTRINGTOFOURCC16 {         /* mm1220 */
    WORD       f2;
    VPCSTR     f1;
} MMIOSTRINGTOFOURCC16;
typedef MMIOSTRINGTOFOURCC16 UNALIGNED *PMMIOSTRINGTOFOURCC16;

typedef struct _MMIOINSTALLIOPROC16 {          /* mm1221 */
    DWORD         f3;
    VPMMIOPROC16  f2;
    FOURCC        f1;
} MMIOINSTALLIOPROC16;
typedef MMIOINSTALLIOPROC16 UNALIGNED *PMMIOINSTALLIOPROC16;

typedef struct _MMIOSENDMESSAGE16 {            /* mm1222 */
    LPARAM     f4;
    LPARAM     f3;
    WORD       f2;
    HMMIO16    f1;
} MMIOSENDMESSAGE16;
typedef MMIOSENDMESSAGE16 UNALIGNED *PMMIOSENDMESSAGE16;

typedef struct _MMIODESCEND16 {                /* mm1223 */
    WORD          f4;
    VPMMCKINFO16  f3;
    VPMMCKINFO16  f2;
    HMMIO16       f1;
} MMIODESCEND16;
typedef MMIODESCEND16 UNALIGNED *PMMIODESCEND16;

typedef struct _MMIOASCEND16 {                 /* mm1224 */
    WORD          f3;
    VPMMCKINFO16  f2;
    HMMIO16       f1;
} MMIOASCEND16;
typedef MMIOASCEND16 UNALIGNED *PMMIOASCEND16;

typedef struct _MMIOCREATECHUNK16 {            /* mm1225 */
    WORD          f3;
    VPMMCKINFO16  f2;
    HMMIO16       f1;
} MMIOCREATECHUNK16;
typedef MMIOCREATECHUNK16 UNALIGNED *PMMIOCREATECHUNK16;

typedef struct _MMIORENAME16 {                 /* mm1226 */
    DWORD        f4;
    VPMMIOINFO16 f3;
    VPCSTR       f2;
    VPCSTR       f1;
} MMIORENAME16;
typedef MMIORENAME16 UNALIGNED *PMMIORENAME16;

/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowshell.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWSHELL.H
 *  16-bit SHELL API argument structures
 *
 *  History:
 *  Created 14-April-1992 by Chandan S. Chauhan (ChandanC)
 *  Added Win95 exports 17-Oct-1996 Dave Hart (davehart)
 *
--*/

/* SHELL API IDs
 */
#define FUN_REGOPENKEY            1
#define FUN_REGCREATEKEY          2
#define FUN_REGCLOSEKEY           3
#define FUN_REGDELETEKEY          4
#define FUN_REGSETVALUE           5
#define FUN_REGQUERYVALUE         6
#define FUN_REGENUMKEY            7
#define FUN_DRAGACCEPTFILES       9
#define FUN_DRAGQUERYFILE         11
#define FUN_DRAGFINISH            12
#define FUN_DRAGQUERYPOINT        13
#define FUN_SHELLEXECUTE          20
#define FUN_FINDEXECUTABLE        21
#define FUN_SHELLABOUT            22
#define FUN_WCI                   32
#define FUN_ABOUTDLGPROC          33
#define FUN_EXTRACTICON           34
#define FUN_EXTRACTASSOCIATEDICON 36
#define FUN_DOENVIRONMENTSUBST    37
#define FUN_FINDENVIRONMENTSTRING 38
#define FUN_INTERNALEXTRACTICON   39
#define FUN_HERETHARBETYGARS      41  // export 100
#define FUN_FINDEXEDLGPROC        42  // export 101
#define FUN_REGISTERSHELLHOOK     43  // export 102
#define FUN_SHELLHOOKPROC         44  // export 103

/* New for Win95 */

#define FUN_EXTRACTICONEX         40
#define FUN_RESTARTDIALOG         45  // export 157
#define FUN_PICKICONDLG           46  // export 166
#define FUN_DRIVETYPE             47  // export 262
#define FUN_SH16TO32DRIVEIOCTL    48  // export 263
#define FUN_SH16TO32INT2526       49  // export 264
#define FUN_SHGETFILEINFO         50  // export 300
#define FUN_SHFORMATDRIVE         51  // export 400
#define FUN_SHCHECKDRIVE          52  // export 401
#define FUN__RUNDLLCHECKDRIVE     53  // export 402


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _REGOPENKEY16 {		/* s1 */
    VPVOID  f3;
    VPVOID  f2;
    DWORD	f1;
} REGOPENKEY16;
typedef REGOPENKEY16 UNALIGNED *PREGOPENKEY16;

typedef struct _REGCREATEKEY16 {	/* s2 */
    VPVOID  f3;
    VPVOID  f2;
    DWORD   f1;
} REGCREATEKEY16;
typedef REGCREATEKEY16 UNALIGNED *PREGCREATEKEY16;

typedef struct _REGCLOSEKEY16 {		/* s3 */
    DWORD   f1;
} REGCLOSEKEY16;
typedef REGCLOSEKEY16 UNALIGNED *PREGCLOSEKEY16;

typedef struct _REGDELETEKEY16 {	/* s4 */
    VPVOID  f2;
    DWORD   f1;
} REGDELETEKEY16;
typedef REGDELETEKEY16 UNALIGNED *PREGDELETEKEY16;

typedef struct _REGSETVALUE16 {		/* s5 */
    DWORD   f5;
    VPVOID  f4;
    DWORD   f3;
    VPVOID  f2;
    DWORD   f1;
} REGSETVALUE16;
typedef REGSETVALUE16 UNALIGNED *PREGSETVALUE16;

typedef struct _REGQUERYVALUE16 {	/* s6 */
    VPVOID  f4;
    VPVOID  f3;
    VPVOID  f2;
    DWORD   f1;
} REGQUERYVALUE16;
typedef REGQUERYVALUE16 UNALIGNED *PREGQUERYVALUE16;

typedef struct _REGENUMKEY16 {		/* s7 */
    DWORD   f4;
    VPVOID  f3;
    DWORD   f2;
    DWORD   f1;
} REGENUMKEY16;
typedef REGENUMKEY16 UNALIGNED *PREGENUMKEY16;

typedef struct _DRAGACCEPTFILES16 {	/* s9 */
    SHORT   f2;
    HAND16  f1;
} DRAGACCEPTFILES16;
typedef DRAGACCEPTFILES16 UNALIGNED *PDRAGACCEPTFILES16;

typedef struct _DRAGQUERYFILE16 {	/* s11 */
    WORD    f4;
    VPVOID  f3;
    WORD    f2;
    HAND16  f1;
} DRAGQUERYFILE16;
typedef DRAGQUERYFILE16 UNALIGNED *PDRAGQUERYFILE16;

typedef struct _DRAGFINISH16 {		/* s12 */
    HAND16  f1;
} DRAGFINISH16;
typedef DRAGFINISH16 UNALIGNED *PDRAGFINISH16;

typedef struct _DRAGQUERYPOINT16 {	/* s13 */
    VPVOID  f2;
    HAND16  f1;
} DRAGQUERYPOINT16;
typedef DRAGQUERYPOINT16 UNALIGNED *PDRAGQUERYPOINT16;

typedef struct _SHELLABOUT16 {	      /* s22 */
    HAND16  f4;
    VPVOID  f3;
    VPVOID  f2;
    HAND16  f1;
} SHELLABOUT16;
typedef SHELLABOUT16 UNALIGNED *PSHELLABOUT16;

typedef struct _SHELLEXECUTE16 {	/* s20 */
    WORD    f6;
    VPVOID  f5;
    VPVOID  f4;
    VPVOID  f3;
    VPVOID  f2;
    HAND16  f1;
} SHELLEXECUTE16;
typedef SHELLEXECUTE16 UNALIGNED *PSHELLEXECUTE16;

typedef struct _FINDEXECUTABLE16 {	/* s21 */
    VPVOID  f3;
    VPVOID  f2;
    VPVOID  f1;
} FINDEXECUTABLE16;
typedef FINDEXECUTABLE16 UNALIGNED *PFINDEXECUTABLE16;

typedef struct _EXTRACTICON16 {		/* s34 */
    WORD    f3;
    VPVOID  f2;
    HAND16  f1;
} EXTRACTICON16;
typedef EXTRACTICON16 UNALIGNED *PEXTRACTICON16;

typedef struct _EXTRACTASSOCIATEDICON16 {	  /* s36 */
    VPVOID  f3;
    VPVOID  f2;
    HAND16  f1;
} EXTRACTASSOCIATEDICON16;
typedef EXTRACTASSOCIATEDICON16 UNALIGNED *PEXTRACTASSOCIATEDICON16;

typedef struct _DOENVIRONMENTSUBST16 {            /* s37 */
    WORD    cch;
    VPVOID  vpsz;
} DOENVIRONMENTSUBST16;
typedef DOENVIRONMENTSUBST16 UNALIGNED *PDOENVIRONMENTSUBST16;


/* New for Win95 */


typedef struct _EXTRACTICONEX16 {            /* s40 */
    SHORT   nIcons;
    VPWORD  phiconSmall;
    VPWORD  phiconLarge;
    SHORT   nIconIndex;
    VPSZ    lpszExeFileName;
} EXTRACTICONEX16;
typedef EXTRACTICONEX16 UNALIGNED *PEXTRACTICONEX16;

typedef struct _RESTARTDIALOG16 {            /* s45 */
    DWORD  dwReturn;
    VPSTR  lpszPrompt;
    HWND16 hwnd;
} RESTARTDIALOG16;
typedef RESTARTDIALOG16 UNALIGNED *PRESTARTDIALOG16;

typedef struct _PICKICONDLG16 {            /* s46 */
    VPSHORT piIconIndex;
    WORD    cbIconPath;
    VPSZ    pszIconPath;
    HWND16  hwnd;
} PICKICONDLG16;
typedef PICKICONDLG16 UNALIGNED *PPICKICONDLG16;

typedef struct _DRIVETYPE16 {            /* s47 */
    SHORT   iDrive;
} DRIVETYPE16;
typedef DRIVETYPE16 UNALIGNED *PDRIVETYPE16;

typedef struct _SH16TO32DRIVEIOCTL16 {            /* s48 */
    VPVOID  pv;
    SHORT   iCmd;
    SHORT   iDrive;
} SH16TO32DRIVEIOCTL16;
typedef SH16TO32DRIVEIOCTL16 UNALIGNED *PSH16TO32DRIVEIOCTL16;

typedef struct _SH16TO32INT252616 {            /* s49 */
    DWORD   dwSector;
    WORD    wCount;
    VPVOID  lpBuf;
    SHORT   iInt;
    SHORT   iDrive;
} SH16TO32INT252616;
typedef SH16TO32INT252616 UNALIGNED *PSH16TO32INT252616;

typedef struct _SHGETFILEINFO16 {            /* s50 */
    WORD    wFlags;
    WORD    cbFileInfo;
    VPVOID  lpsfi;
    DWORD   dwFileAttributes;
    VPSZ    lpszPath;
} SHGETFILEINFO16;
typedef SHGETFILEINFO16 UNALIGNED *PSHGETFILEINFO16;

typedef struct _SHFORMATDRIVE16 {            /* s51 */
    WORD    wOptions;
    WORD    wFmtID;
    WORD    wDrive;
    HWND16  hwnd;
} SHFORMATDRIVE16;
typedef SHFORMATDRIVE16 UNALIGNED *PSHFORMATDRIVE16;

typedef struct _SHCHECKDRIVE16 {            /* s52 */
    VPWORD lpTLhwnd;
    DWORD  dwDrvList;
    DWORD  dwOptions;
    HWND16 hwnd;
} SHCHECKDRIVE16;
typedef SHCHECKDRIVE16 UNALIGNED *PSHCHECKDRIVE16;

typedef struct __RUNDLLCHECKDRIVE16 {            /* s53 */
    SHORT   nCmdShow;
    VPSZ    lpszCmdLine;
    HINST16 hAppInstance;
    HWND16  hwndStub;
} _RUNDLLCHECKDRIVE16;
typedef _RUNDLLCHECKDRIVE16 UNALIGNED *P_RUNDLLCHECKDRIVE16;


/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowsnd.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWSND.H
 *  16-bit Sound API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
--*/


/* Sound API IDs
 */
#define FUN_CLOSESOUND			2   //
#define FUN_COUNTVOICENOTES		13  //
#define FUN_DOBEEP			17  // Internal
#define FUN_GETTHRESHOLDEVENT		14  //
#define FUN_GETTHRESHOLDSTATUS		15  //
#define FUN_MYOPENSOUND 		18  // Internal
#define FUN_OPENSOUND			1   //
#define FUN_SETSOUNDNOISE		7   //
#define FUN_SETVOICEACCENT		5   //
#define FUN_SETVOICEENVELOPE		6   //
#define FUN_SETVOICENOTE		4   //
#define FUN_SETVOICEQUEUESIZE		3   //
#define FUN_SETVOICESOUND		8   //
#define FUN_SETVOICETHRESHOLD		16  //
#define FUN_SOUND_WEP			0   // Export by name
#define FUN_STARTSOUND			9   //
#define FUN_STOPSOUND			10  //
#define FUN_SYNCALLVOICES		12  //
#define FUN_WAITSOUNDSTATE		11  //


/* XLATOFF */
#pragma pack(2)
/* XLATON */

#ifdef NULLSTRUCT
typedef struct _CLOSESOUND16 {			/* s2 */
} CLOSESOUND16;
typedef CLOSESOUND16 UNALIGNED *PCLOSESOUND16;
#endif

typedef struct _COUNTVOICENOTES16 {		/* s13 */
    SHORT f1;
} COUNTVOICENOTES16;
typedef COUNTVOICENOTES16 UNALIGNED *PCOUNTVOICENOTES16;

#ifdef NULLSTRUCT
typedef struct _GETTHRESHOLDEVENT16 {		/* s14 */
} GETTHRESHOLDEVENT16;
typedef GETTHRESHOLDEVENT16 UNALIGNED *PGETTHRESHOLDEVENT16;
#endif

#ifdef NULLSTRUCT
typedef struct _GETTHRESHOLDSTATUS16 {		/* s15 */
} GETTHRESHOLDSTATUS16;
typedef GETTHRESHOLDSTATUS16 UNALIGNED *PGETTHRESHOLDSTATUS16;
#endif

#ifdef NULLSTRUCT
typedef struct _OPENSOUND16 {			/* s1 */
} OPENSOUND16;
typedef OPENSOUND16 UNALIGNED *POPENSOUND16;
#endif

typedef struct _SETSOUNDNOISE16 {		/* s7 */
    SHORT f1;
    SHORT f2;
} SETSOUNDNOISE16;
typedef SETSOUNDNOISE16 UNALIGNED *PSETSOUNDNOISE16;

typedef struct _SETVOICEACCENT16 {		/* s5 */
    SHORT f1;
    SHORT f2;
    SHORT f3;
    SHORT f4;
    SHORT f5;
} SETVOICEACCENT16;
typedef SETVOICEACCENT16 UNALIGNED *PSETVOICEACCENT16;

typedef struct _SETVOICEENVELOPE16 {		/* s6 */
    SHORT f1;
    SHORT f2;
    SHORT f3;
} SETVOICEENVELOPE16;
typedef SETVOICEENVELOPE16 UNALIGNED *PSETVOICEENVELOPE16;

typedef struct _SETVOICENOTE16 {		/* s4 */
    SHORT f1;
    SHORT f2;
    SHORT f3;
    SHORT f4;
} SETVOICENOTE16;
typedef SETVOICENOTE16 UNALIGNED *PSETVOICENOTE16;

typedef struct _SETVOICEQUEUESIZE16 {		/* s3 */
    SHORT f1;
    SHORT f2;
} SETVOICEQUEUESIZE16;
typedef SETVOICEQUEUESIZE16 UNALIGNED *PSETVOICEQUEUESIZE16;

typedef struct _SETVOICESOUND16 {		/* s8 */
    SHORT f1;
    LONG f2;
    SHORT f3;
} SETVOICESOUND16;
typedef SETVOICESOUND16 UNALIGNED *PSETVOICESOUND16;

typedef struct _SETVOICETHRESHOLD16 {		/* s16 */
    SHORT f1;
    SHORT f2;
} SETVOICETHRESHOLD16;
typedef SETVOICETHRESHOLD16 UNALIGNED *PSETVOICETHRESHOLD16;

#ifdef NULLSTRUCT
typedef struct _STARTSOUND16 {			/* s9 */
} STARTSOUND16;
typedef STARTSOUND16 UNALIGNED *PSTARTSOUND16;
#endif

#ifdef NULLSTRUCT
typedef struct _STOPSOUND16 {			/* s10 */
} STOPSOUND16;
typedef STOPSOUND16 UNALIGNED *PSTOPSOUND16;
#endif

#ifdef NULLSTRUCT
typedef struct _SYNCALLVOICES16 {		/* s12 */
} SYNCALLVOICES16;
typedef SYNCALLVOICES16 UNALIGNED *PSYNCALLVOICES16;
#endif

typedef struct _WAITSOUNDSTATE16 {		/* s11 */
    SHORT f1;
} WAITSOUNDSTATE16;
typedef WAITSOUNDSTATE16 UNALIGNED *PWAITSOUNDSTATE16;

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowtd.h ===
// This is here so it can be h2inc'd for fastwow.asm
//


// Note:  The offset definitons below HAVE TO match the offsets in wow32.h
//   From the TD struct:
#define cbOffCOMMDLGTD 3*sizeof(DWORD)


// Note:  The offset definitons below HAVE TO match the offsets in wow.h
//   From the VDMFRAME struct:
#define cbOffwThunkCSIP 0x1c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowth.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWTH.H
 *  16-bit ToolHelp thunked API argument structures
 *
 *  History:
 *  12-Nov-92 Dave Hart (davehart) created using wowkrn.h as template
--*/


/* ToolHelp API IDs
 */
#define FUN_CLASSFIRST          1
#define FUN_CLASSNEXT           2


/* XLATOFF */
#pragma pack(2)
/* XLATON */


typedef struct _CLASSFIRST16 {      /* th1 */
    VPVOID f1;
} CLASSFIRST16;
typedef CLASSFIRST16 UNALIGNED *PCLASSFIRST16;

typedef struct _CLASSNEXT16 {       /* th2 */
    VPVOID f1;
} CLASSNEXT16;
typedef CLASSNEXT16 UNALIGNED *PCLASSNEXT16;


/* XLATOFF */
#pragma pack()
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wownls.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWNLS.H
 *  16-bit IME API argument structures
 *
 *  History:
 *  Created 16-Apl-1996 by MSKK
 *
--*/

/* IME API IDs
 */
#define FUN_SENDIMEMESSAGE		6
#define FUN_SENDIMEMESSAGEEX		7

#define	FUN_WINNLSGETIMEHOTKEY		15
#define	FUN_WINNLSENABLEIME		16
#define	FUN_WINNLSGETENABLESTATUS	18

#define	FUN_IMPQUERYIME			22
#define	FUN_IMPGETIME			23
#define	FUN_IMPSETIME			24


#if 0 // NT does not support the following APIs
#define FUN_INQUIREWINNLS		1
#define	FUN_HOOKKEYBOARDMESSAGE		2
#define FUN_CONTROLIMEMESSAGE       	8	// for Taiwan, Prc
#define	FUN_WINNLSSETKEYBOARDHOOK	10
#define	FUN_WINNLSSETIMEHANDLE		11
#define	FUN_WINNLSSETIMESTATUS		12
#define	FUN_WINNLSSETIMEHOTKEY		14
#define	FUN_WINNLSGETKEYSTATE		17
#define	FUN_WINNLSSETKEYSTATE		19
#define	FUN_IMPADDIME			20
#define	FUN_IMPDELETEIME		21
#define	FUN_IMPMODIFYIME		25
#define	FUN_IMPGETDEFAULTIME		26
#define	FUN_IMPSETDEFAULTIME		27
#define	FUN_WINNLSSENDSTRING		30
#define	FUN_WINNLSPOSTAPPMESSAGE	31
#define	FUN_WINNLSSENDAPPMESSAGE	32
#define FUN_WINNLSQUERYIMEINFO      	40     // for Taiwan, Prc
#endif // 0


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _SENDIMEMESSAGE16 { /* wn6 */
	DWORD	lParam;
	HWND16	hwnd;
} SENDIMEMESSAGE16;
typedef SENDIMEMESSAGE16 UNALIGNED *PSENDIMEMESSAGE16;

typedef struct _SENDIMEMESSAGEEX16 { /* wn7 */
	DWORD	lParam;
	HWND16	hwnd;
} SENDIMEMESSAGEEX16;
typedef SENDIMEMESSAGEEX16 UNALIGNED *PSENDIMEMESSAGEEX16;

typedef struct _WINNLSGETIMEHOTKEY16 { /* wn15 */
	HWND16	hwnd;
} WINNLSGETIMEHOTKEY16;
typedef WINNLSGETIMEHOTKEY16 UNALIGNED *PWINNLSGETIMEHOTKEY16;

typedef struct _WINNLSENABLEIME16 { /* wn16 */
	WORD	fEnabled;
	HWND16	hwnd;
} WINNLSENABLEIME16;
typedef WINNLSENABLEIME16 UNALIGNED *PWINNLSENABLEIME16;

typedef struct _WINNLSGETENABLESTATUS16 { /* wn 18 */
	HWND16	hwnd;
} WINNLSGETENABLESTATUS16;
typedef WINNLSGETENABLESTATUS16 UNALIGNED *PWINNLSGETENABLESTATUS16;

typedef struct _IMPQUERYIME16 { /* wn22 */
        VPVOID  lpIMEPro;
} IMPQUERYIME16;
typedef IMPQUERYIME16 UNALIGNED *PIMPQUERYIME16;

typedef struct _IMPGETIME16 { /* wn23 */
        VPVOID  lpIMEPro;
	HWND16	hwnd;
} IMPGETIME16;
typedef IMPGETIME16 UNALIGNED *PIMPGETIME16;

typedef struct _IMPSETIME16 { /* wn24 */
        VPVOID  lpIMEPro;
	HWND16	hwnd;
} IMPSETIME16;
typedef IMPSETIME16 UNALIGNED *PIMPSETIME16;






#if 0 // NT does not support the following APIs
typedef struct _SETKEYBOARDHOOK16 { /* wn10 */
	WORD    flag;
} SETKEYBOARDHOOK16;
typedef SETKEYBOARDHOOK16 UNALIGNED *PSETKEYBOARDHOOK16;

typedef struct _SETIMEHANDLE16 { /* wn11 */
	VPSTR	lpszName;
	HWND16	hwnd;
} SETIMEHANDLE16;
typedef SETIMEHANDLE16 UNALIGNED *PSETIMEHANDLE16;

typedef struct _SETIMESTATUS16 { /* wn12 */
	WORD	status;
	HWND16	hwnd;
} SETIMESTATUS16;
typedef SETIMESTATUS16 UNALIGNED *PSETIMESTATUS16;

typedef struct _SETIMEHOTKEY16 { /* wn14 */
	WORD	key;
	HWND16	hwnd;
} SETIMEHOTKEY16;
typedef SETIMEHOTKEY16 UNALIGNED *PSETIMEHOTKEY16;
#endif // 0

typedef struct _IMESTRUCT16 { /* imest */
	WORD	fnc;
	WORD	wParam;
	WORD	wCount;
	WORD	dchSource;
	WORD	dchDest;
	LONG	lParam1;
	LONG	lParam2;
	LONG	lParam3;
} IMESTRUCT16;
typedef IMESTRUCT16 UNALIGNED *PIMESTRUCT16;

#if 0
typedef struct _SETKEYSTATE16 { /* wn19 */
	HWND16	hwnd;
	WORD	wState;
} SETKEYSTATE16;
typedef SETKEYSTATE16 UNALIGNED *PSETKEYSTATE16;
#endif // 0

typedef struct _DATETIME16 { /* dt */
    WORD	year;
    WORD	month;
    WORD	day;
    WORD	hour;
    WORD	min;
    WORD	sec;
} DATETIME16;

typedef struct _IMEPRO16 { /* pro */
	HWND16	hWnd;
	DATETIME16 InstDate;
	WORD	wVersion;
	BYTE	szDescription[50];
	BYTE	szName[80];
	BYTE	szOptions[30];
} IMEPRO16;
typedef IMEPRO16 UNALIGNED *PIMEPRO16;

typedef struct _UNDETERMINESTRUCT16 { /* ud16 */
    DWORD    dwSize;
    INT16     uDefIMESize;
    INT16     uDefIMEPos;
    INT16     uUndetTextLen;
    INT16     uUndetTextPos;
    INT16     uUndetAttrPos;
    INT16     uCursorPos;
    INT16     uDeltaStart;
    INT16     uDetermineTextLen;
    INT16     uDetermineTextPos;
    INT16     uDetermineDelimPos;
    INT16     uYomiTextLen;
    INT16     uYomiTextPos;
    INT16     uYomiDelimPos;
} UNDETERMINESTRUCT16;
typedef UNDETERMINESTRUCT16 UNALIGNED *PUNDETERMINESTRUCT16;

typedef struct _STRINGEXSTRUCT16 { /* sx16 */
    DWORD    dwSize;
    INT16     uDeterminePos;
    INT16     uDetermineDelimPos;
    INT16     uYomiPos;
    INT16     uYomiDelimPos;
} STRINGEXSTRUCT16;
typedef STRINGEXSTRUCT16 UNALIGNED *PSTRINGEXSTRUCT16;




/////////// tmp /////////
#if 0
#define IR_DBCSCHAR             0x160   /* New for 3.1 */
#define IR_UNDETERMINE          0x170   /* New for 3.1 */
#define IR_STRINGEX             0x180   /* New for 3.1 */

typedef struct UNDETERMINESTRUCT32 { /* ud32 */
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT32;
typedef UNDETERMINESTRUCT32 UNALIGNED *PUNDETERMINESTRUCT32;

typedef struct STRINGEXSTRUCT32 { /* sx32 */
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT32;
typedef STRINGEXSTRUCT32 UNALIGNED *PSTRINGEXSTRUCT32;
#endif // 0
//////// end of tmp ///////////

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowwife.h ===
#define FUN_MISCGETEUDCLEADBYTERANGE	66

/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _MISCGETEUDCLEADBYTERANGE16 { /* wm66 */
	WORD	usCharSet;
} MISCGETEUDCLEADBYTERANGE16;
typedef MISCGETEUDCLEADBYTERANGE16 UNALIGNED *PMISCGETEUDCLEADBYTERANGE16;

/* XLATOFF */
#pragma pack()
/* XLATON */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\xmsexp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  XMSEXP.H
 *  XMS exports
 *
 *  History:
 *  15-May-1991 Sudeep Bharati (sudeepb)
 *  Created.
--*/

extern BOOL XMSDispatch(ULONG iXMSSvc);
extern BOOL XMSInit(int argc, char *argv[]);

/*
 * handle for extended memory tracking.
 * this is used by DPMI on risc so that
 * DPMI and XMS can both allocate extended
 * memory
 */
extern PVOID ExtMemSA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowwsock.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWWSOCK.H
 *  16-bit Winsock API argument structures
 *
 *  History:
 *  Created 02-Oct-1992 by David Treadwell (davidtr)
--*/

//#include <windows.h>
//#include <winsock.h>

/* XLATOFF */
#pragma pack(1)
/* XLATON */

/*++
 *
 * Winsock data structures
 *
--*/

typedef WORD HSOCKET16;
typedef DWORD IN_ADDR16;

typedef struct _SOCKADDR16 {                           /* sa16 */
    WORD sa_family;
    BYTE sa_data[14];
} SOCKADDR16;
typedef SOCKADDR16 UNALIGNED *PSOCKADDR16;
typedef VPVOID VPSOCKADDR;

#define FD_SETSIZE      64

typedef struct _FD_SET16 {                             /* fd16 */
    WORD fd_count;
    HSOCKET16 fd_array[FD_SETSIZE];
} FD_SET16;
typedef FD_SET16 UNALIGNED *PFD_SET16;
typedef VPVOID VPFD_SET16;

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct _WSADATA16 {                            /* wd16 */
    WORD wVersion;
    WORD wHighVersion;
    CHAR szDescription[WSADESCRIPTION_LEN+1];
    CHAR szSystemStatus[WSASYS_STATUS_LEN+1];
    INT16 iMaxSockets;
    INT16 iMaxUdpDg;
    VPBYTE lpVendorInfo;
} WSADATA16;
typedef WSADATA16 UNALIGNED *PWSADATA16;
typedef VPVOID VPWSADATA16;

typedef struct _TIMEVAL16 {                            /* tv16 */
    DWORD tv_sec;         /* seconds */
    DWORD tv_usec;        /* and microseconds */
} TIMEVAL16;
typedef TIMEVAL16 *PTIMEVAL16;
typedef VPVOID VPTIMEVAL16;

typedef struct _HOSTENT16 {                            /* he16 */
    VPSZ h_name;
    VPVOID h_aliases;
    WORD h_addrtype;
    WORD h_length;
    VPBYTE h_addr_list;
} HOSTENT16;
typedef HOSTENT16 *PHOSTENT16;
typedef VPVOID VPHOSTENT16;

typedef struct _PROTOENT16 {                           /* pe16 */
    VPSZ p_name;
    VPVOID p_aliases;
    WORD p_proto;
} PROTOENT16;
typedef PROTOENT16 *PPROTOENT16;
typedef VPVOID VPPROTOENT16;

typedef struct _SERVENT16 {                            /* se16 */
    VPSZ s_name;
    VPVOID s_aliases;
    WORD s_port;
    VPSZ s_proto;
} SERVENT16;
typedef SERVENT16 *PSERVENT16;
typedef VPVOID VPSERVENT16;

typedef struct _NETENT16 {                             /* ne16 */
    VPSZ n_name;
    VPVOID n_aliases;
    WORD n_addrtype;
    DWORD n_net;
} NETENT16;
typedef NETENT16 *PNETENT16;
typedef VPVOID VPNETENT16;

/*++
 *
 * Winsock API IDs (equal to ordinal numbers)
 *
--*/

#define FUN_ACCEPT                         1   //
#define FUN_BIND                           2   //
#define FUN_CLOSESOCKET                    3   //
#define FUN_CONNECT                        4   //
#define FUN_GETPEERNAME                    5   //
#define FUN_GETSOCKNAME                    6   //
#define FUN_GETSOCKOPT                     7   //
#define FUN_HTONL                          8   //
#define FUN_HTONS                          9   //
#define FUN_INET_ADDR                      10  //
#define FUN_INET_NTOA                      11  //
#define FUN_IOCTLSOCKET                    12  //
#define FUN_LISTEN                         13  //
#define FUN_NTOHL                          14  //
#define FUN_NTOHS                          15  //
#define FUN_RECV                           16  //
#define FUN_RECVFROM                       17  //
#define FUN_SELECT                         18  //
#define FUN_SEND                           19  //
#define FUN_SENDTO                         20  //
#define FUN_SETSOCKOPT                     21  //
#define FUN_SHUTDOWN                       22  //
#define FUN_SOCKET                         23  //

#define FUN_GETHOSTBYADDR                  51  //
#define FUN_GETHOSTBYNAME                  52  //
#define FUN_GETPROTOBYNAME                 53  //
#define FUN_GETPROTOBYNUMBER               54  //
#define FUN_GETSERVBYNAME                  55  //
#define FUN_GETSERVBYPORT                  56  //
#define FUN_GETHOSTNAME                    57  //

#define FUN_WSAASYNCSELECT                 101 //
#define FUN_WSAASYNCGETHOSTBYADDR          102 //
#define FUN_WSAASYNCGETHOSTBYNAME          103 //
#define FUN_WSAASYNCGETPROTOBYNUMBER       104 //
#define FUN_WSAASYNCGETPROTOBYNAME         105 //
#define FUN_WSAASYNCGETSERVBYPORT          106 //
#define FUN_WSAASYNCGETSERVBYNAME          107 //
#define FUN_WSACANCELASYNCREQUEST          108 //
#define FUN_WSASETBLOCKINGHOOK             109 //
#define FUN_WSAUNHOOKBLOCKINGHOOK          110 //
#define FUN_WSAGETLASTERROR                111 //
#define FUN_WSASETLASTERROR                112 //
#define FUN_WSACANCELBLOCKINGCALL          113 //
#define FUN_WSAISBLOCKING                  114 //
#define FUN_WSASTARTUP                     115 //
#define FUN_WSACLEANUP                     116 //

#define FUN___WSAFDISSET                   151 //

/*++

  Winsock function prototypes - the seemingly unimportant number in the
  comment on each function MUST match the ones in the list above!!!

  !! BE WARNED !!

--*/

typedef struct _ACCEPT16 {                             /* ws1 */
    VPWORD AddressLength;
    VPSOCKADDR Address;
    HSOCKET16 hSocket;
} ACCEPT16;
typedef ACCEPT16 UNALIGNED *PACCEPT16;

typedef struct _BIND16 {                               /* ws2 */
    WORD AddressLength;
    VPSOCKADDR Address;
    HSOCKET16 hSocket;
} BIND16;
typedef BIND16 UNALIGNED *PBIND16;

typedef struct _CLOSESOCKET16 {                        /* ws3 */
    HSOCKET16 hSocket;
} CLOSESOCKET16;
typedef CLOSESOCKET16 UNALIGNED *PCLOSESOCKET16;

typedef struct _CONNECT16 {                            /* ws4 */
    WORD AddressLength;
    VPSOCKADDR Address;
    HSOCKET16 hSocket;
} CONNECT16;
typedef CONNECT16 UNALIGNED *PCONNECT16;

typedef struct _GETPEERNAME16 {                        /* ws5 */
    VPWORD AddressLength;
    VPSOCKADDR Address;
    HSOCKET16 hSocket;
} GETPEERNAME16;
typedef GETPEERNAME16 UNALIGNED *PGETPEERNAME16;

typedef struct _GETSOCKNAME16 {                        /* ws6 */
    VPWORD AddressLength;
    VPSOCKADDR Address;
    HSOCKET16 hSocket;
} GETSOCKNAME16;
typedef GETSOCKNAME16 UNALIGNED *PGETSOCKNAME16;

typedef struct _GETSOCKOPT16 {                         /* ws7 */
    VPWORD OptionLength;
    VPBYTE OptionValue;
    WORD OptionName;
    WORD Level;
    HSOCKET16 hSocket;
} GETSOCKOPT16;
typedef GETSOCKOPT16 UNALIGNED *PGETSOCKOPT16;

typedef struct _HTONL16 {                              /* ws8 */
    DWORD HostLong;
} HTONL16;
typedef HTONL16 UNALIGNED *PHTONL16;

typedef struct _HTONS16 {                              /* ws9 */
    WORD HostShort;
} HTONS16;
typedef HTONS16 UNALIGNED *PHTONS16;

typedef struct _INET_ADDR16 {                          /* ws10 */
    VPSZ cp;
} INET_ADDR16;
typedef INET_ADDR16 UNALIGNED *PINET_ADDR16;

typedef struct _INET_NTOA16 {                          /* ws11 */
    IN_ADDR16 in;
} INET_NTOA16;
typedef INET_NTOA16 UNALIGNED *PINET_NTOA16;

typedef struct _IOCTLSOCKET16 {                        /* ws12 */
    VPDWORD Argument;
    DWORD Command;
    HSOCKET16 hSocket;
} IOCTLSOCKET16;
typedef IOCTLSOCKET16 UNALIGNED *PIOCTLSOCKET16;

typedef struct _LISTEN16 {                             /* ws13 */
    WORD Backlog;
    HSOCKET16 hSocket;
} LISTEN16;
typedef LISTEN16 UNALIGNED *PLISTEN16;

typedef struct _NTOHL16 {                              /* ws14 */
    DWORD NetLong;
} NTOHL16;
typedef NTOHL16 UNALIGNED *PNTOHL16;

typedef struct _NTOHS16 {                              /* ws15 */
    WORD NetShort;
} NTOHS16;
typedef NTOHS16 UNALIGNED *PNTOHS16;

typedef struct _RECV16 {                               /* ws16 */
    WORD Flags;
    WORD BufferLength;
    VPBYTE Buffer;
    HSOCKET16 hSocket;
} RECV16;
typedef RECV16 UNALIGNED *PRECV16;

typedef struct _RECVFROM16 {                           /* ws17 */
    VPWORD AddressLength;
    VPSOCKADDR Address;
    WORD Flags;
    WORD BufferLength;
    VPBYTE Buffer;
    HSOCKET16 hSocket;
} RECVFROM16;
typedef RECVFROM16 UNALIGNED *PRECVFROM16;

typedef struct _SELECT16 {                             /* ws18 */
    VPTIMEVAL16 Timeout;
    VPFD_SET16 Exceptfds;
    VPFD_SET16 Writefds;
    VPFD_SET16 Readfds;
    WORD HandleCount;
} SELECT16;
typedef SELECT16 UNALIGNED *PSELECT16;

typedef struct _SEND16 {                               /* ws19 */
    WORD Flags;
    WORD BufferLength;
    VPBYTE Buffer;
    HSOCKET16 hSocket;
} SEND16;
typedef SEND16 UNALIGNED *PSEND16;

typedef struct _SENDTO16 {                             /* ws20 */
    WORD AddressLength;
    VPSOCKADDR Address;
    WORD Flags;
    WORD BufferLength;
    VPBYTE Buffer;
    HSOCKET16 hSocket;
} SENDTO16;
typedef SENDTO16 UNALIGNED *PSENDTO16;

typedef struct _SETSOCKOPT16 {                         /* ws21 */
    WORD OptionLength;
    VPBYTE OptionValue;
    WORD OptionName;
    WORD Level;
    HSOCKET16 hSocket;
} SETSOCKOPT16;
typedef SETSOCKOPT16 UNALIGNED *PSETSOCKOPT16;

typedef struct _SHUTDOWN16 {                           /* ws22 */
    WORD How;
    HSOCKET16 hSocket;
} SHUTDOWN16;
typedef SHUTDOWN16 UNALIGNED *PSHUTDOWN16;

typedef struct _SOCKET16 {                             /* ws23 */
    WORD Protocol;
    WORD Type;
    WORD AddressFamily;
} SOCKET16;
typedef SOCKET16 UNALIGNED *PSOCKET16;

typedef struct _GETHOSTBYADDR16 {                      /* ws51 */
    WORD Type;
    WORD Length;
    VPBYTE Address;
} GETHOSTBYADDR16;
typedef GETHOSTBYADDR16 UNALIGNED *PGETHOSTBYADDR16;

typedef struct _GETHOSTBYNAME16 {                      /* ws52 */
    VPSZ Name;
} GETHOSTBYNAME16;
typedef GETHOSTBYNAME16 UNALIGNED *PGETHOSTBYNAME16;

typedef struct _GETPROTOBYNAME16 {                     /* ws53 */
    VPSZ Name;
} GETPROTOBYNAME16;
typedef GETPROTOBYNAME16 UNALIGNED *PGETPROTOBYNAME16;

typedef struct _GETPROTOBYNUMBER16 {                   /* ws54 */
    WORD Protocol;
} GETPROTOBYNUMBER16;
typedef GETPROTOBYNUMBER16 UNALIGNED *PGETPROTOBYNUMBER16;

typedef struct _GETSERVBYNAME16 {                      /* ws55 */
    VPSZ Protocol;
    VPSZ Name;
} GETSERVBYNAME16;
typedef GETSERVBYNAME16 UNALIGNED *PGETSERVBYNAME16;

typedef struct _GETSERVBYPORT16 {                      /* ws56 */
    VPSZ Protocol;
    WORD Port;
} GETSERVBYPORT16;
typedef GETSERVBYPORT16 UNALIGNED *PGETSERVBYPORT16;

typedef struct _GETHOSTNAME16 {                        /* ws57 */
    WORD NameLength;
    VPSZ Name;
} GETHOSTNAME16;
typedef GETHOSTNAME16 UNALIGNED *PGETHOSTNAME16;

typedef struct _WSAASYNCSELECT16 {                     /* ws101 */
    DWORD lEvent;
    WORD wMsg;
    HWND16 hWnd;
    HSOCKET16 hSocket;
} WSAASYNCSELECT16;
typedef WSAASYNCSELECT16 UNALIGNED *PWSAASYNCSELECT16;

typedef struct _WSAASYNCGETHOSTBYADDR16 {              /* ws102 */
    WORD BufferLength;
    VPBYTE Buffer;
    WORD Type;
    WORD Length;
    VPBYTE Address;
    WORD wMsg;
    HWND16 hWnd;
} WSAASYNCGETHOSTBYADDR16;
typedef WSAASYNCGETHOSTBYADDR16 UNALIGNED *PWSAASYNCGETHOSTBYADDR16;

typedef struct _WSAASYNCGETHOSTBYNAME16 {              /* ws103 */
    WORD BufferLength;
    VPBYTE Buffer;
    VPSZ Name;
    WORD wMsg;
    HWND16 hWnd;
} WSAASYNCGETHOSTBYNAME16;
typedef WSAASYNCGETHOSTBYNAME16 UNALIGNED *PWSAASYNCGETHOSTBYNAME16;

typedef struct _WSAASYNCGETPROTOBYNUMBER16 {           /* ws104 */
    WORD BufferLength;
    VPBYTE Buffer;
    WORD Number;
    WORD wMsg;
    HWND16 hWnd;
} WSAASYNCGETPROTOBYNUMBER16;
typedef WSAASYNCGETPROTOBYNUMBER16 UNALIGNED *PWSAASYNCGETPROTOBYNUMBER16;

typedef struct _WSAASYNCGETPROTOBYNAME16 {             /* ws105 */
    WORD BufferLength;
    VPBYTE Buffer;
    VPSZ Name;
    WORD wMsg;
    HWND16 hWnd;
} WSAASYNCGETPROTOBYNAME16;
typedef WSAASYNCGETPROTOBYNAME16 UNALIGNED *PWSAASYNCGETPROTOBYNAME16;

typedef struct _WSAASYNCGETSERVBYPORT16 {              /* ws106 */
    WORD BufferLength;
    VPBYTE Buffer;
    VPSZ Protocol;
    WORD Port;
    WORD wMsg;
    HWND16 hWnd;
} WSAASYNCGETSERVBYPORT16;
typedef WSAASYNCGETSERVBYPORT16 UNALIGNED *PWSAASYNCGETSERVBYPORT16;

typedef struct _WSAASYNCGETSERVBYNAME16 {              /* ws107 */
    WORD BufferLength;
    VPBYTE Buffer;
    VPSZ Protocol;
    VPSZ Name;
    WORD wMsg;
    HWND16 hWnd;
} WSAASYNCGETSERVBYNAME16;
typedef WSAASYNCGETSERVBYNAME16 UNALIGNED *PWSAASYNCGETSERVBYNAME16;

typedef struct _WSACANCELASYNCREQUEST16 {              /* ws108 */
    WORD hAsyncTaskHandle;
} WSACANCELASYNCREQUEST16;
typedef WSACANCELASYNCREQUEST16 UNALIGNED *PWSACANCELASYNCREQUEST16;

typedef struct _WSASETBLOCKINGHOOK16 {                 /* ws109 */
    VPWNDPROC lpBlockFunc;
} WSASETBLOCKINGHOOK16;
typedef WSASETBLOCKINGHOOK16 UNALIGNED *PWSASETBLOCKINGHOOK16;

typedef struct _WSASETLASTERROR16 {                    /* ws112 */
    WORD Error;
} WSASETLASTERROR16;
typedef WSASETLASTERROR16 UNALIGNED *PWSASETLASTERROR16;

typedef struct _WSASTARTUP16 {                         /* ws115 */
    VPWSADATA16 lpWSAData;
    WORD wVersionRequired;
} WSASTARTUP16;
typedef WSASTARTUP16 UNALIGNED *PWSASTARTUP16;

typedef struct ___WSAFDISSET16 {                       /* ws151 */
    VPFD_SET16 Set;
    HSOCKET16 hSocket;
} __WSAFDISSET16;
typedef __WSAFDISSET16 UNALIGNED *P__WSAFDISSET16;

/* XLATOFF */
#pragma pack()
/* XLATON */

#define FUN___WSAFDISSET                   151 //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\xmssvc.h ===
/**	SVC Defines
 *
 *	Revision history:
 *
 *	sudeepb 15-May-1991 Created
 *
 *	williamh 25-Sept-1992 Added UMB support BOPs
 */


/* XMSSVC - XMS SVC calls.
 *
 *	 This macro is used by himem.sys
 *
 */

/* ASM
include bop.inc

xmssvc	macro	func
	BOP	BOP_XMS
	db	func
	endm
*/

#define XMS_A20 			0x00
#define XMS_MOVEBLOCK			0x01
#define XMS_ALLOCBLOCK			0x02
#define XMS_FREEBLOCK			0x03
#define XMS_SYSPAGESIZE			0x04
#define XMS_EXTMEM			0x05
#define XMS_INITUMB			0x06
#define XMS_REQUESTUMB			0x07
#define XMS_RELEASEUMB			0x08
#define XMS_NOTIFYHOOKI15               0x09
#define XMS_QUERYEXTMEM                 0x0a
#define XMS_REALLOCBLOCK                0x0b
#define XMS_LASTSVC                     0x0c

extern BOOL XMSInit (int argc, char *argv[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\x86def.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990  Microsoft Corporation

Module Name:

    X86PC.H

Abstract:

    This file contains macros, function prototypes, and externs for the
    x86 emulator NT version of SoftPC v3.0.

Author:

    Dave Hastings (daveh) 4-11-91

Revision History:

    Jeff Parsons (jeffpar) 14-May-1991
    Essentially copied this file from V86PC.H, except that I had to define
    X86CONTEXT as the x86-compatible version of CONTEXT.

--*/


//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_ENVIRONMENT   108
#define SIZE_OF_80387_REGISTERS      80

typedef struct _FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[SIZE_OF_80387_REGISTERS];
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;


// x86 Context Frame (copied from nti386.h)
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _X86CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} X86CONTEXT, *PX86CONTEXT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\meinc\apc.inc ===
;-----------------------------------------------------------------------
;
; APC.INC - Asynchronous Procedure Call Interface File
;
;-----------------------------------------------------------------------
;
;       Author:     Mike Toutonghi
;       Copyright:  1993 Microsoft
;
;-----------------------------------------------------------------------
;  File Description:
;       Provides an interface to both USER and KERNEL level APCs under
;       Chicago. This file must be kept in sync with APC.H
;
;-----------------------------------------------------------------------
;  Revision History:
;       2/23/93 - created (miketout)
;
;-----------------------------------------------------------------------

AssertSignature         macro   x
ifdef DEBUG
   x&_dwSignature       dd      ?
endif
endm

AssertCreate    macro x, p
ifdef DEBUG
        mov     [p].x&_dwSignature, x&_SIGNATURE
endif
endm

AssertDestroy   macro x, p
ifdef DEBUG
        mov     [p].x&_dwSignature, 44414544h
endif
endm

AssertP macro x, p
ifdef DEBUG
        cmp     [p].x&_dwSignature, x&_SIGNATURE
        Debug_OutNE "Assertion failed"
endif
endm

;---------------------------------------------------------------------
; SUPPORT STRUCTURES
;---------------------------------------------------------------------

APC_FUNC_PROTO  TYPEDEF PROTO STDCALL dwParam:DWORD

; These pointer types are only correct when included in 32 bit code
PAPCFUNC        TYPEDEF PTR APC_FUNC_PROTO
PUAPC           TYPEDEF PTR USERAPCREC
PKAPC           TYPEDEF PTR XKERNELAPCREC

SYNCAPCREC      STRUC
    sar_nextapc         dd      0       ; next APCREC in list
    sar_dwparam1        dd      0       ; first parameter
    sar_dwparam2        dd      0       ; second parameter
    sar_apcaddr         dd      0       ; address of APC
    sar_dwparam3        dd      0       ; third parameter
    AssertSignature SYNCAPCREC
SYNCAPCREC      ENDS

SYNCAPCREC_SIGNATURE    equ     20524153h

USERAPCREC      STRUC
    uar_nextapc         dd      0       ; next APCREC in list
    uar_apcstate        dd      0       ; state of APC (APC_DELIVERED)
    uar_dwparam         dd      0       ; APC parameter
    uar_apcaddr         dd      0       ; address of APC
    uar_apcR0rundown    dd      0       ; call if can't deliver APC,
    AssertSignature USERAPCREC
USERAPCREC      ENDS

USERAPCREC_SIGNATURE    equ     20524155h

.errnz ((SIZE USERAPCREC)-(SIZE SYNCAPCREC))

; APC state flags
APC_DELIVERED           equ     0       ; bit set when an APC is delivered
APC_DELIVERED_MASK      equ     (1 SHL APC_DELIVERED)
APC_FLAG_LAST           equ     0       ; last APC flag

KERNELAPCREC    STRUC
    kar_nextapc         dd      0       ; next APCREC in list
    kar_dwparam         dd      0       ; APC parameter
    kar_apcaddr         dd      0       ; address of APC
    kar_apcevent        dd      0       ; set if event queued for APC
    kar_savedeax        dd      0       ; saved eax for parameter
    kar_savedeip        dd      0       ; eip for same reason as above
    kar_savedcs         dw      0       ; saved ring 3 cs to return w/o stk
    kar_apcstate        dw      0       ; state of APC (KAR_FLAG...)
    AssertSignature KERNELAPCREC
KERNELAPCREC    ENDS

KERNELAPCREC_SIGNATURE  equ     2052414bh

; KERNEL APC specific flags
KAR_FLAG_BUSY           equ     0
KAR_FLAG_BUSY_MASK      equ     (1 SHL KAR_FLAG_BUSY)
KAR_FLAG_STATIC         equ     (KAR_FLAG_BUSY+1)
KAR_FLAG_STATIC_MASK    equ     (1 SHL KAR_FLAG_STATIC)
KAR_FLAG_CALLBACK       equ     (KAR_FLAG_STATIC+1)
KAR_FLAG_CALLBACK_MASK  equ     (1 SHL KAR_FLAG_CALLBACK)


IFNDEF STATUS_WAIT_0
    STATUS_WAIT_0       EQU 0           ; normal return code
ENDIF
IFNDEF STATUS_USER_APC
    STATUS_USER_APC     EQU 0C0H        ; return code for wake from APC
ENDIF
IFNDEF STATUS_KERNEL_APC
    STATUS_KERNEL_APC   EQU 0100H       ; return code for kernel APC wake
ENDIF

;
; Terminate Process Info structure for local reboot init dialog
;
TPI struc
    tpi_ptpiNext        dd      ?
    tpi_hwnd            dd      ?
    tpi_ppdb            dd      ?
    tpi_ptdb            dd      ?
    tpi_flags           dd      ?
    tpi_nIndex          dd      ?
    AssertSignature TPI
TPI ends

TPI_SIGNATURE           equ     20495054h

TPIF_HUNG               equ     00000001h
TPIF_PROCESSNAME        equ     00000002h

;
; TerminateThread apc parameter packet.  Allocated at ring 3, passed to
;       VxDTerminateThread.
;
TERMDATA        struc
    term_ptdb           dd      ?
    term_ptcbAPC        dd      ?
    term_pfnAPC         dd      ?
    term_hAPC           dd      ?
    term_htimeout       dd      ?
    term_pfrinfo        dd      ?
    AssertSignature TERMDATA
TERMDATA        ends

TERMDATA_SIGNATURE      equ     4d524554h

TPITERM union
    tpiterm_term TERMDATA <>
    tpiterm_tpi  TPI <>
TPITERM ends

;
; Parameter packet used to start a ring 0 thread
;
KERNTHREADSTARTDATA STRUCT
    StartAddress        dd      ?       ; start address in ring 3
    dwThreadParam       dd      ?       ; parameter for ring 3 startup function
    dwKTStackSize       dd      ?       ; ring 3 stack size
    dwCreationFlags     dd      ?       ; thread creation flags
    pRing3Event         dd      ?       ; set after thread is created
    dwThreadID          dd      ?       ; handle for new thread or NULL
    dwErrorCode         dd      ?       ; error code if error
KERNTHREADSTARTDATA ENDS

;
; Parameter packet used to start a ring 0 win32 thread
;
R0THREADSTARTDATA STRUCT
    R0StartAddress      dd      ?       ; start address in ring 0
    dwR0ThreadParam     dd      ?       ; parameter for ring 0 startup function
    dwR3StackSize       dd      ?       ; ring 3 stack size
    pRing0Event         dd      ?       ; set after thread is created
    R0FailCallBack      dd      ?       ; or invoke this callback on failure
    dwRing3ThreadID     dd      ?       ; ID for thread
    dwRing0ThreadID     dd      ?       ; same for ring 0
R0THREADSTARTDATA ENDS

INCLUDE TDBX.INC

externdef _VWIN32_QueueUserAPC:near
externdef _VWIN32_QueueKernelAPC:near
externdef _VW32_CleanAPCList:near
externdef _DeliverPendingKernelAPCs:near

QueueSyncAPC proto C
DeliverSyncAPCs proto C
CancelKernelAPC proto
CancelSuspendAPC proto
SuspendAPCHandler proto stdcall, Reserved:DWORD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\inc\wowusr.h ===
/*++ BUILD Version: 0001
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  WOWUSR.H
 *  16-bit User API argument structures
 *
 *  History:
 *  Created 02-Feb-1991 by Jeff Parsons (jeffpar)
 *  Added Win 3.1 APIs on 19-March-1992 Chandan S. Chauhan (ChandanC)
 *
--*/

/* User API IDs
 */
#define FUN_ADJUSTWINDOWRECT        102 //
#define FUN_ADJUSTWINDOWRECTEX      454 //
#define FUN_ANSILOWER               432 //
#define FUN_ANSILOWERBUFF           438 //
#define FUN_ANSINEXT                472 //
#define FUN_ANSIPREV                473 //
#define FUN_ANSIUPPER               431 //
#define FUN_ANSIUPPERBUFF           437 //
#define FUN_ANYPOPUP                52  //
#define FUN_APPENDMENU              411 //
#define FUN_ARRANGEICONICWINDOWS    170 // Internal, proto
#define FUN_BEGINDEFERWINDOWPOS     259 // Internal, proto
#define FUN_BEGINPAINT              39  //
#define FUN_BRINGWINDOWTOTOP        45  //
#define FUN_BROADCASTMESSAGE        355 // Internal
#define FUN_BUILDCOMMDCB            213 //
#define FUN_BUTTONWNDPROC           303 // Internal
#define FUN_CALCCHILDSCROLL         462 // Internal
#define FUN_CALLMSGFILTER           123 //
#define FUN_CALLWINDOWPROC          122 //
#define FUN_CARETBLINKPROC          311 // Internal
#define FUN_CASCADECHILDWINDOWS     198 // Internal
#define FUN_CHANGECLIPBOARDCHAIN    149 //
#define FUN_CHANGEMENU              153 //
#define FUN_CHECKDLGBUTTON          97  //
#define FUN_CHECKMENUITEM           154 //
#define FUN_CHECKRADIOBUTTON        96  //
#define FUN_CHILDWINDOWFROMPOINT    191 //
#define FUN_CLEARCOMMBREAK          211 //
#define FUN_CLIENTTOSCREEN          28  //
#define FUN_CLIPCURSOR              16  //
#define FUN_CLOSECLIPBOARD          138 //
#define FUN_CLOSECOMM               207 //
#define FUN_CLOSEWINDOW             43  //
#define FUN_COMBOBOXCTLWNDPROC      344 // Internal
#define FUN_COMPUPDATERECT          316 // Internal
#define FUN_COMPUPDATERGN           317 // Internal
#define FUN_CONTROLPANELINFO        273 // Internal
#define FUN_CONTSCROLL              310 // Internal
#define FUN_COPYRECT                74  //
#define FUN_COUNTCLIPBOARDFORMATS   143 //
#define FUN_CREATECARET             163 //
#define FUN_CREATECURSOR            406 //
#define FUN_CREATECURSORICONINDIRECT 408 // Internal
#define FUN_CREATEDIALOG            89  //
#define FUN_CREATEDIALOGINDIRECT    219 //
#define FUN_CREATEDIALOGINDIRECTPARAM 242 //
#define FUN_CREATEDIALOGPARAM       241 //
#define FUN_CREATEICON              407 //
#define FUN_CREATEMENU              151 //
#define FUN_CREATEPOPUPMENU         415 //
#define FUN_CREATEWINDOW            41  //
#define FUN_CREATEWINDOWEX          452 //
#define FUN_DEFDLGPROC              308 //
#define FUN_DEFERWINDOWPOS          260 // Internal, proto
#define FUN_DEFFRAMEPROC            445 //
#define FUN_DEFHOOKPROC             235 //
#define FUN_DEFMDICHILDPROC         447 //
#define FUN_DEFWINDOWPROC           107 //
#define FUN_DELETEMENU              413 //
#define FUN_DESKTOPWNDPROC          305 // Internal
#define FUN_DESTROYCARET            164 //
#define FUN_DESTROYCURSOR           458 //
#define FUN_DESTROYICON             457 //
#define FUN_DESTROYMENU             152 //
#define FUN_DESTROYWINDOW           53  //
#define FUN_DIALOGBOX               87  //
#define FUN_DIALOGBOXINDIRECT       218 //
#define FUN_DIALOGBOXINDIRECTPARAM  240 //
#define FUN_DIALOGBOXPARAM          239 //
#define FUN_DISABLEOEMLAYER         4   // Internal
#define FUN_DISPATCHMESSAGE         114 //
#define FUN_DLGDIRLIST              100 //
#define FUN_DLGDIRLISTCOMBOBOX      195 //
#define FUN_DLGDIRSELECT            99  //
#define FUN_DLGDIRSELECTCOMBOBOX    194 //
#define FUN_DRAGDETECT              465 // Internal
#define FUN_DRAGOBJECT              464 // Internal
#define FUN_DRAWFOCUSRECT           466 //
#define FUN_DRAWICON                84  //
#define FUN_DRAWMENUBAR             160 //
#define FUN_DRAWTEXT                85  //
#define FUN_DUMPICON                459 // Internal
#define FUN_EDITWNDPROC             301 // Internal
#define FUN_EMPTYCLIPBOARD          139 //
#define FUN_ENABLEHARDWAREINPUT     331 //
#define FUN_ENABLEMENUITEM          155 //
#define FUN_ENABLEOEMLAYER          3   // Internal
#define FUN_ENABLEWINDOW            34  //
#define FUN_ENDDEFERWINDOWPOS       261 // Internal, proto
#define FUN_ENDDIALOG               88  //
#define FUN_ENDMENU                 187 // Internal
#define FUN_ENDPAINT                40  //
#define FUN_ENUMCHILDWINDOWS        55  //
#define FUN_ENUMCLIPBOARDFORMATS    144 //
#define FUN_ENUMPROPS               27  //
#define FUN_ENUMTASKWINDOWS         225 //
#define FUN_ENUMWINDOWS             54  //
#define FUN_EQUALRECT               244 //
#define FUN_ESCAPECOMMFUNCTION      214 //
#define FUN_EXCLUDEUPDATERGN        238 //
#define FUN_EXITWINDOWS             7   // Internal, proto
#define FUN_FARCALLNETDRIVER        500 // Internal
#define FUN_FILEPORTDLGPROC         346 // Internal
#define FUN_FILLRECT                81  //
#define FUN_FILLWINDOW              324 // Internal
#define FUN_FINALUSERINIT           400 // Internal
#define FUN_FINDWINDOW              50  //
#define FUN_FLASHWINDOW             105 //
#define FUN_FLUSHCOMM               215 //
#define FUN_FRAMERECT               83  //
#define FUN_GETACTIVEWINDOW         60  //
#define FUN_GETASYNCKEYSTATE        249 //
#define FUN_GETCAPTURE              236 //
#define FUN_GETCARETBLINKTIME       169 //
#define FUN_GETCARETPOS             183 //
#define FUN_GETCLASSINFO            404 //
#define FUN_GETCLASSLONG            131 //
#define FUN_GETCLASSNAME            58  //
#define FUN_GETCLASSWORD            129 //
#define FUN_GETCLIENTRECT           33  //
#define FUN_GETCLIPBOARDDATA        142 //
#define FUN_GETCLIPBOARDFORMATNAME  146 //
#define FUN_GETCLIPBOARDOWNER       140 //
#define FUN_GETCLIPBOARDVIEWER      148 //
#define FUN_GETCOMMERROR            203 //
#define FUN_GETCOMMEVENTMASK        209 //
#define FUN_GETCOMMSTATE            202 //
#define FUN_GETCONTROLBRUSH         326 // Internal
#define FUN_GETCURRENTTIME          15  //
#define FUN_GETSYSTEMMSECCOUNT      15  //  This system.drv rtn gets thunked to GetCurrentTime
#define FUN_GETCURSORPOS            17  //
#define FUN_GETDC                   66  //
#define FUN_GETDESKTOPHWND          278 // Internal, proto
#define FUN_GETDESKTOPWINDOW        286 //
#define FUN_GETDIALOGBASEUNITS      243 //
#define FUN_GETDLGCTRLID            277 // Internal, proto
#define FUN_GETDLGITEM              91  //
#define FUN_GETDLGITEMINT           95  //
#define FUN_GETDLGITEMTEXT          93  //
#define FUN_GETDOUBLECLICKTIME      21  //
#define FUN_GETFILEPORTNAME         343 // Internal
#define FUN_GETFOCUS                23  //
#define FUN_GETICONID               455 // Internal
#define FUN_GETINPUTSTATE           335 //
#define FUN_GETINTERNALWINDOWPOS    460 // Internal
#define FUN_GETKEYBOARDSTATE        222 //
#define FUN_GETKEYSTATE             106 //
#define FUN_GETLASTACTIVEPOPUP      287 //
#define FUN_GETMENU                 157 //
#define FUN_GETMENUCHECKMARKDIMENSIONS  417 //
#define FUN_GETMENUITEMCOUNT        263 //
#define FUN_GETMENUITEMID           264 //
#define FUN_GETMENUSTATE            250 //
#define FUN_GETMENUSTRING           161 //
#define FUN_GETMESSAGE              108 //
#define FUN_GETMESSAGE2             323 // Internal
#define FUN_GETMESSAGEPOS           119 //
#define FUN_GETMESSAGETIME          120 //
#define FUN_GETMOUSEEVENTPROC       337 // Internal
#define FUN_GETNEXTDLGGROUPITEM     227 //
#define FUN_GETNEXTDLGTABITEM       228 //
#define FUN_GETNEXTQUEUEWINDOW      274 // Internal
#define FUN_GETNEXTWINDOW           230 //
#define FUN_GETPARENT               46  //
#define FUN_GETPRIORITYCLIPBOARDFORMAT  402 //
#define FUN_GETPROP                 25  //
#define FUN_GETQUEUESTATUS          334 // Internal
#define FUN_GETSCROLLPOS            63  //
#define FUN_GETSCROLLRANGE          65  //
#define FUN_GETSUBMENU              159 //
#define FUN_GETSYSCOLOR             180 //
#define FUN_GETSYSMODALWINDOW       189 //
#define FUN_GETSYSTEMMENU           156 //
#define FUN_GETSYSTEMMETRICS        179 //
#define FUN_GETTABBEDTEXTEXTENT     197 //
#define FUN_GETTICKCOUNT            13  //
#define FUN_GETTIMERRESOLUTION      14  // Internal
#define FUN_GETTOPWINDOW            229 //
#define FUN_GETUPDATERECT           190 //
#define FUN_GETUPDATERGN            237 //
#define FUN_GETWC2                  318 // Internal
#define FUN_GETWINDOW               262 //
#define FUN_GETWINDOWDC             67  //
#define FUN_GETWINDOWLONG           135 //
#define FUN_GETWINDOWRECT           32  //
#define FUN_GETWINDOWTASK           224 //
#define FUN_GETWINDOWTEXT           36  //
#define FUN_GETWINDOWTEXTLENGTH     38  //
#define FUN_GETWINDOWWORD           133 //
#define FUN_GLOBALADDATOM           268 //
#define FUN_GLOBALDELETEATOM        269 //
#define FUN_GLOBALFINDATOM          270 //
#define FUN_GLOBALGETATOMNAME       271 //
#define FUN_GRAYSTRING              185 //
#define FUN_HIDECARET               166 //
#define FUN_HILITEMENUITEM          162 //
#define FUN_ICONSIZE                86  // Internal
#define FUN_INFLATERECT             78  //
#define FUN_INITAPP                 5   // No proto
#define FUN_INSENDMESSAGE           192 //
#define FUN_INSERTMENU              410 //
#define FUN_INTERSECTRECT           79  //
#define FUN_INVALIDATERECT          125 //
#define FUN_INVALIDATERGN           126 //
#define FUN_INVERTRECT              82  //
#define FUN_ISCHARALPHA             433 //
#define FUN_ISCHARALPHANUMERIC      434 //
#define FUN_ISCHARLOWER             436 //
#define FUN_ISCHARUPPER             435 //
#define FUN_ISCHILD                 48  //
#define FUN_ISCLIPBOARDFORMATAVAILABLE  193 //
#define FUN_ISDIALOGMESSAGE         90  //
#define FUN_ISDLGBUTTONCHECKED      98  //
#define FUN_ISICONIC                31  //
#define FUN_ISRECTEMPTY             75  //
#define FUN_ISTWOBYTECHARPREFIX     51  // Internal, proto
#define FUN_ISUSERIDLE              333 // Internal
#define FUN_ISWINDOW                47  //
#define FUN_ISWINDOWENABLED         35  //
#define FUN_ISWINDOWVISIBLE         49  //
#define FUN_ISZOOMED                272 //
#define FUN_KILLSYSTEMTIMER         182 // Internal
#define FUN_KILLTIMER               12  //
#define FUN_KILLTIMER2              327 // Internal
#define FUN_LBOXCARETBLINKER        453 // Internal
#define FUN_LBOXCTLWNDPROC          307 // Internal
#define FUN_LOADACCELERATORS        177 //
#define FUN_LOADBITMAP              175 //
#define FUN_LOADCURSOR              173 //
#define FUN_LOADCURSORICONHANDLER   336 // Internal
#define FUN_LOADDIBCURSORHANDLER    356 // Internal
#define FUN_LOADDIBICONHANDLER      357 // Internal
#define FUN_LOADICON                174 //
#define FUN_LOADICONHANDLER         456 // Internal
#define FUN_LOADMENU                150 //
#define FUN_LOADMENUINDIRECT        220 //
#define FUN_LOADSTRING              176 //
#define FUN_LOCKMYTASK              276 // Internal
#define FUN_LOOKUPMENUHANDLE        217 // Internal
#define FUN_LSTRCMP                 430 //
#define FUN_LSTRCMPI                471 //
#define FUN_MAPDIALOGRECT           103 //
#define FUN_MB_DLGPROC              409 // Internal
#define FUN_MDICLIENTWNDPROC        444 // Internal
#define FUN_MENUITEMSTATE           329 // Internal
#define FUN_MENUWNDPROC             306 // Internal
#define FUN_MESSAGEBEEP             104 //
#define FUN_MESSAGEBOX              1   //
#define FUN_MODIFYMENU              414 //
#define FUN_MOVEWINDOW              56  //
#define FUN_OFFSETRECT              77  //
#define FUN_OLDEXITWINDOWS          2   // Internal
#define FUN_OPENCLIPBOARD           137 //
#define FUN_OPENCOMM                200 //
#define FUN_OPENICON                44  //
#define FUN_PAINTRECT               325 // Internal
#define FUN_PEEKMESSAGE             109 //
#define FUN_POSTAPPMESSAGE          116 //
#define FUN_POSTMESSAGE             110 //
#define FUN_POSTMESSAGE2            313 // Internal
#define FUN_POSTQUITMESSAGE         6   //
#define FUN_PTINRECT                76  //
#define FUN_READCOMM                204 //
#define FUN_REALIZEPALETTE          283 //
#define FUN_REGISTERCLASS           57  //
#define FUN_REGISTERCLIPBOARDFORMAT 145 //
#define FUN_REGISTERWINDOWMESSAGE   118 //
#define FUN_RELEASECAPTURE          19  //
#define FUN_RELEASEDC               68  //
#define FUN_REMOVEMENU              412 //
#define FUN_REMOVEPROP              24  //
#define FUN_REPAINTSCREEN           275 // No proto
#define FUN_REPLYMESSAGE            115 //
#define FUN_SBWNDPROC               304 // Internal
#define FUN_SCREENTOCLIENT          29  //
#define FUN_SCROLLCHILDREN          463 // Internal
#define FUN_SCROLLDC                221 //
#define FUN_SCROLLWINDOW            61  //
#define FUN_SELECTPALETTE           282 //
#define FUN_SENDDLGITEMMESSAGE      101 //
#define FUN_SENDMESSAGE             111 //
#define FUN_SENDMESSAGE2            312 // Internal
#define FUN_SETACTIVEWINDOW         59  //
#define FUN_SETCAPTURE              18  //
#define FUN_SETCARETBLINKTIME       168 //
#define FUN_SETCARETPOS             165 //
#define FUN_SETCLASSLONG            132 //
#define FUN_SETCLASSWORD            130 //
#define FUN_SETCLIPBOARDDATA        141 //
#define FUN_SETCLIPBOARDVIEWER      147 //
#define FUN_SETCOMMBREAK            210 //
#define FUN_SETCOMMEVENTMASK        208 //
#define FUN_SETCOMMSTATE            201 //
#define FUN_SETCURSOR               69  //
#define FUN_SETCURSORPOS            70  //
#define FUN_SETDESKPATTERN          279 // Internal
#define FUN_SETDESKWALLPAPER        285 // Internal
#define FUN_SETDLGITEMINT           94  //
#define FUN_SETDLGITEMTEXT          92  //
#define FUN_SETDOUBLECLICKTIME      20  //
#define FUN_SETEVENTHOOK            321 // Internal
#define FUN_SETFOCUS                22  //
#define FUN_SETGETKBDSTATE          330 // Internal
#define FUN_SETGRIDGRANULARITY      284 // Internal
#define FUN_SETINTERNALWINDOWPOS    461 // Internal
#define FUN_SETKEYBOARDSTATE        223 //
#define FUN_SETMENU                 158 //
#define FUN_SETMENUITEMBITMAPS      418 //
#define FUN_SETMESSAGEQUEUE         266 //
#define FUN_SETPARENT               233 //
#define FUN_SETPROP                 26  //
#define FUN_SETRECT                 72  //
#define FUN_SETRECTEMPTY            73  //
#define FUN_SETSCROLLPOS            62  //
#define FUN_SETSCROLLRANGE          64  //
#define FUN_SETSYSCOLORS            181 //
#define FUN_SETSYSMODALWINDOW       188 //
#define FUN_SETSYSTEMMENU           280 // Internal
#define FUN_SETSYSTEMTIMER          11  // Internal
#define FUN_SETTIMER                10  //
#define FUN_SETTIMER2               328 // Internal
#define FUN_SETWC2                  319 // Internal
#define FUN_SETWINDOWLONG           136 //
#define FUN_SETWINDOWPOS            232 //
#define FUN_SETWINDOWSHOOKINTERNAL  121 // Internal
#define FUN_SETWINDOWTEXT           37  //
#define FUN_SETWINDOWWORD           134 //
#define FUN_SHOWCARET               167 //
#define FUN_SHOWCURSOR              71  //
#define FUN_SHOWOWNEDPOPUPS         265 //
#define FUN_SHOWSCROLLBAR           267 //
#define FUN_SHOWWINDOW              42  //
#define FUN_SIGNALPROC              314 // Internal
#define FUN_SNAPWINDOW              281 // Internal
#define FUN_STATICWNDPROC           302 // Internal
#define FUN_STRINGFUNC              470 // Internal
#define FUN_SWAPMOUSEBUTTON         186 //
#define FUN_SWITCHTOTHISWINDOW      172 // Internal
#define FUN_SWITCHWNDPROC           347 // Internal
#define FUN_SYSERRORBOX             320 // Internal
#define FUN_TABBEDTEXTOUT           196 //
#define FUN_TABTHETEXTOUTFORWIMPS   354 // Internal
#define FUN_TILECHILDWINDOWS        199 // Internal
#define FUN_TITLEWNDPROC            345 // Internal
#define FUN_TRACKPOPUPMENU          416 //
#define FUN_TRANSLATEACCELERATOR    178 //
#define FUN_TRANSLATEMDISYSACCEL    451 //
#define FUN_TRANSLATEMESSAGE        113 //
#define FUN_TRANSMITCOMMCHAR        206 //
#define FUN_UNGETCOMMCHAR           212 //
#define FUN_UNHOOKWINDOWSHOOK       234 //
#define FUN_UNIONRECT               80  //
#define FUN_UNREGISTERCLASS         403 //
#define FUN_UPDATEWINDOW            124 //
#define FUN_USERYIELD               332 // Internal
#define FUN_VALIDATERECT            127 //
#define FUN_VALIDATERGN             128 //
#define FUN_WAITMESSAGE             112 //
#define FUN_WINDOWFROMPOINT         30  //
#define FUN_WINFARFRAME             340 // Internal
#define FUN_WINHELP                 171 //
#define FUN_WINOLDAPPHACKOMATIC     322 // Internal
#define FUN_WNETADDCONNECTION       517 // Internal
#define FUN_WNETBROWSEDIALOG        515 // Internal
#define FUN_WNETCANCELCONNECTION    518 // Internal
#define FUN_WNETCANCELJOB           506 // Internal
#define FUN_WNETCLOSEJOB            502 // Internal
#define FUN_WNETDEVICEMODE          514 // Internal
#define FUN_WNETGETCAPS             513 // Internal
#define FUN_WNETGETCONNECTION       512 // Internal
#define FUN_WNETGETERROR            519 // Internal
#define FUN_WNETGETERRORTEXT        520 // Internal
#define FUN_WNETGETUSER             516 // Internal
#define FUN_WNETHOLDJOB             504 // Internal
#define FUN_WNETLOCKQUEUEDATA       510 // Internal
#define FUN_WNETOPENJOB             501 // Internal
#define FUN_WNETRELEASEJOB          505 // Internal
#define FUN_WNETSETJOBCOPIES        507 // Internal
#define FUN_WNETUNLOCKQUEUEDATA     511 // Internal
#define FUN_WNETUNWATCHQUEUE        509 // Internal
#define FUN_WNETWATCHQUEUE          508 // Internal
#define FUN_WRITECOMM               205 //
#define FUN_WVSPRINTF               421 //
#define FUN_XCSTODS                 315 // Internal
#define FUN__FFFE_FARFRAME          341 // No proto
#define FUN__WSPRINTF               420 //
#define FUN_SETWINDOWSHOOKEX        291 // win31 api
#define FUN_UNHOOKWINDOWSHOOKEX     292 // win31 api
#define FUN_CALLNEXTHOOKEX          293 // win31 api
#define FUN_CLOSEDRIVER             253
#define FUN_COPYCURSOR              369
#define FUN_COPYICON                368
#define FUN_DEFDRIVERPROC           255
#define FUN_ENABLESCROLLBAR         482
#define FUN_GETCLIPCURSOR           309
#define FUN_GETCURSOR               247
#define FUN_GETDCEX                 359
#define FUN_GETDRIVERMODULEHANDLE   254
#define FUN_GETDRIVERINFO           256
#define FUN_GETFREESYSTEMRESOURCES  284
#define FUN_GETMESSAGEEXTRAINFO         288
#define FUN_GETNEXTDRIVER               257
#define FUN_GETOPENCLIPBOARDWINDOW      248
#define FUN_GETQUEUESTATUS              334
#define FUN_GETSYSTEMDEBUGSTATE         231
#define FUN_GETTIMERRESOLUTION          14
#define FUN_GETWINDOWPLACEMENT          370
#define FUN_ISMENU                      358
#define FUN_LOCKINPUT                   226
#define FUN_LOCKWINDOWUPDATE            294
#define FUN_MAPWINDOWPOINTS             258
#define FUN_OPENDRIVER                  252
#define FUN_QUERYSENDMESSAGE            184
#define FUN_REDRAWWINDOW                290
#define FUN_SCROLLWINDOWEX              319
#define FUN_SENDDRIVERMESSAGE           251
#define FUN_SETWINDOWPLACEMENT          371
#define FUN_SUBTRACTRECT                373
#define FUN_SYSTEMPARAMETERSINFO        483

#define FUN_TILECHILDWzINDOWS           199
#define FUN_USERSEEUSERDO               216
#define FUN_ENABLECOMMNOTIFICATION      245
#define FUN_EXITWINDOWSEXEC             246
#define FUN_OLDSETDESKPATTERN           279
#define FUN_OLDSETDESKWALLPAPER         285
#define FUN_KEYBD_EVENT                 289
#define FUN_MOUSE_EVENT                 299
#define FUN_BOZOSLIVEHERE               301
#define FUN_GETINTERNALICONHEADER       372
#define FUN_DLGDIRSELECTEX              422
#define FUN_DLGDIRSELECTCOMBOBOXEX      423
#define FUN_GETUSERLOCALOBJTYPE         480
#define FUN_HARDWARE_EVENT              481
#define FUN_DCHOOK                      362
#define FUN_WNETERRORTEXT               499
#define FUN_WNETABORTJOB                503
#define FUN_WNETENABLE                  521
#define FUN_WNETDISABLE                 522
#define FUN_WNETRESTORECONNECTION       523
#define FUN_WNETWRITEJOB                524
#define FUN_WNETCONNECTDIALOG           525
#define FUN_WNETDISCONNECTDIALOG        526
#define FUN_WNETCONNECTIONDIALOG        527
#define FUN_WNETVIEWQUEUEDIALOG         528
#define FUN_WNETPROPERTYDIALOG          529
#define FUN_WNETGETDIRECTORYTYPE        530
#define FUN_WNETDIRECTORYNOTIFY         531
#define FUN_WNETGETPROPERTYTEXT         532

/* New in Win95 user16 */

#define FUN_ACTIVATEKEYBOARDLAYOUT      562  // export 650
#define FUN_BROADCASTSYSTEMMESSAGE      554  // export 604
#define FUN_CALLMSGFILTER32             589  // export 823
#define FUN_CASCADEWINDOWS              429
#define FUN_CHANGEDISPLAYSETTINGS       557  // export 620
#define FUN_CHECKMENURADIOITEM          576  // export 666
#define FUN_CHILDWINDOWFROMPOINTEX      399
#define FUN_CHOOSECOLOR_CALLBACK16      584  // export 804
#define FUN_CHOOSEFONT_CALLBACK16       580  // export 800
#define FUN_COPYIMAGE                   390
#define FUN_CREATEICONFROMRESOURCEEX    450
#define FUN_DESTROYICON32               553  // export 610
#define FUN_DISPATCHINPUT               569  // export 658
#define FUN_DISPATCHMESSAGE32           588  // export 822
#define FUN_DLLENTRYPOINT               374
#define FUN_DOHOTKEYSTUFF               541  // export 601, export 541 NewSignalProc not thunked
#define FUN_DRAWANIMATEDRECTS           448
#define FUN_DRAWCAPTION                 571  // export 660
#define FUN_DRAWCAPTIONTEMP             568  // export 657
#define FUN_DRAWEDGE                    570  // export 659
#define FUN_DRAWFRAMECONTROL            567  // export 656
#define FUN_DRAWICONEX                  394
#define FUN_DRAWMENUBARTEMP             573  // export 662
#define FUN_DRAWSTATE                   449
#define FUN_DRAWTEXTEX                  375
#define FUN_ENUMDISPLAYSETTINGS         560  // export 621
#define FUN_FINDREPLACE_CALLBACK16      581  // export 801
#define FUN_FINDWINDOWEX                427
#define FUN_FORMATMESSAGE               556  // export 606
#define FUN_GETAPPVER                   498
#define FUN_GETCLASSINFOEX              398
#define FUN_GETFOREGROUNDWINDOW         558  // export 608
#define FUN_GETICONINFO                 395
#define FUN_GETKEYBOARDLAYOUT           563  // export 651
#define FUN_GETKEYBOARDLAYOUTLIST       564  // export 652
#define FUN_GETKEYBOARDLAYOUTNAME       477
#define FUN_GETMENUCONTEXTHELPID        385
#define FUN_GETMENUDEFAULTITEM          574  // export 663
#define FUN_GETMENUITEMINFO             443
#define FUN_GETMENUITEMRECT             575  // export 665
#define FUN_GETMESSAGE32                586  // export 820
#define FUN_GETPROPEX                   379
#define FUN_GETSCROLLINFO               476
#define FUN_GETSHELLWINDOW              540  // export 600
#define FUN_GETSYSCOLORBRUSH            281
#define FUN_GETWINDOWCONTEXTHELPID      383
#define FUN_GETWINDOWRGN                579  // export 669
#define FUN_HACKTASKMONITOR             555  // export 605
#define FUN_INITTHREADINPUT             409
#define FUN_INSERTMENUITEM              441
#define FUN_INSTALLIMT                  594  // export 890
#define FUN_ISDIALOGMESSAGE32           590  // export 824
#define FUN_LOADIMAGE                   389
#define FUN_LOADKEYBOARDLAYOUT          478
#define FUN_LOOKUPICONIDFROMDIRECTORYEX 364
#define FUN_MENUITEMFROMPOINT           479
#define FUN_MESSAGEBOXINDIRECT          593  // export 827
#define FUN_MSGWAITFORMULTIPLEOBJECTS   561  // export 640
#define FUN_OPENFILENAME_CALLBACK16     582  // export 802
#define FUN_PEEKMESSAGE32               585  // export 819
#define FUN_PLAYSOUNDEVENT              8
#define FUN_POSTMESSAGE32               591  // export 825
#define FUN_POSTPOSTEDMESSAGES          566  // export 655
#define FUN_POSTTHREADMESSAGE32         592  // export 826
#define FUN_PRINTDLG_CALLBACK16         583  // export 803
#define FUN_REGISTERCLASSEX             397
#define FUN_REMOVEPROPEX                380
#define FUN_SETCHECKCURSORTIMER         542  // export 602
#define FUN_SETFOREGROUNDWINDOW         559  // export 609
#define FUN_SETMENUCONTEXTHELPID        384
#define FUN_SETMENUDEFAULTITEM          543  // export 664
#define FUN_SETMENUITEMINFO             446
#define FUN_SETMESSAGEEXTRAINFO         376
#define FUN_SETPROPEX                   378
#define FUN_SETSCROLLINFO               475
#define FUN_SETSYSCOLORSTEMP            572  // export 661
#define FUN_SETWINDOWCONTEXTHELPID      382
#define FUN_SETWINDOWRGN                578  // export 668
#define FUN_SIGNALPROC32                391
#define FUN_TILEWINDOWS                 428
#define FUN_TRACKPOPUPMENUEX            577  // export 667
#define FUN_TRANSLATEMESSAGE32          587  // export 821
#define FUN_UNINSTALLIMT                595  // export 891
#define FUN_UNLOADINSTALLABLEDRIVERS    300
#define FUN_UNLOADKEYBOARDLAYOUT        565  // export 654
#define FUN_WINDOWFROMDC                117
#define FUN_WNETINITIALIZE              533
#define FUN_WNETLOGON                   534


/* WOW private thunks in USER */

#define FUN_NOTIFYWOW                   535
#define FUN_DEFDLGPROCTHUNK             536  // used by walias.c, not in thunk table
#define FUN_WOWWORDBREAKPROC            537
#define FUN_MOUSEEVENT                  538
#define FUN_KEYBDEVENT                  539
#define FUN_WIN32WINHELP                596  

/* NotifyWOW ID's */
#define NW_LOADICON          1
#define NW_LOADCURSOR        2
#define NW_LOADACCELERATORS  3
#define NW_FINALUSERINIT     4
#define NW_KRNL386SEGS       5
#define NW_WINHELP           6


/* XLATOFF */
#pragma pack(2)
/* XLATON */

typedef struct _ADJUSTWINDOWRECT16 {        /* u102 */
    BOOL16  f3;
    LONG    f2;
    VPRECT16 f1;
} ADJUSTWINDOWRECT16;
typedef ADJUSTWINDOWRECT16 UNALIGNED *PADJUSTWINDOWRECT16;

typedef struct _ADJUSTWINDOWRECTEX16 {      /* u454 */
    DWORD   f4;
    BOOL16  f3;
    LONG    f2;
    VPRECT16 f1;
} ADJUSTWINDOWRECTEX16;
typedef ADJUSTWINDOWRECTEX16 UNALIGNED *PADJUSTWINDOWRECTEX16;

typedef struct _ANSILOWER16 {           /* u432 */
    VPSTR   f1;
} ANSILOWER16;
typedef ANSILOWER16 UNALIGNED *PANSILOWER16;

typedef struct _ANSILOWERBUFF16 {       /* u438 */
    WORD    f2;
    VPSTR   f1;
} ANSILOWERBUFF16;
typedef ANSILOWERBUFF16 UNALIGNED *PANSILOWERBUFF16;

typedef struct _ANSINEXT16 {            /* u472 */
    VPSTR   f1;
} ANSINEXT16;
typedef ANSINEXT16 UNALIGNED *PANSINEXT16;

typedef struct _ANSIPREV16 {            /* u473 */
    VPSTR   f2;
    VPSTR   f1;
} ANSIPREV16;
typedef ANSIPREV16 UNALIGNED *PANSIPREV16;

typedef struct _ANSIUPPER16 {           /* u431 */
    VPSTR   f1;
} ANSIUPPER16;
typedef ANSIUPPER16 UNALIGNED *PANSIUPPER16;

typedef struct _ANSIUPPERBUFF16 {       /* u437 */
    WORD    f2;
    VPSTR   f1;
} ANSIUPPERBUFF16;
typedef ANSIUPPERBUFF16 UNALIGNED *PANSIUPPERBUFF16;

#ifdef NULLSTRUCT
typedef struct _ANYPOPUP16 {            /* u52 */
} ANYPOPUP16;
typedef ANYPOPUP16 UNALIGNED *PANYPOPUP16;
#endif

typedef struct _APPENDMENU16 {          /* u411 */
    VPSTR   f4;
    WORD    f3;
    WORD    f2;
    HMENU16 f1;
} APPENDMENU16;
typedef APPENDMENU16 UNALIGNED *PAPPENDMENU16;

typedef struct _ARRANGEICONICWINDOWS16 {    /* u170 */
    HWND16  hwnd;
} ARRANGEICONICWINDOWS16;
typedef ARRANGEICONICWINDOWS16 UNALIGNED *PARRANGEICONICWINDOWS16;

typedef struct _BEGINDEFERWINDOWPOS16 {     /* u259 */
    SHORT   f1;
} BEGINDEFERWINDOWPOS16;
typedef BEGINDEFERWINDOWPOS16 UNALIGNED *PBEGINDEFERWINDOWPOS16;

typedef struct _BEGINPAINT16 {          /* u39 */
    VPPAINTSTRUCT16 vpPaint;
    HWND16  hwnd;
} BEGINPAINT16;
typedef BEGINPAINT16 UNALIGNED *PBEGINPAINT16;

typedef struct _BRINGWINDOWTOTOP16 {        /* u45 */
    HWND16  f1;
} BRINGWINDOWTOTOP16;
typedef BRINGWINDOWTOTOP16 UNALIGNED *PBRINGWINDOWTOTOP16;

typedef struct _BROADCASTMESSAGE16 {    /* u355 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} BROADCASTMESSAGE16;
typedef BROADCASTMESSAGE16 UNALIGNED *PBROADCASTMESSAGE16;

typedef struct _BUILDCOMMDCB16 {        /* u213 */
    VPDCB16 f2;
    VPSTR   f1;
} BUILDCOMMDCB16;
typedef BUILDCOMMDCB16 UNALIGNED *PBUILDCOMMDCB16;

typedef struct _CALCCHILDSCROLL16 {     /* u462 */
    WORD    f2;
    HWND16  f1;
} CALCCHILDSCROLL16;
typedef CALCCHILDSCROLL16 UNALIGNED *PCALCCHILDSCROLL16;

typedef struct _CALLMSGFILTER16 {       /* u123 */
    SHORT   f2;
    VPMSG16 f1;
} CALLMSGFILTER16;
typedef CALLMSGFILTER16 UNALIGNED *PCALLMSGFILTER16;

typedef struct _CALLWINDOWPROC16 {      /* u122 */
    LONG    f5;
    WORD    f4;
    WORD    f3;
    HWND16  f2;
    VPPROC f1;
} CALLWINDOWPROC16;
typedef CALLWINDOWPROC16 UNALIGNED *PCALLWINDOWPROC16;

typedef struct _CARETBLINKPROC16 {      /* u311 */
    DWORD   f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} CARETBLINKPROC16;
typedef CARETBLINKPROC16 UNALIGNED *PCARETBLINKPROC16;

typedef struct _CASCADECHILDWINDOWS16 { /* u198 */
    WORD    f2;
    HWND16  f1;
} CASCADECHILDWINDOWS16;
typedef CASCADECHILDWINDOWS16 UNALIGNED *PCASCADECHILDWINDOWS16;

typedef struct _CHANGECLIPBOARDCHAIN16 {    /* u149 */
    HWND16  f2;
    HWND16  f1;
} CHANGECLIPBOARDCHAIN16;
typedef CHANGECLIPBOARDCHAIN16 UNALIGNED *PCHANGECLIPBOARDCHAIN16;

typedef struct _CHANGEMENU16 {          /* u153 */
    WORD    f5;
    WORD    f4;
    VPSTR   f3;
    WORD    f2;
    HMENU16 f1;
} CHANGEMENU16;
typedef CHANGEMENU16 UNALIGNED *PCHANGEMENU16;

typedef struct _CHECKDLGBUTTON16 {      /* u97 */
    WORD    f3;
    SHORT   f2;
    HWND16  f1;
} CHECKDLGBUTTON16;
typedef CHECKDLGBUTTON16 UNALIGNED *PCHECKDLGBUTTON16;

typedef struct _CHECKMENUITEM16 {       /* u154 */
    WORD    f3;
    WORD    f2;
    HMENU16 f1;
} CHECKMENUITEM16;
typedef CHECKMENUITEM16 UNALIGNED *PCHECKMENUITEM16;

typedef struct _CHECKRADIOBUTTON16 {        /* u96 */
    SHORT   f4;
    SHORT   f3;
    SHORT   f2;
    HWND16  f1;
} CHECKRADIOBUTTON16;
typedef CHECKRADIOBUTTON16 UNALIGNED *PCHECKRADIOBUTTON16;

typedef struct _CHILDWINDOWFROMPOINT16 {    /* u191 */
    POINT16 f2;
    HWND16  f1;
} CHILDWINDOWFROMPOINT16;
typedef CHILDWINDOWFROMPOINT16 UNALIGNED *PCHILDWINDOWFROMPOINT16;

typedef struct _CLEARCOMMBREAK16 {      /* u211 */
    SHORT   f1;
} CLEARCOMMBREAK16;
typedef CLEARCOMMBREAK16 UNALIGNED *PCLEARCOMMBREAK16;

typedef struct _CLIENTTOSCREEN16 {      /* u28 */
    VPPOINT16 f2;
    HWND16  f1;
} CLIENTTOSCREEN16;
typedef CLIENTTOSCREEN16 UNALIGNED *PCLIENTTOSCREEN16;

typedef struct _CLIPCURSOR16 {          /* u16 */
    VPRECT16 f1;
} CLIPCURSOR16;
typedef CLIPCURSOR16 UNALIGNED *PCLIPCURSOR16;

#ifdef NULLSTRUCT
typedef struct _CLOSECLIPBOARD16 {      /* u138 */
} CLOSECLIPBOARD16;
typedef CLOSECLIPBOARD16 UNALIGNED *PCLOSECLIPBOARD16;
#endif

typedef struct _CLOSECOMM16 {           /* u207 */
    VPDWORD f2;  /* added for SetCommEventMask() support */
    SHORT   f1;
} CLOSECOMM16;
typedef CLOSECOMM16 UNALIGNED *PCLOSECOMM16;

typedef struct _CLOSEWINDOW16 {         /* u43 */
    HWND16  f1;
} CLOSEWINDOW16;
typedef CLOSEWINDOW16 UNALIGNED *PCLOSEWINDOW16;

typedef struct _COMPUPDATERECT16 {      /* u316 */
    WORD     f4;
    BOOL16   f3;
    VPRECT16 f2;
    HWND16   f1;
} COMPUPDATERECT16;
typedef COMPUPDATERECT16 UNALIGNED *PCOMPUPDATERECT16;

typedef struct _COMPUPDATERGN16 {       /* u317 */
    WORD     f4;
    BOOL16   f3;
    HRGN16   f2;
    HWND16   f1;
} COMPUPDATERGN16;
typedef COMPUPDATERGN16 UNALIGNED *PCOMPUPDATERGN16;

typedef struct _CONTROLPANELINFO16 {    /* u273 */
    VPVOID  f3;
    WORD    f2;
    WORD    f1;
} CONTROLPANELINFO16;
typedef CONTROLPANELINFO16 UNALIGNED *PCONTROLPANELINFO16;

typedef struct _CONTSCROLL16 {          /* u310 */
    DWORD   f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} CONTSCROLL16;
typedef CONTSCROLL16 UNALIGNED *PCONTSCROLL16;

typedef struct _COPYRECT16 {            /* u74 */
    VPRECT16 f2;
    VPRECT16 f1;
} COPYRECT16;
typedef COPYRECT16 UNALIGNED *PCOPYRECT16;

#ifdef NULLSTRUCT
typedef struct _COUNTCLIPBOARDFORMATS16 {   /* u143 */
} COUNTCLIPBOARDFORMATS16;
typedef COUNTCLIPBOARDFORMATS16 UNALIGNED *PCOUNTCLIPBOARDFORMATS16;
#endif

typedef struct _CREATECARET16 {         /* u163 */
    SHORT   f4;
    SHORT   f3;
    HBM16   f2;
    HWND16  f1;
} CREATECARET16;
typedef CREATECARET16 UNALIGNED *PCREATECARET16;

typedef struct _CREATECURSOR16 {        /* u406 */
    VPSTR   f7;
    VPSTR   f6;
    SHORT   f5;
    SHORT   f4;
    SHORT   f3;
    SHORT   f2;
    HAND16  f1;
} CREATECURSOR16;
typedef CREATECURSOR16 UNALIGNED *PCREATECURSOR16;

typedef struct _CREATECURSORICONINDIRECT16 { /* u408 */
    VPSTR   f4;
    VPSTR   f3;
    VPSTR   f2;
    HAND16  f1;
} CREATECURSORICONINDIRECT16;
typedef CREATECURSORICONINDIRECT16 UNALIGNED *PCREATECURSORICONINDIRECT16;

typedef struct _CREATEDIALOG16 {        /* u89 */
    VPPROC  f4;
    HWND16  f3;
    VPSTR   f2;
    HAND16  f1;
} CREATEDIALOG16;
typedef CREATEDIALOG16 UNALIGNED *PCREATEDIALOG16;

typedef struct _CREATEDIALOGINDIRECT16 {    /* u219 */
    VPPROC f4;
    HWND16  f3;
    VPSTR   f2;
    HAND16  f1;
} CREATEDIALOGINDIRECT16;
typedef CREATEDIALOGINDIRECT16 UNALIGNED *PCREATEDIALOGINDIRECT16;

typedef struct _CREATEDIALOGINDIRECTPARAM16 {   /* u242 */
    LONG    f5;
    VPPROC f4;
    HWND16  f3;
    VPSTR   f2;
    HAND16  f1;
} CREATEDIALOGINDIRECTPARAM16;
typedef CREATEDIALOGINDIRECTPARAM16 UNALIGNED *PCREATEDIALOGINDIRECTPARAM16;

typedef struct _CREATEDIALOGPARAM16 {       /* u241 */
    DWORD   f6;
    LONG    f5;
    VPPROC  f4;
    HWND16  f3;
    VPSTR   f2;
    HAND16  f1;
} CREATEDIALOGPARAM16;
typedef CREATEDIALOGPARAM16 UNALIGNED *PCREATEDIALOGPARAM16;

typedef struct _CREATEICON16 {          /* u407 */
    VPSTR   f7;
    VPSTR   f6;
    WORD    f5;
    WORD    f4;
    SHORT   f3;
    SHORT   f2;
    HAND16  f1;
} CREATEICON16;
typedef CREATEICON16 UNALIGNED *PCREATEICON16;

#ifdef NULLSTRUCT
typedef struct _CREATEMENU16 {          /* u151 */
} CREATEMENU16;
typedef CREATEMENU16 UNALIGNED *PCREATEMENU16;
#endif

#ifdef NULLSTRUCT
typedef struct _CREATEPOPUPMENU16 {     /* u415 */
} CREATEPOPUPMENU16;
typedef CREATEPOPUPMENU16 UNALIGNED *PCREATEPOPUPMENU16;
#endif

typedef struct _CREATEWINDOW16 {        /* u41 */
    VPBYTE  vpParam;
    HAND16  hInstance;
    HMENU16 hMenu;
    HWND16  hwndParent;
    SHORT   cy;
    SHORT   cx;
    SHORT   y;
    SHORT   x;
    DWORD   dwStyle;
    VPSTR   vpszWindow;
    VPSTR   vpszClass;
} CREATEWINDOW16;
typedef CREATEWINDOW16 UNALIGNED *PCREATEWINDOW16;

typedef struct _CREATEWINDOWEX16 {      /* u452 */
    VPSTR   f12;
    HAND16  f11;
    HMENU16 f10;
    HWND16  f9;
    SHORT   f8;
    SHORT   f7;
    SHORT   f6;
    SHORT   f5;
    DWORD   f4;
    VPSTR   f3;
    VPSTR   f2;
    DWORD   f1;
} CREATEWINDOWEX16;
typedef CREATEWINDOWEX16 UNALIGNED *PCREATEWINDOWEX16;

typedef struct _DCHOOK16 {              /* u362 */
    DWORD   f4;
    DWORD   f3;
    WORD    f2;
    HDC16   f1;
} DCHOOK16;
typedef DCHOOK16 UNALIGNED *PDCHOOK16;

typedef struct _DEFDLGPROC16 {          /* u308 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} DEFDLGPROC16;
typedef DEFDLGPROC16 UNALIGNED *PDEFDLGPROC16;

typedef struct _DEFERWINDOWPOS16 {      /* u260 */
    WORD    f8;
    SHORT   f7;
    SHORT   f6;
    SHORT   f5;
    SHORT   f4;
    HWND16  f3;
    HWND16  f2;
    HAND16  f1;
} DEFERWINDOWPOS16;
typedef DEFERWINDOWPOS16 UNALIGNED *PDEFERWINDOWPOS16;

typedef struct _DEFFRAMEPROC16 {        /* u445 */
    LONG    f5;
    WORD    f4;
    WORD    f3;
    HWND16  f2;
    HWND16  f1;
} DEFFRAMEPROC16;
typedef DEFFRAMEPROC16 UNALIGNED *PDEFFRAMEPROC16;

typedef struct _DEFHOOKPROC16 {         /* u235 */
    VPPROC f4;
    DWORD   f3;
    WORD    f2;
    SHORT   f1;
} DEFHOOKPROC16;
typedef DEFHOOKPROC16 UNALIGNED *PDEFHOOKPROC16;

typedef struct _DEFMDICHILDPROC16 {     /* u447 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} DEFMDICHILDPROC16;
typedef DEFMDICHILDPROC16 UNALIGNED *PDEFMDICHILDPROC16;

typedef struct _DEFWINDOWPROC16 {       /* u107 */
    LONG    lParam;
    WORD    wParam;
    WORD    wMsg;
    HWND16  hwnd;
} DEFWINDOWPROC16;
typedef DEFWINDOWPROC16 UNALIGNED *PDEFWINDOWPROC16;

typedef struct _DELETEMENU16 {          /* u413 */
    WORD    f3;
    WORD    f2;
    HMENU16 f1;
} DELETEMENU16;
typedef DELETEMENU16 UNALIGNED *PDELETEMENU16;

typedef struct _DESKTOPWNDPROC16 {      /* u305 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} DESKTOPWNDPROC16;
typedef DESKTOPWNDPROC16 UNALIGNED *PDESKTOPWNDPROC16;

#ifdef NULLSTRUCT
typedef struct _DESTROYCARET16 {        /* u164 */
} DESTROYCARET16;
typedef DESTROYCARET16 UNALIGNED *PDESTROYCARET16;
#endif

typedef struct _DESTROYCURSOR16 {       /* u458 */
    HCUR16  f1;
} DESTROYCURSOR16;
typedef DESTROYCURSOR16 UNALIGNED *PDESTROYCURSOR16;

typedef struct _DESTROYICON16 {         /* u457 */
    HICON16 f1;
} DESTROYICON16;
typedef DESTROYICON16 UNALIGNED *PDESTROYICON16;

typedef struct _DESTROYMENU16 {         /* u152 */
    HMENU16 f1;
} DESTROYMENU16;
typedef DESTROYMENU16 UNALIGNED *PDESTROYMENU16;

typedef struct _DESTROYWINDOW16 {       /* u53 */
    HWND16 f1;
} DESTROYWINDOW16;
typedef DESTROYWINDOW16 UNALIGNED *PDESTROYWINDOW16;

typedef struct _DIALOGBOX16 {           /* u87 */
    VPPROC f4;
    HWND16  f3;
    VPSTR   f2;
    HAND16  f1;
} DIALOGBOX16;
typedef DIALOGBOX16 UNALIGNED *PDIALOGBOX16;

typedef struct _DIALOGBOXINDIRECT16 {       /* u218 */
    VPPROC f4;
    HWND16  f3;
    HAND16  f2;
    HAND16  f1;
} DIALOGBOXINDIRECT16;
typedef DIALOGBOXINDIRECT16 UNALIGNED *PDIALOGBOXINDIRECT16;

typedef struct _DIALOGBOXINDIRECTPARAM16 {  /* u240 */
    LONG    f5;
    VPPROC f4;
    HWND16  f3;
    HAND16  f2;
    HAND16  f1;
} DIALOGBOXINDIRECTPARAM16;
typedef DIALOGBOXINDIRECTPARAM16 UNALIGNED *PDIALOGBOXINDIRECTPARAM16;

typedef struct _DIALOGBOXPARAM16 {      /* u239 */
    WORD    f7;
    DWORD   f6;
    LONG    f5;
    VPPROC  f4;
    HWND16  f3;
    VPSTR   f2;
    HAND16  f1;
} DIALOGBOXPARAM16;
typedef DIALOGBOXPARAM16 UNALIGNED *PDIALOGBOXPARAM16;

#ifdef NULLSTRUCT
typedef struct _DISABLEOEMLAYER16 {     /* u4 */
} DISABLEOEMLAYER16;
typedef DISABLEOEMLAYER16 UNALIGNED *PDISABLEOEMLAYER16;
#endif

typedef struct _DISPATCHMESSAGE16 {     /* u114 */
    VPMSG16 f1;
} DISPATCHMESSAGE16;
typedef DISPATCHMESSAGE16 UNALIGNED *PDISPATCHMESSAGE16;

typedef struct _DLGDIRLIST16 {          /* u100 */
    WORD    f5;
    SHORT   f4;
    SHORT   f3;
    VPSTR   f2;
    HWND16  f1;
} DLGDIRLIST16;
typedef DLGDIRLIST16 UNALIGNED *PDLGDIRLIST16;

typedef struct _DLGDIRLISTCOMBOBOX16 {      /* u195 */
    WORD    f5;
    SHORT   f4;
    SHORT   f3;
    VPSTR   f2;
    HWND16  f1;
} DLGDIRLISTCOMBOBOX16;
typedef DLGDIRLISTCOMBOBOX16 UNALIGNED *PDLGDIRLISTCOMBOBOX16;

typedef struct _DLGDIRSELECT16 {        /* u99 */
    SHORT   f3;
    VPSTR   f2;
    HWND16  f1;
} DLGDIRSELECT16;
typedef DLGDIRSELECT16 UNALIGNED *PDLGDIRSELECT16;

typedef struct _DLGDIRSELECTCOMBOBOX16 {    /* u194 */
    SHORT   f3;
    VPSTR   f2;
    HWND16  f1;
} DLGDIRSELECTCOMBOBOX16;
typedef DLGDIRSELECTCOMBOBOX16 UNALIGNED *PDLGDIRSELECTCOMBOBOX16;

typedef struct _DLGDIRSELECTEX16 {  /* u422 */
    SHORT   f4;
    SHORT   f3;
    VPSTR   f2;
    HWND16  f1;
} DLGDIRSELECTEX16;
typedef DLGDIRSELECTEX16 UNALIGNED *PDLGDIRSELECTEX16;

typedef struct _DLGDIRSELECTCOMBOBOXEX16 {    /* u423 */
    SHORT   f4;
    SHORT   f3;
    VPSTR   f2;
    HWND16  f1;
} DLGDIRSELECTCOMBOBOXEX16;
typedef DLGDIRSELECTCOMBOBOXEX16 UNALIGNED *PDLGDIRSELECTCOMBOBOXEX16;

typedef struct _DRAGDETECT16 {          /* u465 */
    POINT16 pt;
    HWND16  hwnd;
} DRAGDETECT16;
typedef DRAGDETECT16 UNALIGNED *PDRAGDETECT16;

typedef struct _DRAGOBJECT16 {          /* u464 */
    HAND16  f5;
    LONG    f4;
    WORD    f3;
    HWND16  f2;
    HWND16  f1;
} DRAGOBJECT16;
typedef DRAGOBJECT16 UNALIGNED *PDRAGOBJECT16;

typedef struct _DRAWFOCUSRECT16 {       /* u466 */
    VPRECT16 f2;
    HDC16   f1;
} DRAWFOCUSRECT16;
typedef DRAWFOCUSRECT16 UNALIGNED *PDRAWFOCUSRECT16;

typedef struct _DRAWICON16 {            /* u84 */
    HICON16 f4;
    SHORT   f3;
    SHORT   f2;
    HDC16   f1;
} DRAWICON16;
typedef DRAWICON16 UNALIGNED *PDRAWICON16;

typedef struct _DRAWMENUBAR16 {         /* u160 */
    HWND16  f1;
} DRAWMENUBAR16;
typedef DRAWMENUBAR16 UNALIGNED *PDRAWMENUBAR16;

typedef struct _DRAWTEXT16 {            /* u85 */
    WORD     wFormat;
    VPRECT16 vpRect;
    SHORT    nCount;
    VPSTR    vpString;
    HDC16    hdc;
} DRAWTEXT16;
typedef DRAWTEXT16 UNALIGNED *PDRAWTEXT16;

typedef struct _DUMPICON16 {            /* u459 */
    VPSTR   f4;
    VPSTR   f3;
    VPWORD  f2;
    VPSTR   f1;
} DUMPICON16;
typedef DUMPICON16 UNALIGNED *PDUMPICON16;

#ifdef NULLSTRUCT
typedef struct _EMPTYCLIPBOARD16 {      /* u139 */
} EMPTYCLIPBOARD16;
typedef EMPTYCLIPBOARD16 UNALIGNED *PEMPTYCLIPBOARD16;
#endif

typedef struct _ENABLECOMMNOTIFICATION16 {     /* u245 */
    SHORT   f4;
    SHORT   f3;
    HWND16  f2;
    SHORT   f1;
} ENABLECOMMNOTIFICATION16;
typedef ENABLECOMMNOTIFICATION16 UNALIGNED *PENABLECOMMNOTIFICATION16;


typedef struct _ENABLEHARDWAREINPUT16 {     /* u331 */
    BOOL16  f1;
} ENABLEHARDWAREINPUT16;
typedef ENABLEHARDWAREINPUT16 UNALIGNED *PENABLEHARDWAREINPUT16;

typedef struct _ENABLEMENUITEM16 {      /* u155 */
    WORD    f3;
    WORD    f2;
    HMENU16 f1;
} ENABLEMENUITEM16;
typedef ENABLEMENUITEM16 UNALIGNED *PENABLEMENUITEM16;

#ifdef NULLSTRUCT
typedef struct _ENABLEOEMLAYER16 {      /* u3 */
} ENABLEOEMLAYER16;
typedef ENABLEOEMLAYER16 UNALIGNED *PENABLEOEMLAYER16;
#endif

typedef struct _ENABLEWINDOW16 {        /* u34 */
    BOOL16  f2;
    HWND16  f1;
} ENABLEWINDOW16;
typedef ENABLEWINDOW16 UNALIGNED *PENABLEWINDOW16;

typedef struct _ENDDEFERWINDOWPOS16 {       /* u261 */
    HAND16  f1;
} ENDDEFERWINDOWPOS16;
typedef ENDDEFERWINDOWPOS16 UNALIGNED *PENDDEFERWINDOWPOS16;

typedef struct _ENDDIALOG16 {           /* u88 */
    SHORT   f2;
    HWND16  f1;
} ENDDIALOG16;
typedef ENDDIALOG16 UNALIGNED *PENDDIALOG16;

#ifdef NULLSTRUCT
typedef struct _ENDMENU16 {             /* u187 */
} ENDMENU16;
typedef ENDMENU16 UNALIGNED *PENDMENU16;
#endif

typedef struct _ENDPAINT16 {            /* u40 */
    VPPAINTSTRUCT16 vpPaint;
    HWND16  hwnd;
} ENDPAINT16;
typedef ENDPAINT16 UNALIGNED *PENDPAINT16;

typedef struct _ENUMCHILDWINDOWS16 {        /* u55 */
    LONG    f3;
    VPPROC f2;
    HWND16  f1;
} ENUMCHILDWINDOWS16;
typedef ENUMCHILDWINDOWS16 UNALIGNED *PENUMCHILDWINDOWS16;

typedef struct _ENUMCLIPBOARDFORMATS16 {    /* u144 */
    WORD    f1;
} ENUMCLIPBOARDFORMATS16;
typedef ENUMCLIPBOARDFORMATS16 UNALIGNED *PENUMCLIPBOARDFORMATS16;

typedef struct _ENUMPROPS16 {           /* u27 */
    VPPROC f2;
    HWND16 f1;
} ENUMPROPS16;
typedef ENUMPROPS16 UNALIGNED *PENUMPROPS16;

typedef struct _ENUMTASKWINDOWS16 {     /* u225 */
    LONG    f3;
    VPPROC f2;
    HAND16  f1;
} ENUMTASKWINDOWS16;
typedef ENUMTASKWINDOWS16 UNALIGNED *PENUMTASKWINDOWS16;

typedef struct _ENUMWINDOWS16 {         /* u54 */
    LONG    f2;
    VPPROC f1;
} ENUMWINDOWS16;
typedef ENUMWINDOWS16 UNALIGNED *PENUMWINDOWS16;

typedef struct _EQUALRECT16 {           /* u244 */
    VPRECT16 f2;
    VPRECT16 f1;
} EQUALRECT16;
typedef EQUALRECT16 UNALIGNED *PEQUALRECT16;

typedef struct _ESCAPECOMMFUNCTION16 {      /* u214 */
    SHORT   f2;
    SHORT   f1;
} ESCAPECOMMFUNCTION16;
typedef ESCAPECOMMFUNCTION16 UNALIGNED *PESCAPECOMMFUNCTION16;

typedef struct _EXCLUDEUPDATERGN16 {        /* u238 */
    HWND16  f2;
    HDC16   f1;
} EXCLUDEUPDATERGN16;
typedef EXCLUDEUPDATERGN16 UNALIGNED *PEXCLUDEUPDATERGN16;

typedef struct _EXITWINDOWS16 {         /* u7 */
    WORD    wReturnCode;
    DWORD   dwReserved;
} EXITWINDOWS16;
typedef EXITWINDOWS16 UNALIGNED *PEXITWINDOWS16;

typedef struct _EXITWINDOWSEXEC16 {     /* u246 */
    VPSTR   vpCmdLine;
    VPSTR   vpProgName;
} EXITWINDOWSEXEC16;
typedef EXITWINDOWSEXEC16 UNALIGNED *PEXITWINDOWSEXEC16;

#ifdef NULLSTRUCT
typedef struct _FARCALLNETDRIVER16 {    /* u500 */
} FARCALLNETDRIVER16;
typedef FARCALLNETDRIVER16 UNALIGNED *PFARCALLNETDRIVER16;
#endif

typedef struct _FILEPORTDLGPROC16 {     /* u346 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} FILEPORTDLGPROC16;
typedef FILEPORTDLGPROC16 UNALIGNED *PFILEPORTDLGPROC16;

typedef struct _FILLRECT16 {            /* u81 */
    HBRSH16 f3;
    VPRECT16 f2;
    HDC16 f1;
} FILLRECT16;
typedef FILLRECT16 UNALIGNED *PFILLRECT16;

#ifdef NULLSTRUCT
typedef struct _FINALUSERINIT16 {       /* u400 */
} FINALUSERINIT16;
typedef FINALUSERINIT16 UNALIGNED *PFINALUSERINIT16;
#endif

typedef struct _FINDWINDOW16 {          /* u50 */
    VPSTR   f2;
    VPSTR   f1;
} FINDWINDOW16;
typedef FINDWINDOW16 UNALIGNED *PFINDWINDOW16;

typedef struct _FLASHWINDOW16 {         /* u105 */
    BOOL16  f2;
    HWND16  f1;
} FLASHWINDOW16;
typedef FLASHWINDOW16 UNALIGNED *PFLASHWINDOW16;

typedef struct _FLUSHCOMM16 {           /* u215 */
    SHORT   f2;
    SHORT   f1;
} FLUSHCOMM16;
typedef FLUSHCOMM16 UNALIGNED *PFLUSHCOMM16;

typedef struct _FRAMERECT16 {           /* u83 */
    HBRSH16 f3;
    VPRECT16 f2;
    HDC16 f1;
} FRAMERECT16;
typedef FRAMERECT16 UNALIGNED *PFRAMERECT16;

#ifdef NULLSTRUCT
typedef struct _GETACTIVEWINDOW16 {     /* u60 */
} GETACTIVEWINDOW16;
typedef GETACTIVEWINDOW16 UNALIGNED *PGETACTIVEWINDOW16;
#endif

typedef struct _GETASYNCKEYSTATE16 {        /* u249 */
    SHORT   f1;
} GETASYNCKEYSTATE16;
typedef GETASYNCKEYSTATE16 UNALIGNED *PGETASYNCKEYSTATE16;

#ifdef NULLSTRUCT
typedef struct _GETCAPTURE16 {          /* u236 */
} GETCAPTURE16;
typedef GETCAPTURE16 UNALIGNED *PGETCAPTURE16;
#endif

#ifdef NULLSTRUCT
typedef struct _GETCARETBLINKTIME16 {       /* u169 */
} GETCARETBLINKTIME16;
typedef GETCARETBLINKTIME16 UNALIGNED *PGETCARETBLINKTIME16;
#endif

typedef struct _GETCARETPOS16 {         /* u183 */
    VPPOINT16 f1;
} GETCARETPOS16;
typedef GETCARETPOS16 UNALIGNED *PGETCARETPOS16;

typedef struct _GETCLASSINFO16 {        /* u404 */
    VPWNDCLASS16 f3;
    VPSTR   f2;
    HAND16  f1;
} GETCLASSINFO16;
typedef GETCLASSINFO16 UNALIGNED *PGETCLASSINFO16;

typedef struct _GETCLASSLONG16 {        /* u131 */
    SHORT   f2;
    HWND16  f1;
} GETCLASSLONG16;
typedef GETCLASSLONG16 UNALIGNED *PGETCLASSLONG16;

typedef struct _GETCLASSNAME16 {        /* u58 */
    SHORT   f3;
    VPSTR   f2;
    HWND16  f1;
} GETCLASSNAME16;
typedef GETCLASSNAME16 UNALIGNED *PGETCLASSNAME16;

typedef struct _GETCLASSWORD16 {        /* u129 */
    SHORT   f2;
    HWND16  f1;
} GETCLASSWORD16;
typedef GETCLASSWORD16 UNALIGNED *PGETCLASSWORD16;

typedef struct _GETCLIENTRECT16 {       /* u33 */
    VPRECT16 vpRect;
    HWND16   hwnd;
} GETCLIENTRECT16;
typedef GETCLIENTRECT16 UNALIGNED *PGETCLIENTRECT16;

typedef struct _GETCLIPBOARDDATA16 {        /* u142 */
    WORD    f1;
} GETCLIPBOARDDATA16;
typedef GETCLIPBOARDDATA16 UNALIGNED *PGETCLIPBOARDDATA16;

typedef struct _GETCLIPBOARDFORMATNAME16 {  /* u146 */
    SHORT   f3;
    VPSTR   f2;
    WORD    f1;
} GETCLIPBOARDFORMATNAME16;
typedef GETCLIPBOARDFORMATNAME16 UNALIGNED *PGETCLIPBOARDFORMATNAME16;

#ifdef NULLSTRUCT
typedef struct _GETCLIPBOARDOWNER16 {       /* u140 */
} GETCLIPBOARDOWNER16;
typedef GETCLIPBOARDOWNER16 UNALIGNED *PGETCLIPBOARDOWNER16;
#endif

#ifdef NULLSTRUCT
typedef struct _GETCLIPBOARDVIEWER16 {      /* u148 */
} GETCLIPBOARDVIEWER16;
typedef GETCLIPBOARDVIEWER16 UNALIGNED *PGETCLIPBOARDVIEWER16;
#endif

typedef struct _GETCOMMERROR16 {        /* u203 */
    VPCOMSTAT16 f2;
    SHORT   f1;
} GETCOMMERROR16;
typedef GETCOMMERROR16 UNALIGNED *PGETCOMMERROR16;

typedef struct _GETCOMMEVENTMASK16 {        /* u209 */
    SHORT   f2;
    SHORT   f1;
} GETCOMMEVENTMASK16;
typedef GETCOMMEVENTMASK16 UNALIGNED *PGETCOMMEVENTMASK16;

typedef struct _GETCOMMSTATE16 {        /* u202 */
    VPDCB16 f2;
    SHORT   f1;
} GETCOMMSTATE16;
typedef GETCOMMSTATE16 UNALIGNED *PGETCOMMSTATE16;

typedef struct _GETCONTROLBRUSH16 {     /* u326 */
    WORD    f3;
    HDC16   f2;
    HWND16  f1;
} GETCONTROLBRUSH16;
typedef GETCONTROLBRUSH16 UNALIGNED *PGETCONTROLBRUSH16;

#ifdef NULLSTRUCT
typedef struct _GETCURRENTTIME16 {      /* u15 */
} GETCURRENTTIME16;
typedef GETCURRENTTIME16 UNALIGNED *PGETCURRENTTIME16;
#endif

typedef struct _GETCURSORPOS16 {        /* u17 */
    VPPOINT16 f1;
} GETCURSORPOS16;
typedef GETCURSORPOS16 UNALIGNED *PGETCURSORPOS16;

typedef struct _GETDC16 {           /* u66 */
    HWND16  f1;
} GETDC16;
typedef GETDC16 UNALIGNED *PGETDC16;

#ifdef NULLSTRUCT
typedef struct _GETDESKTOPHWND16 {      /* u278 */
} GETDESKTOPHWND16;
typedef GETDESKTOPHWND16 UNALIGNED *PGETDESKTOPHWND16;
#endif

#ifdef NULLSTRUCT
typedef struct _GETDESKTOPWINDOW16 {        /* u286 */
} GETDESKTOPWINDOW16;
typedef GETDESKTOPWINDOW16 UNALIGNED *PGETDESKTOPWINDOW16;
#endif

#ifdef NULLSTRUCT
typedef struct _GETDIALOGBASEUNITS16 {      /* u243 */
} GETDIALOGBASEUNITS16;
typedef GETDIALOGBASEUNITS16 UNALIGNED *PGETDIALOGBASEUNITS16;
#endif

typedef struct _GETDLGCTRLID16 {        /* u277 */
    HWND16  f1;
} GETDLGCTRLID16;
typedef GETDLGCTRLID16 UNALIGNED *PGETDLGCTRLID16;

typedef struct _GETDLGITEM16 {          /* u91 */
    SHORT   f2;
    HWND16  f1;
} GETDLGITEM16;
typedef GETDLGITEM16 UNALIGNED *PGETDLGITEM16;

typedef struct _GETDLGITEMINT16 {       /* u95 */
    BOOL16  f4;
    VPBOOL16 f3;
    SHORT   f2;
    HWND16  f1;
} GETDLGITEMINT16;
typedef GETDLGITEMINT16 UNALIGNED *PGETDLGITEMINT16;

typedef struct _GETDLGITEMTEXT16 {      /* u93 */
    SHORT   f4;
    VPSTR   f3;
    SHORT   f2;
    HWND16  f1;
} GETDLGITEMTEXT16;
typedef GETDLGITEMTEXT16 UNALIGNED *PGETDLGITEMTEXT16;

#ifdef NULLSTRUCT
typedef struct _GETDOUBLECLICKTIME16 {      /* u21 */
} GETDOUBLECLICKTIME16;
typedef GETDOUBLECLICKTIME16 UNALIGNED *PGETDOUBLECLICKTIME16;
#endif

typedef struct _GETFILEPORTNAME16 {     /* u343 */
    VPSTR   f1;
} GETFILEPORTNAME16;
typedef GETFILEPORTNAME16 UNALIGNED *PGETFILEPORTNAME16;

#ifdef NULLSTRUCT
typedef struct _GETFOCUS16 {            /* u23 */
} GETFOCUS16;
typedef GETFOCUS16 UNALIGNED *PGETFOCUS16;
#endif

typedef struct _GETICONID16 {           /* u455 */
    VPSTR  f2;
    HAND16 f1;
} GETICONID16;
typedef GETICONID16 UNALIGNED *PGETICONID16;

#ifdef NULLSTRUCT
typedef struct _GETINPUTSTATE16 {       /* u335 */
} GETINPUTSTATE16;
typedef GETINPUTSTATE16 UNALIGNED *PGETINPUTSTATE16;
#endif

typedef struct _GETINTERNALICONHEADER16 {   /* u372 */
    VPSTR   f2;
    VPSTR   f1;
} GETINTERNALICONHEADER16;
typedef GETINTERNALICONHEADER16 UNALIGNED *PGETINTERNALICONHEADER16;

typedef struct _GETINTERNALWINDOWPOS16 {    /* u460 */
    VPPOINT16 f3;
    VPRECT16  f2;
    HWND16    f1;
} GETINTERNALWINDOWPOS16;
typedef GETINTERNALWINDOWPOS16 UNALIGNED *PGETINTERNALWINDOWPOS16;

typedef struct _GETKEYBOARDSTATE16 {        /* u222 */
    VPBYTE  f1;
} GETKEYBOARDSTATE16;
typedef GETKEYBOARDSTATE16 UNALIGNED *PGETKEYBOARDSTATE16;

typedef struct _GETKEYSTATE16 {         /* u106 */
    SHORT   f1;
} GETKEYSTATE16;
typedef GETKEYSTATE16 UNALIGNED *PGETKEYSTATE16;

typedef struct _GETLASTACTIVEPOPUP16 {      /* u287 */
    HWND16  f1;
} GETLASTACTIVEPOPUP16;
typedef GETLASTACTIVEPOPUP16 UNALIGNED *PGETLASTACTIVEPOPUP16;

typedef struct _GETMENU16 {         /* u157 */
    HWND16  f1;
} GETMENU16;
typedef GETMENU16 UNALIGNED *PGETMENU16;

#ifdef NULLSTRUCT
typedef struct _GETMENUCHECKMARKDIMENSIONS16 {  /* u417 */
} GETMENUCHECKMARKDIMENSIONS16;
typedef GETMENUCHECKMARKDIMENSIONS16 UNALIGNED *PGETMENUCHECKMARKDIMENSIONS16;
#endif

typedef struct _GETMENUITEMCOUNT16 {        /* u263 */
    HMENU16 f1;
} GETMENUITEMCOUNT16;
typedef GETMENUITEMCOUNT16 UNALIGNED *PGETMENUITEMCOUNT16;

typedef struct _GETMENUITEMID16 {       /* u264 */
    SHORT   f2;
    HMENU16 f1;
} GETMENUITEMID16;
typedef GETMENUITEMID16 UNALIGNED *PGETMENUITEMID16;

typedef struct _GETMENUSTATE16 {        /* u250 */
    WORD    f3;
    WORD    f2;
    HMENU16 f1;
} GETMENUSTATE16;
typedef GETMENUSTATE16 UNALIGNED *PGETMENUSTATE16;

typedef struct _GETMENUSTRING16 {       /* u161 */
    WORD    f5;
    SHORT   f4;
    VPSTR   f3;
    WORD    f2;
    HMENU16 f1;
} GETMENUSTRING16;
typedef GETMENUSTRING16 UNALIGNED *PGETMENUSTRING16;

typedef struct _GETMESSAGE16 {          /* u108 */
    WORD    wMax;
    WORD    wMin;
    HWND16  hwnd;
    VPMSG16 vpMsg;
} GETMESSAGE16;
typedef GETMESSAGE16 UNALIGNED *PGETMESSAGE16;

typedef struct _GETMESSAGE216 {         /* u323 */
    BOOL16  f6;
    WORD    f5;
    WORD    f4;
    WORD    f3;
    HWND16  f2;
    VPMSG16 f1;
} GETMESSAGE216;
typedef GETMESSAGE216 UNALIGNED *PGETMESSAGE216;

#ifdef NULLSTRUCT
typedef struct _GETMESSAGEPOS16 {       /* u119 */
} GETMESSAGEPOS16;
typedef GETMESSAGEPOS16 UNALIGNED *PGETMESSAGEPOS16;
#endif

#ifdef NULLSTRUCT
typedef struct _GETMESSAGETIME16 {      /* u120 */
} GETMESSAGETIME16;
typedef GETMESSAGETIME16 UNALIGNED *PGETMESSAGETIME16;
#endif

typedef struct _GETNEXTDLGGROUPITEM16 {     /* u227 */
    BOOL16  f3;
    HWND16  f2;
    HWND16  f1;
} GETNEXTDLGGROUPITEM16;
typedef GETNEXTDLGGROUPITEM16 UNALIGNED *PGETNEXTDLGGROUPITEM16;

typedef struct _GETNEXTDLGTABITEM16 {       /* u228 */
    BOOL16  f3;
    HWND16  f2;
    HWND16  f1;
} GETNEXTDLGTABITEM16;
typedef GETNEXTDLGTABITEM16 UNALIGNED *PGETNEXTDLGTABITEM16;

typedef struct _GETNEXTQUEUEWINDOW16 {  /* u274 */
    BOOL16  f2;
    HWND16  f1;
} GETNEXTQUEUEWINDOW16;
typedef GETNEXTQUEUEWINDOW16 UNALIGNED *PGETNEXTQUEUEWINDOW16;

typedef struct _GETNEXTWINDOW16 {       /* u230 */
    WORD    f2;
    HWND16  f1;
} GETNEXTWINDOW16;
typedef GETNEXTWINDOW16 UNALIGNED *PGETNEXTWINDOW16;

typedef struct _GETPARENT16 {           /* u46 */
    HWND16  f1;
} GETPARENT16;
typedef GETPARENT16 UNALIGNED *PGETPARENT16;

typedef struct _GETPRIORITYCLIPBOARDFORMAT16 {  /* u402 */
    SHORT   f2;
    VPWORD  f1;
} GETPRIORITYCLIPBOARDFORMAT16;
typedef GETPRIORITYCLIPBOARDFORMAT16 UNALIGNED *PGETPRIORITYCLIPBOARDFORMAT16;

typedef struct _GETPROP16 {         /* u25 */
    VPSTR   f2;
    HWND16  f1;
} GETPROP16;
typedef GETPROP16 UNALIGNED *PGETPROP16;

typedef struct _GETSCROLLPOS16 {        /* u63 */
    SHORT   f2;
    HWND16  f1;
} GETSCROLLPOS16;
typedef GETSCROLLPOS16 UNALIGNED *PGETSCROLLPOS16;

typedef struct _GETSCROLLRANGE16 {      /* u65 */
    VPSHORT f4;
    VPSHORT f3;
    SHORT   f2;
    HWND16  f1;
} GETSCROLLRANGE16;
typedef GETSCROLLRANGE16 UNALIGNED *PGETSCROLLRANGE16;

typedef struct _GETSUBMENU16 {          /* u159 */
    SHORT   f2;
    HMENU16 f1;
} GETSUBMENU16;
typedef GETSUBMENU16 UNALIGNED *PGETSUBMENU16;

typedef struct _GETSYSCOLOR16 {         /* u180 */
    SHORT   f1;
} GETSYSCOLOR16;
typedef GETSYSCOLOR16 UNALIGNED *PGETSYSCOLOR16;

#ifdef NULLSTRUCT
typedef struct _GETSYSMODALWINDOW16 {       /* u189 */
} GETSYSMODALWINDOW16;
typedef GETSYSMODALWINDOW16 UNALIGNED *PGETSYSMODALWINDOW16;
#endif

typedef struct _GETSYSTEMMENU16 {       /* u156 */
    BOOL16  f2;
    HWND16  f1;
} GETSYSTEMMENU16;
typedef GETSYSTEMMENU16 UNALIGNED *PGETSYSTEMMENU16;

typedef struct _GETSYSTEMMETRICS16 {        /* u179 */
    SHORT   f1;
} GETSYSTEMMETRICS16;
typedef GETSYSTEMMETRICS16 UNALIGNED *PGETSYSTEMMETRICS16;

typedef struct _GETTABBEDTEXTEXTENT16 {     /* u197 */
    VPSHORT f5;
    SHORT   f4;
    SHORT   f3;
    VPSTR   f2;
    HDC16   f1;
} GETTABBEDTEXTEXTENT16;
typedef GETTABBEDTEXTEXTENT16 UNALIGNED *PGETTABBEDTEXTEXTENT16;

#ifdef NULLSTRUCT
typedef struct _GETTICKCOUNT16 {        /* u13 */
} GETTICKCOUNT16;
typedef GETTICKCOUNT16 UNALIGNED *PGETTICKCOUNT16;
#endif

#ifdef NULLSTRUCT
typedef struct _GETTIMERRESOLUTION16 {  /* u14 */
} GETTIMERRESOLUTION16;
typedef GETTIMERRESOLUTION16 UNALIGNED *PGETTIMERRESOLUTION16;
#endif

typedef struct _GETTOPWINDOW16 {        /* u229 */
    HWND16  f1;
} GETTOPWINDOW16;
typedef GETTOPWINDOW16 UNALIGNED *PGETTOPWINDOW16;

typedef struct _GETUPDATERECT16 {       /* u190 */
    BOOL16  f3;
    VPRECT16 f2;
    HWND16  f1;
} GETUPDATERECT16;
typedef GETUPDATERECT16 UNALIGNED *PGETUPDATERECT16;

typedef struct _GETUPDATERGN16 {        /* u237 */
    BOOL16  f3;
    HRGN16  f2;
    HWND16  f1;
} GETUPDATERGN16;
typedef GETUPDATERGN16 UNALIGNED *PGETUPDATERGN16;

typedef struct _GETUSERLOCALOBJTYPE16 { /* u480 */
    HAND16  f1;
} GETUSERLOCALOBJTYPE16;
typedef GETUSERLOCALOBJTYPE16 UNALIGNED *PGETUSERLOCALOBJTYPE16;

typedef struct _GETWC216 {              /* u318 */
    SHORT   f2;
    HWND16  f1;
} GETWC216;
typedef GETWC216 UNALIGNED *PGETWC216;

typedef struct _GETWINDOW16 {           /* u262 */
    WORD    f2;
    HWND16  f1;
} GETWINDOW16;
typedef GETWINDOW16 UNALIGNED *PGETWINDOW16;

typedef struct _GETWINDOWDC16 {         /* u67 */
    HWND16  f1;
} GETWINDOWDC16;
typedef GETWINDOWDC16 UNALIGNED *PGETWINDOWDC16;

typedef struct _GETWINDOWLONG16 {       /* u135 */
    SHORT   f2;
    HWND16  f1;
} GETWINDOWLONG16;
typedef GETWINDOWLONG16 UNALIGNED *PGETWINDOWLONG16;

typedef struct _GETWINDOWRECT16 {       /* u32 */
    VPRECT16 f2;
    HWND16  f1;
} GETWINDOWRECT16;
typedef GETWINDOWRECT16 UNALIGNED *PGETWINDOWRECT16;

typedef struct _GETWINDOWTASK16 {       /* u224 */
    HWND16  f1;
} GETWINDOWTASK16;
typedef GETWINDOWTASK16 UNALIGNED *PGETWINDOWTASK16;

typedef struct _GETWINDOWTEXT16 {       /* u36 */
    WORD    f3;
    VPSTR   f2;
    HWND16  f1;
} GETWINDOWTEXT16;
typedef GETWINDOWTEXT16 UNALIGNED *PGETWINDOWTEXT16;

typedef struct _GETWINDOWTEXTLENGTH16 {     /* u38 */
    HWND16  f1;
} GETWINDOWTEXTLENGTH16;
typedef GETWINDOWTEXTLENGTH16 UNALIGNED *PGETWINDOWTEXTLENGTH16;

typedef struct _GETWINDOWWORD16 {       /* u133 */
    SHORT   f2;
    HWND16  f1;
} GETWINDOWWORD16;
typedef GETWINDOWWORD16 UNALIGNED *PGETWINDOWWORD16;

typedef struct _GLOBALADDATOM16 {       /* u268 */
    VPSTR   f1;
} GLOBALADDATOM16;
typedef GLOBALADDATOM16 UNALIGNED *PGLOBALADDATOM16;

typedef struct _GLOBALDELETEATOM16 {        /* u269 */
    ATOM    f1;
} GLOBALDELETEATOM16;
typedef GLOBALDELETEATOM16 UNALIGNED *PGLOBALDELETEATOM16;

typedef struct _GLOBALFINDATOM16 {      /* u270 */
    VPSTR   f1;
} GLOBALFINDATOM16;
typedef GLOBALFINDATOM16 UNALIGNED *PGLOBALFINDATOM16;

typedef struct _GLOBALGETATOMNAME16 {       /* u271 */
    SHORT   f3;
    VPSTR   f2;
    ATOM    f1;
} GLOBALGETATOMNAME16;
typedef GLOBALGETATOMNAME16 UNALIGNED *PGLOBALGETATOMNAME16;

typedef struct _GRAYSTRING16 {          /* u185 */
    SHORT   f9;
    SHORT   f8;
    SHORT   f7;
    SHORT   f6;
    SHORT   f5;
    DWORD   f4;
    VPPROC f3;
    HBRSH16 f2;
    HDC16   f1;
} GRAYSTRING16;
typedef GRAYSTRING16 UNALIGNED *PGRAYSTRING16;

#ifdef NULLSTRUCT
typedef struct _HARDWARE_EVENT16 {      /* u481 */
} HARDWARE_EVENT16;
typedef HARDWARE_EVENT16 UNALIGNED *PHARDWARE_EVENT16;
#endif

typedef struct _HIDECARET16 {           /* u166 */
    HWND16 f1;
} HIDECARET16;
typedef HIDECARET16 UNALIGNED *PHIDECARET16;

typedef struct _HILITEMENUITEM16 {      /* u162 */
    WORD f4;
    WORD f3;
    HMENU16 f2;
    HWND16 f1;
} HILITEMENUITEM16;
typedef HILITEMENUITEM16 UNALIGNED *PHILITEMENUITEM16;

#ifdef NULLSTRUCT
typedef struct _ICONSIZE16 {            /* u86 */
} ICONSIZE16;
typedef ICONSIZE16 UNALIGNED *PICONSIZE16;
#endif

typedef struct _INFLATERECT16 {         /* u78 */
    SHORT f3;
    SHORT f2;
    VPRECT16 f1;
} INFLATERECT16;
typedef INFLATERECT16 UNALIGNED *PINFLATERECT16;

typedef struct _INITAPP16 {         /* u5 */
    HAND16  hInstance;
} INITAPP16;
typedef INITAPP16 UNALIGNED *PINITAPP16;

#ifdef NULLSTRUCT
typedef struct _INSENDMESSAGE16 {       /* u192 */
} INSENDMESSAGE16;
typedef INSENDMESSAGE16 UNALIGNED *PINSENDMESSAGE16;
#endif

typedef struct _INSERTMENU16 {          /* u410 */
    VPSTR f5;
    WORD f4;
    WORD f3;
    WORD f2;
    HMENU16 f1;
} INSERTMENU16;
typedef INSERTMENU16 UNALIGNED *PINSERTMENU16;

typedef struct _INTERSECTRECT16 {       /* u79 */
    VPRECT16 f3;
    VPRECT16 f2;
    VPRECT16 f1;
} INTERSECTRECT16;
typedef INTERSECTRECT16 UNALIGNED *PINTERSECTRECT16;

typedef struct _INVALIDATERECT16 {      /* u125 */
    BOOL16 f3;
    VPRECT16 f2;
    HWND16 f1;
} INVALIDATERECT16;
typedef INVALIDATERECT16 UNALIGNED *PINVALIDATERECT16;

typedef struct _INVALIDATERGN16 {       /* u126 */
    BOOL16 f3;
    HRGN16 f2;
    HWND16 f1;
} INVALIDATERGN16;
typedef INVALIDATERGN16 UNALIGNED *PINVALIDATERGN16;

typedef struct _INVERTRECT16 {          /* u82 */
    VPRECT16 f2;
    HDC16 f1;
} INVERTRECT16;
typedef INVERTRECT16 UNALIGNED *PINVERTRECT16;

typedef struct _ISCHARALPHA16 {         /* u433 */
    SHORT f1;
} ISCHARALPHA16;
typedef ISCHARALPHA16 UNALIGNED *PISCHARALPHA16;

typedef struct _ISCHARALPHANUMERIC16 {      /* u434 */
    SHORT f1;
} ISCHARALPHANUMERIC16;
typedef ISCHARALPHANUMERIC16 UNALIGNED *PISCHARALPHANUMERIC16;

typedef struct _ISCHARLOWER16 {         /* u436 */
    SHORT f1;
} ISCHARLOWER16;
typedef ISCHARLOWER16 UNALIGNED *PISCHARLOWER16;

typedef struct _ISCHARUPPER16 {         /* u435 */
    SHORT f1;
} ISCHARUPPER16;
typedef ISCHARUPPER16 UNALIGNED *PISCHARUPPER16;

typedef struct _ISCHILD16 {         /* u48 */
    HWND16 f2;
    HWND16 f1;
} ISCHILD16;
typedef ISCHILD16 UNALIGNED *PISCHILD16;

typedef struct _ISCLIPBOARDFORMATAVAILABLE16 {  /* u193 */
    WORD f1;
} ISCLIPBOARDFORMATAVAILABLE16;
typedef ISCLIPBOARDFORMATAVAILABLE16 UNALIGNED *PISCLIPBOARDFORMATAVAILABLE16;

typedef struct _ISDIALOGMESSAGE16 {     /* u90 */
    VPMSG16 f2;
    HWND16 f1;
} ISDIALOGMESSAGE16;
typedef ISDIALOGMESSAGE16 UNALIGNED *PISDIALOGMESSAGE16;

typedef struct _ISDLGBUTTONCHECKED16 {      /* u98 */
    SHORT f2;
    HWND16 f1;
} ISDLGBUTTONCHECKED16;
typedef ISDLGBUTTONCHECKED16 UNALIGNED *PISDLGBUTTONCHECKED16;

typedef struct _ISICONIC16 {            /* u31 */
    HWND16 f1;
} ISICONIC16;
typedef ISICONIC16 UNALIGNED *PISICONIC16;

typedef struct _ISRECTEMPTY16 {         /* u75 */
    VPRECT16 f1;
} ISRECTEMPTY16;
typedef ISRECTEMPTY16 UNALIGNED *PISRECTEMPTY16;

typedef struct _ISTWOBYTECHARPREFIX16 {     /* u51 */
    SHORT f1;
} ISTWOBYTECHARPREFIX16;
typedef ISTWOBYTECHARPREFIX16 UNALIGNED *PISTWOBYTECHARPREFIX16;

#ifdef NULLSTRUCT
typedef struct _ISUSERIDLE16 {          /* u59 */
} ISUSERIDLE16;
typedef ISUSERIDLE16 UNALIGNED *PISUSERIDLE16;
#endif

typedef struct _ISWINDOW16 {            /* u47 */
    HWND16 f1;
} ISWINDOW16;
typedef ISWINDOW16 UNALIGNED *PISWINDOW16;

typedef struct _ISWINDOWENABLED16 {     /* u35 */
    HWND16 f1;
} ISWINDOWENABLED16;
typedef ISWINDOWENABLED16 UNALIGNED *PISWINDOWENABLED16;

typedef struct _ISWINDOWVISIBLE16 {     /* u49 */
    HWND16 f1;
} ISWINDOWVISIBLE16;
typedef ISWINDOWVISIBLE16 UNALIGNED *PISWINDOWVISIBLE16;

typedef struct _ISZOOMED16 {            /* u272 */
    HWND16 f1;
} ISZOOMED16;
typedef ISZOOMED16 UNALIGNED *PISZOOMED16;

#ifdef NULLSTRUCT
typedef struct _KEYBD_EVENT16 {         /* u289 */
} KEYBD_EVENT16;
typedef KEYBD_EVENT16 UNALIGNED *PKEYBD_EVENT16;
#endif

typedef struct _KEYBDEVENT16 {          /* u539 */
    DWORD dwExtraInfo;
    WORD bScanCode;
    WORD bVirtualKey;
} KEYBDEVENT16;
typedef KEYBDEVENT16 UNALIGNED *PKEYBDEVENT16;

typedef struct _KILLSYSTEMTIMER16 {     /* u182 */
    SHORT  f2;
    HWND16 f1;
} KILLSYSTEMTIMER16;
typedef KILLSYSTEMTIMER16 UNALIGNED *PKILLSYSTEMTIMER16;

typedef struct _KILLTIMER16 {           /* u12 */
    SHORT f2;
    HWND16 f1;
} KILLTIMER16;
typedef KILLTIMER16 UNALIGNED *PKILLTIMER16;

typedef struct _KILLTIMER216 {          /* u327 */
    SHORT  f2;
    HWND16 f1;
} KILLTIMER216;
typedef KILLTIMER216 UNALIGNED *PKILLTIMER216;

typedef struct _LBOXCARETBLINKER16 {    /* u453 */
    DWORD   f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} LBOXCARETBLINKER16;
typedef LBOXCARETBLINKER16 UNALIGNED *PLBOXCARETBLINKER16;

typedef struct _LOADACCELERATORS16 {        /* u177 */
    VPSTR f2;
    HAND16 f1;
} LOADACCELERATORS16;
typedef LOADACCELERATORS16 UNALIGNED *PLOADACCELERATORS16;

typedef struct _LOADBITMAP16 {          /* u175 */
    DWORD  f4;
    DWORD  f3;
    VPSTR  f2;
    HAND16 f1;
} LOADBITMAP16;
typedef LOADBITMAP16 UNALIGNED *PLOADBITMAP16;

typedef struct _LOADCURSOR16 {		/* u173 */
    WORD   f7;
    WORD   f6;
    WORD   f5;
    DWORD  f4;
    DWORD  f3;
    VPSTR  f2;
    HAND16 f1;
} LOADCURSOR16;
typedef LOADCURSOR16 UNALIGNED *PLOADCURSOR16;

typedef struct _LOADCURSORICONHANDLER16 { /* u336 */
    HAND16  f3;
    HAND16  f2;
    HAND16  f1;
} LOADCURSORICONHANDLER16;
typedef LOADCURSORICONHANDLER16 UNALIGNED *PLOADCURSORICONHANDLER16;

typedef struct _LOADDIBCURSORHANDLER16 {  /* u356 */
    HAND16  f3;
    HAND16  f2;
    HAND16  f1;
} LOADDIBCURSORHANDLER16;
typedef LOADDIBCURSORHANDLER16 UNALIGNED *PLOADDIBCURSORHANDLER16;

typedef struct _LOADDIBICONHANDLER16 {    /* u357 */
    HAND16  f3;
    HAND16  f2;
    HAND16  f1;
} LOADDIBICONHANDLER16;
typedef LOADDIBICONHANDLER16 UNALIGNED *PLOADDIBICONHANDLER16;

typedef struct _LOADICON16 {		/* u174 */
    WORD   f6;
    WORD   f5;
    DWORD  f4;
    DWORD  f3;
    VPSTR  f2;
    HAND16 f1;
} LOADICON16;
typedef LOADICON16 UNALIGNED *PLOADICON16;

typedef struct _LOADICONHANDLER16 {     /* u456 */
    BOOL16  f2;
    HICON16 f1;
} LOADICONHANDLER16;
typedef LOADICONHANDLER16 UNALIGNED *PLOADICONHANDLER16;

typedef struct _LOADMENU16 {            /* u150 */
    WORD   f5;
    DWORD  f4;
    DWORD  f3;
    VPSTR  f2;
    HAND16 f1;
} LOADMENU16;
typedef LOADMENU16 UNALIGNED *PLOADMENU16;

typedef struct _LOADMENUINDIRECT16 {        /* u220 */
    VPSTR f1;
} LOADMENUINDIRECT16;
typedef LOADMENUINDIRECT16 UNALIGNED *PLOADMENUINDIRECT16;

typedef struct _LOADSTRING16 {          /* u176 */
    SHORT f4;
    VPSTR f3;
    WORD f2;
    HAND16 f1;
} LOADSTRING16;
typedef LOADSTRING16 UNALIGNED *PLOADSTRING16;

typedef struct _LOCKMYTASK16 {          /* u276 */
    BOOL16  f1;
} LOCKMYTASK16;
typedef LOCKMYTASK16 UNALIGNED *PLOCKMYTASK16;

typedef struct _LOOKUPMENUHANDLE16 {    /* u217 */
    WORD    f2;
    HMENU16 f1;
} LOOKUPMENUHANDLE16;
typedef LOOKUPMENUHANDLE16 UNALIGNED *PLOOKUPMENUHANDLE16;

typedef struct _LSTRCMP16 {         /* u430 */
    VPSTR  f2;
    VPSTR f1;
} LSTRCMP16;
typedef LSTRCMP16 UNALIGNED *PLSTRCMP16;

typedef struct _LSTRCMPI16 {            /* u471 */
    VPSTR  f2;
    VPSTR f1;
} LSTRCMPI16;
typedef LSTRCMPI16 UNALIGNED *PLSTRCMPI16;

typedef struct _MAPDIALOGRECT16 {       /* u103 */
    VPRECT16 f2;
    HWND16 f1;
} MAPDIALOGRECT16;
typedef MAPDIALOGRECT16 UNALIGNED *PMAPDIALOGRECT16;

typedef struct _MB_DLGPROC16 {          /* u409 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} MB_DLGPROC16;
typedef MB_DLGPROC16 UNALIGNED *PMB_DLGPROC16;

typedef struct _MENUITEMSTATE16 {       /* u329 */
    WORD    f3;
    WORD    f2;
    HMENU16 f1;
} MENUITEMSTATE16;
typedef MENUITEMSTATE16 UNALIGNED *PMENUITEMSTATE16;

typedef struct _MESSAGEBEEP16 {         /* u104 */
    WORD f1;
} MESSAGEBEEP16;
typedef MESSAGEBEEP16 UNALIGNED *PMESSAGEBEEP16;

typedef struct _MESSAGEBOX16 {          /* u1 */
    WORD f4;
    VPSTR f3;
    VPSTR f2;
    HWND16 f1;
} MESSAGEBOX16;
typedef MESSAGEBOX16 UNALIGNED *PMESSAGEBOX16;

typedef struct _MODIFYMENU16 {          /* u414 */
    VPSTR f5;
    WORD f4;
    WORD f3;
    WORD f2;
    HMENU16 f1;
} MODIFYMENU16;
typedef MODIFYMENU16 UNALIGNED *PMODIFYMENU16;

#ifdef NULLSTRUCT
typedef struct _MOUSE_EVENT16 {         /* u299 */
} MOUSE_EVENT16;
typedef MOUSE_EVENT16 UNALIGNED *PMOUSE_EVENT16;
#endif

typedef struct _MOUSEEVENT16 {          /* u538 */
    DWORD dwExtraInfo;
    WORD cButtons;
    WORD dy;
    WORD dx;
    WORD wFlags;
} MOUSEEVENT16;
typedef MOUSEEVENT16 UNALIGNED *PMOUSEEVENT16;


typedef struct _MOVEWINDOW16 {          /* u56 */
    BOOL16 f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HWND16 f1;
} MOVEWINDOW16;
typedef MOVEWINDOW16 UNALIGNED *PMOVEWINDOW16;

typedef struct _OFFSETRECT16 {          /* u77 */
    SHORT f3;
    SHORT f2;
    VPRECT16 f1;
} OFFSETRECT16;
typedef OFFSETRECT16 UNALIGNED *POFFSETRECT16;

typedef struct _OPENCLIPBOARD16 {       /* u137 */
    HWND16 f1;
} OPENCLIPBOARD16;
typedef OPENCLIPBOARD16 UNALIGNED *POPENCLIPBOARD16;

typedef struct _OPENCOMM16 {            /* u200 */
    DWORD f4;  /* added for SetCommEventMask() support */
    WORD  f3;
    WORD  f2;
    VPSTR f1;
} OPENCOMM16;
typedef OPENCOMM16 UNALIGNED *POPENCOMM16;

typedef struct _OPENICON16 {            /* u44 */
    HWND16 f1;
} OPENICON16;
typedef OPENICON16 UNALIGNED *POPENICON16;

typedef struct _PAINTRECT16 {           /* u325 */
    VPRECT16 f5;
    HBRSH16  f4;
    HDC16    f3;
    HWND16   f2;
    HWND16   f1;
} PAINTRECT16;
typedef PAINTRECT16 UNALIGNED *PPAINTRECT16;

typedef struct _PEEKMESSAGE16 {         /* u109 */
    WORD f5;
    WORD f4;
    WORD f3;
    HWND16 f2;
    VPMSG16 f1;
} PEEKMESSAGE16;
typedef PEEKMESSAGE16 UNALIGNED *PPEEKMESSAGE16;

typedef struct _POSTAPPMESSAGE16 {      /* u116 */
    LONG f4;
    WORD f3;
    WORD f2;
    HAND16 f1;
} POSTAPPMESSAGE16;
typedef POSTAPPMESSAGE16 UNALIGNED *PPOSTAPPMESSAGE16;

typedef struct _POSTMESSAGE16 {         /* u110 */
    LONG f4;
    WORD f3;
    WORD f2;
    HWND16 f1;
} POSTMESSAGE16;
typedef POSTMESSAGE16 UNALIGNED *PPOSTMESSAGE16;

typedef struct _POSTMESSAGE216 {        /* u313 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} POSTMESSAGE216;
typedef POSTMESSAGE216 UNALIGNED *PPOSTMESSAGE216;

typedef struct _POSTQUITMESSAGE16 {     /* u6 */
    SHORT   wExitCode;
} POSTQUITMESSAGE16;
typedef POSTQUITMESSAGE16 UNALIGNED *PPOSTQUITMESSAGE16;

typedef struct _PTINRECT16 {            /* u76 */
    POINT16 f2;
    VPRECT16 f1;
} PTINRECT16;
typedef PTINRECT16 UNALIGNED *PPTINRECT16;

typedef struct _READCOMM16 {            /* u204 */
    SHORT f3;
    VPSTR f2;
    SHORT f1;
} READCOMM16;
typedef READCOMM16 UNALIGNED *PREADCOMM16;

typedef struct _REALIZEPALETTE16 {      /* u283 */
    HDC16 f1;
} REALIZEPALETTE16;
typedef REALIZEPALETTE16 UNALIGNED *PREALIZEPALETTE16;

typedef struct _REGISTERCLASS16 {       /* u57 */
    VPWNDCLASS16 vpWndClass;
} REGISTERCLASS16;
typedef REGISTERCLASS16 UNALIGNED *PREGISTERCLASS16;

typedef struct _REGISTERCLIPBOARDFORMAT16 { /* u145 */
    VPSTR f1;
} REGISTERCLIPBOARDFORMAT16;
typedef REGISTERCLIPBOARDFORMAT16 UNALIGNED *PREGISTERCLIPBOARDFORMAT16;

typedef struct _REGISTERWINDOWMESSAGE16 {   /* u118 */
    VPSTR f1;
} REGISTERWINDOWMESSAGE16;
typedef REGISTERWINDOWMESSAGE16 UNALIGNED *PREGISTERWINDOWMESSAGE16;

#ifdef NULLSTRUCT
typedef struct _RELEASECAPTURE16 {      /* u19 */
} RELEASECAPTURE16;
typedef RELEASECAPTURE16 UNALIGNED *PRELEASECAPTURE16;
#endif

typedef struct _RELEASEDC16 {           /* u68 */
    HDC16 f2;
    HWND16 f1;
} RELEASEDC16;
typedef RELEASEDC16 UNALIGNED *PRELEASEDC16;

typedef struct _REMOVEMENU16 {          /* u412 */
    WORD f3;
    WORD f2;
    HMENU16 f1;
} REMOVEMENU16;
typedef REMOVEMENU16 UNALIGNED *PREMOVEMENU16;

typedef struct _REMOVEPROP16 {          /* u24 */
    VPSTR f2;
    HWND16 f1;
} REMOVEPROP16;
typedef REMOVEPROP16 UNALIGNED *PREMOVEPROP16;

#ifdef NULLSTRUCT
typedef struct _REPAINTSCREEN16 {       /* u275 */
} REPAINTSCREEN16;
typedef REPAINTSCREEN16 UNALIGNED *PREPAINTSCREEN16;
#endif

typedef struct _REPLYMESSAGE16 {        /* u115 */
    LONG f1;
} REPLYMESSAGE16;
typedef REPLYMESSAGE16 UNALIGNED *PREPLYMESSAGE16;

typedef struct _SCREENTOCLIENT16 {      /* u29 */
    VPPOINT16 f2;
    HWND16 f1;
} SCREENTOCLIENT16;
typedef SCREENTOCLIENT16 UNALIGNED *PSCREENTOCLIENT16;

typedef struct _SCROLLCHILDREN16 {      /* u463 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} SCROLLCHILDREN16;
typedef SCROLLCHILDREN16 UNALIGNED *PSCROLLCHILDREN16;

typedef struct _SCROLLDC16 {            /* u221 */
    VPRECT16 f7;
    HRGN16 f6;
    VPRECT16 f5;
    VPRECT16 f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} SCROLLDC16;
typedef SCROLLDC16 UNALIGNED *PSCROLLDC16;

typedef struct _SCROLLWINDOW16 {        /* u61 */
    VPRECT16 f5;
    VPRECT16 f4;
    SHORT f3;
    SHORT f2;
    HWND16 f1;
} SCROLLWINDOW16;
typedef SCROLLWINDOW16 UNALIGNED *PSCROLLWINDOW16;

typedef struct _SELECTPALETTE16 {       /* u282 */
    BOOL16 f3;
    HPAL16 f2;
    HDC16 f1;
} SELECTPALETTE16;
typedef SELECTPALETTE16 UNALIGNED *PSELECTPALETTE16;

typedef struct _SENDDLGITEMMESSAGE16 {      /* u101 */
    LONG f5;
    WORD f4;
    WORD f3;
    SHORT f2;
    HWND16 f1;
} SENDDLGITEMMESSAGE16;
typedef SENDDLGITEMMESSAGE16 UNALIGNED *PSENDDLGITEMMESSAGE16;

typedef struct _SENDMESSAGE16 {         /* u111 */
    LONG f4;
    WORD f3;
    WORD f2;
    HWND16 f1;
} SENDMESSAGE16;
typedef SENDMESSAGE16 UNALIGNED *PSENDMESSAGE16;

typedef struct _SENDMESSAGE216 {        /* u312 */
    LONG   f4;
    WORD   f3;
    WORD   f2;
    HWND16 f1;
} SENDMESSAGE216;
typedef SENDMESSAGE216 UNALIGNED *PSENDMESSAGE216;

typedef struct _SETACTIVEWINDOW16 {     /* u59 */
    HWND16 f1;
} SETACTIVEWINDOW16;
typedef SETACTIVEWINDOW16 UNALIGNED *PSETACTIVEWINDOW16;

typedef struct _SETCAPTURE16 {          /* u18 */
    HWND16 f1;
} SETCAPTURE16;
typedef SETCAPTURE16 UNALIGNED *PSETCAPTURE16;

typedef struct _SETCARETBLINKTIME16 {       /* u168 */
    WORD f1;
} SETCARETBLINKTIME16;
typedef SETCARETBLINKTIME16 UNALIGNED *PSETCARETBLINKTIME16;

typedef struct _SETCARETPOS16 {         /* u165 */
    SHORT f2;
    SHORT f1;
} SETCARETPOS16;
typedef SETCARETPOS16 UNALIGNED *PSETCARETPOS16;

typedef struct _SETCLASSLONG16 {        /* u132 */
    LONG f3;
    SHORT f2;
    HWND16 f1;
} SETCLASSLONG16;
typedef SETCLASSLONG16 UNALIGNED *PSETCLASSLONG16;

typedef struct _SETCLASSWORD16 {        /* u130 */
    WORD f3;
    SHORT f2;
    HWND16 f1;
} SETCLASSWORD16;
typedef SETCLASSWORD16 UNALIGNED *PSETCLASSWORD16;

typedef struct _SETCLIPBOARDDATA16 {        /* u141 */
    HAND16 f2;
    WORD f1;
} SETCLIPBOARDDATA16;
typedef SETCLIPBOARDDATA16 UNALIGNED *PSETCLIPBOARDDATA16;

typedef struct _SETCLIPBOARDVIEWER16 {      /* u147 */
    HWND16 f1;
} SETCLIPBOARDVIEWER16;
typedef SETCLIPBOARDVIEWER16 UNALIGNED *PSETCLIPBOARDVIEWER16;

typedef struct _SETCOMMBREAK16 {        /* u210 */
    SHORT f1;
} SETCOMMBREAK16;
typedef SETCOMMBREAK16 UNALIGNED *PSETCOMMBREAK16;

typedef struct _SETCOMMEVENTMASK16 {        /* u208 */
    WORD  f2;
    SHORT f1;
} SETCOMMEVENTMASK16;
typedef SETCOMMEVENTMASK16 UNALIGNED *PSETCOMMEVENTMASK16;

typedef struct _SETCOMMSTATE16 {        /* u201 */
    VPDCB16 f1;
} SETCOMMSTATE16;
typedef SETCOMMSTATE16 UNALIGNED *PSETCOMMSTATE16;

typedef struct _SETCURSOR16 {           /* u69 */
    HCUR16 f1;
} SETCURSOR16;
typedef SETCURSOR16 UNALIGNED *PSETCURSOR16;

typedef struct _SETCURSORPOS16 {        /* u70 */
    SHORT f2;
    SHORT f1;
} SETCURSORPOS16;
typedef SETCURSORPOS16 UNALIGNED *PSETCURSORPOS16;

typedef struct _SETDESKPATTERN16 {      /* u279 */
    VPSTR   f1;
} SETDESKPATTERN16;
typedef SETDESKPATTERN16 UNALIGNED *PSETDESKPATTERN16;

typedef struct _SETDESKWALLPAPER16 {    /* u285 */
    VPSTR   f1;
} SETDESKWALLPAPER16;
typedef SETDESKWALLPAPER16 UNALIGNED *PSETDESKWALLPAPER16;

typedef struct _SETDLGITEMINT16 {       /* u94 */
    BOOL16 f4;
    WORD f3;
    SHORT f2;
    HWND16 f1;
} SETDLGITEMINT16;
typedef SETDLGITEMINT16 UNALIGNED *PSETDLGITEMINT16;

typedef struct _SETDLGITEMTEXT16 {      /* u92 */
    VPSTR f3;
    SHORT f2;
    HWND16 f1;
} SETDLGITEMTEXT16;
typedef SETDLGITEMTEXT16 UNALIGNED *PSETDLGITEMTEXT16;

typedef struct _SETDOUBLECLICKTIME16 {      /* u20 */
    WORD f1;
} SETDOUBLECLICKTIME16;
typedef SETDOUBLECLICKTIME16 UNALIGNED *PSETDOUBLECLICKTIME16;

typedef struct _SETFOCUS16 {            /* u22 */
    HWND16 f1;
} SETFOCUS16;
typedef SETFOCUS16 UNALIGNED *PSETFOCUS16;

typedef struct _SETGETKBDSTATE16 {      /* u330 */
    VPBYTE  f1;
} SETGETKBDSTATE16;
typedef SETGETKBDSTATE16 UNALIGNED *PSETGETKBDSTATE16;

typedef struct _SETINTERNALWINDOWPOS16 {    /* u461 */
    VPPOINT16 f4;
    VPRECT16  f3;
    WORD      f2;
    HWND16    f1;
} SETINTERNALWINDOWPOS16;
typedef SETINTERNALWINDOWPOS16 UNALIGNED *PSETINTERNALWINDOWPOS16;

typedef struct _SETKEYBOARDSTATE16 {        /* u223 */
    VPBYTE f1;
} SETKEYBOARDSTATE16;
typedef SETKEYBOARDSTATE16 UNALIGNED *PSETKEYBOARDSTATE16;

typedef struct _SETMENU16 {         /* u158 */
    HMENU16 f2;
    HWND16 f1;
} SETMENU16;
typedef SETMENU16 UNALIGNED *PSETMENU16;

typedef struct _SETMENUITEMBITMAPS16 {      /* u418 */
    HBM16 f5;
    HBM16 f4;
    WORD f3;
    WORD f2;
    HMENU16 f1;
} SETMENUITEMBITMAPS16;
typedef SETMENUITEMBITMAPS16 UNALIGNED *PSETMENUITEMBITMAPS16;

typedef struct _SETMESSAGEQUEUE16 {     /* u266 */
    SHORT f1;
} SETMESSAGEQUEUE16;
typedef SETMESSAGEQUEUE16 UNALIGNED *PSETMESSAGEQUEUE16;

typedef struct _SETPARENT16 {           /* u233 */
    HWND16 f2;
    HWND16 f1;
} SETPARENT16;
typedef SETPARENT16 UNALIGNED *PSETPARENT16;

typedef struct _SETPROP16 {         /* u26 */
    HAND16 f3;
    VPSTR f2;
    HWND16 f1;
} SETPROP16;
typedef SETPROP16 UNALIGNED *PSETPROP16;

typedef struct _SETRECT16 {         /* u72 */
    SHORT f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    VPRECT16 f1;
} SETRECT16;
typedef SETRECT16 UNALIGNED *PSETRECT16;

typedef struct _SETRECTEMPTY16 {        /* u73 */
    VPRECT16 f1;
} SETRECTEMPTY16;
typedef SETRECTEMPTY16 UNALIGNED *PSETRECTEMPTY16;

typedef struct _SETSCROLLPOS16 {        /* u62 */
    BOOL16 f4;
    SHORT f3;
    SHORT f2;
    HWND16 f1;
} SETSCROLLPOS16;
typedef SETSCROLLPOS16 UNALIGNED *PSETSCROLLPOS16;

typedef struct _SETSCROLLRANGE16 {      /* u64 */
    BOOL16 f5;
    SHORT f4;
    SHORT f3;
    SHORT f2;
    HWND16 f1;
} SETSCROLLRANGE16;
typedef SETSCROLLRANGE16 UNALIGNED *PSETSCROLLRANGE16;

typedef struct _SETSYSCOLORS16 {        /* u181 */
    VPLONG f3;
    VPSHORT f2;
    SHORT f1;
} SETSYSCOLORS16;
typedef SETSYSCOLORS16 UNALIGNED *PSETSYSCOLORS16;

typedef struct _SETSYSMODALWINDOW16 {       /* u188 */
    HWND16 f1;
} SETSYSMODALWINDOW16;
typedef SETSYSMODALWINDOW16 UNALIGNED *PSETSYSMODALWINDOW16;

typedef struct _SETSYSTEMMENU16 {       /* u280 */
    HMENU16 f2;
    HWND16  f1;
} SETSYSTEMMENU16;
typedef SETSYSTEMMENU16 UNALIGNED *PSETSYSTEMMENU16;

typedef struct _SETSYSTEMTIMER16 {      /* u11 */
    VPPROC  f4;
    WORD    f3;
    SHORT   f2;
    HWND16  f1;
} SETSYSTEMTIMER16;
typedef SETSYSTEMTIMER16 UNALIGNED *PSETSYSTEMTIMER16;

typedef struct _SETTIMER16 {            /* u10 */
    VPPROC f4;
    WORD f3;
    SHORT f2;
    HWND16 f1;
} SETTIMER16;
typedef SETTIMER16 UNALIGNED *PSETTIMER16;

typedef struct _SETTIMER216 {           /* u328 */
    VPPROC  f4;
    WORD    f3;
    SHORT   f2;
    HWND16  f1;
} SETTIMER216;
typedef SETTIMER216 UNALIGNED *PSETTIMER216;

typedef struct _SETWINDOWLONG16 {       /* u136 */
    LONG f3;
    SHORT f2;
    HWND16 f1;
} SETWINDOWLONG16;
typedef SETWINDOWLONG16 UNALIGNED *PSETWINDOWLONG16;

typedef struct _SETWINDOWPOS16 {        /* u232 */
    WORD f7;
    SHORT f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    HWND16 f2;
    HWND16 f1;
} SETWINDOWPOS16;
typedef SETWINDOWPOS16 UNALIGNED *PSETWINDOWPOS16;

typedef struct _SETWINDOWSHOOKINTERNAL16 {      /* u121 */
    VPPROC f3;
    SHORT f2;
    SHORT f1;
} SETWINDOWSHOOKINTERNAL16;
typedef SETWINDOWSHOOKINTERNAL16 UNALIGNED *PSETWINDOWSHOOKINTERNAL16;

typedef struct _SETWINDOWTEXT16 {       /* u37 */
    VPSTR f2;
    HWND16 f1;
} SETWINDOWTEXT16;
typedef SETWINDOWTEXT16 UNALIGNED *PSETWINDOWTEXT16;

typedef struct _SETWINDOWWORD16 {       /* u134 */
    WORD f3;
    SHORT f2;
    HWND16 f1;
} SETWINDOWWORD16;
typedef SETWINDOWWORD16 UNALIGNED *PSETWINDOWWORD16;

typedef struct _SHOWCARET16 {           /* u167 */
    HWND16 f1;
} SHOWCARET16;
typedef SHOWCARET16 UNALIGNED *PSHOWCARET16;

typedef struct _SHOWCURSOR16 {          /* u71 */
    BOOL16 f1;
} SHOWCURSOR16;
typedef SHOWCURSOR16 UNALIGNED *PSHOWCURSOR16;

typedef struct _SHOWOWNEDPOPUPS16 {     /* u265 */
    BOOL16 f2;
    HWND16 f1;
} SHOWOWNEDPOPUPS16;
typedef SHOWOWNEDPOPUPS16 UNALIGNED *PSHOWOWNEDPOPUPS16;

typedef struct _SHOWSCROLLBAR16 {       /* u267 */
    BOOL16 f3;
    WORD f2;
    HWND16 f1;
} SHOWSCROLLBAR16;
typedef SHOWSCROLLBAR16 UNALIGNED *PSHOWSCROLLBAR16;

typedef struct _SHOWWINDOW16 {          /* u42 */
    SHORT f2;
    HWND16 f1;
} SHOWWINDOW16;
typedef SHOWWINDOW16 UNALIGNED *PSHOWWINDOW16;

typedef struct _SIGNALPROC16 {          /* u314 */
    LONG f4;
    WORD f3;
    WORD f2;
    HTASK16 f1;
} SIGNALPROC16;
typedef SIGNALPROC16 UNALIGNED *PSIGNALPROC16;

typedef struct _SNAPWINDOW16 {          /* u281 */
    HWND16  f1;
} SNAPWINDOW16;
typedef SNAPWINDOW16 UNALIGNED *PSNAPWINDOW16;

typedef struct _SWAPMOUSEBUTTON16 {     /* u186 */
    BOOL16 f1;
} SWAPMOUSEBUTTON16;
typedef SWAPMOUSEBUTTON16 UNALIGNED *PSWAPMOUSEBUTTON16;

typedef struct _SWITCHTOTHISWINDOW16 {  /* u172 */
    BOOL16  f2;
    HWND16  f1;
} SWITCHTOTHISWINDOW16;
typedef SWITCHTOTHISWINDOW16 UNALIGNED *PSWITCHTOTHISWINDOW16;

typedef struct _SWITCHWNDPROC16 {       /* u347 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} SWITCHWNDPROC16;
typedef SWITCHWNDPROC16 UNALIGNED *PSWITCHWNDPROC16;

typedef struct _SYSERRORBOX16 {         /* u320 */
    SHORT sBtn3;
    SHORT sBtn2;
    SHORT sBtn1;
    VPSZ  vpszCaption;
    VPSZ  vpszText;
} SYSERRORBOX16;
typedef SYSERRORBOX16 UNALIGNED *PSYSERRORBOX16;

typedef struct _TABBEDTEXTOUT16 {       /* u196 */
    SHORT f8;
    VPSHORT f7;
    SHORT f6;
    SHORT f5;
    VPSTR f4;
    SHORT f3;
    SHORT f2;
    HDC16 f1;
} TABBEDTEXTOUT16;
typedef TABBEDTEXTOUT16 UNALIGNED *PTABBEDTEXTOUT16;

typedef struct _TABTHETEXTOUTFORWIMPS16 { /* u354 */
    BOOL16   f9;
    SHORT    f8;
    VPSHORT  f7;
    SHORT    f6;
    SHORT    f5;
    VPSTR    f4;
    SHORT    f3;
    SHORT    f2;
    HDC16    f1;
} TABTHETEXTOUTFORWIMPS16;
typedef TABTHETEXTOUTFORWIMPS16 UNALIGNED *PTABTHETEXTOUTFORWIMPS16;

typedef struct _TILECHILDWINDOWS16 {    /* u199 */
    WORD    f2;
    HWND16  f1;
} TILECHILDWINDOWS16;
typedef TILECHILDWINDOWS16 UNALIGNED *PTILECHILDWINDOWS16;

typedef struct _TITLEWNDPROC16 {        /* u345 */
    LONG    f4;
    WORD    f3;
    WORD    f2;
    HWND16  f1;
} TITLEWNDPROC16;
typedef TITLEWNDPROC16 UNALIGNED *PTITLEWNDPROC16;

typedef struct _TRACKPOPUPMENU16 {      /* u416 */
    VPRECT16 f7;
    HWND16 f6;
    SHORT f5;
    SHORT f4;
    SHORT f3;
    WORD f2;
    HMENU16 f1;
} TRACKPOPUPMENU16;
typedef TRACKPOPUPMENU16 UNALIGNED *PTRACKPOPUPMENU16;

typedef struct _TRANSLATEACCELERATOR16 {    /* u178 */
    VPMSG16 f3;
    HAND16 f2;
    HWND16 f1;
} TRANSLATEACCELERATOR16;
typedef TRANSLATEACCELERATOR16 UNALIGNED *PTRANSLATEACCELERATOR16;

typedef struct _TRANSLATEMDISYSACCEL16 {    /* u451 */
    VPMSG16 f2;
    HWND16 f1;
} TRANSLATEMDISYSACCEL16;
typedef TRANSLATEMDISYSACCEL16 UNALIGNED *PTRANSLATEMDISYSACCEL16;

typedef struct _TRANSLATEMESSAGE16 {        /* u113 */
    VPMSG16 f1;
} TRANSLATEMESSAGE16;
typedef TRANSLATEMESSAGE16 UNALIGNED *PTRANSLATEMESSAGE16;

typedef struct _TRANSMITCOMMCHAR16 {        /* u206 */
    SHORT f2;
    SHORT f1;
} TRANSMITCOMMCHAR16;
typedef TRANSMITCOMMCHAR16 UNALIGNED *PTRANSMITCOMMCHAR16;

typedef struct _UNGETCOMMCHAR16 {       /* u212 */
    SHORT f2;
    SHORT f1;
} UNGETCOMMCHAR16;
typedef UNGETCOMMCHAR16 UNALIGNED *PUNGETCOMMCHAR16;

typedef struct _UNHOOKWINDOWSHOOK16 {       /* u234 */
    VPPROC f2;
    SHORT f1;
} UNHOOKWINDOWSHOOK16;
typedef UNHOOKWINDOWSHOOK16 UNALIGNED *PUNHOOKWINDOWSHOOK16;

typedef struct _UNIONRECT16 {           /* u80 */
    VPRECT16 f3;
    VPRECT16 f2;
    VPRECT16 f1;
} UNIONRECT16;
typedef UNIONRECT16 UNALIGNED *PUNIONRECT16;

typedef struct _UNREGISTERCLASS16 {     /* u403 */
    HAND16  hInstance;
    VPSTR   vpszClass;
} UNREGISTERCLASS16;
typedef UNREGISTERCLASS16 UNALIGNED *PUNREGISTERCLASS16;

typedef struct _UPDATEWINDOW16 {        /* u124 */
    HWND16 f1;
} UPDATEWINDOW16;
typedef UPDATEWINDOW16 UNALIGNED *PUPDATEWINDOW16;

typedef struct _USERSEEUSERDO16 {       /* u216 */
    LONG    f3;
    WORD    f2;
    WORD    f1;
} USERSEEUSERDO16;
typedef USERSEEUSERDO16 UNALIGNED *PUSERSEEUSERDO16;

#ifdef NULLSTRUCT
typedef struct _USERYIELD16 {           /* u332 */
} USERYIELD16;
typedef USERYIELD16 UNALIGNED *PUSERYIELD16;
#endif

typedef struct _VALIDATERECT16 {        /* u127 */
    VPRECT16 f2;
    HWND16 f1;
} VALIDATERECT16;
typedef VALIDATERECT16 UNALIGNED *PVALIDATERECT16;

typedef struct _VALIDATERGN16 {         /* u128 */
    HRGN16 f2;
    HWND16 f1;
} VALIDATERGN16;
typedef VALIDATERGN16 UNALIGNED *PVALIDATERGN16;

#ifdef NULLSTRUCT
typedef struct _WAITMESSAGE16 {         /* u112 */
} WAITMESSAGE16;
typedef WAITMESSAGE16 UNALIGNED *PWAITMESSAGE16;
#endif

typedef struct _WINDOWFROMPOINT16 {     /* u30 */
    POINT16 f1;
} WINDOWFROMPOINT16;
typedef WINDOWFROMPOINT16 UNALIGNED *PWINDOWFROMPOINT16;

typedef struct _WINHELP16 {         /* u171 */
    DWORD f4;
    WORD f3;
    VPSTR f2;
    HWND16 f1;
} WINHELP16;
typedef WINHELP16 UNALIGNED *PWINHELP16;

typedef struct _WIN32WINHELP16 {         /* ??? */
    DWORD f4;
    WORD f3;
    VPSTR f2;
    HWND16 f1;
} WIN32WINHELP16;
typedef WIN32WINHELP16 UNALIGNED *PWIN32WINHELP16;


typedef struct _WINOLDAPPHACKOMATIC16 { /* u322 */
    LONG    f1;
} WINOLDAPPHACKOMATIC16;
typedef WINOLDAPPHACKOMATIC16 UNALIGNED *PWINOLDAPPHACKOMATIC16;

typedef struct _WRITECOMM16 {           /* u205 */
    SHORT f3;
    VPSTR f2;
    SHORT f1;
} WRITECOMM16;
typedef WRITECOMM16 UNALIGNED *PWRITECOMM16;

typedef struct _WSPRINTF16 {            /* u420 */
    VPSTR f2;
    VPSTR f1;
} WSPRINTF16;
typedef WSPRINTF16 UNALIGNED *PWSPRINTF16;

typedef struct _WVSPRINTF16 {           /* u421 */
    VPSTR f3;
    VPSTR f2;
    VPSTR f1;
} WVSPRINTF16;
typedef WVSPRINTF16 UNALIGNED *PWVSPRINTF16;

#ifdef NULLSTRUCT
typedef struct _XCSTODS16 {             /* u315 */
} XCSTODS16;
typedef XCSTODS16 UNALIGNED *PXCSTODS16;
#endif

typedef struct _SETWINDOWSHOOKEX16 {      /* u291 */
    HTASK16 f4;
    HAND16  f3;
    VPPROC  f2;
    SHORT   f1;
} SETWINDOWSHOOKEX16;
typedef SETWINDOWSHOOKEX16 UNALIGNED *PSETWINDOWSHOOKEX16;

typedef struct _UNHOOKWINDOWSHOOKEX16 {       /* u292 */
    HHOOK16 f1;
} UNHOOKWINDOWSHOOKEX16;
typedef UNHOOKWINDOWSHOOKEX16 UNALIGNED *PUNHOOKWINDOWSHOOKEX16;

typedef struct _CALLNEXTHOOKEX16 {         /* u293 */
    DWORD   f4;
    WORD    f3;
    SHORT   f2;
    HHOOK16 f1;
} CALLNEXTHOOKEX16;
typedef CALLNEXTHOOKEX16 UNALIGNED *PCALLNEXTHOOKEX16;

typedef struct _CLOSEDRIVER16 {    /* u253 */
    VPVOID f3;
    VPVOID f2;
    WORD f1;
} CLOSEDRIVER16;
typedef CLOSEDRIVER16 UNALIGNED *PCLOSEDRIVER16;

typedef struct _COPYCURSOR16 {     /* u369 */
    HAND16 f2;
    HAND16 f1;
} COPYCURSOR16;
typedef COPYCURSOR16 UNALIGNED *PCOPYCURSOR16;

typedef struct _COPYICON16 {       /* u368 */
    HAND16 f2;
    HAND16 f1;
} COPYICON16;
typedef COPYICON16 UNALIGNED *PCOPYICON16;

typedef struct _DEFDRIVERPROC16 {      /* u255 */
    VPVOID f5;
    VPVOID f4;
    WORD    f3;
    HAND16 f2;
    DWORD f1;
} DEFDRIVERPROC16;
typedef DEFDRIVERPROC16 UNALIGNED *PDEFDRIVERPROC16;

typedef struct _ENABLESCROLLBAR16 {    /* u482 */
    WORD f3;
    SHORT f2;
    HAND16 f1;
} ENABLESCROLLBAR16;
typedef ENABLESCROLLBAR16 UNALIGNED *PENABLESCROLLBAR16;

typedef struct _GETCLIPCURSOR16 {      /* u309 */
    VPRECT16 f1;
} GETCLIPCURSOR16;
typedef GETCLIPCURSOR16 UNALIGNED *PGETCLIPCURSOR16;

typedef struct _GETDCEX16 {    /* u359 */
    DWORD f3;
    WORD f2;
    HAND16 f1;
} GETDCEX16;
typedef GETDCEX16 UNALIGNED *PGETDCEX16;

typedef struct _GETDRIVERMODULEHANDLE16 {      /* u254 */
    HAND16 f1;
} GETDRIVERMODULEHANDLE16;
typedef GETDRIVERMODULEHANDLE16 UNALIGNED *PGETDRIVERMODULEHANDLE16;

typedef struct _GETDRIVERINFO16 {      /* u256 */
    VPVOID f2;
    HAND16 f1;
} GETDRIVERINFO16;
typedef GETDRIVERINFO16 UNALIGNED *PGETDRIVERINFO16;

typedef struct _GETFREESYSTEMRESOURCES16 {     /* u284 */
    WORD f1;
} GETFREESYSTEMRESOURCES16;
typedef GETFREESYSTEMRESOURCES16 UNALIGNED *PGETFREESYSTEMRESOURCES16;

typedef struct _GETNEXTDRIVER16 {      /* u257 */
    DWORD f2;
    HAND16 f1;
} GETNEXTDRIVER16;
typedef GETNEXTDRIVER16 UNALIGNED *PGETNEXTDRIVER16;

typedef struct _GETQUEUESTATUS16 {     /* u334 */
    WORD f1;
} GETQUEUESTATUS16;
typedef GETQUEUESTATUS16 UNALIGNED *PGETQUEUESTATUS16;

typedef struct _GETWINDOWPLACEMENT16 {     /* u370 */
    VPVOID f2;
    HAND16 f1;
} GETWINDOWPLACEMENT16;
typedef GETWINDOWPLACEMENT16 UNALIGNED *PGETWINDOWPLACEMENT16;

typedef struct _ISMENU16 {     /* u358 */
    HAND16 f1;
} ISMENU16;
typedef ISMENU16 UNALIGNED *PISMENU16;

typedef struct _LOCKINPUT16 {      /* u226 */
    BOOL16 f3;
    HAND16 f2;
    HAND16 f1;
} LOCKINPUT16;
typedef LOCKINPUT16 UNALIGNED *PLOCKINPUT16;

typedef struct _LOCKWINDOWUPDATE16 {       /* u294 */
    HAND16 f1;
} LOCKWINDOWUPDATE16;
typedef LOCKWINDOWUPDATE16 UNALIGNED *PLOCKWINDOWUPDATE16;

typedef struct _MAPWINDOWPOINTS16 {    /* u258 */
    WORD f4;
    VPVOID f3;
    HAND16 f2;
    HAND16 f1;
} MAPWINDOWPOINTS16;
typedef MAPWINDOWPOINTS16 UNALIGNED *PMAPWINDOWPOINTS16;

typedef struct _OPENDRIVER16 {     /* u252 */
    VPVOID f3;
    VPVOID f2;
    VPVOID f1;
} OPENDRIVER16;
typedef OPENDRIVER16 UNALIGNED *POPENDRIVER16;

typedef struct _QUERYSENDMESSAGE16 {       /* u184 */
    VPVOID f4;
    WORD f3;
    WORD f2;
    WORD f1;
} QUERYSENDMESSAGE16;
typedef QUERYSENDMESSAGE16 UNALIGNED *PQUERYSENDMESSAGE16;

typedef struct _REDRAWWWINDOW16 {      /* ux293 */
    WORD f4;
    WORD f3;
    VPVOID f2;
    HAND16 f1;
} REDRAWWWINDOW16;
typedef REDRAWWWINDOW16 UNALIGNED *PREDRAWWWINDOW16;

typedef struct _SCROLLWINDOWEX16 {     /* u319 */
    WORD f8;
    VPRECT16 f7;
    WORD f6;
    VPRECT16 f5;
    VPRECT16 f4;
    SHORT f3;
    SHORT f2;
    HAND16 f1;
} SCROLLWINDOWEX16;
typedef SCROLLWINDOWEX16 UNALIGNED *PSCROLLWINDOWEX16;

typedef struct _SENDDRIVERMESSAGE16 {      /* u251 */
    VPVOID f4;
    VPVOID f3;
    WORD f2;
    HAND16 f1;
} SENDDRIVERMESSAGE16;
typedef SENDDRIVERMESSAGE16 UNALIGNED *PSENDDRIVERMESSAGE16;

typedef struct _REDRAWWINDOW16 {       /* u290 */
    WORD f4;
    WORD f3;
    VPVOID f2;
    HAND16 f1;
} REDRAWWINDOW16;
typedef REDRAWWINDOW16 UNALIGNED *PREDRAWWINDOW16;


typedef struct _SETEVENTHOOK16 {     /* u321 */
    VPPROC f1;
} SETEVENTHOOK16;
typedef SETEVENTHOOK16 UNALIGNED *PSETEVENTHOOK16;

typedef struct _FILLWINDOW16 {     /* u324 */
    HBRSH16  f4;
    HDC16    f3;
    HWND16   f2;
    HWND16   f1;
} FILLWINDOW16;
typedef FILLWINDOW16 UNALIGNED *PFILLWINDOW16;

typedef struct _SETWINDOWPLACEMENT16 {     /* u371 */
    VPVOID f2;
    HAND16 f1;
} SETWINDOWPLACEMENT16;
typedef SETWINDOWPLACEMENT16 UNALIGNED *PSETWINDOWPLACEMENT16;

typedef struct _SUBTRACTRECT16 {       /* u373 */
    VPVOID f3;
    VPVOID f2;
    VPVOID f1;
} SUBTRACTRECT16;
typedef SUBTRACTRECT16 UNALIGNED *PSUBTRACTRECT16;

typedef struct _SYSTEMPARAMETERSINFO16 {       /* u483 */
    WORD f4;
    VPVOID f3;
    WORD f2;
    WORD f1;
} SYSTEMPARAMETERSINFO16;
typedef SYSTEMPARAMETERSINFO16 UNALIGNED *PSYSTEMPARAMETERSINFO16;

typedef struct _CURSORSHAPE16 { /* curs */
    SHORT xHotSpot;
    SHORT yHotSpot;
    SHORT cx;
    SHORT cy;
    SHORT cbWidth;  /* Bytes per row, accounting for word alignment. */
    BYTE Planes;
    BYTE BitsPixel;
} CURSORSHAPE16;
typedef CURSORSHAPE16 UNALIGNED *PCURSORSHAPE16;


typedef struct _MULTIKEYHELP16 { /* mkh */
    WORD    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP16;
typedef MULTIKEYHELP16 UNALIGNED *PMULTIKEYHELP16;


typedef struct _HELPWININFO16 { /* hwinfo */
    SHORT  wStructSize;
    SHORT  x;
    SHORT  y;
    SHORT  dx;
    SHORT  dy;
    SHORT  wMax;
    BYTE   rgchMember[2];
} HELPWININFO16;
typedef HELPWININFO16 UNALIGNED *PHELPWININFO16;

typedef struct _LOADACCEL16 {    /* ldaccel */
    WORD   hInst;
    WORD   hAccel;
    VPVOID pAccel;
    DWORD  cbAccel;
} LOADACCEL16;
typedef LOADACCEL16 UNALIGNED FAR *PLOADACCEL16;

typedef struct _NOTIFYWOW16 {           /* u535 */
    VPVOID pData;
    WORD   Id;
} NOTIFYWOW16;
typedef NOTIFYWOW16 UNALIGNED *PNOTIFYWOW16;
