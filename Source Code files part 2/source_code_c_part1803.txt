      xi;
#ifdef UNICODE
    IShellLinkA         slA;            // To support ANSI callers
#endif
#ifdef ENABLE_TRACK
    IShellLinkTracker   slt;        // Interface to CTracker object.
#endif
#ifdef WINNT
    IShellLinkDataList  sldl;
#endif

    UINT                cRef;

    BOOL                bDirty;         // something has changed
    LPTSTR              pszCurFile;     // current file from IPersistFile
    LPTSTR              pszRelSource;   // overrides pszCurFile in relative tracking

    IContextMenu        *pcmTarget;     // stuff for IContextMenu
    UINT                indexMenuSave;
    UINT                idCmdFirstSave;
    UINT                idCmdLastSave;
    UINT                uFlagsSave;

    BOOL                fDataAlreadyResolved;   // for data object

    // IDropTarget specific
    IDropTarget*        pdtSrc;         // IDropTarget of link source (unresolved)
    DWORD               grfKeyStateLast;

    // persistant data

    LPITEMIDLIST        pidl;           // may be NULL
    PLINKINFO           pli;            // may be NULL

    LPTSTR              pszName;        // title on short volumes
    LPTSTR              pszRelPath;
    LPTSTR              pszWorkingDir;
    LPTSTR              pszArgs;
    LPTSTR              pszIconLocation;

    LPDBLIST            pExtraData;     // extra data to preserve for future compatibility

#ifdef ENABLE_TRACK
    struct CTracker *   ptracker;
#endif

    SHELL_LINK_DATA     sld;
} CShellLink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\tools\pifdump\pifdump.h ===
#include <windows.h>
#include <stdio.h>
#define UNICODE
#include <pif.h>
#undef UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\tools\pifdump\pifdump.c ===
#include <pifdump.h>
#pragma hdrstop


#define STRING(x) x[0]?x:"(empty string in .pif file)"


int __cdecl main( int argc, char *argv[])
{
    HFILE hFile;
    STDPIF stdpif;
    PIFEXTHDR pifexthdr;
    LONG cbRead;
    CHAR szTemp[ 512 ];
    memset( &stdpif, 0, sizeof(stdpif) );

    if (argc!=2)
    {
        printf("usage: pifdump filename.pif\n" );
        return(1);
    }


    hFile =  _lopen( argv[1], OF_READ );
    if (hFile == HFILE_ERROR)
    {
        printf( "pifdump: unable to open file %s, err %d\n",
                argv[1],
                GetLastError()
               );
        return(1);
    }

    _lread( hFile, &stdpif, sizeof(stdpif) );


    printf( "\n===== Dump of PIF file (%s) =====\n\n", argv[1] );

    printf( "[Standard PIF Data]\n" );
    printf( "    unknown    = 0x%02X\n", stdpif.unknown );
    printf( "    id         = 0x%02X\n", stdpif.id );
    printf( "    appname    = %s\n",     STRING(stdpif.appname) );
    printf( "    maxmem     = 0x%04X\n", stdpif.maxmem );
    printf( "    minmem     = 0x%04X\n", stdpif.minmem );
    printf( "    startfile  = %s\n",     STRING(stdpif.startfile) );
    printf( "    MSflags    = 0x%02X\n", stdpif.MSflags );
    if (stdpif.MSflags & fResident)
        printf( "        [fResident is set ==> directly modifies memory]\n", fResident );
    if (stdpif.MSflags & fGraphics)
        printf( "        [fGraphics is set ==> screen exchange: graphics/text]\n", fGraphics );
    if (stdpif.MSflags & fNoSwitch)
        printf( "        [fNoSwitch is set ==> program switch: prevent]\n", fNoSwitch );
    if (stdpif.MSflags & fNoGrab)
        printf( "        [fNoGrab   is set ==> screen exchange: none]\n", fNoGrab );
    if (stdpif.MSflags & fDestroy)
        printf( "        [fDestroy  is set ==> close window on exit]\n", fDestroy );
    if (stdpif.MSflags & fCOM1)
        printf( "        [fCOM1     is set ==> directly modifies: COM1]\n", fCOM1 );
    if (stdpif.MSflags & fCOM2)
        printf( "        [fCOM2     is set ==> directly modifies: COM2]\n", fCOM2 );
    printf( "    reserved   = 0x%02X\n", stdpif.reserved );
    printf( "    defpath    = %s\n",     STRING(stdpif.defpath) );
    printf( "    params     = %s\n",     STRING(stdpif.params) );
    printf( "    cPages     = 0x%02X   (should always be 0x01!)\n", stdpif.cPages );
    printf( "    lowVector  = 0x%02X   (should always be 0x00!)\n", stdpif.lowVector );
    printf( "    highVector = 0x%02X   (should always be 0xFF!)\n", stdpif.highVector );
    printf( "    rows       = 0x%02X   (not used)\n", stdpif.rows );
    printf( "    cols       = 0x%02X   (not used)\n", stdpif.cols );
    printf( "    rowoff     = 0x%02X   (not used)\n", stdpif.rowoff );
    printf( "    coloff     = 0x%02X   (not used)\n", stdpif.coloff );
    printf( "    sysmem     = 0x%04X (not used)\n", stdpif.sysmem );
    printf( "    behavior   = 0x%02X\n", stdpif.behavior);
    if (stdpif.behavior & fScreen)
        printf( "      [fScreen     (0x%02X) is set ==> directly modifies screen]\n", fScreen );
    if (stdpif.behavior & fForeground)
        printf( "      [fForeground (0x%02X) is set ==> Set same as fScreen (alias)]\n", fForeground );
    if (stdpif.behavior & f8087)
        printf( "      [f8087       (0x%02X) is set ==> No PIFEDIT control]\n", f8087 );
    if (stdpif.behavior & fKeyboard)
        printf( "      [fKeyboard   (0x%02X) is set ==> directly modifies keyboard]\n", fKeyboard );
    printf( "    sysflags   = 0x%02X\n", stdpif.sysflags);


    // Read in extended header sections
    while( (cbRead = _lread( hFile, &pifexthdr, sizeof( pifexthdr )))!=0 )
    {
        printf( "\n[%s]\n", pifexthdr.extsig );

        if (strcmp(pifexthdr.extsig, STDHDRSIG)==0) {


            if (pifexthdr.extnxthdrfloff==0xFFFF) {
                printf( "    No more entries\n" );
                goto OutOfHere;
            }
            else
                printf( "    No information in \"%s\" section (as expected)\n\n", STDHDRSIG );

        }

        if (strcmp(pifexthdr.extsig, W286HDRSIG30)==0) {

            W286PIF30   w286ext30;


            _lread( hFile, &w286ext30, sizeof( w286ext30 ) );
            printf( "    PfMaxXmsK   = 0x%04X\n", w286ext30.PfMaxXmsK );
            printf( "    PfMinXmsK   = 0x%04X\n", w286ext30.PfMinXmsK );
            printf( "    PfW286Flags = 0x%04X\n", w286ext30.PfW286Flags );
            if (w286ext30.PfW286Flags & fALTTABdis286)
                printf( "        fALTTABdis286   is set.\n" );
            if (w286ext30.PfW286Flags & fALTESCdis286)
                printf( "        fALTESCdis286   is set.\n" );
            if (w286ext30.PfW286Flags & fALTESCdis286)
                printf( "        fALTPRTSCdis286 is set.\n" );
            if (w286ext30.PfW286Flags & fPRTSCdis286)
                printf( "        fPRTSCdis286    is set.\n" );
            if (w286ext30.PfW286Flags & fCTRLESCdis286)
                printf( "        fCTRLESCdis286  is set.\n" );
            if (w286ext30.PfW286Flags & fNoSaveVid286)
                printf( "        fNoSaveVid286   is set.\n" );
            if (w286ext30.PfW286Flags & fCOM3_286)
                printf( "        fCOM3_286       is set.\n" );
            if (w286ext30.PfW286Flags & fCOM4_286)
                printf( "        fCOM4_286       is set.\n" );
            printf( "\n" );

        }

        if (strcmp(pifexthdr.extsig, W386HDRSIG30)==0) {
            W386PIF30   w386ext30;

            _lread( hFile, &w386ext30, sizeof( w386ext30 ) );
            printf( "    PfW386maxmem  = 0x%02X (%d)\n", w386ext30.PfW386maxmem, w386ext30.PfW386maxmem );
            printf( "    PfW386minmem  = 0x%02X (%d)\n", w386ext30.PfW386minmem, w386ext30.PfW386minmem );
            printf( "    PfFPriority   = 0x%02X (%d)\n", w386ext30.PfFPriority,  w386ext30.PfFPriority );
            printf( "    PfBPriority   = 0x%02X (%d)\n", w386ext30.PfBPriority,  w386ext30.PfBPriority );
            printf( "    PfMaxEMMK     = 0x%02X (%d)\n", w386ext30.PfMaxEMMK,    w386ext30.PfMaxEMMK );
            printf( "    PfMinEMMK     = 0x%02X (%d)\n", w386ext30.PfMinEMMK,    w386ext30.PfMinEMMK );
            printf( "    PfMaxXmsK     = 0x%02X (%d)\n", w386ext30.PfMaxXmsK,    w386ext30.PfMaxXmsK );
            printf( "    PfMinXmsK     = 0x%02X (%d)\n", w386ext30.PfMinXmsK,    w386ext30.PfMinXmsK );
            printf( "    PfW386Flags   = 0x%08X\n", w386ext30.PfW386Flags );
            if (w386ext30.PfW386Flags & fEnableClose)
                printf( "        fEnableClose    is set.\n" );
            if (w386ext30.PfW386Flags & fBackground)
                printf( "        fBackground     is set.\n" );
            if (w386ext30.PfW386Flags & fExclusive)
                printf( "        fExclusive      is set.\n" );
            if (w386ext30.PfW386Flags & fFullScreen)
                printf( "        fFullScreen     is set.\n" );
            if (w386ext30.PfW386Flags & fALTTABdis)
                printf( "        fALTTABdis      is set.\n" );
            if (w386ext30.PfW386Flags & fALTESCdis)
                printf( "        fALTESCdis      is set.\n" );
            if (w386ext30.PfW386Flags & fALTSPACEdis)
                printf( "        fALTSPACEdis    is set.\n" );
            if (w386ext30.PfW386Flags & fALTENTERdis)
                printf( "        fALTENTERdis    is set.\n" );
            if (w386ext30.PfW386Flags & fALTPRTSCdis)
                printf( "        fALTPRTSCdis    is set.\n" );
            if (w386ext30.PfW386Flags & fPRTSCdis)
                printf( "        fPRTSCdis       is set.\n" );
            if (w386ext30.PfW386Flags & fCTRLESCdis)
                printf( "        fCTRLESCdis     is set.\n" );
            if (w386ext30.PfW386Flags & fPollingDetect)
                printf( "        fPollingDetect  is set.\n" );
            if (w386ext30.PfW386Flags & fNoHMA)
                printf( "        fNoHMA          is set.\n" );
            if (w386ext30.PfW386Flags & fHasHotKey)
                printf( "        fHasHotKey      is set.\n" );
            if (w386ext30.PfW386Flags & fEMSLocked)
                printf( "        fEMSLocked      is set.\n" );
            if (w386ext30.PfW386Flags & fXMSLocked)
                printf( "        fXMSLocked      is set.\n" );
            if (w386ext30.PfW386Flags & fINT16Paste)
                printf( "        fINT16Paste     is set.\n" );
            if (w386ext30.PfW386Flags & fVMLocked)
                printf( "        fVMLocked       is set.\n" );
            if (w386ext30.PfW386Flags & fGlobalProtect)
                printf( "        fGlobalProtect  is set.\n" );
            if (w386ext30.PfW386Flags & fMinimized)
                printf( "        fMinimized      is set.\n" );
            if (w386ext30.PfW386Flags & fMaximized)
                printf( "        fMaximized      is set.\n" );
            if (w386ext30.PfW386Flags & fRealMode)
                printf( "        fRealMode       is set.\n" );
            if (w386ext30.PfW386Flags & fWinLie)
                printf( "        fWinLie         is set.\n" );
            if (w386ext30.PfW386Flags & fStrayPtrDetect)
                printf( "        fStrayPtrDetect is set.\n" );
            if (w386ext30.PfW386Flags & fNoSuggestMSDOS)
                printf( "        fNoSuggestMSDOS is set.\n" );
            if (w386ext30.PfW386Flags & fLocalUMBs)
                printf( "        fLocalUMBs      is set.\n" );
            if (w386ext30.PfW386Flags & fRealModeSilent)
                printf( "        fRealModeSilent is set.\n" );
            if (w386ext30.PfW386Flags & fQuickStart)
                printf( "        fQuickStart     is set.\n" );
            if (w386ext30.PfW386Flags & fAmbiguousPIF)
                printf( "        fAmbiguousPIF   is set.\n" );
            printf( "    PfW386Flags2  = 0x%08X\n", w386ext30.PfW386Flags2 );
            if (w386ext30.PfW386Flags2 & fVidTxtEmulate)
                printf( "        fVidTxtEmulate  is set.\n" );
            if (w386ext30.PfW386Flags2 & fVidNoTrpTxt)
                printf( "        fVidNoTrpTxt    is set.\n" );
            if (w386ext30.PfW386Flags2 & fVidNoTrpLRGrfx)
                printf( "        fVidNoTrpLRGrfx is set.\n" );
            if (w386ext30.PfW386Flags2 & fVidNoTrpHRGrfx)
                printf( "        fVidNoTrpHRGrfx is set.\n" );
            if (w386ext30.PfW386Flags2 & fVidTextMd)
                printf( "        fVidTextMd      is set.\n" );
            if (w386ext30.PfW386Flags2 & fVidLowRsGrfxMd)
                printf( "        fVidLowRsGrfxd  is set.\n" );
            if (w386ext30.PfW386Flags2 & fVidHghRsGrfxMd)
                printf( "        fVidHghRsGrfxd  is set.\n" );
            if (w386ext30.PfW386Flags2 & fVidRetainAllo)
                printf( "        fVidRetainAllo  is set.\n" );
            printf( "    PfHotKeyScan  = 0x%04X\n", w386ext30.PfHotKeyScan );
            printf( "    PfHotKeyShVal = 0x%04X\n", w386ext30.PfHotKeyShVal );
            printf( "    PfHotKeyShMsk = 0x%04X\n", w386ext30.PfHotKeyShMsk );
            printf( "    PfHotKeyVal   = 0x%02X\n", w386ext30.PfHotKeyVal );
            printf( "    PfW386params  = %s\n",     STRING(w386ext30.PfW386params) );
            printf( "\n" );

        }

        if (strcmp(pifexthdr.extsig, WNTHDRSIG31)==0) {
            WNTPIF31    wntpif31;

            _lread( hFile, &wntpif31, sizeof( wntpif31 ) );
            printf( "    ==> Internal Revision %d <==\n", wntpif31.wInternalRevision );
            printf( "    dwWNTFlags      = 0x%08X\n", wntpif31.nt31Prop.dwWNTFlags );
            if (wntpif31.nt31Prop.dwWNTFlags & COMPAT_TIMERTIC)
                printf( "        COMPAT_TIMERTIC is set.\n" );
            printf( "    dwRes1          = 0x%08X\n", wntpif31.nt31Prop.dwRes1 );
            printf( "    dwRes2          = 0x%08X\n", wntpif31.nt31Prop.dwRes2 );
            printf( "    achConfigFile   = %s\n", STRING(wntpif31.nt31Prop.achConfigFile) );
            printf( "    achAuotexecFile = %s\n", STRING(wntpif31.nt31Prop.achAutoexecFile) );
        }

        if (strcmp(pifexthdr.extsig, WENHHDRSIG40)==0) {
            WENHPIF40    wenhpif40;

            _lread( hFile, &wenhpif40, sizeof( wenhpif40 ) );
            printf( "    ==> Internal Revision %d <==\n", wenhpif40.wInternalRevision );
            printf( "    dwEnhModeFlagsProp  = 0x%08X\n", wenhpif40.dwEnhModeFlagsProp );
            printf( "    dwRealModeFlagsProp = 0x%08X\n", wenhpif40.dwRealModeFlagsProp );
            printf( "    achOtherFileProp    = %s\n",     STRING(wenhpif40.achOtherFileProp) );
            printf( "    achIconFileProp     = %s\n",     STRING(wenhpif40.achIconFileProp) );
            printf( "    wIconInxexProp      = 0x%04X\n", wenhpif40.wIconIndexProp );

            printf( "    PROPTSK:\n" );
            printf( "        flTsk            = 0x%04X\n", wenhpif40.tskProp.flTsk );
            if (wenhpif40.tskProp.flTsk & TSK_ALLOWCLOSE)
                printf( "            TSK_ALLOWCLOSE      is set.\n" );
            if (wenhpif40.tskProp.flTsk & TSK_BACKGROUND)
                printf( "            TSK_BACKGROUND      is set.\n" );
            if (wenhpif40.tskProp.flTsk & TSK_EXCLUSIVE)
                printf( "            TSK_EXCLUSIVE       is set.\n" );
            if (wenhpif40.tskProp.flTsk & TSK_NOWARNTERMINATE)
                printf( "            TSK_NOWARNTERMINATE is set.\n" );
            if (wenhpif40.tskProp.flTsk & TSK_NOSCREENSAVER)
                printf( "            TSK_NOSCREENSAVER   is set.\n" );
            printf( "        flTskInit        = 0x%04X\n", wenhpif40.tskProp.flTskInit );
            printf( "        wReserved1       = 0x%04X\n", wenhpif40.tskProp.wReserved1 );
            printf( "        wReserved2       = 0x%04X\n", wenhpif40.tskProp.wReserved2 );
            printf( "        wReserved3       = 0x%04X\n", wenhpif40.tskProp.wReserved3 );
            printf( "        wReserved4       = 0x%04X\n", wenhpif40.tskProp.wReserved4 );
            printf( "        wIdleSensitivity = 0x%04X\n", wenhpif40.tskProp.wIdleSensitivity );

            printf( "    PROPVID:\n" );
            printf( "        flVid        = 0x%04X\n", wenhpif40.vidProp.flVid );
            if (wenhpif40.vidProp.flVid & VID_TEXTEMULATE)
                printf( "            VID_TEXTEMULATE  is set.\n" );
            if (wenhpif40.vidProp.flVid & VID_RETAINMEMORY)
                printf( "            VID_RETAINMEMORY is set.\n" );
            if (wenhpif40.vidProp.flVid & VID_FULLSCREEN)
                printf( "            VID_FULLSCREEN   is set.\n" );
            printf( "        flVidInit    = 0x%04X\n", wenhpif40.vidProp.flVidInit );
            printf( "        wReserved1   = 0x%04X\n", wenhpif40.vidProp.wReserved1 );
            printf( "        wReserved2   = 0x%04X\n", wenhpif40.vidProp.wReserved2 );
            printf( "        wReserved3   = 0x%04X\n", wenhpif40.vidProp.wReserved3 );
            printf( "        cScreenLines = 0x%04X\n", wenhpif40.vidProp.cScreenLines );

            printf( "    PROPKBD:\n" );
            printf( "        flKbd            = 0x%04X\n", wenhpif40.kbdProp.flKbd );
            if (wenhpif40.kbdProp.flKbd & KBD_FASTPASTE)
                printf( "            KBD_FASTPASTE  is set.\n" );
            if (wenhpif40.kbdProp.flKbd & KBD_NOALTTAB)
                printf( "            KBD_NOALTTAB   is set.\n" );
            if (wenhpif40.kbdProp.flKbd & KBD_NOALTESC)
                printf( "            KBD_NOALTESC   is set.\n" );
            if (wenhpif40.kbdProp.flKbd & KBD_NOALTSPACE)
                printf( "            KBD_NOALTSPACE is set.\n" );
            if (wenhpif40.kbdProp.flKbd & KBD_NOALTENTER)
                printf( "            KBD_NOALTENTER is set.\n" );
            if (wenhpif40.kbdProp.flKbd & KBD_NOALTPRTSC)
                printf( "            KBD_NOALTPRTSC is set.\n" );
            if (wenhpif40.kbdProp.flKbd & KBD_NOPRTSC)
                printf( "            KBD_NOPRTSC    is set.\n" );
            if (wenhpif40.kbdProp.flKbd & KBD_NOCTRLESC)
                printf( "            KBD_NOCTRLESC   is set.\n" );
            printf( "        flKbdInit        = 0x%04X\n", wenhpif40.kbdProp.flKbdInit );
            printf( "        msAltDelay       = 0x%04X\n", wenhpif40.kbdProp.msAltDelay );
            printf( "        msAltPasteDelay  = 0x%04X\n", wenhpif40.kbdProp.msAltPasteDelay );
            printf( "        msPasteDelay     = 0x%04X\n", wenhpif40.kbdProp.msPasteDelay );
            printf( "        msPasteFullDelay = 0x%04X\n", wenhpif40.kbdProp.msPasteFullDelay );
            printf( "        msPasteTimeout   = 0x%04X\n", wenhpif40.kbdProp.msPasteTimeout );
            printf( "        cPasteSkip       = 0x%04X\n", wenhpif40.kbdProp.cPasteSkip );
            printf( "        cPasteCRSkip     = 0x%04X\n", wenhpif40.kbdProp.cPasteCRSkip );

            printf( "    PROPMSE:\n" );
            printf( "        flMse     = 0x%04X\n", wenhpif40.mseProp.flMse );
            if (wenhpif40.mseProp.flMse & MSE_WINDOWENABLE)
                printf( "            MSE_WINDOWENABLE is set.\n" );
            if (wenhpif40.mseProp.flMse & MSE_EXCLUSIVE)
                printf( "            MSE_EXCLUSIVE    is set.\n" );
            printf( "        flMseInit = 0x%04X\n", wenhpif40.mseProp.flMseInit );

            printf( "    PROPSND:\n" );
            printf( "        flSnd     = 0x%04X\n", wenhpif40.sndProp.flSnd );
            if (wenhpif40.sndProp.flSnd & SND_SPEAKERENABLE)
                printf( "            SND_SPEAKERENABLE is set.\n" );
            printf( "        flSndInit = 0x%04X\n", wenhpif40.sndProp.flSndInit );

            printf( "    PROPFNT:\n" );
            printf( "        flFnt             = 0x%04X\n", wenhpif40.fntProp.flFnt );
            if (wenhpif40.fntProp.flFnt & FNT_RASTERFONTS)
                printf( "            FNT_RASTERFONTS is set.\n" );
            if (wenhpif40.fntProp.flFnt & FNT_TTFONTS)
                printf( "            FNT_TTFONTS     is set.\n" );
            if (wenhpif40.fntProp.flFnt & FNT_AUTOSIZE)
                printf( "            FNT_AUTOSIZE    is set.\n" );
            if (wenhpif40.fntProp.flFnt & FNT_RASTER)
                printf( "            FNT_RASTER      is set.\n" );
            if (wenhpif40.fntProp.flFnt & FNT_TT)
                printf( "            FNT_TT          is set.\n" );
            printf( "        flFntInit         = 0x%04X\n", wenhpif40.fntProp.flFntInit );
            printf( "        cxFont            = 0x%04X (%d)\n", wenhpif40.fntProp.cxFont, wenhpif40.fntProp.cxFont );
            printf( "        cyFont            = 0x%04X (%d)\n", wenhpif40.fntProp.cyFont, wenhpif40.fntProp.cyFont );
            printf( "        cxFontActual      = 0x%04X (%d)\n", wenhpif40.fntProp.cxFontActual, wenhpif40.fntProp.cxFontActual );
            printf( "        cyFontActual      = 0x%04X (%d)\n", wenhpif40.fntProp.cyFontActual, wenhpif40.fntProp.cyFontActual );
            printf( "        achRasterFaceName = %s\n",     STRING(wenhpif40.fntProp.achRasterFaceName) );
            printf( "        achTTFaceName     = %s\n",     STRING(wenhpif40.fntProp.achRasterFaceName) );
            printf( "        wCurrentCP        = 0x%04X\n", wenhpif40.fntProp.wCurrentCP );

            printf( "    PROPWIN:\n" );
            printf( "        flWin      = 0x%04X\n", wenhpif40.winProp.flWin );
            if (wenhpif40.winProp.flWin & WIN_SAVESETTINGS)
                printf( "            WIN_SAVESETTINGS is set.\n" );
            if (wenhpif40.winProp.flWin & WIN_TOOLBAR)
                printf( "            WIN_TOOLBAR      is set.\n" );
            printf( "        flWinInit  = 0x%04X\n",      wenhpif40.winProp.flWinInit );
            printf( "        cxCells    = 0x%04X (%d)\n", wenhpif40.winProp.cxCells,  wenhpif40.winProp.cxCells );
            printf( "        cyCells    = 0x%04X (%d)\n", wenhpif40.winProp.cyCells,  wenhpif40.winProp.cyCells );
            printf( "        cxClient   = 0x%04X (%d)\n", wenhpif40.winProp.cxClient, wenhpif40.winProp.cxClient );
            printf( "        cyClient   = 0x%04X (%d)\n", wenhpif40.winProp.cyClient, wenhpif40.winProp.cyClient );
            printf( "        cxWindow   = 0x%04X (%d)\n", wenhpif40.winProp.cxWindow, wenhpif40.winProp.cxWindow );
            printf( "        cyWindow   = 0x%04X (%d)\n", wenhpif40.winProp.cyWindow, wenhpif40.winProp.cyWindow );
            printf( "        wLength    = 0x%04X\n",      wenhpif40.winProp.wLength );
            printf( "        wShowFlags = 0x%04X\n",      wenhpif40.winProp.wShowFlags );
            printf( "        wShowCmd   = 0x%04X\n",      wenhpif40.winProp.wShowCmd );
            printf( "        xMinimize  = 0x%04X (%d)\n", wenhpif40.winProp.xMinimize, wenhpif40.winProp.xMinimize );
            printf( "        yMinimize  = 0x%04X (%d)\n", wenhpif40.winProp.yMinimize, wenhpif40.winProp.yMinimize );
            printf( "        xMaximize  = 0x%04X (%d)\n", wenhpif40.winProp.xMaximize, wenhpif40.winProp.xMaximize );
            printf( "        yMaximize  = 0x%04X (%d)\n", wenhpif40.winProp.yMaximize, wenhpif40.winProp.yMaximize );
            printf( "        rcNormal   = (0x%04X, 0x%04X, 0x%04X, 0x%04X)\n",
                    wenhpif40.winProp.rcNormal.left, wenhpif40.winProp.rcNormal.top,
                    wenhpif40.winProp.rcNormal.right,wenhpif40.winProp.rcNormal.bottom
                   );

            printf( "    PROPENV:\n" );
            printf( "        flEnv         = 0x%04X\n", wenhpif40.envProp.flEnv );
            printf( "        flEnvInit     = 0x%04X\n", wenhpif40.envProp.flEnvInit );
            printf( "        achBatchFile  = %s\n",     STRING(wenhpif40.envProp.achBatchFile) );
            printf( "        cbEnvironemnt = 0x%04X\n", wenhpif40.envProp.cbEnvironment );
            printf( "        wMaxDPMI      = 0x%04X\n", wenhpif40.envProp.wMaxDPMI );

        }

        if (strcmp(pifexthdr.extsig, WNTHDRSIG40)==0) {

            WNTPIF40   wntpif40;

            _lread( hFile, &wntpif40, sizeof( wntpif40 ) );
            printf( "    ==> Internal Revision %d <==\n", wntpif40.wInternalRevision );
            printf( "    flWnt            = 0x%08X\n", wntpif40.nt40Prop.flWnt );
            if (wntpif40.nt40Prop.flWnt & WNT_LET_SYS_POS)
                printf( "            WNT_LET_SYS_POS   is set.\n" );
            if (wntpif40.nt40Prop.flWnt & WNT_CONSOLE_PROPS)
                printf( "            WNT_CONSOLE_PROPS is set.\n" );

            WideCharToMultiByte( CP_ACP, 0, wntpif40.nt40Prop.awchCmdLine, -1, szTemp, 512, NULL, NULL );
            printf( "    awchCmdLine      = %s\n", STRING(szTemp) );
            printf( "    achSaveCmdLine   = %s\n", STRING(wntpif40.nt40Prop.achSaveCmdLine) );

            WideCharToMultiByte( CP_ACP, 0, wntpif40.nt40Prop.awchOtherFile, -1, szTemp, 512, NULL, NULL );
            printf( "    awchOtherFile    = %s\n", STRING(szTemp) );
            printf( "    achSaveOtherFile = %s\n", STRING(wntpif40.nt40Prop.achSaveOtherFile) );

            WideCharToMultiByte( CP_ACP, 0, wntpif40.nt40Prop.awchPIFFile, -1, szTemp, 512, NULL, NULL );
            printf( "    awchPIFFile      = %s\n", STRING(szTemp) );
            printf( "    achSavePIFFile   = %s\n", STRING(wntpif40.nt40Prop.achSavePIFFile) );

            WideCharToMultiByte( CP_ACP, 0, wntpif40.nt40Prop.awchTitle, -1, szTemp, 512, NULL, NULL );
            printf( "    awchTitle        = %s\n", STRING(szTemp) );
            printf( "    achSaveTitle     = %s\n", STRING(wntpif40.nt40Prop.achSaveTitle) );

            WideCharToMultiByte( CP_ACP, 0, wntpif40.nt40Prop.awchIconFile, -1, szTemp, 512, NULL, NULL );
            printf( "    awchIconFIle     = %s\n", STRING(szTemp) );
            printf( "    achSaveIconFile  = %s\n", STRING(wntpif40.nt40Prop.achSaveIconFile) );

            WideCharToMultiByte( CP_ACP, 0, wntpif40.nt40Prop.awchWorkDir, -1, szTemp, 512, NULL, NULL );
            printf( "    awchWorkDir      = %s\n", STRING(szTemp) );
            printf( "    achSaveWorkDir   = %s\n", STRING(wntpif40.nt40Prop.achSaveWorkDir) );

            WideCharToMultiByte( CP_ACP, 0, wntpif40.nt40Prop.awchBatchFile, -1, szTemp, 512, NULL, NULL );
            printf( "    awchBatchFile    = %s\n", STRING(szTemp) );
            printf( "    achSaveBatchFile = %s\n", STRING(wntpif40.nt40Prop.achSaveBatchFile) );

            printf( "    dwForeColor      = 0x%08X\n", wntpif40.nt40Prop.dwForeColor );
            printf( "    dwBackColor      = 0x%08X\n", wntpif40.nt40Prop.dwBackColor );
            printf( "    dwPopupForeColor = 0x%08X\n", wntpif40.nt40Prop.dwPopupForeColor );
            printf( "    dwPopupBackColor = 0x%08X\n", wntpif40.nt40Prop.dwPopupBackColor );
            printf( "    WinSize          = (0x%04X, 0x%04X)\n", wntpif40.nt40Prop.WinSize.X,  wntpif40.nt40Prop.WinSize.Y );
            printf( "    BuffSize         = (0x%04X, 0x%04X)\n", wntpif40.nt40Prop.BuffSize.X, wntpif40.nt40Prop.BuffSize.Y );
            printf( "    WinPos           = (0x%08X, 0x%08X)\n", wntpif40.nt40Prop.WinPos.x,   wntpif40.nt40Prop.WinPos.y );
            printf( "    dwCursorSize     = 0x%08X\n", wntpif40.nt40Prop.dwCursorSize );
            printf( "    dwCmdHistBufSize = 0x%08X\n", wntpif40.nt40Prop.dwCmdHistBufSize );
            printf( "    dwNumCmdHist     = 0x%08X\n", wntpif40.nt40Prop.dwNumCmdHist );

        }

        _llseek( hFile, pifexthdr.extnxthdrfloff, FILE_BEGIN );

    }

OutOfHere:
    printf( "\n" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\mydiam.h ===
typedef struct tagLZI {
    BYTE *rgbyteRingBuf;    // ring buffer for expansion
    BYTE *rgbyteInBuf;      // input buffer for reads
    BYTE *pbyteInBufEnd;    // pointer past end of rgbyteInBuf[]
    BYTE *pbyteInBuf;       // pointer to next byte to read from
    BYTE *rgbyteOutBuf;     // output buffer for writes
    BYTE *pbyteOutBufEnd;   // pointer past end of rgbyteOutBuf[]
    BYTE *pbyteOutBuf;      // pointer to last byte to write from
    // Flag indicating whether or not rgbyteInBuf[0], which holds the last byte
    // from the previous input buffer, should be read as the next input byte.
    // (Only used so that at least one unReadUChar() can be done at all input
    // buffer positions.)
    BOOL bLastUsed;
    // Actually, rgbyteInBuf[] has length (ucbInBufLen + 1) since rgbyteInBuf[0]
    // is used when bLastUsed is TRUE.
    INT cbMaxMatchLen;      // longest match length for current algorithm
    LONG cblInSize,         // size in bytes of input file
         cblOutSize;        // size in bytes of output file
    DWORD ucbInBufLen,      // length of input buffer
          ucbOutBufLen;     // length of output buffer
    DWORD uFlags;           // LZ decoding description byte
    INT iCurRingBufPos;     // ring buffer offset
    INT *leftChild;         // parents and left and right
    INT *rightChild;        // children that make up the
    INT *parent;            // binary search trees

    INT iCurMatch,          // index of longest match (set by LZInsertNode())
        cbCurMatch;         // length of longest match (set by LZInsertNode())

} LZINFO;

typedef LZINFO *PLZINFO;

typedef struct _dcx {
    INT dcxDiamondLastIoError;
    HFDI dcxFdiContext;
    ERF dcxFdiError;
} DIAMOND_CONTEXT;

typedef DIAMOND_CONTEXT *PDIAMOND_CONTEXT;


extern DWORD itlsDiamondContext;

#define ITLS_ERROR          (0xFFFFFFFF)

#define GotDmdTlsSlot()     (itlsDiamondContext != ITLS_ERROR)
#define GotDmdContext()     (TlsGetValue(itlsDiamondContext) != NULL)

#define FdiContext          (((GotDmdTlsSlot() && GotDmdContext()) ? ((PDIAMOND_CONTEXT)(TlsGetValue(itlsDiamondContext)))->dcxFdiContext : NULL))
#define SetFdiContext(v)    (((PDIAMOND_CONTEXT)(TlsGetValue(itlsDiamondContext)))->dcxFdiContext = (v))
#define FdiError            (((PDIAMOND_CONTEXT)(TlsGetValue(itlsDiamondContext)))->dcxFdiError)
#define DiamondLastIoError  (((PDIAMOND_CONTEXT)(TlsGetValue(itlsDiamondContext)))->dcxDiamondLastIoError)

DWORD
InitDiamond(
    VOID
    );

VOID
TermDiamond(
    VOID
    );

BOOL
IsDiamondFile(
    IN PSTR FileName
    );

INT
ExpandDiamondFile(
    IN  PSTR       SourceFileName,  // Because LZOpen ... returns ASCII!
    IN  PTSTR      TargetFileName,
    IN  BOOL       RenameTarget,
    OUT PLZINFO    pLZI
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\diamond.c ===
#include <windows.h>
#include <lzexpand.h>
#include <fcntl.h>

/************************************************************************\
*
* NOTE!!!!
*
* While the 'Diamond' interfaced functions defined in this file are
* multi thread safe, EACH THREAD MUST ONLY HAVE ONE DIAMOND FILE
* OPEN AT A TIME!  (ie. You can not nest InitDiamond()/TermDiamond()
* pairs in one thread of execution.)
*
\************************************************************************/

//
// diamond headers
//
#include <diamondd.h>
#include "mydiam.h"

HINSTANCE hCabinet;
DWORD cCabinetLoad;
typedef HFDI (DIAMONDAPI * tFDICreate) (PFNALLOC pfnalloc,
                                        PFNFREE  pfnfree,
                                        PFNOPEN  pfnopen,
                                        PFNREAD  pfnread,
                                        PFNWRITE pfnwrite,
                                        PFNCLOSE pfnclose,
                                        PFNSEEK  pfnseek,
                                        int      cpuType,
                                        PERF     perf);

typedef BOOL (DIAMONDAPI * tFDIIsCabinet)(HFDI            hfdi,
                                          INT_PTR         hf,
                                          PFDICABINETINFO pfdici);

typedef BOOL (DIAMONDAPI * tFDICopy)(HFDI          hfdi,
                                     char FAR     *pszCabinet,
                                     char FAR     *pszCabPath,
                                     int           flags,
                                     PFNFDINOTIFY  pfnfdin,
                                     PFNFDIDECRYPT pfnfdid,
                                     void FAR     *pvUser);

typedef BOOL (DIAMONDAPI * tFDIDestroy)(HFDI hfdi);

tFDICreate    pFDICreate;
tFDIIsCabinet pFDIIsCabinet;
tFDICopy      pFDICopy;
tFDIDestroy   pFDIDestroy;

// this function is the same as CharNextA, available locally
extern LPSTR WINAPI VerCharNextA(LPCSTR lpCurrentChar);

INT CopyDateTimeStamp(INT_PTR doshFrom, INT_PTR doshTo)
{
    FILETIME lpCreationTime, lpLastAccessTime, lpLastWriteTime;

    if (!GetFileTime((HANDLE) doshFrom, &lpCreationTime, &lpLastAccessTime,
                     &lpLastWriteTime)) {
        return ((INT)LZERROR_BADINHANDLE);
    }
    if (!SetFileTime((HANDLE) doshTo, &lpCreationTime, &lpLastAccessTime,
                     &lpLastWriteTime)) {
        return ((INT)LZERROR_BADINHANDLE);
    }

    return (TRUE);
}

INT_PTR
DIAMONDAPI
SpdFdiOpen(
          IN PSTR FileName,
          IN int  oflag,
          IN int  pmode
          );

int
DIAMONDAPI
SpdFdiClose(
           IN INT_PTR Handle
           );

typedef struct _DIAMOND_INFO {

    //
    // A read handle to the source file.
    //
    INT_PTR SourceFileHandle;

    //
    // File names.
    //
    PSTR SourceFileName;
    PSTR TargetFileName;

    //
    // Flag indicating whether to rename the target file.
    //
    BOOL RenameTargetFile;

    //
    // Pointer to LZ information structure.
    // We'll fill in some of the fields to fool expand.
    //
    PLZINFO pLZI;

} DIAMOND_INFO, *PDIAMOND_INFO;


PSTR
StringRevChar(
             IN PSTR String,
             IN CHAR Char
             )
{
    //
    // Although not the most efficient possible algoeithm in each case,
    // this algorithm is correct for unicode, sbcs, or dbcs.
    //
    PCHAR Occurrence,Next;

    //
    // Check each character in the string and remember
    // the most recently encountered occurrence of the desired char.
    //
    for (Occurrence=NULL,Next=VerCharNextA(String); *String; ) {

        if (!memcmp(String,&Char,(int)((PUCHAR)Next-(PUCHAR)String))) {
            Occurrence = String;
        }

        String = Next;
        Next = VerCharNextA(Next);
    }

    //
    // Return address of final occurrence of the character
    // (will be NULL if not found at all).
    //
    return (Occurrence);
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
                     IN FDINOTIFICATIONTYPE Operation,
                     IN PFDINOTIFICATION    Parameters
                     )
{
    switch (Operation) {

        case fdintCABINET_INFO:
        case fdintNEXT_CABINET:
        case fdintPARTIAL_FILE:
        case fdintENUMERATE:

            //
            // Cabinet management functions which we don't use.
            // Return success.
            //
            return (0);

        case fdintCOPY_FILE:

            //
            // Diamond is asking us whether we want to copy the file.
            //
            {
                PDIAMOND_INFO Info = (PDIAMOND_INFO)Parameters->pv;
                HFILE h;

                //
                // If we need to rename the target file, do that here.
                // The name stored in the cabinet file will be used as
                // the uncompressed name.
                //
                if (Info->RenameTargetFile) {

                    PSTR p,q;

                    //
                    // Find the start of the filename part of the target.
                    //
                    if (p = StringRevChar(Info->TargetFileName,'\\')) {
                        p++;
                    } else {
                        p = Info->TargetFileName;
                    }

                    //
                    // Find the start of the filename part of the name in the cabinet.
                    //
                    if (q = StringRevChar(Parameters->psz1,'\\')) {
                        q++;
                    } else {
                        q = Parameters->psz1;
                    }

                    //
                    // Copy the filename part of the name in the cabinet over
                    // the filename part of the name in the target spec.
                    //
                    lstrcpyA(p,q);
                }

                {
                    // Check they're not the same file

                    CHAR Source[MAX_PATH];
                    CHAR Target[MAX_PATH];
                    PSTR FileName;
                    DWORD PathLenSource;
                    DWORD PathLenTarget;

                    PathLenSource = GetFullPathNameA(Info->SourceFileName,
                                                     MAX_PATH,
                                                     Source,
                                                     &FileName);
                    PathLenTarget = GetFullPathNameA(Info->TargetFileName,
                                                     MAX_PATH,
                                                     Target,
                                                     &FileName);

                    if (PathLenSource == 0 || PathLenSource >= MAX_PATH ||
                        PathLenTarget == 0 || PathLenTarget >= MAX_PATH ||
                        lstrcmpiA(Source, Target) == 0) {
                        return 0;
                    }
                }

                //
                // Remember the uncompressed size and open the file.
                // Returns -1 if an error occurs opening the file.
                //
                Info->pLZI->cblOutSize = Parameters->cb;
                h = _lcreat(Info->TargetFileName,0);
                if (h == HFILE_ERROR) {
                    DiamondLastIoError = LZERROR_BADOUTHANDLE;
                    return (-1);
                }
                return (h);
            }

        case fdintCLOSE_FILE_INFO:

            //
            // Diamond is done with the target file and wants us to close it.
            // (ie, this is the counterpart to fdint_COPY_FILE).
            //
            {
                PDIAMOND_INFO Info = (PDIAMOND_INFO)Parameters->pv;

                CopyDateTimeStamp(Info->SourceFileHandle,Parameters->hf);
                _lclose((HFILE)Parameters->hf);
            }
            return (TRUE);

         default:

            //
            // invalid operation
            //
            return(-1);
    }
}



PVOID
DIAMONDAPI
SpdFdiAlloc(
           IN ULONG NumberOfBytes
           )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return ((PVOID)LocalAlloc(LMEM_FIXED,NumberOfBytes));
}


VOID
DIAMONDAPI
SpdFdiFree(
          IN PVOID Block
          )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    LocalFree((HLOCAL)Block);
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
          IN PSTR FileName,
          IN int  oflag,
          IN int  pmode
          )

/*++

Routine Description:

    Callback used by FDICopy to open files.

Arguments:

    FileName - supplies name of file to be opened.

    oflag - supplies flags for open.

    pmode - supplies additional flags for open.

Return Value:

    Handle to open file or -1 if error occurs.

--*/

{
    HFILE h;
    int OpenMode;

    if (oflag & _O_WRONLY) {
        OpenMode = OF_WRITE;
    } else {
        if (oflag & _O_RDWR) {
            OpenMode = OF_READWRITE;
        } else {
            OpenMode = OF_READ;
        }
    }

    h = _lopen(FileName,OpenMode | OF_SHARE_DENY_WRITE);

    if (h == HFILE_ERROR) {
        DiamondLastIoError = LZERROR_BADINHANDLE;
        return (-1);
    }

    return ((INT_PTR)h);
}


UINT
DIAMONDAPI
SpdFdiRead(
          IN  INT_PTR Handle,
          OUT PVOID pv,
          IN  UINT  ByteCount
          )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;

    rc = _lread((HFILE)Handle,pv,ByteCount);

    if (rc == HFILE_ERROR) {
        rc = (UINT)(-1);
        DiamondLastIoError = LZERROR_READ;
    }

    return (rc);
}


UINT
DIAMONDAPI
SpdFdiWrite(
           IN INT_PTR Handle,
           IN PVOID pv,
           IN UINT  ByteCount
           )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;

    rc = _lwrite((HFILE)Handle,pv,ByteCount);

    if (rc == HFILE_ERROR) {

        DiamondLastIoError = (GetLastError() == ERROR_DISK_FULL) ? LZERROR_WRITE : LZERROR_BADOUTHANDLE;

    } else {

        if (rc != ByteCount) {
            //
            // let caller interpret return value but record last error just in case
            //
            DiamondLastIoError = LZERROR_WRITE;
        }
    }

    return (rc);
}


int
DIAMONDAPI
SpdFdiClose(
           IN INT_PTR Handle
           )

/*++

Routine Description:

    Callback used by FDICopy to close files.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    _lclose((HFILE)Handle);
    return (0);
}


LONG
DIAMONDAPI
SpdFdiSeek(
          IN INT_PTR Handle,
          IN long Distance,
          IN int  SeekType
          )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset or -1 if an error occurs.

--*/

{
    LONG rc;

    rc = _llseek((HFILE)Handle,Distance,SeekType);

    if (rc == HFILE_ERROR) {
        DiamondLastIoError = LZERROR_BADINHANDLE;
        rc = -1L;
    }

    return (rc);
}

//
// this function is linked in from ntdll
//
extern int sprintf(LPSTR, LPCSTR, ...);

INT
ExpandDiamondFile(
                 IN  PSTR       SourceFileName,      // Note ASCII
                 IN  PTSTR      TargetFileNameT,
                 IN  BOOL       RenameTarget,
                 OUT PLZINFO    pLZI
                 )
{
    BOOL b;
    INT rc;
    INT_PTR h;
    DIAMOND_INFO DiamondInfo;
    CHAR TargetFileName[MAX_PATH];

    sprintf(TargetFileName, "%ls", TargetFileNameT);

    if (!FdiContext) {
        return (LZERROR_BADVALUE);
    }

    DiamondLastIoError = TRUE;

    //
    // Get a handle to the source to use to
    // copy the date and time stamp.
    //
    h = SpdFdiOpen(SourceFileName,_O_RDONLY,0);
    if (h == -1) {
        return (LZERROR_BADINHANDLE);
    }

    pLZI->cblInSize = GetFileSize((HANDLE)h,NULL);
    if (pLZI->cblInSize == -1) {
        SpdFdiClose(h);
        return (LZERROR_BADINHANDLE);
    }

    DiamondInfo.SourceFileHandle = h;
    DiamondInfo.SourceFileName = SourceFileName;
    DiamondInfo.TargetFileName = TargetFileName;
    DiamondInfo.RenameTargetFile = RenameTarget;
    DiamondInfo.pLZI = pLZI;

    b = pFDICopy(
                FdiContext,
                SourceFileName,             // pass the whole path as the name
                "",                         // don't bother with the path part
                0,                          // flags
                DiamondNotifyFunction,
                NULL,                       // no decryption
                &DiamondInfo
                );

    if (b) {

        rc = TRUE;

    } else {

        switch (FdiError.erfOper) {

            case FDIERROR_CORRUPT_CABINET:
            case FDIERROR_UNKNOWN_CABINET_VERSION:
            case FDIERROR_BAD_COMPR_TYPE:
                rc = LZERROR_READ;              // causes SID_FORMAT_ERROR message
                break;

            case FDIERROR_ALLOC_FAIL:
                rc = LZERROR_GLOBALLOC;
                break;

            case FDIERROR_TARGET_FILE:
            case FDIERROR_USER_ABORT:
                rc = DiamondLastIoError;
                break;

            default:
                //
                // The rest of the errors are not handled specially.
                //
                rc = LZERROR_BADVALUE;
                break;
        }

        //
        // Remove the partial target file.
        //
        DeleteFileA(TargetFileName);
    }

    SpdFdiClose(h);

    return (rc);
}


BOOL
IsDiamondFile(
             IN PSTR FileName
             )
{
    FDICABINETINFO CabinetInfo;
    BOOL b;
    INT_PTR h;

    if (!FdiContext) {
        return (FALSE);
    }

    //
    // Open the file such that the handle is valid for use
    // in the diamond context (ie, seek, read routines above).
    //
    h = SpdFdiOpen(FileName,_O_RDONLY,0);
    if (h == -1) {
        return (FALSE);
    }

    b = pFDIIsCabinet(FdiContext,h,&CabinetInfo);

    SpdFdiClose(h);

    return (b);
}


DWORD
InitDiamond(
           VOID
           )
{
    PDIAMOND_CONTEXT pdcx;

    if (!GotDmdTlsSlot())
        return VIF_OUTOFMEMORY;

    if (GotDmdContext())
        return VIF_OUTOFMEMORY;

    pdcx = LocalAlloc(LPTR, sizeof(DIAMOND_CONTEXT));

    if (pdcx == NULL || !TlsSetValue(itlsDiamondContext, pdcx)) {
        /*
         * For some unknown reason, we can't associate
         * our thread storage with the slot, so free
         * it and say we never got one.
         */

        if (pdcx) {
            LocalFree(pdcx);
        }
        return VIF_OUTOFMEMORY;
    }

    if (!cCabinetLoad) {
        hCabinet = LoadLibraryW(L"CABINET.DLL");
        if (!hCabinet) {
            return (VIF_CANNOTLOADCABINET);
        }
        pFDICreate    = (tFDICreate)    GetProcAddress(hCabinet, "FDICreate");
        pFDIDestroy   = (tFDIDestroy)   GetProcAddress(hCabinet, "FDIDestroy");
        pFDIIsCabinet = (tFDIIsCabinet) GetProcAddress(hCabinet, "FDIIsCabinet");
        pFDICopy      = (tFDICopy)      GetProcAddress(hCabinet, "FDICopy");

        if (!(pFDICreate && pFDIDestroy && pFDIIsCabinet && pFDICopy)) {
            FreeLibrary(hCabinet);
            return (VIF_CANNOTLOADCABINET);
        }

        if (InterlockedExchangeAdd(&cCabinetLoad, 1) != 0) {
            // Multiple threads are attempting to LoadLib
            // Free one here.
            FreeLibrary(hCabinet);
        }
    }

    SetFdiContext( pFDICreate(
                             SpdFdiAlloc,
                             SpdFdiFree,
                             SpdFdiOpen,
                             SpdFdiRead,
                             SpdFdiWrite,
                             SpdFdiClose,
                             SpdFdiSeek,
                             cpuUNKNOWN,
                             &FdiError
                             ));

    return ((FdiContext == NULL) ? VIF_CANNOTLOADCABINET : 0);
}


VOID
TermDiamond(
           VOID
           )
{
    if (!GotDmdTlsSlot() || !GotDmdContext())
        return;

    if (FdiContext) {
        pFDIDestroy(FdiContext);
        SetFdiContext( NULL );
    }

    LocalFree( TlsGetValue(itlsDiamondContext) );
    TlsSetValue(itlsDiamondContext, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\filever.c ===
/***************************************************************************
 *  FILERES.C
 *
 *              File resource extraction routines.
 *
 ***************************************************************************/
//
//  REARCHITECT - GetVerInfoSize plays tricks and tells the caller to allocate
//  some extra slop at the end of the buffer in case we need to thunk all
//  the strings to ANSI.  The bug is that it only tells it to allocate
//  one extra ANSI char (== BYTE) for each Unicode char.  This is not correct
//  in the DBCS case (since one Unicode char can equal a two byte DBCS char)
//
//  We should change GetVerInfoSize return the Unicode size * 2 (instead
//  of (Unicode size * 1.5) and then change VerQueryInfoA to also use the
//  * 2 computation instead of * 1.5 (== x + x/2)
//
//  23-May-1996 JonPa
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "verpriv.h"
#include <memory.h>

#define DWORDUP(x) (((x)+3)&~03)

typedef struct tagVERBLOCK {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;
    WCHAR szKey[1];
} VERBLOCK ;

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


typedef struct tagVERBLOCK16 {
    WORD wTotLen;
    WORD wValLen;
    CHAR szKey[1];
} VERBLOCK16 ;

typedef struct tagVERHEAD16 {
    WORD wTotLen;
    WORD wValLen;
    CHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;      // same as win31
} VERHEAD16 ;

DWORD VER2_SIG='X2EF';


extern WCHAR szTrans[];

// function resides in this file
extern LPSTR WINAPI VerCharNextA(LPCSTR lpCurrentChar);

/* ----- Functions ----- */
DWORD
MyExtractVersionResource16W (
    LPCWSTR  lpwstrFilename,
    LPHANDLE hVerRes
    )
{
    DWORD dwTemp = 0;
    DWORD (__stdcall *pExtractVersionResource16W)(LPCWSTR, LPHANDLE);
    HINSTANCE hShell32 = LoadLibraryW(L"shell32.dll");

    if (hShell32) {
        pExtractVersionResource16W = (DWORD(__stdcall *)(LPCWSTR, LPHANDLE))
                                     GetProcAddress(hShell32, "ExtractVersionResource16W");
        if (pExtractVersionResource16W) {
            dwTemp = pExtractVersionResource16W( lpwstrFilename, hVerRes );
        } else {
            dwTemp = 0;
        }
        FreeLibrary(hShell32);
    }
    return dwTemp;
}


/* GetFileVersionInfoSize
 * Gets the size of the version information; notice this is quick
 * and dirty, and the handle is just the offset
 *
 * Returns size of version info in bytes
 * lpwstrFilename is the name of the file to get version information from
 * lpdwHandle is outdated for the Win32 api and is set to zero.
 */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
                       LPWSTR lpwstrFilename,
                       LPDWORD lpdwHandle
                       )
{
    DWORD dwTemp;
    VERHEAD *pVerHead;
    HANDLE hMod;
    HANDLE hVerRes;
    HANDLE h;
    DWORD dwError;

    if (lpdwHandle != NULL)
        *lpdwHandle = 0;

    dwTemp = SetErrorMode(SEM_FAILCRITICALERRORS);
    hMod = LoadLibraryEx(lpwstrFilename, NULL, LOAD_LIBRARY_AS_DATAFILE);
    SetErrorMode(dwTemp);

    pVerHead = NULL;
    if (!hMod) {
        hVerRes = NULL;
        __try
        {
            dwTemp = MyExtractVersionResource16W( lpwstrFilename, &hVerRes );

            if (!dwTemp) {
                dwError = ERROR_RESOURCE_DATA_NOT_FOUND;
                __leave;
            }

            if (!(pVerHead = GlobalLock(hVerRes)) || (pVerHead->wTotLen > dwTemp)) {
                dwError = ERROR_INVALID_DATA;
                dwTemp = 0;
                __leave;
            }

            dwError = ERROR_SUCCESS;

        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0 ;
        }

        if (pVerHead)
            GlobalUnlock(hVerRes);

        if (hVerRes)
            GlobalFree(hVerRes);

        SetLastError(dwError);

        return dwTemp ? dwTemp * 3 : 0;     // 3x == 1x for ansi input, 2x for unicode convert space
    }

    __try {
        dwError = ERROR_SUCCESS;
        if ((hVerRes = FindResource(hMod, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO)) == NULL) {
            dwError = ERROR_RESOURCE_TYPE_NOT_FOUND;
            dwTemp = 0;
            __leave;
        }

        if ((dwTemp=SizeofResource(hMod, hVerRes)) == 0) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }

        if ((h = LoadResource(hMod, hVerRes)) == NULL) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }

        if ((pVerHead = (VERHEAD*)LockResource(h)) == NULL) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }

        if ((DWORD)pVerHead->wTotLen > dwTemp) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }

        dwTemp = (DWORD)pVerHead->wTotLen;

        dwTemp = DWORDUP(dwTemp);

        if (pVerHead->vsf.dwSignature != VS_FFI_SIGNATURE) {
            dwError = ERROR_INVALID_DATA;
            dwTemp = 0;
            __leave;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
        dwTemp = 0;
    }

    if (pVerHead)
        UnlockResource(h);

    FreeLibrary(hMod);

    SetLastError(dwError);

    //
    // dwTemp should be evenly divisible by two since not single
    // byte components at all (also DWORDUP for safety above):
    // alloc space for ansi components
    //

    //
    // Keep space for DBCS chars.
    //
    return dwTemp ? (dwTemp * 2) + sizeof(VER2_SIG) : 0;
}


/* GetFileVersionInfo
 * Gets the version information; fills in the structure up to
 * the size specified by the dwLen parameter (since Control Panel
 * only cares about the version numbers, it won't even call
 * GetFileVersionInfoSize).  Notice this is quick and dirty
 * version, and dwHandle is just the offset (or NULL).
 *
 * lpwstrFilename is the name of the file to get version information from.
 * dwHandle is the handle filled in from the GetFileVersionInfoSize call.
 * dwLen is the length of the buffer to fill.
 * lpData is the buffer to fill.
 */
BOOL
APIENTRY
GetFileVersionInfoW(
                   LPWSTR lpwstrFilename,
                   DWORD dwHandle,
                   DWORD dwLen,
                   LPVOID lpData
                   )
{
    VERHEAD *pVerHead;
    VERHEAD16 *pVerHead16;
    HANDLE hMod;
    HANDLE hVerRes;
    HANDLE h;
    UINT   dwTemp;
    BOOL bTruncate, rc;
    DWORD dwError;

    UNREFERENCED_PARAMETER(dwHandle);

    // Check minimum size to prevent access violations

    // WORD for the VERHEAD wTotLen field
    if (dwLen < sizeof(WORD)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (FALSE);
    }

    dwTemp = SetErrorMode(SEM_FAILCRITICALERRORS);
    hMod = LoadLibraryEx(lpwstrFilename, NULL, LOAD_LIBRARY_AS_DATAFILE);
    SetErrorMode(dwTemp);

    if (hMod == NULL) {

        // Allow 16bit stuff

        __try {
            dwTemp = MyExtractVersionResource16W( lpwstrFilename, &hVerRes );
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            dwTemp = 0 ;
        }

        if (!dwTemp) {
            SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
            return (FALSE);
        }

        if (!(pVerHead16 = GlobalLock(hVerRes))) {

            SetLastError(ERROR_INVALID_DATA);
            GlobalFree(hVerRes);
            return (FALSE);
        }

        __try {
            dwTemp = (DWORD)pVerHead16->wTotLen;

            if (dwTemp > dwLen / 3) {

                //
                // We are forced to truncate.
                //
                dwTemp = dwLen/3;

                bTruncate = TRUE;

            } else {

                bTruncate = FALSE;
            }

            // Now mem copy only the real size of the resource.  (We alloced
            // extra space for unicode)

            memcpy((PVOID)lpData, (PVOID)pVerHead16, dwTemp);
            if (bTruncate) {

                // If we truncated above, then we must set the new
                // size of the block so that we don't overtraverse.

                ((VERHEAD16*)lpData)->wTotLen = (WORD)dwTemp;
            }
            rc = TRUE;
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            rc = FALSE;
        }

        GlobalUnlock(hVerRes);
        GlobalFree(hVerRes);
        
        SetLastError(rc ? ERROR_INVALID_DATA : ERROR_SUCCESS);

        return rc;
    }

    rc = TRUE;
    dwError = ERROR_SUCCESS;
    if (((hVerRes = FindResource(hMod, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO)) == NULL) ||
        ((pVerHead = LoadResource(hMod, hVerRes)) == NULL)) 
    {
        dwError = ERROR_RESOURCE_TYPE_NOT_FOUND;
        rc = FALSE;
    } else {
        __try {
            dwTemp = (DWORD)pVerHead->wTotLen;

            if (dwTemp > (dwLen - sizeof(VER2_SIG)) / 2) {

                // We are forced to truncate.

                //
                // dwLen = UnicodeBuffer + AnsiBuffer.
                //
                // if we try to "memcpy" with "(dwLen/3) * 2" size, pVerHead
                // might not have such a big data...
                //
                dwTemp = (dwLen - sizeof(VER2_SIG)) / 2;

                bTruncate = TRUE;
            } else {
                bTruncate = FALSE;
            }

            // Now mem copy only the real size of the resource.  (We alloced
            // extra space for ansi)

            memcpy((PVOID)lpData, (PVOID)pVerHead, dwTemp);

            // Store a sig between the raw data and the ANSI translation area so we know
            // how much space we have available in VerQuery for ANSI translation.
            *((DWORD UNALIGNED *)((ULONG_PTR)lpData + dwTemp)) = VER2_SIG;
            if (bTruncate) {
                // If we truncated above, then we must set the new
                // size of the block so that we don't overtraverse.

                ((VERHEAD*)lpData)->wTotLen = (WORD)dwTemp;
            }

            rc = TRUE;
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            dwError = ERROR_INVALID_DATA;
            rc = FALSE;
        }
    }

    FreeLibrary(hMod);

    SetLastError(dwError);

    return (rc);
}


BOOL
VerpQueryValue16(
                const LPVOID pb,
                LPVOID lpSubBlockX,
                INT    nIndex,
                LPVOID *lplpKey,
                LPVOID *lplpBuffer,
                PUINT puLen,
                BOOL    bUnicodeNeeded
                )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    LPSTR lpSubBlock;
    LPSTR lpSubBlockOrg;
    NTSTATUS Status;
    UINT uLen;

    VERBLOCK16 *pBlock = (VERBLOCK16*)pb;
    LPSTR lpStart, lpEndBlock, lpEndSubBlock;
    CHAR cTemp, cEndBlock;
    BOOL bLastSpec;
    DWORD dwHeadLen, dwTotBlockLen;
    INT  nCmp;
    DWORD LastError = ERROR_SUCCESS;

    BOOL bThunkNeeded;

    /*
     * If needs unicode, then we must thunk the input parameter
     * to ansi.  If it's ansi already, we make a copy so we can
     * modify it.
     */

    if (bUnicodeNeeded) {

        //
        // Thunk is not needed if lpSubBlockX == \VarFileInfo\Translation
        // or if lpSubBlockX == \
        //
        bThunkNeeded = (BOOL)((*(LPTSTR)lpSubBlockX != 0) &&
                              (lstrcmp(lpSubBlockX, TEXT("\\")) != 0) &&
                              (lstrcmpi(lpSubBlockX, szTrans) != 0));

        RtlInitUnicodeString(&UnicodeString, lpSubBlockX);
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

        if (!NT_SUCCESS(Status)) {
            SetLastError(Status);
            return FALSE;
        }
        lpSubBlock = AnsiString.Buffer;

    } else {
        lpSubBlockOrg = (LPSTR)LocalAlloc(LPTR,(lstrlenA(lpSubBlockX)+1)*sizeof(CHAR));
        if (lpSubBlockOrg == NULL ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        lstrcpyA(lpSubBlockOrg,lpSubBlockX);
        lpSubBlock = lpSubBlockOrg;
    }

    if (!puLen)
        puLen = &uLen;

    *puLen = 0;

    /* Ensure that the total length is less than 32K but greater than the
     * size of a block header; we will assume that the size of pBlock is at
     * least the value of this first INT.
     */
    if ((INT)pBlock->wTotLen < sizeof(VERBLOCK16)) {
        LastError = ERROR_INVALID_DATA;
        goto Fail;
    }

    /*
     * Put a '\0' at the end of the block so that none of the lstrlen's will
     * go past then end of the block.  We will replace it before returning.
     */
    lpEndBlock = ((LPSTR)pBlock) + pBlock->wTotLen - 1;
    cEndBlock = *lpEndBlock;
    *lpEndBlock = '\0';

    bLastSpec = FALSE;

    while ((*lpSubBlock || nIndex != -1)) {
        //
        // Ignore leading '\\'s
        //
        while (*lpSubBlock == '\\')
            ++lpSubBlock;

        if ((*lpSubBlock || nIndex != -1)) {
            /* Make sure we still have some of the block left to play with
             */
            dwTotBlockLen = (DWORD)(lpEndBlock - ((LPSTR)pBlock) + 1);
            if ((INT)dwTotBlockLen<sizeof(VERBLOCK16) ||
                pBlock->wTotLen>dwTotBlockLen)

                goto NotFound;

            /* Calculate the length of the "header" (the two length WORDs plus
             * the identifying string) and skip past the value
             */

            dwHeadLen = sizeof(WORD)*2 + DWORDUP(lstrlenA(pBlock->szKey)+1)
                        + DWORDUP(pBlock->wValLen);

            if (dwHeadLen > pBlock->wTotLen)
                goto NotFound;
            lpEndSubBlock = ((LPSTR)pBlock) + pBlock->wTotLen;
            pBlock = (VERBLOCK16 FAR *)((LPSTR)pBlock+dwHeadLen);

            /* Look for the first sub-block name and terminate it
             */
            for (lpStart=lpSubBlock; *lpSubBlock && *lpSubBlock!='\\';
                lpSubBlock=VerCharNextA(lpSubBlock))
                /* find next '\\' */ ;
            cTemp = *lpSubBlock;
            *lpSubBlock = '\0';

            /* Continue while there are sub-blocks left
             * pBlock->wTotLen should always be a valid pointer here because
             * we have validated dwHeadLen above, and we validated the previous
             * value of pBlock->wTotLen before using it
             */

            nCmp = 1;
            while ((INT)pBlock->wTotLen>sizeof(VERBLOCK16) &&
                   (INT)(lpEndSubBlock-((LPSTR)pBlock))>=(INT)pBlock->wTotLen) {

                //
                // Index functionality: if we are at the end of the path
                // (cTemp == 0 set below) and nIndex is NOT -1 (index search)
                // then break on nIndex zero.  Else do normal wscicmp.
                //
                if (bLastSpec && nIndex != -1) {

                    if (!nIndex) {

                        if (lplpKey) {
                            *lplpKey = pBlock->szKey;
                        }
                        nCmp=0;

                        //
                        // Index found, set nInde to -1
                        // so that we exit this loop
                        //
                        nIndex = -1;
                        break;
                    }

                    nIndex--;

                } else {

                    //
                    // Check if the sub-block name is what we are looking for
                    //

                    if (!(nCmp=lstrcmpiA(lpStart, pBlock->szKey)))
                        break;
                }

                /* Skip to the next sub-block
                 */
                pBlock=(VERBLOCK16 FAR *)((LPSTR)pBlock+DWORDUP(pBlock->wTotLen));
            }

            /* Restore the char NULLed above and return failure if the sub-block
             * was not found
             */
            *lpSubBlock = cTemp;
            if (nCmp)
                goto NotFound;
        }
        bLastSpec = !cTemp;
    }

    /* Fill in the appropriate buffers and return success
     */
    *puLen = pBlock->wValLen;

    *lplpBuffer = (LPSTR)pBlock + 4 + DWORDUP(lstrlenA(pBlock->szKey) + 1);

    //
    // Shouldn't need zero-length value check since win31 compatible.
    //

    *lpEndBlock = cEndBlock;

    /*
     * Must free string we allocated above
     */

    if (bUnicodeNeeded) {
        RtlFreeAnsiString(&AnsiString);
    } else {
        LocalFree(lpSubBlockOrg);
    }


    /*----------------------------------------------------------------------
     * thunk the results
     *
     * Must always thunk key, always ??? value
     *
     * We have no way of knowing if the resource info is binary or strings
     * Version stuff is usually string info, so thunk.
     *
     * The best we can do is assume that everything is a string UNLESS
     * we are looking at \VarFileInfo\Translation or at \.
     *
     * This is acceptable because the documenation of VerQueryValue
     * indicates that this is used only for strings (except these cases.)
     *----------------------------------------------------------------------*/

    if (bUnicodeNeeded) {

        //
        // Do thunk only if we aren't looking for \VarFileInfo\Translation or \
        //
        if (bThunkNeeded) {

            // subtract 1 since puLen includes null
            AnsiString.Length = AnsiString.MaximumLength = (SHORT)*puLen - 1;
            AnsiString.Buffer = *lplpBuffer;

            //
            // Do the string conversion in the second half of the buffer
            // Assumes wTotLen is first filed in VERHEAD
            //
            UnicodeString.Buffer = (LPWSTR)((PBYTE)pb + DWORDUP(*((WORD*)pb)) +
                                            (DWORD)((PBYTE)*lplpBuffer - (PBYTE)pb)*2);

            UnicodeString.MaximumLength = (SHORT)(*puLen * sizeof(WCHAR));
            RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, FALSE);

            *lplpBuffer = UnicodeString.Buffer;
        }

        if (lplpKey) {

            //
            // Thunk the key
            //

            dwHeadLen = lstrlenA(*lplpKey);
            AnsiString.Length = AnsiString.MaximumLength = (SHORT)dwHeadLen;
            AnsiString.Buffer = *lplpKey;

            UnicodeString.Buffer = (LPWSTR) ((PBYTE)pb + DWORDUP(*((WORD*)pb)) +
                                             (DWORD)((PBYTE)*lplpKey - (PBYTE)pb)*2);

            UnicodeString.MaximumLength = (SHORT)((dwHeadLen+1) * sizeof(WCHAR));
            RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, FALSE);

            *lplpKey = UnicodeString.Buffer;
        }
    }

    SetLastError(LastError);

    return (TRUE);



NotFound:

    /* Restore the char we NULLed above
     */
    *lpEndBlock = cEndBlock;
    LastError = ERROR_RESOURCE_TYPE_NOT_FOUND;

Fail:

    if (bUnicodeNeeded) {
        RtlFreeAnsiString(&AnsiString);
    } else {
        LocalFree(lpSubBlockOrg);
    }

    SetLastError(LastError);

    return (FALSE);
}



/* VerpQueryValue
 * Given a pointer to a branch of a version info tree and the name of a
 * sub-branch (as in "sub\subsub\subsubsub\..."), this fills in a pointer
 * to the specified value and a word for its length.  Returns TRUE on success,
 * FALSE on failure.
 *
 * Note that a subblock name may start with a '\\', but it will be ignored.
 * To get the value of the current block, use lpSubBlock=""
 */
BOOL
APIENTRY
VerpQueryValue(
              const LPVOID pb,
              LPVOID lpSubBlockX,    // can be ansi or unicode
              INT    nIndex,
              LPVOID *lplpKey,
              LPVOID *lplpBuffer,
              PUINT puLen,
              BOOL    bUnicodeNeeded
              )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    LPWSTR lpSubBlockOrg;
    LPWSTR lpSubBlock;
    NTSTATUS Status;

    VERBLOCK *pBlock = (PVOID)pb;
    LPWSTR lpStart, lpEndBlock, lpEndSubBlock;
    WCHAR cTemp, cEndBlock;
    DWORD dwHeadLen, dwTotBlockLen;
    BOOL bLastSpec;
    INT nCmp;
    BOOL bString;
    UINT uLen;
    DWORD LastError = ERROR_SUCCESS;

    if (!puLen) {
        puLen = &uLen;
    }

    *puLen = 0;

    /*
     * Major hack: wType is 0 for win32 versions, but holds 56 ('V')
     * for win16.
     */

    if (((VERHEAD*)pb)->wType)
        return VerpQueryValue16(pb,
                                lpSubBlockX,
                                nIndex,
                                lplpKey,
                                lplpBuffer,
                                puLen,
                                bUnicodeNeeded);

    /*
     * If doesnt need unicode, then we must thunk the input parameter
     * to unicode.
     */

    if (!bUnicodeNeeded) {

        RtlInitAnsiString(&AnsiString, (LPSTR)lpSubBlockX);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

        if (!NT_SUCCESS(Status)) {
            SetLastError(Status);
            return FALSE;
        }
        lpSubBlock = UnicodeString.Buffer;

    } else {
        lpSubBlockOrg = (LPWSTR)LocalAlloc(LPTR,(lstrlen(lpSubBlockX)+1)*sizeof(WCHAR));
        if (lpSubBlockOrg == NULL ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        lstrcpy(lpSubBlockOrg,lpSubBlockX);
        lpSubBlock = lpSubBlockOrg;
    }



    /* Ensure that the total length is less than 32K but greater than the
     * size of a block header; we will assume that the size of pBlock is at
     * least the value of this first int.
     * Put a '\0' at the end of the block so that none of the wcslen's will
     * go past then end of the block.  We will replace it before returning.
     */
    if ((int)pBlock->wTotLen < sizeof(VERBLOCK)) {
        LastError = ERROR_INVALID_DATA;
        goto Fail;
    }

    lpEndBlock = (LPWSTR)((LPSTR)pBlock + pBlock->wTotLen - sizeof(WCHAR));
    cEndBlock = *lpEndBlock;
    *lpEndBlock = 0;
    bString = FALSE;
    bLastSpec = FALSE;

    while ((*lpSubBlock || nIndex != -1)) {
        //
        // Ignore leading '\\'s
        //
        while (*lpSubBlock == TEXT('\\'))
            ++lpSubBlock;

        if ((*lpSubBlock || nIndex != -1)) {
            /* Make sure we still have some of the block left to play with
             */
            dwTotBlockLen = (DWORD)((LPSTR)lpEndBlock - (LPSTR)pBlock + sizeof(WCHAR));
            if ((int)dwTotBlockLen < sizeof(VERBLOCK) ||
                pBlock->wTotLen > (WORD)dwTotBlockLen)
                goto NotFound;

            /* Calculate the length of the "header" (the two length WORDs plus
             * the data type flag plus the identifying string) and skip
             * past the value.
             */
            dwHeadLen = (DWORD)(DWORDUP(sizeof(VERBLOCK) - sizeof(WCHAR) +
                                (wcslen(pBlock->szKey) + 1) * sizeof(WCHAR)) +
                        DWORDUP(pBlock->wValLen));
            if (dwHeadLen > pBlock->wTotLen)
                goto NotFound;
            lpEndSubBlock = (LPWSTR)((LPSTR)pBlock + pBlock->wTotLen);
            pBlock = (VERBLOCK*)((LPSTR)pBlock+dwHeadLen);

            /* Look for the first sub-block name and terminate it
             */
            for (lpStart=lpSubBlock; *lpSubBlock && *lpSubBlock!=TEXT('\\');
                lpSubBlock++)
                /* find next '\\' */ ;
            cTemp = *lpSubBlock;
            *lpSubBlock = 0;

            /* Continue while there are sub-blocks left
             * pBlock->wTotLen should always be a valid pointer here because
             * we have validated dwHeadLen above, and we validated the previous
             * value of pBlock->wTotLen before using it
             */
            nCmp = 1;
            while ((int)pBlock->wTotLen > sizeof(VERBLOCK) &&
                   (int)pBlock->wTotLen <= (LPSTR)lpEndSubBlock-(LPSTR)pBlock) {

                //
                // Index functionality: if we are at the end of the path
                // (cTemp == 0 set below) and nIndex is NOT -1 (index search)
                // then break on nIndex zero.  Else do normal wscicmp.
                //
                if (bLastSpec && nIndex != -1) {

                    if (!nIndex) {

                        if (lplpKey) {
                            *lplpKey = pBlock->szKey;
                        }
                        nCmp=0;

                        //
                        // Index found, set nInde to -1
                        // so that we exit this loop
                        //
                        nIndex = -1;
                        break;
                    }

                    nIndex--;

                } else {

                    //
                    // Check if the sub-block name is what we are looking for
                    //

                    if (!(nCmp=_wcsicmp(lpStart, pBlock->szKey)))
                        break;
                }

                /* Skip to the next sub-block
                 */
                pBlock=(VERBLOCK*)((LPSTR)pBlock+DWORDUP(pBlock->wTotLen));
            }

            /* Restore the char NULLed above and return failure if the sub-block
             * was not found
             */
            *lpSubBlock = cTemp;
            if (nCmp)
                goto NotFound;
        }
        bLastSpec = !cTemp;
    }

    /* Fill in the appropriate buffers and return success
     */

    *puLen = pBlock->wValLen;

    /* Add code to handle the case of a null value.
     *
     * If zero-len, then return the pointer to the null terminator
     * of the key.  Remember that this is thunked in the ansi case.
     *
     * We can't just look at pBlock->wValLen.  Check if it really is
     * zero-len by seeing if the end of the key string is the end of the
     * block (i.e., the val string is outside of the current block).
     */

    lpStart = (LPWSTR)((LPSTR)pBlock+DWORDUP((sizeof(VERBLOCK)-sizeof(WCHAR))+
                                             (wcslen(pBlock->szKey)+1)*sizeof(WCHAR)));

    *lplpBuffer = lpStart < (LPWSTR)((LPBYTE)pBlock+pBlock->wTotLen) ?
                  lpStart :
                  (LPWSTR)(pBlock->szKey+wcslen(pBlock->szKey));

    bString = pBlock->wType;

    *lpEndBlock = cEndBlock;

    /*
     * Must free string we allocated above
     */

    if (!bUnicodeNeeded) {
        RtlFreeUnicodeString(&UnicodeString);
    } else {
        LocalFree(lpSubBlockOrg);
    }

    /*----------------------------------------------------------------------
     * thunk the results
     *
     * Must always thunk key, sometimes (if bString true) value
     *----------------------------------------------------------------------*/

    if (!bUnicodeNeeded) {

        // See if we're looking at a V1 or a V2 input block so we know how much space we
        // have for decoding the strings.
        BOOL fV2 = *(PDWORD)((PBYTE)pb + DWORDUP(*((WORD*)pb))) == VER2_SIG ? TRUE : FALSE;

        DWORD cbAnsiTranslateBuffer;
        if (fV2) {
            cbAnsiTranslateBuffer = DWORDUP(*((WORD *)pb));
        } else {
            cbAnsiTranslateBuffer = DWORDUP(*((WORD *)pb)) / 2;
        }

        if (bString && *puLen != 0) {
            DWORD cb, cb2;

            //
            // Must multiply length by two (first subtract 1 since puLen includes the null terminator)
            //
            UnicodeString.Length = UnicodeString.MaximumLength = (SHORT)((*puLen - 1) * 2);
            UnicodeString.Buffer = *lplpBuffer;

            //
            // Do the string conversion in the second half of the buffer
            // Assumes wTotLen is first filed in VERHEAD
            //

            // cb = offset in buffer to beginning of string
            cb = (DWORD)((PBYTE)*lplpBuffer - (PBYTE)pb);

            // cb2 = offset in translation area for this string
            if (fV2) {
                cb2 = cb + sizeof(VER2_SIG);
            } else {
                cb2 = cb / 2;
            }

            AnsiString.Buffer = (PBYTE)pb + DWORDUP(*((WORD*)pb)) + cb2;

            AnsiString.MaximumLength = (USHORT)RtlUnicodeStringToAnsiSize(&UnicodeString);
            if ( AnsiString.MaximumLength > MAXUSHORT ) {
                LastError = ERROR_INVALID_DATA;
                goto Fail;
            }

            AnsiString.MaximumLength = (USHORT)(__min((DWORD)AnsiString.MaximumLength,
                                                      (DWORD)(cbAnsiTranslateBuffer-cb2)));

            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

            *lplpBuffer = AnsiString.Buffer;
            *puLen = AnsiString.Length + 1;

        }

        if (lplpKey) {

            DWORD cb, cb2;

            //
            // Thunk the key
            //
            dwHeadLen = wcslen(*lplpKey);
            UnicodeString.Length = UnicodeString.MaximumLength = (SHORT)(dwHeadLen * sizeof(WCHAR));
            UnicodeString.Buffer = *lplpKey;

            // cb2 = offset in translation area for this string

            cb = (DWORD)((PBYTE)*lplpKey - (PBYTE)pb);
            if (fV2) {
                cb2 = cb + sizeof(VER2_SIG);
            } else {
                cb2 = cb / 2;
            }

            AnsiString.Buffer = (PBYTE)pb + DWORDUP(*((WORD*)pb)) + cb2;

            AnsiString.MaximumLength = (USHORT)RtlUnicodeStringToAnsiSize(&UnicodeString);
            if ( AnsiString.MaximumLength > MAXUSHORT ) {
                LastError = ERROR_INVALID_DATA;
                goto Fail;
            }

            AnsiString.MaximumLength = (USHORT)(__min((DWORD)AnsiString.MaximumLength,
                                                      (DWORD)(cbAnsiTranslateBuffer-cb2)));
            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

            *lplpKey = AnsiString.Buffer;
            *puLen = AnsiString.Length+1;
        }
    }

    SetLastError(LastError);

    return (TRUE);


NotFound:
    /* Restore the char we NULLed above
     */
    *lpEndBlock = cEndBlock;
    LastError = ERROR_RESOURCE_TYPE_NOT_FOUND;

Fail:

    if (!bUnicodeNeeded) {
        RtlFreeUnicodeString(&UnicodeString);
    } else {
        LocalFree(lpSubBlockOrg);
    }

    SetLastError(LastError);

    return (FALSE);
}

//////////////////////////////////////////////////////////
//
// This is an EXACT replica of CharNextA api found in user
// it is here so that we won't have to link to user32

LPSTR WINAPI VerCharNextA(
    LPCSTR lpCurrentChar)
{
    if ((!!NLS_MB_CODE_PAGE_TAG) && IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point to string-terminator
     */

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\ifhelp.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "verpriv.h"
#include "wchar.h"

/* Determine if a file is in use by Windows
 */
BOOL FileInUse(LPWSTR lpszFilePath, LPWSTR lpszFileName)
{
    HANDLE hFile;
    BOOL bResult = FALSE;

    //
    // Attempt to open the file exclusively.
    //

    hFile = CreateFile(lpszFilePath,
                       GENERIC_WRITE | GENERIC_READ,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {

        //
        // If the last error is access denied,
        // then the file is in use by someone
        // else.  Return TRUE in this case.
        //

        if (GetLastError() == ERROR_SHARING_VIOLATION)
            bResult = TRUE;

    } else {

        //
        // CreateFile successfully opened the file.
        // Close the handle and return FALSE.
        //

        CloseHandle(hFile);
    }

    return bResult;
}


/* Take a Dir and Filename and make a full path from them
 */
DWORD MakeFileName(LPWSTR lpDst, LPWSTR lpDir, LPWSTR lpFile, int cchDst)
{
  DWORD wDirLen;
  WCHAR cTemp;

  wcsncpy(lpDst, lpDir, cchDst);
  lpDst[cchDst-1] = TEXT('\0');
  wDirLen=wcslen(lpDst);

  if ( wDirLen && (cTemp=*(lpDst+wDirLen-1))!=TEXT('\\') && cTemp!=TEXT(':'))
      lpDst[wDirLen++] = TEXT('\\');

  wcsncpy(lpDst+wDirLen, lpFile, cchDst - wDirLen);
  lpDst[cchDst-1] = TEXT('\0');

  return(wDirLen);
}


/* Given a filename and a list of directories, find the first directory
 * that contains the file, and copy it into the buffer.  Note that in the
 * library version, you can give an environment style path, but not in the
 * DLL version.
 */
INT
GetDirOfFile(LPWSTR lpszFileName,
    LPWSTR lpszPathName,
    DWORD wSize,
    LPWSTR *lplpszDirs)
{
  WCHAR szFileName[_MAX_PATH];
  HANDLE hfRes;
  INT nFileLen = 0;
  INT nPathLen = 0;
  BOOL bDoDefaultOpen = TRUE;
  LPWSTR *lplpFirstDir;
  LPWSTR lpszDir;

  nFileLen = wcslen(lpszFileName);

  for (lplpFirstDir=lplpszDirs; *lplpFirstDir && bDoDefaultOpen;
        ++lplpFirstDir)
    {
      lpszDir = *lplpFirstDir;

      if (nFileLen+wcslen(lpszDir) >= _MAX_PATH-1)
          continue;
      MakeFileName(szFileName, lpszDir, lpszFileName, ARRAYSIZE(szFileName));

TryOpen:
    nPathLen = 0;  // Re-init for this path.

    if ((hfRes = CreateFile(szFileName, GENERIC_READ,
            FILE_SHARE_READ, NULL, OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN, NULL)) != (HANDLE)-1)
        {
          CloseHandle(hfRes);
          for (lpszDir=szFileName; *lpszDir; lpszDir++)
              if (*lpszDir == TEXT('\\'))
                  nPathLen = (INT)(lpszDir - (LPWSTR)szFileName);

          /* This gets rid of the '\' if this is not the root of a drive
           */
          if (nPathLen <= 3)
              ++nPathLen;

          /* Account for the terminating NULL, and make sure wSize is in bounds
           * then NULL terminate the string in the appropriate place so that
           * we can just do an wcscpy.
           */
          --wSize;
          szFileName[(int)wSize<nPathLen ? wSize : nPathLen] = 0;
          wcscpy(lpszPathName, szFileName);

          return(nPathLen);
        }
    }

  if (bDoDefaultOpen)
    {
      bDoDefaultOpen = FALSE;
      wcscpy(szFileName, lpszFileName);
      goto TryOpen;
    }

  return(0);
}


#define GetWindowsDir(x,y,z) GetWindowsDirectory(y,z)
#define GetSystemDir(x,y,z) GetSystemDirectory(y,z)


DWORD
APIENTRY
VerFindFileW(
        DWORD wFlags,
        LPWSTR lpszFileName,
        LPWSTR lpszWinDir,
        LPWSTR lpszAppDir,
        LPWSTR lpszCurDir,
        PUINT puCurDirLen,
        LPWSTR lpszDestDir,
        PUINT puDestDirLen
        )
{
  static WORD wSharedDirLen = 0;
  static WCHAR gszSharedDir[_MAX_PATH];

  WCHAR szSysDir[_MAX_PATH], cTemp;
  WCHAR szWinDir[_MAX_PATH];
  WCHAR szCurDir[_MAX_PATH];
  LPWSTR lpszDir, lpszDirs[4];
  WORD wDestLen, wWinLen, wRetVal = 0, wTemp;
  int nRet;

#ifdef WX86
  //  Save a copy of the 'from Wx86' flag and clear it.
  BOOLEAN UseKnownWx86Dll = NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll;
  NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
#endif

  /* We want to really look in the Windows directory; we don't trust the app
   */
  GetWindowsDir(lpszWinDir ? lpszWinDir : "", szWinDir, _MAX_PATH);
  lpszWinDir = szWinDir;

#ifdef WX86
  NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = UseKnownWx86Dll;
#endif

  if(!GetSystemDir( lpszWinDir, szSysDir, _MAX_PATH))
      wcscpy(szSysDir, lpszWinDir);

#ifdef WX86
  NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
#endif

  if (wFlags & VFFF_ISSHAREDFILE) {
     lpszDirs[0] = lpszWinDir;
     lpszDirs[1] = szSysDir;
     lpszDirs[2] = lpszAppDir;
  } else {
     lpszDirs[0] = lpszAppDir;
     lpszDirs[1] = lpszWinDir;
     lpszDirs[2] = szSysDir;
  }

  lpszDirs[3] = NULL;

  if (!(wTemp=(WORD)GetDirOfFile(lpszFileName, szCurDir, _MAX_PATH, lpszDirs)))
      *szCurDir = 0;
  if (*puCurDirLen > wTemp)
      wcscpy(lpszCurDir, szCurDir);
  else
      wRetVal |= VFF_BUFFTOOSMALL;
  *puCurDirLen = wTemp + 1;

  if (lpszDestDir)
    {
      if (wFlags & VFFF_ISSHAREDFILE)
        {
          if (!wSharedDirLen)
            {
              if ((wWinLen = (WORD)wcslen(lpszWinDir)) &&
                    *(lpszWinDir-1)==TEXT('\\'))
                {
                  if (szSysDir[wWinLen-1] == TEXT('\\'))
                      goto doCompare;
                }
              else if (szSysDir[wWinLen] == TEXT('\\'))
                {
doCompare:
                  cTemp = szSysDir[wWinLen];
                  szSysDir[wWinLen] = 0;
                  nRet = _wcsicmp(lpszWinDir, szSysDir);
                  szSysDir[wWinLen] = cTemp;
                  if(nRet)
                      goto doCopyWinDir;
                  wcscpy(gszSharedDir, szSysDir);
                }
              else
                {
doCopyWinDir:
                  wcscpy(gszSharedDir, lpszWinDir);
                }
              wSharedDirLen = (WORD)wcslen(gszSharedDir);
            }

          wDestLen = wSharedDirLen;
          lpszDir = gszSharedDir;
        }
      else
        {
          wDestLen = (WORD)wcslen(lpszAppDir);
          lpszDir = lpszAppDir;
        }

      if (*puDestDirLen > wDestLen)
        {
          wcscpy(lpszDestDir, lpszDir);

          if ((wWinLen = (WORD)wcslen(lpszDestDir)) &&
                *(lpszDestDir-1)==TEXT('\\'))
              lpszDestDir[wWinLen-1] = 0;

          if (_wcsicmp(lpszCurDir, lpszDestDir))
              wRetVal |= VFF_CURNEDEST;
        }
      else
          wRetVal |= VFF_BUFFTOOSMALL;
      *puDestDirLen = wDestLen + 1;
    }

  if (*szCurDir)
    {
      MakeFileName(szSysDir, szCurDir, lpszFileName, ARRAYSIZE(szSysDir));
      if (FileInUse(szSysDir, lpszFileName))
          wRetVal |= VFF_FILEINUSE;
    }

  return(wRetVal);
}


/*
 *  DWORD
 *  APIENTRY
 *  VerLanguageNameW(
 *      DWORD wLang,
 *      LPWSTR szLang,
 *      DWORD wSize)
 *
 *  This routine was moved to NLSLIB.LIB so that it uses the WINNLS.RC file.
 *  NLSLIB.LIB is part of KERNEL32.DLL.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\ansi.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "verpriv.h"

#define DWORDUP(x) (((x)+3) & ~3)
DWORD
APIENTRY
VerFindFileA(
        DWORD wFlags,
        LPSTR lpszFileName,
        LPSTR lpszWinDir,
        LPSTR lpszAppDir,
        LPSTR lpszCurDir,
        PUINT puCurDirLen,
        LPSTR lpszDestDir,
        PUINT puDestDirLen
        )
{
    UNICODE_STRING FileName;
    UNICODE_STRING WinDir;
    UNICODE_STRING AppDir;
    UNICODE_STRING CurDir;
    UNICODE_STRING DestDir;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD       CurDirLen = (*puCurDirLen) ? (*puCurDirLen) : 1;
    DWORD       DestDirLen = (*puDestDirLen) ? (*puDestDirLen) : 1;

    CurDirLen = min(MAX_PATH, CurDirLen);
    DestDirLen = min(MAX_PATH, DestDirLen);

    RtlInitAnsiString(&AnsiString, lpszFileName);
    Status = RtlAnsiStringToUnicodeString(&FileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        SetLastError(Status);
        return VFF_BUFFTOOSMALL;
    }
    RtlInitAnsiString(&AnsiString, lpszWinDir);
    Status = RtlAnsiStringToUnicodeString(&WinDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&FileName);
        SetLastError(Status);
        return VFF_BUFFTOOSMALL;
    }
    RtlInitAnsiString(&AnsiString, lpszAppDir);
    Status = RtlAnsiStringToUnicodeString(&AppDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&FileName);
        RtlFreeUnicodeString(&WinDir);
        SetLastError(Status);
        return VFF_BUFFTOOSMALL;
    }
    CurDir.MaximumLength = (USHORT)CurDirLen * sizeof(WCHAR);
    CurDir.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, CurDir.MaximumLength);
    if (CurDir.Buffer == NULL) {
        RtlFreeUnicodeString(&FileName);
        RtlFreeUnicodeString(&WinDir);
        RtlFreeUnicodeString(&AppDir);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return VFF_BUFFTOOSMALL;
    }
    DestDir.MaximumLength = (USHORT)DestDirLen * sizeof(WCHAR);
    DestDir.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, DestDir.MaximumLength);
    if (DestDir.Buffer == NULL) {
        RtlFreeUnicodeString(&FileName);
        RtlFreeUnicodeString(&WinDir);
        RtlFreeUnicodeString(&AppDir);
        RtlFreeUnicodeString(&CurDir);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return VFF_BUFFTOOSMALL;
    }
    Status = VerFindFileW(wFlags,
                        FileName.Buffer,
                        WinDir.Buffer,
                        AppDir.Buffer,
                        CurDir.Buffer, &CurDirLen,
                        DestDir.Buffer, &DestDirLen);

    if (Status & VFF_BUFFTOOSMALL) {
        *lpszCurDir = 0;
        *puCurDirLen = CurDirLen;
        *lpszDestDir = 0;
        *puDestDirLen = DestDirLen;
    } else {

        CurDir.Length = (USHORT)(sizeof(WCHAR)*CurDirLen);
        DestDir.Length = (USHORT)(sizeof(WCHAR)*DestDirLen);

        AnsiString.Buffer = lpszCurDir;
        AnsiString.MaximumLength = (USHORT)*puCurDirLen;
        RtlUnicodeStringToAnsiString(&AnsiString, &CurDir, FALSE);
        *puCurDirLen = AnsiString.Length;

        AnsiString.Buffer = lpszDestDir;
        AnsiString.MaximumLength = (USHORT)*puDestDirLen;
        RtlUnicodeStringToAnsiString(&AnsiString, &DestDir, FALSE);
        *puDestDirLen = AnsiString.Length;
    }

    RtlFreeUnicodeString(&FileName);
    RtlFreeUnicodeString(&WinDir);
    RtlFreeUnicodeString(&AppDir);
    RtlFreeUnicodeString(&CurDir);
    RtlFreeUnicodeString(&DestDir);
    return Status;

}

DWORD
APIENTRY
VerInstallFileA(
        DWORD wFlags,
        LPSTR lpszSrcFileName,
        LPSTR lpszDstFileName,
        LPSTR lpszSrcDir,
        LPSTR lpszDstDir,
        LPSTR lpszCurDir,
        LPSTR lpszTmpFile,
        PUINT puTmpFileLen
        )
{
    UNICODE_STRING SrcFileName;
    UNICODE_STRING DstFileName;
    UNICODE_STRING SrcDir;
    UNICODE_STRING CurDir;
    UNICODE_STRING DstDir;
    UNICODE_STRING TmpFile;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD    TmpFileLen = (*puTmpFileLen) ? (*puTmpFileLen) : 1;

    TmpFileLen = min(MAX_PATH, TmpFileLen);

    RtlInitAnsiString(&AnsiString, lpszSrcFileName);
    Status = RtlAnsiStringToUnicodeString(&SrcFileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }
    RtlInitAnsiString(&AnsiString, lpszDstFileName);
    Status = RtlAnsiStringToUnicodeString(&DstFileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }
    RtlInitAnsiString(&AnsiString, lpszSrcDir);
    Status = RtlAnsiStringToUnicodeString(&SrcDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }
    RtlInitAnsiString(&AnsiString, lpszCurDir);
    Status = RtlAnsiStringToUnicodeString(&CurDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        RtlFreeUnicodeString(&SrcDir);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }
    RtlInitAnsiString(&AnsiString, lpszDstDir);
    Status = RtlAnsiStringToUnicodeString(&DstDir, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        RtlFreeUnicodeString(&SrcDir);
        RtlFreeUnicodeString(&CurDir);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }

    RtlInitAnsiString(&AnsiString, lpszTmpFile);

    TmpFile.MaximumLength = (USHORT)(TmpFileLen * sizeof(WCHAR));
    TmpFile.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, TmpFile.MaximumLength);
    if (TmpFile.Buffer == NULL) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        RtlFreeUnicodeString(&SrcDir);
        RtlFreeUnicodeString(&CurDir);
        RtlFreeUnicodeString(&DstDir);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return VIF_OUTOFMEMORY;
    }

    Status = RtlAnsiStringToUnicodeString(&TmpFile, &AnsiString, FALSE);

    if (!NT_SUCCESS(Status)) {
        RtlFreeUnicodeString(&SrcFileName);
        RtlFreeUnicodeString(&DstFileName);
        RtlFreeUnicodeString(&SrcDir);
        RtlFreeUnicodeString(&CurDir);
        RtlFreeUnicodeString(&DstDir);
        RtlFreeUnicodeString(&TmpFile);
        SetLastError(Status);
        return VIF_OUTOFMEMORY;
    }

    Status = VerInstallFileW(wFlags,
                        SrcFileName.Buffer,
                        DstFileName.Buffer,
                        SrcDir.Buffer,
                        DstDir.Buffer,
                        CurDir.Buffer,
                        TmpFile.Buffer, &TmpFileLen);

    if (Status & VIF_BUFFTOOSMALL) {
        //
        // The lpszTmpFile buffer was too small,
        // the TmpFileLen field contains the size necessary.
        //
        *lpszTmpFile = 0;
        *puTmpFileLen = TmpFileLen;

    } else {

        TmpFile.Length = TmpFile.MaximumLength = (USHORT)(TmpFileLen * sizeof(WCHAR));

        AnsiString.Buffer = lpszTmpFile;
        AnsiString.MaximumLength = (USHORT)*puTmpFileLen;
        RtlUnicodeStringToAnsiString(&AnsiString, &TmpFile, FALSE);
        *puTmpFileLen = AnsiString.Length;
    }

    RtlFreeUnicodeString(&SrcFileName);
    RtlFreeUnicodeString(&DstFileName);
    RtlFreeUnicodeString(&SrcDir);
    RtlFreeUnicodeString(&DstDir);
    RtlFreeUnicodeString(&CurDir);
    RtlFreeUnicodeString(&TmpFile);
    return Status;
}

DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lpstrFilename,
        LPDWORD lpdwHandle
        )
{
    UNICODE_STRING FileName;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD dwStatus;

    RtlInitAnsiString(&AnsiString, lpstrFilename);
    Status = RtlAnsiStringToUnicodeString(&FileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        SetLastError(Status);
        return FALSE;
    }

    dwStatus = GetFileVersionInfoSizeW(FileName.Buffer, lpdwHandle);
    RtlFreeUnicodeString(&FileName);
    return dwStatus;
}

BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lpstrFilename,
        DWORD dwHandle,
        DWORD dwLen,
        LPVOID lpData
        )
{
    UNICODE_STRING FileName;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL bStatus;

    RtlInitAnsiString(&AnsiString, lpstrFilename);
    Status = RtlAnsiStringToUnicodeString(&FileName, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {
        SetLastError(Status);
        return FALSE;
    }

    bStatus = GetFileVersionInfoW(FileName.Buffer, dwHandle, dwLen, lpData);
    RtlFreeUnicodeString(&FileName);
    return bStatus;
}


/*
 *  DWORD
 *  APIENTRY
 *  VerLanguageNameA(
 *      DWORD wLang,
 *      LPSTR szLang,
 *      DWORD wSize)
 *
 *  This routine was moved to NLSLIB.LIB so that it uses the WINNLS.RC file.
 *  NLSLIB.LIB is part of KERNEL32.DLL.
 */


BOOL
APIENTRY
VerQueryValueIndexA(
        const LPVOID pb,
        LPSTR lpSubBlock,
        INT    nIndex,
        LPVOID *lplpKey,
        LPVOID *lplpBuffer,
        PUINT puLen
        )
{
   return VerpQueryValue(pb,
                         lpSubBlock,
                         nIndex,
                         lplpKey,
                         lplpBuffer,
                         puLen,
                         FALSE);
}

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pb,
        LPSTR lpSubBlock,
        LPVOID *lplpBuffer,
        PUINT puLen
        )
{
    return VerpQueryValue(pb,
                          lpSubBlock,
                          -1,
                          NULL,
                          lplpBuffer,
                          puLen,
                          FALSE);
}


BOOL
APIENTRY
VerQueryValueW(
        const LPVOID pb,
        LPWSTR lpSubBlock,
        LPVOID *lplpBuffer,
        PUINT puLen
        )
{
    return VerpQueryValue(pb,
                          lpSubBlock,
                          -1,
                          NULL,
                          lplpBuffer,
                          puLen,
                          TRUE);
}


BOOL
APIENTRY
VerQueryValueIndexW(
        const LPVOID pb,
        LPWSTR lpSubBlock,
        INT    nIndex,
        LPVOID *lplpKey,
        LPVOID *lplpBuffer,
        PUINT puLen
        )
{
    return VerpQueryValue(pb,
                          lpSubBlock,
                          nIndex,
                          lplpKey,
                          lplpBuffer,
                          puLen,
                          TRUE);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\instfile.c ===
#include "verpriv.h"
#include <lzexpand.h>
#include "diamondd.h"
#include "mydiam.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
** Prototypes
*/

// For the time being, private APIS exported
INT
LZCreateFileW(
    LPWSTR,
    DWORD,
    DWORD,
    DWORD,
    LPWSTR);

VOID
LZCloseFile(
    INT);


#ifdef __cplusplus
}
#endif


BOOL    FileInUse(LPWSTR lpszFilePath, LPWSTR lpszFileName);
DWORD   MakeFileName(LPWSTR lpDst, LPWSTR lpDir, LPWSTR lpFile, int cchDst);

typedef struct tagVS_VERSION {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;
    WCHAR szSig[16];
    VS_FIXEDFILEINFO vInfo;
} VS_VERSION;

typedef struct tagLANGANDCP {
    WORD wLanguage;
    WORD wCodePage;
} LANGANDCP;

WCHAR szTrans[] = TEXT("\\VarFileInfo\\Translation");
WCHAR szTempHdr[] = TEXT("temp.");


/* The routines in here will find a file on a path, and an environment
 * variable.  The constants _MAX_PATH and need to be defined
 * by the including module, plus the constant WINDOWS should
 * be defined if this is to be used in Windows, so that lstrcmpi
 * and lstrlen will not be compiled
 */


VOID Ver3IToA(LPWSTR lpwStr, int n)
{
    int nShift;
    WCHAR cTemp;

    for (nShift=8; nShift>=0; nShift-=4, ++lpwStr) {
        if ((cTemp = (WCHAR)((n>>nShift)&0x000f)) >= 10)
            *lpwStr = (WCHAR)('A' + cTemp - 10);
        else
            *lpwStr = (WCHAR)('0' + cTemp     );
    }
    *lpwStr = 0;
}


/* Convert a DOS error into an error flag
 */
DWORD FileErrFlag(int err)
{
    switch (err) {
        case 0x05:
            return (VIF_ACCESSVIOLATION);

        case 0x20:
            return (VIF_SHARINGVIOLATION);

        default:
            return (0);
    }
}


/* Create the given file with default flags; global nFileErr will
 * receive any DOS error; returns -1 on error, otherwise the DOS
 * file handle.
 */
HANDLE VerCreateFile(LPWSTR lpszFile)
{
    HANDLE hFile;

    hFile = CreateFile(lpszFile, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ, NULL, CREATE_NEW,
                       FILE_ATTRIBUTE_NORMAL, NULL);

    return (hFile);
}


VOID VerClose(HANDLE hW32File)
{
    CloseHandle(hW32File);
}


#define MyAlloc(x) ((WCHAR *)LocalAlloc(LMEM_FIXED, x))
#define MyFree(x) LocalFree((HANDLE)(x))

LPVOID MyGetFileVersionInfo(LPWSTR lpFileName)
{
    WCHAR *pInfo;
    WORD wLen = 2048;

TryAgain:
    if (!(pInfo=MyAlloc(wLen)))
        goto Error1;
    if (!GetFileVersionInfo(lpFileName, 0L, wLen, pInfo))
        goto Error2;
    if (wLen < *(WORD *)pInfo) {
        wLen = *(WORD *)pInfo;
        MyFree(pInfo);
        goto TryAgain;
    }
    return (pInfo);

Error2:
    MyFree(pInfo);
Error1:
    return (NULL);
}

HINSTANCE hLz32;
DWORD cLz32Load;
typedef INT  (APIENTRY *tLZInit)( INT );
typedef INT  (APIENTRY *tLZOpenFileW)(LPWSTR, LPOFSTRUCT, WORD );
typedef INT  (APIENTRY *tLZCreateFileW)(LPWSTR, DWORD, DWORD, DWORD, LPWSTR);
typedef VOID (APIENTRY *tLZClose)( INT );
typedef VOID (APIENTRY *tLZCloseFile)( INT );
typedef LONG (APIENTRY *tLZCopy)( INT, INT );

tLZInit      pLZInit;
tLZOpenFileW pLZOpenFileW;
tLZCreateFileW pLZCreateFileW;
tLZClose     pLZClose;
tLZCloseFile     pLZCloseFile;
tLZCopy      pLZCopy;

DWORD
APIENTRY
VerInstallFileW(
               DWORD wFlags,
               LPWSTR lpszSrcFileName,
               LPWSTR lpszDstFileName,
               LPWSTR lpszSrcDir,
               LPWSTR lpszDstDir,
               LPWSTR lpszCurDir,
               LPWSTR lpszTmpFile,
               PUINT puTmpFileLen
               )
{
    WCHAR szSrcFile[_MAX_PATH];
    WCHAR szDstFile[_MAX_PATH];
    WCHAR szCurFile[_MAX_PATH];
    DWORD dwRetVal = 0L, dwSrcAttr;
    WORD wDirLen;
    LONG lCopy;
    HANDLE hW32Out;
    int i, fIn, fDosOut;
    WCHAR szCompFile[_MAX_PATH];
    CHAR  szOemFile[_MAX_PATH];
    int   iOemString;
    BOOL  bDefaultCharUsed;
    BOOL DiamondFile;

    if (!cLz32Load) {
        hLz32 = LoadLibraryW(L"LZ32.DLL");
        if (!hLz32) {
            return (VIF_CANNOTLOADLZ32);
        }
        pLZOpenFileW   = (tLZOpenFileW)   GetProcAddress(hLz32, "LZOpenFileW");
        pLZCreateFileW = (tLZCreateFileW) GetProcAddress(hLz32, "LZCreateFileW");
        pLZInit        = (tLZInit)        GetProcAddress(hLz32, "LZInit");
        pLZCopy        = (tLZCopy)        GetProcAddress(hLz32, "LZCopy");
        pLZClose       = (tLZClose)       GetProcAddress(hLz32, "LZClose");
        pLZCloseFile   = (tLZCloseFile)   GetProcAddress(hLz32, "LZCloseFile");
        if (!(pLZOpenFileW && pLZInit && pLZCopy && pLZClose && pLZCreateFileW && pLZCloseFile)) {
            FreeLibrary(hLz32);
            return (VIF_CANNOTLOADLZ32);
        }

        if (InterlockedExchangeAdd(&cLz32Load, 1) != 0) {
            // Multiple threads are attempting to LoadLib
            // Free one here.
            FreeLibrary(hLz32);
        }
    }

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    /* LZ Open the source for reading
     */
    MakeFileName(szSrcFile, lpszSrcDir, lpszSrcFileName, ARRAYSIZE(szSrcFile));
    dwRetVal = InitDiamond();
    if (dwRetVal) {
        return (dwRetVal);
    }
    if((fIn=pLZCreateFileW(szSrcFile, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, szCompFile)) < 0) {
        dwRetVal |= VIF_CANNOTREADSRC;
        goto doReturn;
    }

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

  /*
   * now we don't have any unicode interface for Diamond API. we need to convert
   * it to OEM charset string. we will use the converted string instead of of.szPathName.
   */

   DiamondFile = FALSE;

   iOemString = WideCharToMultiByte( CP_OEMCP,            // Oem Codepage
                                     0,                   // no option flag
                                     szCompFile,          // Unicode string
                                     -1,                  // should be NULL terminated
                                     szOemFile,           // Oem string
                                     ARRAYSIZE(szOemFile),// Oem string buffer size
                                     NULL,                // use nls default char 
                                     &bDefaultCharUsed 
                                   );

   if( ( iOemString != 0               ) && // should succeed conversion.
       ( iOemString <= OFS_MAXPATHNAME ) && // should be <= 128 for OpenFile() API.
       ( bDefaultCharUsed == FALSE     )    // the def. char should not be contain.
     )
   {
      DiamondFile = IsDiamondFile(szOemFile);
   }

    if (DiamondFile) {
        pLZCloseFile(fIn);
    }

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    /* If the dest file exists and is read only, return immediately;
     * the calling app must change the attributes before continuing
     * In the library version, we assume the file is in use if it exists
     * and we are in a VM; check all other possible errors and then return,
     * so the calling app can override our determination of "in use"
     * on a second call, along with all other problems
     */
    wDirLen = (WORD)MakeFileName(szDstFile, lpszDstDir, lpszDstFileName, ARRAYSIZE(szDstFile));
    lstrcpyn(szSrcFile, szDstFile, ARRAYSIZE(szSrcFile));
    if (!HIWORD(dwSrcAttr=GetFileAttributes(szSrcFile))) {
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        if (LOWORD(dwSrcAttr)&0x01) {
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            dwRetVal |= VIF_WRITEPROT;
            goto doCloseSrc;
        }
    }

    /* If this is a force install and there is a temp file name from a
     * previous call to this function, use that as the temp file name
     */
    LogData("inst", __LINE__, (DWORD)puTmpFileLen);
    if ((wFlags&VIFF_FORCEINSTALL) && *lpszTmpFile) {
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        LogData("fnam", (DWORD)lpszDstDir, (DWORD)lpszTmpFile);
        MakeFileName(szSrcFile, lpszDstDir, lpszTmpFile, ARRAYSIZE(szSrcFile));
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        LogData("srcf", (DWORD)szSrcFile, *(LPDWORD)szSrcFile);
        if (!HIWORD(GetFileAttributes(szSrcFile))) {
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            goto doCheckDstFile;
        }
    }

    /* Determine a file name that is not in use; try names of the form:
     * temp.nnn where nnn is a three digit hex number.  If we get to
     * 0xfff, we have a serious file system problem.  Create the file.
     */
    LogData("inst", __LINE__, (DWORD)puTmpFileLen);
    lstrcpy(szSrcFile+wDirLen, szTempHdr);
    for (i=0; ; ++i) {
        Ver3IToA(szSrcFile+wDirLen+lstrlen(szTempHdr), i);
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        if (HIWORD(GetFileAttributes(szSrcFile)))
            break;
        if (i > 0xfff) {
            dwRetVal |= VIF_CANNOTCREATE;
            goto doCloseSrc;
        }
    }
    /* Copy the file, and fill in appropriate errors
     */

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    if (DiamondFile) {
        LZINFO lzi;
        lCopy = ExpandDiamondFile(szOemFile,
                                  szSrcFile,
                                  FALSE,
                                  &lzi);
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
    } else {
        if ((hW32Out=VerCreateFile(szSrcFile)) == INVALID_HANDLE_VALUE) {
            dwRetVal |= VIF_CANNOTCREATE | FileErrFlag(GetLastError());
            goto doCloseSrc;
        }

        LogData("inst", __LINE__, (DWORD)puTmpFileLen);

        fDosOut = pLZInit((INT)((DWORD_PTR)hW32Out));
        lCopy = pLZCopy(fIn, fDosOut);
        pLZClose(fDosOut);
    }

    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    switch (lCopy) {
        case LZERROR_BADINHANDLE:
        case LZERROR_READ:
        case LZERROR_BADVALUE:
        case LZERROR_UNKNOWNALG:
            dwRetVal |= VIF_CANNOTREADSRC;
            goto doDelTempFile;

        case LZERROR_BADOUTHANDLE:
        case LZERROR_WRITE:
            dwRetVal |= VIF_OUTOFSPACE;
            goto doDelTempFile;

        case LZERROR_GLOBALLOC:
        case LZERROR_GLOBLOCK:
            dwRetVal |= VIF_OUTOFMEMORY;
            goto doDelTempFile;

        default:
            break;
    }

    /* If the destination exists, check the versions of the two files,
     * and only copy if the src file is at least as new as the dst, and
     * they are the same type and in the same language and codepage
     */
doCheckDstFile:
    if (!HIWORD(dwSrcAttr)) {
        VS_VERSION *pSrcVer, *pDstVer;
        LANGANDCP *lpSrcTrans, *lpDstTrans;
        DWORD   dwSrcNum, dwDstNum;
        DWORD   dwSrcTrans, dwDstTrans;

        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        if (!(wFlags & VIFF_FORCEINSTALL) &&
            (pDstVer=MyGetFileVersionInfo(szDstFile))) {
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            if (!(pSrcVer=MyGetFileVersionInfo(szSrcFile))) {
                dwRetVal |= VIF_MISMATCH | VIF_SRCOLD;
            } else {
                LogData("inst", __LINE__, (DWORD)puTmpFileLen);
                if (pDstVer->vInfo.dwFileVersionMS>pSrcVer->vInfo.dwFileVersionMS
                    || (pDstVer->vInfo.dwFileVersionMS==pSrcVer->vInfo.dwFileVersionMS &&
                        pDstVer->vInfo.dwFileVersionLS>pSrcVer->vInfo.dwFileVersionLS))
                    dwRetVal |= VIF_MISMATCH | VIF_SRCOLD;

                if (pDstVer->vInfo.dwFileType!=pSrcVer->vInfo.dwFileType ||
                    pDstVer->vInfo.dwFileSubtype!=pSrcVer->vInfo.dwFileSubtype)
                    dwRetVal |= VIF_MISMATCH | VIF_DIFFTYPE;

                if (VerQueryValueW(pDstVer, szTrans, (LPVOID)&lpDstTrans, &dwDstNum) &&
                    VerQueryValueW(pSrcVer, szTrans, (LPVOID)&lpSrcTrans, &dwSrcNum)) {
                    dwDstNum /= sizeof(DWORD);
                    dwSrcNum /= sizeof(DWORD);

                    for (dwDstTrans=0; dwDstTrans<dwDstNum; ++dwDstTrans) {
                        for (dwSrcTrans=0; ; ++dwSrcTrans) {
                            if (dwSrcTrans >= dwSrcNum) {
                                dwRetVal |= VIF_MISMATCH | VIF_DIFFLANG;
                                break;
                            }

                            if (lpDstTrans[dwDstTrans].wLanguage
                                == lpSrcTrans[dwSrcTrans].wLanguage) {
                                /* OK if dst is CP0 and src is not UNICODE
                                 */
                                if (lpDstTrans[dwDstTrans].wCodePage==0 &&
                                    lpSrcTrans[dwSrcTrans].wCodePage!=1200)
                                    break;
                                if (lpDstTrans[dwDstTrans].wCodePage
                                    == lpSrcTrans[dwSrcTrans].wCodePage)
                                    break;
                            }
                        }
                    }
                }

                LogData("inst", __LINE__, (DWORD)puTmpFileLen);
                MyFree(pSrcVer);
            }
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            MyFree(pDstVer);
        }

        /* If there were no errors, delete the currently existing file
         */
        LogData("inst", __LINE__, (DWORD)puTmpFileLen);
        if (FileInUse(szDstFile, lpszDstFileName)) {
            LogData("inst", __LINE__, (DWORD)puTmpFileLen);
            dwRetVal |= VIF_FILEINUSE;
        }
    
        if (!dwRetVal && !DeleteFile(szDstFile)) {
            dwRetVal |= VIF_CANNOTDELETE | FileErrFlag(GetLastError());
            goto doDelTempFile;
        }
    }

    /* If there were no errors, rename the temp file (any existing file
     * should have been deleted by now).  Otherwise, if we created a valid
     * temp file, then pass along the temp file name.
     */
    LogData("inst", __LINE__, (DWORD)puTmpFileLen);

    if (dwRetVal) {
        DWORD wTemp;

        if (*puTmpFileLen > (wTemp=lstrlen(szSrcFile+wDirLen))) {
            lstrcpy(lpszTmpFile, szSrcFile+wDirLen);
            dwRetVal |= VIF_TEMPFILE;
        } else {
            dwRetVal |= VIF_BUFFTOOSMALL;
            DeleteFile(szSrcFile);
        }
        *puTmpFileLen = wTemp + 1;
    } else {
        /* Delete the currently existing file; this gets done before renaming
         * the temp file in case someone has tried to mess us up with a weird
         * directory name that would allow us to delete the newly installed
         * file.
         */
        if (!(wFlags&VIFF_DONTDELETEOLD) &&
            lpszCurDir && *lpszCurDir && lstrcmpi(lpszCurDir, lpszDstDir)) {
            MakeFileName(szCurFile, lpszCurDir, lpszDstFileName, ARRAYSIZE(szCurFile));
            if (!HIWORD(GetFileAttributes(szCurFile)) &&
                (FileInUse(szCurFile, lpszDstFileName) ||
                 !DeleteFile(szCurFile)))
                dwRetVal |= VIF_CANNOTDELETECUR | FileErrFlag(GetLastError());
        }

        if (!MoveFile(szSrcFile, szDstFile)) {
            dwRetVal |= VIF_CANNOTRENAME | FileErrFlag(GetLastError());
doDelTempFile:
            DeleteFile(szSrcFile);
        }
    }

doCloseSrc:
    if (!DiamondFile) {
        pLZCloseFile(fIn);
    }
doReturn:
    LogData("inst", __LINE__, (DWORD)puTmpFileLen);
    TermDiamond();
    return (dwRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\verpriv.h ===
/***************************************************************************
 *  VERPRIV.H
 *
 *    Private include file for the version stamping API.  Includes
 *    WINDOWS.H if this is being made to be a DLL.
 *
 ***************************************************************************/

#ifndef VERPRIV_H
#define VERPRIV_H
#undef DBCS

#include <stdlib.h>
#include <windows.h>

#define SEEK_START      0
#define SEEK_CURRENT 1
#define SEEK_END     2

/* ----- Function prototypes ----- */
#define FileClose(a)       LZClose(a)
#define FileRead(a, b, c)  LZRead((a), (b), (c))
#define FileSeek(a, b, c)  LZSeek((a), (b), (c))


BOOL
APIENTRY
VerpQueryValue(
   const LPVOID pb,
   LPVOID lpSubBlockX,
   INT    nIndex,
   LPVOID *lplpKey,
   LPVOID *lplpBuffer,
   PUINT  puLen,
   BOOL  bUnicodeNeeded
   );

#endif /* VERPRIV_H */


#if 0
#define LOG_DATA 1
#endif


#ifdef LOG_DATA
#   pragma message(__FILE__"(43) : warning !!!! : remove debug code before checking in" )
extern void LogThisData( DWORD id, char *szMsg, DWORD dwLine, DWORD dwData );

#   define LogData( sz, dw1, dw2 )   LogThisData(GetCurrentThreadId(), sz "            ", dw1, dw2 )
#else
#   define LogData( sz, dw1, dw2 )
#endif



#ifndef ARRAYSIZE
#   define ARRAYSIZE(sz)   (sizeof(sz) / sizeof((sz)[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\winver\winver.c ===
/*---------------------------------------------------------------------------
 |   WINVER.C - Windows Version program
 |
 |   History:
 |  03/08/89 Toddla     Created
 |
 *--------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <port1632.h>
#include <stdio.h>
#include "winverp.h"
#include <shellapi.h>

void FileTimeToDateTimeString(
    LPFILETIME pft,
    LPTSTR     pszBuf,
    UINT       cchBuf)
{
    SYSTEMTIME st;
    int cch;

    FileTimeToLocalFileTime(pft, pft);
    FileTimeToSystemTime(pft, &st);

    cch = GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszBuf, cchBuf);
    cchBuf -= cch;
    pszBuf += cch - 1;

    *pszBuf++ = TEXT(' ');
    *pszBuf = 0;          // (in case GetTimeFormat doesn't add anything)
    cchBuf--;

    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszBuf, cchBuf);
}

/*----------------------------------------------------------------------------*\
|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )                              |
|                                                                              |
|   Description:                                                               |
|       The main procedure for the App.  After initializing, it just goes      |
|       into a message-processing loop until it gets a WM_QUIT message         |
|       (meaning the app was closed).                                          |
|                                                                              |
|   Arguments:                                                                 |
|   hInst       instance handle of this instance of the app                    |
|   hPrev       instance handle of previous instance, NULL if first            |
|       lpszCmdLine     ->null-terminated command line                         |
|       cmdShow         specifies how the window is initially displayed        |
|                                                                              |
|   Returns:                                                                   |
|       The exit code as specified in the WM_QUIT message.                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
INT
__cdecl
ModuleEntry()
{
    TCHAR szTitle[32];
    LARGE_INTEGER Time = USER_SHARED_DATA->SystemExpirationDate;

    LoadString(GetModuleHandle(NULL), IDS_APPTITLE, szTitle, 32);

    if (Time.QuadPart) {
        TCHAR szExtra[128];
        TCHAR szTime[128];

        FileTimeToDateTimeString((PFILETIME)&Time, szTime, 128);

        LoadString(GetModuleHandle(NULL), IDS_EVALUATION, szExtra, 128);

        lstrcat(szExtra, szTime);

        ShellAbout(NULL, szTitle, szExtra, NULL);
    } else {
        ShellAbout(NULL, szTitle, NULL, NULL);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\version.c ===
/***************************************************************************
 *  VER.C
 *
 *	Code specific to the DLL version of VER which contains the Windows
 *	procedures necessary to make it work
 *
 ***************************************************************************/

#include "verpriv.h"
#include <diamondd.h>
#include "mydiam.h"

/*  LibMain
 *		Called by DLL startup code.
 *		Initializes VER.DLL.
 */

#ifdef LOG_DATA
typedef struct {
    DWORD idThd;
    char  szMsg[4];
    DWORD dwLine;
    DWORD dwData;
} LOGLINE;

typedef LOGLINE *PLOGLINE;

#define CLOG_MAX    16384

LOGLINE llLogBuff[CLOG_MAX];
int illLogPtr = 0;
CRITICAL_SECTION csLog;

void LogThisData( DWORD id, char *szMsg, DWORD dwLine, DWORD dwData ) {
    PLOGLINE pll;

    EnterCriticalSection(&csLog);
    pll = &llLogBuff[illLogPtr++];
    if (illLogPtr >= CLOG_MAX)
        illLogPtr = 0;
    LeaveCriticalSection(&csLog);


    pll->idThd = id;
    pll->dwData = dwData;
    pll->dwLine = dwLine;
    CopyMemory( pll->szMsg, szMsg, sizeof(pll->szMsg) );
}
#endif





HANDLE  hInst;
extern HINSTANCE hLz32;
extern HINSTANCE hCabinet;

DWORD itlsDiamondContext = ITLS_ERROR;  // Init to Error Condition

INT
APIENTRY
LibMain(
       HANDLE  hInstance,
       DWORD   dwReason,
       LPVOID  lp
       )
{
    PDIAMOND_CONTEXT pdcx;

    UNREFERENCED_PARAMETER(lp);

    hInst = hInstance;

#ifdef LOG_DATA
    {
        TCHAR szBuffer[80];
        swprintf( szBuffer, TEXT("thd[0x%08ld]: Attached to version.dll for %ld\n"), GetCurrentThreadId(), dwReason );
        OutputDebugString(szBuffer);
    }
#endif

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:

#ifdef LOG_DATA
            InitializeCriticalSection(&csLog);
#endif

#ifdef LOG_DATA

            {
                TCHAR szBuffer[MAX_PATH];
                OutputDebugString(TEXT(">>>version.c: compiled ") TEXT(__DATE__) TEXT(" ") TEXT(__TIME__) TEXT("\n"));
                OutputDebugString(TEXT("\tProcess "));
                GetModuleFileName(NULL, szBuffer, sizeof(szBuffer) / sizeof(TCHAR));
                OutputDebugString(szBuffer);
                OutputDebugString(TEXT(" attached\n"));
            }
#endif
            itlsDiamondContext = TlsAlloc();

            // Fall through to Thread Attach, since for some reason
            // the DLL_PROCESS_ATTACH thread does not call DLL_THREAD_ATTACH

        case DLL_THREAD_ATTACH:
            if (GotDmdTlsSlot())
                TlsSetValue(itlsDiamondContext, NULL);

            break;

        case DLL_PROCESS_DETACH:

            if (GotDmdTlsSlot()) {
                TlsFree(itlsDiamondContext);
            }
            if (hLz32) {
                FreeLibrary(hLz32);
            }

            if (hCabinet) {
                FreeLibrary(hCabinet);
            }
            break;
    }

    /* Return success */
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\test\test.h ===
#define IDC_DUMMY                   -1
#define IDD_ABOUT	100
#define IDD_FIND	101
#define IDD_INSTALL	102
#define IDD_INFO	103
#define IDD_QUERY	104
#define IDD_LANG	105

#define IDC_FILENAME    201
#define IDC_SUBLANGID   202
#define IDC_LANGID      203

#define IDM_VERSION	300

#define IDM_ABOUT	301
#define IDM_EXIT	302
#define IDM_FIND	303
#define IDM_INSTALL	304
#define IDM_INFO	305
#define IDM_QUERY	306
#define IDM_LANG	307
#define IDM_FREE	308

BOOL	InitApplication(HANDLE);
BOOL	InitInstance(HANDLE, int);
LRESULT	MainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR	About(HWND, UINT, WPARAM, LPARAM);
INT_PTR	Find(HWND, UINT, WPARAM, LPARAM);
INT_PTR	Install(HWND, UINT, WPARAM, LPARAM);
INT_PTR	Information(HWND, UINT, WPARAM, LPARAM);
INT_PTR	Query(HWND, UINT, WPARAM, LPARAM);
INT_PTR	Language(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\winver\winverp.h ===
/*----------------------------------------------------------------------------*\
|   WINVER.H - Windows Version program                                         |
|                                                                              |
|   History:                                                                   |
|       03/08/89 Toddla     Created                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/


#define IDS_APPTITLE   101
#define IDS_EVALUATION 102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\cabinet.c ===
#include "shellpch.h"
#pragma hdrstop

#include <fdi.h>

static
BOOL
FAR DIAMONDAPI
FDICopy (
    HFDI          hfdi,
    char FAR     *pszCabinet,
    char FAR     *pszCabPath,
    int           flags,
    PFNFDINOTIFY  pfnfdin,
    PFNFDIDECRYPT pfnfdid,
    void FAR     *pvUser
    )
{
    return FALSE;
}

static
HFDI
FAR DIAMONDAPI
FDICreate (
    PFNALLOC pfnalloc,
    PFNFREE  pfnfree,
    PFNOPEN  pfnopen,
    PFNREAD  pfnread,
    PFNWRITE pfnwrite,
    PFNCLOSE pfnclose,
    PFNSEEK  pfnseek,
    int      cpuType,
    PERF     perf
    )
{
    return NULL;
}

static
BOOL
FAR DIAMONDAPI
FDIDestroy (
    HFDI hfdi
    )
{
    return FALSE;
}

static
BOOL
FAR DIAMONDAPI
FDIIsCabinet (
    HFDI            hfdi,
    INT_PTR         hf,
    PFDICABINETINFO pfdici
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(cabinet)
{
    DLOENTRY(20, FDICreate)
    DLOENTRY(21, FDIIsCabinet)
    DLOENTRY(22, FDICopy)
    DLOENTRY(23, FDIDestroy)
};

DEFINE_ORDINAL_MAP(cabinet)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\browseui.c ===
#include "shellpch.h"
#pragma hdrstop

#define _BROWSEUI_
#include <shlobj.h>
#include <shlobjp.h>
#include <objidl.h>
#include <comctrlp.h>
#include <shellapi.h>
#include <browseui.h>

#undef BROWSEUIAPI
#define BROWSEUIAPI             HRESULT STDAPICALLTYPE
#undef BROWSEUIAPI_
#define BROWSEUIAPI_(type)      type STDAPICALLTYPE


static
BROWSEUIAPI_(HRESULT)
Channel_QuickLaunch()
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BROWSEUIAPI_(void)
SHCreateSavedWindows()
{
}

static 
BROWSEUIAPI_(BOOL)
SHParseIECommandLine(
    LPCWSTR * ppszCmdLine,
    IETHREADPARAM * piei
    )
{
    return FALSE;
}

static
BROWSEUIAPI
SHCreateBandForPidl(
    LPCITEMIDLIST pidl,
    IUnknown** ppunk,
    BOOL fAllowBrowserBand
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BROWSEUIAPI_(DWORD)
IDataObject_GetDeskBandState(
    IDataObject *pdtobj
    )
{
    return 0;
}

static
BROWSEUIAPI_(BOOL)
SHOpenFolderWindow(
    IETHREADPARAM* pieiIn
    )
{
    // we leak some memebers, but we at least free piei
    LocalFree(pieiIn);
    return FALSE;
}

static
BROWSEUIAPI_(IETHREADPARAM*)
SHCreateIETHREADPARAM(
    LPCWSTR pszCmdLineIn,
    int nCmdShowIn,
    ITravelLog *ptlIn,
    IEFreeThreadedHandShake* piehsIn
    )
{
    return NULL;
}

static
BROWSEUIAPI_(void)
SHDestroyIETHREADPARAM(
    IETHREADPARAM* piei
    )
{
    // we leak som memebers, but we at least free piei
    LocalFree(piei);
}

static
BROWSEUIAPI_(BOOL)
SHOnCWMCommandLine(
    LPARAM lParam
    )
{
    return FALSE;
}

static
BROWSEUIAPI_(LPITEMIDLIST)
Channel_GetFolderPidl()
{
    return NULL;
}

static
BROWSEUIAPI
IUnknown_SetBandInfoSFB(
    IUnknown *punkBand,
    BANDINFOSFB *pbi
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BROWSEUIAPI_(void)
Channels_SetBandInfoSFB(
    IUnknown* punkBand
    )
{
}

static
BROWSEUIAPI_(IDeskBand *)
ChannelBand_Create(
    LPCITEMIDLIST pidlDefault
    )
{
    return NULL;
}

static
BROWSEUIAPI_(HRESULT)
SHGetNavigateTarget(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    LPITEMIDLIST *ppidl,
    DWORD *pdwAttribs
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BROWSEUIAPI_(BOOL)
GetInfoTip(
    IShellFolder* psf,
    LPCITEMIDLIST pidl,
    LPTSTR pszText,
    int cchTextMax
    )
{
    *pszText = 0;
    return FALSE;
}

static
BROWSEUIAPI_(BOOL)
SHCreateFromDesktop(
    PNEWFOLDERINFO pfi
    )
{
    return TRUE;
}

static
BROWSEUIAPI
SHOpenNewFrame(
    LPITEMIDLIST pidlNew,
    ITravelLog *ptl,
    DWORD dwBrowserIndex,
    UINT uFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}



//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(browseui)
{
    DLOENTRY(102, SHOpenFolderWindow)
    DLOENTRY(103, SHOpenNewFrame)
    DLOENTRY(105, SHCreateSavedWindows)
    DLOENTRY(106, SHCreateFromDesktop)
    DLOENTRY(120, SHCreateBandForPidl)
    DLOENTRY(122, IDataObject_GetDeskBandState)
    DLOENTRY(123, SHCreateIETHREADPARAM)
    DLOENTRY(125, SHParseIECommandLine)
    DLOENTRY(126, SHDestroyIETHREADPARAM)
    DLOENTRY(127, SHOnCWMCommandLine)
    DLOENTRY(128, Channel_GetFolderPidl)
    DLOENTRY(129, ChannelBand_Create)
    DLOENTRY(130, Channels_SetBandInfoSFB)
    DLOENTRY(131, IUnknown_SetBandInfoSFB)
    DLOENTRY(133, Channel_QuickLaunch)
    DLOENTRY(134, SHGetNavigateTarget)
    DLOENTRY(135, GetInfoTip)
};

DEFINE_ORDINAL_MAP(browseui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\version\test\test.c ===
#define UNICODE
#include <windows.h>		    /* required for all Windows applications */
#include <stdio.h>
#include <stdlib.h>
#include "test.h"		    /* specific to this program		     */

HANDLE hInst;			    /* current instance			     */
HMODULE	hMod=NULL;

TCHAR szInfoBuf[1024];
TCHAR szBuffer[256];
TCHAR szFileName[MAX_PATH];
WORD	languageid;

/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop

    COMMENTS:

        Windows recognizes this function by name as the initial entry point
        for the program.  This function calls the application initialization
        routine, if no other instance of the program is running, and always
        calls the instance initialization routine.  It then executes a message
        retrieval and dispatch loop that is the top-level control structure
        for the remainder of execution.  The loop is terminated when a WM_QUIT
        message is received, at which time this function exits the application
        instance by returning the value passed by PostQuitMessage().

        If this function must abort before entering the message loop, it
        returns the conventional value NULL.

****************************************************************************/

int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{

    MSG msg;				     /* message			     */

    UNREFERENCED_PARAMETER( lpCmdLine );

    if (!hPrevInstance)			 /* Other instances of app running? */
	if (!InitApplication(hInstance)) /* Initialize shared things */
	    return (FALSE);		 /* Exits if unable to initialize     */

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg,	   /* message structure			     */
	    NULL,		   /* handle of window receiving the message */
	    0,   		   /* lowest message to examine		     */
	    0))                    /* highest message to examine	     */
	{
	TranslateMessage(&msg);	   /* Translates virtual key codes	     */
	DispatchMessage(&msg);	   /* Dispatches message to window	     */
    }
    return (int)(msg.wParam);	   /* Returns the value from PostQuitMessage */
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

    COMMENTS:

        This function is called at initialization time only if no other
        instances of the application are running.  This function performs
        initialization tasks that can be done once for any number of running
        instances.

        In this case, we initialize a window class by filling out a data
        structure of type WNDCLASS and calling the Windows RegisterClass()
        function.  Since all instances of this application use the same window
        class, we only need to do this when the first instance is initialized.


****************************************************************************/

BOOL InitApplication(HANDLE hInstance)       /* current instance	     */
{
    WNDCLASS  wc;

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;                       /* Class style(s).                    */
    wc.lpfnWndProc = MainWndProc;       /* Function to retrieve messages for  */
                                        /* windows of this class.             */
    wc.cbClsExtra = 0;                  /* No per-class extra data.           */
    wc.cbWndExtra = 0;                  /* No per-window extra data.          */
    wc.hInstance = hInstance;          /* Application that owns the class.   */
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  MAKEINTRESOURCE(IDM_VERSION);
    wc.lpszClassName = TEXT("VerTestWClass"); /* Name used in call to CreateWindow. */

    /* Register the window class and return success/failure code. */

    return (RegisterClass(&wc));

}


/****************************************************************************

    FUNCTION:  InitInstance(HANDLE, int)

    PURPOSE:  Saves instance handle and creates main window

    COMMENTS:

        This function is called at initialization time for every instance of
        this application.  This function performs initialization tasks that
        cannot be shared by multiple instances.

        In this case, we save the instance handle in a static variable and
        create and display the main program window.

****************************************************************************/

BOOL InitInstance(
    HANDLE          hInstance,          /* Current instance identifier.       */
    int             nCmdShow)           /* Param for first ShowWindow() call. */
{
    HWND            hWnd;               /* Main window handle.                */

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    hInst = hInstance;

    /* Create a main window for this application instance.  */

    hWnd = CreateWindow(
        TEXT("VerTestWClass"),          /* See RegisterClass() call.          */
        TEXT("Version Test"),           /* Text for window title bar.         */
        WS_OVERLAPPEDWINDOW,            /* Window style.                      */
        CW_USEDEFAULT,                  /* Default horizontal position.       */
        CW_USEDEFAULT,                  /* Default vertical position.         */
        CW_USEDEFAULT,                  /* Default width.                     */
        CW_USEDEFAULT,                  /* Default height.                    */
        NULL,                           /* Overlapped windows have no parent. */
        NULL,                           /* Use the window class menu.         */
        hInstance,                      /* This instance owns this window.    */
        NULL                            /* Pointer not needed.                */
    );

    /* If window could not be created, return "failure" */

    if (!hWnd)
        return (FALSE);

    /* Make the window visible; update its client area; and return "success" */

    ShowWindow(hWnd, nCmdShow);  /* Show the window                        */
    UpdateWindow(hWnd);          /* Sends WM_PAINT message                 */
    return (TRUE);               /* Returns the value from PostQuitMessage */

}

/****************************************************************************

    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LPARAM)

    PURPOSE:  Processes messages

    MESSAGES:

	WM_COMMAND    - application menu
	WM_DESTROY    - destroy window

    COMMENTS:

****************************************************************************/

LRESULT APIENTRY MainWndProc(
    HWND hWnd,		  /* window handle		     */
    UINT message,		  /* type of message		     */
    WPARAM wParam,		  /* additional information	     */
    LPARAM lParam)		  /* additional information	     */
{
    TCHAR	szLang[256];
    TCHAR	szBuf[256];
    PVOID	pData;
    INT		cbData;
    INT		dummy;
    VS_FIXEDFILEINFO	*pvs;
    DWORD	*pdw;
    WORD	*pw;
    PAINTSTRUCT ps;

    switch (message) {
	case WM_COMMAND:	   /* message: command from application menu */
	    switch (LOWORD(wParam)) {

	    case IDM_ABOUT:
    		DialogBox(hInst,		 /* current instance	     */
			MAKEINTRESOURCE(IDD_ABOUT),	 /* resource to use  */
		        hWnd,			 /* parent handle	     */
		        About);	 /* About() instance address */

	    	break;

	    case IDM_FREE:
		FreeLibrary(hMod);
		break;

	    case IDM_EXIT:
		FreeLibrary(hMod);
		DestroyWindow(hWnd);
		break;

	    case IDM_QUERY:
    		DialogBox(hInst,		 /* current instance	     */
			MAKEINTRESOURCE(IDD_QUERY),	 /* resource to use  */
		        hWnd,			 /* parent handle	     */
		        Query);	 /* About() instance address */
		if (VerQueryValue(szInfoBuf, szFileName, &pData, &cbData) == FALSE)
		    MessageBox(hWnd, TEXT("Returned NULL"), TEXT("VerQueryValue"), MB_OK);
		else {
		    if (lstrcmp(szFileName, TEXT("\\")) == 0) {
			pvs = (VS_FIXEDFILEINFO*)pData;
			wsprintf(szBuffer, TEXT("0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx "),
				pvs->dwSignature,
				pvs->dwStrucVersion,
				pvs->dwFileVersionMS,
				pvs->dwFileVersionLS,
				pvs->dwProductVersionMS,
				pvs->dwProductVersionLS,
				pvs->dwFileFlagsMask,
				pvs->dwFileFlags,
				pvs->dwFileOS,
				pvs->dwFileType,
				pvs->dwFileSubtype,
				pvs->dwFileDateMS,
				pvs->dwFileDateLS);
			MessageBox(hWnd, szBuffer, TEXT("VerQueryValue VS_FIXEDFILEINFO"), MB_OK);
		    }
		    else if (lstrcmpi(szFileName, TEXT("\\VarFileInfo\\Translation")) == 0) {
			pw = (WORD*)pData;	/* assume 2 words */
			wsprintf(szBuffer, TEXT("0x%lx 0x%lx"), *pw, *(pw+1));
			MessageBox(hWnd, szBuffer, TEXT("VerQueryValue VS_FIXEDFILEINFO"), MB_OK);
		    }
    		    else if (
#ifndef UNICODE
                             strnicmp
#else
                             _wcsnicmp
#endif
		                     (szFileName, TEXT("\\StringFileInfo\\"), 16) == 0) {
			wsprintf(szBuffer, TEXT("%s:%ws"), szFileName, pData);
			MessageBox(hWnd, szBuffer, TEXT("VerQueryValue"), MB_OK);
		    }
		    else
			MessageBox(hWnd, TEXT("Other"), TEXT("VerQueryValue"), MB_OK);
		}
		break;

	    case IDM_INFO:
    		DialogBox(hInst,		 /* current instance	     */
			MAKEINTRESOURCE(IDD_INFO),	 /* resource to use  */
		        hWnd,			 /* parent handle	     */
		        Information);	 /* About() instance address */
		if (GetFileVersionInfoSize(szFileName, NULL) == FALSE)
		    MessageBox(hWnd, TEXT("Returned NULL"), TEXT("GetFileVersionInfoSize"), MB_OK);
		else {
		    if (GetFileVersionInfo(szFileName, 0, 1024, szInfoBuf) == FALSE)
			MessageBox(hWnd, TEXT("Returned NULL"), TEXT("GetFileVersionInfo"), MB_OK);
		    else {
			MessageBox(hWnd, TEXT("Returned OK"), TEXT("GetFileVersionInfo"), MB_OK);
		    }
		}
		break;

	    case IDM_FIND:
    		DialogBox(hInst,		 /* current instance	     */
			MAKEINTRESOURCE(IDD_FIND),	 /* resource to use  */
		        hWnd,			 /* parent handle	     */
		        Find);	 /* About() instance address */
		GetWindowsDirectory(szBuf, 256);
		dummy = 256;
		cbData = 1024;
		if (VerFindFile(0L, szFileName, szBuf, TEXT("c:\\tmp"), szLang, &dummy, szInfoBuf, &cbData) == FALSE)
		    MessageBox(hWnd, TEXT("Returned NULL"), TEXT("VerFindFile"), MB_OK);
		else {
		    wsprintf(szBuffer, TEXT("%s:%s"), szLang, szInfoBuf);
		    MessageBox(hWnd, szBuffer, TEXT("VerFindFile"), MB_OK);
		}
		break;

	    case IDM_INSTALL:
    		DialogBox(hInst,		 /* current instance	     */
			MAKEINTRESOURCE(IDD_INSTALL),	 /* resource to use  */
		        hWnd,			 /* parent handle	     */
		        Install);	 /* About() instance address */

		dummy = 256;
		cbData = VerInstallFile(VIFF_FORCEINSTALL|VIFF_DONTDELETEOLD,
			szFileName, szFileName, TEXT("."), szLang, szInfoBuf,
			szBuf, &dummy);
		if (cbData == 0)
		    MessageBox(hWnd, TEXT("Returned NULL"), TEXT("VerInstallFile"), MB_OK);
		else {
		    wsprintf(szBuffer, TEXT("0x%lx:%s"), cbData, szBuf);
		    MessageBox(hWnd, szBuffer, TEXT("VerInstallFile"), MB_OK);
		}
		break;

	    case IDM_LANG:
    		DialogBox(hInst,		 /* current instance	     */
			MAKEINTRESOURCE(IDD_LANG),	 /* resource to use  */
		        hWnd,			 /* parent handle	     */
		        Language);	 /* About() instance address */
		VerLanguageName(languageid, szLang, 256);
		MessageBox(hWnd, szLang, TEXT("Language ID is:"), MB_OK);
		break;

	    default:
		    return (DefWindowProc(hWnd, message, wParam, lParam));
	    }

	case WM_PAINT:
            BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);
            EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
	    break;

	case WM_DESTROY:		  /* message: window being destroyed */
	    PostQuitMessage(0);
	    break;

	default:			  /* Passes it on if unproccessed    */
	    return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}


/****************************************************************************

    FUNCTION: About(HWND, unsigned, WPARAM, LPARAM)

    PURPOSE:  Processes messages for "About" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

    COMMENTS:

	No initialization is needed for this particular dialog box, but TRUE
	must be returned to Windows.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR APIENTRY About(
	HWND hDlg,                /* window handle of the dialog box */
	UINT message,             /* type of message                 */
	WPARAM wParam,		/* message-specific information    */
	LPARAM lParam)
{
    switch (message) {
	case WM_INITDIALOG:		   /* message: initialize dialog box */
	    return (TRUE);

	case WM_COMMAND:		      /* message: received a command */
	    if (LOWORD(wParam) == IDOK)		/* "OK" box selected?	     */
		EndDialog(hDlg, TRUE);	      /* Exits the dialog box	     */
	    else if (LOWORD(wParam) == IDCANCEL) /* close command? */
		EndDialog(hDlg, FALSE);	      /* Exits the dialog box	     */
	    return (TRUE);
    }
    return (FALSE);			      /* Didn't process a message    */
	UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: Find(HWND, unsigned, WPARAM, LPARAM)

    PURPOSE:  Processes messages for "Find" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

    COMMENTS:

	No initialization is needed for this particular dialog box, but TRUE
	must be returned to Windows.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR APIENTRY Find(
	HWND hDlg,                /* window handle of the dialog box */
	UINT message,             /* type of message                 */
	WPARAM wParam,		/* message-specific information    */
	LPARAM lParam)
{
    switch (message) {
	case WM_INITDIALOG:		   /* message: initialize dialog box */
	    return (TRUE);

	case WM_COMMAND:		/* message: received a command */
	    if (LOWORD(wParam) == IDOK)	{	/* "OK" box selected?	     */
		GetDlgItemText(hDlg, IDC_FILENAME, szFileName, MAX_PATH);
		EndDialog(hDlg, TRUE);	      /* Exits the dialog box	     */
	    }
	    else if (LOWORD(wParam) == IDCANCEL) /* close command? */
		EndDialog(hDlg, FALSE);	      /* Exits the dialog box	     */
	    return (TRUE);
	    break;
    }
    return (FALSE);			      /* Didn't process a message    */
	UNREFERENCED_PARAMETER(lParam);
}

/****************************************************************************

    FUNCTION: Install(HWND, unsigned, WPARAM, LPARAM)

    PURPOSE:  Processes messages for "Install" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

    COMMENTS:

	No initialization is needed for this particular dialog box, but TRUE
	must be returned to Windows.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR APIENTRY Install(
	HWND hDlg,                /* window handle of the dialog box */
	UINT message,             /* type of message                 */
	WPARAM wParam,		/* message-specific information    */
	LPARAM lParam)
{
    switch (message) {
	case WM_INITDIALOG:		   /* message: initialize dialog box */
	    return (TRUE);

	case WM_COMMAND:		/* message: received a command */
	    if (LOWORD(wParam) == IDOK)	{	/* "OK" box selected?	     */
		GetDlgItemText(hDlg, IDC_FILENAME, szFileName, MAX_PATH);
		EndDialog(hDlg, TRUE);	      /* Exits the dialog box	     */
	    }
	    else if (LOWORD(wParam) == IDCANCEL) /* close command? */
		EndDialog(hDlg, FALSE);	      /* Exits the dialog box	     */
	    return (TRUE);
	    break;
    }
    return (FALSE);			      /* Didn't process a message    */
	UNREFERENCED_PARAMETER(lParam);
}

/****************************************************************************

    FUNCTION: Query(HWND, unsigned, WPARAM, LPARAM)

    PURPOSE:  Processes messages for "Query" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

    COMMENTS:

	No initialization is needed for this particular dialog box, but TRUE
	must be returned to Windows.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR APIENTRY Query(
	HWND hDlg,                /* window handle of the dialog box */
	UINT message,             /* type of message                 */
	WPARAM wParam,		/* message-specific information    */
	LPARAM lParam)
{
    switch (message) {
	case WM_INITDIALOG:		   /* message: initialize dialog box */
	    return (TRUE);

	case WM_COMMAND:		/* message: received a command */
	    if (LOWORD(wParam) == IDOK)	{	/* "OK" box selected?	     */
		GetDlgItemText(hDlg, IDC_FILENAME, szFileName, MAX_PATH);
		EndDialog(hDlg, TRUE);	      /* Exits the dialog box	     */
	    }
	    else if (LOWORD(wParam) == IDCANCEL) /* close command? */
		EndDialog(hDlg, FALSE);	      /* Exits the dialog box	     */
	    return (TRUE);
	    break;
    }
    return (FALSE);			      /* Didn't process a message    */
	UNREFERENCED_PARAMETER(lParam);
}

/****************************************************************************

    FUNCTION: Language(HWND, unsigned, WPARAM, LPARAM)

    PURPOSE:  Processes messages for "Language" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

    COMMENTS:

	No initialization is needed for this particular dialog box, but TRUE
	must be returned to Windows.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR APIENTRY Language(
	HWND hDlg,                /* window handle of the dialog box */
	UINT message,             /* type of message                 */
	WPARAM wParam,		/* message-specific information    */
	LPARAM lParam)
{
    UINT	lang;
    UINT	sublang;

    switch (message) {
	case WM_INITDIALOG:		   /* message: initialize dialog box */
	    return (TRUE);

	case WM_COMMAND:		/* message: received a command */
	    if (LOWORD(wParam) == IDOK)	{	/* "OK" box selected?	     */
		lang = GetDlgItemInt(hDlg, IDC_LANGID, NULL, FALSE);
		sublang = GetDlgItemInt(hDlg, IDC_SUBLANGID, NULL, FALSE);
		languageid = MAKELANGID(lang, sublang);
		EndDialog(hDlg, TRUE);	      /* Exits the dialog box	     */
	    }
	    else if (LOWORD(wParam) == IDCANCEL) /* close command? */
		EndDialog(hDlg, FALSE);	      /* Exits the dialog box	     */
	    return (TRUE);
	    break;
    }
    return (FALSE);			      /* Didn't process a message    */
	UNREFERENCED_PARAMETER(lParam);
}

/****************************************************************************

    FUNCTION: Information(HWND, unsigned, WPARAM, LPARAM)

    PURPOSE:  Processes messages for "Information" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

    COMMENTS:

	No initialization is needed for this particular dialog box, but TRUE
	must be returned to Windows.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

INT_PTR APIENTRY Information(
	HWND hDlg,                /* window handle of the dialog box */
	UINT message,             /* type of message                 */
	WPARAM wParam,		/* message-specific information    */
	LPARAM lParam)
{
    switch (message) {
	case WM_INITDIALOG:		   /* message: initialize dialog box */
	    return (TRUE);

	case WM_COMMAND:		/* message: received a command */
	    if (LOWORD(wParam) == IDOK)	{	/* "OK" box selected?	     */
		GetDlgItemText(hDlg, IDC_FILENAME, szFileName, MAX_PATH);
		EndDialog(hDlg, TRUE);	      /* Exits the dialog box	     */
	    }
	    else if (LOWORD(wParam) == IDCANCEL) /* close command? */
		EndDialog(hDlg, FALSE);	      /* Exits the dialog box	     */
	    return (TRUE);
	    break;
    }
    return (FALSE);			      /* Didn't process a message    */
	UNREFERENCED_PARAMETER(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\comdlg32.c ===
#include "shellpch.h"
#pragma hdrstop

#define _COMDLG32_
#include <commdlg.h>

static
DWORD
APIENTRY
CommDlgExtendedError(VOID)
{
    return 0;
}

static
SHORT
APIENTRY
GetFileTitleW (
    LPCWSTR lpszFileW,
    LPWSTR lpszTitleW,
    WORD cbBuf
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
GetOpenFileNameW (
    LPOPENFILENAMEW pofn
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
GetOpenFileNameA (
    LPOPENFILENAMEA pofn
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetSaveFileNameW (
    LPOPENFILENAMEW pofn
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetSaveFileNameA (
    LPOPENFILENAMEA pofn
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
ChooseColorW(
    LPCHOOSECOLORW pccw
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
PageSetupDlgW(
    LPPAGESETUPDLGW pPSDA
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
PageSetupDlgA(
    LPPAGESETUPDLGA pPSDA
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
PrintDlgA(
    LPPRINTDLGA pPDA
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
PrintDlgW(
    LPPRINTDLGW pPDA
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comdlg32)
{
    DLPENTRY(ChooseColorW)
    DLPENTRY(CommDlgExtendedError)
    DLPENTRY(GetFileTitleW)
    DLPENTRY(GetOpenFileNameA)
    DLPENTRY(GetOpenFileNameW)
    DLPENTRY(GetSaveFileNameA)
    DLPENTRY(GetSaveFileNameW)
    DLPENTRY(PageSetupDlgA)
    DLPENTRY(PageSetupDlgW)
    DLPENTRY(PrintDlgA)
    DLPENTRY(PrintDlgW)
};

DEFINE_PROCNAME_MAP(comdlg32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\devmgr.c ===
#include "shellpch.h"
#pragma hdrstop

#include <hwtab.h>

static
HWND
WINAPI
DeviceCreateHardwarePageEx(HWND hwndParent,
                           const GUID *pguid,
                           int iNumClass,
                           DWORD dwViewMode)
{
    return NULL;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(devmgr)
{
    DLOENTRY(20, DeviceCreateHardwarePageEx)
};

DEFINE_ORDINAL_MAP(devmgr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\cdfview.c ===
#include "shellpch.h"
#pragma hdrstop

static
HRESULT WINAPI
SubscribeToCDF(
    HWND hwndOwner,
    LPWSTR wszURL,
    DWORD dwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT WINAPI
ParseDesktopComponent(
    HWND hwndOwner,
    LPWSTR wszURL,
    void* pInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(cdfview)
{
    DLPENTRY(ParseDesktopComponent)
    DLPENTRY(SubscribeToCDF)
};

DEFINE_PROCNAME_MAP(cdfview)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\comctl32.c ===
#include "shellpch.h"
#pragma hdrstop

#define _COMCTL32_
#include <commctrl.h>
#include <comctrlp.h>


static
WINCOMMCTRLAPI
HPROPSHEETPAGE
WINAPI
CreatePropertySheetPageW (
    LPCPROPSHEETPAGEW psp
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HWND
WINAPI
CreateUpDownControl (
    DWORD dwStyle, int x, int y, int cx, int cy,
    HWND hParent, int nID, HINSTANCE hInst,
    HWND hBuddy,
    int nUpper, int nLower, int nPos
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
DestroyPropertySheetPage (
    HPROPSHEETPAGE hpage
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
int
WINAPI
ImageList_Add (
    HIMAGELIST himl,
    HBITMAP hbmImage,
    HBITMAP hbmMask
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_Create (
    int cx, int cy, UINT flags, int cInitial, int cGrow
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_Destroy (
    HIMAGELIST himl
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_Draw (
    HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_Duplicate (
    HIMAGELIST himl
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HICON
WINAPI
ImageList_GetIcon (
    HIMAGELIST himl, int i, UINT flags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_GetIconSize (
    HIMAGELIST himl, int FAR *cx, int FAR *cy
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_LoadImageA (
    HINSTANCE hi,
    LPCSTR lpbmp,
    int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
HIMAGELIST
WINAPI
ImageList_LoadImageW (
    HINSTANCE hi,
    LPCWSTR lpbmp,
    int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI ImageList_Remove(
    HIMAGELIST himl, 
    int i
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
int
WINAPI
ImageList_ReplaceIcon (
    HIMAGELIST himl, int i, HICON hicon
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
COLORREF
WINAPI
ImageList_SetBkColor (
    HIMAGELIST himl,
    COLORREF clrBk
    )
{
    return CLR_NONE;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_SetOverlayImage (
    HIMAGELIST himl,
    int iImage,
    int iOverlay
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void
WINAPI InitCommonControls (
    void
    )
{
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
InitCommonControlsEx (
    LPINITCOMMONCONTROLSEX icce
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
INT_PTR
WINAPI
PropertySheetW (
    LPCPROPSHEETHEADERW psh
    )
{
    return -1;
}

static
LRESULT
WINAPI
DefSubclassProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return 0;
}

static
WINCOMMCTRLAPI
int
WINAPI
DSA_InsertItem(
    HDSA hdsa,
    int i,
    void *pitem
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
void
WINAPI
DSA_DestroyCallback(
    HDSA hdsa,
    PFNDSAENUMCALLBACK pfnCB,
    void *pData
    )
{
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
Str_SetPtrW(
    LPWSTR * ppsz,
    LPCWSTR psz
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
void*
WINAPI
DPA_DeletePtr(
    HDPA hdpa,
    int i
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
int
WINAPI
DPA_InsertPtr(
    HDPA hdpa,
    int i,
    void *p)
{
    return -1;
}

static
WINCOMMCTRLAPI
BOOL  
WINAPI
DPA_DeleteAllPtrs(
    HDPA hdpa
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
INT_PTR
WINAPI
PropertySheetA(
    LPCPROPSHEETHEADERA psh
    )
{
    return -1;
}

static
WINCOMMCTRLAPI
void*
WINAPI
DSA_GetItemPtr(
    HDSA hdsa,
    int i
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
DPA_Destroy(
    HDPA hdpa
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HDPA
WINAPI
DPA_Create(
    int cItemGrow
    )
{
    return NULL;
}

static
BOOL
WINAPI
SetWindowSubclass(
    HWND hWnd,
    SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData
    )
{
    return FALSE;
}

static
BOOL
WINAPI
RemoveWindowSubclass(
    HWND hWnd,
    SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass
    )
{
    return FALSE;
}

static
WINCOMMCTRLAPI
HDSA
WINAPI
DSA_Create(
    int cbItem,
    int cItemGrow
    )
{
    return NULL;
}

static
WINCOMMCTRLAPI
BOOL
WINAPI
ImageList_DrawIndirect(
    IMAGELISTDRAWPARAMS* pimldp
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(comctl32)
{
    DLOENTRY(16, CreateUpDownControl)
    DLOENTRY(17, InitCommonControls)
    DLOENTRY(236, Str_SetPtrW)
    DLOENTRY(320, DSA_Create)
    DLOENTRY(323, DSA_GetItemPtr)
    DLOENTRY(324, DSA_InsertItem)
    DLOENTRY(328, DPA_Create)
    DLOENTRY(329, DPA_Destroy)
    DLOENTRY(334, DPA_InsertPtr)
    DLOENTRY(336, DPA_DeletePtr)
    DLOENTRY(337, DPA_DeleteAllPtrs)
    DLOENTRY(388, DSA_DestroyCallback)
    DLOENTRY(410, SetWindowSubclass)
    DLOENTRY(412, RemoveWindowSubclass)
    DLOENTRY(413, DefSubclassProc)
};

DEFINE_ORDINAL_MAP(comctl32)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(comctl32)
{
    DLPENTRY(CreatePropertySheetPageW)
    DLPENTRY(DestroyPropertySheetPage)
    DLPENTRY(ImageList_Add)
    DLPENTRY(ImageList_Create)
    DLPENTRY(ImageList_Destroy)
    DLPENTRY(ImageList_Draw)
    DLPENTRY(ImageList_DrawIndirect)
    DLPENTRY(ImageList_Duplicate)
    DLPENTRY(ImageList_GetIcon)
    DLPENTRY(ImageList_GetIconSize)
    DLPENTRY(ImageList_LoadImageA)
    DLPENTRY(ImageList_LoadImageW)
    DLPENTRY(ImageList_Remove)
    DLPENTRY(ImageList_ReplaceIcon)
    DLPENTRY(ImageList_SetBkColor)
    DLPENTRY(ImageList_SetOverlayImage)
    DLPENTRY(InitCommonControlsEx)
    DLPENTRY(PropertySheetA)
    DLPENTRY(PropertySheetW)
};

DEFINE_PROCNAME_MAP(comctl32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\efsadu.c ===
#include "shellpch.h"
#pragma hdrstop

#include <efsui.h>

static
void
WINAPI
EfsDetail(
    HWND hwndParent,
    LPCWSTR FileName
    )
{
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(efsadu)
{
    DLPENTRY(EfsDetail)
};

DEFINE_PROCNAME_MAP(efsadu)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\linkinfo.c ===
#include "shellpch.h"
#pragma hdrstop

#define _LINKINFO_
#include <linkinfo.h>

static
LINKINFOAPI
BOOL
WINAPI
CreateLinkInfoW(
                LPCWSTR psz,
                PLINKINFO* pli
                )
{
    return FALSE;
}

static
LINKINFOAPI
BOOL
WINAPI
GetLinkInfoData(
    PCLINKINFO pcli,
    LINKINFODATATYPE lidt,
    const VOID** ppv
    )
{
    return FALSE;
}

static
LINKINFOAPI
BOOL
WINAPI
IsValidLinkInfo(
    PCLINKINFO pcli
    )
{
    // If you can't load LinkInfo then just declare all linkinfo structures
    // invalid because you can't use them anyway
    return FALSE;
}

static
LINKINFOAPI
BOOL
WINAPI
ResolveLinkInfoW(
    PCLINKINFO pcli,
    LPWSTR pszResolvedPathBuf,
    DWORD dwInFlags,
    HWND hwndOwner,
    PDWORD pdwOutFlags,
    PLINKINFO *ppliUpdated
    )
{
    return FALSE;
}

static
LINKINFOAPI
void
WINAPI
DestroyLinkInfo(
    PLINKINFO pli
    )
{
    // leak it since it comes from a private heap
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(linkinfo)
{
    DLPENTRY(CreateLinkInfoW)
    DLPENTRY(DestroyLinkInfo)
    DLPENTRY(GetLinkInfoData)
    DLPENTRY(IsValidLinkInfo)
    DLPENTRY(ResolveLinkInfoW)
};

DEFINE_PROCNAME_MAP(linkinfo)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\mlang.c ===
#include "shellpch.h"
#pragma hdrstop

#include <objbase.h>
#include <mlang.h>

#undef STDAPI
#define STDAPI          HRESULT STDAPICALLTYPE


static
STDAPI
ConvertINetUnicodeToMultiByte(
    LPDWORD lpdwMode,
    DWORD dwEncoding,
    LPCWSTR lpSrcStr,
    LPINT lpnWideCharCount,
    LPSTR lpDstStr,
    LPINT lpnMultiCharCount
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
ConvertINetMultiByteToUnicode(
    LPDWORD lpdwMode,
    DWORD dwEncoding,
    LPCSTR lpSrcStr,
    LPINT lpnMultiCharCount,
    LPWSTR lpDstStr,
    LPINT lpnWideCharCount)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
LcidToRfc1766A(
    LCID Locale,
    LPSTR pszRfc1766,
    int iMaxLength)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
} 

static
STDAPI
Rfc1766ToLcidW(
    LCID *pLocale,
    LPCWSTR pszRfc1766
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
} 

static
STDAPI
LcidToRfc1766W(
    LCID Locale,
    LPWSTR pszRfc1766,
    int nChar
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(mlang)
{
    DLOENTRY(112, ConvertINetUnicodeToMultiByte)
    DLOENTRY(113, ConvertINetMultiByteToUnicode)
    DLOENTRY(120, LcidToRfc1766A)
    DLOENTRY(121, LcidToRfc1766W)
    DLOENTRY(123, Rfc1766ToLcidW)
};

DEFINE_ORDINAL_MAP(mlang)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\lz32.c ===
#include "shellpch.h"
#pragma hdrstop

#include <lzexpand.h>

static
VOID
APIENTRY
LZClose (
    INT oLZFile
    )
{
}

static
LONG
APIENTRY
LZCopy (
    INT doshSource,
    INT doshDest
    )
{
    return LZERROR_BADINHANDLE;
}

static
INT
APIENTRY
LZOpenFileW (
    LPWSTR lpFileName,
    LPOFSTRUCT lpReOpenBuf,
    WORD wStyle
    )
{
    return LZERROR_BADINHANDLE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(lz32)
{
    DLPENTRY(LZClose)
    DLPENTRY(LZCopy)
    DLPENTRY(LZOpenFileW)
};

DEFINE_PROCNAME_MAP(lz32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\netplwiz.c ===
#include "shellpch.h"
#pragma hdrstop

#undef STDAPI_
#define STDAPI_(type)           type STDAPICALLTYPE

static
STDAPI_(DWORD)
NetPlacesWizardDoModal(
    LPCONNECTDLGSTRUCTW  lpConnDlgStruct,
    DWORD                npwt,
    BOOL                 fIsROPath
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
STDAPI_(DWORD)
SHDisconnectNetDrives(
    HWND hwndParent
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netplwiz)
{
    DLPENTRY(NetPlacesWizardDoModal)
    DLPENTRY(SHDisconnectNetDrives)
};

DEFINE_PROCNAME_MAP(netplwiz)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\msrating.c ===
#include "shellpch.h"
#pragma hdrstop

#include <ratings.h>

#undef STDAPI
#define STDAPI          HRESULT STDAPICALLTYPE


static
STDAPI
RatingObtainQuery(LPCSTR pszTargetUrl,
                  DWORD dwUserData,
                  void (*fCallback)(DWORD dwUserData,
                  HRESULT hr,
                  LPCSTR pszRating,
                  void *lpvRatingDetails),
                  HANDLE *phRatingObtainQuery)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingEnabledQuery()
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingFreeDetails(void *pRatingDetails)
{
    return NOERROR;
}

static
STDAPI
RatingAccessDeniedDialog2(HWND hDlg,
                          LPCSTR pszUsername,
                          void *pRatingDetails)
{
    return S_FALSE;
}

static
STDAPI
RatingCustomDeleteCrackedData(struct RATINGBLOCKINGINFO* prblInfo)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingCustomCrackData(LPCSTR pszUsername,
                      void* pvRatingDetails,
                      struct RATINGBLOCKINGINFO** pprbInfo)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingCheckUserAccess(LPCSTR pszUsername,
                      LPCSTR pszURL,
                      LPCSTR pszRatingInfo,
                      LPBYTE pData,
                      DWORD cbData,
                      void **ppRatingDetails)
{
    if (ppRatingDetails)
    {
        *ppRatingDetails = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RatingObtainCancel(HANDLE hRatingObtainQuery)
{
    return E_HANDLE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(msrating)
{
    DLPENTRY(RatingAccessDeniedDialog2)
    DLPENTRY(RatingCheckUserAccess)
    DLPENTRY(RatingCustomCrackData)
    DLPENTRY(RatingCustomDeleteCrackedData)
    DLPENTRY(RatingEnabledQuery)
    DLPENTRY(RatingFreeDetails)
    DLPENTRY(RatingObtainCancel)
    DLPENTRY(RatingObtainQuery)
};

DEFINE_PROCNAME_MAP(msrating)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\powrprof.c ===
#include "shellpch.h"
#pragma hdrstop

#include <powrprof.h>

BOOLEAN WINAPI SetSuspendState(
    BOOLEAN bHibernate,
    BOOLEAN bForce,
    BOOLEAN bWakeupEventsDisabled
    )
{
    return FALSE;
}

BOOLEAN WINAPI IsPwrHibernateAllowed()
{
    return FALSE;
}

BOOLEAN WINAPI IsPwrSuspendAllowed()
{
    return FALSE;
}

BOOLEAN WINAPI IsPwrShutdownAllowed()
{
    return FALSE;
}

BOOLEAN WINAPI GetActivePwrScheme(
    PUINT puiID
    )
{
    return FALSE;
}

BOOLEAN WINAPI SetActivePwrScheme(
    UINT uiID,
    PGLOBAL_POWER_POLICY pgpp,
    PPOWER_POLICY ppp
    )
{
    return FALSE;
}

BOOLEAN WINAPI ReadPwrScheme(
    UINT uiID,
    PPOWER_POLICY ppp
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(powrprof)
{
    DLPENTRY(GetActivePwrScheme)
    DLPENTRY(IsPwrHibernateAllowed)
    DLPENTRY(IsPwrShutdownAllowed)
    DLPENTRY(IsPwrSuspendAllowed)
    DLPENTRY(ReadPwrScheme)
    DLPENTRY(SetActivePwrScheme)
    DLPENTRY(SetSuspendState)
};

DEFINE_PROCNAME_MAP(powrprof)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\shdocvw.c ===
#include "shellpch.h"
#pragma hdrstop

#define _SHDOCVW_
#include <shlobj.h>
#include <shlobjp.h>
#include <objidl.h>
#include <comctrlp.h>
#include <shellapi.h>
#include <shdocvw.h>

#undef SHDOCAPI
#define SHDOCAPI            HRESULT STDAPICALLTYPE
#undef SHDOCAPI_
#define SHDOCAPI_(type)     type STDAPICALLTYPE
#undef SHSTDDOCAPI_
#define SHSTDDOCAPI_(type)  type STDAPICALLTYPE


static
SHDOCAPI_(IStream *)
OpenPidlOrderStream(
    LPCITEMIDLIST pidlRoot,
    LPCITEMIDLIST pidl,
    LPCSTR pszKey,
    DWORD grfMode
    )
{
    return NULL;
}

static
SHDOCAPI_(BOOL)
IEIsLinkSafe(
    HWND hwnd,
    LPCITEMIDLIST pidl,
    ILS_ACTION ilsFlag
    )
{
    return FALSE;
}

static
SHDOCAPI
DragDrop(
    HWND hwnd,
    IShellFolder * psfParent,
    LPCITEMIDLIST pidl,
    DWORD dwPrefEffect,
    DWORD *pdwEffect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
IECreateFromPathCPWithBCW(
    UINT uiCP,
    LPCWSTR pszPath,
    IBindCtx * pbc,
    LPITEMIDLIST *ppidlOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
ILIsWeb(
    LPCITEMIDLIST pidl
    )
{
    return FALSE;
}

static
SHDOCAPI
IECreateFromPathCPWithBCA(
    UINT uiCP,
    LPCSTR pszPath,
    IBindCtx * pbc,
    LPITEMIDLIST *ppidlOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
SHGetIDispatchForFolder(
    LPCITEMIDLIST pidl,
    IWebBrowserApp **ppauto
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
ParseURLFromOutsideSourceW(
    LPCWSTR psz,
    LPWSTR pszOut,
    LPDWORD pcchOut,
    LPBOOL pbWasSearchURL
    )
{
    return FALSE;
}

static
SHDOCAPI_(IShellWindows *)
WinList_GetShellWindows(
    BOOL fForceMarshalled
    )
{
    return NULL;
}

static
SHDOCAPI_(IStream*)
SHGetViewStream(
    LPCITEMIDLIST pidl,
    DWORD grfMode,
    LPCWSTR pszName,
    LPCWSTR pszStreamMRU,
    LPCWSTR pszStreams
    )
{
    return NULL;
}

static
SHDOCAPI_(void)
IEOnFirstBrowserCreation(
    IUnknown* punkAuto
    )
{
}

static
SHDOCAPI_(DWORD)
SHRestricted2W(
    BROWSER_RESTRICTIONS rest,
    LPCWSTR pwzUrl,
    DWORD dwReserved
    )
{
    return 0;
}

static
SHDOCAPI
IEBindToObject(
    LPCITEMIDLIST pidl,
    IShellFolder **ppsfOut
    )
{
    *ppsfOut = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
IEGetAttributesOf(
    LPCITEMIDLIST pidl,
    DWORD* pdwAttribs
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
NavToUrlUsingIEW(
    LPCWSTR wszUrl,
    BOOL fNewWindow
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
URLSubLoadString(
    HINSTANCE hInst,
    UINT idRes,
    LPWSTR pszUrlOut, 
    DWORD cchSizeOut,
    DWORD dwSubstitutions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
IEParseDisplayNameWithBCW(
    UINT uiCP,
    LPCWSTR pwszPath,
    IBindCtx * pbc,
    LPITEMIDLIST * ppidlOut
    )
{
    *ppidlOut = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(DWORD)
SoftwareUpdateMessageBox(
    HWND hWnd,
    LPCWSTR szDistUnit,
    DWORD dwFlags,
    LPSOFTDISTINFO psdi
    )
{
    return IDABORT;
}

static
SHDOCAPI_(BOOL)
IsURLChild(
    LPCITEMIDLIST pidl,
    BOOL fIncludeHome
    )
{
    return FALSE;
}

static
SHDOCAPI_(void)
IEInvalidateImageList()
{
}

static
SHDOCAPI_(BOOL)
DoOrganizeFavDlgW(
    HWND hwnd,
    LPWSTR pszInitDir
    )
{
    return FALSE;
}

static
SHDOCAPI
URLSubstitution(
    LPCWSTR pszUrlIn,
    LPWSTR pszUrlOut,
    DWORD cchSize,
    DWORD dwSubstitutions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
SHDGetPageLocation(
    HWND hwndOwner,
    UINT idp,
    LPWSTR pszPath,
    UINT cchMax,
    LPITEMIDLIST *ppidlOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
ResetWebSettings(
    HWND hwnd,
    BOOL *pfChangedHomePage
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
SHIsRestricted2W(
    HWND hwnd,
    BROWSER_RESTRICTIONS rest,
    LPCWSTR pwzUrl,
    DWORD dwReserved
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
SHIsRegisteredClient(
    LPCWSTR pszClient
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
IsResetWebSettingsRequired()
{
    return FALSE;
}

static
SHSTDDOCAPI_(LPNMVIEWFOLDER)
DDECreatePostNotify(
    LPNMVIEWFOLDER lpnm
    )
{
    return NULL;
}

static
SHDOCAPI
IEGetDisplayName(
    LPCITEMIDLIST pidl,
    LPWSTR pszName,
    UINT uFlags
    )
{
    if (pszName)
    {
        *pszName = L'0';
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
WinList_FindFolderWindow(
    LPCITEMIDLIST pidl,
    LPCITEMIDLIST pidlRoot,
    HWND *phwnd,
    IWebBrowserApp **ppauto
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(void)
FireEvent_Quit(
    IExpDispSupport *peds
    )
{
}

static
SHSTDDOCAPI_(BOOL)
DDEHandleViewFolderNotify(
    IShellBrowser* psb,
    HWND hwnd,
    LPNMVIEWFOLDER lpnm
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
IEDDE_WindowDestroyed(
    HWND hwnd
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
IEDDE_NewWindow(
    HWND hwnd
    )
{
    return FALSE;
}

static
SHDOCAPI_(void)
EnsureWebViewRegSettings()
{
}

static
SHDOCAPI
WinList_RegisterPending(
    DWORD dwThread,
    LPCITEMIDLIST pidl,
    LPCITEMIDLIST pidlRoot,
    long *pdwRegister
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
WinList_NotifyNewLocation(
    IShellWindows* psw,
    long dwRegister,
    LPCITEMIDLIST pidl
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(void)
_DeletePidlDPA(
    HDPA hdpa
    )
{
}

static
SHDOCAPI_(BOOL)
IsIEDefaultBrowser()
{
    return TRUE;
}

static
SHDOCAPI_(BOOL)
PathIsFilePath(
    LPCWSTR lpszPath
    )
{
    return TRUE;
}

static
SHDOCAPI_(BOOL)
SHUseClassicToolbarGlyphs()
{
    return FALSE;
}

static
HRESULT
PrepareURLForDisplayUTF8W(
    LPCWSTR pwz,
    LPWSTR pwzOut,
    LPDWORD pcbOut,
    BOOL fUTF8Enabled
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
IsErrorUrl(
    LPCWSTR pwszDisplayName
    )
{
    return FALSE;
}

static
SHDOCAPI
CShellUIHelper_CreateInstance2(
    IUnknown** ppunk,
    REFIID riid, 
    IUnknown *pSite,
    IDispatch *pExternalDisp
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
GetLinkInfo(
    IShellFolder* psf,
    LPCITEMIDLIST pidlItem,
    BOOL* pfAvailable,
    BOOL* pfSticky
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(int)
IEMapPIDLToSystemImageListIndex(
    IShellFolder *psfParent,
    LPCITEMIDLIST pidlChild,
    int *piSelectedImage
    )
{
    return -1;
}

static
SHDOCAPI
CreateShortcutInDirW(
    IN LPCITEMIDLIST pidlTarget,
    IN LPWSTR pwzTitle,
    IN LPCWSTR pwzDir, 
    OUT LPWSTR pwzOut,
    IN BOOL bUpdateProperties)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
_GetStdLocation(
    LPWSTR pszPath,
    DWORD cchPathSize,
    UINT id
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
long
SetQueryNetSessionCount(
    enum SessionOp Op
    )
{
    return 0;
}

static
SHDOCAPI_(void)
IECleanUpAutomationObject()
{
}

static
SHDOCAPI_(BOOL)
IEILIsEqual(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2,
    BOOL fIgnoreHidden
    )
{
    return (pidl1 == pidl2);
}

static
SHDOCAPI_(BOOL)
GetDefaultInternetSearchUrlW(
    LPWSTR pwszUrl,
    int cchUrl,
    BOOL bSubstitute
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
GetSearchAssistantUrlW(
    LPWSTR pwszUrl,
    int cchUrl,
    BOOL bSubstitute,
    BOOL bCustomize
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
DllRegisterWindowClasses(
    const SHDRC * pshdrc
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
SHIsGlobalOffline()
{
    return FALSE;
}

static
SHDOCAPI
WinList_Revoke(
    long dwRegister
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
UrlHitsNetW(
    LPCWSTR pszURL
            )
{
    return TRUE;
}

static
SHDOCAPI
IURLQualify(
    LPCWSTR pcszURL,
    DWORD dwFlags,
    LPWSTR pszTranslatedURL,
    LPBOOL pbWasSearchURL,
    LPBOOL pbWasCorrected
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI
IEBindToObjectEx(
    LPCITEMIDLIST pidl,
    IBindCtx *pbc,
    REFIID riid,
    void **ppv
    )
{
    *ppv = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(BOOL)
IsFileUrl(
    LPCSTR psz
    )
{
    return FALSE;
}

static
SHDOCAPI
IEGetNameAndFlags(
    LPCITEMIDLIST pidl,
    UINT uFlags,
    LPWSTR pszName,
    DWORD cchName,
    DWORD *prgfInOutAttrs
    )
{
    if (pszName)
    {
        *pszName = 0;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHDOCAPI_(void)
IEWriteErrorLog(
    const EXCEPTION_RECORD* pexr
    )
{
}


static
SHDOCAPI_(BOOL)
SafeOpenPromptForShellExec(
    HWND hwnd,
    PCWSTR pszFile
    )
{
    return FALSE;
}

static
SHDOCAPI_(BOOL)
SafeOpenPromptForPackager(
    HWND hwnd,
    PCWSTR pszFile,
    BOOL bFromCommandLine
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shdocvw)
{
    DLOENTRY(103, CreateShortcutInDirW)
    DLOENTRY(116, DDECreatePostNotify)
    DLOENTRY(117, DDEHandleViewFolderNotify)
    DLOENTRY(135, IsFileUrl)
    DLOENTRY(137, PathIsFilePath)
    DLOENTRY(138, URLSubLoadString)
    DLOENTRY(139, OpenPidlOrderStream)
    DLOENTRY(140, DragDrop)
    DLOENTRY(141, IEInvalidateImageList)
    DLOENTRY(142, IEMapPIDLToSystemImageListIndex)
    DLOENTRY(143, ILIsWeb)
    DLOENTRY(145, IEGetAttributesOf)
    DLOENTRY(146, IEBindToObject)
    DLOENTRY(147, IEGetNameAndFlags)
    DLOENTRY(148, IEGetDisplayName)
    DLOENTRY(149, IEBindToObjectEx)
    DLOENTRY(150, _GetStdLocation)
    DLOENTRY(152, CShellUIHelper_CreateInstance2)
    DLOENTRY(153, IsURLChild)
    DLOENTRY(159, SHRestricted2W)
    DLOENTRY(160, SHIsRestricted2W)
    DLOENTRY(165, URLSubstitution)
    DLOENTRY(167, IsIEDefaultBrowser)
    DLOENTRY(170, ParseURLFromOutsideSourceW)
    DLOENTRY(171, _DeletePidlDPA)
    DLOENTRY(172, IURLQualify)
    DLOENTRY(174, SHIsGlobalOffline)
    DLOENTRY(176, EnsureWebViewRegSettings)
    DLOENTRY(177, WinList_NotifyNewLocation)
    DLOENTRY(178, WinList_FindFolderWindow)
    DLOENTRY(179, WinList_GetShellWindows)
    DLOENTRY(180, WinList_RegisterPending)
    DLOENTRY(181, WinList_Revoke)
    DLOENTRY(185, FireEvent_Quit)
    DLOENTRY(187, SHDGetPageLocation)
    DLOENTRY(191, SHIsRegisteredClient)
    DLOENTRY(194, IECleanUpAutomationObject)
    DLOENTRY(195, IEOnFirstBrowserCreation)
    DLOENTRY(196, IEDDE_WindowDestroyed)
    DLOENTRY(197, IEDDE_NewWindow)
    DLOENTRY(198, IsErrorUrl)
    DLOENTRY(200, SHGetViewStream)
    DLOENTRY(204, NavToUrlUsingIEW)
    DLOENTRY(210, UrlHitsNetW)
    DLOENTRY(212, GetLinkInfo)
    DLOENTRY(214, GetSearchAssistantUrlW)
    DLOENTRY(216, GetDefaultInternetSearchUrlW)
    DLOENTRY(218, IEParseDisplayNameWithBCW)
    DLOENTRY(219, IEILIsEqual)
    DLOENTRY(221, IECreateFromPathCPWithBCA)
    DLOENTRY(222, IECreateFromPathCPWithBCW)
    DLOENTRY(223, ResetWebSettings)
    DLOENTRY(224, IsResetWebSettingsRequired)
    DLOENTRY(225, PrepareURLForDisplayUTF8W)
    DLOENTRY(226, IEIsLinkSafe)
    DLOENTRY(227, SHUseClassicToolbarGlyphs)
    DLOENTRY(228, SafeOpenPromptForShellExec)
    DLOENTRY(229, SafeOpenPromptForPackager)
};

DEFINE_ORDINAL_MAP(shdocvw)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(shdocvw)
{
    DLPENTRY(DllRegisterWindowClasses)
    DLPENTRY(DoOrganizeFavDlgW)
    DLPENTRY(IEWriteErrorLog)
    DLPENTRY(SHGetIDispatchForFolder)
    DLPENTRY(SetQueryNetSessionCount)
    DLPENTRY(SoftwareUpdateMessageBox)
};

DEFINE_PROCNAME_MAP(shdocvw)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\shell32.c ===
#include "shellpch.h"
#pragma hdrstop

#define _SHELL32_
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>

#undef SHSTDAPI
#define SHSTDAPI        HRESULT STDAPICALLTYPE
#undef SHSTDAPI_
#define SHSTDAPI_(type) type STDAPICALLTYPE

static
WINSHELLAPI
UINT
WINAPI
ExtractIconExW (
    LPCWSTR lpszFile,
    int nIconIndex,
    HICON FAR *phiconLarge,
    HICON FAR *phiconSmall,
    UINT nIcons)
{
    return 0;
}

static
WINSHELLAPI
UINT
WINAPI
ExtractIconExA (
    LPCSTR lpszFile,
    int nIconIndex,
    HICON FAR *phiconLarge,
    HICON FAR *phiconSmall,
    UINT nIcons)
{
    return 0;
}

static
HINSTANCE
WINAPI
FindExecutableA (
    LPCSTR lpFile, 
    LPCSTR lpDirectory, 
    LPSTR lpResult
    )
{
    return 0;
}

static
HINSTANCE 
WINAPI
FindExecutableW (
    LPCWSTR lpFile, 
    LPCWSTR lpDirectory, 
    LPWSTR lpResult
    )
{
    return 0;
}

static
int
WINAPI
RestartDialog (
    HWND hParent,
    LPCTSTR lpPrompt,
    DWORD dwReturn
    )
{
    return IDNO;
}

static
int
WINAPI
RestartDialogEx (
    HWND hParent,
    LPCTSTR lpPrompt,
    DWORD dwReturn,
    DWORD ReasonCode
    )
{
    return IDNO;
}

static
LPITEMIDLIST
WINAPI
SHBrowseForFolderW (
    LPBROWSEINFOW lpbi
    )
{
    return NULL;
}

static
LPITEMIDLIST
WINAPI
SHBrowseForFolderA (
    LPBROWSEINFOA lpbi
    )
{
    return NULL;
}

static
void
STDAPICALLTYPE
SHChangeNotify(
    LONG wEventId,
    UINT uFlags,
    LPCVOID dwItem1,
    LPCVOID dwItem2)
{
}

static
HRESULT
STDAPICALLTYPE
SHGetFolderPathA (
    HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath
    )
{
    *pszPath = 0;
    return E_FAIL;
}

static
HRESULT
STDAPICALLTYPE
SHGetFolderPathW (
    HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath
    )
{
    *pszPath = 0;
    return E_FAIL;
}

static
HRESULT
STDAPICALLTYPE
SHGetMalloc (
    LPMALLOC * ppMalloc
    )
{
    return E_FAIL;
}

static
BOOL
STDAPICALLTYPE
SHGetPathFromIDListW (
    LPCITEMIDLIST   pidl,
    LPWSTR          pszPath
    )
{
    return FALSE;
}

static
BOOL
STDAPICALLTYPE
SHGetPathFromIDListA (
    LPCITEMIDLIST   pidl,
    LPSTR           pszPath
    )
{
    return FALSE;
}

static
HRESULT
STDAPICALLTYPE
SHGetSpecialFolderLocation (
    HWND hwnd,
    int csidl,
    LPITEMIDLIST *ppidl
    )
{
    return E_FAIL;
}

static
BOOL
STDAPICALLTYPE
SHGetSpecialFolderPathW(
    HWND hwnd,
    LPWSTR pszPath,
    int csidl,
    BOOL fCreate)
{
    return FALSE;
}

static
WINSHELLAPI
INT
WINAPI
ShellAboutW(
    HWND hwnd,
    LPCWSTR szApp,
    LPCWSTR szOtherStuff,
    HICON hIcon
    )
{
    return FALSE;
}

static
WINSHELLAPI
HINSTANCE
APIENTRY
ShellExecuteA (
    HWND hwnd,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    INT nShowCmd
    )
{
    return NULL;
}

static
WINSHELLAPI
BOOL
WINAPI
ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo)
{
    return FALSE;
}

static
WINSHELLAPI
BOOL
WINAPI
ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo)
{
    return FALSE;
}

static
WINSHELLAPI
HINSTANCE
APIENTRY
ShellExecuteW (
    HWND hwnd,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    INT nShowCmd
    )
{
    return NULL;
}

static
BOOL
WINAPI
LinkWindow_RegisterClass()
{
    return FALSE;
}

static
BOOL 
WINAPI 
LinkWindow_UnregisterClass(
    HINSTANCE hInst
    )
{
    return FALSE;
}

static
UINT
WINAPI
DragQueryFileA(
    HDROP hDrop,
    UINT wFile,
    LPSTR lpFile,
    UINT cb
    )
{
    return wFile;
}

static
UINT
WINAPI
DragQueryFileW(
    HDROP hDrop,
    UINT wFile,
    LPWSTR lpFile,
    UINT cb
    )
{
    return wFile;
}

static
HRESULT
WINAPI
SHDefExtractIconA(
    LPCSTR pszIconFile,
    int iIndex,
    UINT uFlags,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
SHDefExtractIconW(
    LPCWSTR pszIconFile,
    int iIndex,
    UINT uFlags,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
SHGetNewLinkInfoA(
    LPCSTR pszLinkTo,
    LPCSTR pszDir,
    LPSTR pszName,
    BOOL* pfMustCopy,
    UINT uFlags
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SHGetNewLinkInfoW(
    LPCWSTR pszLinkTo,
    LPCWSTR pszDir,
    LPWSTR pszName,
    BOOL* pfMustCopy,
    UINT uFlags
    )
{
    return FALSE;
}

static
HICON
WINAPI
ExtractIconA(
    HINSTANCE hInst,
    LPCSTR lpszExeFileName,
    UINT nIconIndex
    )
{
    return NULL;
}

static
HICON
WINAPI
ExtractIconW(
    HINSTANCE hInst,
    LPCWSTR lpszExeFileName,
    UINT nIconIndex
    )
{
    return NULL;
}

static
DWORD_PTR
WINAPI
SHGetFileInfoA(
    LPCSTR pszPath,
    DWORD dwFileAttributes,
    SHFILEINFOA *psfi,
    UINT cbFileInfo,
    UINT uFlags
    )
{
    return 0;
}

static
DWORD_PTR
WINAPI
SHGetFileInfoW(
    LPCWSTR pszPath,
    DWORD dwFileAttributes,
    SHFILEINFOW *psfi,
    UINT cbFileInfo,
    UINT uFlags
    )
{
    return 0;
}

static
DWORD
WINAPI
SHFormatDrive(
    HWND hwnd,
    UINT drive,
    UINT fmtID,
    UINT options
    )
{
    return SHFMT_ERROR;
}

static
int
WINAPI
DriveType(
    int iDrive
    )
{
    return DRIVE_UNKNOWN;
}

static
int
WINAPI
RealDriveType(
    int iDrive,
    BOOL fOKToHitNet
    )
{
    return DRIVE_UNKNOWN;
}

static
void
WINAPI
ILFree(
    LPITEMIDLIST pidl
    )
{
}

static
LPITEMIDLIST
WINAPI
ILClone(
    LPCITEMIDLIST pidl
    )
{
    return NULL;
}

static
BOOL
WINAPI
ILIsEqual(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    )
{
    return (pidl1 == pidl2);
}

static
HRESULT
WINAPI
SHGetDesktopFolder(
    IShellFolder** ppshf
    )
{
    *ppshf = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
int
WINAPI
Shell_GetCachedImageIndex(
    LPCTSTR pszIconPath,
    int iIconIndex,
    UINT uIconFlags
    )
{
    return -1;
}

static
int
WINAPI
SHFileOperationA(
    LPSHFILEOPSTRUCTA lpFileOp
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
int
WINAPI
SHFileOperationW(
    LPSHFILEOPSTRUCTW lpFileOp
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
int
WINAPI
IsNetDrive(
    int iDrive
    )
{
    return 0;
}

static
UINT
WINAPI
ILGetSize(
    LPCITEMIDLIST pidl
    )
{
    return 0;
}

static
void
WINAPI
SHFlushSFCache()
{
}

static
HRESULT
WINAPI
SHCoCreateInstance(
    LPCTSTR pszCLSID,
    const CLSID *pclsid,
    IUnknown *pUnkOuter,
    REFIID riid,
    void** ppv
    )
{
    *ppv = NULL;
    return E_FAIL;
}

static
HRESULT
WINAPI
SHGetInstanceExplorer(
    IUnknown** ppunk
    )
{
    *ppunk = NULL;
    return E_FAIL;
}

static
HRESULT
WINAPI
SHGetDataFromIDListW(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    int nFormat,
    void* pv,
    int cb
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
SHBindToParent(
    LPCITEMIDLIST pidl,
    REFIID riid,
    void** ppv,
    LPCITEMIDLIST* ppidlLast
    )
{
    *ppv = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(void)
SHFree(
    void* pv
    )
{
}

static
SHSTDAPI_(void)
SHGetSetSettings(
    LPSHELLSTATE lpss,
    DWORD dwMask,
    BOOL bSet
    )
{
    ZeroMemory(lpss, sizeof(SHELLSTATE));
}

static
SHSTDAPI_(BOOL)
Shell_GetImageLists(
    HIMAGELIST *phiml,
    HIMAGELIST *phimlSmall
    )
{
    if (phiml)
    {
        *phiml = NULL;
    }

    if (phimlSmall)
    {
        *phimlSmall = NULL;
    }

    return FALSE;
}

static
SHSTDAPI_(BOOL) 
Shell_NotifyIconW(
    DWORD dwMessage, 
    NOTIFYICONDATAW *pnid
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_DragEnterEx2(
    HWND hwndTarget,
    const POINT ptStart,
    IDataObject *pdtObject
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_DragMove(
    POINT pt
    )
{
    return FALSE;
}

static
SHSTDAPI
SHGetDataFromIDListA(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    int nFormat,
    void* pv,
    int cb
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(LPITEMIDLIST)
ILCombine(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    )
{
    return NULL;
}

static
SHSTDAPI
SHDoDragDrop(
    HWND hwnd,
    IDataObject *pdata,
    IDropSource *pdsrc,
    DWORD dwEffect,
    DWORD *pdwEffect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHLoadOLE(
    LPARAM lParam
    )
{
    return S_OK;
}

static
SHSTDAPI_(void)
SHSetInstanceExplorer(
    IUnknown *punk
    )
{
}

static
SHSTDAPI
SHCreateStdEnumFmtEtc(
    UINT cfmt,
    const FORMATETC afmt[],
    IEnumFORMATETC **ppenumFormatEtc
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
ILLoadFromStream(
    IStream *pstm,
    LPITEMIDLIST *pidl
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(UINT)
Shell_MergeMenus(
    HMENU hmDst,
    HMENU hmSrc,
    UINT uInsert,
    UINT uIDAdjust,
    UINT uIDAdjustMax,
    ULONG uFlags
    )
{
    return uIDAdjust;
}

static 
SHSTDAPI_(LPITEMIDLIST)
ILCloneFirst(
    LPCITEMIDLIST pidl
    )
{
    return NULL;
}

static
SHSTDAPI_(DWORD)
SHRestricted(
    RESTRICTIONS rest
    )
{
    return 0;
}

static
SHSTDAPI
SHStartNetConnectionDialogW(
    HWND hwnd,
    LPCWSTR pszRemoteName,
    DWORD dwType
    )
{
    return S_OK;
}

static
SHSTDAPI_(BOOL)
SHChangeNotifyDeregister(
    unsigned long ulID
    )
{
    return FALSE;
}

static
SHSTDAPI
SHFlushClipboard()
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(LPITEMIDLIST)
ILFindChild(
    LPCITEMIDLIST pidlParent, 
    LPCITEMIDLIST pidlChild
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
ILIsParent(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2,
    BOOL fImmediate
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
ILRemoveLastID(
    LPITEMIDLIST pidl
    )
{
    return FALSE;
}

static
SHSTDAPI_(IContextMenu*)
SHFind_InitMenuPopup(
    HMENU hmenu,
    HWND hwndOwner,
    UINT idCmdFirst,
    UINT idCmdLast
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
SHChangeNotification_Unlock(
    HANDLE hLock
    )
{
    return FALSE;
}

static
SHSTDAPI_(HANDLE)
SHChangeNotification_Lock(
    HANDLE hChangeNotification,
    DWORD dwProcessId,
    LPITEMIDLIST **pppidl,
    LONG *plEvent
    )
{
    return NULL;
}

static
SHSTDAPI
SHGetRealIDL(
    IShellFolder *psf,
    LPCITEMIDLIST pidlSimple,
    LPITEMIDLIST * ppidlReal
    )
{
    *ppidlReal = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
ILSaveToStream(
    IStream *pstm,
    LPCITEMIDLIST pidl
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(BOOL)
DAD_ShowDragImage(
    BOOL fShow
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
SignalFileOpen(
    LPCITEMIDLIST pidl
    )
{
    return FALSE;
}

static
SHSTDAPI_(int)
SHMapPIDLToSystemImageListIndex(
    IShellFolder *pshf,
    LPCITEMIDLIST pidl,
    int *piIndexSel
    )
{
    return -1;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILGetNext(
    LPCITEMIDLIST pidl
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
PathIsExe(
    LPCTSTR pszPath
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_DragLeave()
{
    return FALSE;
}

static
SHSTDAPI_(UINT_PTR)
SHAppBarMessage(
    DWORD dwMessage,
    PAPPBARDATA pData
    )
{
    return FALSE;
}

static
SHSTDAPI_(HICON)
ExtractAssociatedIconExW(
     HINSTANCE hInst,
     LPWSTR lpIconPath,
     LPWORD lpiIconIndex,
     LPWORD lpiIconId
     )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
DAD_AutoScroll(
    HWND hwnd,
    AUTO_SCROLL_DATA *pad,
    const POINT *pptNow
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_SetDragImage(
    HIMAGELIST him,
    POINT * pptOffset
    )
{
    return TRUE;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILAppendID(
    LPITEMIDLIST pidl,
    LPCSHITEMID pmkid,
    BOOL fAppend
    )
{
    return NULL;
}

static
SHSTDAPI_(int)
SHHandleUpdateImage(
    LPCITEMIDLIST pidlExtra
    )
{
    return -1;
}

static
SHSTDAPI_(LPITEMIDLIST)
SHCloneSpecialIDList(
    HWND hwnd,
    int csidl,
    BOOL fCreate
    )
{
    return NULL;
}

static
SHSTDAPI_(INT)
ShellAboutA(
    HWND hWnd,
    LPCSTR szApp,
    LPCSTR szOtherStuff,
    HICON hIcon
    )
{
    return 0;
}

static
SHSTDAPI_(int)
SHCreateDirectory(
    HWND hwnd,
    LPCTSTR pszPath
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
SHSTDAPI_(int)
PathCleanupSpec(
    LPCTSTR pszDir,
    LPTSTR pszSpec
    )
{
    return 0;
}

static
SHSTDAPI_(void *)
SHAlloc(
    SIZE_T cb
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
ReadCabinetState(
    LPCABINETSTATE lpState,
    int iSize
    )
{
    return FALSE;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILCreateFromPathA(
    LPCSTR pszPath
    )
{
    return NULL;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILCreateFromPathW(
    LPCWSTR pszPath
    )
{
    return NULL;
}

static
SHSTDAPI_(LPITEMIDLIST)
ILFindLastID(
    LPCITEMIDLIST pidl
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
WriteCabinetState(
    LPCABINETSTATE lpState
    )
{
    return FALSE;
}

static
SHSTDAPI_(void)
SHUpdateImageW(
    LPCWSTR pszHashItem,
    int iIndex,
    UINT uFlags,
    int iImageIndex
    )
{
}

static
SHSTDAPI
SHLimitInputEdit(
    HWND hwndEdit,
    IShellFolder *psf
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHPathPrepareForWriteW(
    HWND hwnd,
    IUnknown *punkEnableModless,
    LPCWSTR pszPath,
    DWORD dwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHLoadInProc(
    REFCLSID rclsid
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(LONG)
PathProcessCommand(
    LPCTSTR lpSrc,
    LPTSTR lpDest,
    int iMax,
    DWORD dwFlags
    )
{
    return -1;
}

static
WINSHELLAPI
HRESULT
STDAPICALLTYPE
SHCLSIDFromString(
    LPCTSTR lpsz,
    LPCLSID lpclsid
    )
{
    ZeroMemory(lpclsid, sizeof(CLSID));
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI
SHILCreateFromPath(
    LPCTSTR szPath,
    LPITEMIDLIST *ppidl,
    DWORD *rgfInOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(LPITEMIDLIST)
SHSimpleIDListFromPath(
    LPCTSTR pszPath
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
GetFileNameFromBrowse(
    HWND hwnd,
    LPTSTR pszFilePath,
    UINT cbFilePath,
    LPCTSTR pszWorkingDir,
    LPCTSTR pszDefExt,
    LPCTSTR pszFilters,
    LPCTSTR pszTitle
    )
{
    return FALSE;
}

static
SHSTDAPI_(IStream*)
OpenRegStream(
    HKEY hkey,
    LPCTSTR pszSubkey,
    LPCTSTR pszValue,
    DWORD grfMode
    )
{
    return NULL;
}

static
SHSTDAPI_(BOOL)
PathYetAnotherMakeUniqueName(
    LPTSTR pszUniqueName,
    LPCTSTR pszPath,
    LPCTSTR pszShort,
    LPCTSTR pszFileSpec
    )
{
    return FALSE;
}

static
WINSHELLAPI
int
WINAPI
PickIconDlg(
    HWND hwnd,
    LPTSTR pszIconPath,
    UINT cbIconPath,
    int *piIconIndex
    )
{
    return 0;
}

static
SHSTDAPI_(LRESULT)
SHShellFolderView_Message(
    HWND hwndMain,
    UINT uMsg,
    LPARAM lParam
    )
{
    return 0;
}

static
SHSTDAPI
SHCreateShellFolderViewEx(
    LPCSFV pcsfv,
    IShellView** ppsv
    )
{
    *ppsv = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
SHSTDAPI_(BOOL)
SHFindFiles(
    LPCITEMIDLIST pidlFolder,
    LPCITEMIDLIST pidlSaveFile
    )
{
    return FALSE;
}

static
SHSTDAPI_(BOOL)
DAD_DragEnterEx(
    HWND hwndTarget,
    const POINT ptStart
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shell32)
{
    DLOENTRY(3, SHDefExtractIconA)
    DLOENTRY(4, SHChangeNotifyDeregister)
    DLOENTRY(6, SHDefExtractIconW)
    DLOENTRY(14, SHStartNetConnectionDialogW)
    DLOENTRY(16, ILFindLastID)
    DLOENTRY(17, ILRemoveLastID)
    DLOENTRY(18, ILClone)
    DLOENTRY(19, ILCloneFirst)
    DLOENTRY(21, ILIsEqual)
    DLOENTRY(22, DAD_DragEnterEx2)
    DLOENTRY(23, ILIsParent)
    DLOENTRY(24, ILFindChild)
    DLOENTRY(25, ILCombine)
    DLOENTRY(26, ILLoadFromStream)
    DLOENTRY(27, ILSaveToStream)
    DLOENTRY(28, SHILCreateFromPath)
    DLOENTRY(43, PathIsExe)
    DLOENTRY(59, RestartDialog)
    DLOENTRY(62, PickIconDlg)
    DLOENTRY(63, GetFileNameFromBrowse)
    DLOENTRY(64, DriveType)
    DLOENTRY(66, IsNetDrive)
    DLOENTRY(67, Shell_MergeMenus)
    DLOENTRY(68, SHGetSetSettings)
    DLOENTRY(71, Shell_GetImageLists)
    DLOENTRY(72, Shell_GetCachedImageIndex)
    DLOENTRY(73, SHShellFolderView_Message)
    DLOENTRY(74, SHCreateStdEnumFmtEtc)
    DLOENTRY(75, PathYetAnotherMakeUniqueName)
    DLOENTRY(77, SHMapPIDLToSystemImageListIndex)
    DLOENTRY(85, OpenRegStream)
    DLOENTRY(88, SHDoDragDrop)
    DLOENTRY(89, SHCloneSpecialIDList)
    DLOENTRY(90, SHFindFiles)
    DLOENTRY(98, SHGetRealIDL)
    DLOENTRY(100, SHRestricted)
    DLOENTRY(102, SHCoCreateInstance)
    DLOENTRY(103, SignalFileOpen)
    DLOENTRY(121, SHFlushClipboard)
    DLOENTRY(129, DAD_AutoScroll)
    DLOENTRY(131, DAD_DragEnterEx)
    DLOENTRY(132, DAD_DragLeave)
    DLOENTRY(134, DAD_DragMove)
    DLOENTRY(136, DAD_SetDragImage)
    DLOENTRY(137, DAD_ShowDragImage)
    DLOENTRY(147, SHCLSIDFromString)
    DLOENTRY(149, SHFind_InitMenuPopup)
    DLOENTRY(151, SHLoadOLE)
    DLOENTRY(152, ILGetSize)
    DLOENTRY(153, ILGetNext)
    DLOENTRY(154, ILAppendID)
    DLOENTRY(155, ILFree)
    DLOENTRY(157, ILCreateFromPathW)
    DLOENTRY(162, SHSimpleIDListFromPath)
    DLOENTRY(165, SHCreateDirectory)
    DLOENTRY(171, PathCleanupSpec)
    DLOENTRY(174, SHCreateShellFolderViewEx)
    DLOENTRY(175, SHGetSpecialFolderPathW)
    DLOENTRY(176, SHSetInstanceExplorer)
    DLOENTRY(179, SHGetNewLinkInfoA)
    DLOENTRY(180, SHGetNewLinkInfoW)
    DLOENTRY(189, ILCreateFromPathA)
    DLOENTRY(190, ILCreateFromPathW)
    DLOENTRY(192, SHUpdateImageW)
    DLOENTRY(193, SHHandleUpdateImage)
    DLOENTRY(195, SHFree)
    DLOENTRY(196, SHAlloc)
    DLOENTRY(258, LinkWindow_RegisterClass)
    DLOENTRY(259, LinkWindow_UnregisterClass)
    DLOENTRY(524, RealDriveType)
    DLOENTRY(526, SHFlushSFCache)
    DLOENTRY(644, SHChangeNotification_Lock)
    DLOENTRY(645, SHChangeNotification_Unlock)
    DLOENTRY(652, WriteCabinetState)
    DLOENTRY(653, PathProcessCommand)
    DLOENTRY(654, ReadCabinetState)
    DLOENTRY(730, RestartDialogEx)
    DLOENTRY(747, SHLimitInputEdit)
};

DEFINE_ORDINAL_MAP(shell32)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(shell32)
{
    DLPENTRY(DragQueryFileA)
    DLPENTRY(DragQueryFileW)
    DLPENTRY(ExtractAssociatedIconExW)
    DLPENTRY(ExtractIconA)
    DLPENTRY(ExtractIconExA)
    DLPENTRY(ExtractIconExW)
    DLPENTRY(ExtractIconW)
    DLPENTRY(FindExecutableA)
    DLPENTRY(FindExecutableW)
    DLPENTRY(SHAppBarMessage)
    DLPENTRY(SHBindToParent)
    DLPENTRY(SHBrowseForFolderA)
    DLPENTRY(SHBrowseForFolderW)
    DLPENTRY(SHChangeNotify)
    DLPENTRY(SHFileOperationA)
    DLPENTRY(SHFileOperationW)
    DLPENTRY(SHFormatDrive)
    DLPENTRY(SHGetDataFromIDListA)
    DLPENTRY(SHGetDataFromIDListW)
    DLPENTRY(SHGetDesktopFolder)
    DLPENTRY(SHGetFileInfoA)
    DLPENTRY(SHGetFileInfoW)
    DLPENTRY(SHGetFolderPathA)
    DLPENTRY(SHGetFolderPathW)
    DLPENTRY(SHGetInstanceExplorer)
    DLPENTRY(SHGetMalloc)
    DLPENTRY(SHGetPathFromIDListA)
    DLPENTRY(SHGetPathFromIDListW)
    DLPENTRY(SHGetSpecialFolderLocation)
    DLPENTRY(SHGetSpecialFolderPathW)
    DLPENTRY(SHLoadInProc)
    DLPENTRY(SHPathPrepareForWriteW)
    DLPENTRY(ShellAboutA)
    DLPENTRY(ShellAboutW)
    DLPENTRY(ShellExecuteA)
    DLPENTRY(ShellExecuteExA)
    DLPENTRY(ShellExecuteExW)
    DLPENTRY(ShellExecuteW)
    DLPENTRY(Shell_NotifyIconW)
};

DEFINE_PROCNAME_MAP(shell32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\shellpch.h ===
#pragma once

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4211) // nonstandard extension used : redefined extern to static


#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\badapps.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    badapp.h

Abstract:

    Declares the structures used for CheckBadApps data.

Author:

    Calin Negreanu (calinn) 01/20/1999

Revision History:

--*/

#pragma once

#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSIONSUB    0x00000005
#define APPTYPE_SHIM          0x00000006

#define APPTYPE_FLAG_MASK     0xFFFFFF00

#define APPTYPE_FLAG_NONET    0x00000100
#define APPTYPE_FLAG_FAT32    0x00000200
#define APPTYPE_FLAG_NTFS     0x00000400

typedef struct {
    DWORD Size;
    DWORD MsgId;
    DWORD AppType;
} BADAPP_PROP, *PBADAPP_PROP;

typedef struct {
    DWORD Size;
    PCTSTR FilePath;
    PBYTE Blob;
    DWORD BlobSize;
} BADAPP_DATA, *PBADAPP_DATA;

BOOL
SHIsBadApp (
    IN      PBADAPP_DATA Data,
    OUT     PBADAPP_PROP Prop
    );

#define EDIT    TRUE
#define NOEDIT  FALSE

// version allowances
#define VA_ALLOWMAINFILE     0x01
#define VA_ALLOWADDNLFILES   0x02

#define VA_ALLOWALLFILES     0x03

//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,
    VTID_PREVOSMAJORVERSION = VTID_REQFILE +21,
    VTID_PREVOSMINORVERSION = VTID_REQFILE +22,
    VTID_PREVOSPLATFORMID   = VTID_REQFILE +23,
    VTID_PREVOSBUILDNO      = VTID_REQFILE +24,

    // add new versions here

    VTID_LASTID
};

#define VERSION_STAMPS \
    LIBARGS(VTID_FILESIZE, ShCheckFileSize) \
    TOOLARGS(TEXT("FILESIZE"), TEXT("File Size:"), VA_ALLOWALLFILES, NOEDIT, QueryFileSize, OutputHexValue)\
    \
    LIBARGS(VTID_EXETYPE, ShCheckModuleType) \
    TOOLARGS(TEXT("EXETYPE"), TEXT("Module Type:"), VA_ALLOWADDNLFILES, NOEDIT, QueryModuleType, OutputModuleTypeValue)\
    \
    LIBARGS(VTID_BINFILEVER, ShCheckBinFileVer) \
    TOOLARGS(TEXT("BINFILEVER"), TEXT("Binary File Version:"), VA_ALLOWALLFILES, EDIT, QueryBinFileVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_BINPRODUCTVER, ShCheckBinProductVer) \
    TOOLARGS(TEXT("BINPRODUCTVER"), TEXT("Binary Product Version:"), VA_ALLOWALLFILES, EDIT, QueryBinProductVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_FILEDATEHI, ShCheckFileDateHi) \
    TOOLARGS(TEXT("FILEDATEHI"), TEXT("File Date (HI):"), VA_ALLOWALLFILES, NOEDIT, QueryFileDateHi, OutputHexValue)\
    \
    LIBARGS(VTID_FILEDATELO, ShCheckFileDateLo) \
    TOOLARGS(TEXT("FILEDATELO"), TEXT("File Date (LO):"), VA_ALLOWALLFILES, NOEDIT, QueryFileDateLo, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVEROS, ShCheckFileVerOs) \
    TOOLARGS(TEXT("FILEVEROS"), TEXT("File OS Version:"), VA_ALLOWALLFILES, NOEDIT, QueryFileVerOs, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVERTYPE, ShCheckFileVerType) \
    TOOLARGS(TEXT("FILEVERTYPE"), TEXT("File Type:"), VA_ALLOWALLFILES, NOEDIT, QueryFileVerType, OutputHexValue)\
    \
    LIBARGS(VTID_CHECKSUM, ShCheckFileCheckSum) \
    TOOLARGS(TEXT("CHECKSUM"), TEXT("File CheckSum:"), VA_ALLOWALLFILES, NOEDIT, QueryFileCheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_PECHECKSUM, ShCheckFilePECheckSum) \
    TOOLARGS(TEXT("PECHECKSUM"), TEXT("File Header CheckSum:"), VA_ALLOWALLFILES, NOEDIT, QueryFilePECheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_COMPANYNAME, ShCheckCompanyName) \
    TOOLARGS(TEXT("COMPANYNAME"), TEXT("Company Name:"), VA_ALLOWALLFILES, EDIT, QueryCompanyName, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTVERSION, ShCheckProductVersion) \
    TOOLARGS(TEXT("PRODUCTVERSION"), TEXT("Product Version:"), VA_ALLOWALLFILES, EDIT, QueryProductVersion, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTNAME, ShCheckProductName) \
    TOOLARGS(TEXT("PRODUCTNAME"), TEXT("Product Name:"), VA_ALLOWALLFILES, EDIT, QueryProductName, OutputStrValue)\
    \
    LIBARGS(VTID_FILEDESCRIPTION, ShCheckFileDescription) \
    TOOLARGS(TEXT("FILEDESCRIPTION"), TEXT("File Description:"), VA_ALLOWALLFILES, EDIT, QueryFileDescription, OutputStrValue)\
    \
    LIBARGS(VTID_FILEVERSION, ShCheckFileVersion) \
    TOOLARGS(TEXT("FILEVERSION"), TEXT("File Version:"), VA_ALLOWALLFILES, EDIT, QueryFileVersion, OutputStrValue)\
    \
    LIBARGS(VTID_ORIGINALFILENAME, ShCheckOriginalFileName) \
    TOOLARGS(TEXT("ORIGINALFILENAME"), TEXT("Original File Name:"), VA_ALLOWALLFILES, EDIT, QueryOriginalFileName, OutputStrValue)\
    \
    LIBARGS(VTID_INTERNALNAME, ShCheckInternalName) \
    TOOLARGS(TEXT("INTERNALNAME"), TEXT("Internal Name:"), VA_ALLOWALLFILES, EDIT, QueryInternalName, OutputStrValue)\
    \
    LIBARGS(VTID_LEGALCOPYRIGHT, ShCheckLegalCopyright) \
    TOOLARGS(TEXT("LEGALCOPYRIGHT"), TEXT("Legal Copyright:"), VA_ALLOWALLFILES, EDIT, QueryLegalCopyright, OutputStrValue)\
    \
    LIBARGS(VTID_16BITDESCRIPTION, ShCheck16BitDescription) \
    TOOLARGS(TEXT("DESCRIPTION"), TEXT("16 Bit Description:"), VA_ALLOWALLFILES, EDIT, Query16BitDescription, OutputStrValue)\
    \
    LIBARGS(VTID_UPTOBINPRODUCTVER, ShCheckUpToBinProductVer) \
    TOOLARGS(TEXT("UPTOBINPRODUCTVER"), TEXT("Up To Binary Product Version:"), VA_ALLOWALLFILES, EDIT, QueryBinProductVer, OutputUpToBinVerValue)\
    \
    LIBARGS(VTID_PREVOSMAJORVERSION, ShCheckPrevOsMajorVersion) \
    TOOLARGS(TEXT("PREVOSMAJORVERSION"), TEXT("Previous OS Major Version:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsMajorVersion, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSMINORVERSION, ShCheckPrevOsMinorVersion) \
    TOOLARGS(TEXT("PREVOSMINORVERSION"), TEXT("Previous OS Minor Version:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsMinorVersion, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSPLATFORMID, ShCheckPrevOsPlatformId) \
    TOOLARGS(TEXT("PREVOSPLATFORMID"), TEXT("Previous OS Platform Id:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsPlatformId, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSBUILDNO, ShCheckPrevOsBuildNo) \
    TOOLARGS(TEXT("PREVOSBUILDNR"), TEXT("Previous OS Build No:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsBuildNo, OutputDecValue)\
    \

#define S_KEY_PREVOSVERSION     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\PrevOsVersion")
#define S_VAL_BUILDNO           TEXT("BuildNumber")
#define S_VAL_MAJORVERSION      TEXT("MajorVersion")
#define S_VAL_MINORVERSION      TEXT("MinorVersion")
#define S_VAL_PLATFORMID        TEXT("PlatformId")

#define S_VER_COMPANYNAME       TEXT("CompanyName")
#define S_VER_PRODUCTVERSION    TEXT("ProductVersion")
#define S_VER_PRODUCTNAME       TEXT("ProductName")
#define S_VER_FILEDESCRIPTION   TEXT("FileDescription")
#define S_VER_FILEVERSION       TEXT("FileVersion")
#define S_VER_ORIGINALFILENAME  TEXT("OriginalFileName")
#define S_VER_INTERNALNAME      TEXT("InternalName")
#define S_VER_LEGALCOPYRIGHT    TEXT("LegalCopyright")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\shlwapi.c ===
#include "shellpch.h"
#pragma hdrstop


static
LPTSTR
STDAPICALLTYPE
PathFindFileNameW(
    LPCTSTR pPath
    )
{
    return (LPTSTR)pPath;
}

static
HRESULT STDAPICALLTYPE
SHAutoComplete(HWND hwndEdit, DWORD dwFlags)
{
    return E_FAIL;
}

static
BOOL
WINAPI
SHGetFileDescriptionW(
    LPCWSTR pszPath,
    LPCWSTR pszVersionKeyIn,
    LPCWSTR pszCutListIn,
    LPWSTR pszDesc,
    UINT *pcchDesc
    )
{
    return FALSE;
}

static
LPWSTR
StrCatW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    return pszDst;
}

static
HRESULT STDAPICALLTYPE
UrlCanonicalizeW(
    LPCWSTR pszUrl,
    LPWSTR pszCanonicalized,
    LPDWORD pcchCanonicalized,
    DWORD dwFlags
    )
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shlwapi)
{
    DLOENTRY(348, SHGetFileDescriptionW)
};

DEFINE_ORDINAL_MAP(shlwapi)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(shlwapi)
{
    DLPENTRY(PathFindFileNameW)
    DLPENTRY(SHAutoComplete)
    DLPENTRY(StrCatW)
    DLPENTRY(UrlCanonicalizeW)
};

DEFINE_PROCNAME_MAP(shlwapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\shsvcs.c ===
#include "shellpch.h"
#pragma hdrstop

static
BOOL
WINAPI
ThemeWatchForStart (
    void
    )

{
    return FALSE;
}

static
DWORD
WINAPI
ThemeWaitForServiceReady (
    DWORD dwTimeout
    )

{
    return WAIT_TIMEOUT;
}

static
BOOL
WINAPI
ThemeUserLogoff (
    void
    )

{
    return FALSE;
}

static
BOOL
WINAPI
ThemeUserLogon (
    HANDLE hToken
    )

{
    return FALSE;
}

static
BOOL
WINAPI
ThemeUserStartShell (
    void
    )

{
    return FALSE;
}

static
BOOL
WINAPI
ThemeUserTSReconnect (
    void
    )

{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(shsvcs)
{
    DLOENTRY(1,ThemeWatchForStart)
    DLOENTRY(2,ThemeWaitForServiceReady)
    DLOENTRY(3,ThemeUserLogoff)
    DLOENTRY(4,ThemeUserLogon)
    DLOENTRY(5,ThemeUserStartShell)
    DLOENTRY(6,ThemeUserTSReconnect)
};

DEFINE_ORDINAL_MAP(shsvcs)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\cplext.h ===
///////////////////////////////////////////////////////////////////////////////
//
// CPLEXT.H  --  defines for property sheet extensions to system control panels
//
// Version 4.00
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _INC_CPLEXT
#define _INC_CPLEXT


///////////////////////////////////////////////////////////////////////////////
//  Below are constants for pages which can be replaced in the standard control
// panel applets.  To extend an applet, you must define an object which
// supports the IShellPropSheetExt interface and register it's in-process
// server in a subkey under the applet's registry key.  Registry paths for the
// applets are defined in the header file REGSTR.H
//  Generally, when an IShellPropSheetExt is loaded, it's AddPages method
// will be called once, while it's ReplacePage method may be called zero or
// more times.  ReplacePage is only called in context.
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Mouse Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Mouse" )
//-----------------------------------------------------------------------------

#define CPLPAGE_MOUSE_BUTTONS       1
#define CPLPAGE_MOUSE_PTRMOTION     2
#define CPLPAGE_MOUSE_WHEEL         3


//-----------------------------------------------------------------------------
// Keyboard Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Keyboard" )
//-----------------------------------------------------------------------------

#define CPLPAGE_KEYBOARD_SPEED      1


//-----------------------------------------------------------------------------
// Display Control Panel Extensions
// The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
// uPageID parameter for servers registered under
//                                  ( REGSTR_PATH_CONTROLSFOLDER "\\Display" )
//-----------------------------------------------------------------------------

#define CPLPAGE_DISPLAY_BACKGROUND  1


///////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\uxtheme.c ===
#include "shellpch.h"
#pragma hdrstop

#define _UXTHEME_
#include <uxtheme.h>
#include <uxthemep.h>

#undef THEMEAPI_
#define THEMEAPI_(type)     type STDAPICALLTYPE

#undef THEMEAPI
#define THEMEAPI            HRESULT STDAPICALLTYPE

static
HRESULT
WINAPI
ApplyTheme(
    HTHEMEFILE hThemeFile, 
    DWORD dwApplyFlags,
    HWND hwndTarget
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CloseThemeData(
    HTHEME hTheme
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CloseThemeFile(
    HTHEMEFILE hThemeFile
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
DrawNCPreview(
    HDC hdc,
    DWORD dwFlags,
    LPRECT prc,
    LPCWSTR pszVSPath,
    LPCWSTR pszVSColor,
    LPCWSTR pszVSSize,
    NONCLIENTMETRICS* pncm,
    COLORREF* prgb
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnumThemes(
    LPCWSTR pszThemeRoot,
    THEMEENUMPROC lpEnumFunc,
    LPARAM lParam
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnumThemeColors(
    LPCWSTR pszThemeName,
    LPCWSTR pszSizeName,
    DWORD dwColorIndex,
    THEMENAMEINFO *ptn
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnumThemeSizes(
    LPCWSTR pszThemeName,
    LPCWSTR pszColorScheme,
    DWORD dwSizeIndex,
    THEMENAMEINFO *ptn
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
GetCurrentThemeName(
    LPWSTR pszNameBuff,
    int cchMaxNameChars,
    LPWSTR pszColorBuff,
    int cchMaxColorChars,
    LPWSTR pszSizeBuff,
    int cchMaxSizeChars
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnableTheming(
    BOOL fEnable
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeDefaults(
    LPCWSTR pszThemeName,
    LPWSTR pszDefaultColor,
    int cchMaxColorChars,
    LPWSTR pszDefaultSize,
    int cchMaxSizeChars
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeDocumentationProperty(
    LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName,
    LPWSTR pszValueBuff,
    int cchMaxValChars
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
GetThemeSysString(
    HTHEME hTheme,
    int iStringId,
    LPWSTR pszStringBuff,
    int cchMaxStringChars
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
COLORREF
WINAPI
GetThemeSysColor(
    HTHEME hTheme,
    int iColorId
    )
{
    return 0x000000;
}


static
HBRUSH
WINAPI
GetThemeSysColorBrush(
    HTHEME hTheme,
    int iColorId
    )
{
    return NULL;
}

static
HRESULT
WINAPI
GetThemeSysInt(
    HTHEME hTheme,
    int iIntId,
    int *piValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
GetThemeSysBool(
    HTHEME hTheme,
    int iBoolId
    )
{
    return FALSE;
}

static
int
WINAPI
GetThemeSysSize(
    HTHEME hTheme,
    int iSizeId
    )
{
    return 0;
}

static
int
WINAPI
GetThemeSysSize96(
    HTHEME hTheme,
    int iSizeId
    )
{
    return 0;
}

static
HRESULT
WINAPI
GetThemeSysFont(
    HTHEME hTheme,
    int iFontId,
    OUT LOGFONT *plf
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeSysFont96(
    HTHEME hTheme,
    int iFontId,
    OUT LOGFONT *plf
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
OpenThemeFile(
    LPCWSTR pszThemePath,
    OPTIONAL LPCWSTR pszColorParam,
    OPTIONAL LPCWSTR pszSizeParam,
    OUT HTHEMEFILE *phThemeFile,
    BOOL fGlobalTheme
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeParseErrorInfo(
    PARSE_ERROR_INFO *pInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
OpenThemeFileFromData(
    HTHEME hTheme,
    HTHEMEFILE *phThemeFile
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HTHEME
WINAPI
OpenThemeDataFromFile(
    HTHEMEFILE hLoadedThemeFile,
    HWND hwnd,
    LPCWSTR pszClassList,
    BOOL fClient
    )
{
    return NULL;
}

static
DWORD
WINAPI
QueryThemeServices(
    void
    )
{
    return 0;
}

static
HRESULT
WINAPI
RegisterDefaultTheme(
    LPCWSTR pszFileName,
    BOOL fOverride
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
SetWindowTheme(
    HWND hwnd,
    LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
IsThemeActive(
    void
    )
{
    return FALSE;
}

//  These functions are exported for the use of the server. When the server
//  is collapsed in themesrv.dll these should be removed because they will
//  not be used and should not be exposed.

static
void*
WINAPI
SessionAllocate(
    HANDLE hProcess,
    DWORD dwServerChangeNumber,
    void *pfnRegister,
    void *pfnUnregister,
    void *pfnClearStockObjects
    )
{
    return NULL;
}

static
void
WINAPI
SessionFree(
    void *pvContext
    )
{
}

static
HRESULT
WINAPI
ThemeHooksOn(
    void *pvContext
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
ThemeHooksOff(
    void *pvContext
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
AreThemeHooksActive(
    void *pvContext
    )
{
    return FALSE;
}

static
int
WINAPI
GetCurrentChangeNumber(
    void *pvContext
    )
{
    return -1;
}

static
int
WINAPI
GetNewChangeNumber(
    void *pvContext
    )
{
    return -1;
}

static
HRESULT
WINAPI
SetGlobalTheme(
    void *pvContext,
    HANDLE hSection
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
void
WINAPI
MarkSection(
    HANDLE hSection,
    DWORD dwAdd,
    DWORD dwRemove
    )
{
}

static
HRESULT
WINAPI
GetGlobalTheme(
    void *pvContext,
    HANDLE *phSection
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CheckThemeSignature(
    LPCWSTR pszName
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
LoadTheme(
    void *pvContext,
    HANDLE hSection,
    HANDLE *phSection,
    LPCWSTR pszName,
    LPCWSTR pszColor,
    LPCWSTR pszSize
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
InitUserTheme(
    BOOL fPolicyCheckOnly
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
InitUserRegistry(
    void
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
ReestablishServerConnection(
    void
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
void
WINAPI
ThemeHooksInstall(
    void *pvContext
    )
{
}

static
void
WINAPI
ThemeHooksRemove(
    void *pvContext
    )
{
}

static
void
WINAPI
ServerClearStockObjects(
    void *pvContext
    )
{
}

static
int
WINAPI
ClassicGetSystemMetrics(
    int iMetric
    )
{
    return 0;
}

static
BOOL
WINAPI
ClassicSystemParametersInfoA(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ClassicSystemParametersInfoW(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni
    )
{
    return FALSE;
}

static
HRESULT
WINAPI
GetThemeInt(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    OUT int *piVal
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeTextMetrics(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    OUT TEXTMETRIC* ptm
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeFont(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId, 
    int iPropId,
    OUT LOGFONT *pFont
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeMetric(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId, 
    int iPropId,
    OUT int *piVal
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
IsThemeBackgroundPartiallyTransparent(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    )
{
    return FALSE;
}

static
BOOL
WINAPI
IsThemePartDefined(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    )
{
    return FALSE;
}

static
HRESULT
WINAPI
GetThemeMargins(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    OPTIONAL RECT *prc,
    OUT MARGINS *pMargins
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemePartSize(
    HTHEME hTheme,
    HDC hdc, 
    int iPartId,
    int iStateId,
    OPTIONAL RECT *prc,
    enum THEMESIZE eSize,
    OUT SIZE *psz
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
DrawThemeEdge(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pDestRect,
    UINT uEdge,
    UINT uFlags,
    OPTIONAL OUT RECT *pContentRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
HitTestThemeBackground(
    HTHEME hTheme, 
    OPTIONAL HDC hdc, 
    int iPartId, 
    int iStateId, 
    DWORD dwOptions, 
    const RECT *pRect, 
    OPTIONAL HRGN hrgn,
    POINT ptTest, 
    OUT WORD *pwHitTestCode
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeBackgroundExtent(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pContentRect,
    OUT RECT *pExtentRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeBackgroundRegion(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pRect,
    OUT HRGN *pRegion
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeTextExtent(
    HTHEME hTheme,
    HDC hdc, 
    int iPartId,
    int iStateId,
    LPCWSTR pszText,
    int iCharCount, 
    DWORD dwTextFlags,
    OPTIONAL const RECT *pBoundingRect, 
    OUT RECT *pExtentRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HTHEME
WINAPI
OpenThemeData(
    HWND hwnd,
    LPCWSTR pszClassIdList
    )
{
    return NULL;
}

static 
HRESULT
WINAPI
DrawThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId, 
    int iStateId,
    const RECT *pRect,
    OPTIONAL const RECT *pClipRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static 
HRESULT
WINAPI
DrawThemeParentBackground(
    HWND hwnd, 
    HDC hdc, 
    RECT* prc
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
RefreshThemeForTS(
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static HRESULT WINAPI DrawThemeIcon(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeBackgroundContentRect(
    HTHEME hTheme,
    OPTIONAL HDC hdc, 
    int iPartId,
    int iStateId,
    const RECT *pBoundingRect, 
    OUT RECT *pContentRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
GetThemeColor(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    OUT COLORREF *pColor
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
DrawThemeText(
    HTHEME hTheme,
    HDC hdc,
    int iPartId, 
    int iStateId,
    LPCWSTR pszText,
    int iCharCount,
    DWORD dwTextFlags, 
    DWORD dwTextFlags2,
    const RECT *pRect
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
EnableThemeDialogTexture(
    HWND hwnd,
    DWORD dwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
THEMEAPI_(BOOL)
IsAppThemed()
{
    return FALSE;
}

static THEMEAPI_(void) SetThemeAppProperties(DWORD dwFlags)
{
}

static THEMEAPI_(HTHEME) GetWindowTheme(HWND hwnd)
{
    return NULL;
}

static THEMEAPI_(BOOL) IsThemeDialogTextureEnabled(HWND hwnd)
{
    return FALSE;
}

static THEMEAPI_(DWORD) GetThemeAppProperties()
{
    return 0;
}

static THEMEAPI GetThemeFilename(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LPWSTR pszThemeFileName, int cchMaxBuffChars)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeString(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LPWSTR pszBuff, int cchMaxBuffChars)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeBool(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT BOOL *pfVal)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeIntList(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT INTLIST *pIntList)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeEnumValue(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT int *piVal)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemePosition(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT POINT *pPoint)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemeRect(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT RECT *pRect)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI GetThemePropertyOrigin(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT enum PROPERTYORIGIN *pOrigin)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI DrawThemeBackgroundEx(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static THEMEAPI_(BOOL) ClassicAdjustWindowRectEx( LPRECT prcWnd, DWORD dwStyle, 
    BOOL fMenu, DWORD dwExStyle )
{
    return FALSE;
}


static THEMEAPI DumpLoadedThemeToTextFile(HTHEMEFILE hThemeFile, 
    LPCWSTR pszTextFile, BOOL fPacked, BOOL fFullInfo)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

//---- fake some structs for these c++ classes ----
typedef struct _CDrawBase {int dummy;} CDrawBase;
typedef struct _CTextDraw {int dummy;} CTextDraw;

static THEMEAPI_(HTHEME) CreateThemeDataFromObjects(OPTIONAL CDrawBase *pDrawObj, 
    OPTIONAL CTextDraw *pTextObj, DWORD dwOtdFlags)
{
    return NULL;
}

static THEMEAPI_(HTHEME) OpenThemeDataEx(HWND hwnd, LPCWSTR pszClassList, DWORD dwFlags)
{
    return NULL;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(uxtheme)         // PRIVATE functions
{
    DLOENTRY(1,QueryThemeServices)
    DLOENTRY(2,OpenThemeFile)
    DLOENTRY(3,CloseThemeFile)
    DLOENTRY(4,ApplyTheme)
    DLOENTRY(7,GetThemeDefaults)
    DLOENTRY(8,EnumThemes)
    DLOENTRY(9,EnumThemeColors)
    DLOENTRY(10,EnumThemeSizes)
    DLOENTRY(13,DrawNCPreview)
    DLOENTRY(14,RegisterDefaultTheme)
    DLOENTRY(15,DumpLoadedThemeToTextFile)
    DLOENTRY(16,OpenThemeDataFromFile)
    DLOENTRY(17,OpenThemeFileFromData)
    DLOENTRY(18,GetThemeSysSize96)
    DLOENTRY(19,GetThemeSysFont96)
    DLOENTRY(20,SessionAllocate)
    DLOENTRY(21,SessionFree)
    DLOENTRY(22,ThemeHooksOn)
    DLOENTRY(23,ThemeHooksOff)
    DLOENTRY(24,AreThemeHooksActive)
    DLOENTRY(25,GetCurrentChangeNumber)
    DLOENTRY(26,GetNewChangeNumber)
    DLOENTRY(27,SetGlobalTheme)
    DLOENTRY(28,GetGlobalTheme)
    DLOENTRY(29,CheckThemeSignature)
    DLOENTRY(30,LoadTheme)
    DLOENTRY(31,InitUserTheme)
    DLOENTRY(32,InitUserRegistry)
    DLOENTRY(33,ReestablishServerConnection)
    DLOENTRY(34,ThemeHooksInstall)
    DLOENTRY(35,ThemeHooksRemove)
    DLOENTRY(36,RefreshThemeForTS)
    DLOENTRY(43,ClassicGetSystemMetrics)
    DLOENTRY(44,ClassicSystemParametersInfoA)
    DLOENTRY(45,ClassicSystemParametersInfoW)
    DLOENTRY(46,ClassicAdjustWindowRectEx)
    DLOENTRY(47,DrawThemeBackgroundEx)
    DLOENTRY(48,GetThemeParseErrorInfo)
    DLOENTRY(60,CreateThemeDataFromObjects)
    DLOENTRY(61,OpenThemeDataEx)
    DLOENTRY(62,ServerClearStockObjects)
    DLOENTRY(63,MarkSection)
};

DEFINE_ORDINAL_MAP(uxtheme)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(uxtheme)        // PUBLIC functions
{
    DLPENTRY(CloseThemeData)
    DLPENTRY(DrawThemeBackground)
    DLPENTRY(DrawThemeEdge)
    DLPENTRY(DrawThemeIcon)
    DLPENTRY(DrawThemeParentBackground)
    DLPENTRY(DrawThemeText)
    DLPENTRY(EnableThemeDialogTexture)
    DLPENTRY(EnableTheming)
    DLPENTRY(GetCurrentThemeName)
    DLPENTRY(GetThemeAppProperties)
    DLPENTRY(GetThemeBackgroundContentRect)
    DLPENTRY(GetThemeBackgroundExtent)
    DLPENTRY(GetThemeBackgroundRegion)
    DLPENTRY(GetThemeBool)
    DLPENTRY(GetThemeColor)
    DLPENTRY(GetThemeDocumentationProperty)
    DLPENTRY(GetThemeEnumValue)
    DLPENTRY(GetThemeFilename)
    DLPENTRY(GetThemeFont)
    DLPENTRY(GetThemeInt)
    DLPENTRY(GetThemeIntList)
    DLPENTRY(GetThemeMargins)
    DLPENTRY(GetThemeMetric)
    DLPENTRY(GetThemePartSize)
    DLPENTRY(GetThemePosition)
    DLPENTRY(GetThemePropertyOrigin)
    DLPENTRY(GetThemeRect)
    DLPENTRY(GetThemeString)
    DLPENTRY(GetThemeSysBool)
    DLPENTRY(GetThemeSysColor)
    DLPENTRY(GetThemeSysColorBrush)
    DLPENTRY(GetThemeSysFont)
    DLPENTRY(GetThemeSysInt)
    DLPENTRY(GetThemeSysSize)
    DLPENTRY(GetThemeSysString)
    DLPENTRY(GetThemeTextExtent)
    DLPENTRY(GetThemeTextMetrics)
    DLPENTRY(GetWindowTheme)
    DLPENTRY(HitTestThemeBackground)
    DLPENTRY(IsAppThemed)
    DLPENTRY(IsThemeActive)
    DLPENTRY(IsThemeBackgroundPartiallyTransparent)
    DLPENTRY(IsThemeDialogTextureEnabled)
    DLPENTRY(IsThemePartDefined)
    DLPENTRY(OpenThemeData)
    DLPENTRY(SetThemeAppProperties)
    DLPENTRY(SetWindowTheme)
};

DEFINE_PROCNAME_MAP(uxtheme)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\aclui.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       aclui.h
//
//  Contents:   Definitions and prototypes for the ACLUI.DLL
//
//---------------------------------------------------------------------------

#ifndef _ACLUI_H_
#define _ACLUI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <objbase.h>
#include <commctrl.h>   // for HPROPSHEETPAGE
#include <accctrl.h>    // for SE_OBJECT_TYPE

#if !defined(_ACLUI_)
#define ACLUIAPI    DECLSPEC_IMPORT WINAPI
#else
#define ACLUIAPI    WINAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// ISecurityInformation interface
//
//  Methods:
//
//     GetObjectInformation - Allows UI to determine type of object being
//       edited.  Also allows determining if object is a container.
//
//     GetSecurity - Allows retrieving of ACLs from the original object
//                       NOTE: ACLUI will LocalFree the security descriptor
//                       returned by GetSecurity.
//     SetSecurity - Allows setting of the ACLs on the original object
//
//     GetAccessRights - For retrieving the list of rights allowed
//              on this object.
//
//     MapGeneric - For mapping generic rights to standard & specific rights
//
//     GetInheritTypes - For retrieving the list of possible sub-object types
//              for a container.
//
//     PropertySheetCallback - A method which is called back during the various
//              security UI property pages so that specialized work can be
//              done.  Similar to PropSheetPageProc.  If uMsg == PSPCB_CREATE,
//              then any error return value other than E_NOTIMPL will abort
//              the creation of that page.  The type of page being created or
//              destroyed is indicated by the uPage parameter.
//

typedef struct _SI_OBJECT_INFO
{
    DWORD       dwFlags;
    HINSTANCE   hInstance;          // resources (e.g. strings) reside here
    LPWSTR      pszServerName;      // must be present
    LPWSTR      pszObjectName;      // must be present
    LPWSTR      pszPageTitle;       // only valid if SI_PAGE_TITLE is set
    GUID        guidObjectType;     // only valid if SI_OBJECT_GUID is set
} SI_OBJECT_INFO, *PSI_OBJECT_INFO;

// SI_OBJECT_INFO flags
#define SI_EDIT_PERMS               0x00000000L // always implied
#define SI_EDIT_OWNER               0x00000001L
#define SI_EDIT_AUDITS              0x00000002L
#define SI_CONTAINER                0x00000004L
#define SI_READONLY                 0x00000008L
#define SI_ADVANCED                 0x00000010L
#define SI_RESET                    0x00000020L //equals to SI_RESET_DACL|SI_RESET_SACL|SI_RESET_OWNER
#define SI_OWNER_READONLY           0x00000040L
#define SI_EDIT_PROPERTIES          0x00000080L
#define SI_OWNER_RECURSE            0x00000100L
#define SI_NO_ACL_PROTECT           0x00000200L
#define SI_NO_TREE_APPLY            0x00000400L
#define SI_PAGE_TITLE               0x00000800L
#define SI_SERVER_IS_DC             0x00001000L
#define SI_RESET_DACL_TREE          0x00004000L
#define SI_RESET_SACL_TREE          0x00008000L
#define SI_OBJECT_GUID              0x00010000L
#define SI_EDIT_EFFECTIVE           0x00020000L
#define SI_RESET_DACL               0x00040000L
#define SI_RESET_SACL               0x00080000L
#define SI_RESET_OWNER              0x00100000L
#define SI_NO_ADDITIONAL_PERMISSION 0x00200000L
#define SI_MAY_WRITE                0x10000000L //not sure if user can write permission

#define SI_EDIT_ALL     (SI_EDIT_PERMS | SI_EDIT_OWNER | SI_EDIT_AUDITS)


typedef struct _SI_ACCESS
{
    const GUID *pguid;
    ACCESS_MASK mask;
    LPCWSTR     pszName;            // may be resource ID
    DWORD       dwFlags;
} SI_ACCESS, *PSI_ACCESS;

// SI_ACCESS flags
#define SI_ACCESS_SPECIFIC  0x00010000L
#define SI_ACCESS_GENERAL   0x00020000L
#define SI_ACCESS_CONTAINER 0x00040000L // general access, container-only
#define SI_ACCESS_PROPERTY  0x00080000L
// ACE inheritance flags (CONTAINER_INHERIT_ACE, etc.) may also be set.
// They will be used as the inheritance when an access is turned on.

typedef struct _SI_INHERIT_TYPE
{
    const GUID *pguid;
    ULONG       dwFlags;
    LPCWSTR     pszName;            // may be resource ID
} SI_INHERIT_TYPE, *PSI_INHERIT_TYPE;

// SI_INHERIT_TYPE flags are a combination of INHERIT_ONLY_ACE,
// CONTAINER_INHERIT_ACE, and OBJECT_INHERIT_ACE.

typedef enum _SI_PAGE_TYPE
{
    SI_PAGE_PERM=0,
    SI_PAGE_ADVPERM,
    SI_PAGE_AUDIT,
    SI_PAGE_OWNER,
    SI_PAGE_EFFECTIVE,
} SI_PAGE_TYPE;

// Message to PropertySheetPageCallback (in addition to
// PSPCB_CREATE and PSPCB_RELEASE)
#define PSPCB_SI_INITDIALOG	(WM_USER + 1)


#undef INTERFACE
#define INTERFACE   ISecurityInformation
DECLARE_INTERFACE_(ISecurityInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (THIS_ PSI_OBJECT_INFO pObjectInfo ) PURE;
    STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) PURE;
    STDMETHOD(SetSecurity) (THIS_ SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) PURE;
    STDMETHOD(GetAccessRights) (THIS_ const GUID* pguidObjectType,
                                DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess ) PURE;
    STDMETHOD(MapGeneric) (THIS_ const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask) PURE;
    STDMETHOD(GetInheritTypes) (THIS_ PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes ) PURE;
    STDMETHOD(PropertySheetPageCallback)(THIS_ HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage ) PURE;
};
typedef ISecurityInformation *LPSECURITYINFO;

#undef INTERFACE
#define INTERFACE   ISecurityInformation2
DECLARE_INTERFACE_(ISecurityInformation2, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation2 methods ***
    STDMETHOD_(BOOL,IsDaclCanonical) (THIS_ IN PACL pDacl) PURE;
    STDMETHOD(LookupSids) (THIS_ IN ULONG cSids, IN PSID *rgpSids, OUT LPDATAOBJECT *ppdo) PURE;
};
typedef ISecurityInformation2 *LPSECURITYINFO2;

// HGLOBAL containing SID_INFO_LIST returned by ISecurityInformation2::LookupSids
#define CFSTR_ACLUI_SID_INFO_LIST   TEXT("CFSTR_ACLUI_SID_INFO_LIST")

// Data structures corresponding to CFSTR_ACLUI_SID_INFO_LIST
typedef struct _SID_INFO
{
    PSID    pSid;
    PWSTR   pwzCommonName;
    PWSTR   pwzClass;       // Used for selecting icon, e.g. "User" or "Group"
    PWSTR   pwzUPN;         // Optional, may be NULL
} SID_INFO, *PSID_INFO;
typedef struct _SID_INFO_LIST
{
    ULONG       cItems;
    SID_INFO    aSidInfo[ANYSIZE_ARRAY];
} SID_INFO_LIST, *PSID_INFO_LIST;


#undef INTERFACE
#define INTERFACE   IEffectivePermission
DECLARE_INTERFACE_(IEffectivePermission, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation methods ***
    STDMETHOD(GetEffectivePermission) (  THIS_ const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength) PURE;
};
typedef IEffectivePermission *LPEFFECTIVEPERMISSION;

#undef INTERFACE
#define INTERFACE   ISecurityObjectTypeInfo
DECLARE_INTERFACE_(ISecurityObjectTypeInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation methods ***
    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray) PURE;
};
typedef ISecurityObjectTypeInfo *LPSecurityObjectTypeInfo;


// {965FC360-16FF-11d0-91CB-00AA00BBB723}
EXTERN_GUID(IID_ISecurityInformation, 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23);
// {c3ccfdb4-6f88-11d2-a3ce-00c04fb1782a}
EXTERN_GUID(IID_ISecurityInformation2, 0xc3ccfdb4, 0x6f88, 0x11d2, 0xa3, 0xce, 0x0, 0xc0, 0x4f, 0xb1, 0x78, 0x2a);
// {3853DC76-9F35-407c-88A1-D19344365FBC}
EXTERN_GUID(IID_IEffectivePermission, 0x3853dc76, 0x9f35, 0x407c, 0x88, 0xa1, 0xd1, 0x93, 0x44, 0x36, 0x5f, 0xbc);
// {FC3066EB-79EF-444b-9111-D18A75EBF2FA}
EXTERN_GUID(IID_ISecurityObjectTypeInfo, 0xfc3066eb, 0x79ef, 0x444b, 0x91, 0x11, 0xd1, 0x8a, 0x75, 0xeb, 0xf2, 0xfa);


HPROPSHEETPAGE ACLUIAPI CreateSecurityPage( LPSECURITYINFO psi );
BOOL ACLUIAPI EditSecurity( HWND hwndOwner, LPSECURITYINFO psi );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _ACLUI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\brdispid.h ===
#ifndef _BRDISPID_H_
#define _BRDISPID_H_

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File: brdispid.h
//
//--------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////
//  IMediaBehavior
////////////////////////////////////////////////////////////////////////////
#define DISPID_MBBEHAVIOR_BASE                      0

#define DISPID_MBBEHAVIOR_PLAYURL                   (DISPID_MBBEHAVIOR_BASE + 1)
#define DISPID_MBBEHAVIOR_STOP                      (DISPID_MBBEHAVIOR_BASE + 2)
#define DISPID_MBBEHAVIOR_PLAYNEXT                  (DISPID_MBBEHAVIOR_BASE + 3)
#define DISPID_MBBEHAVIOR_CURRENTITEM               (DISPID_MBBEHAVIOR_BASE + 4)
#define DISPID_MBBEHAVIOR_NEXTITEM                  (DISPID_MBBEHAVIOR_BASE + 5)
#define DISPID_MBBEHAVIOR_PLAYLISTINFO              (DISPID_MBBEHAVIOR_BASE + 6)
#define DISPID_MBBEHAVIOR_HASNEXTITEM               (DISPID_MBBEHAVIOR_BASE + 7)
#define DISPID_MBBEHAVIOR_PLAYSTATE                 (DISPID_MBBEHAVIOR_BASE + 8)
#define DISPID_MBBEHAVIOR_OPENSTATE                 (DISPID_MBBEHAVIOR_BASE + 9)
#define DISPID_MBBEHAVIOR_ENABLED                   (DISPID_MBBEHAVIOR_BASE + 10)
#define DISPID_MBBEHAVIOR_DISABLEDUI                (DISPID_MBBEHAVIOR_BASE + 11)

#define DISPID_MBBEHAVIOR_LAST                      DISPID_MBBEHAVIOR_DISABLEDUI



////////////////////////////////////////////////////////////////////////////
//  IMediaItem
////////////////////////////////////////////////////////////////////////////
#define DISPID_MBMEDIAITEM_BASE                     DISPID_MBBEHAVIOR_LAST

#define DISPID_MBMEDIAITEM_SOURCEURL                (DISPID_MBMEDIAITEM_BASE + 1)
#define DISPID_MBMEDIAITEM_NAME                     (DISPID_MBMEDIAITEM_BASE + 2)
#define DISPID_MBMEDIAITEM_DURATION                 (DISPID_MBMEDIAITEM_BASE + 3)
#define DISPID_MBMEDIAITEM_ATTRIBUTECOUNT           (DISPID_MBMEDIAITEM_BASE + 4)
#define DISPID_MBMEDIAITEM_GETATTRIBUTENAME         (DISPID_MBMEDIAITEM_BASE + 5)
#define DISPID_MBMEDIAITEM_GETITEMINFO              (DISPID_MBMEDIAITEM_BASE + 6)

#define DISPID_MBMEDIAITEM_LAST                     DISPID_MBMEDIAITEM_GETITEMINFO


////////////////////////////////////////////////////////////////////////////
//  IPlaylistInfo
////////////////////////////////////////////////////////////////////////////
#define DISPID_MBPLAYLISTINFO_BASE                  DISPID_MBMEDIAITEM_LAST

#define DISPID_MBPLAYLISTINFO_NAME                  (DISPID_MBPLAYLISTINFO_BASE + 1)
#define DISPID_MBPLAYLISTINFO_ATTRIBUTECOUNT        (DISPID_MBPLAYLISTINFO_BASE + 2)
#define DISPID_MBPLAYLISTINFO_GETATTRIBUTENAME      (DISPID_MBPLAYLISTINFO_BASE + 3)
#define DISPID_MBPLAYLISTINFO_GETITEMINFO           (DISPID_MBPLAYLISTINFO_BASE + 4)

#define DISPID_MBPLAYLISTINFO_LAST                  DISPID_MBPLAYLISTINFO_GETITEMINFO

////////////////////////////////////////////////////////////////////////////
// DIID_mbEvents
////////////////////////////////////////////////////////////////////////////
#define DISPID_MBBEHAVIOREVENT_BASE                 4000

#define DISPID_MBBEHAVIOREVENT_ONOPENSTATECHANGE    (DISPID_MBBEHAVIOREVENT_BASE + 1)
#define DISPID_MBBEHAVIOREVENT_ONPLAYSTATECHANGE    (DISPID_MBBEHAVIOREVENT_BASE + 2)
#define DISPID_MBBEHAVIOREVENT_ONSHOW               (DISPID_MBBEHAVIOREVENT_BASE + 3)
#define DISPID_MBBEHAVIOREVENT_ONHIDE               (DISPID_MBBEHAVIOREVENT_BASE + 4)

#endif // _BRDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\accoreid.h ===
// Events IDs for FS Notify Control
#define DISPID_ONFSNOTIFYCHANGED        400

#define DISPID_PROP_SPFSNOTIFY_RECURSIVE    10
#define DISPID_PROP_SPFSNOTIFY_FOLDERITEM   11
// Property/method/event IDs for
// IStartPageSectionManager/DStartPageSectionManagerEvents
#define DISPID_SPSM_METHOD_RECALC                    1
#define DISPID_SPSM_PROP_MAXITEMS                    2
#define DISPID_SPSM_EVENT_ONRECALCDONE             100

// Property/method/event IDs for
// IActivityCenterHelp/DActivityCenterHelpEvents
#define DISPID_ACH_EVENT_ONDESKTOPSETTINGSCHANGED  100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\ginarcid.h ===
//  Don't use numbers lower than 20000. These are used by the DS component
//  of msgina.

// UI host failure
#define IDS_UIHOST_FAILURE                          20000
#define IDS_GENERIC_CAPTION                         20001
#define IDS_RECONNECT_FAILURE                       20005

#define IDD_GINA_TURNOFFCOMPUTER                    20050
#define IDD_GINA_RETURNTOWELCOME                    20051

#define IDD_TURNOFFCOMPUTER                         20100
#define IDC_TITLE_FLAG                              20101
#define IDC_TITLE_TURNOFF                           20102
#define IDC_BUTTON_TURNOFF                          20103
#define IDC_BUTTON_STANDBY                          20104
#define IDC_BUTTON_RESTART                          20105
#define IDC_BUTTON_HIBERNATE                        20106
#define IDC_TEXT_TURNOFF                            20107
#define IDC_TEXT_STANDBY                            20108
#define IDC_TEXT_RESTART                            20109
#define IDC_TEXT_HIBERNATE                          20110

#define IDS_TURNOFF_TITLE_FACENAME                  20125
#define IDS_TURNOFF_TITLE_FACESIZE                  20126
#define IDS_TURNOFF_BUTTON_FACENAME                 20127
#define IDS_TURNOFF_BUTTON_FACESIZE                 20128
#define IDS_TURNOFF_TOOLTIP_TEXT_TURNOFF            20129
#define IDS_TURNOFF_TOOLTIP_TEXT_STANDBY            20130
#define IDS_TURNOFF_TOOLTIP_TEXT_STANDBY_HIBERNATE  20131
#define IDS_TURNOFF_TOOLTIP_TEXT_RESTART            20132
#define IDS_TURNOFF_TOOLTIP_TEXT_HIBERNATE          20133

#define IDB_BACKGROUND_8                            20140
#define IDB_FLAG_8                                  20141
#define IDB_BACKGROUND_24                           20142
#define IDB_FLAG_24                                 20143

#define IDB_BUTTONS                                 20150
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\dload\version.c ===
#include "shellpch.h"
#pragma hdrstop

#include <winver.h>

static
BOOL
APIENTRY
GetFileVersionInfoA(
    LPSTR lptstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData
    )
{
    return FALSE;
}

static
DWORD
APIENTRY
GetFileVersionInfoSizeA(
    LPSTR lptstrFilename,
    LPDWORD lpdwHandle
    )
{
    return 0;
}

static
DWORD
APIENTRY
GetFileVersionInfoSizeW(
    LPWSTR lptstrFilename,
    LPDWORD lpdwHandle
    )
{
    return 0;
}

static
BOOL
APIENTRY
GetFileVersionInfoW(
    LPWSTR lptstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
VerQueryValueA(
    const LPVOID pBlock,
    LPSTR lpSubBlock,
    LPVOID * lplpBuffer,
    PUINT puLen
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
VerQueryValueW(
    const LPVOID pBlock,
    LPWSTR lpSubBlock,
    LPVOID * lplpBuffer,
    PUINT puLen
    )
{
    return FALSE;
}

static
BOOL
APIENTRY
VerQueryValueIndexW(
    const void *pBlock,
    LPTSTR lpSubBlock,
    DWORD dwIndex,
    void **ppBuffer,
    void **ppValue,
    PUINT puLen
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(version)
{
    DLPENTRY(GetFileVersionInfoA)
    DLPENTRY(GetFileVersionInfoSizeA)
    DLPENTRY(GetFileVersionInfoSizeW)
    DLPENTRY(GetFileVersionInfoW)
    DLPENTRY(VerQueryValueA)
    DLPENTRY(VerQueryValueIndexW)
    DLPENTRY(VerQueryValueW)
};

DEFINE_PROCNAME_MAP(version)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\help.h ===
// This file contains help context id's in the master windows.h file.

// Id's over 61440 are reserved and will ALWAYS use windows.hlp when
// used for context-sensitive help.

// Id's from 1-999 are reserved for Object help

// REVIEW: has to be 28440 until new help compiler is available

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_BACK    0x3023
#define IDH_NEXT    0x3024
#define IDH_FINISH  0x3025

#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445
#define IDH_COMM_APPLYNOW               28447
#define IDH_FONT_STYLE                  28448
#define IDH_FONT_SIZE                   28449
#define IDH_FONT_SAMPLE                 28450
#define IDH_FONT_EFFECTS                28451
#define IDH_FONT_FONT                   28452
#define IDH_PRINT_SETUP_AVAIL           28453
#define IDH_PRINT_SETUP_OPTIONS         28454
#define IDH_PRINT_SETUP_DETAILS         28455
#define IDH_OPEN_LOCATION               28456
#define IDH_OPEN_FILES                  28457
#define IDH_OPEN_READONLY               28459
#define IDH_OPEN_FILETYPE               28460
#define IDH_OPEN_PATH                   28461
#define IDH_OPEN_FILENAME               28462
#define IDH_FIND_SEARCHTEXT             28463
#define IDH_FIND_NEXT_BUTTON            28464
#define IDH_FIND_WHOLE                  28467
#define IDH_FIND_CASE                   28468
#define IDH_REPLACE_REPLACE             28469
#define IDH_REPLACE_REPLACE_ALL         28470
#define IDH_REPLACE_REPLACEWITH         28471
#define IDH_PRINT_PRINTER               28472
#define IDH_PRINT_PRINTER_SETUP         28473
#define IDH_PRINT_COPIES                28474
#define IDH_PRINT_COLLATE               28475
#define IDH_PRINT_TO_FILE               28476
#define IDH_PRINT_QUALITY               28477
#define IDH_PRINT_RANGE                 28478
#define IDH_PAGE_SAMPLE                 28485
#define IDH_PAGE_ORIENTATION            28486
#define IDH_PAGE_PAPER_SIZE             28487
#define IDH_PAGE_PAPER_SOURCE           28488
#define IDH_PAGE_MARGINS                28489
#define IDH_OPEN_DRIVES                 28490
#define IDH_COMM_DRIVE                  28491
#define IDH_COMM_PASSWDBUTT             28492
#define IDH_COMM_OLDPASSWD              28493
#define IDH_BROWSE                      28496
#define IDH_COLOR_CUSTOM                28497
#define IDH_COLOR_SAMPLE_COLOR          28498
#define IDH_COLOR_HUE                   28500
#define IDH_COLOR_SAT                   28501
#define IDH_COLOR_RED                   28502
#define IDH_COLOR_GREEN                 28503
#define IDH_COLOR_BLUE                  28504
#define IDH_COLOR_LUM                   28505
#define IDH_COLOR_ADD                   28506
#define IDH_COLOR_COLOR_SOLID           28507
#define IDH_COLOR_DEFINE                28508
#define IDH_QUICKINFO                   28509
#define IDH_NO_CROSSREF                 28510
#define IDH_CHARMAP_INSERT              28511
#define IDH_COMM_USER_NAME              28512
#define IDH_COMM_USER_SERVERNAME        28513
#define IDH_COMM_USER_SELECT_FROM       28514
#define IDH_COMM_USER_SELECTED          28515
#define IDH_PRINT32_RANGE               28516
#define IDH_PRINT_PROPERTIES            28517
#define IDH_PRINT_FILENAME              28518
#define IDH_PRINT_CHOOSE_PRINTER        28519
#define IDH_FIND_DIRECTION              28520
#define IDH_FONT_COLOR                  28521
#define IDH_PRINT_SETUP_PAPER           28522
#define IDH_PRINT_SETUP_ORIENT          28523
#define IDH_OPEN_BUTTON                 28529
#define IDH_SAVE_BUTTON                 28531
#define IDH_COLOR_BASIC                 28532
#define IDH_COLOR_CUSTOM_CUSTOM         28533
#define IDH_COLOR_SAMPLE_SCROLL         28534
#define IDH_FONT_SCRIPT                 28535
#define IDH_KERNEL_TASK_LIST            28536
#define IDH_KERNEL_END_TASK             28537
#define IDH_KERNEL_SHUTDOWN             28538
#define IDH_QVIEW_DISPLAY               28539
#define IDH_CHARMAP_COPY                28540
#define IDH_CHARMAP_FONT                28541
#define IDH_CHARMAP_CHARACTERS          28542
#define IDH_CHARMAP_SELECTED_CHARS      28543
#define IDH_CHARMAP_SELECT_BUTTON       28544
#define IDH_CHARMAP_HELP_BUTTON         28545
#define IDH_BOLD                        28546
#define IDH_ITALIC                      28547
#define IDH_COMM_GROUPBOX               28548
#define IDH_OPEN_FILES32                28549
#define IDH_SAVE_FILETYPE               28550
#define IDH_SYSTEM_CFG_OLDNAME          28551
#define IDH_DIAL_WHAT_WRONG             28552
#define IDH_COMCTL_RESET                28553
#define IDH_COMCTL_MOVEUP               28554
#define IDH_COMCTL_MOVEDOWN             28555
#define IDH_COMCTL_BUTTON_LIST          28556
#define IDH_COMCTL_ADD                  28557
#define IDH_COMCTL_REMOVE               28558
#define IDH_COMCTL_AVAIL_BUTTONS        28559
#define IDH_COMCTL_CLOSE                28560
#define IDH_PAGE_PRINTER                28561
#define IDH_DCC_WHAT_WRONG              28562
#define IDH_FILEVIEWER_PREVIEW          28563
#define IDH_PRINT_NETWORK               28564
#define IDH_PRINT_SETUP_DUPLEX          28565

#define IDH_OLEPROP_SUMMARY             28569
#define IDH_OLEPROP_STATISTICS          28570
#define IDH_CONFIGURE_LPT_PORT          28571
#define IDH_ADD_LOCAL_PORT              28572
#define IDH_PRINT_PORT_NAME             28573
#define IDH_PRINT_OUTPUT_FILE           28574
#define IDH_DISKCOPY_START              28575
#define IDH_DISKCOPY_FROM               28576
#define IDH_DISKCOPY_TO                 28577

#define IDH_PRINT_FIND_PRINTER          29010
#define IDH_PRINT_PREFERENCES           29011
#define IDH_PRINT_PRINTER_FOLDER        29015

#define IDH_OPEN_SHORTCUT_BAR           29500
#define IDH_OPEN_BACK_BUTTON            29501
#define IDH_PRINT_BTN                   29510

// ID value for Win 3.1 user transition piece: jump from First experience screen
#define WIN31_TRANSITION_PIECE          30000

#define IDH_FCAB_OPENWITH_LOOKONWEB     3001            // (for the link to the Web on the Open With dialog.)
#define IDH_CANNOTOPEN_USEWEB           3002            // (For the first radio button on the Cannot open this file dialog)
#define IDH_CANNOTOPEN_SELECTLIST       3003            // (For the second radio button on the Cannot open this file dialog)


// ID values 2100-2199 are reserved for Disk Compression.
// See dos\dos86\dblspace\utility\comphelp.h

// ID values 2200-2299 are reserved for Find File. See findhlp.h.

// ID values 2400-2499 are reserved for MultiMedia control panel. See medhelp.h

// ID values 2500-2699 are reserved for Print Trouble Shooter

// ID values 2700-2799 are reserved for Network control panel. See nethelp.h

// ID values 2800-2899 are reserved for Online Registration.

// ID values 2900-2999 are reserved for Clipbook and Chat.

#define IDH_COMM_NEWPASSWD              3018    // See pwdids.h
#define IDH_COMM_NEWPASSCONF            3019    // See pwdids.h

// Briefcase ids

#define IDH_BFC_UPDATE_SCREEN           3100
#define IDH_BFC_UPDATE_BUTTON           3101
#define IDH_BFC_PROP_FILEICON           3102
#define IDH_BFC_PROP_SPLIT_BUTTON       3103
#define IDH_BFC_PROP_FINDORIG_BUTTON    3104
#define IDH_BFC_FILTER_TYPE             3105
#define IDH_BFC_FILTER_INCLUDE          3106

// ID values 3300-3499 are reserved for international. See intlhlp.h

// ID values for the Keyboard property sheet

#define IDH_DLGKEY_REPDEL               4000
#define IDH_DLGKEY_REPSPEED             4001
#define IDH_DLGKEY_REPTEST              4002
#define IDH_DLGKEY_TYPE                 4008
#define IDH_DLGKEY_CHANGE               4010
#define IDH_DLGKEY_CURSBLNK             4011
#define IDH_DLGKEY_CURSOR_GRAPHIC       4012

#define IDH_KEYB_INPUT_LIST             4028
#define IDH_KEYB_INPUT_ADD              4029
#define IDH_KEYB_INPUT_PROP             4030
#define IDH_KEYB_INPUT_DEL              4031
#define IDH_KEYB_INPUT_DEFAULT          4032
#define IDH_KEYB_CAPSLOCK_LAYOUT        4033
#define IDH_KEYB_INPUT_LANG             4034
#define IDH_KEYB_INPUT_INDICATOR        4035
#define IDH_KEYB_INPUT_ONSCRN_KEYB      4036
#define IDH_KEYB_INPUT_PROP_LANG        4039
#define IDH_KEYB_INPUT_PROP_KEYLAY      4042
#define IDH_KEYB_INPUT_DEF_LANG         4043
#define IDH_KEYB_INPUT_SHORTCUT         4044
#define IDH_KEYB_INDICATOR_ON_TASKBAR   4045
#define IDH_KEYB_IME_SETTINGS           4046
#define IDH_KEYB_HOTKEY_LIST            4047
#define IDH_KEYB_CHANGE_HOTKEY          4048
#define IDH_KEYB_CHANGE_KEY             4049

// ID values for Desktop Property sheet

// Settings Page
#define IDH_SETTINGS_DISPLAYDESK        4064    //Monitor icon display area
#define IDH_SETTINGS_DISPLAYLIST        4065    //Monitor dropdown
#define IDH_SETTINGS_COLORBOX           4066    //Colors dropdown   
#define IDH_SETTINGS_SCREENSIZE         4067    //Screen Area dropdown      
#define IDH_SETTINGS_DISPLAYUSEME       4068    //Use this monitor chkbx
#define IDH_SETTINGS_DISPLAYPROPERTIES  4069    //Advanced button

// General Page
#define IDH_GENERAL_FONTSIZEGRP         4080    //Font size dropdown
#define IDH_GENERAL_DYNA                4081    //Compatibility option group
#define IDH_GENERAL_NODYNA              4082    //Restart the computer option
#define IDH_GENERAL_YESDYNA             4083    //Apply the changes option  
#define IDH_GENERAL_SHUTUP              4084    //Always prompt before option

// Background Page (Now the "Desktop" Page)
#define IDH_DSKTPBACKGROUND_MONITOR     4100
#define IDH_DSKTPBACKGROUND_PATTLIST    4102
#define IDH_DSKTPBACKGROUND_WALLLIST    4104
#define IDH_DSKTPBACKGROUND_BROWSE      4105
#define IDH_DSKTPBACKGROUND_TILE        4106
#define IDH_DSKTPBACKGROUND_CENTER      4107
#define IDH_DSKTPBACKGROUND_DISPLAY     4108
#define IDH_DSKTPBACKGROUND_EDITPAT     4109

// Screen Saver Page
#define IDH_DSKTPSCRSAVER_LISTBX        4111
#define IDH_DSKTPSCRSAVER_WAIT          4112
#define IDH_DSKTPSCRSAVER_TEST          4113
#define IDH_DSKTPSCRSAVER_SETTINGS      4114
#define IDH_DSKTPSCRSAVER_MONITOR       4115
#define IDH_SCRSAVER_GRAPHIC            4116
#define IDH_SCRSAVER_LOWPOWSTANDBY      4117
#define IDH_SCRSAVER_SHUTOFFPOW         4118

// Appearance Page

#define IDH_APPEAR_SCHEME               4120
#define IDH_APPEAR_SAVEAS               4121
#define IDH_APPEAR_DELETE               4122
#define IDH_APPEAR_GRAPHIC              4123
#define IDH_APPEAR_ITEMSIZE             4124
#define IDH_APPEAR_FONTBOLD             4125
#define IDH_APPEAR_FONTSIZE             4126
#define IDH_APPEAR_FONTCOLOR            4127
#define IDH_APPEAR_FONTITALIC           4128
#define IDH_APPEAR_BACKGRNDCOLOR        4129
#define IDH_APPEAR_ITEM                 4130
#define IDH_APPEAR_FONT                 4131

// Monitor Settings Page




#define IDH_DSKTPMONITOR_CHANGE_DISPLAY 4134
#define IDH_DSKTPMONITOR_COLOR          4135
#define IDH_DSKTPMONITOR_AREA           4136
#define IDH_DSKTPMONITOR_REFRESH        4137
#define IDH_DSKTPMONITOR_LIST_MODES     4138
#define IDH_DSKTPMONITOR_ENERGY         4139
#define IDH_DSKTPMONITOR_MONITOR        4140
#define IDH_DSKTPMONITOR_TEST           4141
#define IDH_DSKTPMONITOR_ADTYPE         4143
#define IDH_DSKTPMONITOR_CHANGE1        4144
#define IDH_DSKTPMONITOR_CHANGE2        4145
#define IDH_DSKTPMONITOR_MONTYPE        4146
#define IDH_DSKTPMONITOR_CUSTOM         4148
#define IDH_DSKTPMONITOR_FONTSIZE       4149
#define IDH_DSKTPMONITOR_AD_FACTS       4150
#define IDH_DSKTPMONITOR_DRIVER         4151
#define IDH_DSKTPMONITOR_DETECT         4152


#define IDH_SAVESCHEME_EDITFIELD        4170
#define IDH_CUSTOMFONTS_FONTSCALE       4171
#define IDH_CUSTOMFONTS_RULER           4172
#define IDH_CUSTOMFONTS_SAMPLE          4173

#define IDH_PATTERN_EDIT_NAME           4174
#define IDH_PATTERN_EDIT_SAMPLE         4175
#define IDH_PATTERN_EDIT_PIXEL_SCREEN   4176
#define IDH_PATTERN_EDIT_EXIT           4177
#define IDH_PATTERN_EDIT_ADD            4178
#define IDH_PATTERN_EDIT_CHANGE         4179
#define IDH_PATTERN_EDIT_REMOVE         4180

// ID values for Defrag

#define IDH_DEFRAG_START                        4200
#define IDH_DEFRAG_STOP                         4201
#define IDH_DEFRAG_PAUSE                        4202
#define IDH_DEFRAG_SHOWDETAILS                  4203
#define IDH_DEFRAG_HIDEDETAILS                  4204
#define IDH_DEFRAG_LEGEND                       4205
#define IDH_DEFRAG_SPARKLESCRN                  4206
#define IDH_DEFRAG_DEFRAGNOW_ANYWY              4207
#define IDH_DEFRAG_SELECTDRIVE                  4208
#define IDH_DEFRAG_ADVANCED                     4209
#define IDH_DEFRAG_EXIT                         4210
#define IDH_DEFRAG_DRIVELIST                    4211
#define IDH_DEFRAG_RESUME                       4212
#define IDH_DEFRAG_FULL                         4213
#define IDH_DEFRAG_FILESONLY                    4214
#define IDH_DEFRAG_FRSPCONLY                    4215
#define IDH_DEFRAG_USEONCE                      4218
#define IDH_DEFRAG_USEALWAYS                    4219
#define IDH_DEFRAG_GASGAUGE                     4220
#define IDH_DEFRAG_CHECK_DRIVE_FOR_ERRORS       4221

// RNA id values

#define IDH_RNA_CONNECT_NAME            4250
#define IDH_RNA_CONNECT_USER            4251
#define IDH_RNA_CONNECT_PASSWORD        4252
#define IDH_RNA_CONNECT_SAVEPW          4253
#define IDH_RNA_CONNECT_FROM            4254
#define IDH_RNA_OUT_PHONE_NUMBER        4255
#define IDH_RNA_OUT_DIALASST            4256
#define IDH_RNA_OUT_COMPLETE_PHONE      4257
#define IDH_RNA_OUT_CONNECT_BUTTON      4258
#define IDH_RNA_CHOOSE_MODEM            4273
#define IDH_RNA_CONFIG_MODEM            4274
#define IDH_RNA_MODEM_SERVER            4275
#define IDH_RNA_SERVERS                 4276
#define IDH_RNA_CONNECTION_LIST         4277
#define IDH_RNA_SERVER_COMPRESS         4278
#define IDH_RNA_SERVER_ENCRYPT          4279
#define IDH_RNA_SERVER_NETLOGON         4280
#define IDH_RNA_SERVER_PROTOCOL         4281
#define IDH_RNA_SERVER_TCPIPSET         4282
#define IDH_RNA_TCPIP_ASSIGNED_IP       4283
#define IDH_RNA_TCPIP_SPECIFY_IP        4284
#define IDH_RNA_TCPIP_ASSIGNED_DNS      4285
#define IDH_RNA_TCPIP_SPECIFY_DNS       4286
#define IDH_RNA_TCPIP_COMPRESS          4287
#define IDH_RNA_TCPIP_GATEWAY           4288
#define IDH_RNA_SETTINGS_REDIAL         4290
#define IDH_RNA_SETTINGS_TIMES          4291
#define IDH_RNA_SETTINGS_MINSEC         4292
#define IDH_RNA_SETTINGS_PROMPT         4293

// ID values for printing property sheets

#define IDH_PRTPROPS_TYPE_LOCATION              4501
#define IDH_PRTPROPS_COMMENT                    4502
#define IDH_PRTPROPS_NAME_STATIC                4505
#define IDH_PRTPROPS_PORT                       4506
#define IDH_PRTPROPS_DRIVER                     4507
#define IDH_PRTPROPS_NEW_PORT                   4508
#define IDH_PRTPROPS_NEW_DRIVER                 4509
#define IDH_PRTPROPS_SEPARATOR                  4510
#define IDH_PRTPROPS_ICON                       4512
#define IDH_PRTPROPS_SPOOL_SETTINGS             4513
#define IDH_PRTPROPS_PORT_SETTINGS              4514
#define IDH_PRTPROPS_SETUP                      4515
#define IDH_PRTPROPS_SEPARATOR_BROWSE           4516
#define IDH_PRTPROPS_TIMEOUT_NOTSELECTED        4517
#define IDH_PRTPROPS_TIMEOUT_TRANSRETRY         4518
#define IDH_PRTPROPS_TEST_PAGE                  4519
#define IDH_SPOOLSETTINGS_SPOOL                 4520
#define IDH_SPOOLSETTINGS_NOSPOOL               4521
#define IDH_SPOOLSETTINGS_PRINT_FASTER          4522
#define IDH_SPOOLSETTINGS_LESS_SPACE            4523
#define IDH_SPOOLSETTINGS_DATA_FORMAT           4524
#define IDH_SPOOLSETTINGS_RESTORE               4525
#define IDH_PRTPROPS_DEL_PORT                   4528
#define IDH_ADDPORT_NETWORK                     4529
#define IDH_ADDPORT_PORTMON                     4530
#define IDH_ADDPORT_NETPATH                     4531
#define IDH_ADDPORT_BROWSE                      4532
#define IDH_ADDPORT_LB                          4533
#define IDH_DELPORT_LB                          4534
#define IDH_PRTPROPS_MAP_PRN_PORT               4535
#define IDH_PRTPROPS_UNMAP_PRN_PORT             4536
#define IDH_SPOOLSETTINGS_ENABLE_BIDI           4537
#define IDH_SPOOLSETTINGS_DISABLE_BIDI          4538

// ID values for System property sheets

#define IDH_SYSTEM_SYSTEM               4600
#define IDH_SYSTEM_RESOURCES            4602
#define IDH_SYSTEM_OWNER                4603
#define IDH_SYSTEM_PRO_COPY             4624
#define IDH_SYSTEM_PRO_RENAME           4625
#define IDH_SYSTEM_PRO_DELETE           4626
#define IDH_SYSTEM_PRO_LIST             4627
#define IDH_SYSTEM_LOGO                 4628
#define IDH_SYSTEM_CFG_EDIT             4629
#define IDH_SYSTEM_PROCESSOR            4630
#define IDH_SYSTEM_VIEW_RESOURCETYPE    4631
#define IDH_SYSTEM_PAGING               4632
#define IDH_SYSTEM_ADVANCED             4633
#define IDH_SYSTEM_VIRTMEM_ADJUST       4634
#define IDH_SYSTEM_VIRTMEM_DISABLE      4635

#define IDH_SYSTEM_RESERVE_PICKONE      4636

#define IDH_SYSTEM_RESERVE_MODIFY       4639
#define IDH_SYSTEM_RESERVE_ADD          4640
#define IDH_SYSTEM_RESERVE_REMOVE       4641
#define IDH_SYSTEM_CLASSLIST            4642
#define IDH_SYS_PERF_GRAPHICS           4643
#define IDH_SYS_PERF_GRAPHICS_SLIDER    4644

#define IDH_SYSTEM_FILESYSTEM           4661
#define IDH_SYSTEM_DISK                 4662
#define IDH_SYSTEM_CDROM                4663
#define IDH_SYSTEM_CACHE                4664
#define IDH_SYSTEM_BALANCE              4665
#define IDH_SYSTEM_TROUBLESHOOT         4666
#define IDH_SYSTEM_FSCHANGE             4667
#define IDH_DEVMGR_REMOVEONE            4671
#define IDH_DEVMGR_REMOVEALL            4672
#define IDH_SYSTEM_VIEW_RESRES          4673
#define IDH_DEVMGR_CLASS                4674
#define IDH_DEVMGR_ENABLE_HEAD          4675
#define IDH_DEVMGR_PRINT_SELECT         4676
#define IDH_DEVMGR_PRINT_FILE           4677
#define IDH_DEVMGR_SCSI_INFO            4678
#define IDH_DEVMGR_DISKOPTIONS          4679
#define IDH_DEVMGR_DISCONNECT           4680
#define IDH_DEVMGR_SYNC                 4681
#define IDH_DEVMGR_AUTOINSERT           4682
#define IDH_DEVMGR_REMOVABLE            4683
#define IDH_DEVMGR_INT13                4684
#define IDH_DEVMGR_DRIVE_LETTER         4685
#define IDH_DEVMGR_DRIVE_RESERVED       4686
#define IDH_NHF_HELP                4687
#define IDH_NHF_WINDOWS             4688
#define IDH_NHF_DISK                4689
#define IDH_NHF_NODRIVER            4690
#define IDH_NHF_SIMILAR             4691
#define IDH_DMA_MEMORY              4692
#define IDH_DMA_ADDRESS             4693
#define IDH_DMA_DEFAULT             4694
#define IDH_SCSIPROP_SETTINGS       4695
#define IDH_PCI_ENUMTYPE            4697
#define IDH_PCI_IRQ_STEERING        4698
#define IDH_PCI_SETDEFAULTS         4699

// ID's for File properties

#define IDH_FPROP_VER_INFO                      4700
#define IDH_FPROP_GEN_COMPRESSED                4701
#define IDH_FPROP_GEN_COMPRESSED_SIZE           4702
#define IDH_FPROP_SECURITY_PERMISSIONS          4703
#define IDH_FPROP_SECURITY_AUDITING             4704
#define IDH_FPROP_SECURITY_OWNERSHIP            4705
#define IDH_FPROP_GEN_NAME                      4708
#define IDH_FPROP_GEN_TYPE                      4709
#define IDH_FPROP_GEN_SIZE                      4710
#define IDH_FPROP_GEN_LOCATION                  4711
#define IDH_FPROP_GEN_DOSNAME                   4712
#define IDH_FPROP_GEN_LASTCHANGE                4713
#define IDH_FPROP_GEN_LASTACCESS                4714
#define IDH_FPROP_GEN_READONLY                  4715
#define IDH_FPROP_GEN_ARCHIVE                   4716
#define IDH_FPROP_GEN_HIDDEN                    4717
#define IDH_FPROP_GEN_SYSTEM                    4718
#define IDH_FPROP_GEN_PATH                      4719
#define IDH_FPROP_VER_ABOUT                     4720
#define IDH_FCAB_LINK_NAME                      4721
#define IDH_FCAB_DRV_CLEANUP                    4722
#define IDH_FCAB_LINK_LOCATION                  4723
#define IDH_FCAB_LINK_LINKTO                    4724
#define IDH_FCAB_LINK_LINKTYPE                  4725
#define IDH_FCAB_LINK_SIZE                      4726
#define IDH_FCAB_LINK_WORKING                   4727
#define IDH_FCAB_LINK_HOTKEY                    4728
#define IDH_FCAB_LINK_RUN                       4729
#define IDH_FCAB_LINK_CHANGEICON                4730
#define IDH_FCAB_LINK_FIND                      4731
#define IDH_FCAB_LINK_ICONNAME                  4732
#define IDH_FCAB_LINK_CURRENT_ICON              4733
#define IDH_FCAB_DRV_ICON                       4734
#define IDH_FCAB_DRV_LABEL                      4735
#define IDH_FCAB_DRV_TYPE                       4736
#define IDH_FCAB_DRV_USEDCOLORS                 4737
#define IDH_FCAB_DRV_TOTSEP                     4738
#define IDH_FCAB_DRV_PIE                        4739
#define IDH_FCAB_DRV_LETTER                     4740
#define IDH_FCAB_DRV_FS                         4741
#define IDH_FCAB_DISKTOOLS_CHKNOW               4742
#define IDH_FCAB_DISKTOOLS_BKPNOW               4743
#define IDH_FCAB_DISKTOOLS_OPTNOW               4744
#define IDH_FCAB_DELFILEPROP_DELETED            4745
#define IDH_FCAB_DRV_COMPRESS                   4746
#define IDH_FPROP_GEN_DATE_CREATED              4747
#define IDH_FCAB_FOLDEROPTIONS_ALWAYS           4748
#define IDH_FCAB_FOLDEROPTIONS_NEVER            4749
#define IDH_FCAB_VIEWOPTIONS_SHOWALL            4750
#define IDH_FCAB_VIEWOPTIONS_HIDDENEXTS         4751
#define IDH_FCAB_VIEWOPTIONS_SHOWFULLPATH       4752
#define IDH_FCAB_VIEWOPTIONS_HIDEEXTS           4753
#define IDH_FCAB_VIEWOPTIONS_SHOWDESCBAR        4754
#define IDH_FCAB_FT_PROP_LV_FILETYPES           4755
#define IDH_FCAB_FT_PROP_NEW                    4756
#define IDH_FCAB_FT_PROP_REMOVE                 4757
#define IDH_FCAB_FT_PROP_FINDEXT                4758
#define IDH_FCAB_FT_PROP_EDIT                   4759
#define IDH_FCAB_FT_PROP_DETAILS                4760
#define IDH_FCAB_FT_CMD_ACTION                  4761
#define IDH_FCAB_FT_CMD_EXE                     4762
#define IDH_FCAB_FT_CMD_BROWSE                  4763
#define IDH_FCAB_FT_CMD_USEDDE                  4764
#define IDH_FCAB_FT_CMD_DDEMSG                  4765
#define IDH_FCAB_FT_CMD_DDEAPP                  4766
#define IDH_FCAB_FT_CMD_DDEAPPNOT               4767
#define IDH_FCAB_FT_CMD_DDETOPIC                4768
#define IDH_FCAB_FT_EDIT_DOCICON                4769
#define IDH_FCAB_FT_EDIT_CHANGEICON             4770
#define IDH_FCAB_FT_EDIT_DESC                   4771
#define IDH_FCAB_FT_EDIT_EXT                    4772
#define IDH_FCAB_FT_EDIT_LV_CMDS                4773
#define IDH_FCAB_FT_EDIT_DEFAULT                4774
#define IDH_FCAB_FT_EDIT_NEW                    4775
#define IDH_FCAB_FT_EDIT_EDIT                   4776
#define IDH_FCAB_FT_EDIT_REMOVE                 4777
#define IDH_FCAB_DELFILEPROP_COMPRESSED         4778
#define IDH_FPROP_GEN_ICON                      4779
#define IDH_MULTPROP_NAME                       4780
#define IDH_FPROP_FOLDER_CONTAINS               4781
#define IDH_FCAB_LINK_ICON                      4782
#define IDH_FCAB_DELFILEPROP_LOCATION           4783
#define IDH_FCAB_DELFILEPROP_READONLY           4784
#define IDH_FCAB_DELFILEPROP_HIDDEN             4785
#define IDH_FCAB_DELFILEPROP_ARCHIVE            4786
#define IDH_FCAB_DELFILEPROP_SYSTEM             4787
#define IDH_FCAB_OPENAS_DESCRIPTION             4788
#define IDH_FCAB_OPENAS_APPLIST                 4789
#define IDH_FCAB_OPENAS_OTHER                   4790
#define IDH_FCAB_FT_EDIT_QUICKVIEW              4791
#define IDH_GENDRV_CHKWARN                      4792
#define IDH_GENDRV_MBFREE                       4793
#define IDH_FCAB_OPENAS_MAKEASSOC               4794
#define IDH_FCAB_FT_EDIT_SHOWEXT                4795
#define IDH_FCAB_FT_PROP_CONTTYPERO             4796    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_CONTTYPE               4797    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_DEFEXT                 4798    // T.B.D. IExplorer merge
#define IDH_FCAB_VIEWOPTIONS_SHOWCOMPCOLOR      4799


// Screen saver ids

#define IDH_BEZIER_SPEED                4800
#define IDH_BEZIER_LINES                4801
#define IDH_BEZIER_CURVES               4802
#define IDH_BEZIER_DENSITY              4803
#define IDH_BEZIER_ONECOLOR             4804
#define IDH_BEZIER_CHOOSECLR            4805
#define IDH_BEZIER_MULTCOLOR            4806
#define IDH_BEZIER_CLRSCRN              4807
#define IDH_FLYINGWIN_WARP              4808
#define IDH_FLYINGWIN_DENSTY            4809
#define IDH_COMM_PASSWDCHKBOX           4810
#define IDH_MARQUEE_CENTER              4811
#define IDH_MARQUEE_RANDOM              4812
#define IDH_MARQUEE_SPEED               4813
#define IDH_MARQUEE_COLOR               4814
#define IDH_MARQUEE_TEXT                4815
#define IDH_MARQUEE_FORMAT              4817
#define IDH_MYST_SHAPE                  4818
#define IDH_MYST_ACTVBOX                4819
#define IDH_MYST_LINES                  4820
#define IDH_MYST_TWOCOLORS              4821
#define IDH_MYST_MULTIPLE               4822
#define IDH_MYST_CLEARSCRN              4823
#define IDH_STARS_WARP                  4824
#define IDH_STARS_DENSTY                4825
#define IDH_HOP_DELAY                   4826
#define IDH_HOP_SCALE                   4827

// More ids for file properties (first range wasn't big enough)
#define IDH_FCAB_VIEWOPTIONS_WEBVIEW                    4850
#define IDH_FCAB_VIEWOPTIONS_WIN95VIEW                  4851
#define IDH_FCAB_VIEWOPTIONS_DOUBLECLICKINWEBVIEW       4852
#define IDH_FCAB_VIEWOPTIONS_SINGLECLICKINWEBVIEW       4853
#define IDH_FCAB_LINK_DESCRIPTION                       4854

// New filetype's dialog help ID's
#define IDH_FCAB_FT_NE_ADV_BUT                          4855
#define IDH_FCAB_FT_NE_FILETYPE                         4856
#define IDH_FPROP_GEN_OPENSWITH                         4857
#define IDH_FPROP_GEN_ADVANCED                          4858
#define IDH_FPROP_GEN_INDEX                             4859
#define IDH_FPROP_GEN_ENCRYPT                           4860
#define IDH_FCAB_LINK_RUNASUSER                         4861
#define IDH_FCAB_DRV_INDEX                              4862

#define IDH_FCAB_FT_NE_FILEEXT                          4863
#define IDH_FCAB_FT_PROP_EDIT_RESTORE                   4864

#define IDH_FPROP_GEN_MOUNTEDPROP                       4865
#define IDH_FPROP_GEN_MOUNTEDTARGET                     4866

#define IDH_FPROP_GEN_FOLDER_READONLY                   4867

// id's for date-time property sheet

#define IDH_DATETIME_MONTH              4901
#define IDH_DATETIME_YEAR               4902
#define IDH_DATETIME_DATE               4903
#define IDH_DATETIME_TIME               4904
#define IDH_DATETIME_TIMEZONE           4907
#define IDH_DATETIME_BITMAP             4908
#define IDH_DATETIME_DAYLIGHT_SAVE      4909
#define IDH_DATETIME_CURRENT_TIME_ZONE  4910
#define IDH_DATETIME_DATE_GROUP         4911

// id's for Modem Setup

#define IDH_MODEM_SELECT                5000
#define IDH_MODEM_DETECT                5001
#define IDH_MODEM_PORT                  5002
#define IDH_MODEM_NAME                  5003
#define IDH_MODEM_INSTALLED             5004
#define IDH_MODEM_PROP                  5005
#define IDH_MODEM_NEW                   5006
#define IDH_MODEM_DELETE                5007

// id's for Unimodem property pages

#define IDH_UNI_GEN_MODEM               5050
#define IDH_UNI_GEN_PORT                5051
#define IDH_UNI_GEN_VOLUME              5052
#define IDH_UNI_GEN_MAX_SPEED           5053
#define IDH_UNI_GEN_THIS_SPEED          5054
#define IDH_UNI_CON_PREFS               5055
#define IDH_UNI_CON_CALL_PREFS          5056
//#define IDH_UNI_CON_TONE                5057      Deleted
#define IDH_UNI_CON_DIALTONE            5058
#define IDH_UNI_CON_CANCEL              5059
#define IDH_UNI_CON_DISCONNECT          5060
#define IDH_UNI_CON_PORT                5061
#define IDH_UNI_CON_ADVANCED            5062
#define IDH_UNI_CON_ADV_ERROR           5063
#define IDH_UNI_CON_ADV_REQUIRED        5064
#define IDH_UNI_CON_ADV_COMPRESS        5065
#define IDH_UNI_CON_ADV_CELLULAR        5066
#define IDH_UNI_CON_ADV_FLOW            5067
#define IDH_UNI_CON_ADV_MODULATION      5068
#define IDH_UNI_CON_ADV_CSITT           5069
#define IDH_UNI_CON_ADV_BELL            5070
#define IDH_UNI_CON_ADV_EXTRA           5071
#define IDH_UNI_CON_ADV_AUDIT           5072
//#define IDH_UNI_OPT_CONNECTION          5073      Deleted
#define IDH_UNI_OPT_PRE_DIAL            5074
#define IDH_UNI_OPT_POST_DIAL           5075
#define IDH_UNI_OPT_MANUAL              5076
#define IDH_UNI_OPT_STATUS              5077
#define IDH_UNI_TERMINAL                5078
#define IDH_UNI_STATUS_TALK             5079
#define IDH_UNI_STATUS_HANGUP           5080
#define IDH_UNI_GEN_PORT_INT            5081
#define IDH_UNI_OPT_WAIT                5082

#define IDH_LIGHTS                      5099

// id's for TAPI Dial Helper (5100-5199)

#define IDH_TAPI_ACCESS_LINE            5100
#define IDH_TAPI_AREA_CODE              5101
#define IDH_TAPI_CALLCARD_ADD           5102
#define IDH_TAPI_CALLCARD_ADV           5103
#define IDH_TAPI_CALLCARD_NUMBER        5104
#define IDH_TAPI_CALLCARD_REMOVE        5105
#define IDH_TAPI_CALLCARD_RULES         5106
#define IDH_TAPI_CALLCARDS              5107
#define IDH_TAPI_COPY_FROM_BUTTON       5108
#define IDH_TAPI_COPYFROM               5109
#define IDH_TAPI_COUNTRY                5110
#define IDH_TAPI_CREATE_CARD            5111
#define IDH_TAPI_CREATE_LOCATION        5112
#define IDH_TAPI_LOCATION_CALL_WAIT     5113
#define IDH_TAPI_LOCATION_CARD          5114
#define IDH_TAPI_LOCATION_CARD_CHANGE   5115
#define IDH_TAPI_LOCATION_NEW           5116
#define IDH_TAPI_LOCATION_PHONE         5117
#define IDH_TAPI_LOCATION_PULSE         5118
#define IDH_TAPI_LOCATION_REMOVE        5119
#define IDH_TAPI_LOCATIONS              5120
#define IDH_TAPI_LONG_DISTANCE          5121

// id's 5200 - 5500 are reserved for DOS

//  Add/Remove Program IDs reserved 5600-5699

// Miscellaneous ids

#define IDH_TRAY_RUN_COMMAND            6002
#define IDH_TRAY_RUN_SEPMEM             6003
#define IDH_TRAY_TASKBAR_ONTOP          6004
#define IDH_TRAY_TASKBAR_AUTOHIDE       6005
#define IDH_TRAY_SHUTDOWN_SHUTDOWN      6007
#define IDH_TRAY_SHUTDOWN_RESTART       6008
#define IDH_TRAY_SHUTDOWN_LOGOFF        6009
#define IDH_STARTMENU_SMALLICONS        6010
#define IDH_MENUCONFIG_CLEAR            6011
#define IDH_TRAY_ADD_PROGRAM            6012
#define IDH_TRAY_REMOVE_PROGRAM         6013
#define IDH_TRAY_ADVANCED               6014
#define IDH_TRAY_SHUTDOWN_HELP          6015
#define IDH_TRAY_SHOW_CLOCK             6016
#define IDH_TRAY_REMOVEDLG_LIST         6017
#define IDH_TRAY_REMOVEDLG_DEL          6018
#define IDH_TASKBAR_OPTIONS_BITMAP      6019
#define IDH_TRAY_USE_ADAPTIVE_MENUS     6020
#define IDH_TRAY_RESORT_BUTTON          6021
#define IDH_TRAY_RUN_OK                 6022
#define IDH_TRAY_RUN_CANCEL             6023
#define IDH_TRAY_GROUPING               6024
#define IDH_START_PREVIEW               6025
#define IDH_TRAY_CUSTOMIZE_ICONS        6026
#define IDH_TRAY_RESTOREDEFBUTTON       6027
#define IDH_TRAY_HIDE_ICONS             6028
#define IDH_START_SELECTCLASSIC         6029
#define IDH_START_CUSTOMIZECLASSIC      6030
#define IDH_START_SELECTPERSONAL        6031
#define IDH_START_CUSTOMIZEPERSONAL     6032
#define IDH_TRAY_QUICKLAUNCH            6033

// for the general and advanced tabs of the customize new start menu
#define IDH_START_SPCUST_LARGE          6050
#define IDH_START_SPCUST_SMALL          6051
#define IDH_START_SPCUST_MINPROGS       6052
#define IDH_START_SPCUST_CLEARPROG      6053
#define IDH_START_SPCUST_INTERNET       6054
#define IDH_START_SPCUST_INTERNETCB     6055
#define IDH_START_SPCUST_EMAIL          6056
#define IDH_START_SPCUST_EMAILCB        6057

#define IDH_START_SPCUST_HOVEROPEN      6058
#define IDH_START_SPCUST_NOTIFYNEW      6059
#define IDH_START_STARTMENUSETTINGS     6060
#define IDH_START_SPCUST_RECENT         6061
#define IDH_START_SPCUST_CLEARDOCS      6062

// ID values for Virtual Memory Property sheet

#define IDH_DEVMGR_VIEW_BY              6204
#define IDH_SYSTEM_DM_PRINT             6205
#define IDH_DEVMGR_PATH                 6206

#define IDH_DEVMGR_CONFLICT_TRB         6260
#define IDH_DEVMGR_DRIVERINFO           6261
#define IDH_DEVMGR_CHANGEDRIVER         6262
#define IDH_DEVMGR_DRIVERS              6264
#define IDH_DEVMGR_PRINTER              6265
#define IDH_DEVMGR_PRINTOVERVIEW        6266
#define IDH_DEVMGR_PRINT_SYS            6267
#define IDH_DEVMGR_PRINT_CLASS          6268
#define IDH_DEVMGR_SHOW                 6271
#define IDH_DEVMGR_HAVEDISK             6272
#define IDH_DEVMGR_CHOOSE_DEVICE        6273

//  Ids for the performance page
#define IDH_PERFLOWRES                  6301
#define IDH_PERFLOWMEM                  6302
#define IDH_4MBHELP                     6303
#define IDH_PERFCOMPATVIRTMEM           6304
#define IDH_PERFVIRTMEMOFF              6305
#define IDH_PERFPCMCIAOFF               6306
#define IDH_PERFRMCOMPRESS              6307
#define IDH_PERFNOPMODEDRIVES           6308
#define IDH_PERFMBRHOOK                 6309
#define IDH_PERFREALMODEDRIVE           6310
#define IDH_PERFNOPMODETSR              6311

#define IDH_SYS_PERF_MEMORY             6320
#define IDH_SYS_PERF_SR                 6321
#define IDH_SYS_PERF_FS                 6322
#define IDH_SYS_PERF_VMEM               6323
#define IDH_SYS_PERF_COMPRESS           6324
#define IDH_SYS_PERF_PCMCIA             6325
#define IDH_SYS_PERF_PROBLEM            6326
#define IDH_SYS_PERF_DETAILS            6327


//  sysclass.dll
#define IDH_FPU_DIAGTEXT                6350
#define IDH_FPU_SETTING                 6351
#define IDH_POWERCFG_ENABLE_PM          6352
#define IDH_POWERCFG_FORCE_APM          6353
#define IDH_POWERCFG_DISABLE_INTEL      6354
#define IDH_POWERCFG_POLLING            6355


// More ids for system cpl (ran out of #'s above)
#define IDH_SYSTEM_DMCONFIG_RETRY               6400
#define IDH_SYSTEM_DMCONFIG_IGNORE              6401

#define IDH_SYSTEM_OEMSUPPORT           6407
#define IDH_SYSTEM_DEVGEN_STATUS                6408
#define IDH_SYSTEM_DEGEN_SPECIALMF      6409
#define IDH_SYSTEM_DEVRES_SETTINGS              6410
#define IDH_SYSTEM_USESYSSETTINGS               6411
#define IDH_SYSTEM_DEVRES_CHANGE                6412
#define IDH_SYSTEM_LOGCONFIGLIST                6413
#define IDH_SYSTEM_REGRSTR_RESTORE              6417
#define IDH_SYSTEM_TREE                         6418
#define IDH_SYSTEM_PROPERTIES                   6419
#define IDH_SYSTEM_DM_REFRESH                   6420

#define IDH_SYSTEM_VIRTMEM_ON                   6421
#define IDH_SYSTEM_VIRTMEM_DEFAULT              6422
#define IDH_SYSTEM_VIRTMEM_SWAPDRIVE            6424
#define IDH_SYSTEM_VIRTMEM_MINSIZE              6427
#define IDH_SYSTEM_VIRTMEM_MAXSIZE              6428

#define IDH_SYSTEM_DEVRES_DESC                  6442
#define IDH_SYSTEM_CONFLICT_IO                  6443
#define IDH_SYSTEM_EDITRANGE_STARTVAL           6444
#define IDH_SYSTEM_CONFLICT_USED                6445
#define IDH_SYSTEM_DM_REMOVE                    6446

#define IDH_POWERCFG_ENABLEMETER                        6452
#define IDH_POWERCFG_POWERSTATUSBAR                     6453
#define IDH_POWERCFG_PMLEVELLIST                        6454
#define IDH_POWERCFG_OPTIONS                            6455

#define IDH_PCMCIA_SELECT                               6458
#define IDH_PCMCIA_MEMORY                               6459
#define IDH_PCMCIA_SOUND                                6460
#define IDH_PCMCIA_CARDSERV                             6461

#define IDH_SYSTEM_DEVGEN_DEVDESC                       6462
#define IDH_SYSTEM_DEVRES_MAKEFC                        6463

#define IDH_SYSTEM_DEVRES_LISTCONFLICT                  6474

#define IDH_SYSTEM_VIEW_LIST                            6483
#define IDH_SYSTEM_RCW_LIST                             6485
#define IDH_SYSTEM_RCW_DETAILS                          6488

#define IDH_POWERCFG_STARTMENU          6491
#define IDH_BATMETER_LOWBATWARN         6492

#define IDH_PCMCIA_TRAY                                 6493
#define IDH_PCMCIA_EJECT                                6494
#define IDH_PCMCIA_WARN                                 6495
#define IDH_PCMCIA_LIST                                 6496

// browseui.dll
#define IDH_BROWSEUI_TB_TEXTOPTIONS                             6800
#define IDH_BROWSEUI_TB_ICONOPTIONS                             6801

// More WinDisk IDs

#define IDH_WINDISK_DDEMDBPB_IGNORE                             7000
#define IDH_WINDISK_DDEMDBPB_REPAIR                             7005
#define IDH_WINDISK_DDERRBOOT_IGNORE                            7010
#define IDH_WINDISK_DDERRBOOT_REPAIR                            7015
#define IDH_WINDISK_DDERRCVFNM_IGNORE                           7020
#define IDH_WINDISK_DDERRCVFNM_REPAIR                           7025
#define IDH_WINDISK_DDERRLSTSQZ_DISCARD                         7030
#define IDH_WINDISK_DDERRLSTSQZ_IGNORE                          7035
#define IDH_WINDISK_DDERRLSTSQZ_KEEP                            7040
#define IDH_WINDISK_DDERRMDFAT_IGNORE                           7045
#define IDH_WINDISK_DDERRMDFAT_REPAIR                           7050
#define IDH_WINDISK_DDERRSIG_IGNORE                             7055
#define IDH_WINDISK_DDERRSIG_REPAIR                             7060
#define IDH_WINDISK_DDERRXLSQZ_COPY                             7065
#define IDH_WINDISK_DDERRXLSQZ_DELETE                           7070
#define IDH_WINDISK_DDERRXLSQZ_IGNORE                           7075
#define IDH_WINDISK_DDESIZE2_IGNORE                             7080
#define IDH_WINDISK_DDESIZE2_REPAIR                             7085
#define IDH_WINDISK_FATERRCDLIMIT_DELETE                        7090
#define IDH_WINDISK_FATERRCDLIMIT_IGNORE                        7095
#define IDH_WINDISK_FATERRCDLIMIT_REPAIR                        7100
#define IDH_WINDISK_FATERRFILE_DELETE_FILE                      7105
#define IDH_WINDISK_FATERRFILE_DELETE_FOLDER                    7107
#define IDH_WINDISK_FATERRFILE_IGNORE                           7110
#define IDH_WINDISK_FATERRFILE_REPAIR                           7115
#define IDH_WINDISK_FATERRLSTCLUS_CONVERT                       7120
#define IDH_WINDISK_FATERRLSTCLUS_DISCARD                       7125
#define IDH_WINDISK_FATERRLSTCLUS_IGNORE                        7130
#define IDH_WINDISK_FATERRMISMAT_DONT_REPAIR                    7135
#define IDH_WINDISK_FATERRMISMAT_REPAIR                         7140
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FILE                    7145
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FOLDER                  7150
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FILE                    7155
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FOLDER                  7160
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FILE                    7165
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FOLDER                  7170
#define IDH_WINDISK_FATERRRESVAL_DONT_REPAIR                    7175
#define IDH_WINDISK_FATERRRESVAL_REPAIR                         7180
#define IDH_WINDISK_FATERRXLNK_COPY                             7185
#define IDH_WINDISK_FATERRXLNK_DELETE                           7190
#define IDH_WINDISK_FATERRXLNK_IGNORE                           7195
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_DEL_OTH                 7200
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_TRUNC_OTH               7205
#define IDH_WINDISK_FATERRXLNK_TRUNCATE_ALL                     7210
#define IDH_WINDISK_ISBAD_COMP_HOST_DONE_REPAIR                 7215
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_REPAIR              7220
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_RESTART             7225
#define IDH_WINDISK_ISBAD_COMP_RETRY                            7230
#define IDH_WINDISK_ISBAD_IGNORE                                7235
#define IDH_WINDISK_ISBAD_SYSTEM_IGNORE                         7240
#define IDH_WINDISK_ISBAD_SYSTEM_RETRY                          7245
#define IDH_WINDISK_ISBAD_UNCOMP_DATA_REPAIR                    7250
#define IDH_WINDISK_ISBAD_UNCOMP_RETRY                          7255
#define IDH_WINDISK_ISNTBAD_RETRY                               7260
#define IDH_WINDISK_ISNTBAD_CLEAR                               7265
#define IDH_WINDISK_ISNTBAD_LEAVE                               7270
#define IDH_WINDISK_ISTR_FATERRCIRCC_DELETE                     7275
#define IDH_WINDISK_ISTR_FATERRCIRCC_IGNORE                     7280
#define IDH_WINDISK_ISTR_FATERRCIRCC_TRUNCATE                   7285
#define IDH_WINDISK_ISTR_FATERRDIR_DELETE                       7290
#define IDH_WINDISK_ISTR_FATERRDIR_IGNORE                       7295
#define IDH_WINDISK_ISTR_FATERRDIR_REPAIR                       7300
#define IDH_WINDISK_ISTR_FATERRINVCLUS_DELETE                   7305
#define IDH_WINDISK_ISTR_FATERRINVCLUS_IGNORE                   7310
#define IDH_WINDISK_ISTR_FATERRINVCLUS_TRUNCATE                 7315
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_NOTSET      7320
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_SET         7330
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_NOTSET      7340
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_SET         7350
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_NOTSET      7360
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_SET         7370
#define IDH_WINDISK_MEMORYERROR_IGNORE                          7380
#define IDH_WINDISK_MEMORYERROR_RETRY                           7385
#define IDH_WINDISK_READERROR_RETRY                             7390
#define IDH_WINDISK_READWRITEERROR_COMP_SYSTEM_IGNORE           7395
#define IDH_WINDISK_READWRITEERROR_COMP_THOROUGH                7400
#define IDH_WINDISK_READWRITEERROR_DATA_IGNORE                  7405
#define IDH_WINDISK_READWRITEERROR_UNCOMP_SYSTEM_IGNORE         7410
#define IDH_WINDISK_READWRITEERROR_UNCOMP_THOROUGH              7415
#define IDH_WINDISK_WRITEERROR_RETRY                            7420
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FILE              7425
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FOLDER            7430
#define IDH_SCANDISK                                            7431
#define IDH_SCANDISK_FINISH                                     7432
#define IDH_SCANDISK_FINISH_SURF_HOST                           7433
#define IDH_SCANDISK_FINISH_SURF                                7434
#define IDH_COMPRESS_CORRECT_SIZE                               7435
#define IDH_COMPRESS_CORRECT_RATIO                              7436
#define IDH_UTILITIES_DEFRAG_DISK_ERROR                         7437
#define IDH_CVF_TOO_SMALL_CHECK_HOST                            7438
#define IDH_THOROUGH_TEST_CHECK_HOST                            7439
#define IDH_DISK_LOGICAL                                        7440
#define IDH_DISK_PHYSICAL                                       7441
#define IDH_WINDISK_DDERRMDFAT_LOST_REPAIR                      7442
#define IDH_WINDISK_DDERRMDFAT_LOST_IGNORE                      7443
#define IDH_WINDISK_ISBAD_NO_FREE_CLUSTER                       7444
#define IDH_WINDISK_MAIN_LIST                                   7445
#define IDH_WINDISK_MAIN_STANDARD                               7446
#define IDH_WINDISK_MAIN_OPTIONS                                7447
#define IDH_WINDISK_MAIN_THOROUGH                               7448
#define IDH_WINDISK_MAIN_AUTOFIX                                7449
#define IDH_WINDISK_MAIN_ADVANCED                               7450
#define IDH_WINDISK_ADV_ALWAYS                                  7451
#define IDH_WINDISK_ADV_NEVER                                   7452
#define IDH_WINDISK_ADV_ONLY_IF_FOUND                           7453
#define IDH_WINDISK_ADV_DELETE                                  7454
#define IDH_WINDISK_ADV_MAKE_COPIES                             7455
#define IDH_WINDISK_ADV_IGNORE                                  7456
#define IDH_WINDISK_ADV_FILENAME                                7457
#define IDH_WINDISK_ADV_DATE_TIME                               7458
#define IDH_WINDISK_ADV_CHECK_HOST                              7459
#define IDH_WINDISK_ADV_FREE                                    7460
#define IDH_WINDISK_ADV_CONVERT                                 7461
#define IDH_WINDISK_OPTIONS_SYS_AND_DATA                        7462
#define IDH_WINDISK_OPTIONS_SYS_ONLY                            7463
#define IDH_WINDISK_OPTIONS_DATA_ONLY                           7464
#define IDH_WINDISK_OPTIONS_NO_WRITE_TEST                       7465
#define IDH_WINDISK_OPTIONS_NO_HID_SYS                          7466
#define IDH_FORMATDLG_CAPACITY                                  7467
#define IDH_FORMATDLG_QUICK                                     7468
#define IDH_FORMATDLG_FULL                                      7469
#define IDH_FORMATDLG_DOSYS                                     7470
#define IDH_FORMATDLG_LABEL                                     7471
#define IDH_FORMATDLG_NOLAB                                     7472
#define IDH_FORMATDLG_REPORT                                    7473
#define IDH_FORMATDLG_MKSYS                                     7474
#define IDH_WINDISK_MAIN_START                                  7475
#define IDH_WINDISK_MAIN_CLOSE                                  7476
#define IDH_WINDISK_OK_FOR_ERRORS                               7477
#define IDH_WINDISK_CANCEL_FOR_ERRORS                           7478
#define IDH_WINDISK_MORE_INFO                                   7479
#define IDH_FORMATDLG_START                                     7480
#define IDH_WINDISK_REPLACE_LOG                                 7481
#define IDH_WINDISK_APPEND_LOG                                  7482
#define IDH_WINDISK_NO_LOG                                      7483
#define IDH_FORMATDLG_FILESYS                                   7484
#define IDH_FORMATDLG_ALLOCSIZE                                 7485
#define IDH_FORMATDLG_QUICKFULL                                 7486
#define IDH_FORMATDLG_COMPRESS                                  7487

#define IDH_CHKDSKDLG_START                                     7488
#define IDH_CHKDSKDLG_FIXERRORS                                 7489
#define IDH_CHKDSKDLG_SCAN                                      7490
#define IDH_CHKDSKDLG_CANCEL                                    7491
#define IDH_CHKDSKDLG_PROGRESS                                  7492
#define IDH_FORMATDLG_PROGRESS                                  7493

// IDs for Port Settings

#define IDH_PORT_BAUD                                           7900
#define IDH_PORT_DATA                                           7901
#define IDH_PORT_PARITY                                         7902
#define IDH_PORT_STOPBITS                                       7903
#define IDH_PORT_FLOW                                           7904
#define IDH_PORT_RESTORE                                        7905

// IDs for Modem Diagnostics

#define IDH_MODEM_DIAG_INSTALLED                                7950
#define IDH_MODEM_DIAG_HELP                                     7951
#define IDH_MODEM_DIAG_MOREINFO                                 7952
#define IDH_MODEM_DIAG_DRIVER                                   7953

// IDs for Wastebasket/Recycle

#define IDH_WASTE_FREEING_DISK_SPACE                            8000
#define IDH_RECYCLE_CONFIG_INDEP                                8001
#define IDH_RECYCLE_CONFIG_ALL                                  8002
#define IDH_RECYCLE_PURGE_ON_DEL                                8003
#define IDH_RECYCLE_MAX_SIZE                                    8004
#define IDH_RECYCLE_DRIVE_SIZE                                  8005
#define IDH_RECYCLE_BIN_SIZE                                    8006
#define IDH_DELETE_CONFIRM_DLG                                  8007

#define IDH_FPROP_GEN_CHANGE                                    475102
#define IDH_CONFIRM_OPEN                                        51065
#define IDH_SAME_WINDOW                                         51066

// ID values 8100-8199 are reserved for Font dialog.

#define IDH_TRAY_START_MENU_SETTINGS                            51132
#define IDH_TRAY_DISPLAY_LOGOFF                                 51133
#define IDH_TRAY_DISPLAY_FAVORITES                              51134
#define IDH_TRAY_EXPAND_CPANEL                                  51135
#define IDH_TRAY_EXPAND_MYDOCS                                  51136
#define IDH_TRAY_EXPAND_PRINTERS                                51137
#define IDH_TRAY_SCROLL_PROGRAMS                                51138
#define IDH_TRAY_PERSONALIZED_MENUS                             51139
#define IDH_TRAY_DISPLAY_ADMIN_TOOLS                            51140

#define IDH_TRAY_ENABLEMOVERESIZE                               51143
#define IDH_TRAY_CONTEXTMENU                                    51144

#define IDH_DATETIME_AUTOSETFROMINTERNET                        51150
#define IDH_DATETIME_UPDATEFROMINTERNET                         51151
#define IDH_DATETIME_SERVER_EDIT                                51152
#define IDH_DATETIME_INFOTEXT                                   51153
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\dlgs.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dlgs.h

Abstract:

    This module contains the UI dialog header information.

--*/


#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_


//
//  Constant Declarations.
//

#define ctlFirst    0x0400
#define ctlLast     0x04ff

//
//  Push buttons.
//
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f

//
//  Checkboxes.
//
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f

//
//  Radio buttons.
//
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f

//
//  Groups, frames, rectangles, and icons.
//
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f

//
//  Static text.
//
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f

//
//  Listboxes.
//
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f

//
//  Combo boxes.
//
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f

//
//  Edit controls.
//
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f

//
//  Scroll bars.
//
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

//
//  Controls
//
#define ctl1        0x04A0

//
//  These dialog resource ordinals really start at 0x0600, but the
//  RC Compiler can't handle hex for resource IDs, hence the decimal.
//
#ifdef UNIX

#define MW_BIG_FILEOPENORD      10000
#define MW_BIG_MULTIFILEOPENORD 10001

#define FILEOPENORDMOTIF        10003
#define PRINTDLGORDMOTIF        10004
#define FINDDLGORDMOTIF         10005
#endif

#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544
#define RUNDLGORD        1545

#if (WINVER >= 0x400)
#define PAGESETUPDLGORD         1546
#define NEWFILEOPENORD          1547
#define PRINTDLGEXORD           1549
#define PAGESETUPDLGORDMOTIF    1550
#define COLORMGMTDLGORD         1551
#define NEWFILEOPENV2ORD        1552
#endif /* WINVER >= 0x400) */






//
//  Typedef Declarations.
//
typedef struct tagCRGB
{
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
} CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\cleanoc.h ===
#ifndef __CLEANOC_API__
#define __CLEANOC_API__

// Flags used in GetControlInfo()
#define GCI_NAME         1
#define GCI_FILE         2
#define GCI_CLSID        3
#define GCI_TYPELIBID    4
#define GCI_TOTALSIZE    5
#define GCI_SIZESAVED    6
#define GCI_TOTALFILES   7
#define GCI_CODEBASE     8
#define GCI_ISDISTUNIT   9
#define GCI_DIST_UNIT_VERSION 10
#define GCI_STATUS       11
#define GCI_HAS_ACTIVEX  12
#define GCI_HAS_JAVA     13

// control status flags
#define STATUS_CTRL_UNKNOWN             0   // Errors prevent determining the actual control state
#define STATUS_CTRL_INSTALLED           1   // Control is properly installed and ready for use
#define STATUS_CTRL_SHARED              2   // One or more components are shared by more than one control
#define STATUS_CTRL_DAMAGED             3   // The control file or some part of the installation is damaged or missing
#define STATUS_CTRL_UNPLUGGED           4   // The control has been re-registered in another location, the cache's
                                            // instance of the control is no longer being used.

// RemoveExpiredControls flags
#define REC_SILENT     1    // If set, controls whose deletion would require confirmation are not removed.

///////////////////////////////////////////////////////////////////////////////
// FindFirstControl
//
// Purpose:
//     Initiate a search on the registry for an installed ActiveX control.
//
// Return Value:
//     - ERROR_SUCCESS if a control is found and search has been successfully
//       initiated.
//     - ERROR_NO_MORE_ITEMS if no control is found.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h
//
// Parameters:
//     hFindHandle    -- a handle needed for resuming the search.  Caller must
//                       pass this handle to FindNextControl to retrieve the
//                       the next installed ActiveX control.
//     hControlHandle -- handle to a control's data.  Caller must pass this
//                       handle into GetControlInfo to retrieve information
//                       about the control.  Call ReleaseControlHandle on the
//                       handle when done.  
//     lpCachePath    -- points to a string buffer that has the path where
//                       all controls to be retrieved are located.  If it
//                       is NULL, the internet cache path will be read
//                       from the registry.  If a path is to be supplied,
//                       the path must be a full pathname without any ~'s
//                       in order for the enumeration to work correctly.
//
#define axcFINDFIRSTCONTROL "FindFirstControl"

LONG WINAPI FindFirstControl(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle, 
                     LPCTSTR lpszCachePath = NULL
                     );

typedef LONG (WINAPI *FINDFIRSTCONTROL)(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle, 
                     LPCTSTR lpszCachePath = NULL
                     );


///////////////////////////////////////////////////////////////////////////////
// FindNextControl
//
// Purpose:
//     Resume a previously started search for installed ActiveX controls. The
//     search must have been initiated by a call to FirstFirstControl.
//
// Return Value:
//     - ERROR_SUCCESS if a control is found and search has been successfully
//       initiated.
//     - ERROR_NO_MORE_ITEMS if no control is found.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h.  In this situation, the caller can choose to continue
//       the search with another call to FindNextControl, or simply abort.
//
// Parameters:
//     hFindHandle    -- a handle received from a call to FindFirstControl.
//                       Pass this handle to subsequent calls to
//                       FindNextControl to retrieve controls one at a time.
//     hControlHandle -- handle to a control's data.  Caller must pass this
//                       handle into GetControlInfo to retrieve information
//                       about the control.  Call ReleaseControlHandle on the
//                       handle when done.  
//
#define axcFINDNEXTCONTROL "FindNextControl"

LONG WINAPI FindNextControl(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle
                     );

typedef LONG (WINAPI *FINDNEXTCONTROL)(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle
                     );

///////////////////////////////////////////////////////////////////////////////
// FindControlClose
//
// Purpose:
//     Called when search is over.  Missing a call to this function after a
//     search might contribute memory leak.  This function can be called
//     regardless of what FindFirstControl and/or FindNextControl return.
//
// Return Value:
//     None.
//
// Parameters:
//     hFindHandle -- a handle obtained from calls to FindFirstControl and
//                    FindNextControl in the current search.
//
#define axcFINDCONTROLCLOSE "FindControlClose"

void WINAPI FindControlClose(
                     HANDLE hFindHandle
                     );

typedef void (WINAPI *FINDCONTROLCLOSE)(
                     HANDLE hFindHandle
                     );


///////////////////////////////////////////////////////////////////////////////
// ReleaseControlHandle
//
// Purpose:
//     When a handle of a control is retrieved via FindFirstControl or
//     FindNextControl, the caller is responsible to release that handle
//     by call this function.
//
// Return Value:
//     None.
//
// Parameters:
//     hControlHandle -- a handle to a control obtained from FindFirstControl
//                       or FindNextControl.
//
#define axcRELEASECONTROLHANDLE "ReleaseControlHandle"

void WINAPI ReleaseControlHandle(
                          HANDLE hControlHandle
                          );

typedef void (WINAPI *RELEASECONTROLHANDLE)(
                          HANDLE hControlHandle
                          );


///////////////////////////////////////////////////////////////////////////////
// GetControlInfo
//
// Purpose:
//     Once a handle to a control is obtained via FindFirstControl or
//     FindNextControl, the caller may retrieve information about the control
//     by call this function with a flag (nFlag) indicating what info to
//     retrieve.  The supported flags are:
//     GCI_NAME       -- friendly name of control
//     GCI_FILE       -- main full path & file name of control
//     GCI_CLSID      -- clsid of control, in a NULL-terminated string
//     GCI_TYPELIBID  -- typelib guid of control, in a NULL-terminated string
//     GCI_TOTALSIZE  -- total size in bytes of all control's dependent files
//     GCI_SIZESAVED  -- total size in bytes restored if control is removed
//                       It can be different from GCI_TOTALSIZE since some
//                       of the control's dependent files might be shared dlls
//     GCI_TOTALFILES -- total number of control dependent files, including
//                       shared dlls if there are any
//     GCI_STATUS     -- the controls status value from STATUS_CTRL_* <above>
//     GCI_HAS_ACTIVEX -- non-zero if control includes ActiveX contols(s)
//     GCI_HAS_JAVA   -- non-zero if control includes Java packages
//
// Return Value:
//     TRUE if succeeded, FALSE otherwise.
//
// Parameters:
//     hControlHandle -- handle to a control for which information is to be
//                       retrieved.
//     nFlag          -- indicate which information to retrieve. Please refer
//                       to Purpose section above for a list of supported 
//                       flags.  nFlag can only equal to one of them so do
//                       not pass in multiple flags OR'ed together.
//     lpdwData       -- address of a buffer for storing a numerical value.
//                       (ie. GCI_TOTALSIZE, GCI_SIZESAVED & GCI_TOTALFILES)
//                       This parameter is ignored for other flags.
//     lpszData       -- address of a buffer for storing a NULL-terminated
//                       string value (ie. GCI_NAME, GCI_FILE, GCI_CLSID &
//                       GCI_TYPELIBID)  This paramter is ignored if other
//                       flags are specified.
//     nBufLen        -- length of string buffer pointed to by lpszData.
//                       This parameter is ignored if a numerical value is
//                       being retrieved.
//
#define axcGETCONTROLINFO "GetControlInfo"

BOOL WINAPI GetControlInfo(
                      HANDLE hControlHandle, 
                      UINT nFlag,
                      LPDWORD lpdwData,
                      LPTSTR lpszBuf,
                      int nBufLen
                      );

typedef BOOL (WINAPI *GETCONTROLINFO)(
                      HANDLE hControlHandle, 
                      UINT nFlag,
                      LPDWORD lpdwData,
                      LPTSTR lpszBuf,
                      int nBufLen
                      );


///////////////////////////////////////////////////////////////////////////////
// GetControlDependentFile
//
// Purpose:
//     A given control might depend on other files.  For instance, FOO.OCX
//     might need FOO.INF and MFCXX.DLL in order to work.  This function
//     retrieves one file at a time from a list of files depended upon by a
//     given ActiveX control.  The list of files is NOT sorted.
//
// Return Value:
//     - ERROR_SUCCESS if a file is found at position iFile in the list.
//     - ERROR_NO_MORE_FILES if no file is found at position iFile in the list.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h.
//     
// Parameters:
//     iFile          -- a zero-based index indicating which file in the list
//                       to retrieve.
//     hControlHandle -- handle to a control obtained via FindFirstControl
//                       or FindNextControl.
//     lpszFile       -- points to a buffer used to store the retrieved name.
//     lpszSize       -- points to a DWORD variable that is to store the size
//                       in bytes of the file retrieved.  If it is 0, the file
//                       does not exist.
//     bToUpper       -- TRUE if the filename returned is to be converted to
//                       uppercase.  No conversion takes place if FALSE
//          
#define axcGETCONTROLDEPENDENTFILE "GetControlDependentFile"
         
LONG WINAPI GetControlDependentFile(
             int iFile,
             HANDLE hControlHandle,
             LPTSTR lpszFile,
             LPDWORD lpdwSize,
             BOOL bToUpper = FALSE
             );

typedef LONG (WINAPI *GETCONTROLDEPENDENTFILE)(
             int iFile,
             HANDLE hControlHandle,
             LPTSTR lpszFile,
             LPDWORD lpdwSize,
             BOOL bToUpper = FALSE
             );


///////////////////////////////////////////////////////////////////////////////
// IsModuleRemovable
//
// Purpose:
//     Checks whether a file can be removed by looking into the registry.
//     This function is called "IsModuleRemovable" instead of
//     "IsFileRemovable" because this routine does not check the actual file
//     for its status.  For instance, a file can be deemed removable even if
//     is being exclusively opened by someone.  This routine only tells from
//     the registry's point of view if a file can be safely removed or not.
//
// Return Value:
//     - FALSE if there is any indication that the given file is being shared
//       by other applications.
//     - TRUE otherwise.
//
// Parameter: 
//     lpszFile -- points to a buffer that has the name (with full path) of
//                 the file whose removal status is to be verified.
//
#define axcISMODULEREMOVABLE "IsModuleRemovable"

BOOL WINAPI IsModuleRemovable(
             LPCTSTR lpszFile
             );

typedef BOOL (WINAPI *ISMODULEREMOVABLE)(
             LPCTSTR lpszFile
             );


///////////////////////////////////////////////////////////////////////////////
// RemoveControlByHandle
//
// Purpose:
//     Remove a control from registry as well as all the files that the control
//     depends on.  
//
// Return Value:
//     - S_OK if control has been successfully uninstalled.
//     - S_FALSE if minor error has occurred, but not serious enough to
//       abort the uninstallation.  Control has been uninstalled when the
//       call returns.
//     - An error code defined in winerror.h if an serious error has occurred
//       and uninstallation has been aborted.  The state of the control
//       is not gaurenteed.
//
// Parameters:
//     lpControlData -- points to an instance of CONTROL_DATA representing the
//                      control to be removed.  The struct must have been
//                      initialized by a call to FindFirstControl or
//                      FindNextControl.  Be sure to call ReleaseControlData
//                      on this struct after successful removal, for the data
//                      in this struct is no longer useful.
//     bForceRemove  -- If this flag is FALSE, the removal routine will check
//                      if the control is safe for removal before removing it.
//                      If the flag is TRUE, the control will be removed
//                      regardless of its removal status (except for Shared
//                      Violation).  The flag only applies to the control file
//                      itself.  Other files upon which the control depends are
//                      removed only if they are deemed as safe for removal.
//
#define axcREMOVECONTROLBYHANDLE "RemoveControlByHandle"

HRESULT WINAPI RemoveControlByHandle(
             HANDLE hControlHandle,
             BOOL bForceRemove = FALSE
             );

typedef HRESULT (WINAPI *REMOVECONTROLBYHANDLE)(
             HANDLE hControlHandle,
             BOOL bForceRemove = FALSE
             );


///////////////////////////////////////////////////////////////////////////////
// RemoveControlByName
//
// Purpose:
//     Remove a control from registry as well as all the files that the control
//     depends on.  It is an overloaded version.
//
// Return Value:
//     - S_OK if control has been successfully uninstalled.
//     - S_FALSE if minor error has occurred, but not serious enough to
//       abort the uninstallation.  Control has been uninstalled when the
//       call returns.
//     - An error code defined in winerror.h if an serious error has occurred
//       and uninstallation has been aborted.  The state of the control
//       is not gaurenteed.
//
// Parameters:
//     lpszFile      -- Address of a null-terminated string which is the main
//                      file for the control (ie "FOO.OCX" for FOO control).
//     lpszCLSID     -- Address of a null-terminated string which is the CLSID
//                      of the control.
//     lpszTypeLibID -- Address of a null-terminated string which is the TypeLib
//                      clsid of the control.
//     bForceRemove  -- If this flag is FALSE, the removal routine will check
//                      if the control is safe for removal before removing it.
//                      If the flag is TRUE, the control will be removed
//                      regardless of its removal status (except for Shared
//                      Violation).  The flag only applies to the control file
//                      itself.  Other files upon which the control depends are
//                      removed only if they are deemed as safe for removal.
//     dwIsDistUnit  -- boolean value to tell if this is really a dist unit
//
#define axcREMOVECONTROLBYNAME "RemoveControlByName"

HRESULT WINAPI RemoveControlByName(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove = FALSE,
             DWORD dwIsDistUnit = FALSE
             );

typedef HRESULT (WINAPI *REMOVECONTROLBYNAME)(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove = FALSE,
             DWORD dwIsDistUnit = FALSE
             );


///////////////////////////////////////////////////////////////////////////////
// type PFNDOBEFOREREMOVAL, used for function SweepControlsByLastAccessDate
//
// Purpose:
//     Define callback function to be called right before removing a control
//
// Return Values:
//     If a success code (S_XXX) is returned, the control will be removed.
//     If a fail code (E_XXX) is returned, the control will be skipped.
//
// Parameters:
//     HANDLE -- handle to the control to be removed.  One can get information
//               about the control using the GetControlInfo function.  Do NOT
//               call ReleaseControlHandle on the handle.
//     UINT   -- number of remaining controls including this one.
//
typedef HRESULT (CALLBACK *PFNDOBEFOREREMOVAL)(HANDLE, UINT);


///////////////////////////////////////////////////////////////////////////////
// type PFNDOAFTERREMOVAL, used for function SweepControlsByLastAccessDate
//
// Purpose:
//     Define callback function to be called right after removing a control
//
// Return Values:
//     If a success code (S_XXX) is returned, the removal operation proceeds.
//     If a fail code (E_XXX) is returned, the removal operation is aborted.
//
// Parameters:
//     HRESULT -- result of removing the control.  The handle to this control
//                was passed to the callback of type PFNDOBEFOREREMOVAL before
//                the control was removed.  The possible values for this
//                HRESULT parameter are:
//                - S_OK (succeeded)
//                - S_FALSE (control had been removed with possibly some very
//                  minor errors)
//                - E_ACCESSDENIED (control not safe for removal)
//                - STG_E_SHAREVIOLATION (control being used by others)
//                - Other errors returned by registry functions
//                It is up to the implementator of this function to decide
//                what to do given the result of removing the last control.
//     UINT    -- number of remaining controls, NOT including the one just
//                removed.
//
typedef HRESULT (CALLBACK *PFNDOAFTERREMOVAL)(HRESULT, UINT);


///////////////////////////////////////////////////////////////////////////////
// SweepControlsByLastAccessDate
//
// Purpose:
//     Remove all controls whose last access date is before and on a given
//     date.
//
// Return Value:
//     - S_OK if succeeded and at least one control was removed.
//     - S_FALSE if succeeded but no controls have been removed.
//     - E_XXX defined in winerror.h if an error has occurred.
//
// Parameters:
//     pLastAccessTime -- specify a last access date.  All controls accessed
//                        before and on this date are to be removed.  Note
//                        that all fields except wYear, wMonth and wDay are
//                        ignored.  If NULL, all control will be removed.
//     pfnDoBefore     -- callback function called just before a control is
//                        removed.  Please read the description for type
//                        PFNDOBEFOREREMOVAL for details.  If NULL, nothing
//                        is to be done prior to removing a control.
//     pfnDoAfter      -- callback function called right after a control is
//                        removed.  Please read the description for type
//                        PFNDOAFTERREMOVAL for details.  If NULL, nothing
//                        is to be done after a control is removed.
//     dwSizeLimit     -- controls will be removed only if the total size
//                        (in bytes) of all controls exceeds the size
//                        specified by this paramter.  This parameter is
//                        ignored if 0 is specified.
//
#define axcSWEEPCONTROLSBYLASTACCESSDATE "SweepControlsByLastAccessDate"

HRESULT WINAPI SweepControlsByLastAccessDate(
                              SYSTEMTIME *pLastAccessTime = NULL,
                              PFNDOBEFOREREMOVAL pfnDoBefore = NULL,
                              PFNDOAFTERREMOVAL pfnDoAfter = NULL,
                              DWORD dwSizeLimit = 0
                              );

typedef HRESULT (WINAPI *SWEEPCONTROLSBYLASTACCESSDATE)(
                              SYSTEMTIME *pLastAccessTime = NULL,
                              PFNDOBEFOREREMOVAL pfnDoBefore = NULL,
                              PFNDOAFTERREMOVAL pfnDoAfter = NULL,
                              DWORD dwSizeLimit = 0
                              );


///////////////////////////////////////////////////////////////////////////////
// RemoveExpiredControls
//
// Purpose:
//     Similar to IEmptyVolumeCache. Removes all controls with a last
//     access date in the distant past and all controls flagged for more
//     rapid auto-expire.
//
// Return Value:
//     - S_OK if succeeded and at least one control was removed.
//     - S_FALSE if succeeded but no controls have been removed.
//     - E_XXX defined in winerror.h if an error has occurred.
//
// Parameters:
//     dwFlags         -- Currently, only REC_SILENT is defined.
//     dwReserved      -- Must be 0.
//
#define axcREMOVEEXPIREDCONTROLS "RemoveExpiredControls"

HRESULT WINAPI RemoveExpiredControls(DWORD dwFlags, DWORD dwReserved);

typedef HRESULT (WINAPI *REMOVEEXPIREDCONTROLS)(DWORD dwFlags, DWORD dwReserved);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\lpcthemes.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCThemes.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are specific to
//  the theme services API.
//
//  History:    2000-10-10  vtan        created
//              2000-11-11  vtan        collapse to single instance
//  --------------------------------------------------------------------------

#ifndef     _LPCThemes_
#define     _LPCThemes_

#include <LPCGeneric.h>

static  const WCHAR     THEMES_PORT_NAME[]              =   L"\\ThemeApiPort";
static  const WCHAR     THEMES_CONNECTION_REQUEST[]     =   L"ThemeApiConnectionRequest";
static  const WCHAR     THEMES_START_EVENT_NAME[]       =   L"ThemesStartEvent";

enum
{
    API_THEMES_THEMEHOOKSON             =   1,
    API_THEMES_THEMEHOOKSOFF,
    API_THEMES_GETSTATUSFLAGS,
    API_THEMES_GETCURRENTCHANGENUMBER,
    API_THEMES_GETNEWCHANGENUMBER,
    API_THEMES_SETGLOBALTHEME,
    API_THEMES_GETGLOBALTHEME,
    API_THEMES_CHECKTHEMESIGNATURE,
    API_THEMES_LOADTHEME,
    API_THEMES_MARKSECTION,

    API_THEMES_USERLOGON                =   1001,
    API_THEMES_USERLOGOFF,
    API_THEMES_SESSIONCREATE,
    API_THEMES_SESSIONDESTROY,
    API_THEMES_PING
};

typedef struct
{
} API_THEMES_THEMEHOOKSON_IN;

typedef struct
{
    HRESULT             hr;
} API_THEMES_THEMEHOOKSON_OUT;

typedef struct
{
} API_THEMES_THEMEHOOKSOFF_IN;

typedef struct
{
    HRESULT         hr;
} API_THEMES_THEMEHOOKSOFF_OUT;

typedef struct
{
} API_THEMES_GETSTATUSFLAGS_IN;

typedef struct
{
    DWORD           dwFlags;
} API_THEMES_GETSTATUSFLAGS_OUT;

typedef struct
{
} API_THEMES_GETCURRENTCHANGENUMBER_IN;

typedef struct
{
    int             iChangeNumber;
} API_THEMES_GETCURRENTCHANGENUMBER_OUT;

typedef struct
{
} API_THEMES_GETNEWCHANGENUMBER_IN;

typedef struct
{
    int             iChangeNumber;
} API_THEMES_GETNEWCHANGENUMBER_OUT;

typedef struct
{
    HANDLE          hSection;
} API_THEMES_SETGLOBALTHEME_IN;

typedef struct
{
    HANDLE          hSection;
    DWORD           dwAdd;
    DWORD           dwRemove;
} API_THEMES_MARKSECTION_IN;

typedef struct
{
} API_THEMES_MARKSECTION_OUT;

typedef struct
{
    HRESULT         hr;
} API_THEMES_SETGLOBALTHEME_OUT;

typedef struct
{
} API_THEMES_GETGLOBALTHEME_IN;

typedef struct
{
    HRESULT         hr;
    HANDLE          hSection;
} API_THEMES_GETGLOBALTHEME_OUT;

typedef struct
{
    const WCHAR     *pszName;
    int             cchName;
} API_THEMES_CHECKTHEMESIGNATURE_IN;

typedef struct
{
    HRESULT         hr;
} API_THEMES_CHECKTHEMESIGNATURE_OUT;

typedef struct
{
    const WCHAR     *pszName;
    int             cchName;
    const WCHAR     *pszColor;
    int             cchColor;
    const WCHAR     *pszSize;
    int             cchSize;
    HANDLE          hSection;
} API_THEMES_LOADTHEME_IN;

typedef struct
{
    HRESULT         hr;
    HANDLE          hSection;
} API_THEMES_LOADTHEME_OUT;

typedef struct
{
} API_THEMES_GETLASTERRORCONTEXT_IN;

typedef struct
{
} API_THEMES_GETLASTERRORCONTEXT_OUT;

typedef struct
{
} API_THEMES_GETERRORCONTEXTSECTION_IN;

typedef struct
{
    HANDLE          hSection;
} API_THEMES_GETERRORCONTEXTSECTION_OUT;

typedef struct
{
    HANDLE          hToken;
} API_THEMES_USERLOGON_IN;

typedef struct
{
} API_THEMES_USERLOGON_OUT;

typedef struct
{
} API_THEMES_USERLOGOFF_IN;

typedef struct
{
} API_THEMES_USERLOGOFF_OUT;

typedef struct
{
    void            *pfnRegister;
    void            *pfnUnregister;
    void            *pfnClearStockObjects;
    DWORD           dwStackSizeReserve;
    DWORD           dwStackSizeCommit;
} API_THEMES_SESSIONCREATE_IN;

typedef struct
{
} API_THEMES_SESSIONCREATE_OUT;

typedef struct
{
} API_THEMES_SESSIONDESTROY_IN;

typedef struct
{
} API_THEMES_SESSIONDESTROY_OUT;

typedef struct
{
} API_THEMES_PING_IN;

typedef struct
{
} API_THEMES_PING_OUT;

typedef union
{
    union
    {
        API_THEMES_THEMEHOOKSON_IN             in;
        API_THEMES_THEMEHOOKSON_OUT            out;
    } apiThemeHooksOn;
    union
    {
        API_THEMES_THEMEHOOKSOFF_IN             in;
        API_THEMES_THEMEHOOKSOFF_OUT            out;
    } apiThemeHooksOff;
    union
    {
        API_THEMES_GETSTATUSFLAGS_IN            in;
        API_THEMES_GETSTATUSFLAGS_OUT           out;
    } apiGetStatusFlags;
    union
    {
        API_THEMES_GETCURRENTCHANGENUMBER_IN    in;
        API_THEMES_GETCURRENTCHANGENUMBER_OUT   out;
    } apiGetCurrentChangeNumber;
    union
    {
        API_THEMES_GETNEWCHANGENUMBER_IN        in;
        API_THEMES_GETNEWCHANGENUMBER_OUT       out;
    } apiGetNewChangeNumber;
    union
    {
        API_THEMES_SETGLOBALTHEME_IN            in;
        API_THEMES_SETGLOBALTHEME_OUT           out;
    } apiSetGlobalTheme;
    union
    {
        API_THEMES_MARKSECTION_IN               in;
        API_THEMES_MARKSECTION_OUT              out;
    } apiMarkSection;
    union
    {
        API_THEMES_GETGLOBALTHEME_IN            in;
        API_THEMES_GETGLOBALTHEME_OUT           out;
    } apiGetGlobalTheme;
    union
    {
        API_THEMES_CHECKTHEMESIGNATURE_IN       in;
        API_THEMES_CHECKTHEMESIGNATURE_OUT      out;
    } apiCheckThemeSignature;
    union
    {
        API_THEMES_LOADTHEME_IN                 in;
        API_THEMES_LOADTHEME_OUT                out;
    } apiLoadTheme;
    union
    {
        API_THEMES_USERLOGON_IN                 in;
        API_THEMES_USERLOGON_OUT                out;
    } apiUserLogon;
    union
    {
        API_THEMES_USERLOGOFF_IN                in;
        API_THEMES_USERLOGOFF_OUT               out;
    } apiUserLogoff;
    union
    {
        API_THEMES_SESSIONCREATE_IN             in;
        API_THEMES_SESSIONCREATE_OUT            out;
    } apiSessionCreate;
    union
    {
        API_THEMES_SESSIONDESTROY_IN            in;
        API_THEMES_SESSIONDESTROY_OUT           out;
    } apiSessionDestroy;
    union
    {
        API_THEMES_PING_IN                      in;
        API_THEMES_PING_OUT                     out;
    } apiPing;
} API_THEMES_SPECIFIC;

typedef struct
{
    API_GENERIC             apiGeneric;
    API_THEMES_SPECIFIC     apiSpecific;
} API_THEMES, *PAPI_THEMES;

typedef struct
{
    PORT_MESSAGE    portMessage;
    API_THEMES      apiThemes;
} THEMESAPI_PORT_MESSAGE, *PTHEMESAPI_PORT_MESSAGE;

EXTERN_C    DWORD   WINAPI  ThemeWaitForServiceReady (DWORD dwTimeout);
EXTERN_C    BOOL    WINAPI  ThemeWatchForStart (void);
EXTERN_C    BOOL    WINAPI  ThemeUserLogon (HANDLE hToken);
EXTERN_C    BOOL    WINAPI  ThemeUserLogoff (void);
EXTERN_C    BOOL    WINAPI  ThemeUserTSReconnect (void);
EXTERN_C    BOOL    WINAPI  ThemeUserStartShell (void);

typedef DWORD   (WINAPI * PFNTHEMEWAITFORSERVICEREADY) (DWORD dwTimeout);
typedef BOOL    (WINAPI * PFNTHEMEWATCHFORSTART) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERLOGON) (HANDLE hToken);
typedef HANDLE  (WINAPI * PFNTHEMEUSERLOGOFF) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERTSRECONNECT) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERSTARTSHELL) (void);

#define ORDINAL_THEMEWAITFORSERVICEREADY    1
#define ORDINAL_THEMEWATCHFORSTART          2
#define ORDINAL_THEMEUSERLOGON              3
#define ORDINAL_THEMEUSERLOGFF              4
#define ORDINAL_THEMEUSERTSRECONNECT        5
#define ORDINAL_THEMEUSERSTARTSHELL         6

#endif  /*  _LPCThemes_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\isguids.h ===
/*
 * isguids.h - Internet Shortcut GUID definitions.
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */


/* GUIDs
 ********/

#ifndef _ISGUIDS_H_
#define _ISGUIDS_H_

DEFINE_GUID(CLSID_InternetShortcut,       0xFBF23B40L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

DEFINE_GUID(IID_IUniformResourceLocatorA, 0xFBF23B80L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);
DEFINE_GUID(IID_IUniformResourceLocatorW, 0xCABB0DA0L, 0xDA57, 0x11CF, 0x99, 0x74, 0x00, 0x20, 0xAF, 0xD7, 0x97, 0x62);

#ifdef UNICODE
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorW
#else
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\ieguidp.h ===
#ifndef _IEGUIDP_H_
#define _IEGUIDP_H_

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif


//
// from shlguidp.h
//

#if (_WIN32_IE >= 0x0400)

// favorites band
// {EFA24E61-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_FavBand,              0xefa24e61, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// history band
// {EFA24E62-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_HistBand,              0xefa24e62, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// channels band
// {EFA24E63-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ChannelBand,          0xefa24e63, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// {A2B0DD40-CC59-11d0-A3A5-00C04FD706EC}
DEFINE_GUID( CLSID_IESplashScreen, 0xa2b0dd40, 0xcc59, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

#endif  // (_WIN32_IE >= 0x0400)



#if (_WIN32_IE >= 0x0400)

DEFINE_GUID(IID_IWinEventHandler,       0xEA5F2D61L, 0xE008, 0x11CF, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);

DEFINE_GUID(IID_IExplorerToolbar,       0x8455F0C1L, 0x158F, 0x11D0, 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define SID_SExplorerToolbar IID_IExplorerToolbar

// IQueryCodePage {C7B236CE-EE80-11D0-985F-006008059382}
DEFINE_GUID(IID_IQueryCodePage, 0xC7B236CEL, 0xEE80, 0x11D0, 0x98, 0x5F, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

DEFINE_GUID(CGID_AddressEditBox, 0x72730b70, 0xe8f7, 0x11d0, 0xbc, 0x44, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

/// AddressEditBox stuff
// {A08C11D1-A228-11d0-825B-00AA005B4383}
DEFINE_GUID(IID_IAddressEditBox, 0xa08c11d1, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
DEFINE_GUID(CLSID_AddressEditBox,0xa08c11d2, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {????} - For JITting in HTML Help Feature
DEFINE_GUID(CLSID_IEHelp, 0x45ea75a0L, 0xa269, 0x11d1, 0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15);

// {603D3800-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ShellTaskScheduler,        0x603d3800, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {6CCB7BE0-6807-11d0-B810-00C04FD706EC}
DEFINE_GUID(IID_IShellTaskScheduler,         0x6ccb7be0, 0x6807, 0x11d0, 0xb8, 0x10, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {04B3813B-0A23-11d2-B5AC-006097DF5BD4} - For JITting in FTP Shell Extension.
DEFINE_GUID(CLSID_FTPShellExtension, 0x4b3813b, 0xa23, 0x11d2, 0xb5, 0xac, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {CB81A3CB-1039-11d1-AB74-00C04FC30936}
DEFINE_GUID( IID_ISplashScreen, 0xcb81a3cb, 0x1039, 0x11d1, 0xab, 0x74, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);

// {6B707A1C-744F-11d2-86B9-00C04F8EEA99}
DEFINE_GUID(IID_IBrowserBand, 0x6b707a1c, 0x744f, 0x11d2, 0x86, 0xb9, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);

DEFINE_GUID(VID_WebView, 0x5984FFE0L, 0x28D4, 0x11CF, 0xAE, 0x66, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {BE098140-A513-11d0-A3A4-00C04FD706EC}

// {603D3801-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_SharedTaskScheduler,       0x603d3801, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

DEFINE_GUID(CLSID_ImageListCache,            0x3f4eef80, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

DEFINE_GUID(IID_IAddressBand,           0x106E86E1, 0x52B5, 0x11D0, 0xBF, 0xED, 0x0, 0xAA, 0x0, 0x5B, 0x43, 0x83);

// used by shell32 and ie components.
// same interface as IID_IExtractImage
// {D4029EC0-0920-11d1-9A0B-00C04FC2D6C1}
DEFINE_GUID(IID_IExtractLogo,                0xd4029ec0, 0x920, 0x11d1, 0x9a, 0xb, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {0D14E31C-D8C0-11d0-9816-00C04FD91972}
DEFINE_GUID(SID_SMenuBandHandler,           0xd14e31c, 0xd8c0, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {3F4EEF80-BFE8-11d0-A3A5-00C04FD706EC}
// {4FCE9180-BFE8-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IImageCache,                 0x4fce9180, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {8A4D3EDC-13A4-11d1-9A22-00C04FC2D6C1}
DEFINE_GUID(CLSID_ThumbnailScaler, 0x8a4d3edc, 0x13a4, 0x11d1, 0x9a, 0x22, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {45B324CE-B8A1-11d1-98D3-00C04FB687DA}
DEFINE_GUID(IID_IScaleAndSharpenImage2, 0x45b324ce, 0xb8a1, 0x11d1, 0x98, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

DEFINE_GUID(IID_IDeskBarClient,         0xEB0FE175L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);

DEFINE_GUID(IID_IMultiMonitorDockingSite, 0x03879DE0L, 0xA205, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1); 

// {D12F26B1-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(IID_IRestrict, 0xd12f26b1, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B2-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(SID_SRestrictionHandler, 0xd12f26b2, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B3-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(RID_RDeskBars, 0xd12f26b3, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {4622AD16-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(IID_IInitializeObject,0x4622ad16, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);



#endif  // (_WIN32_IE >= 0x0400)


#if _WIN32_IE >= 0x0500

DEFINE_GUID(IID_IPersistString, 0xD5E37E20L, 0x0257, 0x11CF, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {8210BAC0-C6D2-11cf-89AA-00A0C9054129}

// {AC3E9E59-96D7-11d1-98A4-00C04FB687DA}
DEFINE_GUID(IID_IImageCache2,                0xac3e9e59, 0x96d7, 0x11d1, 0x98, 0xa4, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

#endif  // _WIN32_IE >= 0x0500

#if (_WIN32_IE >= 0x0501)
// {58C73AE8-6AFE-4784-96FC-F97F65773B64}
DEFINE_GUID(IID_IShellTaskScheduler2,        0x58c73ae8, 0x6afe, 0x4784, 0x96, 0xfc, 0xf9, 0x7f, 0x65, 0x77, 0x3b, 0x64);

// {B61D9AB3-F120-4a5c-83A0-542923985BF7}
DEFINE_GUID(IID_IImageCache3,                0xb61d9ab3, 0xf120, 0x4a5c, 0x83, 0xa0, 0x54, 0x29, 0x23, 0x98, 0x5b, 0xf7);
#endif


#if _WIN32_IE >= 0x0600

#ifndef DEFINE_SHLGUID
#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#endif

// SID_SBrandBand: the spinning globe {82A62DE8-32AC-4e4a-9935-9046C378CF90}
DEFINE_GUID(SID_SBrandBand, 0x82a62de8, 0x32ac, 0x4e4a, 0x99, 0x35, 0x90, 0x46, 0xc3, 0x78, 0xcf, 0x90);

// Command group for the BrandBand {25019D8C-9EE0-45c0-883B-972D48325E18}
DEFINE_GUID(CGID_BrandCmdGroup, 0x25019d8c, 0x9ee0, 0x45c0, 0x88, 0x3b, 0x97, 0x2d, 0x48, 0x32, 0x5e, 0x18);

// Command IDs for the BrandBand's CGID_BrandCmdGroup (to be called in Exec)
#define CBRANDIDM_STARTGLOBEANIMATION   1
#define CBRANDIDM_STOPGLOBEANIMATION    2


// {31D44C2F-6C6A-45fc-B8C7-946BA8EDB8B4}
DEFINE_GUID(CGID_MediaBar, 0x31d44c2f, 0x6c6a, 0x45fc, 0xb8, 0xc7, 0x94, 0x6b, 0xa8, 0xed, 0xb8, 0xb4);

#endif // _WIN32_IE >= 0x0600


// Private Dochost Commands
//
DEFINE_SHLGUID(CGID_DocHostCmdPriv,         0x000214D4L, 0, 0);



//
//  from shguidp.h
//

// explorer band
// {EFA24E64-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ExplorerBand,         0xefa24e64, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

/// INSCTree
// {43A8F463-4222-11d2-B641-006097DF5BD4}
DEFINE_GUID(CLSID_NSCTree,              0x43a8f463, 0x4222, 0x11d2, 0xb6, 0x41, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {1FBA04EE-3024-11d2-8F1F-0000F87ABD16}
DEFINE_GUID(CLSID_ToolbarExtExec, 0x1fba04ee, 0x3024, 0x11d2, 0x8f, 0x1f, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {E0DD6CAB-2D10-11d2-8F1A-0000F87ABD16}
DEFINE_GUID(CLSID_ToolbarExtBand, 0xe0dd6cab, 0x2d10, 0x11d2, 0x8f, 0x1a, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {83799FE0-1F5A-11d1-95C7-00609797EA4F}
DEFINE_GUID(CLSID_DocFileInfoTip,   0x83799fe0, 0x1f5a, 0x11d1, 0x95, 0xc7, 0x0, 0x60, 0x97, 0x97, 0xea, 0x4f);

// {8E6E6079-0CB7-11d2-8F10-0000F87ABD16}
DEFINE_GUID(CLSID_OfflinePagesCacheCleaner, 0x8e6e6079, 0xcb7, 0x11d2, 0x8f, 0x10, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// Internet Cache Cleaner
// {9B0EFD60-F7B0-11D0-BAEF-00C04FC308C9}
DEFINE_GUID(CLSID_InternetCacheCleaner,     0x9b0efd60, 0xf7b0, 0x11d0, 0xba, 0xef, 0x0, 0xc0, 0x4f, 0xc3, 0x08, 0xc9);

// {67EA19A0-CCEF-11d0-8024-00C04FD75D13}
DEFINE_GUID(CLSID_CDFCopyHook, 0x67ea19a0, 0xccef, 0x11d0, 0x80, 0x24, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

//ffdc1a80-d527-11d0-a32c-34af06c10000
DEFINE_GUID (CLSID_WinListShellProc, 0xffdc1a80, 0xd527, 0x11d0, 0xa3, 0x2c, 0x34, 0xaf, 0x06, 0xc1, 0x00, 0x00);

DEFINE_GUID(CLSID_ChannelOC,            0x131A6951L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

DEFINE_GUID(CLSID_CStubBindStatusCallback, 
                                        0x2B4F54B1, 0x3D6D, 0x11d0, 0x82, 0x58, 0x00, 0xC0, 0x4F, 0xD5, 0xAE, 0x38);// 2B4F54B1-3D6D-11d0-8258-00C04FD5AE38

// History Shell Folder
DEFINE_GUID(CLSID_HistFolder,           0xFF393560L, 0xC2A7, 0x11CF, 0xBF, 0xF4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

// Cache Shell Folder UICLSID
DEFINE_GUID(CLSID_CacheFolder,          0x7BD29E00L, 0x76C1, 0x11CF, 0x9D, 0xD0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x33);
// Cache Shell Folder full implementation
DEFINE_GUID(CLSID_CacheFolder2,         0x7BD29E01L, 0x76C1, 0x11CF, 0x9D, 0xD0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x33);

DEFINE_GUID(CLSID_CDocObjectFolder,     0xE7E4BC40, 0xE76A, 0x11CE, 0xA9,0xBB,0x00,0xAA,0x00,0x4A,0xE8,0x37);//E7E4BC40-E76A-11CE-A9BB-00AA004AE837

// {BB90CD8B-4F08-11d0-B497-00C04FD90119}
DEFINE_GUID(IID_IShellHTMLWindowSupport,0xbb90cd8bL, 0x4f08, 0x11d0, 0xb4, 0x97, 0x00, 0xc0, 0x4f, 0xd9, 0x01, 0x19);

DEFINE_GUID(IID_IExpDispSupport,        0x0D7D1D00, 0x6FC0, 0x11D0, 0xA9, 0x74, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);//0D7D1D00-6FC0-11D0-A974-00C04FD705A2

DEFINE_GUID(IID_IDocNavigate,           0x131A6950L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

//***   SID_STopFrameBrowser -- like SID_STopLevelBrowser, but blocked by BrowserBand
// currently used to make BrowserBand get its own global history, but could
// be more generally useful than that, hence the more generic name.
// {A9227C3C-7F8E-11d0-8CB0-00A0C92DBFE8}
DEFINE_GUID(SID_STopFrameBrowser,       0xa9227c3c, 0x7f8e, 0x11d0, 0x8c, 0xb0, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// {C7A30296-907E-11d2-B02F-00C04FA35D89}
DEFINE_GUID(IID_IUrlHistoryPriv,        0xc7a30296, 0x907e, 0x11d2, 0xb0, 0x2f, 0x0, 0xc0, 0x4f, 0xa3, 0x5d, 0x89);

// 20C46561-8491-11CF-960C-0080C7F4EE85 
// this is who should navigate instead
DEFINE_GUID(SID_SProxyBrowser,          0x20C46561L, 0x8491, 0x11CF, 0x96, 0x0C, 0x00, 0x80, 0xC7, 0xF4, 0xEE, 0x85);

//1E79697E-9CC5-11D1-A83F-00C04FC99D61
DEFINE_GUID(CLSID_CommonButtons, 0x1E79697EL, 0x9CC5, 0x11D1, 0xA8, 0x3F, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

DEFINE_GUID(SID_PendingBindStatusCallback, 0xfe390c68, 0xe2bc, 0x11d0, 0x88, 0x8c, 0x0, 0xc0, 0x4f, 0xc2, 0xc8, 0x36);

// {32bb8320-b41b-11cf-a6bb-0080c7b2d682}
DEFINE_GUID(IID_IBrowserExtension, 0x32bb8320, 0xb41b, 0x11cf, 0xa6, 0xbb, 0x0, 0x80, 0xc7, 0xb2, 0xd6, 0x82);

DEFINE_GUID(SID_ITopViewHost,           0xd1e7afec, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

DEFINE_GUID(IID_IEFrameAuto,            0x131A6953L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

DEFINE_GUID(IID_IExpDispSupportOC,      0x0D7D1D01, 0x6FC0, 0x11D0, 0xA9, 0x74, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);//0D7D1D01-6FC0-11D0-A974-00C04FD705A2

// {48123bc4-99d9-11d1-a6b3-00c04fd91555}
DEFINE_GUID(CLSID_XMLViewerDocObj, 0x48123bc4, 0x99d9, 0x11d1, 0xa6, 0xb3, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x55);

DEFINE_GUID(IID_IOrderList,             0x8bfcb27d, 0xcf1a, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
DEFINE_GUID(CLSID_OrderListExport,      0xf3368374, 0xcf19, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

// Interface used to keep channel cache in sync.
DEFINE_GUID(IID_IChannelMgrPriv, 0xc9ace0f0, 0xac1, 0x11d1, 0x8f, 0x45, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x3f);
DEFINE_GUID(IID_IChannelMgrPriv2, 0xc9ace0f1, 0xac1, 0x11d1, 0x8f, 0x45, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x3f);

// {1ABCFC13-2340-11d2-B601-006097DF5BD4}
DEFINE_GUID(CLSID_FtpInstaller, 0x1abcfc13, 0x2340, 0x11d2, 0xb6, 0x1, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
DEFINE_GUID(IID_IFtpInstaller, 0x1abcfc13, 0x2340, 0x11d2, 0xb6, 0x1, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// this is used in shdocvw's CConnectionPoint implementation
// to let CShellOcx type OCs get advised of Advise/Unadvise
// calls to the connection point. CShellFolderViewOC uses it.
//
DEFINE_GUID(IID_IConnectionPointCB,     0xAAAC9640L, 0x1252, 0x11D0, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);

// {4ec5337e-4554-4705-81fd-06a3e1b0430a}
DEFINE_GUID(IID_IShellHTMLWindowSupport2,0x4ec5337e, 0x4554, 0x4705, 0x81, 0xfd, 0x06, 0xa3, 0xe1, 0xb0, 0x43, 0x0a);

// {DD313E04-FEFF-11d1-8ECD-0000F87A470C}
DEFINE_GUID(CLSID_UserAssist, 0xdd313e04, 0xfeff, 0x11d1, 0x8e, 0xcd, 0x0, 0x0, 0xf8, 0x7a, 0x47, 0xc);

// {DD313E05-FEFF-11d1-8ECD-0000F87A470C}
DEFINE_GUID(IID_IUserAssist, 0xdd313e05, 0xfeff, 0x11d1, 0x8e, 0xcd, 0x0, 0x0, 0xf8, 0x7a, 0x47, 0xc);

// navigate band UI from pidl
DEFINE_GUID(IID_IBandNavigate,          0x3697c30b, 0xcd88, 0x11d0, 0x8a, 0x3e, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// {3050f803-98b5-11cf-bb82-00aa00bdce0b} SID_QIClientSite
DEFINE_GUID(SID_QIClientSite, 0x3050f803, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {996E1EB1-B524-11d1-9120-00A0C98BA67D}
DEFINE_GUID(SRCID_SFindComputer,   0x996e1eb1, 0xb524, 0x11d1, 0x91, 0x20, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// {D515F311-B78B-11d1-9123-00A0C98BA67D}
DEFINE_GUID(SRCID_SFindPrinter,    0xd515f311, 0xb78b, 0x11d1, 0x91, 0x23, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// {169A0691-8DF9-11d1-A1C4-00C04FD75D13}
DEFINE_GUID(CLSID_ShellSearchExt,       0x169a0691, 0x8df9, 0x11d1, 0xa1, 0xc4, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {23d9b0f1-40fc-11d2-bf8c-00c04fb93661}
DEFINE_GUID(IID_IFolderSearches, 0x23d9b0f1, 0x40fc, 0x11d2, 0xbf, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x36, 0x61);

// 830abff0-afd9-11d1-b9f1-00a0c98bc547
DEFINE_GUID(IID_ISearchItems,      0x830abff0L, 0xafd9, 0x11d1, 0xb9, 0xf1, 0x00, 0xa0, 0xc9, 0x8b, 0xc5, 0x47);

// New MSIE FTP UI from msieftp.dll
DEFINE_GUID(CLSID_FtpFolder,            0x63da6ec0, 0x2e98, 0x11cf, 0x8d,0x82,0x44,0x45,0x53,0x54,0,0);

//A48F1A32-A340-11D1-BC6B-00A0C90312E1
DEFINE_GUID(GUID_Restrictions, 0xA48F1A32L, 0xA340, 0x11D1, 0xBC, 0x6B, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

DEFINE_GUID (IID_IHist,                 0x06faeb04L, 0x191c, 0x11d3, 0x95, 0x73, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
DEFINE_GUID (IID_ICache,                0x06faeb05L, 0x191c, 0x11d3, 0x95, 0x73, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

// {B1E437E0-047A-11D1-B833-00C04FC9B31F}
DEFINE_GUID(IID_IDwnCodePage, 0xb1e437e0, 0x047a, 0x11d1, 0xb8, 0x33, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f);

// {AFD971E0-C870-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IPrivateOleObject, 0xafd971e0, 0xc870, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {a28a872c-1bce-11d4-a114-00c04f8ef9b9}
DEFINE_GUID(IID_ISearchBandTBHelper, 0xa28a872c, 0x1bce, 0x11d4, 0xa1, 0x14, 0x0, 0xc0, 0x4f, 0x8e, 0xf9, 0xb9);

// used when communicating with the Internet Toolbar. 
DEFINE_GUID(CGID_ShellBrowser, 0x3531F060L, 0x22B3, 0x11D0, 0x96, 0x9E, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 );

/// IAddressList
// {D7E67AA1-AA76-11d0-8282-00AA005B4383}
DEFINE_GUID(IID_IAddressList,           0xd7e67aa1, 0xaa76, 0x11d0, 0x82, 0x82, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

/// IBandProxy
// {208CE801-754B-11d0-80CA-00AA005B4383}
DEFINE_GUID(IID_IBandProxy,             0x208ce801, 0x754b, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {1011fa30-69da-11d2-8599-006097df8c11}
DEFINE_GUID(IID_IMRU,                   0x1011fa30, 0x69da, 0x11d2, 0x85, 0x99, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

//0F12079C-C193-11D0-8D49-00C04FC99D61
DEFINE_GUID(CGID_Theater, 0x0F12079CL, 0xC193, 0x11D0, 0x8D, 0x49, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// {9581015C-D08E-11d0-8D36-00A0C92DBFE8}
DEFINE_GUID(CLSID_BrowserBar,           0x9581015c, 0xd08e, 0x11d0, 0x8d, 0x36, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// {2D3DDFC0-09E1-11d1-BC59-00AA006CE2F5}
DEFINE_GUID(CGID_MenuBandHandler, 0x2d3ddfc0, 0x9e1, 0x11d1, 0xbc, 0x59, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

// this defines the deskbar and also id's for each of the toolbands that we implement
//ECD4FC4C-521C-11D0-B792-00A0C90312E1
DEFINE_GUID(CLSID_DeskBar,              0xECD4FC4CL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_RebarBandSite,        0xECD4FC4DL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_BandSiteMenu,         0xECD4FC4EL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_MenuDeskBar,          0xECD4FC4FL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// {8C7461EF-2B13-11d2-BE35-3078302C2030}
DEFINE_GUID(CLSID_ComCatCacheTask,  0x8c7461ef, 0x2b13, 0x11d2, 0xbe, 0x35, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {3CCF8A41-5C85-11d0-9796-00AA00B90ADF}
DEFINE_GUID(CLSID_DeskBarApp,           0x3ccf8a41, 0x5c85, 0x11d0, 0x97, 0x96, 0x0, 0xaa, 0x0, 0xb9, 0xa, 0xdf);

// 4AF4A5FA-912A-11D1-B945-00A0C90312E1
DEFINE_GUID(IID_IDockingBarPropertyBagInit, 0x4AF4A5FAL, 0x912A, 0x11D1, 0xB9, 0x45, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// ef8ad2d3-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(IID_IGlobalFolderSettings, 0xef8ad2d3L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// {37e856d7-3dfd-11d2-bf8b-00c04fb93661}
DEFINE_GUID(IID_IEnumUrlSearch,   0x37e856d7, 0x3dfd, 0x11d2, 0xbf, 0x8b, 0x0, 0xc0, 0x4f, 0xb9, 0x36, 0x61);

DEFINE_GUID(SID_IBandProxy,             0x80243ac1, 0x569, 0x11d1, 0xa7, 0xae, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {AF4F6511-F982-11d0-8595-00AA004CD6D8}
DEFINE_GUID(IID_IRegTreeOptions, 0xaf4f6511, 0xf982, 0x11d0, 0x85, 0x95, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0xd8);

// {07798131-AF23-11d1-9111-00A0C98BA67D}
DEFINE_GUID(CLSID_WebSearchExt,         0x7798131, 0xaf23, 0x11d1, 0x91, 0x11, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// NOTE!  Different from the IID_ITranslateShellChangeNotify in IE4x and IE5.0
// {B4DF2675-BA23-11d2-B5EE-006097C686F6}
DEFINE_GUID(IID_ITranslateShellChangeNotify, 0xb4df2675, 0xba23, 0x11d2, 0xb5, 0xee, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

//Pidl Filtering for Menu Bands.
// {B16C55D1-0534-11d1-8D3F-00A0C90F2719}
DEFINE_GUID(CGID_FilterObject,0xb16c55d1, 0x534, 0x11d1, 0x8d, 0x3f, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {B16C55D3-0534-11d1-8D3F-00A0C90F2719}
DEFINE_GUID(SID_SHostProxyFilter,0xb16c55d3, 0x534, 0x11d1, 0x8d, 0x3f, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// Also used by SHCreateGlobalCounter to count changes to global folder settings
#define GUID_FolderSettingsChange       CLSID_ShellFldSetExt

// {7376D660-C583-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ImgCtxThumbnailExtractor, 0x7376d660, 0xc583, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// 438755C2-A8BA-11D1-B96B-00A0C90312E1
DEFINE_GUID(CLSID_BrowseuiPreloader, 0x438755C2L, 0xA8BA, 0x11D1, 0xB9, 0x6B, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// ef8ad2d1-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(CLSID_GlobalFolderSettings, 0xef8ad2d1L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// {D1E7AFEA-6A2E-11d0-8C78-00C04FD918B4}
DEFINE_GUID(IID_IBandSiteHelper,        0xd1e7afea, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

//AF604EFE-8897-11D1-B944-00A0C90312E1
DEFINE_GUID(CLSID_CCommonBrowser, 0xAF604EFEL, 0x8897, 0x11D1, 0xB9, 0x44, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// Currently not used -- will be used when dbapp moves to shell32
// 4AF4A5FC-912A-11D1-B945-00A0C90312E1
DEFINE_GUID(CLSID_CDockingBarPropertyBag, 0x4AF4A5FCL, 0x912A, 0x11D1, 0xB9, 0x45, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// {AF4F6510-F982-11d0-8595-00AA004CD6D8}
DEFINE_GUID(CLSID_CRegTreeOptions, 0xaf4f6510, 0xf982, 0x11d0, 0x85, 0x95, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0xd8);

// {E56829C9-2D59-11d2-BE38-3078302C2030}
DEFINE_GUID(CLSID_ComCatConditionalCacheTask, 0xe56829c9, 0x2d59, 0x11d2, 0xbe, 0x38, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// URL Shell Execute Hook for IE4
// {AEB6717E-7E19-11d0-97EE-00C04FD91972}
DEFINE_GUID(CLSID_URLExecHook,          0xaeb6717e, 0x7e19, 0x11d0, 0x97, 0xee, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);



//
// From shdguid.h
//

// 3DC7A020-0ACD-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CURLFolder,       0x3DC7A020L, 0x0ACD, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

//A5E46E3A-8849-11D1-9D8C-00C04FC99D61
DEFINE_GUID(CLSID_CBaseBrowser, 0xA5E46E3AL, 0x8849, 0x11D1, 0x9D, 0x8C, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// IID_IShellService is used in shdocvw and shell32.  Put it here so shdocvw builds.
DEFINE_GUID(IID_IShellService, 0x5836FB00L, 0x8187, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// f62d9369-75ef-4578-8856-232802c76468
DEFINE_GUID(IID_ITridentService2, 0xf62d9369, 0x75ef, 0x4578, 0x88, 0x56, 0x23, 0x28, 0x02, 0xc7, 0x64, 0x68);

// 3050f801-98b5-11cf-bb82-00aa00bdce0b
DEFINE_GUID(IID_ITridentService, 0x3050f801, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DEFINE_GUID(IID_IBrowserService, 0x02ba3b52, 0x0547, 0x11d1, 0xb8, 0x33, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f);

// (old: E4A141D2-70C7-11D1-8DD7-00C04FC99D61 until 980512)
// (old: C3F16B61-E91A-11d1-BCD9-00A0C92DBFE8 until 980903)
// {68BD21CC-438B-11d2-A560-00A0C92DBFE8}
DEFINE_GUID(IID_IBrowserService2, 0x68bd21cc, 0x438b, 0x11d2, 0xa5, 0x60, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
DEFINE_GUID(IID_IBrowserService3, 0x27D7CE21L, 0x762D, 0x48F3, 0x86, 0xF3, 0x40, 0xE2, 0xFD, 0x37, 0x49, 0xC4);

// C2EA74E0-0ED2-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CDocObjectView,   0xC2EA74E0L, 0x0ED2, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// 3050f804-98b5-11cf-bb82-00aa00bdce0b
DEFINE_GUID(IID_IWebBrowserPriv,  0x3050f804, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);

// Remove this after Beta 2.
DEFINE_GUID(CLSID_QuickLinksOld, 0x7BA4C741L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// 01E04581-4EEE-11d0-BFE9-00AA005B4383
DEFINE_GUID(CLSID_AddressBand, 0x1e04581, 0x4eee, 0x11d0, 0xbf, 0xe9, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {30D02401-6A81-11d0-8274-00C04FD5AE38}
DEFINE_GUID(CLSID_SearchBand, 0x30d02401, 0x6a81, 0x11d0, 0x82, 0x74, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);
#define CGID_SearchBand CLSID_SearchBand

// {32683183-48a0-441b-a342-7c2a440a9478}
DEFINE_GUID(CLSID_MediaBand, 0x32683183, 0x48a0, 0x441b, 0xa3, 0x42, 0x7c, 0x2a, 0x44, 0x0a, 0x94, 0x78);

// {B6E3D794-F864-42a4-8F7B-1779A4DEAC83}
DEFINE_GUID(SID_SMediaBar, 0xb6e3d794, 0xf864, 0x42a4, 0x8f, 0x7b, 0x17, 0x79, 0xa4, 0xde, 0xac, 0x83);

// 5E6AB780-7743-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_InternetToolbar, 0x5E6AB780L, 0x7743, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

/// {AFA7AD8A-51A7-11d2-83A1-00C04FD918D0}
DEFINE_GUID(IID_IOrderList2,    0xafa7ad8a, 0x51a7, 0x11d2, 0x83, 0xa1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {F98D8294-2BBC-11d2-8DBD-0000F87A556C}
DEFINE_GUID(IID_IShellFolderSearchableCallback, 0xf98d8294, 0x2bbc, 0x11d2, 0x8d, 0xbd, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {4E1AE66C-204B-11d2-8DB3-0000F87A556C}
DEFINE_GUID(IID_IShellFolderSearchable, 0x4e1ae66c, 0x204b, 0x11d2, 0x8d, 0xb3, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {49422C1E-1C03-11d2-8DAB-0000F87A556C}
DEFINE_GUID(IID_IShellFolderViewType, 0x49422c1e, 0x1c03, 0x11d2, 0x8d, 0xab, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {94FD6891-92CD-11d1-A1C6-00C04FD75D13}
DEFINE_GUID(SRCID_SWebSearch,      0x94fd6891, 0x92cd, 0x11d1, 0xa1, 0xc6, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

#define SRCID_SFileSearch          CLSID_ShellSearchExt

// {B8A9C381-19DF-11d1-9193-006097DF5BD4}
DEFINE_GUID(IID_IIsWebBrowserSB, 0xb8a9c381, 0x19df, 0x11d1, 0x91, 0x93, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// 062E1261-A60E-11d0-82C2-00C04FD5AE38
DEFINE_GUID(IID_IHistSFPrivate, 0x62e1261, 0xa60e, 0x11d0, 0x82, 0xc2, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);

// 22BF0C20-6DA7-11D0-B373-00A0C9034938
DEFINE_GUID(CLSID_BrandBand, 0x22BF0C20, 0x6DA7, 0x11D0, 0xB3, 0x73, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x38);

DEFINE_GUID(CLSID_BrowserBand, 0x7BA4C742L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// {4D5C8C2A-D075-11d0-B416-00C04FB90376}
DEFINE_GUID(CLSID_CommBand, 0x4d5c8c2a, 0xd075, 0x11d0, 0xb4, 0x16, 0x0, 0xc0, 0x4f, 0xb9, 0x3, 0x76);

// {35C042C1-75BE-11d0-80D2-00AA005B4383}
DEFINE_GUID(CLSID_MRUList, 0x35c042c1, 0x75be, 0x11d0, 0x80, 0xd2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {91EA3F8C-C99B-11d0-9815-00C04FD91972}
DEFINE_GUID(IID_IAugmentedShellFolder,      0x91ea3f8c, 0xc99b, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
// {8DB3B3F4-6CFE-11d1-8AE9-00C04FD918D0}
DEFINE_GUID(IID_IAugmentedShellFolder2,     0x8db3b3f4, 0x6cfe, 0x11d1, 0x8a, 0xe9, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {F61FFEC1-754F-11d0-80CA-00AA005B4383}
DEFINE_GUID(CLSID_BandProxy, 0xf61ffec1, 0x754f, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {91EA3F8B-C99B-11d0-9815-00C04FD91972}
DEFINE_GUID(CLSID_AugmentedShellFolder,     0x91ea3f8b, 0xc99b, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {6413BA2C-B461-11d1-A18A-080036B11A03}
DEFINE_GUID(CLSID_AugmentedShellFolder2,    0x6413ba2c, 0xb461, 0x11d1, 0xa1, 0x8a, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3);





#endif // _IEGUIDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\lpcfus.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCFUS.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are specific to
//  the bad application API.
//
//  History:    2000-08-26  vtan        created
//              2000-10-12  vtan        moved from DS to SHELL depot
//  --------------------------------------------------------------------------

#ifndef     _LPCFUS_
#define     _LPCFUS_

#include <LPCGeneric.h>

static  const TCHAR     FUS_PORT_NAME[]             =   L"\\FusApiPort";
static  const TCHAR     FUS_CONNECTION_REQUEST[]    =   L"FusApiConnectionRequest";

enum
{
    API_BAM_QUERYRUNNING            =   1,
    API_BAM_REGISTERRUNNING,
    API_BAM_QUERYUSERPERMISSION,
    API_BAM_TERMINATERUNNING,

    API_BAM_REQUESTSWITCHUSER       =   1001,
};

typedef enum
{
    BAM_TYPE_MINIMUM                            =   0,
    BAM_TYPE_UNKNOWN                            =   BAM_TYPE_MINIMUM,
    BAM_TYPE_SECOND_INSTANCE_START,
    BAM_TYPE_SWITCH_USER,
    BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE,
    BAM_TYPE_SWITCH_TO_NEW_USER,
    BAM_TYPE_MAXIMUM
} BAM_TYPE;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
} API_BAM_QUERYRUNNING_IN;

typedef struct
{
    bool            fResult;
} API_BAM_QUERYRUNNING_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
    DWORD           dwProcessID;
    BAM_TYPE        bamType;
} API_BAM_REGISTERRUNNING_IN;

typedef struct
{
} API_BAM_REGISTERRUNNING_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
    WCHAR           *pszUser;
    int             cchUser;
} API_BAM_QUERYUSERPERMISSION_IN;

typedef struct
{
    bool            fCanShutdownApplication;
} API_BAM_QUERYUSERPERMISSION_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
} API_BAM_TERMINATERUNNING_IN;

typedef struct
{
    bool            fResult;
} API_BAM_TERMINATERUNNING_OUT;

typedef struct
{
} API_BAM_REQUESTSWITCHUSER_IN;

typedef struct
{
    bool            fAllowSwitch;
} API_BAM_REQUESTSWITCHUSER_OUT;

typedef union
{
    union
    {
        API_BAM_QUERYRUNNING_IN             in;
        API_BAM_QUERYRUNNING_OUT            out;
    } apiQueryRunning;
    union
    {
        API_BAM_REGISTERRUNNING_IN          in;
        API_BAM_REGISTERRUNNING_OUT         out;
    } apiRegisterRunning;
    union
    {
        API_BAM_QUERYUSERPERMISSION_IN      in;
        API_BAM_QUERYUSERPERMISSION_OUT     out;
    } apiQueryUserPermission;
    union
    {
        API_BAM_TERMINATERUNNING_IN         in;
        API_BAM_TERMINATERUNNING_OUT        out;
    } apiTerminateRunning;
    union
    {
        API_BAM_REQUESTSWITCHUSER_IN        in;
        API_BAM_REQUESTSWITCHUSER_OUT       out;
    } apiRequestSwitchUser;
} API_BAM_SPECIFIC;

typedef struct
{
    API_GENERIC         apiGeneric;
    API_BAM_SPECIFIC    apiSpecific;
} API_BAM, *PAPI_BAM;

typedef struct
{
    PORT_MESSAGE    portMessage;
    API_BAM         apiBAM;
} FUSAPI_PORT_MESSAGE, *PFUSAPI_PORT_MESSAGE;

#endif  /*  _LPCFUS_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\inetcpl.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*         Copyright(c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _INETCPLP_H_
#define _INETCPLP_H_

// property sheet page IDs
#define INET_PAGE_GENERAL       0x00000001
#define INET_PAGE_CONNECTION    0x00000002
#define INET_PAGE_PLACES        0x00000004      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_PROGRAMS      0x00000008
#define INET_PAGE_SECURITY_OLD  0x00000010      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_ADVANCED      0x00000020
#define INET_PAGE_PRINT         0x00000040      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_CONTENT       0x00000080
#define INET_PAGE_SECURITY      0x00000100
#define INET_PAGE_ASSOC         0x00000200      // UNIX Assocations
#define INET_PAGE_ALIAS         0x00000400      // UNIX Aliases
#define INET_PAGE_PRIVACY       0x00000800


//  restrict flags
#define R_MULTIMEDIA    0x00000001              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_COLORS        0x00000002              // colors section of the Colors Dialog
#define R_LINKS         0x00000004              // links section of the Colors Dialog
#define R_TOOLBARS      0x00000008              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_FONTS         0x00000010              // Fonts Dialog
#define R_DIALING       0x00000020              // Connection section of Connection tab (incl Settings subdialog)
#define R_PROXYSERVER   0x00000040              // Proxy server section of Connection tab (incl Advanced subdialog)
#define R_CUSTOMIZE     0x00000080              // Homepage section of General tab
#define R_HISTORY       0x00000100              // History section of General tab
#define R_MAILANDNEWS   0x00000200              // Messaging section of Programs tab
#define R_VIEWERS       0x00000400              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_RATINGS       0x00000800              // Ratings section of Content tab
#define R_CERTIFICATES  0x00001000              // Certificates section of Content tab
#define R_ACTIVECONTENT 0x00002000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_WARNINGS      0x00004000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_CACHE         0x00008000              // Temporary Internet Files section of General Tab (incl Settings subdialog)
#define R_CRYPTOGRAPHY  0x00010000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_PLACESDEFAULT 0x00020000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_OTHER         0x00040000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_CHECKBROWSER  0x00080000              // "IE should check if default browser" checkbox on Programs tab
#define R_LANGUAGES     0x00100000              // Languages Dialog off of the General tab
#define R_ACCESSIBILITY 0x00200000              // Accessibility Dialog off of the General tab
#define R_SECURITY_HKLM_ONLY 0x00400000         // Security tab settings (everything is read only)
#define R_SECURITY_CHANGE_SETTINGS 0x00800000   // Security tab settings (can't change security level for a zone)
#define R_SECURITY_CHANGE_SITES 0x01000000      // Security tab settings (disable everything on Add sites)
#define R_PROFILES      0x02000000              // Profile Asst. section of Content tab
#define R_WALLET        0x04000000              // MS Wallet section of Content tab
#define R_CONNECTION_WIZARD 0x08000000          // Connection wizard button on Connection tab
#define R_AUTOCONFIG    0x10000000              // Auto config section of Programs tab
#define R_ADVANCED      0x20000000              // Entire Advanced tab (including "Restore Defaults")
#define R_CAL_CONTACT   0x40000000              // Personal Info section of Programs tab

#define STR_INETCPL TEXT("inetcpl.cpl") // LoadLibrary() with this string

// structure to pass info to the control panel
typedef struct {
    UINT cbSize;                    // size of the structure
    DWORD dwFlags;                  // enabled page flags (remove pages)
    LPSTR pszCurrentURL;            // the current URL (NULL=none)
    DWORD dwRestrictMask;           // disable sections of the control panel
    DWORD dwRestrictFlags;          // masking for the above
} IEPROPPAGEINFO, *LPIEPROPPAGEINFO;

// GetProcAddress() with this string
#define STR_ADDINTERNETPROPSHEETS "AddInternetPropertySheets"

typedef HRESULT (STDMETHODCALLTYPE * PFNADDINTERNETPROPERTYSHEETS)(
    LPFNADDPROPSHEETPAGE pfnAddPage,   // add PS callback function
    LPARAM lparam,                     // pointer to prop. sheet header
    PUINT pucRefCount,                 // reference counter (NULL if not used)
    LPFNPSPCALLBACK pfnCallback        // PS-to-be-added's callback function (NULL if not used);
);


// GetProcAddress() with this string
#define STR_ADDINTERNETPROPSHEETSEX "AddInternetPropertySheetsEx"

typedef HRESULT (STDMETHODCALLTYPE * PFNADDINTERNETPROPERTYSHEETSEX)(
    LPFNADDPROPSHEETPAGE pfnAddPage, // add PS callback function
    LPARAM lparam,                   // pointer to prop. sheet header
    PUINT pucRefCount,               // reference counter (NULL if not used)
    LPFNPSPCALLBACK pfnCallback,     // PS-to-be-added's callback function (NULL if not used)
    LPIEPROPPAGEINFO piepi           // structure to pass info to control panel
);

STDAPI_(INT_PTR) OpenFontsDialog(HWND hDlg, LPCSTR lpszKeyPath);
STDAPI_(BOOL) LaunchSecurityDialogEx(HWND hDlg, DWORD dwZone, DWORD dwFlags);

#define STR_LAUNCHSECURITYDIALOGEX TEXT("LaunchSecurityDialogEx")

// Flags understood by LaunchSecurityDialog
typedef enum {
    LSDFLAG_DEFAULT    = 0x00000000,
    LSDFLAG_NOADDSITES = 0x00000001,
    LSDFLAG_FORCEUI    = 0x00000002
} LSDFLAG;

typedef BOOL (STDMETHODCALLTYPE * PFNLAUNCHSECURITYDIALOGEX)(
    HWND        hDlg,    // Parent Window
    DWORD       dwZone,  // Initial Zone to display, as defined in urlmon
    DWORD       dwFlags // Initialization flags: or'd combination of LSD_FLAGS
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\lpcgeneric.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCGeneric.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are generic to
//  any API.
//
//  History:    1999-11-17  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-10-12  vtan        moved from DS to SHELL depot
//  --------------------------------------------------------------------------

#ifndef     _LPCGeneric_
#define     _LPCGeneric_

enum
{
    API_GENERIC_STOPSERVER              =   0x00010000,
    API_GENERIC_EXECUTE_IMMEDIATELY     =   0x80000000,

    API_GENERIC_SPECIAL_MASK            =   0x00FF0000,
    API_GENERIC_OPTIONS_MASK            =   0xFF000000,
    API_GENERIC_RESERVED_MASK           =   0xFFFF0000,
    API_GENERIC_NUMBER_MASK             =   0x0000FFFF
};

typedef union
{
    unsigned long   ulAPINumber;        //   IN: API number request to server
    NTSTATUS        status;             //  OUT: NTSTATUS error code returned from server
} API_GENERIC;

#endif  /*  _LPCGeneric_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\msluguid.h ===
//*********************************************************************
//*                  Microsoft Internet Explorer                     **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _MSLUGUID_H_
#define _MSLUGUID_H_

// 95D0F020-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(CLSID_LocalUsers, 0x95D0F020L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F023-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUser,0x95D0F023L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F022-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUserDatabase,0x95D0F023L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F024-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUserProfileInit,0x95D0F024L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

#ifdef USER_SETTINGS_IMPLEMENTED
// EA7364C0-0730-11D0-83B1-00C04FD705B2
DEFINE_GUID(IID_IUserSettings,0xEA7364C0L, 0x0730, 0x11D0, 0x83, 0xB1, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xB2);
#endif

#endif  // _MSLUGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\msluapi.h ===
//*********************************************************************
//*                  Microsoft Internet Explorer                     **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _MSLUAPI_H_
#define _MSLUAPI_H_

#ifdef USER_SETTINGS_IMPLEMENTED

/************************************************************************

IUserSettings interface

This interface is used to manipulate the settings for a particular component,
corresponding to a local user account.  An IUserSettings interface may be
obtained by CLSID or name, or through enumeration;  in both cases, this is
relative to a particular user.

Member functions, other than IUnknown:

GetCLSID(CLSID *pclsidOut)
	Returns the CLSID identifying the component.  May be GUID_NULL if no
	CLSID is defined for the component.

GetName(LPSTR pbBuffer, UINT cbBuffer)
	Returns a unique name identifying the component.  This may be used
	instead of a CLSID if the component provider does not wish to provide
	a COM server to help administer the settings.

GetDisplayName(LPSTR pbBuffer, UINT cbBuffer)
	Returns a user-friendly name for the component, suitable for presentation
	to the user.

QueryKey(HKEY *phkeyOut)
	Returns a registry key where the component stores settings for the
	specified user.  The key is owned by the interface and must not be
	closed by the application using RegCloseKey, otherwise changes will
	not be propagated correctly.

((((
OpenKey(HKEY *phkeyOut, DWORD fdwAccess)
	Returns a registry key where the component stores settings for the
	specified user.  The key MUST be closed using IUserSettings::CloseKey
	so that changes will be propagated correctly.  fdwAccess indicates
	the type of access desired;  valid values include GENERIC_READ and
	GENERIC_WRITE.

CloseKey(HKEY hKey)
	Closes a registry key obtained via IUserSettings::OpenKey.

Lock(BOOL fLock)
	Locks or unlocks the settings for updates.  Attempting to lock the
	settings will fail if they are already locked.  Locking the settings
	does not, however, affect any of the other member functions
))))
************************************************************************/

DECLARE_INTERFACE_(IUserSettings, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetCLSID) (THIS_ CLSID *pclsidOut) PURE;
	STDMETHOD(GetName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;
	STDMETHOD(GetDisplayName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;

	STDMETHOD(QueryKey) (THIS_ HKEY *phkeyOut) PURE;
};
#endif  /* USER_SETTINGS_IMPLEMENTED */


/************************************************************************

IUser interface

This interface is used to manipulate a local user account.  It allows
various operations to be performed on a particular user.  To obtain one
of these interfaces, the companion interface IUserDatabase must be
used -- its AddUser, GetUser, and GetCurrentUser member functions all
return IUser objects, as does IEnumUsers::Next.

In all descriptions here, "the user" refers to the user which this
ILocalUser object describes.  "The current user" means the user who
is currently logged on at the workstation.

If the current user is a supervisor, all functions are allowed.  Otherwise,
a more limited set of member functions is available if the IUser object
corresponds to the current user.  If the current user is not a supervisor
and the IUser object refers to a different user, a still more limited set
of functions is allowed.

Member functions, other than IUnknown:

GetName(LPSTR pbBuffer, UINT cbBuffer)
	Returns the user's logon name.

GetProfileDirectory(LPSTR pbBuffer, UINT cbBuffer)
	Returns the user's local profile directory (e.g., C:\WINDOWS\PROFILES\gregj).
	May fail if the user is the default user (doesn't really have a profile
	directory as such).

IsSupervisor()
	Returns whether the user is a supervisor or not.  This is not a generic
	property because it's actually based on the presence of security info
	in the user's PWL (at least on win95).

SetSupervisorPrivilege(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
	Grants or revokes supervisor privilege for the user.  Only supervisors
	can grant or revoke that privilege, of course.  If pszSupervisorPassword
    is not NULL, it is used to determine whether the current user is a
    supervisor.  If it is NULL, then the current user's password cache is
    used instead.  This allows making any user into a supervisor without
    the current user being one.

MakeTempSupervisor(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
    Grants or revokes supervisor privilege for the user, but only for the
    lifetime of this IUser object.  As soon as the object is destroyed,
    the user is no longer considered a supervisor, and in fact other IUser
    objects currently in existence which refer to the same user will not
    indicate him as a supervisor.

    Note that MakeTempSupervisor(FALSE) only revokes temporary-supervisor
    privilege granted by MakeTempSupervisor(TRUE).  If the user still has
    the supervisor password in his PWL, he will still be considered a
    supervisor.

AppearsSupervisor()
	Returns whether or not the user should appear as a supervisor in a list
	of users.  This allows querying this property on each user for display
	purposes without taking the large performance hit to locate each user's
	PWL, open it up, get the supervisor key out, and validate it.  Instead,
	a registry value under the user's key is used to maintain this value.
	It should NOT be used to determine whether the user has permission to
	do something, because the simple registry value is not as secure.

Authenticate(LPCSTR pszPassword)
	Attempts to authenticate the user using the given password.  Returns
	S_OK if the password is correct for the user, or an error otherwise.
	No user interface is displayed by this function.

ChangePassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
	Attempts to change the user's password from the given old password
	to the given new password.  Returns an error code indicating success
	or failure.  If the current user is a supervisor, the old password
	may be NULL, in which case the supervisor's credentials are used to
	get the password via other means.

GetPasswordCache(LPCSTR pszPassword, LPHPWL phOut)
	Returns a handle to the user's password cache, suitable for use with
	the MSPWL32.DLL APIs.  May fail, of course, if password caching is
	disabled.

LoadProfile(LPHKEY phkeyUser)
    Loads the user's profile into the registry and returns a handle to the
    root key.  The current user can always load his own profile (just returns
    HKEY_CURRENT_USER);  to load other users' profiles, the current user must
    be a supervisor.  IUser::UnloadProfile() should always be called when the
    caller is done playing with the user's profile.

UnloadProfile(HKEY hkeyUser)
    Unloads the user's profile from the registry if possible, and closes the
    key handle returned by IUser::LoadProfile.  If the specified user is the
    current user, this function does nothing.

GetComponentSettings(REFCLSID clsidComponent, LPCSTR pszName,
					 IUnknown **ppOut, DWORD fdwAccess)
    CURRENTLY NOT IMPLEMENTED
	Returns an IUserSettings interface which can be used to access the
	user's settings for a particular component.  Either clsidComponent or
	pszName may be used to refer to the component whose settings are to be
	accessed.  If pszName is not NULL, it takes precedence over clsidComponent.
	fdwAccess specifies whether the caller wants read or write access to the
	settings.  If the component's settings are restricted and the current user
	is not a supervisor, only GENERIC_READ access will be allowed;
	GENERIC_WRITE will fail.

EnumerateComponentSettings(IEnumUnknown **ppOut, DWORD fdwAccess)
    CURRENTLY NOT IMPLEMENTED
	Returns an IEnumUnknown interface which can be used to enumerate all
	components which have settings recorded for the user.  fdwAccess
	specifies the desired access, read or write.  If the current user
	is not a supervisor and the caller requests write access, the enumerator
	will not return any components which do not permit such access.

************************************************************************/

DECLARE_INTERFACE_(IUser, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;
	STDMETHOD(GetProfileDirectory) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;

	STDMETHOD(IsSupervisor) (THIS) PURE;
	STDMETHOD(SetSupervisorPrivilege) (THIS_ BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword) PURE;
	STDMETHOD(MakeTempSupervisor) (THIS_ BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword) PURE;
	STDMETHOD(AppearsSupervisor) (THIS) PURE;

	STDMETHOD(Authenticate) (THIS_ LPCSTR pszPassword) PURE;
	STDMETHOD(ChangePassword) (THIS_ LPCSTR pszOldPassword, LPCSTR pszNewPassword) PURE;
	STDMETHOD(GetPasswordCache) (THIS_ LPCSTR pszPassword, LPHANDLE phOut) PURE;

    STDMETHOD(LoadProfile) (THIS_ HKEY *phkeyUser) PURE;
    STDMETHOD(UnloadProfile) (THIS_ HKEY hkeyUser) PURE;

	STDMETHOD(GetComponentSettings) (THIS_ REFCLSID clsidComponent,
									 LPCSTR pszName, IUnknown **ppOut,
									 DWORD fdwAccess) PURE;
	STDMETHOD(EnumerateComponentSettings) (THIS_ IEnumUnknown **ppOut,
										   DWORD fdwAccess) PURE;
};


/************************************************************************

IUserProfileInit interface

This interface is a helper for IUserDatabase::Install and IUserDatabase::Create.
It allows the client of those functions to perform initialization of a new
user's profile before and after the new user's per-user folders are set up.

Member functions, other than IUnknown:

PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
	Called when the user's profile has been created, but no per-user folders
    have been created or initialized yet.  Here the implementer can add keys to
    the user's profile which will affect the initialization of those per-user
    folders.  hkeyUser is the root of the user's profile, which would be
    HKEY_CURRENT_USER if the user were currently logged on.

PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
    Called after the user's per-user folders have been created and initialized.
    Here the implementer can add keys to the user's profile which will control
    roaming of per-user folders, without causing the IUserDatabase profile
    cloning code to want to initialize those folders from their default
    locations.

************************************************************************/

DECLARE_INTERFACE_(IUserProfileInit, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(PreInitProfile) (THIS_ HKEY hkeyUser, LPCSTR pszProfileDir) PURE;
    STDMETHOD(PostInitProfile) (THIS_ HKEY hkeyUser, LPCSTR pszProfileDir) PURE;
};


/************************************************************************

IUserDatabase interface

This interface is used to manage the local user database as a whole.  Any
activities which deal with the list of users in any way are done through
this interface;  operations which deal with the properties (other than the
name) of an existing user are done through IUser.

Member functions, other than IUnknown:

Install(LPCSTR pszSupervisorName, LPCSTR pszSupervisorPassword,
        LPCSTR pszRatingsPassword, IUserProfileInit *pInit)
	Installs the user settings subsystem.  This includes creating an account
	for the supervisor.  A separate member function is necessary for doing
	this because all the others would insist that the current user already
	be a supervisor.  The pInit object (optional, may be NULL) is called
    back to allow the installer to do initialization of the profile being
    created, before and after its per-user files are copied.

AddUser(LPCSTR pszName, IUser *pSourceUser, IUserProfileInit *pInit,
        IUser **ppOut)
	Creates a new user on the system.  This includes creating a profile
	for the user.  It does not, however, include creating a password list
	file.  IUser::ChangePassword can be used to configure the password
	for the user.  An IUser object is returned to the caller so that the
	caller can configure the properties of the user.  This function will
	fail if the current user is not a supervisor.  The caller can optionally
	specify a user account to be cloned.  The pInit object (optional, may be
	NULL) is called back to allow the installer to do initialization of the
	profile being created, before and after its per-user files are copied.

GetUser(LPCSTR pszName, IUser **ppOut)
	Gets an IUser object corresponding to the specified user.  The current
	user need not be a supervisor to call this function, and any user's
	name may be specified.  The IUser interface will control what a non-
	supervisor can and cannot do to the user object.

GetSpecialUser(DWORD nSpecialUserCode, IUser **ppOut)
	Gets an IUser object corresponding to a special particular user.
	Current values for nSpecialUserCode include GSU_CURRENT, meaning
	the currently logged on user, and GSU_DEFAULT, meaning the default
	user identity (i.e., the identity used when nobody is logged on,
	also used as a template when creating new identities).

GetCurrentUser(IUser **ppOut)
	Gets an IUser object corresponding to the currently logged on user.
	Shorthand for GetSpecialUser(GSU_CURRENT, ppOut).

SetCurrentUser(IUser *pUser)
	Sets this IUserDatabase object's idea of who the current user is.
	The user must have previously been authenticated.  This user object
	is used for all checks which, for example, determine whether the
	"current user" is a supervisor, or whether a user can access his
	or her own settings, etc.  SetCurrentUser does not AddRef the IUser
	object passed.

DeleteUser(LPCSTR pszName)
	Deletes the profile and password cache for the specified user,
	effectively destroying that user's identity.  This function may
	only be called if the current user is a supervisor.  Any existing
	IUser objects which refer to the user are no longer useful, but
	still must be destroyed in the ordinary way (Release()).

RenameUser(LPCSTR pszOldName, LPCSTR pszNewName)
	Changes the username of a user.  This function may only be called
	if the current user is a supervisor.

EnumUsers(IEnumUnknown **ppOut)
	Returns an IEnumUnknown object which the caller can use to enumerate
	the local users on the system.

Authenticate(HWND hwndOwner, DWORD dwFlags, LPCSTR pszName, LPCSTR pszPassword,
			 IUser **ppOut)
	Attempts to authenticate a user.  dwFlags specifies whether or not
	to prompt for credentials, and whether or not non-supervisors are
	acceptable.  If no dialog is to be displayed by the API, then the
	pszName and pszPassword parameters are used instead.  If the credentials
	are authenticated succcessfully, S_OK is returned.  The ppOut parameter,
	if not NULL, is filled with a pointer to an IUser object describing the
	user who was authenticated, in case the caller cares to find out about
	who typed in their name and password.

    The dwFlags parameter specifies whether UI will be displayed by the
    function, and whether or not the credentials will be cached in memory
    for use at the next logon.

InstallComponent(REFCLSID clsidComponent, LPCSTR pszName, DWORD dwFlags)
    CURRENTLY NOT IMPLEMENTED

	Installs a component into the settings database, so that it will appear
	in the settings UI.  clsidComponent or pszName can be used to refer to
	the component being installed;  use of a CLSID is preferable because
	then the component can provide server code which renders the settings
	UI for that component, and knows how to initialize the settings for a
	new user.

	The only bit currently defined for dwFlags is:

	SETTINGS_NS_CAN_WRITE:		Non-supervisors can change their own settings
								for this component.

	A component's settings for the current user can always be read, at least
	programmatically -- there is no point in storing settings which can only
	be accessed if the current user is a supervisor.  If non-supervisors
	should not be shown the UI for restricted settings (even a read-only UI),
	that decision can be made at the UI level.

	InstallComponent fails if the current user is not a supervisor.

RemoveComponent(REFCLSID clsidComponent, LPCSTR pszName)
    CURRENTLY NOT IMPLEMENTED

	Removes a component from the settings database, so that it will no longer
	appear in the settings UI.  This also removes this component's settings
	from all user identities.

	RemoveComponent fails if the current user is not a supervisor.

InstallWizard(HWND hwndParent)
    Runs the wizard that switches to multiuser mode.

AddUserWizard(HWND hwndParent)
    Runs the wizard that adds a new user, invoking the go-multiuser wizard
    if necessary.

UserCPL(HWND hwndParent)
    Invokes the general user management UI as seen in Control panel, invoking
    the go-multiuser wizard if necessary.

************************************************************************/

DECLARE_INTERFACE_(IUserDatabase, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(Install) (THIS_ LPCSTR pszSupervisorName, LPCSTR pszSupervisorPassword,
	                    LPCSTR pszRatingsPassword, IUserProfileInit *pInit) PURE;
	STDMETHOD(AddUser) (THIS_ LPCSTR pszName, IUser *pSourceUser,
	                    IUserProfileInit *pInit, IUser **ppOut) PURE;
	STDMETHOD(GetUser) (THIS_ LPCSTR pszName, IUser **ppOut) PURE;
	STDMETHOD(GetSpecialUser) (THIS_ DWORD nSpecialUserCode, IUser **ppOut) PURE;
	STDMETHOD(GetCurrentUser) (THIS_ IUser **ppOut) PURE;
	STDMETHOD(SetCurrentUser) (THIS_ IUser *pUser) PURE;
	STDMETHOD(DeleteUser) (THIS_ LPCSTR pszName) PURE;
	STDMETHOD(RenameUser) (THIS_ LPCSTR pszOldName, LPCSTR pszNewName) PURE;
	STDMETHOD(EnumUsers) (THIS_ IEnumUnknown **ppOut) PURE;

	STDMETHOD(Authenticate) (THIS_ HWND hwndOwner, DWORD dwFlags,
							 LPCSTR pszName, LPCSTR pszPassword,
							 IUser **ppOut) PURE;

	STDMETHOD(InstallComponent) (THIS_ REFCLSID clsidComponent, LPCSTR pszName,
								 DWORD dwFlags) PURE;
	STDMETHOD(RemoveComponent) (THIS_ REFCLSID clsidComponent, LPCSTR pszName) PURE;
    STDMETHOD(InstallWizard) (THIS_ HWND hwndParent) PURE;
    STDMETHOD(AddUserWizard) (THIS_ HWND hwndParent) PURE;

    STDMETHOD(UserCPL) (THIS_ HWND hwndParent) PURE;
};

// codes for IUserDatabase::GetSpecialUser

const DWORD GSU_CURRENT = 0;				// current user
const DWORD GSU_DEFAULT = 1;				// default user profile

// flags for IUserDatabase::Authenticate
const DWORD LUA_DIALOG = 0x00000001;			// display dialog to get credentials
												// otherwise use pszName, pszPassword
const DWORD LUA_SUPERVISORONLY = 0x00000002;	// authenticate supervisors only
const DWORD LUA_FORNEXTLOGON = 0x00000004;      // cache credentials for next logon

// flags for IUserDatabase::InstallComponent
const DWORD SETTINGS_NS_CAN_WRITE = 0x01;	// non-supervisors can change their own settings

#endif  // _MSLUAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\makefile.inc ===
#
#
#  R E A D   T H I S
#
#  See the inference rules below (the section marked "Inference rules") to
#  see if any of them cover the rule that you want performed for your file.
#  The inference rules should cover most of the cases.  If they don't, try
#  to add a new inference rule rather than adding a special-case rule for
#  your file.
#

#
# Explicit dependencies for .w files -- needed to make inference rules apply
#

# cmnquery.w -> $(SDK_INC_PATH)\cmnquery.h
# BUGBUG (reinerf) - why are we splitting this if we only use the public file??
$(O)\cmnquery.h : cmnquery.w

# commctrl.w -> $(SDK_INC_PATH)\commctrl.h, $(SDK_INC_PATH)\commctrl.rh, $(PROJECT_INC_PATH)\comctrlp.h
$(O)\commctrl.h $(O)\commctrlp.h : commctrl.w

# commdlg.w -> $(SDK_INC_PATH)\commdlg.h, $(PROJECT_INC_PATH)\commdlgp.h
$(O)\commdlg.h $(O)\commdlgp.h : commdlg.w

# cpl.w -> $(SDK_INC_PATH)\cpl.h, $(PROJECT_INC_PATH)\cplp.h
$(O)\cpl.h $(O)\cplp.h : cpl.w

# dsclient.w -> $(SDK_INC_PATH)\dsclient.h, $(PROJECT_INC_PATH)\dsclintp.h
$(O)\dsclient.h $(O)\dsclientp.h : dsclient.w

# dsquery.w -> $(SDK_INC_PATH)\dsquery.h, $(PROJECT_INC_PATH)\dsqueryp.h
$(O)\dsquery.h $(O)\dsqueryp.h : dsquery.w

# intshcut.w -> $(SDK_INC_PATH)\intshcut.h, $(PROJECT_INC_PATH)\intshctp.h
$(O)\intshcut.h $(O)\intshcutp.h : intshcut.w

# multimon.w -> $(SDK_INC_PATH)\multimon.h, $(PROJECT_INC_PATH)\multimop.h
$(O)\multimon.h $(O)\multimonp.h : multimon.w

# prsht.w -> $(SDK_INC_PATH)\prsht.h, $(PROJECT_INC_PATH)\prshtp.h
$(O)\prsht.h $(O)\prshtp.h : prsht.w

# powrprof.w -> $(SDK_INC_PATH)\powrprof.h, $(PROJECT_INC_PATH)\powrprofp.h
$(O)\powrprof.h $(O)\powrprofp.h : powrprof.w

# shellapi.w -> $(SDK_INC_PATH)\shellapi.h, $(PROJECT_INC_PATH)\shlapip.h
$(O)\shellapi.h $(O)\shellapip.h : shellapi.w

#shlguid.w -> $(SDK_INC_PATH)\shlguid.h, $(PROJECT_INC_PATH)\shlguidp.h
$(O)\shlguid.h $(O)\shlguidp.h : shlguid.w

# shlobj.w -> $(SDK_INC_PATH)\shlobj.h, $(PROJECT_INC_PATH)\shlobjp.h
$(O)\shlobj.h $(O)\shlobjp.h : shlobj.w

# shlwapi.w -> $(SDK_INC_PATH)\shlwapi.h, $(PROJECT_INC_PATH)\shlwapip.h
$(O)\shlwapi.h $(O)\shlwapip.h : shlwapi.w

# winver.w -> $(SDK_INC_PATH)\winver.h
$(O)\winver.h : winver.w


$(O)\commctrl.rh: $(O)\commctrl.h
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    commctrl.rh

Abstract:

    This module defines the 32-Bit Windows resource codes from commctrl.h.

Revision History:

--*/
<<
    hextract -o $@ -lt r_commctrl -bt begin_r_commctrl end_r_commctrl $(O)\commctrl.h

#
# Explicit dependencies for public files that must be done on pass0
#

$(O)\shobjidl_pub.idl : shobjidl.idl
    hsplit -e -o $(O)\shobjidl_pub.idl $(O)\shobjidl_priv.idl $**

$(O)\shobjidl_pub.h : $(O)\shobjidl.h
    hsplit -e -o $(O)\shobjidl_pub.h $(O)\shobjidl_priv.h $**

#
# Explicit dependencies for private files that must be done on pass0
#

$(PROJECT_ROOT)\lib\$(O)\brdispp.tlb : $(O)\brdispp.tlb
$(O)\brdispp.tlb : brdispp.idl $(O)\brdispp.h
$(PROJECT_ROOT)\inc\$(O)\brdispp.h : $(O)\brdispp.h
$(PROJECT_ROOT)\lib\$O\brdispp_i.c : $(O)\brdispp_i.c

$(PROJECT_ROOT)\inc\$(O)\intshctp.h : $(O)\intshcut.h
    copy $(O)\intshcutp.h $(PROJECT_ROOT)\inc\$(O)\intshctp.h

$(PROJECT_ROOT)\inc\$(O)\navbar.h : $(O)\navbar.h

$(PROJECT_ROOT)\inc\$(O)\navlog.h : $(O)\navlog.h

$(PROJECT_ROOT)\inc\$(O)\shobjidlp.h : $(O)\shobjidl_pub.h
    copy $(O)\shobjidl_priv.h $(PROJECT_ROOT)\inc\$(O)\shobjidlp.h

$(PROJECT_ROOT)\lib\$(O)\msieftp.tlb : $(O)\msieftp.tlb
$(O)\msieftp.tlb : msieftp.idl $(O)\msieftp.h
$(PROJECT_ROOT)\inc\$(O)\msieftp.h : $(O)\msieftp.h
$(PROJECT_ROOT)\lib\$O\msieftp_i.c : $(O)\msieftp_i.c

$(PROJECT_ROOT)\lib\$(O)\theme.tlb : $(O)\theme.tlb
$(O)\theme.tlb : theme.idl $(O)\theme.h
$(PROJECT_ROOT)\inc\$(O)\theme.h : $(O)\theme.h
$(PROJECT_ROOT)\lib\$O\theme_i.c : $(O)\theme_i.c

$(PROJECT_ROOT)\lib\$(O)\shgina.tlb : $(O)\shgina.tlb
$(O)\shgina.tlb : shgina.idl $(O)\shgina.h

$(PROJECT_ROOT)\lib\$(O)\shldisp.tlb : $(O)\shldisp.tlb
$(O)\shldisp.tlb : shldisp.idl $(O)\shldisp.h

$(PROJECT_ROOT)\lib\$(O)\shimgvw.tlb : $(O)\shimgvw.tlb
$(O)\shimgvw.tlb : shimgvw.idl $(O)\shimgvw.h
$(PROJECT_ROOT)\inc\$(O)\shimgvw.h : $(O)\shimgvw.h
$(PROJECT_ROOT)\lib\$(O)\shimgvw_i.c : $(O)\shimgvw_i.c

$(PROJECT_ROOT)\inc\$(O)\opsprof.h : $(O)\opsprof.h

$(PROJECT_ROOT)\lib\$(O)\webvw.tlb : $(O)\webvw.tlb
$(O)\webvw.tlb : webvw.idl $(O)\webvw.h
$(PROJECT_ROOT)\inc\$(O)\webvw.h : $(O)\webvw.h
$(PROJECT_ROOT)\lib\$(O)\webvw_i.c : $(O)\webvw_i.c

$(PROJECT_ROOT)\lib\$(O)\shpriv_i.c : $(O)\shpriv_i.c
$(O)\shpriv_i.c : shpriv.idl

$(PROJECT_ROOT)\lib\$(O)\iepriv_i.c : $(O)\iepriv_i.c
$(O)\iepriv_i.c : iepriv.idl

#
# Inference rules.  These help build whatever is in the NTTARGETFILES and
# NTTARGETFILE0 lists.
#

.SUFFIXES:.w .h .tlb

# generate header.h and headerp.h from header.w
{}.w{$O}.h:
    hsplit -e -o $(*R).x $(*R)p.x $**
    wcshdr < $(*R)p.x > $(*R)p.h
    wcshdr < $(*R).x > $(*R).y
    shfusion2 $(*R).y > $@

# copy generated headers to shell\inc
{$O}.h{$(PROJECT_ROOT)\inc\$(O)}.h:
    copy $** $@

# copy generated tlb's to shell\lib\$O
{$O}.tlb{$(PROJECT_ROOT)\lib\$O}.tlb:
    copy $** $@

# copy generated c's to shell\lib\$O
{$O}.c{$(PROJECT_ROOT)\lib\$O}.c:
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\msshrui.h ===
/*****************************************************************/
/**                      Microsoft Windows                      **/
//*   Copyright (c) Microsoft Corporation. All rights reserved. **/
/*****************************************************************/

/*
    msshrui.h
    Prototypes and definitions for sharing APIs

    FILE HISTORY:
    gregj    06/03/93    Created
	brucefo  3/5/96      Fixed prototypes for NT
*/

#ifndef _INC_MSSHRUI
#define _INC_MSSHRUI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


// Note: make sure you GetProcAddress the proper (ANSI/UNICODE) entrypoint!

BOOL WINAPI
IsPathShared(
    IN LPCTSTR lpPath,
    IN BOOL fRefresh
    );

typedef
BOOL
(WINAPI* PFNISPATHSHARED)(
    IN LPCTSTR lpPath,
    IN BOOL fRefresh
    );

BOOL WINAPI
SharingDialog(
    IN HWND hwndParent,
    IN LPTSTR pszComputerName,
    IN LPTSTR pszPath
    );

typedef
BOOL
(WINAPI* PFNSHARINGDIALOG)(
    IN HWND hwndParent,
    IN LPTSTR pszComputerName,
    IN LPTSTR pszPath
    );

BOOL WINAPI
GetNetResourceFromLocalPath(
    IN     LPCTSTR lpcszPath,
    IN OUT LPTSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    );

typedef
BOOL
(WINAPI* PFNGETNETRESOURCEFROMLOCALPATH)(
    IN     LPCTSTR lpcszPath,
    IN OUT LPTSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    );

BOOL WINAPI
GetLocalPathFromNetResource(
    IN     LPCTSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPTSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    );

typedef
BOOL
(WINAPI* PFNGETLOCALPATHFROMNETRESOURCE)(
    IN     LPCTSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPTSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    );

// Flags returned by IsFolderPrivateForUser via pdwPrivateType
#define IFPFU_NOT_PRIVATE               0x0000
#define IFPFU_PRIVATE                   0x0001
#define IFPFU_PRIVATE_INHERITED         0x0002
#define IFPFU_NOT_NTFS                  0x0004

BOOL WINAPI
IsFolderPrivateForUser(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    );

typedef
BOOL
(WINAPI* PFNISFOLDERPRIVATEFORUSER)(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    );

BOOL WINAPI
SetFolderPermissionsForSharing(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD dwLevel,
    IN     HWND hwndParent
    );

typedef
BOOL
(WINAPI* PFNSETFOLDERPERMISSIONSFORSHARING)(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD dwLevel,
    IN     HWND hwndParent
    );

#ifndef WINNT

UINT WINAPI ShareDirectoryNotify(HWND hwnd, LPCSTR lpDir, DWORD dwOper);

#ifndef WNDN_MKDIR
#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3
#endif

#define ORD_SHARESHUTDOWNNOTIFY 12

BOOL WINAPI
ShareShutdownNotify(
    DWORD dwFlags,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    );

typedef
BOOL
(WINAPI* pfnShareShutdownNotify)(
    DWORD dwFlags,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    );

#endif // WINNT

#ifndef RC_INVOKED
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* !_INC_MSSHRUI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\pif.h ===
/*
 *  Microsoft  Confidential
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  All Rights Reserved.
 *
 *
 *  PIF.H
 *  DOS Program Information File structures, constants, etc.
 */


#ifndef _INC_PIF
#define _INC_PIF

#include <shlobj.h>

/* XLATOFF */
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */
/* XLATON */

// for DOJ compliance, size defines moved to shlobj.w

#ifndef LF_FACESIZE
#define LF_FACESIZE     32
#endif

#define LARGEST_GROUP   sizeof(PROPPRG)

// for DOJ compliance, some property flags moved to shlobj.h
#define OPENPROPS_RAWIO         0x0001		//;Internal
#define OPENPROPS_INFONLY       0x0002		//;Internal
#define OPENPROPS_FORCEREALMODE 0x0004		//;Internal

#define GETPROPS_RAWIO          0x0001		//;Internal
#define GETPROPS_EXTENDED       0x0004          //;Internal
#define GETPROPS_OEM            0x0008		//;Internal

#define FLUSHPROPS_NONE         0x0000		//;Internal
#define FLUSHPROPS_DISCARD      0x0001		//;Internal

#define CREATEPROPS_NONE        0x0000		//;Internal

#define SETPROPS_RAWIO          0x0001		//;Internal
#define SETPROPS_CACHE          0x0002		//;Internal
#define SETPROPS_EXTENDED       0x0004          //;Internal
#define SETPROPS_OEM            0x0008		//;Internal

#define DELETEPROPS_NONE        0x0000		
#define DELETEPROPS_DISCARD     0x0001		
#define DELETEPROPS_ABORT       0x0002

#define LOADPROPLIB_DEFER       0x0001



/* XLATOFF */
#ifndef FAR
#define FAR
#endif
/* XLATON */

//#ifdef  RECT
//#define _INC_WINDOWS
//#endif

//#ifndef _INC_WINDOWS

/* ASM
RECT    struc
        rcLeft      dw  ?
        rcTop       dw  ?
        rcRight     dw  ?
        rcBottom    dw  ?
RECT    ends
*/

/* XLATOFF */
typedef struct tagPIFRECT {
    WORD left;
    WORD top;
    WORD right;
    WORD bottom;
} PIFRECT;
typedef PIFRECT *PPIFRECT;
typedef PIFRECT FAR *LPPIFRECT;
/* XLATON */

//#endif


/*
 *  Property groups, used by PIFMGR.DLL and VxD interfaces
 *
 *  The structures for each of the pre-defined, ordinal-based groups
 *  is a logical view of data in the associated PIF file, if any -- not a
 *  physical view.
 */

#define GROUP_PRG               1           // program group

#define PRG_DEFAULT             0
#define PRG_CLOSEONEXIT         0x0001      // MSflags & EXITMASK
#define PRG_NOSUGGESTMSDOS      0x0400      // see also: PfW386Flags & fNoSuggestMSDOS

#define PRGINIT_DEFAULT         0
#define PRGINIT_MINIMIZED       0x0001      // see also: PfW386Flags & fMinimized
#define PRGINIT_MAXIMIZED       0x0002      // see also: PfW386Flags & fMaximized
#define PRGINIT_WINLIE          0x0004      // see also: PfW386Flags & fWinLie
#define PRGINIT_REALMODE        0x0008      // see also: PfW386Flags & fRealMode
#define PRGINIT_REALMODESILENT  0x0100      // see also: PfW386Flags & fRealModeSilent
#define PRGINIT_QUICKSTART      0x0200      // see also: PfW386Flags & fQuickStart  /* ;Internal */
#define PRGINIT_AMBIGUOUSPIF    0x0400      // see also: PfW386Flags & fAmbiguousPIF
#define PRGINIT_NOPIF           0x1000      // no PIF found
#define PRGINIT_DEFAULTPIF      0x2000      // default PIF found
#define PRGINIT_INFSETTINGS     0x4000      // INF settings found
#define PRGINIT_INHIBITPIF      0x8000      // INF indicates that no PIF be created

/*
 *  Real mode option flags.  NOTE: this field is a dword.  The low word
 *  uses these flags to indicate required options.  The high word is used
 *  to specify "nice" but not required options.
 */
#define RMOPT_MOUSE             0x0001      // Real mode mouse
#define RMOPT_EMS               0x0002      // Expanded Memory
#define RMOPT_CDROM             0x0004      // CD-ROM support
#define RMOPT_NETWORK           0x0008      // Network support
#define RMOPT_DISKLOCK          0x0010      // disk locking required
#define RMOPT_PRIVATECFG        0x0020      // use private configuration (ie, CONFIG/AUTOEXEC)
#define RMOPT_VESA              0x0040      // VESA driver


#define ICONFILE_DEFAULT        TEXT("PIFMGR.DLL")
#define ICONINDEX_DEFAULT       0


// for DOJ compliance, PROPPRG moved to shlobj.w


#define GROUP_TSK               2           // tasking group

#define TSK_DEFAULT             (TSK_BACKGROUND)
#define TSK_ALLOWCLOSE          0x0001      // PfW386Flags & fEnableClose
#define TSK_BACKGROUND          0x0002      // PfW386Flags & fBackground
#define TSK_EXCLUSIVE           0x0004      // PfW386Flags & fExclusive             /* ;Internal */
#define TSK_NOWARNTERMINATE     0x0010      // Don't warn before closing
#define TSK_NOSCREENSAVER       0x0020      // Do not activate screen saver

#define TSKINIT_DEFAULT         0

#define TSKFGNDBOOST_DEFAULT    0           // fgnd boost                           /* ;Internal */
#define TSKBGNDBOOST_DEFAULT    0           // bgnd boost                           /* ;Internal */
                                                                                    /* ;Internal */
#define TSKFGND_OLD_DEFAULT     100         // normal fgnd setting                  /* ;Internal */
#define TSKBGND_OLD_DEFAULT     50          // normal bgnd setting                  /* ;Internal */
                                                                                    /* ;Internal */
#define TSKIDLESENS_DEFAULT     50          // % (min-max == 0-100)

typedef struct PROPTSK {                    /* tsk */
    WORD    flTsk;                          // see TSK_ flags
    WORD    flTskInit;                      // see TSKINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    wReserved4;                     // (reserved, must be zero)
    WORD    wIdleSensitivity;               // %, also affects PfW386Flags & fPollingDetect
} PROPTSK;
typedef UNALIGNED PROPTSK *PPROPTSK;
typedef UNALIGNED PROPTSK FAR *LPPROPTSK;


#define GROUP_VID               3           // video group

#define VID_DEFAULT             (VID_TEXTEMULATE)
#define VID_TEXTEMULATE         0x0001      // PfW386Flags2 & fVidTxtEmulate
#define VID_RETAINMEMORY        0x0080      // PfW386Flags2 & fVidRetainAllo
#define VID_FULLSCREEN          0x0100      // PfW386Flags  & fFullScreen

#define VIDINIT_DEFAULT         0

#define VIDSCREENLINES_MIN      0           // in # lines (0 = use VDD value)
#define VIDSCREENLINES_DEFAULT  0           // in # lines
#define VIDSCREENLINES_MAX      50          // in # lines                           /* ;Internal */

typedef struct PROPVID {                    /* vid */
    WORD    flVid;                          // see VID_ flags
    WORD    flVidInit;                      // see VIDINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    cScreenLines;                   // ([NonWindowsApp]:ScreenLines)
} PROPVID;
typedef UNALIGNED PROPVID *PPROPVID;
typedef UNALIGNED PROPVID FAR *LPPROPVID;


#define GROUP_MEM               4           // memory group

#define MEM_DEFAULT             0

#define MEMINIT_DEFAULT         0
#define MEMINIT_NOHMA           0x0001      // PfW386Flags & fNoHMA
#define MEMINIT_LOWLOCKED       0x0002      // PfW386Flags & fVMLocked
#define MEMINIT_EMSLOCKED       0x0004      // PfW386Flags & fEMSLocked
#define MEMINIT_XMSLOCKED       0x0008      // PfW386Flags & fXMSLocked
#define MEMINIT_GLOBALPROTECT   0x0010      // PfW386Flags & fGlobalProtect
#define MEMINIT_STRAYPTRDETECT  0x0020      // PfW386Flags & fStrayPtrDetect        /* ;Internal */
#define MEMINIT_LOCALUMBS       0x0040      // PfW386Flags & fLocalUMBs             /* ;Internal */

#define MEMLOW_MIN              0           // in KB
#define MEMLOW_DEFAULT          0           // in KB
#define MEMLOW_MAX              640         // in KB

#define MEMEMS_MIN              0           // in KB
#define MEMEMS_DEFAULT          0           // in KB
#define MEMEMS_MAX              0xFFFF      // in KB

#define MEMXMS_MIN              0           // in KB
#define MEMXMS_DEFAULT          0           // in KB
#define MEMXMS_MAX              0xFFFF      // in KB

typedef struct PROPMEM {                    /* mem */
    WORD    flMem;                          // see MEM_ flags
    WORD    flMemInit;                      // see MEMINIT_ flags
    WORD    wMinLow;                        // PfW386minmem
    WORD    wMaxLow;                        // PfW386maxmem
    WORD    wMinEMS;                        // PfMinEMMK
    WORD    wMaxEMS;                        // PfMaxEMMK
    WORD    wMinXMS;                        // PfMinXmsK
    WORD    wMaxXMS;                        // PfMaxXmsK
} PROPMEM;
typedef UNALIGNED PROPMEM *PPROPMEM;
typedef UNALIGNED PROPMEM FAR *LPPROPMEM;


#define GROUP_KBD               5           // keyboard group

#define KBD_DEFAULT             (KBD_FASTPASTE)
#define KBD_FASTPASTE           0x0001      // PfW386Flags & fINT16Paste
#define KBD_NOALTTAB            0x0020      // PfW386Flags & fALTTABdis
#define KBD_NOALTESC            0x0040      // PfW386Flags & fALTESCdis
#define KBD_NOALTSPACE          0x0080      // PfW386Flags & fALTSPACEdis
#define KBD_NOALTENTER          0x0100      // PfW386Flags & fALTENTERdis
#define KBD_NOALTPRTSC          0x0200      // PfW386Flags & fALTPRTSCdis
#define KBD_NOPRTSC             0x0400      // PfW386Flags & fPRTSCdis
#define KBD_NOCTRLESC           0x0800      // PfW386Flags & fCTRLESCdis

#define KBDINIT_DEFAULT         0

#define KBDALTDELAY_MIN             1
#define KBDALTDELAY_DEFAULT         5
#define KBDALTDELAY_MAX             5000

#define KBDALTPASTEDELAY_MIN        1
#define KBDALTPASTEDELAY_DEFAULT    25
#define KBDALTPASTEDELAY_MAX        5000

#define KBDPASTEDELAY_MIN           1
#define KBDPASTEDELAY_DEFAULT       3
#define KBDPASTEDELAY_MAX           5000

#define KBDPASTEFULLDELAY_MIN       1
#define KBDPASTEFULLDELAY_DEFAULT   200
#define KBDPASTEFULLDELAY_MAX       5000

#define KBDPASTETIMEOUT_MIN         1
#define KBDPASTETIMEOUT_DEFAULT     1000
#define KBDPASTETIMEOUT_MAX         5000

#define KBDPASTESKIP_MIN            1
#define KBDPASTESKIP_DEFAULT        2
#define KBDPASTESKIP_MAX            100

#define KBDPASTECRSKIP_MIN          1
#define KBDPASTECRSKIP_DEFAULT      10
#define KBDPASTECRSKIP_MAX          100

typedef struct PROPKBD {                    /* kbd */
    WORD    flKbd;                          // see KBD_ flags
    WORD    flKbdInit;                      // see KBDINIT_ flags
    WORD    msAltDelay;                     // ([386Enh]:AltKeyDelay)
    WORD    msAltPasteDelay;                // ([386Enh]:AltPasteDelay)
    WORD    msPasteDelay;                   // ([386Enh]:KeyPasteDelay)
    WORD    msPasteFullDelay;               // ([386Enh]:KeyBufferDelay)
    WORD    msPasteTimeout;                 // ([386Enh]:KeyPasteTimeOut)
    WORD    cPasteSkip;                     // ([386Enh]:KeyPasteSkipCount)
    WORD    cPasteCRSkip;                   // ([386Enh]:KeyPasteCRSkipCount)
} PROPKBD;
typedef UNALIGNED PROPKBD *PPROPKBD;
typedef UNALIGNED PROPKBD FAR *LPPROPKBD;


#define GROUP_MSE               6           // mouse group

/* No VxD currently pays attention to PROPMSE. VMDOSAPP should know how to
 * handle all cases resulting from a change in these flags.
 *
 * Note that MSE_WINDOWENABLE corresponds to the Windows NT "QuickEdit"
 * property, except backwards.
 */

#define MSE_DEFAULT             (MSE_WINDOWENABLE)
#define MSE_WINDOWENABLE        0x0001      // ([NonWindowsApp]:MouseInDosBox)
#define MSE_EXCLUSIVE           0x0002      //

#define MSEINIT_DEFAULT         0           // default flags

typedef struct PROPMSE {                    /* mse */
    WORD    flMse;                          // see MSE_ flags
    WORD    flMseInit;                      // see MSEINIT_ flags
} PROPMSE;
typedef UNALIGNED PROPMSE *PPROPMSE;
typedef UNALIGNED PROPMSE FAR *LPPROPMSE;


#define GROUP_SND               7           // sound group                  /* ;Internal */
                                                                            /* ;Internal */
#define SND_DEFAULT             (SND_SPEAKERENABLE)                         /* ;Internal */
#define SND_SPEAKERENABLE       0x0001      //                              /* ;Internal */
                                                                            /* ;Internal */
#define SNDINIT_DEFAULT         0                                           /* ;Internal */
                                                                            /* ;Internal */
typedef struct PROPSND {                    /* snd */                       /* ;Internal */
    WORD    flSnd;                          // see SND_ flags               /* ;Internal */
    WORD    flSndInit;                      // see SNDINIT_ flags           /* ;Internal */
} PROPSND;                                                                  /* ;Internal */
typedef UNALIGNED PROPSND *PPROPSND;                                        /* ;Internal */
typedef UNALIGNED PROPSND FAR *LPPROPSND;                                   /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */
#define GROUP_FNT               8           // font group

#define FNT_DEFAULT             (FNT_BOTHFONTS | FNT_AUTOSIZE)
#define FNT_RASTERFONTS         0x0004      // allow raster fonts in dialog
#define FNT_TTFONTS             0x0008      // allow truetype fonts in dialog
#define FNT_BOTHFONTS           (FNT_RASTERFONTS | FNT_TTFONTS)
#define FNT_AUTOSIZE            0x0010      // enable auto-sizing
#define FNT_RASTER              0x0400      // specified font is raster
#define FNT_TT                  0x0800      // specified font is truetype

#define FNT_FONTMASK            (FNT_BOTHFONTS)
#define FNT_FONTMASKBITS        2           // # of bits shifted left

#define FNTINIT_DEFAULT         0
#define FNTINIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPFNT {                    /* fnt */
    WORD    flFnt;                          // see FNT_ flags
    WORD    flFntInit;                      // see FNTINIT_ flags
    WORD    cxFont;                         // width of desired font
    WORD    cyFont;                         // height of desired font
    WORD    cxFontActual;                   // actual width of desired font
    WORD    cyFontActual;                   // actual height of desired font
    CHAR    achRasterFaceName[LF_FACESIZE]; // name to use for raster font
    CHAR    achTTFaceName[LF_FACESIZE];     // name to use for tt font
    WORD    wCurrentCP;                     // Current Codepage
} PROPFNT;
typedef UNALIGNED PROPFNT *PPROPFNT;
typedef UNALIGNED PROPFNT FAR *LPPROPFNT;

#define GROUP_WIN               9          // window group

#define WIN_DEFAULT             (WIN_SAVESETTINGS | WIN_TOOLBAR)
#define WIN_SAVESETTINGS        0x0001      // save settings on exit (default)
#define WIN_TOOLBAR             0x0002      // enable toolbar

#define WININIT_DEFAULT         0
#define WININIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPWIN {                    /* win */
    WORD    flWin;                          // see WIN_ flags
    WORD    flWinInit;                      // see WININIT flags
    WORD    cxCells;                        // width in cells
    WORD    cyCells;                        // height in cells
    WORD    cxClient;                       // width of client window
    WORD    cyClient;                       // height of client window
    WORD    cxWindow;                       // width of entire window
    WORD    cyWindow;                       // height of entire window
    WORD    wLength;
    WORD    wShowFlags;
    WORD    wShowCmd;
    WORD    xMinimize;
    WORD    yMinimize;
    WORD    xMaximize;
    WORD    yMaximize;
    PIFRECT rcNormal;
} PROPWIN;
typedef UNALIGNED PROPWIN *PPROPWIN;
typedef UNALIGNED PROPWIN FAR *LPPROPWIN;

#define PIF_WP_SIZE             ((sizeof(WORD)*7) + sizeof(PIFRECT))

#define GROUP_ENV               10          // environment/startup group

#define ENV_DEFAULT             0

#define ENVINIT_DEFAULT         0

#define ENVSIZE_MIN             0
#define ENVSIZE_DEFAULT         0
#define ENVSIZE_MAX             32768

#define ENVDPMI_MIN             0           // in KB
#define ENVDPMI_DEFAULT         0           // in KB (0 = Auto)
#define ENVDPMI_MAX             0xFFFF      // in KB

typedef struct PROPENV {                    /* env */
    WORD    flEnv;                          // see ENV_ flags
    WORD    flEnvInit;                      // see ENVINIT_ flags
    CHAR    achBatchFile[PIFDEFFILESIZE];   //
    WORD    cbEnvironment;                  // ([386Enh]:CommandEnvSize)
    WORD    wMaxDPMI;                       // (NEW)
} PROPENV;
typedef UNALIGNED PROPENV *PPROPENV;
typedef UNALIGNED PROPENV FAR *LPPROPENV;

#ifdef WINNT

#define GROUP_NT31              11
#ifndef UNICODE
#define MAX_VALID_GROUP         GROUP_NT31
#endif

typedef struct PROPNT31 {
   DWORD dwWNTFlags;                                                        /* ;Internal */
   DWORD dwRes1;                                                            /* ;Internal */
   DWORD dwRes2;                                                            /* ;Internal */
   char  achConfigFile[PIFDEFPATHSIZE];                                     /* ;Internal */
   char  achAutoexecFile[PIFDEFPATHSIZE];                                   /* ;Internal */
} PROPNT31;
typedef UNALIGNED PROPNT31 *PPROPNT31;
typedef UNALIGNED PROPNT31 FAR *LPPROPNT31;
#define COMPAT_TIMERTIC 0x10                                                /* ;Internal */
#define NT31_COMPATTIMER COMPAT_TIMERTIC                                    /* ;Internal */
#endif

#ifdef UNICODE
#ifdef GROUP_NT31
#define GROUP_NT40              12
#else
#define GROUP_NT40              11
#endif
#define MAX_VALID_GROUP         GROUP_NT40


#define WNT_LET_SYS_POS         0x0001
#define WNT_CONSOLE_PROPS       0x0002

typedef struct PROPNT40 {                                   /* wnt */
   DWORD    flWnt;                                          // NT Specific PIF falgs

// UNICODE version of strings, and copy of ANSI to see if they've changed

   WCHAR    awchCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];   // Command line
   CHAR     achSaveCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];// Saved ANSI Command Line

   WCHAR    awchOtherFile[PIFDEFFILESIZE];                  // name of "other" file in directory
   CHAR     achSaveOtherFile[PIFDEFFILESIZE];               // Saved ANSI "other" file in directory

   WCHAR    awchPIFFile[PIFDEFFILESIZE];                    // name of PIF file
   CHAR     achSavePIFFile[PIFDEFFILESIZE];                 // Saved ANSI name of PIF file

   WCHAR    awchTitle[PIFNAMESIZE];                         // Title for cmd window
   CHAR     achSaveTitle[PIFNAMESIZE];                      // Saved ANSI Title for cmd window

   WCHAR    awchIconFile[PIFDEFFILESIZE];                   // Name of file containing icons
   CHAR     achSaveIconFile[PIFDEFFILESIZE];                // Saved ANSI Name of file containing icons

   WCHAR    awchWorkDir[PIFDEFPATHSIZE];                    // working directory
   CHAR     achSaveWorkDir[PIFDEFPATHSIZE];                 // Saved ANSI working directory

   WCHAR    awchBatchFile[PIFDEFFILESIZE];                  // batch file
   CHAR     achSaveBatchFile[PIFDEFFILESIZE];               // Saved ANSI batch file

// Console properties

   DWORD    dwForeColor;                                    // Console Text Foreground Color
   DWORD    dwBackColor;                                    // Console Text Background Color
   DWORD    dwPopupForeColor;                               // Console Popup Text Foreground Color
   DWORD    dwPopupBackColor;                               // Console Popup Text Background Color
   COORD    WinSize;                                        // Console Window Size
   COORD    BuffSize;                                       // Console Buffer Size
   POINT    WinPos;                                         // Console Window Position
   DWORD    dwCursorSize;                                   // Console Cursor Size
   DWORD    dwCmdHistBufSize;                               // Console Command Histroy Buffer Size
   DWORD    dwNumCmdHist;                                   // Number of Command Histories for Console

} PROPNT40;
typedef UNALIGNED PROPNT40 *PPROPNT40;
typedef UNALIGNED PROPNT40 FAR *LPPROPNT40;

#else

#ifndef WINNT
#define MAX_VALID_GROUP         GROUP_ENV
#endif

#endif // UNICODE

#define GROUP_ICON              (MAX_VALID_GROUP+1)
#define GROUP_MAX               0x0FF

                                                                                // ;Internal
                                                                                // ;Internal
/*                                                                              // ;Internal
 * Additional group ordinal bits that can be passed to VxD property hooks       // ;Internal
 */                                                                             // ;Internal
#define EXT_GROUP_QUERY         0x100                                           // ;Internal
#define EXT_GROUP_UPDATE        0x200                                           // ;Internal
                                                                                // ;Internal
                                                                                // ;Internal
/*
 *  PIF "file" structures, used by .PIFs
 */

#define PIFEXTSIGSIZE   16                  // Length of extension signatures
#define MAX_GROUP_NAME  PIFEXTSIGSIZE       //
#define STDHDRSIG       "MICROSOFT PIFEX"   // extsig value for stdpifext
#define LASTHDRPTR      0xFFFF              // This value in the
                                            //  extnxthdrfloff field indicates
                                            //   there are no more extensions.
#define W286HDRSIG30     "WINDOWS 286 3.0"
#define W386HDRSIG30     "WINDOWS 386 3.0"
#define WNTHDRSIG31      "WINDOWS NT  3.1"
#define WENHHDRSIG40     "WINDOWS VMM 4.0"  //
#define WNTHDRSIG40      "WINDOWS NT  4.0"

#define CONFIGHDRSIG40   "CONFIG  SYS 4.0"  //
#define AUTOEXECHDRSIG40 "AUTOEXECBAT 4.0"  //

#define MAX_CONFIG_SIZE     4096
#define MAX_AUTOEXEC_SIZE   4096

#define CONFIGFILE      TEXT("\\CONFIG.SYS")      // normal filenames
#define AUTOEXECFILE    TEXT("\\AUTOEXEC.BAT")

#define MCONFIGFILE     TEXT("\\CONFIG.APP")      // msdos-mode temp filenames
#define MAUTOEXECFILE   TEXT("\\AUTOEXEC.APP")

#define WCONFIGFILE     TEXT("\\CONFIG.WOS")      // windows-mode temp filenames
#define WAUTOEXECFILE   TEXT("\\AUTOEXEC.WOS")


typedef struct PIFEXTHDR {                  /* peh */
    CHAR    extsig[PIFEXTSIGSIZE];
    WORD    extnxthdrfloff;
    WORD    extfileoffset;
    WORD    extsizebytes;
} PIFEXTHDR;
typedef UNALIGNED PIFEXTHDR *PPIFEXTHDR;
typedef UNALIGNED PIFEXTHDR FAR *LPPIFEXTHDR;


/* Flags for MSflags
 */

#define fResident       0x01    // Directly Modifies: Memory
#define fGraphics       0x02    // Screen Exchange: Graphics/Text
#define fNoSwitch       0x04    // Program Switch: Prevent
#define fNoGrab         0x08    // Screen Exchange: None
#define fDestroy        0x10    // Close Window on exit
#define fCOM2           0x40    // Directly Modifies: COM2
#define fCOM1           0x80    // Directly Modifies: COM1

#define MEMMASK         fResident
#define GRAPHMASK       fGraphics
#define TEXTMASK        ((BYTE)(~GRAPHMASK))
#define PSMASK          fNoSwitch
#define SGMASK          fNoGrab
#define EXITMASK        fDestroy
#define COM2MASK        fCOM2
#define COM1MASK        fCOM1

/* Flags for behavior
 */
#define fScreen         0x80    // Directly Modifies: Screen
#define fForeground     0x40    // Set same as fScreen (alias)
#define f8087           0x20    // No PIFEDIT control
#define fKeyboard       0x10    // Directly Modifies: Keyboard

#define SCRMASK         (fScreen + fForeground)
#define MASK8087        f8087
#define KEYMASK         fKeyboard

/* Flags for sysflags
 */

#define SWAPMASK        0x20
#define PARMMASK        0x40

/*
 * All strings in the STDPIF are in the OEM character set.
 */
typedef struct STDPIF {                     /* std */ //Examples
    BYTE    unknown;                        // 0x00     0x00
    BYTE    id;                             // 0x01     0x78
    CHAR    appname[PIFNAMESIZE];           // 0x02     'MS-DOS Prompt'
    WORD    maxmem;                         // 0x20     0x0200 (512Kb)
    WORD    minmem;                         // 0x22     0x0080 (128Kb)
    CHAR    startfile[PIFSTARTLOCSIZE];     // 0x24     "COMMAND.COM"
    BYTE    MSflags;                        // 0x63     0x10
    BYTE    reserved;                       // 0x64     0x00
    CHAR    defpath[PIFDEFPATHSIZE];        // 0x65     "\"
    CHAR    params[PIFPARAMSSIZE];          // 0xA5     ""
    BYTE    screen;                         // 0xE5     0x00
    BYTE    cPages;                         // 0xE6     0x01 (ALWAYS!)
    BYTE    lowVector;                      // 0xE7     0x00 (ALWAYS!)
    BYTE    highVector;                     // 0xE8     0xFF (ALWAYS!)
    BYTE    rows;                           // 0xE9     0x19 (Not used)
    BYTE    cols;                           // 0xEA     0x50 (Not used)
    BYTE    rowoff;                         // 0xEB     0x00 (Not used)
    BYTE    coloff;                         // 0xEC     0x00 (Not used)
    WORD    sysmem;                         // 0xED   0x0007 (Not used; 7=>Text, 23=>Grfx/Mult Text)
    CHAR    shprog[PIFSHPROGSIZE];          // 0xEF     0's  (Not used)
    CHAR    shdata[PIFSHDATASIZE];          // 0x12F    0's  (Not used)
    BYTE    behavior;                       // 0x16F    0x00
    BYTE    sysflags;                       // 0x170    0x00 (Not used)
} STDPIF;
typedef UNALIGNED STDPIF *PSTDPIF;
typedef UNALIGNED STDPIF FAR *LPSTDPIF;


/* Flags for PfW286Flags
 */

#define fALTTABdis286   0x0001
#define fALTESCdis286   0x0002
#define fALTPRTSCdis286 0x0004
#define fPRTSCdis286    0x0008
#define fCTRLESCdis286  0x0010
#define fNoSaveVid286   0x0020              // New for 3.10
#define fCOM3_286       0x4000
#define fCOM4_286       0x8000

typedef struct W286PIF30 {                  /* 286 */ //Examples
    WORD    PfMaxXmsK;                      // 0x19D    0x0000
    WORD    PfMinXmsK;                      // 0x19F    0x0000
    WORD    PfW286Flags;                    // 0x1A1    0x0000
} W286PIF30;
typedef UNALIGNED W286PIF30 *PW286PIF30;
typedef UNALIGNED W286PIF30 FAR *LPW286PIF30;


/* Flags for PfW386Flags
 */

#define fEnableClose    0x00000001          //
#define fEnableCloseBit             0       //
#define fBackground     0x00000002          //
#define fBackgroundBit              1       //
#define fExclusive      0x00000004          //                          /* ;Internal */
#define fExclusiveBit               2       //                          /* ;Internal */
#define fFullScreen     0x00000008          //
#define fFullScreenBit              3       //
#define fALTTABdis      0x00000020          //
#define fALTTABdisBit               5       //
#define fALTESCdis      0x00000040          //
#define fALTESCdisBit               6       //
#define fALTSPACEdis    0x00000080          //
#define fALTSPACEdisBit             7       //
#define fALTENTERdis    0x00000100          //
#define fALTENTERdisBit             8       //
#define fALTPRTSCdis    0x00000200          //
#define fALTPRTSCdisBit             9       //
#define fPRTSCdis       0x00000400          //
#define fPRTSCdisBit                10      //
#define fCTRLESCdis     0x00000800          //
#define fCTRLESCdisBit              11      //
#define fPollingDetect  0x00001000          //
#define fPollingDetectBit           12      //
#define fNoHMA          0x00002000          //
#define fNoHMABit                   13      //
#define fHasHotKey      0x00004000          //
#define fHasHotKeyBit               14      //
#define fEMSLocked      0x00008000          //
#define fEMSLockedBit               15      //
#define fXMSLocked      0x00010000          //
#define fXMSLockedBit               16      //
#define fINT16Paste     0x00020000          //
#define fINT16PasteBit              17      //
#define fVMLocked       0x00040000          //
#define fVMLockedBit                18      //
#define fGlobalProtect  0x00080000          //  New for 4.00
#define fGlobalProtectBit           19      //  New for 4.00
#define fMinimized      0x00100000          //  New for 4.00
#define fMinimizedBit               20      //  New for 4.00
#define fMaximized      0x00200000          //  New for 4.00
#define fMaximizedBit               21      //  New for 4.00
//                      0x00400000          //  Not used                /* ;Internal */
//                                  22      //  Not used                /* ;Internal */
#define fRealMode       0x00800000          //  New for 4.00
#define fRealModeBit                23      //  New for 4.00
#define fWinLie         0x01000000          //  New for 4.00
#define fWinLieBit                  24      //  New for 4.00
#define fStrayPtrDetect 0x02000000          //  New for 4.00            /* ;Internal */
#define fStrayPtrDetectBit          25      //  New for 4.00            /* ;Internal */
#define fNoSuggestMSDOS 0x04000000          //  New for 4.00
#define fNoSuggestMSDOSBit          26      //  New for 4.00
#define fLocalUMBs      0x08000000          //  New for 4.00            /* ;Internal */
#define fLocalUMBsBit               27      //  New for 4.00            /* ;Internal */
#define fRealModeSilent 0x10000000          //  New for 4.00
#define fRealModeSilentBit          28      //  New for 4.00
#define fQuickStart     0x20000000          //  New for 4.00            /* ;Internal */
#define fQuickStartBit              29      //  New for 4.00            /* ;Internal */
#define fAmbiguousPIF   0x40000000          //  New for 4.00
#define fAmbiguousPIFBit            30      //  New for 4.00

/* Flags for PfW386Flags2
 *
 *  NOTE THAT THE LOW 16 BITS OF THIS DWORD ARE VDD RELATED
 *  NOTE THAT ALL OF THE LOW 16 BITS ARE RESERVED FOR VIDEO BITS
 *
 *  You cannot monkey with these bits locations without breaking
 *  all VDDs as well as all old PIFs. SO DON'T MESS WITH THEM.
 */

#define fVDDMask        0x0000FFFF          //
#define fVDDMinBit                  0       //
#define fVDDMaxBit                  15      //

#define fVidTxtEmulate  0x00000001          //
#define fVidTxtEmulateBit           0       //
#define fVidNoTrpTxt    0x00000002          // Obsolete
#define fVidNoTrpTxtBit             1       // Obsolete
#define fVidNoTrpLRGrfx 0x00000004          // Obsolete
#define fVidNoTrpLRGrfxBit          2       // Obsolete
#define fVidNoTrpHRGrfx 0x00000008          // Obsolete
#define fVidNoTrpHRGrfxBit          3       // Obsolete
#define fVidTextMd      0x00000010          // Obsolete
#define fVidTextMdBit               4       // Obsolete
#define fVidLowRsGrfxMd 0x00000020          // Obsolete
#define fVidLowRsGrfxMdBit          5       // Obsolete
#define fVidHghRsGrfxMd 0x00000040          // Obsolete
#define fVidHghRsGrfxMdBit          6       // Obsolete
#define fVidRetainAllo  0x00000080          //
#define fVidRetainAlloBit           7       //

/*                                                                             ;Internal
 * This mask is used to isolate status bits shared with VM_Descriptor          ;Internal
 */                                                                         /* ;Internal */
                                                                            /* ;Internal */
#define PifDescMask                                                         /* ;Internal */ \
(fALTTABdis   + fALTESCdis    + fALTSPACEdis +                              /* ;Internal */ \
 fALTENTERdis + fALTPRTSCdis  + fPRTSCdis +                                 /* ;Internal */ \
 fCTRLESCdis  + fPollingDetect+ fNoHMA +                                    /* ;Internal */ \
 fHasHotKey   + fEMSLocked    + fXMSLocked +                                /* ;Internal */ \
 fINT16Paste  + fVMLocked)                                                  /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */
typedef struct W386PIF30 {                  /* 386 */ //Examples
    // These new maxmem/minmem fields allow values
    // that will not conflict with the 286-specific values
    WORD    PfW386maxmem;                   // 0x1B9    0xFFFF (-1)
    WORD    PfW386minmem;                   // 0x1BB    0xFFFF (-1)
    WORD    PfFPriority;                    // 0x1BD    0x0064 (100)
    WORD    PfBPriority;                    // 0x1BF    0x0032 (50)
    WORD    PfMaxEMMK;                      // 0x1C1    0x0000 (0)
    WORD    PfMinEMMK;                      // 0x1C3    0x0000 (0)
    WORD    PfMaxXmsK;                      // 0x1C5    0x0800 (2048)
    WORD    PfMinXmsK;                      // 0x1C7    0x0000 (0)
    DWORD   PfW386Flags;                    // 0x1C9    0x00021003
    DWORD   PfW386Flags2;                   // 0x1CD    0x0000001F
    WORD    PfHotKeyScan;                   // 0x1D1    Scan code in lower byte
    WORD    PfHotKeyShVal;                  // 0x1D3    Shift state
    WORD    PfHotKeyShMsk;                  // 0x1D5    Mask for shift states interested in
    BYTE    PfHotKeyVal;                    // 0x1D7    Enhanced flags
    BYTE    PfHotKeyPad[9];                 // 0x1D8    Pad Hot key section to 16 bytes
    CHAR    PfW386params[PIFPARAMSSIZE];    // 0x1E1
} W386PIF30;
typedef UNALIGNED W386PIF30 *PW386PIF30;
typedef UNALIGNED W386PIF30 FAR *LPW386PIF30;


typedef struct WENHPIF40 {                  /* enh */                       /* ;Internal */
    DWORD   dwEnhModeFlagsProp;             // PROPPRG data (subset)        /* ;Internal */
    DWORD   dwRealModeFlagsProp;            // PROPPRG data (subset)        /* ;Internal */
    CHAR    achOtherFileProp[PIFDEFFILESIZE];//PROPPRG data (subset)        /* ;Internal */
    CHAR    achIconFileProp[PIFDEFFILESIZE];// PROPPRG data (subset)        /* ;Internal */
    WORD    wIconIndexProp;                 // PROPPRG data (subset)        /* ;Internal */
    PROPTSK tskProp;                        // PROPTSK data                 /* ;Internal */
    PROPVID vidProp;                        // PROPVID data                 /* ;Internal */
    PROPKBD kbdProp;                        // PROPKBD data                 /* ;Internal */
    PROPMSE mseProp;                        // PROPMSE data                 /* ;Internal */
    PROPSND sndProp;                        // PROPSND data                 /* ;Internal */
    PROPFNT fntProp;                        // PROPFNT data                 /* ;Internal */
    PROPWIN winProp;                        // PROPWIN data                 /* ;Internal */
    PROPENV envProp;                        // PROPENV data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WENHPIF40 version   /* ;Internal */
} WENHPIF40;                                                                /* ;Internal */
typedef UNALIGNED WENHPIF40 *PWENHPIF40;                                    /* ;Internal */
typedef UNALIGNED WENHPIF40 FAR *LPWENHPIF40;                               /* ;Internal */

#ifdef WINNT
/* Windows NT extension format */
typedef struct WNTPIF31 {                                                   /* ;Internal */
   PROPNT31 nt31Prop;                                                       /* ;Internal */
   WORD     wInternalRevision;                                              /* ;Internal */
} WNTPIF31;                                                                 /* ;Internal */
typedef UNALIGNED WNTPIF31 *PWNTPIF31;                                      /* ;Internal */
typedef UNALIGNED WNTPIF31 FAR *LPWNTPIF31;                                 /* ;Internal */
#endif
                                                                            /* ;Internal */
#ifdef UNICODE
typedef struct WNTPIF40 {                   /* adv */                       /* ;Internal */
    PROPNT40 nt40Prop;                      // PROPWNT data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WNTPIF40 version    /* ;Internal */
} WNTPIF40;                                                                 /* ;Internal */
typedef UNALIGNED WNTPIF40 *PWNTPIF40;                                      /* ;Internal */
typedef UNALIGNED WNTPIF40 FAR *LPWNTPIF40;                                 /* ;Internal */
#endif
                                                                            /* ;Internal */
//                                                                          /* ;Internal */
// Whenever a previously reserved field or bit becomes used, increment      /* ;Internal */
// the internal revision so that we know to zero them out when we see a     /* ;Internal */
// down-level PIF file.                                                     /* ;Internal */
//                                                                          /* ;Internal */
#define WENHPIF40_VERSION       1           // Current internal version     /* ;Internal */
#define WNTPIF40_VERSION        1           // Current internal version     /* ;Internal */
#define WNTPIF31_VERSION        1           // Current internal version     /* ;Internal */

                                                                            /* ;Internal */
typedef struct PIFDATA {                    /* pd */  //Examples            /* ;Internal */
                                                                            /* ;Internal */
    STDPIF      stdpifdata;                 // 0x000                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   stdpifext;                  // 0x171                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x171    "MICROSOFT PIFEX"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x181    0x0187 (or 0xFFFF)  /* ;Internal */
//      WORD    extfileoffset;              // 0x183    0x0000              /* ;Internal */
//      WORD    extsizebytes;               // 0x185    0x0171              /* ;Internal */
//  };                                                                      /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   w286hdr30;                  // 0x187                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x187    "WINDOWS 286 3.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x197    0x01A3 (or 0xFFFF)  /* ;Internal */
//      WORD    extfileoffset;              // 0x199    0x019D              /* ;Internal */
//      WORD    extsizebytes;               // 0x19B    0x0006              /* ;Internal */
//  };                                                                      /* ;Internal */
    W286PIF30   w286ext30;                  // 0x19D                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   w386hdr30;                  // 0x1A3                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x1A3    "WINDOWS 386 3.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x1B3    0xFFFF (ENH=0x221)  /* ;Internal */
//      WORD    extfileoffset;              // 0x1B5    0x01B9              /* ;Internal */
//      WORD    extsizebytes;               // 0x1B7    0x0068              /* ;Internal */
//  };                                                                      /* ;Internal */
    W386PIF30   w386ext30;                  // 0x1B9                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   wenhhdr40;                  // 0x221                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x221    "WINDOWS VMM 4.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x231    0x????              /* ;Internal */
//      WORD    extfileoffset;              // 0x233    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x235    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WENHPIF40   wenhext40;                  // 0x237                        /* ;Internal */

#ifdef WINNT
    PIFEXTHDR   wnthdr31;                   // 0x000                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x000    "WINDOWS NT  3.1"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x000    0xFFFF              /* ;Internal */
//      WORD    extfileoffset;              // 0x000    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x000    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WNTPIF31    wntpif31;                   // 0x000                        /* ;Internal */
#endif


#ifdef UNICODE
    PIFEXTHDR   wnthdr40;                   // 0x000                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x000    "WINDOWS NT  4.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x000    0xFFFF              /* ;Internal */
//      WORD    extfileoffset;              // 0x000    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x000    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WNTPIF40    wntpif40;                   // 0x000                        /* ;Internal */
#endif
                                                                            /* ;Internal */
} PIFDATA;                                  // 0x221 if Windows 3.x PIF     /* ;Internal */
typedef UNALIGNED PIFDATA *PPIFDATA;                                        /* ;Internal */
typedef UNALIGNED PIFDATA FAR *LPPIFDATA;                                   /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */                                                                            /* ;Internal */
/* AssociateProperties associations
 */

#define HVM_ASSOCIATION         1
#define HWND_ASSOCIATION        2
#define LPARGS_ASSOCIATION      3                                           /* ;Internal */


/* SHEETTYPEs for AddPropertySheet/EnumPropertySheets
 */

#define SHEETTYPE_SIMPLE    0
#define SHEETTYPE_ADVANCED  1


/*  External function ordinals and prototypes
 */

#define ORD_OPENPROPERTIES      2
#define ORD_GETPROPERTIES       3
#define ORD_SETPROPERTIES       4
#define ORD_EDITPROPERTIES      5
#define ORD_FLUSHPROPERTIES     6
#define ORD_ENUMPROPERTIES      7
#define ORD_ASSOCIATEPROPERTIES 8
#define ORD_CLOSEPROPERTIES     9
#define ORD_LOADPROPERTYLIB     10
#define ORD_ENUMPROPERTYLIBS    11
#define ORD_FREEPROPERTYLIB     12
#define ORD_ADDPROPERTYSHEET    13
#define ORD_REMOVEPROPERTYSHEET 14
#define ORD_LOADPROPERTYSHEETS  15
#define ORD_ENUMPROPERTYSHEETS  16
#define ORD_FREEPROPERTYSHEETS  17
#define ORD_CREATESTARTUPPROPERTIES 20
#define ORD_DELETESTARTUPPROPERTIES 21

typedef UINT PIFWIZERR;

#define PIFWIZERR_SUCCESS           0
#define PIFWIZERR_GENERALFAILURE    1
#define PIFWIZERR_INVALIDPARAM      2
#define PIFWIZERR_UNSUPPORTEDOPT    3
#define PIFWIZERR_OUTOFMEM          4
#define PIFWIZERR_USERCANCELED      5

#define WIZACTION_UICONFIGPROP      0
#define WIZACTION_SILENTCONFIGPROP  1
#define WIZACTION_CREATEDEFCLEANCFG 2

/* XLATOFF */

#ifdef WINAPI
PIFWIZERR WINAPI AppWizard(HWND hwnd, HANDLE hProps, UINT action);

int  WINAPI OpenProperties(LPCTSTR lpszApp, LPCTSTR lpszPIF, UINT hInf, UINT flOpt);
int  WINAPI GetProperties(HANDLE hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, UINT flOpt);
int  WINAPI SetProperties(HANDLE hProps, LPCSTR lpszGroup, const VOID FAR *lpProps, int cbProps, UINT flOpt);
int  WINAPI EditProperties(HANDLE hProps, LPCTSTR lpszTitle, UINT uStartPage, HWND hwnd, UINT uMsgPost);
int  WINAPI FlushProperties(HANDLE hProps, UINT flOpt);
HANDLE  WINAPI EnumProperties(HANDLE hProps);
LONG_PTR WINAPI AssociateProperties(HANDLE hProps, int iAssociate, LONG_PTR lData);
int  WINAPI CloseProperties(HANDLE hProps, UINT flOpt);
int  WINAPI CreateStartupProperties(HANDLE hProps, UINT flOpt);
int  WINAPI DeleteStartupProperties(HANDLE hProps, UINT flOpt);
BOOL WINAPI PifPropGetPages(LPVOID lpv, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);


#ifdef  PIF_PROPERTY_SHEETS
HANDLE  WINAPI LoadPropertyLib(LPCTSTR lpszDLL, int fLoad);
HANDLE  WINAPI EnumPropertyLibs(HANDLE iLib, LPHANDLE lphDLL, LPSTR lpszDLL, int cbszDLL);
BOOL WINAPI FreePropertyLib(HANDLE hLib);
HANDLE  WINAPI AddPropertySheet(const PROPSHEETPAGE FAR *lppsi, int iType);
BOOL WINAPI RemovePropertySheet(HANDLE hSheet);
int  WINAPI LoadPropertySheets(HANDLE hProps, int flags);
INT_PTR  WINAPI EnumPropertySheets(HANDLE hProps, int iType, INT_PTR iSheet, LPPROPSHEETPAGE lppsi);
HANDLE  WINAPI FreePropertySheets(HANDLE hProps, int flags);
#endif  /* PIF_PROPERTY_SHEETS */

#endif  /* WINAPI */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

/* XLATON */

#endif // _INC_PIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, LPCSTR pszUsername, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

// A way to check if ratings are installed. We still need to calling
// ratings dll to find out for sure but this allows us to delay load ratings.
_inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, &szSup, &cbSize) == ERROR_SUCCESS);
}

#define S_RATING_ALLOW		S_OK
#define S_RATING_DENY		S_FALSE
#define S_RATING_FOUND		0x00000002
#define E_RATING_NOT_FOUND	0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(ObtainRating) (THIS_ LPCSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

	STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE		0x80000000
#define RATING_ORDER_LOCALLIST		0xC0000000


#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\shfusion.h ===
#ifndef SHFUSION_H
#define SHFUSION_H

#include <winbase.h>

#ifdef __cplusplus
extern "C" {
#endif

extern HANDLE g_hActCtx;       // Global app context for this DLL.

#define SHFUSION_DEFAULT_RESOURCE_ID    ( 123 )
#define SHFUSION_CPL_RESOURCE_ID        ( 124 )

// These are only needed for the callers, not the implementation
// define SHFUSION_NO_API_REDEFINE to prevent this API redefinition
#if !defined(SHFUSION_IMPL) && !defined(SHFUSION_NO_API_REDEFINE)

// The following require app contexts
//#undef LoadLibrary
#undef CreateWindow
#undef CreateWindowEx
#undef CreateDialogParam
#undef CreateDialogIndirectParam
#undef DialogBoxParam
#undef DialogBoxIndirectParam
//#undef GetClassInfo
//#undef GetClassInfoEx


//#define LoadLibrary                  SHFusionLoadLibrary
#define CreateWindow                   SHFusionCreateWindow
#define CreateWindowEx                 SHFusionCreateWindowEx
#define CreateDialogParam              SHFusionCreateDialogParam
#define CreateDialogIndirectParam      SHFusionCreateDialogIndirectParam
#define DialogBoxParam                 SHFusionDialogBoxParam
#define DialogBoxIndirectParam         SHFusionDialogBoxIndirectParam
//#define GetClassInfo                   SHFusionGetClassInfo
//#define GetClassInfoEx                 SHFusionGetClassInfoEx
#endif

void __stdcall SHGetManifest(PTSTR pszManifest, int cch);
BOOL __stdcall SHFusionInitialize(PTSTR pszPath);
BOOL __stdcall SHFusionInitializeFromModule(HMODULE hMod);
BOOL __stdcall SHFusionInitializeFromModuleID(HMODULE hMod, int id);
void __stdcall SHFusionUninitialize();
BOOL __stdcall SHActivateContext(ULONG_PTR * pdwCookie);
void __stdcall SHDeactivateContext(ULONG_PTR dwCookie);
BOOL __stdcall NT5_ActivateActCtx(HANDLE h, ULONG_PTR * p);
BOOL __stdcall NT5_DeactivateActCtx(ULONG_PTR p);

// This is designed for Callers that know that they are creating a property
// sheet on behalf of another that may be using an old version of common controls
// PROPSHEETPAGE is designed so that it can contain extra information, so we can't
// just wax part of the data structure for fusion use.
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageW (LPCPROPSHEETPAGEW a);
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageA (LPCPROPSHEETPAGEA a);


STDAPI __stdcall SHSquirtManifest(HINSTANCE hInst, UINT uIdManifest, LPTSTR pszPath);

HMODULE __stdcall SHFusionLoadLibrary(LPCTSTR lpLibFileName);

HWND __stdcall SHFusionCreateWindow(
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);

// NOTE: There are times when we don't want to use the manifest for creating a window.
// The #1 case is creating the host for MSHTML. Since MSHTML is a host of ActiveX controls,
// the window manager will keep enabling fusion.
HWND __stdcall SHNoFusionCreateWindowEx(
  DWORD dwExStyle,      // extended window style
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);


HWND __stdcall SHFusionCreateWindowEx(
  DWORD dwExStyle,      // extended window style
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);

HWND __stdcall SHFusionCreateDialogIndirect(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc        // dialog box procedure
);

HWND __stdcall SHFusionCreateDialogParam(
  HINSTANCE hInstance,     // handle to module
  LPCTSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
);

HWND __stdcall SHFusionCreateDialogIndirectParam(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
);

HWND __stdcall SHNoFusionCreateDialogIndirectParam(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
);

INT_PTR __stdcall SHFusionDialogBoxIndirectParam(
  HINSTANCE hInstance,             // handle to module
  LPCDLGTEMPLATE hDialogTemplate,  // dialog box template
  HWND hWndParent,                 // handle to owner window
  DLGPROC lpDialogFunc,            // dialog box procedure
  LPARAM dwInitParam               // initialization value
);

INT_PTR __stdcall SHFusionDialogBoxParam(
  HINSTANCE hInstance,     // handle to module
  LPCTSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
);


ATOM __stdcall SHFusionRegisterClass(
  CONST WNDCLASS *lpWndClass  // class data
);

ATOM __stdcall SHFusionRegisterClassEx(
  CONST WNDCLASSEX *lpwcx  // class data
);

BOOL __stdcall SHFusionGetClassInfo(
  HINSTANCE hInstance,    // handle to application instance
  LPCTSTR lpClassName,    // class name
  LPWNDCLASS lpWndClass   // class data
);

BOOL __stdcall SHFusionGetClassInfoEx(
  HINSTANCE hinst,    // handle to application instance
  LPCTSTR lpszClass,  // class name
  LPWNDCLASSEX lpwcx  // class data
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\msprintx.h ===
//////////////////////////////////////////////////////////////////////////
//
// This is the public header file for apps that call MSPRINT.DLL
//
//////////////////////////////////////////////////////////////////////////

#ifdef _WIN32

// Typedef for the following function:
//
// BOOL WINAPI PrinterSetup32(HWND hWnd,WORD wAction,WORD wBufSize,
//                            LPBYTE lpBuffer,LPWORD lpwRequired);

typedef BOOL (WINAPI* PRINTERSETUPPROC32)(HWND,WORD,WORD,LPBYTE,LPWORD);

#define MSPRINT2_PRINTERSETUP32  ("PrinterSetup32")

#endif

#define MSP_NEWPRINTER             1
#define MSP_NETPRINTER             2
#define MSP_NEWDRIVER              3
#define MSP_NETADMIN               4
#define MSP_TESTPAGEFULLPROMPT     5
#define MSP_TESTPAGEPARTIALPROMPT  6
#define MSP_TESTPAGENOPROMPT       7
#define MSP_REMOVEPRINTER          8
#define MSP_SPOOLERFOUNDPRINTER    9
#define MSP_REMOVENETPRINTER       10
#define MSP_NEWPRINTER_MODELESS    11
#define MSP_FINDPRINTER            12

#if 0

#define MSPRINT_TESTONLY

#define MSP_BATCHPRINTERS        100

#define PBD_INSTALLED             1L

typedef struct tagONEPRINTERBATCHDATA
{
    char  szFriendlyName[32];
    char  szModelName[32];
    char  szPort[60];
    DWORD dwFlags;
} ONEPRINTERBATCHDATA, FAR * LPONEPRINTERBATCHDATA;

typedef struct tagPRINTERBATCHDATA
{
    char                szFileSource[60];
    DWORD               dwCount;
    ONEPRINTERBATCHDATA Printers[1];
} PRINTERBATCHDATA, FAR * LPPRINTERBATCHDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\schemadef.h ===
//-----------------------------------------------------------------
//   SchemaDef.h - defines needed to build a Theme Manager schema
//                file
//-----------------------------------------------------------------
#ifndef SCHEMA_STRINGS           // FIRST PASS of this hdr file
//-----------------------------------------------------------------
#ifndef SCHEMADEF_H
#define SCHEMADEF_H
//-----------------------------------------------------------------
#define SCHEMADEF_VERSION   1    // defines the exported func(s) implemented
//-----------------------------------------------------------------
struct TMPROPINFO
{
    LPCWSTR pszName;
    SHORT sEnumVal;
    BYTE bPrimVal;
};
//-----------------------------------------------------------------
struct TMSCHEMAINFO
{
    DWORD dwSize;               // size of this struct
    int iSchemaDefVersion;      // version number from this file
    int iThemeMgrVersion;       // version number from "thschema.h"
    int iPropCount;             // # of entries in prop table
    const struct TMPROPINFO *pPropTable;       // ptr to prop table 
};
//---------------------------------------------------------------------------
#define BEGIN_TM_SCHEMA(name)               
#define BEGIN_TM_PROPS()                    enum PropValues { DummyProp = 49,
#define BEGIN_TM_ENUM(name)                 enum name {
#define BEGIN_TM_CLASS_PARTS(name)          enum name##PARTS { name##PartFiller0,
#define BEGIN_TM_PART_STATES(name)          enum name##STATES { name##StateFiller0,

#define TM_PROP(val, prefix, name, primval) prefix##_##name = val, 
#define TM_ENUM(val, prefix, name)          prefix##_##name = val,
#define TM_PART(val, prefix, name)          prefix##_##name = val, 
#define TM_STATE(val, prefix, name)         prefix##_##name = val, 

#define END_TM_CLASS_PARTS()                };
#define END_TM_PART_STATES()                };
#define END_TM_PROPS()                      };
#define END_TM_ENUM()                       };
#define END_TM_SCHEMA(name)
//---------------------------------------------------------------------------
#endif      // SCHEMADEF_H
//---------------------------------------------------------------------------
#else                   // SECOND PASS of this hdr file
//---------------------------------------------------------------------------
#undef BEGIN_TM_SCHEMA
#undef BEGIN_TM_PROPS
#undef BEGIN_TM_ENUM
#undef BEGIN_TM_CLASS_PARTS
#undef BEGIN_TM_PART_STATES
#undef TM_PROP
#undef TM_PART
#undef TM_STATE
#undef TM_ENUM
#undef END_TM_CLASS_PARTS
#undef END_TM_PART_STATES
#undef END_TM_PROPS
#undef END_TM_ENUM
#undef END_TM_SCHEMA
//---------------------------------------------------------------------------
#define BEGIN_TM_SCHEMA(name)              static const TMPROPINFO name[] = {
#define BEGIN_TM_PROPS()   
#define BEGIN_TM_ENUM(name)                 {L#name, TMT_ENUMDEF, TMT_ENUMDEF},
#define BEGIN_TM_CLASS_PARTS(name)          {L#name L"PARTS", TMT_ENUMDEF, TMT_ENUMDEF},
#define BEGIN_TM_PART_STATES(name)          {L#name L"STATES", TMT_ENUMDEF, TMT_ENUMDEF},

#define TM_PROP(val, prefix, name, primval) {L#name, prefix##_##name, TMT_##primval},
#define TM_PART(val, prefix, name)          {L#name, prefix##_##name, TMT_ENUMVAL},
#define TM_STATE(val, prefix, name)         {L#name, prefix##_##name, TMT_ENUMVAL},
#define TM_ENUM(val, prefix, name)          {L#name, prefix##_##name, TMT_ENUMVAL},

#define END_TM_CLASS_PARTS() 
#define END_TM_PART_STATES() 
#define END_TM_PROPS() 
#define END_TM_ENUM()
#define END_TM_SCHEMA(name)                };  \
    static const TMSCHEMAINFO *GetSchemaInfo() \
    {  \
        static TMSCHEMAINFO si = {sizeof(si)};  \
        si.iSchemaDefVersion = SCHEMADEF_VERSION; \
        si.iThemeMgrVersion = THEMEMGR_VERSION; \
        si.iPropCount = sizeof(name)/sizeof(name[0]); \
        si.pPropTable = name; \
        \
        return &si; \
    }

//-----------------------------------------------------------------
#endif
//-----------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\shdispid.h ===
#ifndef _SHDISPID_H_
#define _SHDISPID_H_

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File: shdispid.h
//
//--------------------------------------------------------------------------

// define the events for the shell folder view
#define DISPID_SELECTIONCHANGED     200     // The Selected Items Changed
#define DISPID_FILELISTENUMDONE     201     // Done enumerating the shell folder
#define DISPID_VERBINVOKED          202     // A verb (either from the main or context menu) was invoked in the folder view
#define DISPID_DEFAULTVERBINVOKED   203     // default verb (either from the main or context menu) was invoked in the folder view
#define DISPID_BEGINDRAG            204     // user clicked on an item
#define DISPID_VIEWMODECHANGED      205     // The ListViewMode Changed
#define DISPID_NOITEMSTATE_CHANGED  206     // We went from 0->some or some->0 items in the view
#define DISPID_CONTENTSCHANGED      207     // contents of the view have changed somehow
#define DISPID_FOCUSCHANGED         208     // The Focused Item Changed

// define the events for the ComboBoxEx control
#define DISPID_ENTERPRESSED         200     // The user hit Enter or Return


// Define Events for search object
#define DISPID_SEARCHCOMMAND_START      1
#define DISPID_SEARCHCOMMAND_COMPLETE   2
#define DISPID_SEARCHCOMMAND_ABORT      3
#define DISPID_SEARCHCOMMAND_UPDATE     4
#define DISPID_SEARCHCOMMAND_PROGRESSTEXT 5
#define DISPID_SEARCHCOMMAND_ERROR      6
#define DISPID_SEARCHCOMMAND_RESTORE    7


// Shell Add/Remove Programs events
#define DISPID_IADCCTL_DIRTY            0x100
#define DISPID_IADCCTL_PUBCAT           0x101
#define DISPID_IADCCTL_SORT             0x102
#define DISPID_IADCCTL_FORCEX86         0x103
#define DISPID_IADCCTL_SHOWPOSTSETUP    0x104
#define DISPID_IADCCTL_ONDOMAIN         0x105
#define DISPID_IADCCTL_DEFAULTCAT       0x106

#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\shfolder.h ===
// functions to get shell special folders/
// shfolder.dll supports these on all platforms including Win95, Win98, NT4 and IE4 shell

// all CSIDL values referred to here are supported natively by shfolder.dll, that is they
// will work on all platforms.

#ifndef _SHFOLDER_H_
#define _SHFOLDER_H_

#ifndef SHFOLDERAPI
#if defined(_SHFOLDER_)
#define SHFOLDERAPI           STDAPI
#else
#define SHFOLDERAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#endif
#endif

#ifndef CSIDL_PERSONAL
#define CSIDL_PERSONAL                  0x0005      // My Documents
#endif

#ifndef CSIDL_MYMUSIC
#define CSIDL_MYMUSIC                   0x000d        // "My Music" folder
#endif

#ifndef CSIDL_APPDATA
#define CSIDL_APPDATA                   0x001A      // Application Data, new for NT4
#endif

#ifndef CSIDL_LOCAL_APPDATA

#define CSIDL_LOCAL_APPDATA             0x001C      // non roaming, user\Local Settings\Application Data
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023      // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024      // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025      // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026      // C:\Program Files
#define CSIDL_MYPICTURES                0x0027      // My Pictures, new for Win2K
#define CSIDL_PROGRAM_FILES_COMMON      0x002b      // C:\Program Files\Common 
#define CSIDL_COMMON_DOCUMENTS          0x002e      // All Users\Documents
#define CSIDL_RESOURCES                 0x0038      // %windir%\Resources\, For theme and other windows resources.
#define CSIDL_RESOURCES_LOCALIZED       0x0039      // %windir%\Resources\<LangID>, for theme and other windows specific resources.


#define CSIDL_FLAG_CREATE               0x8000      // new for Win2K, or this in to force creation of folder

#define CSIDL_COMMON_ADMINTOOLS         0x002f      // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030      // <user name>\Start Menu\Programs\Administrative Tools

#endif // CSIDL_LOCAL_APPDATA


SHFOLDERAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
SHFOLDERAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);

// protos so callers can GetProcAddress() from shfolder.dll

typedef HRESULT (__stdcall * PFNSHGETFOLDERPATHA)(HWND, int, HANDLE, DWORD, LPSTR);  // "SHGetFolderPathA"
typedef HRESULT (__stdcall * PFNSHGETFOLDERPATHW)(HWND, int, HANDLE, DWORD, LPWSTR); // "SHGetFolderPathW"

#ifdef UNICODE
#define SHGetFolderPath     SHGetFolderPathW
#define PFNSHGETFOLDERPATH  PFNSHGETFOLDERPATHW
#else
#define SHGetFolderPath     SHGetFolderPathA
#define PFNSHGETFOLDERPATH  PFNSHGETFOLDERPATHA
#endif

#endif //  _SHFOLDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\tmschema.h ===
//-----------------------------------------------------------------
//   TmSchema.h - Theme Manager schema (properties, parts, etc)
//-----------------------------------------------------------------
//   Note: this file is normally #include-ed twice a single .cpp 
//         file.  The 2nd time, SCHEME_STRINGS should be defined.  
//         This allows the enums and strings to be kept in a 
//         single logical table and ensure they stay in sync with
//         each other.
//-----------------------------------------------------------------
#if (defined(SCHEMA_STRINGS)) || (! defined(TMSCHEMA_H))
//-----------------------------------------------------------------
#define TMSCHEMA_H
//-----------------------------------------------------------------
#include "SchemaDef.h"
//-----------------------------------------------------------------
#define THEMEMGR_VERSION 1  // increment if order of props changes or 
                            // any props are deleted (will prevent loading
                            // of controlsets that use older version
//-----------------------------------------------------------------
BEGIN_TM_SCHEMA(ThemeMgrSchema)

//-----------------------------------------------------------------
//   TM_ENUM (must also be declared in PROPERTIES section)
//
//    these cannot be renumbered (part of uxtheme API)
//-----------------------------------------------------------------
BEGIN_TM_ENUM(BGTYPE)
    TM_ENUM(0, BT, IMAGEFILE)
    TM_ENUM(1, BT, BORDERFILL)
    TM_ENUM(2, BT, NONE)
END_TM_ENUM()

BEGIN_TM_ENUM(IMAGELAYOUT)
    TM_ENUM(0, IL, VERTICAL)
    TM_ENUM(1, IL, HORIZONTAL)
END_TM_ENUM()

BEGIN_TM_ENUM(BORDERTYPE)
    TM_ENUM(0, BT, RECT)
    TM_ENUM(1, BT, ROUNDRECT)
    TM_ENUM(2, BT, ELLIPSE)
END_TM_ENUM()

BEGIN_TM_ENUM(FILLTYPE)
    TM_ENUM(0, FT, SOLID)
    TM_ENUM(1, FT, VERTGRADIENT)
    TM_ENUM(2, FT, HORZGRADIENT)
    TM_ENUM(3, FT, RADIALGRADIENT)
    TM_ENUM(4, FT, TILEIMAGE)
END_TM_ENUM()

BEGIN_TM_ENUM(SIZINGTYPE)
    TM_ENUM(0, ST, TRUESIZE)
    TM_ENUM(1, ST, STRETCH)
    TM_ENUM(2, ST, TILE)
END_TM_ENUM()

BEGIN_TM_ENUM(HALIGN)
    TM_ENUM(0, HA, LEFT)
    TM_ENUM(1, HA, CENTER)
    TM_ENUM(2, HA, RIGHT)
END_TM_ENUM()

BEGIN_TM_ENUM(CONTENTALIGNMENT)
    TM_ENUM(0, CA, LEFT)
    TM_ENUM(1, CA, CENTER)
    TM_ENUM(2, CA, RIGHT)
END_TM_ENUM()

BEGIN_TM_ENUM(VALIGN)
    TM_ENUM(0, VA, TOP)
    TM_ENUM(1, VA, CENTER)
    TM_ENUM(2, VA, BOTTOM)
END_TM_ENUM()

BEGIN_TM_ENUM(OFFSETTYPE)
    TM_ENUM(0, OT, TOPLEFT)
    TM_ENUM(1, OT, TOPRIGHT)
    TM_ENUM(2, OT, TOPMIDDLE)
    TM_ENUM(3, OT, BOTTOMLEFT)
    TM_ENUM(4, OT, BOTTOMRIGHT)
    TM_ENUM(5, OT, BOTTOMMIDDLE)
    TM_ENUM(6, OT, MIDDLELEFT)
    TM_ENUM(7, OT, MIDDLERIGHT)
    TM_ENUM(8, OT, LEFTOFCAPTION)
    TM_ENUM(9, OT, RIGHTOFCAPTION)
    TM_ENUM(10, OT, LEFTOFLASTBUTTON)
    TM_ENUM(11, OT, RIGHTOFLASTBUTTON)
    TM_ENUM(12, OT, ABOVELASTBUTTON)
    TM_ENUM(13, OT, BELOWLASTBUTTON)
END_TM_ENUM()

BEGIN_TM_ENUM(ICONEFFECT)
    TM_ENUM(0, ICE, NONE)
    TM_ENUM(1, ICE, GLOW)
    TM_ENUM(2, ICE, SHADOW)
    TM_ENUM(3, ICE, PULSE)
    TM_ENUM(4, ICE, ALPHA)
END_TM_ENUM()

BEGIN_TM_ENUM(TEXTSHADOWTYPE)
    TM_ENUM(0, TST, NONE)
    TM_ENUM(1, TST, SINGLE)
    TM_ENUM(2, TST, CONTINUOUS)
END_TM_ENUM()

BEGIN_TM_ENUM(GLYPHTYPE)
    TM_ENUM(0, GT, NONE)
    TM_ENUM(1, GT, IMAGEGLYPH)
    TM_ENUM(2, GT, FONTGLYPH)
END_TM_ENUM()

BEGIN_TM_ENUM(IMAGESELECTTYPE)
    TM_ENUM(0, IST, NONE)
    TM_ENUM(1, IST, SIZE)
    TM_ENUM(2, IST, DPI)
END_TM_ENUM()

BEGIN_TM_ENUM(TRUESIZESCALINGTYPE)
    TM_ENUM(0, TSST, NONE)
    TM_ENUM(1, TSST, SIZE)
    TM_ENUM(2, TSST, DPI)
END_TM_ENUM()

BEGIN_TM_ENUM(GLYPHFONTSIZINGTYPE)
    TM_ENUM(0, GFST, NONE)
    TM_ENUM(1, GFST, SIZE)
    TM_ENUM(2, GFST, DPI)
END_TM_ENUM()

//-----------------------------------------------------------------
//    PROPERTIES - used by uxtheme rendering and controls
//      
//    these cannot be renumbered (part of uxtheme API)
//-----------------------------------------------------------------
BEGIN_TM_PROPS()

    //---- primitive types ----
    TM_PROP(201, TMT, STRING,    STRING)
    TM_PROP(202, TMT, INT,       INT)
    TM_PROP(203, TMT, BOOL,      BOOL)
    TM_PROP(204, TMT, COLOR,     COLOR)
    TM_PROP(205, TMT, MARGINS,   MARGINS)
    TM_PROP(206, TMT, FILENAME,  FILENAME)
    TM_PROP(207, TMT, SIZE,      SIZE)
    TM_PROP(208, TMT, POSITION,  POSITION)
    TM_PROP(209, TMT, RECT,      RECT)
    TM_PROP(210, TMT, FONT,      FONT)
    TM_PROP(211, TMT, INTLIST,   INTLIST)

    //---- special misc. properties ----
    TM_PROP(401, TMT, COLORSCHEMES,   STRING)
    TM_PROP(402, TMT, SIZES,          STRING)
    TM_PROP(403, TMT, CHARSET,        INT)

    //---- [documentation] properties ----

#define TMT_FIRST_RCSTRING_NAME   TMT_DISPLAYNAME
#define TMT_LAST_RCSTRING_NAME    TMT_DESCRIPTION

    TM_PROP(601, TMT, DISPLAYNAME,    STRING)
    TM_PROP(602, TMT, TOOLTIP,        STRING)
    TM_PROP(603, TMT, COMPANY,        STRING)
    TM_PROP(604, TMT, AUTHOR,         STRING)
    TM_PROP(605, TMT, COPYRIGHT,      STRING)
    TM_PROP(606, TMT, URL,            STRING)
    TM_PROP(607, TMT, VERSION,        STRING)
    TM_PROP(608, TMT, DESCRIPTION,    STRING)

    //---- theme metrics: fonts ----

#define TMT_FIRSTFONT TMT_CAPTIONFONT
#define TMT_LASTFONT  TMT_ICONTITLEFONT

    TM_PROP(801, TMT, CAPTIONFONT,        FONT)
    TM_PROP(802, TMT, SMALLCAPTIONFONT,   FONT)
    TM_PROP(803, TMT, MENUFONT,           FONT)
    TM_PROP(804, TMT, STATUSFONT,         FONT)
    TM_PROP(805, TMT, MSGBOXFONT,         FONT)
    TM_PROP(806, TMT, ICONTITLEFONT,      FONT)

    //---- theme metrics: bools ----

#define TMT_FIRSTBOOL   TMT_FLATMENUS
#define TMT_LASTBOOL    TMT_FLATMENUS

    TM_PROP(1001, TMT, FLATMENUS,            BOOL)

    //---- theme metrics: sizes ----

#define TMT_FIRSTSIZE   TMT_SIZINGBORDERWIDTH
#define TMT_LASTSIZE    TMT_MENUBARHEIGHT

    TM_PROP(1201, TMT, SIZINGBORDERWIDTH,    SIZE)
    TM_PROP(1202, TMT, SCROLLBARWIDTH,       SIZE)
    TM_PROP(1203, TMT, SCROLLBARHEIGHT,      SIZE)
    TM_PROP(1204, TMT, CAPTIONBARWIDTH,      SIZE)
    TM_PROP(1205, TMT, CAPTIONBARHEIGHT,     SIZE)
    TM_PROP(1206, TMT, SMCAPTIONBARWIDTH,    SIZE)
    TM_PROP(1207, TMT, SMCAPTIONBARHEIGHT,   SIZE)
    TM_PROP(1208, TMT, MENUBARWIDTH,         SIZE)
    TM_PROP(1209, TMT, MENUBARHEIGHT,        SIZE)

    //---- theme metrics: ints ----

#define TMT_FIRSTINT   TMT_MINCOLORDEPTH
#define TMT_LASTINT    TMT_MINCOLORDEPTH

    TM_PROP(1301, TMT, MINCOLORDEPTH,     INT)

    //---- theme metrics: strings ----

#define TMT_FIRSTSTRING   TMT_CSSNAME
#define TMT_LASTSTRING    TMT_XMLNAME

    TM_PROP(1401, TMT, CSSNAME,            STRING)
    TM_PROP(1402, TMT, XMLNAME,            STRING)

    //---- theme metrics: colors ----

#define TMT_FIRSTCOLOR  TMT_SCROLLBAR
#define TMT_LASTCOLOR   TMT_MENUBAR

    TM_PROP(1601, TMT, SCROLLBAR,          COLOR)
    TM_PROP(1602, TMT, BACKGROUND,         COLOR)
    TM_PROP(1603, TMT, ACTIVECAPTION,      COLOR)
    TM_PROP(1604, TMT, INACTIVECAPTION,    COLOR)
    TM_PROP(1605, TMT, MENU,               COLOR)
    TM_PROP(1606, TMT, WINDOW,             COLOR)
    TM_PROP(1607, TMT, WINDOWFRAME,        COLOR)
    TM_PROP(1608, TMT, MENUTEXT,           COLOR)
    TM_PROP(1609, TMT, WINDOWTEXT,         COLOR)
    TM_PROP(1610, TMT, CAPTIONTEXT,        COLOR)
    TM_PROP(1611, TMT, ACTIVEBORDER,       COLOR)
    TM_PROP(1612, TMT, INACTIVEBORDER,     COLOR)
    TM_PROP(1613, TMT, APPWORKSPACE,       COLOR)
    TM_PROP(1614, TMT, HIGHLIGHT,          COLOR)
    TM_PROP(1615, TMT, HIGHLIGHTTEXT,      COLOR)
    TM_PROP(1616, TMT, BTNFACE,            COLOR)
    TM_PROP(1617, TMT, BTNSHADOW,          COLOR)
    TM_PROP(1618, TMT, GRAYTEXT,           COLOR)
    TM_PROP(1619, TMT, BTNTEXT,            COLOR)
    TM_PROP(1620, TMT, INACTIVECAPTIONTEXT,     COLOR)
    TM_PROP(1621, TMT, BTNHIGHLIGHT,            COLOR)
    TM_PROP(1622, TMT, DKSHADOW3D,              COLOR)
    TM_PROP(1623, TMT, LIGHT3D,                 COLOR)
    TM_PROP(1624, TMT, INFOTEXT,                COLOR)
    TM_PROP(1625, TMT, INFOBK,                  COLOR)
    TM_PROP(1626, TMT, BUTTONALTERNATEFACE,     COLOR)
    TM_PROP(1627, TMT, HOTTRACKING,             COLOR)
    TM_PROP(1628, TMT, GRADIENTACTIVECAPTION,   COLOR)
    TM_PROP(1629, TMT, GRADIENTINACTIVECAPTION, COLOR)
    TM_PROP(1630, TMT, MENUHILIGHT,             COLOR)
    TM_PROP(1631, TMT, MENUBAR,                 COLOR)

    //---- hue substitutions ----
    TM_PROP(1801, TMT, FROMHUE1,  INT)
    TM_PROP(1802, TMT, FROMHUE2,  INT)
    TM_PROP(1803, TMT, FROMHUE3,  INT)
    TM_PROP(1804, TMT, FROMHUE4,  INT)
    TM_PROP(1805, TMT, FROMHUE5,  INT)
    TM_PROP(1806, TMT, TOHUE1,    INT)
    TM_PROP(1807, TMT, TOHUE2,    INT)
    TM_PROP(1808, TMT, TOHUE3,    INT)
    TM_PROP(1809, TMT, TOHUE4,    INT)
    TM_PROP(1810, TMT, TOHUE5,    INT)

    //---- color substitutions ----
    TM_PROP(2001, TMT, FROMCOLOR1,  COLOR)
    TM_PROP(2002, TMT, FROMCOLOR2,  COLOR)
    TM_PROP(2003, TMT, FROMCOLOR3,  COLOR)
    TM_PROP(2004, TMT, FROMCOLOR4,  COLOR)
    TM_PROP(2005, TMT, FROMCOLOR5,  COLOR)
    TM_PROP(2006, TMT, TOCOLOR1,    COLOR)
    TM_PROP(2007, TMT, TOCOLOR2,    COLOR)
    TM_PROP(2008, TMT, TOCOLOR3,    COLOR)
    TM_PROP(2009, TMT, TOCOLOR4,    COLOR)
    TM_PROP(2010, TMT, TOCOLOR5,    COLOR)

    //---- rendering BOOL properties ----
    TM_PROP(2201, TMT, TRANSPARENT,   BOOL)       // image has transparent areas (see TransparentColor)
    TM_PROP(2202, TMT, AUTOSIZE,      BOOL)       // if TRUE, nonclient caption width varies with text extent
    TM_PROP(2203, TMT, BORDERONLY,    BOOL)       // only draw the border area of the image
    TM_PROP(2204, TMT, COMPOSITED,    BOOL)       // control will handle the composite drawing
    TM_PROP(2205, TMT, BGFILL,        BOOL)       // if TRUE, TRUESIZE images should be drawn on bg fill
    TM_PROP(2206, TMT, GLYPHTRANSPARENT,  BOOL)   // glyph has transparent areas (see GlyphTransparentColor)
    TM_PROP(2207, TMT, GLYPHONLY,         BOOL)   // only draw glyph (not background)
    TM_PROP(2208, TMT, ALWAYSSHOWSIZINGBAR, BOOL)
    TM_PROP(2209, TMT, MIRRORIMAGE,         BOOL) // default=TRUE means image gets mirrored in RTL (Mirror) windows
    TM_PROP(2210, TMT, UNIFORMSIZING,       BOOL) // if TRUE, height & width must be uniformly sized 
    TM_PROP(2211, TMT, INTEGRALSIZING,      BOOL) // for TRUESIZE and Border sizing; if TRUE, factor must be integer
    TM_PROP(2212, TMT, SOURCEGROW,          BOOL) // if TRUE, will scale up src image when needed
    TM_PROP(2213, TMT, SOURCESHRINK,        BOOL) // if TRUE, will scale down src image when needed

    //---- rendering INT properties ----
    TM_PROP(2401, TMT, IMAGECOUNT,        INT)    // the number of state images in an imagefile
    TM_PROP(2402, TMT, ALPHALEVEL,        INT)    // (0-255) alpha value for an icon (DrawThemeIcon part)
    TM_PROP(2403, TMT, BORDERSIZE,        INT)    // the size of the border line for bgtype=BorderFill
    TM_PROP(2404, TMT, ROUNDCORNERWIDTH,  INT)    // (0-100) % of roundness for rounded rects
    TM_PROP(2405, TMT, ROUNDCORNERHEIGHT, INT)    // (0-100) % of roundness for rounded rects
    TM_PROP(2406, TMT, GRADIENTRATIO1,    INT)    // (0-255) - amt of gradient color 1 to use (all must total=255)
    TM_PROP(2407, TMT, GRADIENTRATIO2,    INT)    // (0-255) - amt of gradient color 2 to use (all must total=255)
    TM_PROP(2408, TMT, GRADIENTRATIO3,    INT)    // (0-255) - amt of gradient color 3 to use (all must total=255)
    TM_PROP(2409, TMT, GRADIENTRATIO4,    INT)    // (0-255) - amt of gradient color 4 to use (all must total=255)
    TM_PROP(2410, TMT, GRADIENTRATIO5,    INT)    // (0-255) - amt of gradient color 5 to use (all must total=255)
    TM_PROP(2411, TMT, PROGRESSCHUNKSIZE, INT)    // size of progress control chunks
    TM_PROP(2412, TMT, PROGRESSSPACESIZE, INT)    // size of progress control spaces
    TM_PROP(2413, TMT, SATURATION,        INT)    // (0-255) amt of saturation for DrawThemeIcon() part
    TM_PROP(2414, TMT, TEXTBORDERSIZE,    INT)    // size of border around text chars
    TM_PROP(2415, TMT, ALPHATHRESHOLD,    INT)    // (0-255) the min. alpha value of a pixel that is solid
    TM_PROP(2416, TMT, WIDTH,             SIZE)   // custom window prop: size of part (min. window)
    TM_PROP(2417, TMT, HEIGHT,            SIZE)   // custom window prop: size of part (min. window)
    TM_PROP(2418, TMT, GLYPHINDEX,        INT)    // for font-based glyphs, the char index into the font
    TM_PROP(2419, TMT, TRUESIZESTRETCHMARK, INT)  // stretch TrueSize image when target exceeds source by this percent
    TM_PROP(2420, TMT, MINDPI1,         INT)      // min DPI ImageFile1 was designed for
    TM_PROP(2421, TMT, MINDPI2,         INT)      // min DPI ImageFile1 was designed for
    TM_PROP(2422, TMT, MINDPI3,         INT)      // min DPI ImageFile1 was designed for
    TM_PROP(2423, TMT, MINDPI4,         INT)      // min DPI ImageFile1 was designed for
    TM_PROP(2424, TMT, MINDPI5,         INT)      // min DPI ImageFile1 was designed for

    //---- rendering FONT properties ----
    TM_PROP(2601, TMT, GLYPHFONT,         FONT)   // the font that the glyph is drawn with

    //---- rendering INTLIST properties ----
    // start with 2801
                                                // (from smallest to largest)
    //---- rendering FILENAME properties ----
    TM_PROP(3001, TMT, IMAGEFILE,         FILENAME)   // the filename of the image (or basename, for mult. images)
    TM_PROP(3002, TMT, IMAGEFILE1,        FILENAME)   // multiresolution image file
    TM_PROP(3003, TMT, IMAGEFILE2,        FILENAME)   // multiresolution image file
    TM_PROP(3004, TMT, IMAGEFILE3,        FILENAME)   // multiresolution image file
    TM_PROP(3005, TMT, IMAGEFILE4,        FILENAME)   // multiresolution image file
    TM_PROP(3006, TMT, IMAGEFILE5,        FILENAME)   // multiresolution image file
    TM_PROP(3007, TMT, STOCKIMAGEFILE,    FILENAME)   // These are the only images that you can call GetThemeBitmap on
    TM_PROP(3008, TMT, GLYPHIMAGEFILE,    FILENAME)   // the filename for the glyph image

    //---- rendering STRING properties ----
    TM_PROP(3201, TMT, TEXT,              STRING)

    //---- rendering POSITION (x and y values) properties ----
    TM_PROP(3401, TMT, OFFSET,            POSITION)   // for window part layout
    TM_PROP(3402, TMT, TEXTSHADOWOFFSET,  POSITION)   // where char shadows are drawn, relative to orig. chars
    TM_PROP(3403, TMT, MINSIZE,           POSITION)   // min dest rect than ImageFile was designed for
    TM_PROP(3404, TMT, MINSIZE1,          POSITION)   // min dest rect than ImageFile1 was designed for
    TM_PROP(3405, TMT, MINSIZE2,          POSITION)   // min dest rect than ImageFile2 was designed for
    TM_PROP(3406, TMT, MINSIZE3,          POSITION)   // min dest rect than ImageFile3 was designed for
    TM_PROP(3407, TMT, MINSIZE4,          POSITION)   // min dest rect than ImageFile4 was designed for
    TM_PROP(3408, TMT, MINSIZE5,          POSITION)   // min dest rect than ImageFile5 was designed for
    TM_PROP(3409, TMT, NORMALSIZE,        POSITION)   // size of dest rect that exactly source

    //---- rendering MARGIN properties ----
    TM_PROP(3601, TMT, SIZINGMARGINS,     MARGINS)    // margins used for 9-grid sizing
    TM_PROP(3602, TMT, CONTENTMARGINS,    MARGINS)    // margins that define where content can be placed
    TM_PROP(3603, TMT, CAPTIONMARGINS,    MARGINS)    // margins that define where caption text can be placed

    //---- rendering COLOR properties ----
    TM_PROP(3801, TMT, BORDERCOLOR,      COLOR)       // color of borders for BorderFill 
    TM_PROP(3802, TMT, FILLCOLOR,        COLOR)       // color of bg fill 
    TM_PROP(3803, TMT, TEXTCOLOR,        COLOR)       // color text is drawn in
    TM_PROP(3804, TMT, EDGELIGHTCOLOR,     COLOR)     // edge color
    TM_PROP(3805, TMT, EDGEHIGHLIGHTCOLOR, COLOR)     // edge color
    TM_PROP(3806, TMT, EDGESHADOWCOLOR,    COLOR)     // edge color
    TM_PROP(3807, TMT, EDGEDKSHADOWCOLOR,  COLOR)     // edge color
    TM_PROP(3808, TMT, EDGEFILLCOLOR,  COLOR)         // edge color
    TM_PROP(3809, TMT, TRANSPARENTCOLOR, COLOR)       // color of pixels that are treated as transparent (not drawn)
    TM_PROP(3810, TMT, GRADIENTCOLOR1,   COLOR)       // first color in gradient
    TM_PROP(3811, TMT, GRADIENTCOLOR2,   COLOR)       // second color in gradient
    TM_PROP(3812, TMT, GRADIENTCOLOR3,   COLOR)       // third color in gradient
    TM_PROP(3813, TMT, GRADIENTCOLOR4,   COLOR)       // forth color in gradient
    TM_PROP(3814, TMT, GRADIENTCOLOR5,   COLOR)       // fifth color in gradient
    TM_PROP(3815, TMT, SHADOWCOLOR,      COLOR)       // color of text shadow
    TM_PROP(3816, TMT, GLOWCOLOR,        COLOR)       // color of glow produced by DrawThemeIcon
    TM_PROP(3817, TMT, TEXTBORDERCOLOR,  COLOR)       // color of text border
    TM_PROP(3818, TMT, TEXTSHADOWCOLOR,  COLOR)       // color of text shadow
    TM_PROP(3819, TMT, GLYPHTEXTCOLOR,        COLOR)  // color that font-based glyph is drawn with
    TM_PROP(3820, TMT, GLYPHTRANSPARENTCOLOR, COLOR)  // color of transparent pixels in GlyphImageFile
    TM_PROP(3821, TMT, FILLCOLORHINT, COLOR)          // hint about fill color used (for custom controls)
    TM_PROP(3822, TMT, BORDERCOLORHINT, COLOR)        // hint about border color used (for custom controls)
    TM_PROP(3823, TMT, ACCENTCOLORHINT, COLOR)        // hint about accent color used (for custom controls)

    //---- rendering enum properties (must be declared in TM_ENUM section above) ----
    TM_PROP(4001, TMT, BGTYPE,           ENUM)        // basic drawing type for each part
    TM_PROP(4002, TMT, BORDERTYPE,       ENUM)        // type of border for BorderFill parts
    TM_PROP(4003, TMT, FILLTYPE,         ENUM)        // fill shape for BorderFill parts
    TM_PROP(4004, TMT, SIZINGTYPE,       ENUM)        // how to size ImageFile parts
    TM_PROP(4005, TMT, HALIGN,           ENUM)        // horizontal alignment for TRUESIZE parts & glyphs
    TM_PROP(4006, TMT, CONTENTALIGNMENT, ENUM)        // custom window prop: how text is aligned in caption
    TM_PROP(4007, TMT, VALIGN,           ENUM)        // horizontal alignment for TRUESIZE parts & glyphs
    TM_PROP(4008, TMT, OFFSETTYPE,       ENUM)        // how window part should be placed
    TM_PROP(4009, TMT, ICONEFFECT,       ENUM)        // type of effect to use with DrawThemeIcon
    TM_PROP(4010, TMT, TEXTSHADOWTYPE,   ENUM)        // type of shadow to draw with text
    TM_PROP(4011, TMT, IMAGELAYOUT,      ENUM)        // how multiple images are arranged (horz. or vert.)
    TM_PROP(4012, TMT, GLYPHTYPE,             ENUM)   // controls type of glyph in imagefile objects
    TM_PROP(4013, TMT, IMAGESELECTTYPE,       ENUM)   // controls when to select from IMAGEFILE1...IMAGEFILE5
    TM_PROP(4014, TMT, GLYPHFONTSIZINGTYPE,   ENUM)   // controls when to select a bigger/small glyph font size
    TM_PROP(4015, TMT, TRUESIZESCALINGTYPE,   ENUM)   // controls how TrueSize image is scaled
    
    //---- custom properties (used only by controls/shell) ----
    TM_PROP(5001, TMT, USERPICTURE,           BOOL)
    TM_PROP(5002, TMT, DEFAULTPANESIZE,       RECT)
    TM_PROP(5003, TMT, BLENDCOLOR,            COLOR)

END_TM_PROPS()

//---------------------------------------------------------------------------------------
//   "Window" (i.e., non-client) Parts & States
//
//    these cannot be renumbered (part of uxtheme API)
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(WINDOW)
    TM_PART(1, WP, CAPTION)
    TM_PART(2, WP, SMALLCAPTION)
    TM_PART(3, WP, MINCAPTION)
    TM_PART(4, WP, SMALLMINCAPTION)
    TM_PART(5, WP, MAXCAPTION)
    TM_PART(6, WP, SMALLMAXCAPTION)
    TM_PART(7, WP, FRAMELEFT)
    TM_PART(8, WP, FRAMERIGHT)
    TM_PART(9, WP, FRAMEBOTTOM)
    TM_PART(10, WP, SMALLFRAMELEFT)
    TM_PART(11, WP, SMALLFRAMERIGHT)
    TM_PART(12, WP, SMALLFRAMEBOTTOM)
    //---- window frame buttons ----
    TM_PART(13, WP, SYSBUTTON)
    TM_PART(14, WP, MDISYSBUTTON)
    TM_PART(15, WP, MINBUTTON)
    TM_PART(16, WP, MDIMINBUTTON)
    TM_PART(17, WP, MAXBUTTON)
    TM_PART(18, WP, CLOSEBUTTON)
    TM_PART(19, WP, SMALLCLOSEBUTTON)
    TM_PART(20, WP, MDICLOSEBUTTON)
    TM_PART(21, WP, RESTOREBUTTON)
    TM_PART(22, WP, MDIRESTOREBUTTON)
    TM_PART(23, WP, HELPBUTTON)
    TM_PART(24, WP, MDIHELPBUTTON)
    //---- scrollbars 
    TM_PART(25, WP, HORZSCROLL)
    TM_PART(26, WP, HORZTHUMB)
    TM_PART(27, WP, VERTSCROLL)
    TM_PART(28, WP, VERTTHUMB)
    //---- dialog ----
    TM_PART(29, WP, DIALOG)
    //---- hit-test templates ---
    TM_PART(30, WP, CAPTIONSIZINGTEMPLATE)
    TM_PART(31, WP, SMALLCAPTIONSIZINGTEMPLATE)
    TM_PART(32, WP, FRAMELEFTSIZINGTEMPLATE)
    TM_PART(33, WP, SMALLFRAMELEFTSIZINGTEMPLATE)
    TM_PART(34, WP, FRAMERIGHTSIZINGTEMPLATE)
    TM_PART(35, WP, SMALLFRAMERIGHTSIZINGTEMPLATE)
    TM_PART(36, WP, FRAMEBOTTOMSIZINGTEMPLATE)
    TM_PART(37, WP, SMALLFRAMEBOTTOMSIZINGTEMPLATE)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(FRAME)
    TM_STATE(1, FS, ACTIVE)
    TM_STATE(2, FS, INACTIVE)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(CAPTION)
    TM_STATE(1, CS, ACTIVE)
    TM_STATE(2, CS, INACTIVE)
    TM_STATE(3, CS, DISABLED)
END_TM_PART_STATES()
    
BEGIN_TM_PART_STATES(MAXCAPTION)
    TM_STATE(1, MXCS, ACTIVE)
    TM_STATE(2, MXCS, INACTIVE)
    TM_STATE(3, MXCS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(MINCAPTION)
    TM_STATE(1, MNCS, ACTIVE)
    TM_STATE(2, MNCS, INACTIVE)
    TM_STATE(3, MNCS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HORZSCROLL)
    TM_STATE(1, HSS, NORMAL)
    TM_STATE(2, HSS, HOT)
    TM_STATE(3, HSS, PUSHED)
    TM_STATE(4, HSS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HORZTHUMB)
    TM_STATE(1, HTS, NORMAL)
    TM_STATE(2, HTS, HOT)
    TM_STATE(3, HTS, PUSHED)
    TM_STATE(4, HTS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(VERTSCROLL)
    TM_STATE(1, VSS, NORMAL)
    TM_STATE(2, VSS, HOT)
    TM_STATE(3, VSS, PUSHED)
    TM_STATE(4, VSS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(VERTTHUMB)
    TM_STATE(1, VTS, NORMAL)
    TM_STATE(2, VTS, HOT)
    TM_STATE(3, VTS, PUSHED)
    TM_STATE(4, VTS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SYSBUTTON)
    TM_STATE(1, SBS, NORMAL)
    TM_STATE(2, SBS, HOT)
    TM_STATE(3, SBS, PUSHED)
    TM_STATE(4, SBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(MINBUTTON)
    TM_STATE(1, MINBS, NORMAL)
    TM_STATE(2, MINBS, HOT)
    TM_STATE(3, MINBS, PUSHED)
    TM_STATE(4, MINBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(MAXBUTTON)
    TM_STATE(1, MAXBS, NORMAL)
    TM_STATE(2, MAXBS, HOT)
    TM_STATE(3, MAXBS, PUSHED)
    TM_STATE(4, MAXBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(RESTOREBUTTON)
    TM_STATE(1, RBS, NORMAL)
    TM_STATE(2, RBS, HOT)
    TM_STATE(3, RBS, PUSHED)
    TM_STATE(4, RBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HELPBUTTON)
    TM_STATE(1, HBS, NORMAL)
    TM_STATE(2, HBS, HOT)
    TM_STATE(3, HBS, PUSHED)
    TM_STATE(4, HBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(CLOSEBUTTON)
    TM_STATE(1, CBS, NORMAL)
    TM_STATE(2, CBS, HOT)
    TM_STATE(3, CBS, PUSHED)
    TM_STATE(4, CBS, DISABLED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Button" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(BUTTON)
    TM_PART(1, BP, PUSHBUTTON)
    TM_PART(2, BP, RADIOBUTTON)
    TM_PART(3, BP, CHECKBOX)
    TM_PART(4, BP, GROUPBOX)
    TM_PART(5, BP, USERBUTTON)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(PUSHBUTTON)
    TM_STATE(1, PBS, NORMAL)
    TM_STATE(2, PBS, HOT)
    TM_STATE(3, PBS, PRESSED)
    TM_STATE(4, PBS, DISABLED)
    TM_STATE(5, PBS, DEFAULTED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(RADIOBUTTON)
    TM_STATE(1, RBS, UNCHECKEDNORMAL)
    TM_STATE(2, RBS, UNCHECKEDHOT)
    TM_STATE(3, RBS, UNCHECKEDPRESSED)
    TM_STATE(4, RBS, UNCHECKEDDISABLED)
    TM_STATE(5, RBS, CHECKEDNORMAL)
    TM_STATE(6, RBS, CHECKEDHOT)
    TM_STATE(7, RBS, CHECKEDPRESSED)
    TM_STATE(8, RBS, CHECKEDDISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(CHECKBOX)
    TM_STATE(1, CBS, UNCHECKEDNORMAL)
    TM_STATE(2, CBS, UNCHECKEDHOT)
    TM_STATE(3, CBS, UNCHECKEDPRESSED)
    TM_STATE(4, CBS, UNCHECKEDDISABLED)
    TM_STATE(5, CBS, CHECKEDNORMAL)
    TM_STATE(6, CBS, CHECKEDHOT)
    TM_STATE(7, CBS, CHECKEDPRESSED)
    TM_STATE(8, CBS, CHECKEDDISABLED)
    TM_STATE(9, CBS, MIXEDNORMAL)
    TM_STATE(10, CBS, MIXEDHOT)
    TM_STATE(11, CBS, MIXEDPRESSED)
    TM_STATE(12, CBS, MIXEDDISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(GROUPBOX)
    TM_STATE(1, GBS, NORMAL)
    TM_STATE(2, GBS, DISABLED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Rebar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(REBAR)
    TM_PART(1, RP, GRIPPER)
    TM_PART(2, RP, GRIPPERVERT)
    TM_PART(3, RP, BAND)
    TM_PART(4, RP, CHEVRON)
    TM_PART(5, RP, CHEVRONVERT)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(CHEVRON)
    TM_STATE(1, CHEVS, NORMAL)
    TM_STATE(2, CHEVS, HOT)
    TM_STATE(3, CHEVS, PRESSED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Toolbar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TOOLBAR)
    TM_PART(1, TP, BUTTON)
    TM_PART(2, TP, DROPDOWNBUTTON)
    TM_PART(3, TP, SPLITBUTTON)
    TM_PART(4, TP, SPLITBUTTONDROPDOWN)
    TM_PART(5, TP, SEPARATOR)
    TM_PART(6, TP, SEPARATORVERT)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(TOOLBAR)
    TM_STATE(1, TS, NORMAL)
    TM_STATE(2, TS, HOT)
    TM_STATE(3, TS, PRESSED)
    TM_STATE(4, TS, DISABLED)
    TM_STATE(5, TS, CHECKED)
    TM_STATE(6, TS, HOTCHECKED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Status" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(STATUS)
    TM_PART(1, SP, PANE)
    TM_PART(2, SP, GRIPPERPANE)
    TM_PART(3, SP, GRIPPER)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "Menu" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(MENU)
    TM_PART(1, MP, MENUITEM)
    TM_PART(2, MP, MENUDROPDOWN)
    TM_PART(3, MP, MENUBARITEM)
    TM_PART(4, MP, MENUBARDROPDOWN)
    TM_PART(5, MP, CHEVRON)
    TM_PART(6, MP, SEPARATOR)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(MENU)
    TM_STATE(1, MS, NORMAL)
    TM_STATE(2, MS, SELECTED)
    TM_STATE(3, MS, DEMOTED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "ListView" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(LISTVIEW)
    TM_PART(1, LVP, LISTITEM)
    TM_PART(2, LVP, LISTGROUP)
    TM_PART(3, LVP, LISTDETAIL)
    TM_PART(4, LVP, LISTSORTEDDETAIL)
    TM_PART(5, LVP, EMPTYTEXT)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(LISTITEM)
    TM_STATE(1, LIS, NORMAL)
    TM_STATE(2, LIS, HOT)
    TM_STATE(3, LIS, SELECTED)
    TM_STATE(4, LIS, DISABLED)
    TM_STATE(5, LIS, SELECTEDNOTFOCUS)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Header" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(HEADER)
    TM_PART(1, HP, HEADERITEM)
    TM_PART(2, HP, HEADERITEMLEFT)
    TM_PART(3, HP, HEADERITEMRIGHT)
    TM_PART(4, HP, HEADERSORTARROW)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(HEADERITEM)
    TM_STATE(1, HIS, NORMAL)
    TM_STATE(2, HIS, HOT)
    TM_STATE(3, HIS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HEADERITEMLEFT)
    TM_STATE(1, HILS, NORMAL)
    TM_STATE(2, HILS, HOT)
    TM_STATE(3, HILS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HEADERITEMRIGHT)
    TM_STATE(1, HIRS, NORMAL)
    TM_STATE(2, HIRS, HOT)
    TM_STATE(3, HIRS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HEADERSORTARROW)
    TM_STATE(1, HSAS, SORTEDUP)
    TM_STATE(2, HSAS, SORTEDDOWN)
END_TM_PART_STATES()
//---------------------------------------------------------------------------------------
//   "Progress" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(PROGRESS)
    TM_PART(1, PP, BAR)
    TM_PART(2, PP, BARVERT)
    TM_PART(3, PP, CHUNK)
    TM_PART(4, PP, CHUNKVERT)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "Tab" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TAB)
    TM_PART(1, TABP, TABITEM)
    TM_PART(2, TABP, TABITEMLEFTEDGE)
    TM_PART(3, TABP, TABITEMRIGHTEDGE)
    TM_PART(4, TABP, TABITEMBOTHEDGE)
    TM_PART(5, TABP, TOPTABITEM)
    TM_PART(6, TABP, TOPTABITEMLEFTEDGE)
    TM_PART(7, TABP, TOPTABITEMRIGHTEDGE)
    TM_PART(8, TABP, TOPTABITEMBOTHEDGE)
    TM_PART(9, TABP, PANE)
    TM_PART(10, TABP, BODY)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(TABITEM)
    TM_STATE(1, TIS, NORMAL)
    TM_STATE(2, TIS, HOT)
    TM_STATE(3, TIS, SELECTED)
    TM_STATE(4, TIS, DISABLED)
    TM_STATE(5, TIS, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TABITEMLEFTEDGE)
    TM_STATE(1, TILES, NORMAL)
    TM_STATE(2, TILES, HOT)
    TM_STATE(3, TILES, SELECTED)
    TM_STATE(4, TILES, DISABLED)
    TM_STATE(5, TILES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TABITEMRIGHTEDGE)
    TM_STATE(1, TIRES, NORMAL)
    TM_STATE(2, TIRES, HOT)
    TM_STATE(3, TIRES, SELECTED)
    TM_STATE(4, TIRES, DISABLED)
    TM_STATE(5, TIRES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TABITEMBOTHEDGES)
    TM_STATE(1, TIBES, NORMAL)
    TM_STATE(2, TIBES, HOT)
    TM_STATE(3, TIBES, SELECTED)
    TM_STATE(4, TIBES, DISABLED)
    TM_STATE(5, TIBES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TOPTABITEM)
    TM_STATE(1, TTIS, NORMAL)
    TM_STATE(2, TTIS, HOT)
    TM_STATE(3, TTIS, SELECTED)
    TM_STATE(4, TTIS, DISABLED)
    TM_STATE(5, TTIS, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TOPTABITEMLEFTEDGE)
    TM_STATE(1, TTILES, NORMAL)
    TM_STATE(2, TTILES, HOT)
    TM_STATE(3, TTILES, SELECTED)
    TM_STATE(4, TTILES, DISABLED)
    TM_STATE(5, TTILES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TOPTABITEMRIGHTEDGE)
    TM_STATE(1, TTIRES, NORMAL)
    TM_STATE(2, TTIRES, HOT)
    TM_STATE(3, TTIRES, SELECTED)
    TM_STATE(4, TTIRES, DISABLED)
    TM_STATE(5, TTIRES, FOCUSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TOPTABITEMBOTHEDGES)
    TM_STATE(1, TTIBES, NORMAL)
    TM_STATE(2, TTIBES, HOT)
    TM_STATE(3, TTIBES, SELECTED)
    TM_STATE(4, TTIBES, DISABLED)
    TM_STATE(5, TTIBES, FOCUSED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Trackbar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TRACKBAR)
    TM_PART(1, TKP, TRACK)
    TM_PART(2, TKP, TRACKVERT)
    TM_PART(3, TKP, THUMB)
    TM_PART(4, TKP, THUMBBOTTOM)
    TM_PART(5, TKP, THUMBTOP)
    TM_PART(6, TKP, THUMBVERT)
    TM_PART(7, TKP, THUMBLEFT)
    TM_PART(8, TKP, THUMBRIGHT)
    TM_PART(9, TKP, TICS)
    TM_PART(10, TKP, TICSVERT)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(TRACKBAR)
    TM_STATE(1, TKS, NORMAL)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TRACK)
    TM_STATE(1, TRS, NORMAL)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TRACKVERT)
    TM_STATE(1, TRVS, NORMAL)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMB)
    TM_STATE(1, TUS, NORMAL)
    TM_STATE(2, TUS, HOT)
    TM_STATE(3, TUS, PRESSED)
    TM_STATE(4, TUS, FOCUSED)
    TM_STATE(5, TUS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBBOTTOM)
    TM_STATE(1, TUBS, NORMAL)
    TM_STATE(2, TUBS, HOT)
    TM_STATE(3, TUBS, PRESSED)
    TM_STATE(4, TUBS, FOCUSED)
    TM_STATE(5, TUBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBTOP)
    TM_STATE(1, TUTS, NORMAL)
    TM_STATE(2, TUTS, HOT)
    TM_STATE(3, TUTS, PRESSED)
    TM_STATE(4, TUTS, FOCUSED)
    TM_STATE(5, TUTS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBVERT)
    TM_STATE(1, TUVS, NORMAL)
    TM_STATE(2, TUVS, HOT)
    TM_STATE(3, TUVS, PRESSED)
    TM_STATE(4, TUVS, FOCUSED)
    TM_STATE(5, TUVS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBLEFT)
    TM_STATE(1, TUVLS, NORMAL)
    TM_STATE(2, TUVLS, HOT)
    TM_STATE(3, TUVLS, PRESSED)
    TM_STATE(4, TUVLS, FOCUSED)
    TM_STATE(5, TUVLS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(THUMBRIGHT)
    TM_STATE(1, TUVRS, NORMAL)
    TM_STATE(2, TUVRS, HOT)
    TM_STATE(3, TUVRS, PRESSED)
    TM_STATE(4, TUVRS, FOCUSED)
    TM_STATE(5, TUVRS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TICS)
    TM_STATE(1, TSS, NORMAL)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(TICSVERT)
    TM_STATE(1, TSVS, NORMAL)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Tooltips" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TOOLTIP)
    TM_PART(1, TTP, STANDARD)
    TM_PART(2, TTP, STANDARDTITLE)
    TM_PART(3, TTP, BALLOON)
    TM_PART(4, TTP, BALLOONTITLE)
    TM_PART(5, TTP, CLOSE)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(CLOSE)
	TM_STATE(1, TTCS, NORMAL)
	TM_STATE(2, TTCS, HOT)
	TM_STATE(3, TTCS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(STANDARD)
	TM_STATE(1, TTSS, NORMAL)
	TM_STATE(2, TTSS, LINK)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(BALLOON)
	TM_STATE(1, TTBS, NORMAL)
	TM_STATE(2, TTBS, LINK)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "TreeView" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TREEVIEW)
    TM_PART(1, TVP, TREEITEM)
    TM_PART(2, TVP, GLYPH)
    TM_PART(3, TVP, BRANCH)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(TREEITEM)
    TM_STATE(1, TREIS, NORMAL)
    TM_STATE(2, TREIS, HOT)
    TM_STATE(3, TREIS, SELECTED)
    TM_STATE(4, TREIS, DISABLED)
    TM_STATE(5, TREIS, SELECTEDNOTFOCUS)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(GLYPH)
    TM_STATE(1, GLPS, CLOSED)
    TM_STATE(2, GLPS, OPENED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Spin" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(SPIN)
    TM_PART(1, SPNP, UP)
    TM_PART(2, SPNP, DOWN)
    TM_PART(3, SPNP, UPHORZ)
    TM_PART(4, SPNP, DOWNHORZ)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(UP)
    TM_STATE(1, UPS, NORMAL)
    TM_STATE(2, UPS, HOT)
    TM_STATE(3, UPS, PRESSED)
    TM_STATE(4, UPS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(DOWN)
    TM_STATE(1, DNS, NORMAL)
    TM_STATE(2, DNS, HOT)
    TM_STATE(3, DNS, PRESSED)
    TM_STATE(4, DNS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(UPHORZ)
    TM_STATE(1, UPHZS, NORMAL)
    TM_STATE(2, UPHZS, HOT)
    TM_STATE(3, UPHZS, PRESSED)
    TM_STATE(4, UPHZS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(DOWNHORZ)
    TM_STATE(1, DNHZS, NORMAL)
    TM_STATE(2, DNHZS, HOT)
    TM_STATE(3, DNHZS, PRESSED)
    TM_STATE(4, DNHZS, DISABLED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Page" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(PAGE)
    TM_PART(1, PGRP, UP)
    TM_PART(2, PGRP, DOWN)
    TM_PART(3, PGRP, UPHORZ)
    TM_PART(4, PGRP, DOWNHORZ)
END_TM_CLASS_PARTS()

//--- Pager uses same states as Spin ---

//---------------------------------------------------------------------------------------
//   "Scrollbar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(SCROLLBAR)
    TM_PART(1, SBP, ARROWBTN)
    TM_PART(2, SBP, THUMBBTNHORZ)
    TM_PART(3, SBP, THUMBBTNVERT)
    TM_PART(4, SBP, LOWERTRACKHORZ)
    TM_PART(5, SBP, UPPERTRACKHORZ)
    TM_PART(6, SBP, LOWERTRACKVERT)
    TM_PART(7, SBP, UPPERTRACKVERT)
    TM_PART(8, SBP, GRIPPERHORZ)
    TM_PART(9, SBP, GRIPPERVERT)
    TM_PART(10, SBP, SIZEBOX)
END_TM_CLASS_PARTS()



BEGIN_TM_PART_STATES(ARROWBTN)
    TM_STATE(1, ABS, UPNORMAL)
    TM_STATE(2, ABS, UPHOT)
    TM_STATE(3, ABS, UPPRESSED)
    TM_STATE(4, ABS, UPDISABLED)
    TM_STATE(5, ABS, DOWNNORMAL)
    TM_STATE(6, ABS, DOWNHOT)
    TM_STATE(7, ABS, DOWNPRESSED)
    TM_STATE(8, ABS, DOWNDISABLED)
    TM_STATE(9, ABS, LEFTNORMAL)
    TM_STATE(10, ABS, LEFTHOT)
    TM_STATE(11, ABS, LEFTPRESSED)
    TM_STATE(12, ABS, LEFTDISABLED)
    TM_STATE(13, ABS, RIGHTNORMAL)
    TM_STATE(14, ABS, RIGHTHOT)
    TM_STATE(15, ABS, RIGHTPRESSED)
    TM_STATE(16, ABS, RIGHTDISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SCROLLBAR)
    TM_STATE(1, SCRBS, NORMAL)
    TM_STATE(2, SCRBS, HOT)
    TM_STATE(3, SCRBS, PRESSED)
    TM_STATE(4, SCRBS, DISABLED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SIZEBOX)
    TM_STATE(1, SZB, RIGHTALIGN)
    TM_STATE(2, SZB, LEFTALIGN)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Edit" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(EDIT)
    TM_PART(1, EP, EDITTEXT)
    TM_PART(2, EP, CARET)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(EDITTEXT)
    TM_STATE(1, ETS, NORMAL)
    TM_STATE(2, ETS, HOT)
    TM_STATE(3, ETS, SELECTED)
    TM_STATE(4, ETS, DISABLED)
    TM_STATE(5, ETS, FOCUSED)
    TM_STATE(6, ETS, READONLY)
    TM_STATE(7, ETS, ASSIST)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "ComboBox" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(COMBOBOX)
    TM_PART(1, CP, DROPDOWNBUTTON)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(COMBOBOX)
    TM_STATE(1, CBXS, NORMAL)
    TM_STATE(2, CBXS, HOT)
    TM_STATE(3, CBXS, PRESSED)
    TM_STATE(4, CBXS, DISABLED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Taskbar Clock" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(CLOCK)
    TM_PART(1, CLP, TIME)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(CLOCK)
    TM_STATE(1, CLS, NORMAL)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "Tray Notify" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TRAYNOTIFY)
    TM_PART(1, TNP, BACKGROUND)
    TM_PART(2, TNP, ANIMBACKGROUND)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "TaskBar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TASKBAR)
    TM_PART(1, TBP, BACKGROUNDBOTTOM)
    TM_PART(2, TBP, BACKGROUNDRIGHT)
    TM_PART(3, TBP, BACKGROUNDTOP)
    TM_PART(4, TBP, BACKGROUNDLEFT)
    TM_PART(5, TBP, SIZINGBARBOTTOM)
    TM_PART(6, TBP, SIZINGBARRIGHT)
    TM_PART(7, TBP, SIZINGBARTOP)
    TM_PART(8, TBP, SIZINGBARLEFT)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "TaskBand" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(TASKBAND)
    TM_PART(1, TDP, GROUPCOUNT)
    TM_PART(2, TDP, FLASHBUTTON)
    TM_PART(3, TDP, FLASHBUTTONGROUPMENU)
END_TM_CLASS_PARTS()

//---------------------------------------------------------------------------------------
//   "StartPanel" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(STARTPANEL)
    TM_PART(1, SPP, USERPANE)
    TM_PART(2, SPP, MOREPROGRAMS)
    TM_PART(3, SPP, MOREPROGRAMSARROW)
    TM_PART(4, SPP, PROGLIST)
    TM_PART(5, SPP, PROGLISTSEPARATOR)
    TM_PART(6, SPP, PLACESLIST)
    TM_PART(7, SPP, PLACESLISTSEPARATOR)
    TM_PART(8, SPP, LOGOFF)
    TM_PART(9, SPP, LOGOFFBUTTONS)
    TM_PART(10, SPP, USERPICTURE)
    TM_PART(11, SPP, PREVIEW)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(MOREPROGRAMSARROW)
    TM_STATE(1, SPS, NORMAL)
    TM_STATE(2, SPS, HOT)
    TM_STATE(3, SPS, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(LOGOFFBUTTONS)
    TM_STATE(1, SPLS, NORMAL)
    TM_STATE(2, SPLS, HOT)
    TM_STATE(3, SPLS, PRESSED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "ExplorerBar" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(EXPLORERBAR)
    TM_PART(1, EBP, HEADERBACKGROUND)
    TM_PART(2, EBP, HEADERCLOSE)
    TM_PART(3, EBP, HEADERPIN)
    TM_PART(4, EBP, IEBARMENU)
    TM_PART(5, EBP, NORMALGROUPBACKGROUND)
    TM_PART(6, EBP, NORMALGROUPCOLLAPSE)
    TM_PART(7, EBP, NORMALGROUPEXPAND)
    TM_PART(8, EBP, NORMALGROUPHEAD)
    TM_PART(9, EBP, SPECIALGROUPBACKGROUND)
    TM_PART(10, EBP, SPECIALGROUPCOLLAPSE)
    TM_PART(11, EBP, SPECIALGROUPEXPAND)
    TM_PART(12, EBP, SPECIALGROUPHEAD)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(HEADERCLOSE)
    TM_STATE(1, EBHC, NORMAL)
    TM_STATE(2, EBHC, HOT)
    TM_STATE(3, EBHC, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(HEADERPIN)
    TM_STATE(1, EBHP, NORMAL)
    TM_STATE(2, EBHP, HOT)
    TM_STATE(3, EBHP, PRESSED)
    TM_STATE(4, EBHP, SELECTEDNORMAL)
    TM_STATE(5, EBHP, SELECTEDHOT)
    TM_STATE(6, EBHP, SELECTEDPRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(IEBARMENU)
    TM_STATE(1, EBM, NORMAL)
    TM_STATE(2, EBM, HOT)
    TM_STATE(3, EBM, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(NORMALGROUPCOLLAPSE)
    TM_STATE(1, EBNGC, NORMAL)
    TM_STATE(2, EBNGC, HOT)
    TM_STATE(3, EBNGC, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(NORMALGROUPEXPAND)
    TM_STATE(1, EBNGE, NORMAL)
    TM_STATE(2, EBNGE, HOT)
    TM_STATE(3, EBNGE, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SPECIALGROUPCOLLAPSE)
    TM_STATE(1, EBSGC, NORMAL)
    TM_STATE(2, EBSGC, HOT)
    TM_STATE(3, EBSGC, PRESSED)
END_TM_PART_STATES()

BEGIN_TM_PART_STATES(SPECIALGROUPEXPAND)
    TM_STATE(1, EBSGE, NORMAL)
    TM_STATE(2, EBSGE, HOT)
    TM_STATE(3, EBSGE, PRESSED)
END_TM_PART_STATES()

//---------------------------------------------------------------------------------------
//   "TaskBand" Parts & States
//---------------------------------------------------------------------------------------
BEGIN_TM_CLASS_PARTS(MENUBAND)
    TM_PART(1, MDP, NEWAPPBUTTON)
    TM_PART(2, MDP, SEPERATOR)
END_TM_CLASS_PARTS()

BEGIN_TM_PART_STATES(MENUBAND)
    TM_STATE(1, MDS, NORMAL)
    TM_STATE(2, MDS, HOT)
    TM_STATE(3, MDS, PRESSED)
    TM_STATE(4, MDS, DISABLED)
    TM_STATE(5, MDS, CHECKED)
    TM_STATE(6, MDS, HOTCHECKED)
END_TM_PART_STATES()
//---------------------------------------------------------------------------
END_TM_SCHEMA(ThemeMgrSchema)
//---------------------------------------------------------------------------
#endif      // TMSCHEMA_H
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\uastrfnc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       uastrfnc.h
//
//  Contents:   Unaligned UNICODE lstr functions for MIPS, PPC, ALPHA, ...
//
//  Classes:
//
//  Functions:
//
//;begin_internal
//  History:    1-11-95   davepl   Created
//;end_internal
//
//--------------------------------------------------------------------------

// NOTE: This file assumes it is included from shellprv.h

#ifndef _UASTRFNC_H_
#define _UASTRFNC_H_

#ifdef __cplusplus
extern "C" {
#endif

// If we are running on a platform that requires aligned data, we need
// to provide custom string functions that can deal with unaligned
// strings.  On other platforms, these call directly to the normal string
// functions.

#ifndef _X86_
#define ALIGNMENT_MACHINE
#endif

#ifdef ALIGNMENT_MACHINE

#define IS_ALIGNED(p)   (((ULONG_PTR)(p) & (sizeof(*(p))-1) )==0)

UNALIGNED WCHAR * ualstrcpynW(UNALIGNED WCHAR * lpString1,
    		  	      UNALIGNED const WCHAR * lpString2,
    			      int iMaxLength);

int 		  ualstrcmpiW (UNALIGNED const WCHAR * dst,
			       UNALIGNED const WCHAR * src);

int 		  ualstrcmpW  (UNALIGNED const WCHAR * src,
			       UNALIGNED const WCHAR * dst);

size_t 		  ualstrlenW  (UNALIGNED const WCHAR * wcs);

UNALIGNED WCHAR * ualstrcpyW  (UNALIGNED WCHAR * dst,
			       UNALIGNED const WCHAR * src);


#else

#define ualstrcpynW StrCpyNW     // lstrcpynW is stubbed out on Windows 95
#define ualstrcmpiW StrCmpIW     // lstrcmpiW is stubbed out on Windows 95
#define ualstrcmpW  StrCmpW      // lstrcmpW is stubbed out on Windows 95
#define ualstrlenW  lstrlenW
#define ualstrcpyW  StrCpyW      // lstrcpyW is stubbed out on Windows 95

#endif // ALIGNMENT_MACHINE

#define ualstrcpynA lstrcpynA
#define ualstrcmpiA lstrcmpiA
#define ualstrcmpA  lstrcmpA
#define ualstrlenA  lstrlenA
#define ualstrcpyA  lstrcpyA

#ifdef UNICODE
#define ualstrcpyn ualstrcpynW
#define ualstrcmpi ualstrcmpiW
#define ualstrcmp  ualstrcmpW
#define ualstrlen  ualstrlenW
#define ualstrcpy  ualstrcpyW
#else
#define ualstrcpyn ualstrcpynA
#define ualstrcmpi ualstrcmpiA
#define ualstrcmp  ualstrcmpA
#define ualstrlen  ualstrlenA
#define ualstrcpy  ualstrcpyA
#endif

#ifdef __cplusplus
}       // extern "C"
#endif

#endif // _UASTRFNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\themeid.h ===
/**************************************************************************\
    FILE: ThemeID.h
    DATE: BryanSt (3/31/2000)

    DESCRIPTION:
        Theme API (Object Model).

    Copyright (c) Microsoft Corporation. All rights reserved.
\**************************************************************************/

#ifndef _THEMEIDLID_H_

// define the ...
#define DISPID_NXOBJ_MIN                 0x00000000
#define DISPID_NXOBJ_MAX                 0x0000FFFF
#define DISPID_NXOBJ_BASE                DISPID_NXOBJ_MIN


//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These are events that are fired for all sites
//----------------------------------------------------------------------------


// IThemeManager Properties
#define DISPIDTHTM_CURRENTTHEME         (DISPID_NXOBJ_BASE + 100)
#define DISPIDTHTM_LENGTH               (DISPID_NXOBJ_BASE + 101)
#define DISPIDTHTM_ITEM                 (DISPID_NXOBJ_BASE + 102)
#define DISPIDTHTM_SELECTEDSCHEME       (DISPID_NXOBJ_BASE + 103)
#define DISPIDTHTM_WEBVIEWCSS           (DISPID_NXOBJ_BASE + 104)
#define DISPIDTHTM_SCHEMELENGTH         (DISPID_NXOBJ_BASE + 105)
#define DISPIDTHTM_SCHEMEITEM           (DISPID_NXOBJ_BASE + 106)
// IThemeManager Methods
#define DISPIDTHTM_GETSELSCHPROPERTY    (DISPID_NXOBJ_BASE + 150)
#define DISPIDTHTM_GETSPECIALTHEME      (DISPID_NXOBJ_BASE + 151)
#define DISPIDTHTM_SETSPECIALTHEME      (DISPID_NXOBJ_BASE + 152)
#define DISPIDTHTM_GETSPECIALSCHEME     (DISPID_NXOBJ_BASE + 153)
#define DISPIDTHTM_SETSPECIALSCHEME     (DISPID_NXOBJ_BASE + 154)
#define DISPIDTHTM_APPLYNOW             (DISPID_NXOBJ_BASE + 155)


// ITheme Properties
#define DISPIDTHTH_DISPLAYNAME          (DISPID_NXOBJ_BASE + 200)
#define DISPIDTHTH_BKGD                 (DISPID_NXOBJ_BASE + 201)
#define DISPIDTHTH_BKGDTILE             (DISPID_NXOBJ_BASE + 202)
#define DISPIDTHTH_SCRNSAVER            (DISPID_NXOBJ_BASE + 203)
#define DISPIDTHTH_LENGTH               (DISPID_NXOBJ_BASE + 204)
#define DISPIDTHTH_ITEM                 (DISPID_NXOBJ_BASE + 205)
#define DISPIDTHTH_SELECTEDSCHEME       (DISPID_NXOBJ_BASE + 206)
// ITheme Methods
#define DISPIDTHTH_GETPATH              (DISPID_NXOBJ_BASE + 250)
#define DISPIDTHTH_SETPATH              (DISPID_NXOBJ_BASE + 251)
#define DISPIDTHTH_VS                   (DISPID_NXOBJ_BASE + 252)
#define DISPIDTHTH_VSCOLOR              (DISPID_NXOBJ_BASE + 253)
#define DISPIDTHTH_VSSIZE               (DISPID_NXOBJ_BASE + 254)
#define DISPIDTHTH_GETCURSOR            (DISPID_NXOBJ_BASE + 255)
#define DISPIDTHTH_SETCURSOR            (DISPID_NXOBJ_BASE + 256)
#define DISPIDTHTH_GETSOUND             (DISPID_NXOBJ_BASE + 257)
#define DISPIDTHTH_SETSOUND             (DISPID_NXOBJ_BASE + 258)
#define DISPIDTHTH_GETICON              (DISPID_NXOBJ_BASE + 259)
#define DISPIDTHTH_SETICON              (DISPID_NXOBJ_BASE + 260)
#define DISPIDTHTH_GETICONBYKEY         (DISPID_NXOBJ_BASE + 261)
#define DISPIDTHTH_SETICONBYKEY         (DISPID_NXOBJ_BASE + 262)
#define DISPIDTHTH_GETWEBVW             (DISPID_NXOBJ_BASE + 263)
#define DISPIDTHTH_SETWEBVW             (DISPID_NXOBJ_BASE + 264)


// IThemeScheme Properties
#define DISPIDTHTS_SCHDISPNAME          (DISPID_NXOBJ_BASE + 301)
#define DISPIDTHTS_SCHEMEPATH           (DISPID_NXOBJ_BASE + 302)
#define DISPIDTHTS_LENGTH               (DISPID_NXOBJ_BASE + 303)
#define DISPIDTHTS_ITEM                 (DISPID_NXOBJ_BASE + 304)
#define DISPIDTHTS_SELECTEDSTYLE        (DISPID_NXOBJ_BASE + 305)
// IThemeScheme Methods
#define DISPIDTHTS_ADDSTYLE             (DISPID_NXOBJ_BASE + 350)


// IThemeStyle Properties
#define DISPIDTHSY_DISPNAME             (DISPID_NXOBJ_BASE + 400)
#define DISPIDTHSY_NAME                 (DISPID_NXOBJ_BASE + 401)
#define DISPIDTHSY_LENGTH               (DISPID_NXOBJ_BASE + 402)
#define DISPIDTHSY_ITEM                 (DISPID_NXOBJ_BASE + 403)
#define DISPIDTHSY_SELECTEDSIZE         (DISPID_NXOBJ_BASE + 404)
// IThemeStyle Methods
#define DISPIDTHSY_ADDSIZE              (DISPID_NXOBJ_BASE + 450)


// IThemeSize Properties
#define DISPIDTHSZ_DISPNAME             (DISPID_NXOBJ_BASE + 500)
#define DISPIDTHSZ_NAME                 (DISPID_NXOBJ_BASE + 501)
#define DISPIDTHSZ_SYSMETCOLOR          (DISPID_NXOBJ_BASE + 502)
#define DISPIDTHSZ_SYSMETSIZE           (DISPID_NXOBJ_BASE + 503)
#define DISPIDTHSZ_WEBVIEWCSS           (DISPID_NXOBJ_BASE + 504)
#define DISPIDTHSZ_CONTRASTLVL          (DISPID_NXOBJ_BASE + 505)
// IThemeSize Methods
#define DISPIDTHSZ_GETSYSMETFONT        (DISPID_NXOBJ_BASE + 550)
#define DISPIDTHSZ_PUTSYSMETFONT        (DISPID_NXOBJ_BASE + 551)

// IThemePreview Methods
#define DISPIDTHPV_UPDATE               (DISPID_NXOBJ_BASE + 650)
#define DISPIDTHPV_CREATEPREVIEW        (DISPID_NXOBJ_BASE + 651)

#define SZ_HELPTHTM_GETCURRENTTHEME                 helpstring("Get the current theme")
#define SZ_HELPTHTM_PUTCURRENTTHEME                 helpstring("Set the current theme")
#define SZ_HELPTHTM_GETLENGTH                       helpstring("Get the number of existing themes")
#define SZ_HELPTHTM_GETITEM                         helpstring("Get a theme by its index")
#define SZ_HELPTHTM_INSTALLTHEME                    helpstring("Install the theme specified by the path")
#define SZ_HELPTHTM_GETSELECTEDSCHEME               helpstring("Get the currently selected scheme")
#define SZ_HELPTHTM_PUTSELECTEDSCHEME               helpstring("Set the currently selected scheme")
#define SZ_HELPTHTM_WEBVIEWCSS                      helpstring("Get the webview CSS file.")
#define SZ_HELPTHTM_GETSCHEMELENGTH                 helpstring("Get the number of existing schemes")
#define SZ_HELPTHTM_GETSCHEMEITEM                   helpstring("Get a scheme by its index")

#define SZ_HELPTHTM_GETSELSCHPROPERTY               helpstring("Get a property of a special marked scheme.  Like a filename, displayname, or canonical name.")
#define SZ_HELPTHTM_GETSPECIALTHEME                 helpstring("Get a special theme by name")
#define SZ_HELPTHTM_SETSPECIALTHEME                 helpstring("Set a special theme by name")
#define SZ_HELPTHTM_GETSPECIALSCHEME                helpstring("Get a special scheme by name")
#define SZ_HELPTHTM_SETSPECIALSCHEME                helpstring("Set a special scheme by name")
#define SZ_HELPTHTM_APPLYNOW                        helpstring("Apply the settings now")

#define SZ_HELPTHTH_GETDISPLAYNAME                  helpstring("Get the display name for the theme")
#define SZ_HELPTHTH_PUTDISPLAYNAME                  helpstring("Set the display name for the theme")
#define SZ_HELPTHTH_GETPATH                         helpstring("Get the path to the theme file")
#define SZ_HELPTHTH_PUTPATH                         helpstring("Set the path to the theme file")
#define SZ_HELPTHTH_GETVS                           helpstring("Get the path to the Visual Style file")
#define SZ_HELPTHTH_PUTVS                           helpstring("Set the path to the Visual Style file")
#define SZ_HELPTHTH_GETVSCOLOR                      helpstring("Get the path to the Visual Style color")
#define SZ_HELPTHTH_PUTVSCOLOR                      helpstring("Set the path to the Visual Style color")
#define SZ_HELPTHTH_GETVSSIZE                       helpstring("Get the path to the Visual Style size")
#define SZ_HELPTHTH_PUTVSSIZE                       helpstring("Set the path to the Visual Style size")
#define SZ_HELPTHTH_GETBKGD                         helpstring("Get the background picture path")
#define SZ_HELPTHTH_PUTBKGD                         helpstring("Set the background picture path")
#define SZ_HELPTHTH_GETBKGDTILE                     helpstring("Get the background tile method")
#define SZ_HELPTHTH_PUTBKGDTILE                     helpstring("Set the background tile method")
#define SZ_HELPTHTH_GETCURSOR                       helpstring("Get a cursor's filename")
#define SZ_HELPTHTH_PUTCURSOR                       helpstring("Set a cursor's filename")
#define SZ_HELPTHTH_GETSOUND                        helpstring("Get a sound's filename")
#define SZ_HELPTHTH_PUTSOUND                        helpstring("Set a sound's filename")
#define SZ_HELPTHTH_GETICON                         helpstring("Get an icon's filename")
#define SZ_HELPTHTH_PUTICON                         helpstring("Set an icon's filename")
#define SZ_HELPTHTH_GETICONBYKEY                    helpstring("Get an icon's filename by specifying the registry key")
#define SZ_HELPTHTH_PUTICONBYKEY                    helpstring("Set an icon's filename by specifying the registry key")
#define SZ_HELPTHTH_GETSCRNSAVER                    helpstring("Get the ScreenSaver filename")
#define SZ_HELPTHTH_PUTSCRNSAVER                    helpstring("Get the ScreenSaver filename")
#define SZ_HELPTHTH_GETWEBVW                        helpstring("Get a webview's filename")
#define SZ_HELPTHTH_PUTWEBVW                        helpstring("Set a webview's filename")
#define SZ_HELPTHTH_GETLENGTH                       helpstring("Get the number of existing schemes")
#define SZ_HELPTHTH_GETITEM                         helpstring("Get a scheme by its index")
#define SZ_HELPTHTH_GETSELECTEDSCHEME               helpstring("Get the currently selected scheme")
#define SZ_HELPTHTH_PUTSELECTEDSCHEME               helpstring("Set the currently selected scheme")

#define SZ_HELPTHTS_GETSCHDISPNAME                  helpstring("Get the display name for the scheme")
#define SZ_HELPTHTS_PUTSCHDISPNAME                  helpstring("Set the display name for the scheme")
#define SZ_HELPTHTS_GETSCHEMEPATH                   helpstring("Get the path to the scheme file")
#define SZ_HELPTHTS_PUTSCHEMEPATH                   helpstring("Set the path to the scheme file")
#define SZ_HELPTHTS_GETLENGTH                       helpstring("Get the number of existing theme styles")
#define SZ_HELPTHTS_GETITEM                         helpstring("Get a style by its index")
#define SZ_HELPTHTS_GETSELECTEDSTYLE                helpstring("Get the currently selected style")
#define SZ_HELPTHTS_PUTSELECTEDSTYLE                helpstring("Set the currently selected style")
#define SZ_HELPTHTS_ADDSTYLE                        helpstring("Add a style")

#define SZ_HELPTHSY_GETDISPNAME                     helpstring("Get the display name for the style")
#define SZ_HELPTHSY_PUTDISPNAME                     helpstring("Set the display name for the style")
#define SZ_HELPTHSY_GETNAME                         helpstring("Get the canonical name for the style")
#define SZ_HELPTHSY_PUTNAME                         helpstring("Set the canonical name for the style")
#define SZ_HELPTHSY_GETLENGTH                       helpstring("Get the number of existing theme sizes")
#define SZ_HELPTHSY_GETITEM                         helpstring("Get a size by its index")
#define SZ_HELPTHSY_GETSELECTEDSIZE                 helpstring("Get the currently selected size")
#define SZ_HELPTHSY_PUTSELECTEDSIZE                 helpstring("Set the currently selected size")
#define SZ_HELPTHSY_ADDSIZE                         helpstring("Add a size")

#define SZ_HELPTHSZ_GETDISPNAME                     helpstring("Get the display name for the size")
#define SZ_HELPTHSZ_PUTDISPNAME                     helpstring("Set the display name for the size")
#define SZ_HELPTHSZ_GETNAME                         helpstring("Get the canonical name for the size")
#define SZ_HELPTHSZ_PUTNAME                         helpstring("Set the canonical name for the size")
#define SZ_HELPTHSZ_GETSYSMETCOLOR                  helpstring("Get the specified SystemMetric color")
#define SZ_HELPTHSZ_PUTSYSMETCOLOR                  helpstring("Set the specified SystemMetric color")
#define SZ_HELPTHSZ_GETSYSMETFONT                   helpstring("Get the specified SystemMetric font")
#define SZ_HELPTHSZ_PUTSYSMETFONT                   helpstring("Set the specified SystemMetric font")
#define SZ_HELPTHSZ_GETSYSMETSIZE                   helpstring("Get the specified SystemMetric size")
#define SZ_HELPTHSZ_PUTSYSMETSIZE                   helpstring("Set the specified SystemMetric size")
#define SZ_HELPTHSZ_WEBVIEWCSS                      helpstring("Get the webview CSS file.")
#define SZ_HELPTHSZ_GETCONTRASTLVL                  helpstring("Get the scheme's contrast level.")
#define SZ_HELPTHSZ_PUTCONTRASTLVL                  helpstring("Set the scheme's contrast level.")
#define SZ_HELPTHPV_UPDATE                          helpstring("Update the preview based on changes")
#define SZ_HELPTHPV_CREATEPREVIEW                   helpstring("Create the preview window")

#define _THEMEIDLID_H_
#endif // _THEMEIDLID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\shellids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//
//  Contents:   Helpids for Shell Help project (windows.hlp) - the help ids
//              in this DLL are for shell componentns (not browser only or redist)
//              ie.  Shdoc401 has a "fixed in stone" version of this headerfile
//              for the "update.hlp" help file shipped with IE.
//              ("iexplore.hlp" is used for shdocvw.dll/browseui.dll.  see iehelpid.h)
//
//  Please keep this file ordered by help ID.  That way we can
//  find space for new ids easily.
//

#define IDH_MYDOCS_TARGET       1101
#define IDH_MYDOCS_BROWSE       1102
#define IDH_MYDOCS_FIND_TARGET  1103
#define IDH_MYDOCS_RESET        1104

// Background Tab implemented in shell32.dll (Win2K version) which replaces
// the background tab implemented in desk.cpl.  The "Background" tab has been
// renamed to "Desktop" in Whistler
// (The corresponding help texts for these IDs are in "Display.hlp")
#define IDH_DISPLAY_BACKGROUND_MONITOR              4000
#define IDH_DISPLAY_BACKGROUND_WALLPAPERLIST        4001
#define IDH_DISPLAY_BACKGROUND_BROWSE_BUTTON        4002
#define IDH_DISPLAY_BACKGROUND_PICTUREDISPLAY       4003
#define IDH_DISPLAY_BACKGROUND_DISPLAY_TILE         4004
#define IDH_DISPLAY_BACKGROUND_DISPLAY_CENTER       4005
#define IDH_DISPLAY_BACKGROUND_DISPLAY_STRETCH      4006
#define IDH_DISPLAY_BACKGROUND_PATTERN_BUTTON       4007
#define IDH_DISPLAY_BACKGROUND_PATTERN_PATTERNLIST  4008
#define IDH_DISPLAY_BACKGROUND_PATTERN_PREVIEW      4009
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_BUTTON   4010
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_NAME     4011
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_SAMPLE   4012
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_PATTERN  4013
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_DONE     4177
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_ADD      4178
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_CHANGE   4179
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_REMOVE   4180
#define IDH_DISPLAY_BACKGROUND_DESKTOP_ITEMS        4181        // This brings up the "Desktop Items..." dialog, previously the "Web" tab.
#define IDH_DISPLAY_BACKGROUND_BACKGROUND_COLOR     4182        // This is the help for the Color Picking control that lets users change their background color

// Web Tab implemented in shell32.dll (Win2K version)
// (The corresponding help texts for these IDs are in "Display.hlp")
#define IDH_DISPLAY_WEB_GRAPHIC                     4500
#define IDH_DISPLAY_WEB_SHOWWEB_CHECKBOX            4501
#define IDH_DISPLAY_WEB_ACTIVEDESKTOP_LIST          4502
#define IDH_DISPLAY_WEB_NEW_BUTTON                  4503
#define IDH_DISPLAY_WEB_DELETE_BUTTON               4504
#define IDH_DISPLAY_WEB_PROPERTIES_BUTTON           4505
#define IDH_DISPLAY_WEB_SYNCHRONIZE_BUTTON          4506


// For Display Properties, Background Tab (implemented in shdoc401.dll)
#define IDH_GROUPBOX                       51000
#define IDH_WALLPAPER_LIST                 51001
#define IDH_BROWSE_WALLPAPER               51002
#define IDH_DESKTOP_PATTERN                51003
#define IDH_DISPLAY_WALLPAPER              51004
#define IDH_DISABLE_ACTIVE_DESKTOP         51005
#define IDH_WALLPAPER_SAMPLE               51006

// For Properties button (implemented in shdoc401.dll)
#define IDH_DISPLAY_PATTERN                51010
#define IDH_EDIT_PATTERN                   51011

// For Pattern Editor (implemented in shdoc401.dll)
#define IDH_PATTERN_NAME                   51012
#define IDH_PATTERN_SAMPLE                 51013
#define IDH_PATTERN_EDIT                   51014
#define IDH_ADD_PATTERN                    51015
#define IDH_CHANGE_PATTERN                 51016
#define IDH_REMOVE_PATTERN                 51017

// For Display Properties, Web tab (implemented in shdoc401.dll)
#define IDH_LIST_CHANNELS                  51020
#define IDH_NEW_CHANNEL                    51021
#define IDH_DELETE_CHANNEL                 51022
#define IDH_CHANNEL_PROPERTIES             51023
#define IDH_TRY_IT                         51024
#define IDH_RESET_ALL                      51025
#define IDH_DISPLAY_CHANNELS               51027
#define IDH_VIEW_AS_WEB_PAGE               51026
#define IDH_FOLDER_OPTIONS                 51029

// For Web tab, Properties button, Subscription tab
#define IDH_SUBSCRIBED_URL                 51030
#define IDH_SUBSCRIPTION_SUMMARY           51031
// Login button
#define IDH_CHANNEL_LOGIN                  51032
// Login Options dialog
#define IDH_LOGIN_USER_ID                  51033
#define IDH_LOGIN_PASSWORD                 51034


// For Web tab, Properties button, Receiving tab
#define IDH_EMAIL_NOTIFICATION             51035
#define IDH_DOWNLOAD                       51036
#define IDH_ADVANCED                       51028
// Change Address button
#define IDH_CHANGE_ADDRESS                 51037
// Mail Options dialog
#define IDH_EMAIL_ADDRESS                  51038
#define IDH_EMAIL_SERVER                   51039

// Advanced Download Options dialog
#define IDH_MAX_DOWNLOAD                   51040
#define IDH_HIGH_PRIORITY                  51041
#define IDH_DOWNLOAD_IMAGES                51042
#define IDH_DOWNLOAD_SOUND                 51043
#define IDH_DOWNLOAD_ACTIVEX               51044
#define IDH_DOWNLOAD_PAGES_DEEP            51045
#define IDH_FOLLOW_LINKS                   51046

// For Web tab, Properties button, Schedule tab
#define IDH_AUTO_SCHEDULE                  51050
#define IDH_CUSTOM_SCHEDULE                51051
#define IDH_MANUAL_SCHEDULE                51052

// For Custom Schedule dialog
#define IDH_NEW_NAME                       51053
#define IDH_SCHED_DAYS                     51054
#define IDH_SCHED_FREQUENCY                51055
#define IDH_SCHED_TIME                     51056
#define IDH_SCHED_REPEAT                   51057
#define IDH_VARY_START                     51058

// For View, Options, General tab, Folders and desktop (My Computer)
//#define IDH_SAMPLE_GRAPHIC                 51060 // shdoc401
//#define IDH_WEB_VIEW                       51061 // shdoc401

//  View\Options menu, Files Types tab, Add New File Type dialog box
#define  IDH_MIME_TYPE                     51063
#define  IDH_DEFAULT_EXT                   51064
#define  IDH_CONFIRM_OPEN                  51065
#define  IDH_SAME_WINDOW                   51066

//  View\Options menu, File Types tab
#define  IDH_EXTENSION                     51067
#define  IDH_OPENS_WITH                    51068

// For View, Options, View tab (My Computer)
//#define IDH_SHOW_MAP_NETWORK               51070 // shdoc401 selfreg
#define IDH_SHOW_FILE_ATTRIB               51071
#define IDH_ALLOW_UPPERCASE                51072 // shell32 selfreg
#define IDH_SMOOTH_EDGES                   51073 // shell32 selfreg
#define IDH_SHOW_WINDOW                    51074 // shell32 selfreg
#define IDH_RESTORE_DEFAULT                51075
#define IDH_VIEW_STATE                     51076 // shell32 selfreg
#define IDH_USE_CURRENT_FOLDER             51077
#define IDH_RESET_TO_ORIGINAL              51078
#define IDH_FOLDERS_IN_SEP_PROCESS         51079 // shell32 selfreg

// For Folder Properties, General tab
#define IDH_PROPERTIES_GENERAL_THUMBNAIL   51080

// For Browse for Folder (right-click taskbar, Toolbar, New Toolbar)
#define IDH_BROWSE_FOLDER_ADDRESS          51082

//   Display properties, Screen Saver tab, Channel Screen Saver settings
#define  IDH_CHANNELS_LIST                 51083
#define  IDH_SET_LENGTH                    51084
#define  IDH_PLAY_SOUNDS                   51085
#define  IDH_CLOSE_SCREENSAVER             51086

//  Subscription properties, Unsubscribe button
#define  IDH_UNSUBSCRIBE                   51087

//  Subscription properties, Schedule
#define  IDH_SCHEDULE_NEW                  51088
#define  IDH_SCHEDULE_REMOVE               51089

// For View, Options, General tab, Folders and desktop (My Computer)
//#define IDH_CLASSIC_STYLE                  51090 // shdoc401
//#define IDH_CUSTOM                         51091 // shdoc401

// For View, Options, General Tab
#define IDH_BROWSE_SAME_WINDOW             51092
#define IDH_BROWSE_SEPARATE_WINDOWS        51093
#define IDH_SHOW_WEB_WHEN_POSSIBLE         51094
#define IDH_SHOW_WEB_WHEN_CHOOSE           51095
#define IDH_SINGLE_CLICK_MODE              51096
#define IDH_TITLES_LIKE_LINKS              51097
#define IDH_TITLES_WHEN_POINT              51098
#define IDH_DOUBLE_CLICK_MODE              51099

// For View, Folder Options, Advanced
#define IDH_FULL_PATH                      51100 // shell32 selfreg
#define IDH_HIDE_EXTENSIONS                51101 // shell32 selfreg
#define IDH_SHOW_TIPS                      51102 // shell32 selfreg
#define IDH_HIDE_HIDDEN_SYSTEM             51103 // shell32 selfreg
#define IDH_HIDE_HIDDEN_ONLY               51104 // shell32 selfreg
#define IDH_SHOW_ALL                       51105 // shell32 selfreg
#define IDH_HIDE_ICONS                     51106 // shell32 selfreg
#define IDH_FULL_PATH_ADDRESSBAR           51107 // shdoc401

// For View, Options, General Tab
#define IDH_ENABLE_WEB_CONTENT             51108
#define IDH_USE_WINDOWS_CLASSIC            51109
//#define IDH_CUSTOMIZE_ACTIVE_DESKTOP       51110 // shdoc401
#define IDH_ACTIVEDESKTOP_GEN              51111
#define IDH_WEB_VIEW_GEN                   51112
#define IDH_BROWSE_FOLDERS_GEN             51113
#define IDH_ICON_OPEN_GEN                  51114
#define IDH_RESTORE_DEFAULTS_GEN           51115


// For Folder Customization Wizard
// Start Page
#define IDH_FCW_CHOOSE_OR_EDIT_TEMPLATE    51116
#define IDH_FCW_CHOOSE_BACKGROUND_PICTURE  51117
#define IDH_FCW_REMOVE_CUST                51118
#define IDH_FCW_DESCRIBE_CHOICE            51119
// Template Page
#define IDH_FCW_TEMPLATE_LIST              51120
#define IDH_FCW_TEMPLATE_PREVIEW           51121
#define IDH_FCW_DESCRIBE_TEMPLATE          51122
#define IDH_FCW_ENABLE_EDITING             51123
// Background Page
#define IDH_FCW_BACKGROUND_PREVIEW         51124
#define IDH_FCW_BACKGROUND_LIST            51125
#define IDH_FCW_BACKGROUND_BROWSE          51126
#define IDH_FCW_ICON_TEXT_COLOR            51127
#define IDH_FCW_ENABLE_ICON_BACKGROUND_COLOR    51128
#define IDH_FCW_ICON_BACKGROUND_COLOR      51129

#define IDH_SHOW_COMP_COLOR                51130 // shell32 selfreg
#define IDH_HIDDEN_FILES_GROUP             51131 // shell32 selfreg
#define IDH_STARTMENU                      51132 // shell32 selfreg
#define IDH_STARTMENU_FAVORITES            51133 // shell32 selfreg
#define IDH_STARTMENU_LOGOFF               51134 // shell32 selfreg
#define IDH_STARTMENU_CONTROLPANEL         51135 // shell32 selfreg
#define IDH_STARTMENU_MYDOCUMENTS          51136 // shell32 selfreg
#define IDH_STARTMENU_PRINTERS             51137 // shell32 selfreg
#define IDH_STARTMENU_SCROLLPROGRAMS       51138 // shell32 selfreg
#define IDH_STARTMENU_INTELLIMENUS         51139 // shell32 selfreg
#define IDH_FILES_AND_FOLDERS              51140 // shell32 selfreg

#define IDH_SHOW_MY_DOCUMENTS              51141 // mydocs selfreg (shell.hlp)

#define IDH_TASKBAR_EXPAND_NETCONNECT      51141 // shell32 selfreg
#define IDH_TASKBAR_DISPLAY_RUN            51142 // shell32 selfreg
#define IDH_TASKBAR_SIZE_MOVE              51143 // shell32 selfreg
#define IDH_TASKBAR_CONTEXTMENU            51144 // shell32 selfreg
#define IDH_TASKBAR_STARTMENU_DRAGDROP     51145 // shell32 selfreg
#define IDH_TASKBAR_EXPAND_MYPICTURES      51146 // shell32 selfreg

#define IDH_DISABLE_NETCRAWLER             51147 // shell32 selfreg
#define IDH_HIDE_CONTENT                   51148 // shell32 selfreg
#define IDH_FRIENDLY_TREE                  51149 // shell32 selfreg

// Themes Tab in Display Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_THEMES_PREVIEW               51190       // Preview window
#define IDH_DISPLAY_THEMES_LIST                 51191       // Drop Down containing Plus! Themes
#define IDH_DISPLAY_THEMES_SETTINGS             51192       // "Properties" button to Advanced settings.
#define IDH_DISPLAY_THEMES_SAVEAS               51196       // Button for Theme "Save As..."
#define IDH_DISPLAY_THEMES_DELETETHEME          51197       // Button for Theme "Delete"

// Theme Settings: These controls go on the "Theme Settings" dialog
// which is the Advanced dialog for the Theme tab in the Display
// Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_THEMESETTINGS_NAMELABLE     51200
#define IDH_DISPLAY_THEMESETTINGS_NAME          51201
#define IDH_DISPLAY_THEMESETTINGS_LABEL         51202
#define IDH_DISPLAY_THEMESETTINGS_WALLPAPER     51203
#define IDH_DISPLAY_THEMESETTINGS_SOUNDS        51204
#define IDH_DISPLAY_THEMESETTINGS_MOUSE         51205
#define IDH_DISPLAY_THEMESETTINGS_SCREENSAVER   51206
#define IDH_DISPLAY_THEMESETTINGS_ICONS         51207
#define IDH_DISPLAY_THEMESETTINGS_COLORS        51208
#define IDH_DISPLAY_THEMESETTINGS_FONTS         51209
#define IDH_DISPLAY_THEMESETTINGS_BORDERS       51210

// Appearance Tab in Display Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_APPEARANCE_PREVIEW          51220
#define IDH_DISPLAY_APPEARANCE_LOOKFEEL         51221
#define IDH_DISPLAY_APPEARANCE_LOOKFEELLABEL    51222
#define IDH_DISPLAY_APPEARANCE_COLORSCHEMELABEL 51223
#define IDH_DISPLAY_APPEARANCE_COLORSCHEME      51224
#define IDH_DISPLAY_APPEARANCE_WNDSIZELABEL     51225
#define IDH_DISPLAY_APPEARANCE_WNDSIZE          51226 
#define IDH_DISPLAY_APPEARANCE_EFFECTS          51227
#define IDH_DISPLAY_APPEARANCE_ADVANCED         51228

// Desktop Items Dialog: These controls go on the dialog
// that appears when "Desktop Items" is click in the
// Desktop tab of the Display Control Panel.
#define IDH_DESKTOPITEMS_DESKTOPICONS_GROUP     51235
#define IDH_DESKTOPITEMS_ICON_MYDOCS            51236
#define IDH_DESKTOPITEMS_ICON_MYCOMP            51237
#define IDH_DESKTOPITEMS_ICON_MYNET             51238
#define IDH_DESKTOPITEMS_ICON_RECYCLE           51239
#define IDH_DESKTOPITEMS_CHANGEDESKTOPICON_LABEL 51240
#define IDH_DESKTOPITEMS_ICONS                  51241       // List of icons
#define IDH_DESKTOPITEMS_CHANGEICON2            51242       // Change Icon Button
#define IDH_DESKTOPITEMS_ICONDEFAULT            51243       // Default Icon Button
#define IDH_DESKTOPITEMS_DESKTOPWEBPAGES_LABEL  51244
#define IDH_DESKTOPITEMS_DESKCLNR_CHECK         51245
#define IDH_DESKTOPITEMS_DESKCLNR_RUNNOW        51246
#define IDH_DESKTOPITEMS_LOCKDESKITEMS_CHECK    51247
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\uxthemep.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File   : uxthemep.h
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _UXTHEMEP_H_                   
#define _UXTHEMEP_H_                   
//---------------------------------------------------------------------------
#include <uxtheme.h> 
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following routines are provided for use by Theme Selection UI.
//---------------------------------------------------------------------------

//---- bits returned by QueryThemeServices() ----

#define QTS_AVAILABLE  (1 << 0)  // services are available
#define QTS_RUNNING    (1 << 1)  // services are running

//---------------------------------------------------------------------------
//  QueryThemeServices()
//                      - returns flags about theme services (see above)
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) QueryThemeServices();

//---------------------------------------------------------------------------
typedef HANDLE HTHEMEFILE;    // handle to a loaded theme file

//---------------------------------------------------------------------------
//  OpenThemeFile()    - Load specified theme into memory (doesn't apply it)
//
//  pszThemePath       - full path of .msstyles file to load
//
//  pszColorScheme     - (optional) name of theme color scheme to load
//
//  pszSize            - (optional) name of theme size to load
//
//  phThemeFile        - if a theme is successfully opened, this handle
//                        is set to a non-NULL value and holds a ref-count 
//                        on the theme to keep it in loaded in memory.
//
//  fGlobalTheme       - FALSE if it's a preview, TRUE if the theme is intended
//                         to be made permanent for the user
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFile(LPCWSTR pszThemePath, OPTIONAL LPCWSTR pszColorParam,
   OPTIONAL LPCWSTR pszSizeParam, OUT HTHEMEFILE *phThemeFile, BOOL fGlobalTheme);

//---------------------------------------------------------------------------
//  CloseThemeFile()   - decrements the ref-count for the theme identified
//                       by the hThemeFile handle
//
//  hThemeFile         - open handle to the loaded theme file
//---------------------------------------------------------------------------
THEMEAPI CloseThemeFile(HTHEMEFILE hThemeFile);

//---------------------------------------------------------------------------
//--- WM_THEMECHANGED msg parameters (internal use only) ----
//---   "wParam" is the "change number" ----

//---- lParam bits ----
#define WTC_THEMEACTIVE     (1 << 0)        // new theme is now active
#define WTC_CUSTOMTHEME     (1 << 1)        // this msg for custom-themed apps

//---------------------------------------------------------------------------
//---- option flags for ApplyTheme() ----

#define AT_LOAD_SYSMETRICS          (1 << 0)        // apply the theme's metrics w/theme
                                                    // or default classic metrics when
                                                    // turning themes off.

#define AT_PROCESS                  (1 << 1)        // apply to current process only
#define AT_EXCLUDE                  (1 << 2)        // all but the specified process/window
#define AT_CACHETHEME               (1 << 3)        // cache this theme file, if applied

#define AT_NOREGUPDATE              (1 << 4)        // don't update the CU registry for theme info
#define AT_SYNC_LOADMETRICS         (1 << 5)        // load system metrics on calling thread

//---- below flags currently not supported ----
#define AT_DISABLE_FRAME_THEMING    (1 << 10)
#define AT_DISABLE_DIALOG_THEMING   (1 << 11)

//---------------------------------------------------------------------------
//  ApplyTheme()        - Apply (or remove) a loaded theme file globally
//                        or to specified apps/windows.
//
//                        Note that when a theme is applied globally
//                        (hwndTarget is NULL), the theme services manager 
//                        will hold a refcount on the theme file.  This
//                        means that the caller can close his HTHEMEFILE 
//                        handle after the ApplyTheme() call.
//
//                        When the global theme is removed, the theme
//                        services manager will drop is refcount.      
//
//      hThemeFile      - (optional)handle to the loaded theme file. 
//                        if NULL then any theme on target app/windows 
//                        will be removed.
//
//      dwApplyFlags    - options for applying theme (see above)
//
//      hwndTarget      - (optional) only theme this window
//---------------------------------------------------------------------------
THEMEAPI ApplyTheme(OPTIONAL HTHEMEFILE hThemeFile, DWORD dwApplyFlags,
    OPTIONAL HWND hwndTarget);

//---------------------------------------------------------------------------
//  RegisterDefaultTheme()
//                      - registers the specified theme as the default
//                        for all users on the system.
//
//  pszThemeFileName    - the name of the theme file (NULL = no theme)
//
//  fOverride           - if TRUE, will override current default theme
//---------------------------------------------------------------------------
THEMEAPI RegisterDefaultTheme(LPCWSTR pszFileName, BOOL fOverride);

//---------------------------------------------------------------------------
//  THEMECALLBACK is a enum describing the type of callback being done
//---------------------------------------------------------------------------
typedef enum THEMECALLBACK
{
    TCB_THEMENAME,      // theme name enumeration
    TCB_COLORSCHEME,    // color scheme enumeration
    TCB_SIZENAME,       // size name enumeration
    TCB_SUBSTTABLE,     // substitution table enumeration
    TCB_CDFILENAME,     // classdata file name enumeration
    TCB_CDFILECOMBO,    // classdata file color/size combinations

    TCB_FILENAME,         // parsed a filename
    TCB_DOCPROPERTY,      // parsed a standard doc property
    TCB_NEEDSUBST,        // callback to get a substituted symbol
    TCB_MINCOLORDEPTH,    // parsed the min color depth

    //---- localizable property callbacks ----
    TCB_FONT,             // parsed a font string
    TCB_MIRRORIMAGE,      // parsed the MirrorImage property
    TCB_LOCALIZABLE_RECT, // parsed a RECT property that needs to be localizable
};

//---------------------------------------------------------------------------
typedef struct 
{
    WCHAR szName[MAX_PATH+1];
    WCHAR szDisplayName[MAX_PATH+1];
    WCHAR szToolTip[MAX_PATH+1];
} THEMENAMEINFO;

//---------------------------------------------------------------------------
//  THEMEENUMPROC()     - callback used by the theme enum/parsing functions.
//                        the return value is used to continue or abort
//                        the enumeration.
//
//  tcbType             - callback type being made 
//  pszName             - simple name of the item being enumerated
//  pszName2            - varies by callback type
//  pszName3            - varies by callback type
//  iIndex              - index number associated with some items
//  lParam              - callback param supplied by caller
//---------------------------------------------------------------------------
typedef BOOL (CALLBACK* THEMEENUMPROC)(enum THEMECALLBACK tcbType,
    LPCWSTR pszName, OPTIONAL LPCWSTR pszName2, 
    OPTIONAL LPCWSTR pszName3, OPTIONAL int iIndex, LPARAM lParam);

//---------------------------------------------------------------------------
//  EnumThemes()        - calls the callback function "lpEnumFunc" with each 
//                        theme.  During the callback, the filename,
//                        Display name, and tooltip string for each theme
//                        are returned.
//
//  pszThemeRoot        - the theme root directory; each theme DLL found in 
//                        a separate subdir immediately under the theme root 
//                        dir is enumerated.  The root name of the DLL must 
//                        match its containing subdir name
//
//  lpEnumFunc          - ptr to the caller's callback function which will
//                        be called for each theme enumerated
//
//  lParam              - caller's callback parameter (will be passed to
//                        lpEnumFunc())
//---------------------------------------------------------------------------
THEMEAPI EnumThemes(LPCWSTR pszThemeRoot, THEMEENUMPROC lpEnumFunc, 
    LPARAM lParam);

//---------------------------------------------------------------------------
//  EnumThemeSizes()    - support direct enumeration of all available theme
//                        sizes.  
//
//  pszThemeName        - is the name of the theme file.
//  pszColorScheme      - (optional) only sizes for this color are enum-ed
//  dwSizeIndex         - 0-relative index of the size being queryed
//  ptn                 - ptr to struct to receive name strings
//---------------------------------------------------------------------------
THEMEAPI EnumThemeSizes(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, 
    OUT THEMENAMEINFO *ptn);

//---------------------------------------------------------------------------
//  EnumThemeColors()   - support direct enumeration of all available theme
//                        color schemes.  
//
//  pszThemeName        - name of the theme file.
//  pszSizeName         - (optional) only colors for this size are enum-ed
//  dwColorIndex        - 0-relative index of the color being queryed
//  ptn                 - ptr to struct to receive name strings
//---------------------------------------------------------------------------
THEMEAPI EnumThemeColors(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, 
    OUT THEMENAMEINFO *ptn);

//---------------------------------------------------------------------------
//  GetThemeDefaults() - returns the default Color name and default Size
//                       name for the specified theme file
//
//  pszThemeName        - name of the theme file
//
//  pszDefaultColor     - buffer to receive the default color name
//                        (the canonical name, not the display version)
//  cchMaxColorChars    - max chars that pszDefaultColor can contain
//
//  pszDefaultSize      - buffer to receive the default size name
//                        (the canonical name, not the display version)
//  cchMaxSizeChars     - max chars that pszDefaultSize can contain
//---------------------------------------------------------------------------
THEMEAPI GetThemeDefaults(LPCWSTR pszThemeName,
    OUT OPTIONAL LPWSTR pszDefaultColor, int cchMaxColorChars, 
    OUT OPTIONAL LPWSTR pszDefaultSize, int cchMaxSizeChars);

//---------------------------------------------------------------------------
#define PTF_CONTAINER_PARSE         0x0001  // parse as a "themes.ini" file
#define PTF_CLASSDATA_PARSE         0x0002  // parse as a "bigred.ini" classdata file

#define PTF_CALLBACK_COLORSECTION   0x0004  // callback on all [colorscheme.xxx] sections
#define PTF_CALLBACK_SIZESECTION    0x0008  // callback on all [size.xxx] sections
#define PTF_CALLBACK_FILESECTION    0x0010  // callback on all [file.xxx] sections 

#define PTF_CALLBACK_FILENAMES      0x0020  // callback on all "filename=" properties
#define PTF_CALLBACK_LOCALIZATIONS  0x0040  // callback on all localizable properties
#define PTF_CALLBACK_DOCPROPERTIES  0x0080  // callback on all standard properties in [doc] section
#define PTF_QUERY_DOCPROPERTY       0x0100  // query for value of specified property (internal)
#define PTF_CALLBACK_SUBSTTABLE     0x0400  // callback on all [subst.xxx] sections 
#define PTF_CALLBACK_SUBSTSYMBOLS   0x0800  // callback on a substituted symbol (##)
#define PTF_CALLBACK_MINCOLORDEPTH  0x1000  // callback on "MinColorDepth="

//---------------------------------------------------------------------------
//  ParseThemeIniFile() - Parse the "themes.inc" file specified by 
//                        "pszFileName". 

//  pzFileName          - name of the theme.inc file to parse
//  dwParseFlags        - flags that control parsing & callback options
//  pfnCallBack         - ptr to caller-supplied callback function
//  lparam              - caller's callback param
//---------------------------------------------------------------------------
THEMEAPI ParseThemeIniFile(LPCWSTR pszFileName, DWORD dwParseFlags,
    OPTIONAL THEMEENUMPROC pFnCallBack, OPTIONAL LPARAM lparam);

//---------------------------------------------------------------------------
#define THEME_PARSING_ERROR(hr)  (SCODE_CODE(hr) == ERROR_UNKNOWN_PROPERTY)

typedef struct _PARSE_ERROR_INFO
{
    DWORD dwSize;                   // of this structure

    //---- last parse error info ----
    DWORD dwParseErrCode;           // error code from last error
    WCHAR szMsg[2*MAX_PATH];    // value of first param for msg
    WCHAR szFileName[MAX_PATH];     // associated source filename
    WCHAR szSourceLine[MAX_PATH];   // source line
    int iLineNum;                   // source line number
} 
PARSE_ERROR_INFO, *PPARSE_ERROR_INFO;
//---------------------------------------------------------------------------
//  GetThemeParseErrorInfo()
//                      - fill in the PARSE_ERROR_CONTEXT structure
//                        with needed information about the last theme API 
//                        parse error.
//
//  pInfo               - ptr to the PARSE_ERROR_INFO to be filled
//---------------------------------------------------------------------------
THEMEAPI GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo);

//---------------------------------------------------------------------------
// resource base numbers for localizable string tables in a .msstyles file
//---------------------------------------------------------------------------
#define RES_BASENUM_COLORDISPLAYS   1000
#define RES_BASENUM_COLORTOOLTIPS   2000

#define RES_BASENUM_SIZEDISPLAYS    3000
#define RES_BASENUM_SIZETOOLTIPS    4000

#define RES_BASENUM_DOCPROPERTIES   5000        // in order shown in TmSchema.h

#define RES_BASENUM_PROPVALUEPAIRS  6000        // property names & localizable values

//---------------------------------------------------------------------------
//  DrawNCPreview()     - Previews the theme for the NC area of a window
//
//  hdc                 - HDC for preview to be draw into
//  prc                 - RECT for preview
//
//---------------------------------------------------------------------------
#define NCPREV_INACTIVEWINDOW   0x00000001
#define NCPREV_ACTIVEWINDOW     0x00000002
#define NCPREV_MESSAGEBOX       0x00000004
#define NCPREV_RTL              0x00000008

THEMEAPI DrawNCPreview(HDC hdc, DWORD dwFlags, LPRECT prc, LPCWSTR pszVSPath, 
    LPCWSTR pszVSColor, LPCWSTR pszVSSize, NONCLIENTMETRICS* pncm, 
    COLORREF* prgb);


//---------------------------------------------------------------------------
//  DumpLoadedThemeToTextFile()     
//                      - (for internal testing) dumps the contents of the
//                        loaded theme file to the specified text file
//
//      hThemeFile      - the handle of the loaded theme file
//
//      pszTextFile     - path of the text file to create & write to
//
//      fPacked         - TRUE to dump packed objects; FALSE for normal
//                        properties
//
//      fFullInfo       - includes sizes, offsets, paths, etc.  Use FALSE
//                        for info that will be DIFF-ed across builds/machines
//---------------------------------------------------------------------------
THEMEAPI DumpLoadedThemeToTextFile(HTHEMEFILE hThemeFile, 
    LPCWSTR pszTextFile, BOOL fPacked, BOOL fFullInfo);

#ifdef __cplusplus

class CDrawBase;          // forward
class CTextDraw;          // forward

//---------------------------------------------------------------------------
//  CreateThemeDataFromObjects() 
//                      - creates a theme handle from a CBorderFill, 
//                        CImageFile, and/or CTextDraw object.  At lease one
//                        non-NULL ptr must be passed (either or both).
//
//      pDrawObj       - (optional) ptr to an object derived from CDrawBase
//                       NOTE: if pDrawObj is a CImageFile ptr and its
//                       "_pImageData" contains any alpha channel bitmaps,
//                       the bits in those bitmaps will be "pre-multiplied"
//                       for alpha blending.
//
//      pTextObj       - (optional) ptr to a CTextDraw object
//
//      dwOtdFlags     - theme override flags (see OpenThemeDataEx())
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) CreateThemeDataFromObjects(OPTIONAL CDrawBase *pDrawObj, 
    OPTIONAL CTextDraw *pTextObj, DWORD dwOtdFlags);
#endif

//---------------------------------------------------------------------------
//  OpenThemeDataFromFile() 
//                      - Open the theme data for the specified loaded theme
//                        file and semi-colon separated list of class names.  
//                        OpenThemeDataFromFile() will try each class name, 
//                        one at a time, and use the first matching theme info
//                        found.  If none match, "NULL" is returned.  
//
//                        Note: normal controls should NOT use this API;
//                        they should use "OpenThemeData()" (which uses the
//                        current global or app theme).
//
//      hLoadedThemeFile - handle to the loaded theme file.
//
//      hwnd             - (optional) hwnd to base the HTHEME on
//
//      pszClassList     - (optional) class name (or list of names) to match 
//                         to theme data section; if NULL, will get match
//                         to [globals] section.
//
//      fClient          - TRUE if theming a client window with returned 
//                         HTHEME.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, 
    OPTIONAL HWND hwnd, OPTIONAL LPCWSTR pszClassList, BOOL fClient);

//---------------------------------------------------------------------------
//  OpenThemeFileFromData() 
//                      - Open the theme file corresponding to the HTHEME.
//
//      hTheme          - handle to the theme data from OpenThemeData().
//
//      phThemeFile     - ptr to return HTHEMEFILE to.
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFileFromData(HTHEME hTheme, HTHEMEFILE *phThemeFile);

//---------------------------------------------------------------------------
//  GetThemeSysSize96() - Get the value of the specified System size metric. 
//                        (original value authored for 96 dpi)
//
//  hTheme              - the theme data handle (required).  Will return
//                        size from [SysMetrics] section of theme.
//
//  iSizeId             - only the following sizes are supported:
//
//                          SM_CXBORDER   (border width)
//                          SM_CXVSCROLL  (scrollbar width)
//                          SM_CYHSCROLL  (scrollbar height)
//                          SM_CXSIZE     (caption width)
//                          SM_CYSIZE     (caption height)
//                          SM_CXSMSIZE   (small caption width)
//                          SM_CYSMSIZE   (small caption height)
//                          SM_CXMENUSIZE (menubar width)
//                          SM_CYMENUSIZE (menubar height)
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize96(HTHEME hTheme, int iSizeId);

//---------------------------------------------------------------------------
//  GetThemeSysFont96() - Get the LOGFONT for the specified System font. 
//                        (original value authored for 96 dpi)
//
//  hTheme              - the theme data handle (required).  Will return
//                        size from [SysMetrics] section of theme.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont96(HTHEME hTheme, int iFontId, OUT LOGFONT *plf);

//---------------------------------------------------------------------------
//  RefreshThemeForTS() 
//                      - turn themes on/off for current Terminal Server user
//---------------------------------------------------------------------------
THEMEAPI RefreshThemeForTS();

//---------------------------------------------------------------------------
//---- flag bits for OpenThemeDataEx() ----

#define OTD_FORCE_RECT_SIZING   0x0001      // make all parts size to rect
#define OTD_NONCLIENT           0x0002      // set if hTheme to be used for nonclient area
//---------------------------------------------------------------------------
//  OpenThemeDataEx     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//
//  dwFlags              - allows certain overrides of std features
//                         (see OTD_XXX defines above)
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataEx(HWND hwnd, LPCWSTR pszClassList, DWORD dwFlags);

THEMEAPI CheckThemeSignature (LPCWSTR pszName);

//---------------------------------------------------------------------------
//  ClassicGetSystemMetrics( int iMetric );
//  
//  ClassicSystemParametersInfoA( IN UINT uiAction, IN UINT uiParam, 
//                                IN OUT PVOID pvParam, IN UINT fWinIni);
//  ClassicSystemParametersInfoW( IN UINT uiAction, IN UINT uiParam, 
//                                IN OUT PVOID pvParam, IN UINT fWinIni);
//  ClassicAdjustWindowRectEx( IN LPRECT prcWnd, IN DWORD dwStyle, IN BOOL fMenu, IN DWORD dwExStyle );
//
//  These exports correspond to their Win32 API counterparts and ensure that
//  the classic visual style metrics are retrieved.   Theme hooks are shunted.
//---------------------------------------------------------------------------
THEMEAPI_(int)  ClassicGetSystemMetrics( int iMetric );
THEMEAPI_(BOOL) ClassicSystemParametersInfoA( UINT uiAction, UINT uiParam, IN OUT PVOID pvParam, UINT fWinIni);
THEMEAPI_(BOOL) ClassicSystemParametersInfoW( UINT uiAction, UINT uiParam, IN OUT PVOID pvParam, UINT fWinIni);
THEMEAPI_(BOOL) ClassicAdjustWindowRectEx( LPRECT prcWnd, DWORD dwStyle, BOOL fMenu, DWORD dwExStyle );

#ifdef UNICODE
#define ClassicSystemParametersInfo ClassicSystemParametersInfoW
#else  UNICODE
#define ClassicSystemParametersInfo ClassicSystemParametersInfoA
#endif UNICODE 

//---------------------------------------------------------------------------
#define PACKTHEM_VERSION 3      // latest change: localizable properties

//---------------------------------------------------------------------------
#endif // _UXTHEMEP_H_                               
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\systrayp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       SYSTRAY.H
*
*  VERSION:     2.1
*
*  AUTHOR:      Tracy Sharpe / RAL
*
*  DATE:        20 Feb 1994
*
*  Public definitions of the system tray applet (battery meter, PCMCIA, etc).
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  20 Feb 1994 TCS Original implementation.
*  11/8/94     RAL Converted to systray
*  10/23/95    Shawnb Unicode enabled
*
*******************************************************************************/

#ifndef _INC_SYSTRAY
#define _INC_SYSTRAY

#define SYSTRAY_CLASSNAME          TEXT ("SystemTray_Main")

//  Private tray icon notification message sent to the BatteryMeter window.
#define STWM_NOTIFYPOWER                (WM_USER + 201)
#define STWM_NOTIFYPCMCIA               (WM_USER + 202)
#define STWM_NOTIFYVOLUME               (WM_USER + 203)
#define STWM_NOTIFYSTICKYKEYS           (WM_USER + 204)
#define STWM_NOTIFYMOUSEKEYS            (WM_USER + 205)
#define STWM_NOTIFYFILTERKEYS           (WM_USER + 206)
#define STWM_NOTIFYCSC                  (WM_USER + 207)
#define STWM_NOTIFYUSBUI                (WM_USER + 208)

//  Private tray icon notification messages sent to the BatteryMeter window.
#define STWM_ENABLESERVICE              (WM_USER + 220)
#define STWM_GETSTATE                   (WM_USER + 221)

#define STSERVICE_POWER                 1
#define STSERVICE_PCMCIA                2
#define STSERVICE_VOLUME                4
#define STSERVICE_CSC                   8
#define STSERVICE_USBUI                 16
#define STSERVICE_ALL                   31   // Internal

//
//  Flags for the PCMCIA registry entry
//
#define PCMCIA_REGFLAG_NOWARN           1

//      Prototypes
_inline BOOL SysTray_EnableService(int idSTService, BOOL fEnable)
{
	HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
	if (hwndST) 
	{
		SendMessage(hwndST, STWM_ENABLESERVICE, idSTService, fEnable);
		return TRUE;
	}
	else
	{
		if (fEnable) 
		{
			static const TCHAR szOPEN[]     = TEXT ("open");
			static const TCHAR szFILE[]     = TEXT ("SYSTRAY.EXE");
			static const TCHAR szFORMAT[]   = TEXT ("%i");
			TCHAR       szPARAMS[10];
			HINSTANCE   hInst;
      
			wsprintf (szPARAMS, szFORMAT, idSTService);

			hInst = ShellExecute (NULL, szOPEN, szFILE,
								  szPARAMS, NULL, SW_SHOWNOACTIVATE);
			if (hInst <= (HINSTANCE)32)
				return FALSE;
		}
		return TRUE;
	} 
} // End SysTray_EnableService


_inline BOOL SysTray_IsServiceEnabled(WPARAM idSTService)
{
   HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
   if (hwndST) 
   {
      return((BOOL)SendMessage(hwndST, STWM_GETSTATE, idSTService, 0));
   } 
   else 
   {
      return (FALSE);
   }
} // End SysTray_IsServiceEnabled


#endif // _INC_SYSTRAY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\uxtheme.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File   : uxtheme.h
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _UXTHEME_H_
#define _UXTHEME_H_
//---------------------------------------------------------------------------
#include <commctrl.h>
//---------------------------------------------------------------------------
//#if (_WIN32_WINNT >= 0x0500)     // only available on XP
//---------------------------------------------------------------------------
// Define API decoration for direct importing of DLL references.
#ifndef THEMEAPI
#if !defined(_UXTHEME_)
#define THEMEAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define THEMEAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define THEMEAPI          STDAPI
#define THEMEAPI_(type)   STDAPI_(type)
#endif
#endif // THEMEAPI
//---------------------------------------------------------------------------
typedef HANDLE HTHEME;          // handle to a section of theme data for class

//---------------------------------------------------------------------------
// NOTE: PartId's and StateId's used in the theme API are defined in the 
//       hdr file <tmschema.h> using the TM_PART and TM_STATE macros.  For
//       example, "TM_PART(BP, PUSHBUTTON)" defines the PartId "BP_PUSHBUTTON".

//---------------------------------------------------------------------------
//  OpenThemeData()     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeData(HWND hwnd, LPCWSTR pszClassList);

//---------------------------------------------------------------------------
//  CloseTHemeData()    - closes the theme data handle.  This should be done 
//                        when the window being themed is destroyed or
//                        whenever a WM_THEMECHANGED msg is received 
//                        (followed by an attempt to create a new Theme data 
//                        handle).
//
//  hTheme              - open theme data handle (returned from prior call
//                        to OpenThemeData() API).
//---------------------------------------------------------------------------
THEMEAPI CloseThemeData(HTHEME hTheme);

//---------------------------------------------------------------------------
//    functions for basic drawing support 
//---------------------------------------------------------------------------
// The following methods are the theme-aware drawing services.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// For the list of all themed classes and the definition of all
// parts and states, see the file "tmschmea.h".
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Note: draw operations are always scaled to fit (and not to exceed)  
// the specified "Rect".
//-----------------------------------------------------------------------

//------------------------------------------------------------------------
//  DrawThemeBackground()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pClipRect           - optional clipping rect (don't draw outside it)
//------------------------------------------------------------------------
THEMEAPI DrawThemeBackground(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect);

//---------------------------------------------------------------------------
//----- DrawThemeText() flags ----

#define DTT_GRAYED      0x1         // draw a grayed-out string  

//-------------------------------------------------------------------------
//  DrawThemeText()     - draws the text using the theme-specified 
//                        color and font for the "iPartId" and 
//                        "iStateId".  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pszText             - actual text to draw
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  dwTextFlags2        - additional drawing options 
//  pRect               - defines the size/location of the part
//-------------------------------------------------------------------------
THEMEAPI DrawThemeText(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    DWORD dwTextFlags2, const RECT *pRect);

//-------------------------------------------------------------------------
//  GetThemeBackgroundContentRect()
//                      - gets the size of the content for the theme-defined 
//                        background.  This is usually the area inside
//                        the borders or Margins.  
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pBoundingRect   - the outer RECT of the part being drawn
//      pContentRect    - RECT to receive the content area
//-------------------------------------------------------------------------
THEMEAPI GetThemeBackgroundContentRect(HTHEME hTheme, OPTIONAL HDC hdc, 
    int iPartId, int iStateId,  const RECT *pBoundingRect, 
    OUT RECT *pContentRect);

//-------------------------------------------------------------------------
//  GetThemeBackgroundExtent() - calculates the size/location of the theme-
//                               specified background based on the 
//                               "pContentRect".
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pContentRect    - RECT that defines the content area
//      pBoundingRect   - RECT to receive the overall size/location of part
//-------------------------------------------------------------------------
THEMEAPI GetThemeBackgroundExtent(HTHEME hTheme, OPTIONAL HDC hdc,
    int iPartId, int iStateId, const RECT *pContentRect, 
    OUT RECT *pExtentRect);

//-------------------------------------------------------------------------
typedef enum THEMESIZE
{
    TS_MIN,             // minimum size
    TS_TRUE,            // size without stretching
    TS_DRAW,            // size that theme mgr will use to draw part
};
//-------------------------------------------------------------------------
//  GetThemePartSize() - returns the specified size of the theme part
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font into & measure against
//  iPartId             - part number to retrieve size for
//  iStateId            - state number (of the part) 
//  prc                 - (optional) rect for part drawing destination
//  eSize               - the type of size to be retreived
//  psz                 - receives the specified size of the part 
//-------------------------------------------------------------------------
THEMEAPI GetThemePartSize(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
    OPTIONAL RECT *prc, enum THEMESIZE eSize, OUT SIZE *psz);

//-------------------------------------------------------------------------
//  GetThemeTextExtent() - calculates the size/location of the specified 
//                         text when rendered in the Theme Font. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font & measure into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pszText             - the text to be measured
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  pszBoundingRect     - optional: to control layout of text
//  pszExtentRect       - receives the RECT for text size/location
//-------------------------------------------------------------------------
THEMEAPI GetThemeTextExtent(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, 
    DWORD dwTextFlags, OPTIONAL const RECT *pBoundingRect, 
    OUT RECT *pExtentRect);

//-------------------------------------------------------------------------
//  GetThemeTextMetrics()
//                      - returns info about the theme-specified font
//                        for the part/state passed in.
//
//  hTheme              - theme data handle
//  hdc                 - optional: HDC for screen context
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  ptm                 - receives the font info
//-------------------------------------------------------------------------
THEMEAPI GetThemeTextMetrics(HTHEME hTheme, OPTIONAL HDC hdc, 
    int iPartId, int iStateId, OUT TEXTMETRIC* ptm);

//-------------------------------------------------------------------------
//  GetThemeBackgroundRegion()
//                      - computes the region for a regular or partially 
//                        transparent theme-specified background that is 
//                        bound by the specified "pRect".
//                        If the rectangle is empty, sets the HRGN to NULL 
//                        and return S_FALSE.
//
//  hTheme              - theme data handle
//  hdc                 - optional HDC to draw into (DPI scaling)
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pRect               - the RECT used to draw the part
//  pRegion             - receives handle to calculated region
//-------------------------------------------------------------------------
THEMEAPI GetThemeBackgroundRegion(HTHEME hTheme, OPTIONAL HDC hdc,  
    int iPartId, int iStateId, const RECT *pRect, OUT HRGN *pRegion);

//-------------------------------------------------------------------------
//----- HitTestThemeBackground, HitTestThemeBackgroundRegion flags ----

//  Theme background segment hit test flag (default). possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTTOP, HTLEFT, HTTOPLEFT, etc:  // hit test succeeded in the the respective theme background segment.
#define HTTB_BACKGROUNDSEG          0x0000  

//  Fixed border hit test option.  possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTBORDER: hit test succeeded in any other background segment
#define HTTB_FIXEDBORDER            0x0002  // Return code may be either HTCLIENT or HTBORDER. 

//  Caption hit test option.  Possible return values are:
//  HTCAPTION: hit test succeeded in the top, top left, or top right background segments
//  HTNOWHERE or another return code, depending on absence or presence of accompanying flags, resp.
#define HTTB_CAPTION                0x0004  

//  Resizing border hit test flags.  Possible return values are:
//  HTCLIENT: hit test succeeded in middle background segment
//  HTTOP, HTTOPLEFT, HTLEFT, HTRIGHT, etc:    hit test succeeded in the respective system resizing zone
//  HTBORDER: hit test failed in middle segment and resizing zones, but succeeded in a background border segment
#define HTTB_RESIZINGBORDER_LEFT    0x0010  // Hit test left resizing border, 
#define HTTB_RESIZINGBORDER_TOP     0x0020  // Hit test top resizing border
#define HTTB_RESIZINGBORDER_RIGHT   0x0040  // Hit test right resizing border
#define HTTB_RESIZINGBORDER_BOTTOM  0x0080  // Hit test bottom resizing border

#define HTTB_RESIZINGBORDER         (HTTB_RESIZINGBORDER_LEFT|HTTB_RESIZINGBORDER_TOP|\
                                     HTTB_RESIZINGBORDER_RIGHT|HTTB_RESIZINGBORDER_BOTTOM)

// Resizing border is specified as a template, not just window edges.
// This option is mutually exclusive with HTTB_SYSTEMSIZINGWIDTH; HTTB_SIZINGTEMPLATE takes precedence  
#define HTTB_SIZINGTEMPLATE      0x0100

// Use system resizing border width rather than theme content margins.   
// This option is mutually exclusive with HTTB_SIZINGTEMPLATE, which takes precedence.
#define HTTB_SYSTEMSIZINGMARGINS 0x0200

//-------------------------------------------------------------------------
//  HitTestThemeBackground()
//                      - returns a HitTestCode (a subset of the values 
//                        returned by WM_NCHITTEST) for the point "ptTest" 
//                        within the theme-specified background
//                        (bound by pRect).  "pRect" and "ptTest" should 
//                        both be in the same coordinate system 
//                        (client, screen, etc).
//
//      hTheme          - theme data handle
//      hdc             - HDC to draw into
//      iPartId         - part number to test against
//      iStateId        - state number (of the part) 
//      pRect           - the RECT used to draw the part
//      hrgn            - optional region to use; must be in same coordinates as
//                      -    pRect and pTest.
//      ptTest          - the hit point to be tested
//      dwOptions       - HTTB_xxx constants
//      pwHitTestCode   - receives the returned hit test code - one of:
//  
//                        HTNOWHERE, HTLEFT, HTTOPLEFT, HTBOTTOMLEFT,
//                        HTRIGHT, HTTOPRIGHT, HTBOTTOMRIGHT,
//                        HTTOP, HTBOTTOM, HTCLIENT
//-------------------------------------------------------------------------
THEMEAPI HitTestThemeBackground(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, DWORD dwOptions, const RECT *pRect, OPTIONAL HRGN hrgn, 
    POINT ptTest, OUT WORD *pwHitTestCode);

//------------------------------------------------------------------------
//  DrawThemeEdge()     - Similar to the DrawEdge() API, but uses part colors
//                        and is high-DPI aware
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pDestRect           - the RECT used to draw the line(s)
//  uEdge               - Same as DrawEdge() API
//  uFlags              - Same as DrawEdge() API
//  pContentRect        - Receives the interior rect if (uFlags & BF_ADJUST)
//------------------------------------------------------------------------
THEMEAPI DrawThemeEdge(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, 
                       const RECT *pDestRect, UINT uEdge, UINT uFlags, OPTIONAL OUT RECT *pContentRect);

//------------------------------------------------------------------------
//  DrawThemeIcon()     - draws an image within an imagelist based on 
//                        a (possible) theme-defined effect. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pRect               - the RECT to draw the image within
//  himl                - handle to IMAGELIST 
//  iImageIndex         - index into IMAGELIST (which icon to draw)
//------------------------------------------------------------------------
THEMEAPI DrawThemeIcon(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, const RECT *pRect, HIMAGELIST himl, int iImageIndex);

//---------------------------------------------------------------------------
//  IsThemePartDefined() - returns TRUE if the theme has defined parameters
//                         for the specified "iPartId" and "iStateId".
//
//  hTheme              - theme data handle
//  iPartId             - part number to find definition for
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemePartDefined(HTHEME hTheme, int iPartId, 
    int iStateId);

//---------------------------------------------------------------------------
//  IsThemeBackgroundPartiallyTransparent()
//                      - returns TRUE if the theme specified background for 
//                        the part/state has transparent pieces or 
//                        alpha-blended pieces.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeBackgroundPartiallyTransparent(HTHEME hTheme, 
    int iPartId, int iStateId);

//---------------------------------------------------------------------------
//    lower-level theme information services
//---------------------------------------------------------------------------
// The following methods are getter routines for each of the Theme Data types.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Each method also take a "iPropId" param because multiple instances of 
// the same primitive type can be defined in the theme schema.
//-----------------------------------------------------------------------


//-----------------------------------------------------------------------
//  GetThemeColor()     - Get the value for the specified COLOR property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pColor              - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI GetThemeColor(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT COLORREF *pColor);

//-----------------------------------------------------------------------
//  GetThemeMetric()    - Get the value for the specified metric/size
//                        property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn into (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI GetThemeMetric(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, int iPropId, OUT int *piVal);

//-----------------------------------------------------------------------
//  GetThemeString()    - Get the value for the specified string property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pszBuff             - receives the string property value
//  cchMaxBuffChars     - max. number of chars allowed in pszBuff
//-----------------------------------------------------------------------
THEMEAPI GetThemeString(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LPWSTR pszBuff, int cchMaxBuffChars);

//-----------------------------------------------------------------------
//  GetThemeBool()      - Get the value for the specified BOOL property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pfVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI GetThemeBool(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT BOOL *pfVal);

//-----------------------------------------------------------------------
//  GetThemeInt()       - Get the value for the specified int property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI GetThemeInt(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT int *piVal);

//-----------------------------------------------------------------------
//  GetThemeEnumValue() - Get the value for the specified ENUM property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the enum (cast to int*)
//-----------------------------------------------------------------------
THEMEAPI GetThemeEnumValue(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT int *piVal);

//-----------------------------------------------------------------------
//  GetThemePosition()  - Get the value for the specified position
//                        property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pPoint              - receives the value of the position property
//-----------------------------------------------------------------------
THEMEAPI GetThemePosition(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT POINT *pPoint);

//-----------------------------------------------------------------------
//  GetThemeFont()      - Get the value for the specified font property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn to (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pFont               - receives the value of the LOGFONT property
//                        (scaled for the current logical screen dpi) 
//-----------------------------------------------------------------------
THEMEAPI GetThemeFont(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, int iPropId, OUT LOGFONT *pFont);

//-----------------------------------------------------------------------
//  GetThemeRect()      - Get the value for the specified RECT property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pRect               - receives the value of the RECT property
//-----------------------------------------------------------------------
THEMEAPI GetThemeRect(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT RECT *pRect);

//-----------------------------------------------------------------------
typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//-----------------------------------------------------------------------
//  GetThemeMargins()   - Get the value for the specified MARGINS property
//
//      hTheme          - theme data handle
//      hdc             - (optional) hdc to be used for drawing
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      prc             - RECT for area to be drawn into
//      pMargins        - receives the value of the MARGINS property
//-----------------------------------------------------------------------
THEMEAPI GetThemeMargins(HTHEME hTheme, OPTIONAL HDC hdc, int iPartId, 
    int iStateId, int iPropId, OPTIONAL RECT *prc, OUT MARGINS *pMargins);

//-----------------------------------------------------------------------
#define MAX_INTLIST_COUNT 10

typedef struct _INTLIST
{
    int iValueCount;      // number of values in iValues
    int iValues[MAX_INTLIST_COUNT];
} INTLIST, *PINTLIST;

//-----------------------------------------------------------------------
//  GetThemeIntList()   - Get the value for the specified INTLIST struct
//
//      hTheme          - theme data handle
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      pIntList        - receives the value of the INTLIST property
//-----------------------------------------------------------------------
THEMEAPI GetThemeIntList(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT INTLIST *pIntList);

//-----------------------------------------------------------------------
typedef enum PROPERTYORIGIN
{
    PO_STATE,           // property was found in the state section
    PO_PART,            // property was found in the part section
    PO_CLASS,           // property was found in the class section
    PO_GLOBAL,          // property was found in [globals] section
    PO_NOTFOUND         // property was not found
};

//-----------------------------------------------------------------------
//  GetThemePropertyOrigin()
//                      - searches for the specified theme property
//                        and sets "pOrigin" to indicate where it was 
//                        found (or not found)
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pOrigin             - receives the value of the property origin
//-----------------------------------------------------------------------
THEMEAPI GetThemePropertyOrigin(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT enum PROPERTYORIGIN *pOrigin);

//---------------------------------------------------------------------------
//  SetWindowTheme()
//                      - redirects an existing Window to use a different 
//                        section of the current theme information than its 
//                        class normally asks for.
//
//  hwnd                - the handle of the window (cannot be NULL)
//
//  pszSubAppName       - app (group) name to use in place of the calling
//                        app's name.  If NULL, the actual calling app 
//                        name will be used.
//
//  pszSubIdList        - semicolon separated list of class Id names to 
//                        use in place of actual list passed by the 
//                        window's class.  if NULL, the id list from the 
//                        calling class is used.
//---------------------------------------------------------------------------
// The Theme Manager will remember the "pszSubAppName" and the
// "pszSubIdList" associations thru the lifetime of the window (even 
// if themes are subsequently changed).  The window is sent a 
// "WM_THEMECHANGED" msg at the end of this call, so that the new
// theme can be found and applied.
//---------------------------------------------------------------------------
// When "pszSubAppName" or "pszSubIdList" are NULL, the Theme Manager 
// removes the previously remember association.  To turn off theme-ing for 
// the specified window, you can pass an empty string (L"") so it 
// won't match any section entries.
//---------------------------------------------------------------------------
THEMEAPI SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList);

//---------------------------------------------------------------------------
//  GetThemeFilename()  - Get the value for the specified FILENAME property.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pszThemeFileName    - output buffer to receive the filename
//  cchMaxBuffChars     - the size of the return buffer, in chars
//---------------------------------------------------------------------------
THEMEAPI GetThemeFilename(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT LPWSTR pszThemeFileName, int cchMaxBuffChars);

//---------------------------------------------------------------------------
//  GetThemeSysColor()  - Get the value of the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        color from [SysMetrics] section of theme.
//                        if NULL, will return the global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(COLORREF) GetThemeSysColor(HTHEME hTheme, int iColorId);

//---------------------------------------------------------------------------
//  GetThemeSysColorBrush() 
//                      - Get the brush for the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        brush matching color from [SysMetrics] section of 
//                        theme.  if NULL, will return the brush matching
//                        global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(HBRUSH) GetThemeSysColorBrush(HTHEME hTheme, int iColorId);

//---------------------------------------------------------------------------
//  GetThemeSysBool()   - Get the boolean value of specified System metric. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        BOOL from [SysMetrics] section of theme.
//                        if NULL, will return the specified system boolean.
//
//  iBoolId             - the TMT_XXX BOOL number (first BOOL
//                        is TMT_FLATMENUS)
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) GetThemeSysBool(HTHEME hTheme, int iBoolId);

//---------------------------------------------------------------------------
//  GetThemeSysSize()   - Get the value of the specified System size metric. 
//                        (scaled for the current logical screen dpi) 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        size from [SysMetrics] section of theme.
//                        if NULL, will return the global system metric.
//
//  iSizeId             - the following values are supported when 
//                        hTheme is non-NULL:
//
//                          SM_CXBORDER   (border width)
//                          SM_CXVSCROLL  (scrollbar width)
//                          SM_CYHSCROLL  (scrollbar height)
//                          SM_CXSIZE     (caption width)
//                          SM_CYSIZE     (caption height)
//                          SM_CXSMSIZE   (small caption width)
//                          SM_CYSMSIZE   (small caption height)
//                          SM_CXMENUSIZE (menubar width)
//                          SM_CYMENUSIZE (menubar height)
//
//                        when hTheme is NULL, iSizeId is passed directly
//                        to the GetSystemMetrics() function
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize(HTHEME hTheme, int iSizeId);

//---------------------------------------------------------------------------
//  GetThemeSysFont()   - Get the LOGFONT for the specified System font. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        font from [SysMetrics] section of theme.
//                        if NULL, will return the specified system font.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//                        (scaled for the current logical screen dpi) 
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont(HTHEME hTheme, int iFontId, OUT LOGFONT *plf);

//---------------------------------------------------------------------------
//  GetThemeSysString() - Get the value of specified System string metric. 
//
//  hTheme              - the theme data handle (required)
//
//  iStringId           - must be one of the following values:
//
//                          TMT_CSSNAME
//                          TMT_XMLNAME
//
//  pszStringBuff       - the buffer to receive the string value
//
//  cchMaxStringChars   - max. number of chars that pszStringBuff can hold
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysString(HTHEME hTheme, int iStringId, 
    OUT LPWSTR pszStringBuff, int cchMaxStringChars);

//---------------------------------------------------------------------------
//  GetThemeSysInt() - Get the value of specified System int.
//
//  hTheme              - the theme data handle (required)
//
//  iIntId              - must be one of the following values:
//
//                          TMT_DPIX
//                          TMT_DPIY
//                          TMT_MINCOLORDEPTH
//
//  piValue             - ptr to int to receive value
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysInt(HTHEME hTheme, int iIntId, int *piValue);

//---------------------------------------------------------------------------
//  IsThemeActive()     - can be used to test if a system theme is active
//                        for the current user session.  
//
//                        use the API "IsAppThemed()" to test if a theme is
//                        active for the calling process.
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeActive();

//---------------------------------------------------------------------------
//  IsAppThemed()       - returns TRUE if a theme is active and available to
//                        the current process
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsAppThemed();


//---------------------------------------------------------------------------
//  GetWindowTheme()    - if window is themed, returns its most recent
//                        HTHEME from OpenThemeData() - otherwise, returns
//                        NULL.
//
//      hwnd            - the window to get the HTHEME of
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) GetWindowTheme(HWND hwnd);


//---------------------------------------------------------------------------
//  EnableThemeDialogTexture() 
//
//  - Enables/disables dialog background theme.  This method can be used to 
//    tailor dialog compatibility with child windows and controls that 
//    may or may not coordinate the rendering of their client area backgrounds 
//    with that of their parent dialog in a manner that supports seamless 
//    background texturing.
//
//      hdlg         - the window handle of the target dialog
//      dwFlags      - ETDT_ENABLE to enable the theme-defined dialog background texturing,
//                     ETDT_DISABLE to disable background texturing,
//                     ETDT_ENABLETAB to enable the theme-defined background 
//                          texturing using the Tab texture
//---------------------------------------------------------------------------

#define ETDT_DISABLE        0x00000001
#define ETDT_ENABLE         0x00000002
#define ETDT_USETABTEXTURE  0x00000004
#define ETDT_ENABLETAB      (ETDT_ENABLE  | ETDT_USETABTEXTURE)

THEMEAPI EnableThemeDialogTexture(HWND hwnd, DWORD dwFlags);


//---------------------------------------------------------------------------
//  IsThemeDialogTextureEnabled() 
//
//  - Reports whether the dialog supports background texturing.
//
//      hdlg         - the window handle of the target dialog
//---------------------------------------------------------------------------
THEMEAPI_(BOOL) IsThemeDialogTextureEnabled(HWND hwnd);


//---------------------------------------------------------------------------
//---- flags to control theming within an app ----

#define STAP_ALLOW_NONCLIENT    (1 << 0)
#define STAP_ALLOW_CONTROLS     (1 << 1)
#define STAP_ALLOW_WEBCONTENT   (1 << 2)

//---------------------------------------------------------------------------
//  GetThemeAppProperties()
//                      - returns the app property flags that control theming
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) GetThemeAppProperties();

//---------------------------------------------------------------------------
//  SetThemeAppProperties()
//                      - sets the flags that control theming within the app
//
//      dwFlags         - the flag values to be set
//---------------------------------------------------------------------------
THEMEAPI_(void) SetThemeAppProperties(DWORD dwFlags);

//---------------------------------------------------------------------------
//  GetCurrentThemeName()
//                      - Get the name of the current theme in-use.  
//                        Optionally, return the ColorScheme name and the 
//                        Size name of the theme.
//
//  pszThemeFileName    - receives the theme path & filename
//  cchMaxNameChars     - max chars allowed in pszNameBuff
//
//  pszColorBuff        - (optional) receives the canonical color scheme name
//                        (not the display name)
//  cchMaxColorChars    - max chars allowed in pszColorBuff
//
//  pszSizeBuff         - (optional) receives the canonical size name 
//                        (not the display name)
//  cchMaxSizeChars     - max chars allowed in pszSizeBuff
//---------------------------------------------------------------------------
THEMEAPI GetCurrentThemeName(
    OUT LPWSTR pszThemeFileName, int cchMaxNameChars, 
    OUT OPTIONAL LPWSTR pszColorBuff, int cchMaxColorChars,
    OUT OPTIONAL LPWSTR pszSizeBuff, int cchMaxSizeChars);

//---------------------------------------------------------------------------
//  GetThemeDocumentationProperty()
//                      - Get the value for the specified property name from 
//                        the [documentation] section of the themes.ini file 
//                        for the specified theme.  If the property has been 
//                        localized in the theme files string table, the 
//                        localized version of the property value is returned. 
//
//  pszThemeFileName    - filename of the theme file to query
//  pszPropertyName     - name of the string property to retreive a value for
//  pszValueBuff        - receives the property string value
//  cchMaxValChars      - max chars allowed in pszValueBuff
//---------------------------------------------------------------------------
#define SZ_THDOCPROP_DISPLAYNAME                L"DisplayName"
#define SZ_THDOCPROP_CANONICALNAME              L"ThemeName"
#define SZ_THDOCPROP_TOOLTIP                    L"ToolTip"
#define SZ_THDOCPROP_AUTHOR                     L"author"

THEMEAPI GetThemeDocumentationProperty(LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName, OUT LPWSTR pszValueBuff, int cchMaxValChars);

//---------------------------------------------------------------------------
//  Theme API Error Handling
//
//      All functions in the Theme API not returning an HRESULT (THEMEAPI_) 
//      use the WIN32 function "SetLastError()" to record any call failures.  
//
//      To retreive the error code of the last failure on the
//      current thread for these type of API's, use the WIN32 function 
//      "GetLastError()".
//
//      All Theme API error codes (HRESULT's and GetLastError() values)
//      should be normal win32 errors which can be formatted into
//      strings using the Win32 API FormatMessage().
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// DrawThemeParentBackground()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//
//  hwnd                - handle of the child control

//  hdc                 - hdc of the child control

//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//---------------------------------------------------------------------------
THEMEAPI DrawThemeParentBackground(HWND hwnd, HDC hdc, OPTIONAL RECT* prc);

//---------------------------------------------------------------------------
//  EnableTheming()     - enables or disables themeing for the current user
//                        in the current and future sessions.
//
//  fEnable             - if FALSE, disable theming & turn themes off.
//                      - if TRUE, enable themeing and, if user previously
//                        had a theme active, make it active now.
//---------------------------------------------------------------------------
THEMEAPI EnableTheming(BOOL fEnable);

//------------------------------------------------------------------------
//---- bits used in dwFlags of DTBGOPTS ----
#define DTBG_CLIPRECT        0x00000001   // rcClip has been specified
#define DTBG_DRAWSOLID       0x00000002   // draw transparent/alpha images as solid
#define DTBG_OMITBORDER      0x00000004   // don't draw border of part
#define DTBG_OMITCONTENT     0x00000008   // don't draw content area of part

#define DTBG_COMPUTINGREGION 0x00000010   // TRUE if calling to compute region

#define DTBG_MIRRORDC        0x00000020   // assume the hdc is mirrorred and
                                          // flip images as appropriate (currently 
                                          // only supported for bgtype=imagefile)
//------------------------------------------------------------------------
typedef struct _DTBGOPTS
{
    DWORD dwSize;           // size of the struct
    DWORD dwFlags;          // which options have been specified
    RECT rcClip;            // clipping rectangle
}
DTBGOPTS, *PDTBGOPTS;

//------------------------------------------------------------------------
//  DrawThemeBackgroundEx()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  NOTE: This will be
//                        merged back into DrawThemeBackground() after 
//                        BETA 2.
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pOptions            - ptr to optional params
//------------------------------------------------------------------------
THEMEAPI DrawThemeBackgroundEx(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const DTBGOPTS *pOptions);


//---------------------------------------------------------------------------
//#endif  /* (_WIN32_WINNT >= 0x0500) *// 
//---------------------------------------------------------------------------
#endif // _UXTHEME_H_
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\webvwid.h ===
// Events IDs for Thumb Control
#define DISPID_ONTHUMBNAILREADY                         200
#define DISPID_WEBVIEWFOLDERICON_ONTHUMBNAILREADY       201

// Property IDs for WebView Folder Icon
#define DISPID_PROP_WVFOLDERICON_SCALE                  1
#define DISPID_PROP_WVFOLDERICON_PATH                   2
#define DISPID_PROP_WVFOLDERICON_VIEW                   3
#define DISPID_PROP_WVFOLDERICON_ADVPROPERTY            4

// New for IWebViewFolderIcon2
#define DISPID_WVFOLDERICON_SETSLICE                    5
// New for IWebViewFolderIcon3
#define DISPID_PROP_WVFOLDERICON_ITEM                   6
#define DISPID_PROP_WVFOLDERICON_CLICKSTYLE             7
#define DISPID_PROP_WVFOLDERICON_LABELGAP               8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\uuid\shguids.c ===
#define INITGUID
#include <guiddef.h>

#include <shlguid.h>
#include <commdlg.h>
#include <dsclient.h>
#include <dsclintp.h>
#include <cmnquery.h>
#include <cmnquryp.h>
#include <dsquery.h>
#include <dsqueryp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\uuid\makefile.inc ===
#
# Explicit rules for copying generated *_i.c files from ..\inc\$(O) to $(O)
#

$(O)\chanmgr_i.c : ..\inc\$(O)\chanmgr_i.c
    copy $** $@

$(O)\CommonControls_i.c : ..\inc\$(O)\CommonControls_i.c
    copy $** $@

$(O)\emptyvc_i.c : ..\inc\$(O)\emptyvc_i.c
    copy $** $@

$(O)\imapi_i.c : ..\inc\$(O)\imapi_i.c
    copy $** $@

$(O)\mlang_i.c : ..\inc\$(O)\mlang_i.c
    copy $** $@

$(O)\opsprof_i.c : ..\inc\$(O)\opsprof_i.c
    copy $** $@

$(O)\shappmgr_i.c : ..\inc\$(O)\shappmgr_i.c
    copy $** $@

$(O)\shimgdata_i.c : ..\inc\$(O)\shimgdata_i.c
    copy $** $@

$(O)\shgina_i.c : ..\inc\$(O)\shgina_i.c
    copy $** $@

$(O)\shhelper_i.c : ..\inc\$(O)\shhelper_i.c
    copy $** $@

$(O)\shldisp_i.c : ..\inc\$(O)\shldisp_i.c
    copy $** $@

$(O)\shobjidl_i.c : ..\inc\$(O)\shobjidl_i.c
    copy $** $@

$(O)\tlog_i.c : ..\inc\$(O)\tlog_i.c
    copy $** $@

$(O)\tlogstg_i.c : ..\inc\$(O)\tlogstg_i.c
    copy $** $@

$(O)\vrsscan_i.c : ..\inc\$(O)\vrsscan_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\wire_mar.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File: wire_mar.c
//
//  Contents: wire_marshal routines for shell data types
//
//  History:  18-JUN-99 ZekeL - created file
//
//--------------------------------------------------------------------------

#define DUMMYUNIONNAME
#include <shtypes.h>
#include <ole2.h>

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

ULONG MyILSize(LPCITEMIDLIST pidl)
{
    ULONG cb = 0;
    if (pidl)
    {
        cb = sizeof(pidl->mkid.cb);     // Null terminator
        while (pidl->mkid.cb)
        {
            cb += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }
    return cb;
}

ULONG __RPC_USER LPITEMIDLIST_UserSize(ULONG *pFlags, ULONG StartingSize, LPITEMIDLIST *ppidl)
{
    return StartingSize + sizeof(ULONG) + MyILSize(*ppidl);
}

UCHAR * __RPC_USER LPITEMIDLIST_UserMarshal(ULONG *pFlags, UCHAR *pBuffer, LPITEMIDLIST *ppidl)
{
    ULONG cb = MyILSize(*ppidl);

    //  set the size of the BYTE_BLOB
    *((ULONG UNALIGNED *)pBuffer) = cb;
    pBuffer += sizeof(ULONG);

    if (cb)
    {
        //  copy the pidl over
        memcpy(pBuffer, *ppidl, cb);
    }
    
    return pBuffer + cb;
}

UCHAR * __RPC_USER LPITEMIDLIST_UserUnmarshal(ULONG *pFlags, UCHAR *pBuffer, LPITEMIDLIST *ppidl)
{
    ULONG cb = *((ULONG UNALIGNED *)pBuffer);
    pBuffer += sizeof(ULONG);

    if (cb)
    {
        //ASSERT(cb == MyILSize((LPCITEMIDLIST)pBuffer);
        
        *ppidl = (LPITEMIDLIST)CoTaskMemRealloc(*ppidl, cb);
        if (*ppidl)
        {
            memcpy(*ppidl, pBuffer, cb);
        }
        else
        {
            RpcRaiseException(E_OUTOFMEMORY);
        }
    }
    else 
        *ppidl = NULL;
    
    return pBuffer + cb;
}

void __RPC_USER LPITEMIDLIST_UserFree(ULONG *pFlags, LPITEMIDLIST *ppidl)
{
    CoTaskMemFree(*ppidl);
}

ULONG __RPC_USER LPCITEMIDLIST_UserSize(ULONG *pFlags, ULONG StartingSize, LPCITEMIDLIST *ppidl)
{
    return LPITEMIDLIST_UserSize(pFlags, StartingSize, (LPITEMIDLIST *)ppidl);
}

UCHAR * __RPC_USER LPCITEMIDLIST_UserMarshal(ULONG *pFlags, UCHAR *pBuffer, LPCITEMIDLIST *ppidl)
{
    return LPITEMIDLIST_UserMarshal(pFlags, pBuffer, (LPITEMIDLIST *)ppidl);
}

UCHAR * __RPC_USER LPCITEMIDLIST_UserUnmarshal(ULONG *pFlags, UCHAR *pBuffer, LPCITEMIDLIST *ppidl)
{
    return LPITEMIDLIST_UserUnmarshal(pFlags, pBuffer, (LPITEMIDLIST *)ppidl);
}

void __RPC_USER LPCITEMIDLIST_UserFree(ULONG *pFlags, LPCITEMIDLIST *ppidl)
{
    CoTaskMemFree((LPITEMIDLIST)*ppidl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplication.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplication.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to encapsulate identification of a bad application.
//
//  History:    2000-08-25  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplication.h"

//  --------------------------------------------------------------------------
//  CBadApplication::CBadApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Default constructor for CBadApplication. This just clears the
//              application image name.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplication::CBadApplication (void)

{
    ZeroMemory(&_szImageName, sizeof(_szImageName));
}

//  --------------------------------------------------------------------------
//  CBadApplication::CBadApplication
//
//  Arguments:  pszImageName    =   Image name of application.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CBadApplication. This copies the given
//              application image name.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplication::CBadApplication (const TCHAR *pszImageName)

{
    ZeroMemory(&_szImageName, sizeof(_szImageName));
    lstrcpyn(_szImageName, pszImageName, ARRAYSIZE(_szImageName));
}

//  --------------------------------------------------------------------------
//  CBadApplication::~CBadApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CBadApplication. Releases any resources used.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplication::~CBadApplication (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplication::operator ==
//
//  Arguments:  compareObject   =   Object to compare against.
//
//  Returns:    bool
//
//  Purpose:    Overloaded operator == to facilitate easier comparison on two
//              CBadApplication objects.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

bool    CBadApplication::operator == (const CBadApplication& compareObject) const

{
    return(lstrcmpi(compareObject._szImageName, _szImageName) == 0);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\published\inc\w95wraps.h ===
/*****************************************************************************\
*                                                                             *
* w95wraps.h - Unicode wrappers for ANSI functions on Win95                   *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

//
//  This file is for internal use only.  Do not put it in the SDK.
//

#ifndef _INC_W95WRAPS
#define _INC_W95WRAPS

// no wrappers are needed for non x86, since win9x only runs on x86!
#ifdef _X86_

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_W95WRAPS_UNITHUNK  Unicode wrapper functions
//    NO_W95WRAPS_TPS       Thread Pool Services
//    NO_W95WRAPS_MLUI      MLUI wrapper functions
//
//  You are expected to have done a #include <shlwapi.h> before including
//  this file.
//
// BUGBUG: you can't include shlwapi.h before this, as ATL templates
// require things like TranlsateAccelerator which, due to munging, get
// turned into TranslateAcceleratorWrapW at compile time.  So w95wraps.h
// pretty much needs to be included FIRST so all the interface definitions
// get munged too.
//#ifndef _INC_SHLWAPI
//#error "You must include shlwapi.h *before* w95wraps.h
//#endif

//=============== Unicode Wrapper Routines ===================================

#ifndef NO_W95WRAPS_UNITHUNK

//
//  If you #include this file, then calls to many UNICODE functions
//  are re-routed through wrapper functions in SHLWAPI which will
//  either call the UNICODE version (on NT) or thunk the parameters
//  to ANSI and call the ANSI version (on 9x).
//
//  Note that these wrapper functions must be used with care, because
//
//  *   They do not account for subtle differences between UNICODE and
//      ANSI versions of the same API.  Examples:
//
//      -   RegisterClassW register a UNICODE window class, whereas
//          RegisterClassA registers an ANSI window class.  Consequently,
//          if you use RegisterClassWrapW, your WNDPROC will receive
//          *ANSI* WM_SETTEXT messages on Windows 9x.
//
//      -   SetWindowLongW(GWL_WNDPROC) and CallWindowProcW behave
//          very differently from their ANSI counterparts.
//
//      -   DialogBoxW will send your dialog procedure UNICODE window
//          messages, whereas DialogBoxA will send ANSI window messages.
//
//      -   Anything that manipulates window messages or MSG structures
//          will be subtly affected by character set discrepancies.
//
//  *   Not all features of the underlying API are always supported,
//      or are supported with restrictions.  Examples:
//
//      -   DialogBoxWrapW does not support named dialog resources.
//
//      -   AppendMenuWrapW does not support bitmap or owner-draw
//          menu items.
//
//      -   FormatMessageWrapW does not support insertions.
//
//      -   If you use RegQueryValueExWrapW with a NULL output buffer to
//          query the size of a buffer, you must also pass *lpcbData = 0.
//
//      -   SendMessageWrapW requires that the window message not conflict
//          with messages used by any of the Windows common controls.
//

#define IsCharAlphaW                IsCharAlphaWrapW
#define IsCharUpperW                IsCharUpperWrapW
#define IsCharLowerW                IsCharLowerWrapW
#define IsCharAlphaNumericW         IsCharAlphaNumericWrapW

#define AppendMenuW                 AppendMenuWrapW
#define CallMsgFilterW              CallMsgFilterWrapW
#define CallWindowProcW             CallWindowProcWrapW
#define CharLowerW                  CharLowerWrapW
#define CharLowerBuffW              CharLowerBuffWrapW
#define CharNextW                   CharNextWrapW
#define CharPrevW                   CharPrevWrapW
#define CharToOemW                  CharToOemWrapW
#define CharUpperW                  CharUpperWrapW
#define CharUpperBuffW              CharUpperBuffWrapW
#define CompareStringW              CompareStringWrapW
#define CopyAcceleratorTableW       CopyAcceleratorTableWrapW
#define CreateAcceleratorTableW     CreateAcceleratorTableWrapW
#define CreateDCW                   CreateDCWrapW
#define CreateDirectoryW            CreateDirectoryWrapW
#define CreateEventW                CreateEventWrapW
#define CreateFileW                 CreateFileWrapW
#define CreateFontW                 CreateFontWrapW
#define CreateFontIndirectW         CreateFontIndirectWrapW
#define CreateMetaFileW             CreateMetaFileWrapW
#define CreateMutexW                CreateMutexWrapW
#define CreateICW                   CreateICWrapW
#define CreateSemaphoreW            CreateSemaphoreWrapW
#define CreateWindowExW             CreateWindowExWrapW
#define GetFileVersionInfoSizeW     GetFileVersionInfoSizeWrapW
#define GetFileVersionInfoW         GetFileVersionInfoWrapW
#define lstrcmpiW                   StrCmpIW
#define lstrcmpW                    StrCmpW
#define lstrcpyW                    StrCpyW
#define lstrcpynW                   StrCpyNW
#define VerQueryValueW              VerQueryValueWrapW

#ifndef NO_W95_ATL_WRAPS_TBS
// #define NO_W95_ATL_WRAPS_TBS if you use ATL.
#define DefWindowProcW              DefWindowProcWrapW
#endif // NO_W95_ATL_WRAPS_TBS

#define DeleteFileW                 DeleteFileWrapW
#define DispatchMessageW            DispatchMessageWrapW
#define DragQueryFileW              DragQueryFileWrapW
#define DrawTextExW                 DrawTextExWrapW
#define DrawTextW                   DrawTextWrapW
#define EnumFontFamiliesW           EnumFontFamiliesWrapW
#define EnumFontFamiliesExW         EnumFontFamiliesExWrapW
#define EnumResourceNamesW          EnumResourceNamesWrapW
#define ExpandEnvironmentStringsW   ExpandEnvironmentStringsWrapW
#define ExtractIconExW              ExtractIconExWrapW
#define ExtTextOutW                 ExtTextOutWrapW
#define FindFirstFileW              FindFirstFileWrapW
#define FindResourceW               FindResourceWrapW
#define FindNextFileW               FindNextFileWrapW
#define FindWindowW                 FindWindowWrapW
#define FindWindowExW               FindWindowExWrapW
#define FormatMessageW              FormatMessageWrapW
#ifndef NO_W95_GETCLASSINFO_WRAPS
// #define NO_W95_GETCLASSINFO_WRAPS if one of the objects uses IProvideClassInfo which has a GetClassInfo method.
#define GetClassInfoW               GetClassInfoWrapW
#define GetClassInfoExW             GetClassInfoExWrapW
#endif  // NO_W95_GETCLASSINFO_WRAPS
#define GetClassLongW               GetClassLongWrapW
#define GetClassNameW               GetClassNameWrapW
#define GetClipboardFormatNameW     GetClipboardFormatNameWrapW
#define GetCurrentDirectoryW        GetCurrentDirectoryWrapW
#define GetDlgItemTextW             GetDlgItemTextWrapW
#define GetFileAttributesW          GetFileAttributesWrapW
#define GetFullPathNameW            GetFullPathNameWrapW
#define GetLocaleInfoW              GetLocaleInfoWrapW
#define GetMenuItemInfoW            GetMenuItemInfoWrapW
#define GetMenuStringW              GetMenuStringWrapW
#define GetMessageW                 GetMessageWrapW
#define GetModuleFileNameW          GetModuleFileNameWrapW
#define GetNumberFormatW            GetNumberFormatWrapW
#define GetSystemDirectoryW         GetSystemDirectoryWrapW
#define GetModuleHandleW            GetModuleHandleWrapW
#define GetObjectW                  GetObjectWrapW
#define GetPrivateProfileIntW       GetPrivateProfileIntWrapW
#define GetPrivateProfileStringW    GetPrivateProfileStringWrapW
#define GetProfileStringW           GetProfileStringWrapW
#define GetPropW                    GetPropWrapW
#define GlobalAddAtomW              GlobalAddAtomWrapW
#define GlobalFindAtomW             GlobalFindAtomWrapW
#define GetShortPathNameW           GetShortPathNameWrapW
#define GetLongPathNameW            GetLongPathNameWrapW
#define GetLongPathNameA            GetLongPathNameWrapA
#define GetStringTypeExW            GetStringTypeExWrapW
#define GetTempFileNameW            GetTempFileNameWrapW
#define GetTempPathW                GetTempPathWrapW
#define GetTextExtentPoint32W       GetTextExtentPoint32WrapW
#define GetTextFaceW                GetTextFaceWrapW
#define GetTextMetricsW             GetTextMetricsWrapW
#define GetTimeFormatW              GetTimeFormatWrapW
#define GetDateFormatW              GetDateFormatWrapW
#define GetUserNameW                GetUserNameWrapW
#define GetWindowLongW              GetWindowLongWrapW
#define GetEnvironmentVariableW     GetEnvironmentVariableWrapW

#ifndef NO_W95_ATL_WRAPS_TBS
// #define NO_W95_ATL_WRAPS_TBS if you use ATL.
#define GetWindowTextW              GetWindowTextWrapW
#endif // NO_W95_ATL_WRAPS_TBS

#define GetWindowTextLengthW        GetWindowTextLengthWrapW
#define GetWindowsDirectoryW        GetWindowsDirectoryWrapW
#define InsertMenuW                 InsertMenuWrapW
#define InsertMenuItemW             InsertMenuItemWrapW
#define IsBadStringPtrW             IsBadStringPtrWrapW
#define IsDialogMessageW            IsDialogMessageWrapW
#define LoadAcceleratorsW           LoadAcceleratorsWrapW
#define LoadBitmapW                 LoadBitmapWrapW
#define LoadCursorW                 LoadCursorWrapW
#define LoadIconW                   LoadIconWrapW
#define LoadImageW                  LoadImageWrapW
#define LoadLibraryW                LoadLibraryWrapW
#define LoadLibraryExW              LoadLibraryExWrapW
#define LoadMenuW                   LoadMenuWrapW
#define LoadStringW                 LoadStringWrapW
#define MessageBoxIndirectW         MessageBoxIndirectWrapW
#define MessageBoxW                 MessageBoxWrapW
#define ModifyMenuW                 ModifyMenuWrapW
#define GetCharWidth32W             GetCharWidth32WrapW
#define GetCharacterPlacementW      GetCharacterPlacementWrapW
#define CopyFileW                   CopyFileWrapW
#define MoveFileW                   MoveFileWrapW
#define OemToCharW                  OemToCharWrapW
#define OpenEventW                  OpenEventWrapW
#define OutputDebugStringW          OutputDebugStringWrapW
#define PeekMessageW                PeekMessageWrapW
#define PostMessageW                PostMessageWrapW
#define PostThreadMessageW          PostThreadMessageWrapW
#define RegCreateKeyW               RegCreateKeyWrapW
#define RegCreateKeyExW             RegCreateKeyExWrapW
#define RegDeleteKeyW               RegDeleteKeyWrapW
#define RegDeleteValueW             RegDeleteValueWrapW
#define RegEnumKeyW                 RegEnumKeyWrapW
#define RegEnumKeyExW               RegEnumKeyExWrapW
#define RegOpenKeyW                 RegOpenKeyWrapW
#define RegOpenKeyExW               RegOpenKeyExWrapW
#define RegQueryInfoKeyW            RegQueryInfoKeyWrapW
#define RegQueryValueW              RegQueryValueWrapW
#define RegQueryValueExW            RegQueryValueExWrapW
#define RegSetValueW                RegSetValueWrapW
#define RegSetValueExW              RegSetValueExWrapW
#define RegisterClassW              RegisterClassWrapW
#define RegisterClassExW            RegisterClassExWrapW
#define RegisterClipboardFormatW    RegisterClipboardFormatWrapW
#define RegisterWindowMessageW      RegisterWindowMessageWrapW
#define RemoveDirectoryW            RemoveDirectoryWrapW
#define RemovePropW                 RemovePropWrapW
#define SearchPathW                 SearchPathWrapW
#define SendDlgItemMessageW         SendDlgItemMessageWrapW
#define SendMessageW                SendMessageWrapW
#define SendMessageTimeoutW         SendMessageTimeoutWrapW
#define SetCurrentDirectoryW        SetCurrentDirectoryWrapW
#define SetDlgItemTextW             SetDlgItemTextWrapW
#define SetMenuItemInfoW            SetMenuItemInfoWrapW
#define SetPropW                    SetPropWrapW
#define SetFileAttributesW          SetFileAttributesWrapW
#define SetWindowLongW              SetWindowLongWrapW

#ifndef NO_W95_SHELL32_WRAPS
#define ExtractIconW                ExtractIconWrapW
#define SHGetFileInfoW              SHGetFileInfoWrapW
#define SHBrowseForFolderW          SHBrowseForFolderWrapW
#define ShellExecuteExW             ShellExecuteExWrapW
#define SHFileOperationW            SHFileOperationWrapW
#define SHGetNewLinkInfoW           SHGetNewLinkInfoWrapW
#define SHDefExtractIconW           SHDefExtractIconWrapW
#define SHChangeNotify              SHChangeNotifyWrap
#define SHFlushSFCache              SHFlushSFCacheWrap
#define SHGetPathFromIDListW        SHGetPathFromIDListWrapW
#endif // NO_W95_SHELL32_WRAPS

#define GetUserNameW                GetUserNameWrapW
#define RegEnumValueW               RegEnumValueWrapW
#define WritePrivateProfileStructW  WritePrivateProfileStructWrapW
#define GetPrivateProfileStructW    GetPrivateProfileStructWrapW
#define CreateProcessW              CreateProcessWrapW
#define DdeInitializeW              DdeInitializeWrapW
#define DdeCreateStringHandleW      DdeCreateStringHandleWrapW
#define DdeQueryStringW             DdeQueryStringWrapW
#define GetSaveFileNameW            GetSaveFileNameWrapW
#define GetOpenFileNameW            GetOpenFileNameWrapW
#define PageSetupDlgW               PageSetupDlgWrapW
#define PrintDlgW                   PrintDlgWrapW
#define SetWindowsHookExW           SetWindowsHookExWrapW
#define SetWindowTextW              SetWindowTextWrapW
#define StartDocW                   StartDocWrapW
#define CreateColorSpaceW           CreateColorSpaceWrapW
#define SystemParametersInfoW       SystemParametersInfoWrapW

#ifndef NO_W95_TRANSACCEL_WRAPS_TBS
// #define NO_W95_TRANSACCEL_WRAPS_TBS if one of the objects uses IOleInPlaceActiveObject which has a TranslateAccelerator method.
#define TranslateAcceleratorW       TranslateAcceleratorWrapW
#endif // NO_W95_TRANSACCEL_WRAPS_TBS

#define UnregisterClassW            UnregisterClassWrapW
#define VkKeyScanW                  VkKeyScanWrapW
#define WinHelpW                    WinHelpWrapW
#define WritePrivateProfileStringW  WritePrivateProfileStringWrapW
#define wvsprintfW                  wvsprintfWrapW
#define WNetRestoreConnectionW      WNetRestoreConnectionWrapW
#define WNetGetLastErrorW           WNetGetLastErrorWrapW

#endif // NO_W95WRAPS_UNITHUNK

#if !defined(NO_W95WRAPS_UNITHUNK) && !defined(NO_W95WRAPS_MLUI)

#define CreateDialogIndirectParamW  CreateDialogIndirectParamWrapW
#define CreateDialogParamW          CreateDialogParamWrapW
#define DialogBoxIndirectParamW     DialogBoxIndirectParamWrapW                 // UNICODE, ML
//#ifdef DialogBoxIndirectW
//#undef DialogBoxIndirectW
//#endif
//#define DialogBoxIndirectW(i,h,w,f) DialogBoxIndirectParamWrapW(i,h,w,f,d,0)    // UNICODE, ML
#define DialogBoxParamW             DialogBoxParamWrapW                         // UNICODE, ML
//#ifdef DialogBoxW
//#undef DialogBoxW
//#endif
//#define DialogBoxW(i,t,w,f)         DialogBoxParamWrapW(i,t,w,f,0)              // UNICODE, ML
#define ShellMessageBoxW            ShellMessageBoxWrapW

#define TrackPopupMenu              TrackPopupMenuWrap
#define TrackPopupMenuEx            TrackPopupMenuExWrap

#define DeleteMenu                  DeleteMenuWrap
#define DestroyMenu                 DestroyMenuWrap

#endif // !defined(NO_W95WRAPS_UNITHUNK) || !defined(NO_W95WRAPS_MLUI)


#if !defined(NO_OLE32_WRAPS)
#define CLSIDFromString             CLSIDFromStringWrap
#define CLSIDFromProgID             CLSIDFromProgIDWrap
#endif

#endif // _X86_

#endif // _INC_W95WRAPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\resource.h ===
//  --------------------------------------------------------------------------
//  Module Name: Resource.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  Resource ID declarations common to the shared shell service DLL.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ShellServicesResource_
#define     _ShellServicesResource_

//  Bad Application Service.

#define IDD_BADAPP_CLOSE                    0x1000
#define IDC_BADAPP_CLOSEPROGRAM             0x1001
#define IDC_BADAPP_CLOSE                    0x1002
#define IDD_BADAPP_STOP                     0x1100
#define IDC_BADAPP_STOP                     0x1101
#define IDD_PROGRESS                        0x1200
#define IDC_PROGRESS_PROGRESSBAR            0x1201
#define IDC_PROGRESS_CLOSE                  0x1202

#define IDS_WARNING_CAPTION                 0x1E00
#define IDS_TERMINATEPROCESS_FAILURE        0x1E01

#define IDS_BAMSERVER_DISPLAYNAME           0x1F00
#define IDS_BAMSERVER_DESCRIPTION           0x1F01

//  Theme Service.

#define IDS_THEMESERVER_DISPLAYNAME         0x2000
#define IDS_THEMESERVER_DESCRIPTION         0x2001

//  Hardware Detection Service.

#define IDS_SHELLHWDETECTION_FRIENDLYNAME   0x3000
#define IDS_SHELLHWDETECTION_DESCRIPTION    0x3001

#endif  /*  _ShellServicesResource_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationapirequest.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationAPIRequest.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class to implement bad application manager API
//  requests.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationAPIRequest_
#define     _BadApplicationAPIRequest_

#include "APIDispatcher.h"
#include "APIRequest.h"
#include "BadApplicationManager.h"
#include "PortMessage.h"

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest
//
//  Purpose:    This is an intermediate class that contains a common method
//              that can be used by sub-classes.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

class   CBadApplicationAPIRequest : public CAPIRequest
{
    private:
                                            CBadApplicationAPIRequest (void);
    public:
                                            CBadApplicationAPIRequest (CAPIDispatcher* pAPIDispatcher);
                                            CBadApplicationAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage);
        virtual                             ~CBadApplicationAPIRequest (void);

        virtual NTSTATUS                    Execute (void);

        static  NTSTATUS                    StaticInitialize (HINSTANCE hInstance);
        static  NTSTATUS                    StaticTerminate (void);
    private:
                NTSTATUS                    Execute_QueryRunning (void);
                NTSTATUS                    Execute_RegisterRunning (void);
                NTSTATUS                    Execute_QueryUserPermission (void);
                NTSTATUS                    Execute_TerminateRunning (void);
                NTSTATUS                    Execute_RequestSwitchUser (void);
    private:
        static  CBadApplicationManager*     s_pBadApplicationManager;
};

#endif  /*  _BadApplicationAPIRequest_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationapiserver.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationAPIServer.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains several classes that implemention virtual functions
//  for complete LPC functionality.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplicationAPIServer.h"

#include <lpcfus.h>

#include "BadApplicationDispatcher.h"
#include "BadApplicationService.h"

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::CBadApplicationAPIServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CBadApplicationAPIServer class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIServer::CBadApplicationAPIServer (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::~CBadApplicationAPIServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CBadApplicationAPIServer class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIServer::~CBadApplicationAPIServer (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::StrToInt
//
//  Arguments:  pszString   =   String to convert to a DWORD
//
//  Returns:    DWORD
//
//  Purpose:    Converts the string to a DWORD - UNSIGNED.
//
//  History:    2000-11-07  vtan        created
//  --------------------------------------------------------------------------

DWORD   CBadApplicationAPIServer::StrToInt (const WCHAR *pszString)

{
    DWORD   dwProcessID;
    WCHAR   c;

    //  Convert inline from decimal WCHAR string to int.

    dwProcessID = 0;
    c = *pszString++;
    while (c != L'\0')
    {
        dwProcessID *= 10;
        ASSERTMSG((c >= L'0') && (c <= L'9'), "Invalid decimal digit in CBadApplicationAPIServer::StrToInt");
        dwProcessID += (c - L'0');
        c = *pszString++;
    }
    return(dwProcessID);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::GetPortName
//
//  Arguments:  <none>
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns a unicode string (const pointer) to the name of the
//              port for this server that supports multiple API sets.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

const WCHAR*    CBadApplicationAPIServer::GetPortName (void)

{
    return(FUS_PORT_NAME);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::GetPortName
//
//  Arguments:  <none>
//
//  Returns:    const TCHAR*
//
//  Purpose:    Uses a common routine to get the theme service name.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

const TCHAR*    CBadApplicationAPIServer::GetServiceName (void)

{
    return(CBadApplicationService::GetName());
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::ConnectionAccepted
//
//  Arguments:  portMessage     =   PORT_MESSAGE from client.
//
//  Returns:    bool
//
//  Purpose:    Accepts or rejects a port connection request. Accepts all
//              connections currently.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

bool    CBadApplicationAPIServer::ConnectionAccepted (const CPortMessage& portMessage)

{
    return(lstrcmpW(reinterpret_cast<const WCHAR*>(portMessage.GetData()), FUS_CONNECTION_REQUEST) == 0);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::CreateDispatchThread
//
//  Arguments:  portMessage     =   PORT_MESSAGE from client.
//
//  Returns:    CAPIDispatcher*
//
//  Purpose:    Called by the LPC connection request handler to create a new
//              thread to handle client requests.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CAPIDispatcher*     CBadApplicationAPIServer::CreateDispatcher (const CPortMessage& portMessage)

{
    HANDLE              hClientProcess;
    OBJECT_ATTRIBUTES   objectAttributes;
    CLIENT_ID           clientID;
    CAPIDispatcher      *pAPIDispatcher;

    pAPIDispatcher = NULL;
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);
    clientID.UniqueProcess = portMessage.GetUniqueProcess();
    clientID.UniqueThread = NULL;

    //  Open a handle to the client process. The handle must have PROCESS_DUP_HANDLE
    //  for the server to be able to deliver handles to the client. It also needs
    //  PROCESS_VM_READ | PROCESS_VM_WRITE if it's to read and write the client
    //  address space to store data that's too big for the LPC port.

    //  That handle is stored by the thread handler. It's not closed here.

    if (NT_SUCCESS(NtOpenProcess(&hClientProcess,
                                 PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
                                 &objectAttributes,
                                 &clientID)))
    {
        pAPIDispatcher = new CBadApplicationDispatcher(hClientProcess);
    }
    return(pAPIDispatcher);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer::Connect
//
//  Arguments:  phPort  =   Handle to the port received on connection.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Connects to the server.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIServer::Connect (HANDLE* phPort)

{
    ULONG                           ulConnectionInfoLength;
    UNICODE_STRING                  portName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[64];

    RtlInitUnicodeString(&portName, GetPortName());
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    lstrcpyW(szConnectionInfo, FUS_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    return(NtConnectPort(phPort,
                         &portName,
                         &sqos,
                         NULL,
                         NULL,
                         NULL,
                         szConnectionInfo,
                         &ulConnectionInfoLength));
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplication.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplication.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to encapsulate identification of a bad application.
//
//  History:    2000-08-25  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifndef     _BadApplication_
#define     _BadApplication_

//  --------------------------------------------------------------------------
//  CBadApplication
//
//  Purpose:    Implements abstraction of what defines a bad application.
//
//  History:    2000-08-25  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

class   CBadApplication
{
    public:
                CBadApplication (void);
                CBadApplication (const TCHAR *pszImageName);
                ~CBadApplication (void);

        bool    operator == (const CBadApplication& compareObject)  const;
    private:
        TCHAR   _szImageName[MAX_PATH];
};

#endif  /*  _BadApplication_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationapirequest.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationAPIRequest.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class to implement bad application manager API
//  requests.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplicationAPIRequest.h"

#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::s_pBadApplicationManager
//
//  Purpose:    Single instance of the CBadApplicationManager object.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationManager*     CBadApplicationAPIRequest::s_pBadApplicationManager     =   NULL;

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::CBadApplicationAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher that calls this object.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CBadApplicationAPIRequest class. It just passes the
//              control to the super class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIRequest::CBadApplicationAPIRequest (CAPIDispatcher* pAPIDispatcher) :
    CAPIRequest(pAPIDispatcher)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::CBadApplicationAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher that calls this object.
//              portMessage     =   CPortMessage to copy construct.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CBadApplicationAPIRequest class. It just passes the
//              control to the super class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIRequest::CBadApplicationAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage) :
    CAPIRequest(pAPIDispatcher, portMessage)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::~CBadApplicationAPIRequest
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CBadApplicationAPIRequest class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationAPIRequest::~CBadApplicationAPIRequest (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute implementation for bad application API requests. This
//              function dispatches requests based on the API request number.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute (void)

{
    NTSTATUS    status;

    switch (reinterpret_cast<API_BAM*>(&_data)->apiGeneric.ulAPINumber)
    {
        case API_BAM_QUERYRUNNING:
            status = Execute_QueryRunning();
            break;
        case API_BAM_REGISTERRUNNING:
            status = Execute_RegisterRunning();
            break;
        case API_BAM_QUERYUSERPERMISSION:
            status = Execute_QueryUserPermission();
            break;
        case API_BAM_TERMINATERUNNING:
            status = Execute_TerminateRunning();
            break;
        case API_BAM_REQUESTSWITCHUSER:
            status = Execute_RequestSwitchUser();
            break;
        default:
            DISPLAYMSG("Unknown API request in CBadApplicationAPIRequest::Execute");
            status = STATUS_NOT_IMPLEMENTED;
            break;
    }
    TSTATUS(status);
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Static initializer for the class. It creates the static
//              instance of the CBadApplicationManager which must be a single
//              instance and knows about bad running applications.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::StaticInitialize (HINSTANCE hInstance)

{
    NTSTATUS    status;

    if (s_pBadApplicationManager == NULL)
    {
        s_pBadApplicationManager = new CBadApplicationManager(hInstance);
        if (s_pBadApplicationManager != NULL)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Static destructor for the class. This terminates the bad
//              application manager, releases the reference on the object and
//              clears out the static variable. When the thread dies it will
//              clean itself up.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::StaticTerminate (void)

{
    if (s_pBadApplicationManager != NULL)
    {
        s_pBadApplicationManager->Terminate();
        s_pBadApplicationManager->Release();
        s_pBadApplicationManager = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_QueryRunning
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_QUERYRUNNING. Returns whether or not the
//              requested image path is currently a known (tracked)
//              executable that is running. Let the bad application manager
//              do the work. Exclude checking in the same session.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_QueryRunning (void)

{
    NTSTATUS                    status;
    HANDLE                      hProcessClient;
    API_BAM_QUERYRUNNING_IN     *pAPIIn;
    API_BAM_QUERYRUNNING_OUT    *pAPIOut;
    WCHAR                       *pszImageName;

    hProcessClient = _pAPIDispatcher->GetClientProcess();
    pAPIIn = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiQueryRunning.in;
    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiQueryRunning.out;

    status = _AllocAndMapClientString(hProcessClient, pAPIIn->pszImageName, pAPIIn->cchImageName,
                                      MAX_PATH, &pszImageName);
    
    if(NT_SUCCESS(status))
    {
        CBadApplication badApplication(pszImageName);

        pAPIOut->fResult = s_pBadApplicationManager->QueryRunning(badApplication, _pAPIDispatcher->GetClientSessionID());
        status = STATUS_SUCCESS;

        _FreeMappedClientString(pszImageName);
    }

    SetDataLength(sizeof(API_BAM));
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_RegisterRunning
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_REGISTERRUNNING. Adds the given image
//              executable to the list of currently running bad applications
//              so that further instances can be excluded.
//
//  History:    2000-08-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_RegisterRunning (void)

{
    NTSTATUS                        status;
    API_BAM_REGISTERRUNNING_IN      *pAPIIn;
    API_BAM_REGISTERRUNNING_OUT     *pAPIOut;
    WCHAR                           *pszImageName;

    pAPIIn = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiRegisterRunning.in;
    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiRegisterRunning.out;
    if ((pAPIIn->bamType > BAM_TYPE_MINIMUM) && (pAPIIn->bamType < BAM_TYPE_MAXIMUM))
    {
        status = _AllocAndMapClientString(_pAPIDispatcher->GetClientProcess(), 
                                          pAPIIn->pszImageName, pAPIIn->cchImageName,
                                          MAX_PATH, &pszImageName);

        if (NT_SUCCESS(status))
        {
            HANDLE              hProcess;
            CBadApplication     badApplication(pszImageName);

            hProcess = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,
                                   FALSE,
                                   pAPIIn->dwProcessID);
            if (hProcess != NULL)
            {
                status = s_pBadApplicationManager->RegisterRunning(badApplication, hProcess, pAPIIn->bamType);
                TBOOL(CloseHandle(hProcess));
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }

            _FreeMappedClientString(pszImageName);
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }
    SetDataLength(sizeof(API_BAM));
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_QueryUserPermission
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_QUERYUSERPERMISSION. Queries the client
//              permission to close down the bad application. Also returns
//              the current user of the bad application.
//
//  History:    2000-08-31  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_QueryUserPermission (void)

{
    NTSTATUS                            status;
    API_BAM_QUERYUSERPERMISSION_IN      *pAPIIn;
    API_BAM_QUERYUSERPERMISSION_OUT     *pAPIOut;
    WCHAR*                              pszImageName;

    pAPIIn = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiQueryUserPermission.in;
    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiQueryUserPermission.out;

    status = _AllocAndMapClientString(_pAPIDispatcher->GetClientProcess(), 
                                      pAPIIn->pszImageName, pAPIIn->cchImageName,
                                      MAX_PATH, &pszImageName);
    
    if(NT_SUCCESS(status))
    {
        HANDLE              hProcess;
        CBadApplication     badApplication(pszImageName);

        //  Query information on the bad application
        //  (get back the process handle).

        status = s_pBadApplicationManager->QueryInformation(badApplication, hProcess);
        if (NT_SUCCESS(status))
        {
            HANDLE  hToken;

            //  Get the client token and impersonate that user.

            status = OpenClientToken(hToken);
            if (NT_SUCCESS(status))
            {
                bool                fCanShutdownApplication;
                HANDLE              hTokenProcess;
                CTokenInformation   tokenInformationClient(hToken);

                fCanShutdownApplication = tokenInformationClient.IsUserAnAdministrator();

                //  Get the bad application process token to get
                //  information on the user for the process.

                if (OpenProcessToken(hProcess,
                                     TOKEN_QUERY,
                                     &hTokenProcess) != FALSE)
                {
                    const WCHAR         *pszUserDisplayName;
                    CTokenInformation   tokenInformationProcess(hTokenProcess);

                    pszUserDisplayName = tokenInformationProcess.GetUserDisplayName();
                    if (pszUserDisplayName != NULL)
                    {
                        int     iCharsToWrite;
                        SIZE_T  dwNumberOfBytesWritten;

                        //  Return the information back to the client.

                        pAPIOut->fCanShutdownApplication = fCanShutdownApplication;
                        iCharsToWrite = lstrlen(pszUserDisplayName) + sizeof('\0');
                        if (iCharsToWrite > pAPIIn->cchUser)
                        {
                            iCharsToWrite = pAPIIn->cchUser;
                        }
                        if (WriteProcessMemory(_pAPIDispatcher->GetClientProcess(),
                                               pAPIIn->pszUser,
                                               const_cast<WCHAR*>(pszUserDisplayName),
                                               iCharsToWrite * sizeof(WCHAR),
                                               &dwNumberOfBytesWritten) != FALSE)
                        {
                            status = STATUS_SUCCESS;
                        }
                        else
                        {
                            status = CStatusCode::StatusCodeOfLastError();
                        }
                    }
                    else
                    {
                        status = CStatusCode::StatusCodeOfLastError();
                    }
                    TBOOL(CloseHandle(hTokenProcess));
                }
                else
                {
                    status = CStatusCode::StatusCodeOfLastError();
                }
                TBOOL(CloseHandle(hToken));
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseHandle(hProcess));
        }

        _FreeMappedClientString(pszImageName);
    }

    SetDataLength(sizeof(API_BAM));
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_QueryUserPermission
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_TERMINATERUNNING. Terminates the given running
//              bad application so a different instance on a different
//              window station can start it.
//
//  History:    2000-08-31  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_TerminateRunning (void)

{
    NTSTATUS                        status;
    API_BAM_TERMINATERUNNING_IN     *pAPIIn;
    API_BAM_TERMINATERUNNING_OUT    *pAPIOut;
    WCHAR                           *pszImageName;

    pAPIIn = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiTerminateRunning.in;
    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiTerminateRunning.out;


    status = _AllocAndMapClientString(_pAPIDispatcher->GetClientProcess(), 
                                      pAPIIn->pszImageName, pAPIIn->cchImageName,
                                      MAX_PATH, &pszImageName);
    
    if(NT_SUCCESS(status))
    {
        HANDLE  hToken;

        //  Get the client token and for membership of the local administrators
        //  group. DO NOT IMPERSONATE THE CLIENT. This will almost certainly
        //  guarantee that the process cannot be terminated.

        status = OpenClientToken(hToken);
        if (NT_SUCCESS(status))
        {
            CTokenInformation   tokenInformationClient(hToken);

            if (tokenInformationClient.IsUserAnAdministrator())
            {
                HANDLE              hProcess;
                CBadApplication     badApplication(pszImageName);

                //  Query information on the bad application
                //  (get back the process handle).

                status = s_pBadApplicationManager->QueryInformation(badApplication, hProcess);
                if (NT_SUCCESS(status))
                {
                    do
                    {
                        status = CBadApplicationManager::PerformTermination(hProcess, true);
                        TBOOL(CloseHandle(hProcess));
                    } while (NT_SUCCESS(status) &&
                             NT_SUCCESS(s_pBadApplicationManager->QueryInformation(badApplication, hProcess)));
                }

                //  If the information could not be found then it's
                //  probably not running. This indicates success.

                else
                {
                    status = STATUS_SUCCESS;
                }
            }
            else
            {
                status = STATUS_ACCESS_DENIED;
            }
            TBOOL(CloseHandle(hToken));
        }

        _FreeMappedClientString(pszImageName);
    }

    pAPIOut->fResult = NT_SUCCESS(status);
    SetDataLength(sizeof(API_BAM));
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationAPIRequest::Execute_RequestSwitchUser
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_BAM_REQUESTSWITCHUSER. Request from
//              winlogon/msgina to switch a user. Terminate all bad
//              applications related to disconnect. Reject the disconnect if
//              it fails.
//
//  History:    2000-11-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationAPIRequest::Execute_RequestSwitchUser (void)

{
    API_BAM_REQUESTSWITCHUSER_OUT   *pAPIOut;

    pAPIOut = &reinterpret_cast<API_BAM*>(&_data)->apiSpecific.apiRequestSwitchUser.out;
    pAPIOut->fAllowSwitch = NT_SUCCESS(s_pBadApplicationManager->RequestSwitchUser());
    SetDataLength(sizeof(API_BAM));
    return(STATUS_SUCCESS);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationdispatcher.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationDispatcher.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class to implement bad application manager API
//  request dispatch handling.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationDispatcher_
#define     _BadApplicationDispatcher_

#include "APIDispatcher.h"
#include "PortMessage.h"

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher
//
//  Purpose:    This sub-class implements CAPIDispatcher::QueueRequest to
//              create a CBadApplicationRequest which knows how to handle
//              API requests for the bad application manager.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

class   CBadApplicationDispatcher : public CAPIDispatcher
{
    private:
                                CBadApplicationDispatcher (void);
    public:
                                CBadApplicationDispatcher (HANDLE hClientProcess);
        virtual                 ~CBadApplicationDispatcher (void);

        virtual NTSTATUS        CreateAndQueueRequest (const CPortMessage& portMessage);
        virtual NTSTATUS        CreateAndExecuteRequest (const CPortMessage& portMessage);
};

#endif  /*  _BadApplicationDispatcher_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationdispatcher.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationDispatcher.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class to implement bad application manager API
//  request dispatch handling.
//
//  History:    2000-08-25  vtan        created
//              2000-12-04  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplicationDispatcher.h"

#include "BadApplicationAPIRequest.h"

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher::CBadApplicationDispatcher
//
//  Arguments:  hClientProcess  =   HANDLE to the client process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CBadApplicationDispatcher class. This
//              stores the client handle. It does not duplicate it.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationDispatcher::CBadApplicationDispatcher (HANDLE hClientProcess) :
    CAPIDispatcher(hClientProcess)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher::~CBadApplicationDispatcher
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CBadApplicationDispatcher class.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationDispatcher::~CBadApplicationDispatcher (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher::CreateAndQueueRequest
//
//  Arguments:  portMessage     =   PORT_MESSAGE request to queue to handler.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Queues the client request to the dispatcher. Tells the
//              handler thread that there is input waiting. This function
//              knows what kind of CAPIRequest to create so that
//              CAPIRequest::Execute will work correctly.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationDispatcher::CreateAndQueueRequest(const CPortMessage& portMessage)

{
    NTSTATUS        status;
    CQueueElement   *pQueueElement;

    pQueueElement = new CBadApplicationAPIRequest(this, portMessage);
    if (pQueueElement != NULL)
    {
        _queue.Add(pQueueElement);
        status = SignalRequestPending();
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationDispatcher::CreateAndExecuteRequest
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Executes the given request immediately and returns the result
//              back to the caller. The API request is done on the server
//              listen thread.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationDispatcher::CreateAndExecuteRequest (const CPortMessage& portMessage)

{
    NTSTATUS        status;
    CAPIRequest     *pAPIRequest;

    pAPIRequest = new CBadApplicationAPIRequest(this, portMessage);
    if (pAPIRequest != NULL)
    {
        status = Execute(pAPIRequest);
        delete pAPIRequest;
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationapiserver.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationAPIServer.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains several classes that implemention virtual functions
//  for complete LPC functionality.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationAPIServer_
#define     _BadApplicationAPIServer_

#include "APIDispatcher.h"
#include "ServerAPI.h"
#include "PortMessage.h"

//  --------------------------------------------------------------------------
//  CBadApplicationAPIServer
//
//  Purpose:    This class implements the interface that the
//              CAPIConnectionThread uses to create create the LPC port,
//              accept or reject connections to the LPC port and create the
//              LPC request handling thread.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

class   CBadApplicationAPIServer : public CServerAPI
{
    public:
                                    CBadApplicationAPIServer (void);
        virtual                     ~CBadApplicationAPIServer (void);

        static  DWORD               StrToInt (const WCHAR *pszString);
    protected:
        virtual const WCHAR*        GetPortName (void);
        virtual const TCHAR*        GetServiceName (void);
        virtual bool                ConnectionAccepted (const CPortMessage& portMessage);
        virtual CAPIDispatcher*     CreateDispatcher (const CPortMessage& portMessage);
        virtual NTSTATUS            Connect (HANDLE* phPort);
    private:
};

#endif  /*  _BadApplicationAPIServer_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationexports.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationServerExports.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains functions exported by name from the BAM service dll.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"

#include "BadApplicationAPIServer.h"
#include "GracefulTerminateApplication.h"

extern  HINSTANCE   g_hInstance;

//  --------------------------------------------------------------------------
//  ::FUSCompatibilityEntryTerminate
//
//  Arguments:  pszCommand  =   Command line from rundll32.
//
//  Returns:    <none>
//
//  Purpose:    Internal entry point to execute termination of a specified
//              process on behalf of the BAM server. The server starts the
//              rundll32 process on the correct session so that it can find
//              the window belonging to that session.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  FUSCompatibilityEntryTerminate (const WCHAR *pszCommand)

{
    CGracefulTerminateApplication   terminateApplication;

    terminateApplication.Terminate(CBadApplicationAPIServer::StrToInt(pszCommand));
    DISPLAYMSG("Where was the call to kernel32!ExitProcess in CGracefulTerminateApplication::Terminate");
}

//  --------------------------------------------------------------------------
//  ::FUSCompatibilityEntryPrompt
//
//  Arguments:  pszCommand  =   Command line from rundll32.
//
//  Returns:    <none>
//
//  Purpose:    Internal entry point to execute a prompt for termination of
//              the parent process of this one. This is used by the BAM shim
//              for type 1. Instead of bringing up UI in the application it
//              creates a rundll32 process to call this entry point which
//              brings up UI and returns a result to the parent in the exit
//              code.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  FUSCompatibilityEntryPrompt (const WCHAR *pszCommand)

{
    CGracefulTerminateApplication::Prompt(g_hInstance, reinterpret_cast<HANDLE>(CBadApplicationAPIServer::StrToInt(pszCommand)));
    DISPLAYMSG("Where was the call to kernel32!ExitProcess in CGracefulTerminateApplication::Prompt");
}

//  --------------------------------------------------------------------------
//  ::FUSCompatibilityEntryW
//
//  Arguments:  hwndStub    =   ?
//              hInstance   =   ?
//              pszCmdLine  =   ?
//              nCmdShow    =   ?
//
//  Returns:    <none>
//
//  Purpose:    External named entry point for rundll32.exe in case of
//              external process hosting.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  FUSCompatibilityEntryW (HWND hwndStub, HINSTANCE hInstance, LPWSTR pszCmdLine, int nCmdShow)

{
    UNREFERENCED_PARAMETER(hwndStub);
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(nCmdShow);

    typedef void    (WINAPI * PFNCOMMANDPROC) (const WCHAR *pszCommand);

    typedef struct
    {
        const WCHAR*    szCommand;
        PFNCOMMANDPROC  pfnCommandProc;
    } COMMAND_ENTRY, *PCOMMAND_ENTRY;

    static  const COMMAND_ENTRY     s_commands[]    =   
    {
        {   L"terminate",   FUSCompatibilityEntryTerminate  },
        {   L"prompt",      FUSCompatibilityEntryPrompt     }
    };

    int     i, iLength;
    WCHAR   szCommand[32];

    i = 0;
    iLength = lstrlenW(pszCmdLine);
    while ((i < iLength) && (pszCmdLine[i] != L' '))
    {
        ++i;
    }
    iLength = i;
    ASSERTMSG((i + sizeof('\0')) < ARRAYSIZE(szCommand), "Impending string overflow in ::BadApplicationEntryW");
    lstrcpy(szCommand, pszCmdLine);
    szCommand[iLength] = L'\0';
    for (i = 0; i < ARRAYSIZE(s_commands); ++i)
    {
        if (lstrcmpiW(s_commands[i].szCommand, szCommand) == 0)
        {
            const WCHAR     *pszParameter;

            pszParameter = pszCmdLine + iLength;
            if (pszCmdLine[iLength] == L' ')
            {
                ++pszParameter;
            }
            s_commands[i].pfnCommandProc(pszParameter);
        }
    }
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationmanager.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationManager.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Classes to manage bad applications in the fast user switching environment.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "BadApplicationManager.h"

#include <wtsapi32.h>
#include <winsta.h>

#include "GracefulTerminateApplication.h"
#include "RestoreApplication.h"
#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CBadApplicationManager::INDEX_EVENT
//  CBadApplicationManager::INDEX_HANDLES
//  CBadApplicationManager::INDEX_RESERVED
//  CBadApplicationManager::s_szDefaultDesktop
//
//  Purpose:    Constant indicies into a HANDLE array passed to
//              user32!MsgWaitForMultipleObjects. The first handle is always
//              the synchronization event. Subsequent HANDLEs are built into
//              a static ARRAY passed with the dynamic amount.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

const int       CBadApplicationManager::INDEX_EVENT             =   0;
const int       CBadApplicationManager::INDEX_HANDLES           =   INDEX_EVENT + 1;
const int       CBadApplicationManager::INDEX_RESERVED          =   2;
const WCHAR     CBadApplicationManager::s_szDefaultDesktop[]    =   L"WinSta0\\Default";

//  --------------------------------------------------------------------------
//  CBadApplicationManager::CBadApplicationManager
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CBadApplicationManager. This creates a thread
//              that watches HANDLEs in the bad application list. The watcher
//              knows when the offending process dies. It also creates a
//              synchronization event that is signalled when the array of
//              bad applications changes (is incremented). The thread
//              maintains removal cases.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationManager::CBadApplicationManager (HINSTANCE hInstance) :
    CThread(),
    _hInstance(hInstance),
    _hModule(NULL),
    _atom(NULL),
    _hwnd(NULL),
    _fTerminateWatcherThread(false),
    _fRegisteredNotification(false),
    _dwSessionIDLastConnect(static_cast<DWORD>(-1)),
    _hTokenLastUser(NULL),
    _hEvent(NULL),
    _badApplications(sizeof(BAD_APPLICATION_INFO)),
    _restoreApplications()

{
    Resume();
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::~CBadApplicationManager
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CBadApplicationManager. Releases any resources
//              used.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationManager::~CBadApplicationManager (void)

{

    //  In case the token hasn't been released yet - release it.

    ReleaseHandle(_hTokenLastUser);
    Cleanup();
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Terminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Forces the watcher thread to terminate. Acquire the lock. Walk
//              the list of entries and release the HANDLE on the process
//              objects so they don't leak. Set the bool to terminate the
//              thread. Set the event to wake the thread up. Release the lock.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::Terminate (void)

{
    int                         i;
    CSingleThreadedExecution    listLock(_lock);

    for (i = _badApplications.GetCount() - 1; i >= 0; --i)
    {
        BAD_APPLICATION_INFO    badApplicationInfo;

        if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
        {
            TBOOL(CloseHandle(badApplicationInfo.hProcess));
        }
        _badApplications.Remove(i);
    }
    _fTerminateWatcherThread = true;
    return(_hEvent.Set());
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::QueryRunning
//
//  Arguments:  badApplication  =   Bad application identifier to query.
//              dwSessionID     =   Session ID of the request.
//
//  Returns:    bool
//
//  Purpose:    Queries the current running known bad applications list
//              looking for a match. Again because this typically runs on a
//              different thread to the watcher thread access to the list is
//              protected by a critical section.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

bool    CBadApplicationManager::QueryRunning (const CBadApplication& badApplication, DWORD dwSessionID)

{
    bool                        fResult;
    NTSTATUS                    status;
    int                         i;
    CSingleThreadedExecution    listLock(_lock);

    status = STATUS_SUCCESS;
    fResult = false;

    //  Loop looking for a match. This uses the overloaded operator ==.

    for (i = _badApplications.GetCount() - 1; !fResult && (i >= 0); --i)
    {
        BAD_APPLICATION_INFO    badApplicationInfo;

        status = _badApplications.Get(&badApplicationInfo, i);
        if (NT_SUCCESS(status))
        {

            //  Make sure the client is not in the same session as the running
            //  bad application. This API exists to prevent cross session instances.
            //  It's assumed that applications have their own mechanisms for multiple
            //  instances in the same session (or object name space).

            fResult = ((badApplicationInfo.dwSessionID != dwSessionID) &&
                       (badApplicationInfo.badApplication == badApplication));
        }
    }
    TSTATUS(status);
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::RegisterRunning
//
//  Arguments:  badApplication  =   Bad application identifier to add.
//              hProcess        =   HANDLE to the process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the given bad application to the known running list. The
//              process object is added as well so that when the process
//              terminates it can be cleaned up out of the list.
//
//              Access to the bad application list is serialized with a
//              critical section. This is important because the thread
//              watching for termination always run on a different thread to
//              the thread on which this function executes. Because they both
//              access the same member variables this must be protected with
//              a critical section.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::RegisterRunning (const CBadApplication& badApplication, HANDLE hProcess, BAM_TYPE bamType)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    listLock(_lock);

    ASSERTMSG((bamType > BAM_TYPE_MINIMUM) && (bamType < BAM_TYPE_MAXIMUM), "Invalid BAM_TYPE value passed to CBadApplicationManager::AddRunning");

    //  Have we reached the maximum number of wait object allowed? If not
    //  then proceed to add this. Otherwise reject the call. This is a
    //  hard coded limit in the kernel so we abide by it.

    if (_badApplications.GetCount() < (MAXIMUM_WAIT_OBJECTS - INDEX_RESERVED))
    {
        BOOL                    fResult;
        BAD_APPLICATION_INFO    badApplicationInfo;

        //  Duplicate the HANDLE with SYNCHRONIZE access. That's
        //  all we need to call the wait function.

        fResult = DuplicateHandle(GetCurrentProcess(),
                                  hProcess,
                                  GetCurrentProcess(),
                                  &badApplicationInfo.hProcess,
                                  SYNCHRONIZE | PROCESS_QUERY_INFORMATION,
                                  FALSE,
                                  0);
        if (fResult != FALSE)
        {
            PROCESS_SESSION_INFORMATION     processSessionInformation;
            ULONG                           ulReturnLength;

            //  Add the information to the list.

            badApplicationInfo.bamType = bamType;
            badApplicationInfo.badApplication = badApplication;
            status = NtQueryInformationProcess(badApplicationInfo.hProcess,
                                               ProcessSessionInformation,
                                               &processSessionInformation,
                                               sizeof(processSessionInformation),
                                               &ulReturnLength);
            if (NT_SUCCESS(status))
            {
                badApplicationInfo.dwSessionID = processSessionInformation.SessionId;
                status = _badApplications.Add(&badApplicationInfo);
                if (NT_SUCCESS(status))
                {
                    status = _hEvent.Set();
                }
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::QueryInformation
//
//  Arguments:  badApplication  =   Bad application identifier to query.
//              hProcess        =   Handle to running process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Finds the given application in the running bad application
//              list and returns a duplicated handle to the caller.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::QueryInformation (const CBadApplication& badApplication, HANDLE& hProcess)

{
    NTSTATUS                    status;
    bool                        fResult;
    int                         i;
    CSingleThreadedExecution    listLock(_lock);

    //  Assume failure
    
    hProcess = NULL;
    status = STATUS_OBJECT_NAME_NOT_FOUND;

    fResult = false;

    //  Loop looking for a match. This uses the overloaded operator ==.

    for (i = _badApplications.GetCount() - 1; !fResult && (i >= 0); --i)
    {
        BAD_APPLICATION_INFO    badApplicationInfo;

        if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
        {

            //  Make sure the client is not in the same session as the running
            //  bad application. This API exists to prevent cross session instances.
            //  It's assumed that applications have their own mechanisms for multiple
            //  instances in the same session (or object name space).

            fResult = (badApplicationInfo.badApplication == badApplication);
            if (fResult)
            {
                if (DuplicateHandle(GetCurrentProcess(),
                                    badApplicationInfo.hProcess,
                                    GetCurrentProcess(),
                                    &hProcess,
                                    0,
                                    FALSE,
                                    DUPLICATE_SAME_ACCESS) != FALSE)
                {
                    status = STATUS_SUCCESS;
                }
                else
                {
                    status = CStatusCode::StatusCodeOfLastError();
                }
            }
        }
    }

    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::RequestSwitchUser
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute terminate of BAM_TYPE_SWITCH_USER. These appications
//              are really poorly behaved. A good example is a DVD player
//              which bypasses GDI and draws directly into the VGA stream.
//
//              Try to kill these and reject the request if it fails.
//
//  History:    2000-11-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::RequestSwitchUser (void)

{
    NTSTATUS    status;
    int         i;

    //  Walk the _badApplications list.

    status = STATUS_SUCCESS;
    _lock.Acquire();
    i = _badApplications.GetCount() - 1;
    while (NT_SUCCESS(status) && (i >= 0))
    {
        BAD_APPLICATION_INFO    badApplicationInfo;

        if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
        {

            //  Look for BAM_TYPE_SWITCH_USER processes. It doesn't matter
            //  what session ID is tagged. This process is getting terminated.

            if (badApplicationInfo.bamType == BAM_TYPE_SWITCH_USER)
            {

                //  In any case release the lock, kill the process
                //  remove it from the watch list. Then reset the
                //  index back to the end of the list. Make sure to
                //  account for the "--i;" instruction below by not
                //  decrementing by 1.

                _lock.Release();
                status = PerformTermination(badApplicationInfo.hProcess, false);
                _lock.Acquire();
                i = _badApplications.GetCount();
            }
        }
        --i;
    }
    _lock.Release();
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::PerformTermination
//
//  Arguments:  hProcess        =   Handle to running process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Terminates the given process. This is a common routine used
//              by both the internal wait thread of this class as well as
//              externally by bad application server itself.
//
//  History:    2000-10-23  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::PerformTermination (HANDLE hProcess, bool fAllowForceTerminate)

{
    NTSTATUS    status;

    status = TerminateGracefully(hProcess);
    if (!NT_SUCCESS(status) && fAllowForceTerminate)
    {
        status = TerminateForcibly(hProcess);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Entry
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Watcher thread for process objects. This thread builds the
//              array of proces handles to wait on as well as including the
//              synchronization event that gets signaled by the Add member
//              function. When that event is signaled the wait is re-executed
//              with the new array of objects to wait on.
//
//              When a process object is signaled it is cleared out of the
//              known list to allow further creates to succeed.
//
//              Acquisition of the critical section is carefully placed in
//              this function so that the critical section is not held when
//              the wait call is made.
//
//              Added to this is a window and a message pump to enable
//              listening for session notifications from terminal server.
//
//  History:    2000-08-25  vtan        created
//              2000-10-23  vtan        added HWND message pump mechanism
//  --------------------------------------------------------------------------

DWORD   CBadApplicationManager::Entry (void)

{
    WNDCLASSEX  wndClassEx;

    //  Register this window class.

    ZeroMemory(&wndClassEx, sizeof(wndClassEx));
    wndClassEx.cbSize = sizeof(WNDCLASSEX);
    wndClassEx.lpfnWndProc = NotificationWindowProc;
    wndClassEx.hInstance = _hInstance;
    wndClassEx.lpszClassName = TEXT("BadApplicationNotificationWindowClass");
    _atom = RegisterClassEx(&wndClassEx);

    //  Create the notification window

    _hwnd = CreateWindow(MAKEINTRESOURCE(_atom),
                         TEXT("BadApplicationNotificationWindow"),
                         WS_OVERLAPPED,
                         0, 0,
                         0, 0,
                         NULL,
                         NULL,
                         _hInstance,
                         this);

    if (_hwnd != NULL)
    {
        _fRegisteredNotification = (WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd, NOTIFY_FOR_ALL_SESSIONS) != FALSE);
        if (!_fRegisteredNotification)
        {
            _hModule = LoadLibrary(TEXT("shsvcs.dll"));
            if (_hModule != NULL)
            {
                DWORD   dwThreadID;
                HANDLE  hThread;

                //  If the register fails then create a thread to wait on the event
                //  and then register onces it's available. If the thread cannot be
                //  created it's no biggy. The notification mechanism fails and the
                //  welcome screen isn't updated.

                AddRef();
                hThread = CreateThread(NULL,
                                       0,
                                       RegisterThreadProc,
                                       this,
                                       0,
                                       &dwThreadID);
                if (hThread != NULL)
                {
                    TBOOL(CloseHandle(hThread));
                }
                else
                {
                    Release();
                    TBOOL(FreeLibrary(_hModule));
                    _hModule = NULL;
                }
            }
        }
    }

    //  Acquire the lock. This is necessary because to fill the array of
    //  handles to wait on requires access to the internal list.

    _lock.Acquire();
    do
    {
        DWORD                   dwWaitResult;
        int                     i, iLimit;
        BAD_APPLICATION_INFO    badApplicationInfo;
        HANDLE                  hArray[MAXIMUM_WAIT_OBJECTS];

        ZeroMemory(&hArray, sizeof(hArray));
        hArray[INDEX_EVENT] = _hEvent;
        iLimit = _badApplications.GetCount();
        for (i = 0; i < iLimit; ++i)
        {
            if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
            {
                hArray[INDEX_HANDLES + i] = badApplicationInfo.hProcess;
            }
        }

        //  Release the lock before we enter the wait state.
        //  Wait on ANY of the objects to be signaled.

        _lock.Release();
        dwWaitResult = MsgWaitForMultipleObjects(INDEX_HANDLES + iLimit,
                                                 hArray,
                                                 FALSE,
                                                 INFINITE,
                                                 QS_ALLINPUT);
        ASSERTMSG(dwWaitResult != WAIT_FAILED, "WaitForMultipleObjects failed in CBadApplicationManager::Entry");

        //  We were woken up by an object being signaled. Is this the
        //  synchronization object?

        dwWaitResult -= WAIT_OBJECT_0;
        if (dwWaitResult == INDEX_EVENT)
        {

            //  Yes. Acquire the lock. Reset the synchronization event. It's
            //  important to acquire the lock before resetting the event because
            //  the Add function could have the lock and be adding to the list.
            //  Once the Add function releases the lock it cannot signal the event.
            //  Otherwise we could reset the event during the Add function adding
            //  a new object and this would be missed.

            _lock.Acquire();
            TSTATUS(_hEvent.Reset());
        }

        //  No. Is this a message that requires dispatching as part of the
        //  message pump?

        else if (dwWaitResult == WAIT_OBJECT_0 + INDEX_HANDLES + static_cast<DWORD>(iLimit))
        {

            //  Yes. Remove the message from the message queue and dispatch it.

            MSG     msg;

            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != FALSE)
            {
                (BOOL)TranslateMessage(&msg);
                (LRESULT)DispatchMessage(&msg);
            }
            _lock.Acquire();
        }
        else
        {

            //  No. One of the bad applications we are watching has terminated
            //  and its proces object is now signaled. Go to the correct index
            //  in the array. Acquire the lock. Close the HANDLE. It's not needed
            //  anymore. Then remove the entry from the list.

            dwWaitResult -= INDEX_HANDLES;
            _lock.Acquire();
            if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, dwWaitResult)))
            {
                TBOOL(CloseHandle(badApplicationInfo.hProcess));
            }
            TSTATUS(_badApplications.Remove(dwWaitResult));
        }

        //  At this point we still hold the lock. This is important because the top
        //  of the loop expects the lock to be held to build the HANDLE array.

    } while (!_fTerminateWatcherThread);

    //  Clean up stuff that happened on this thread.

    Cleanup();

    //  If we here then the thread is being terminated for some reason.
    //  Release the lock. It doesn't matter what happens now anyway.

    _lock.Release();
    return(0);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::TerminateForcibly
//
//  Arguments:  hProcess    =   Process to terminate.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Inject a user mode thread into the process which calls
//              kernel32!ExitProcess. If the thread injection fails then fall
//              back to kernel32!TerminatProcess to force in.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::TerminateForcibly (HANDLE hProcess)

{
    NTSTATUS    status;
    HANDLE      hProcessTerminate;

    //  Duplicate the process handle and request all the access required
    //  to create a remote thread in the process.

    if (DuplicateHandle(GetCurrentProcess(),
                        hProcess,
                        GetCurrentProcess(),
                        &hProcessTerminate,
                        SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
                        FALSE,
                        0) != FALSE)
    {
        DWORD   dwWaitResult;
        HANDLE  hThread, hWaitArray[2];

        //  Go and create the remote thread that immediately turns
        //  around and calls kernel32!ExitProcess. This allows
        //  a clean process shutdown to occur. If this times out
        //  then kill the process with terminate process.

        status = RtlCreateUserThread(hProcessTerminate,
                                     NULL,
                                     FALSE,
                                     0,
                                     0,
                                     0,
                                     reinterpret_cast<PUSER_THREAD_START_ROUTINE>(ExitProcess),
                                     NULL,
                                     &hThread,
                                     NULL);
        if (NT_SUCCESS(status))
        {

            hWaitArray[0] = hThread;
            hWaitArray[1] = hProcessTerminate;
            dwWaitResult = WaitForMultipleObjects(ARRAYSIZE(hWaitArray),
                                                  hWaitArray,
                                                  TRUE,
                                                  5000);
            TBOOL(CloseHandle(hThread));
            if (dwWaitResult != WAIT_TIMEOUT)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = STATUS_TIMEOUT;
            }
        }
        if (status != STATUS_SUCCESS)
        {
            if (TerminateProcess(hProcessTerminate, 0) != FALSE)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
        }
        TBOOL(CloseHandle(hProcessTerminate));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::TerminateGracefully
//
//  Arguments:  hProcess    =   Process to terminate.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates a rundll32 process on the session of the target
//              process in WinSta0\Default which will re-enter this dll and
//              call the "terminate" functionality. This allows the process to
//              walk the window list corresponding to that session and send
//              those windows close messages and wait for graceful
//              termination.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CBadApplicationManager::TerminateGracefully (HANDLE hProcess)

{
    NTSTATUS                    status;
    ULONG                       ulReturnLength;
    PROCESS_BASIC_INFORMATION   processBasicInformation;

    status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &processBasicInformation,
                                       sizeof(processBasicInformation),
                                       &ulReturnLength);
    if (NT_SUCCESS(status))
    {
        HANDLE  hToken;

        if (OpenProcessToken(hProcess,
                             TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY,
                             &hToken) != FALSE)
        {
            STARTUPINFOW            startupInfo;
            PROCESS_INFORMATION     processInformation;
            WCHAR                   szCommandLine[MAX_PATH];

            ZeroMemory(&startupInfo, sizeof(startupInfo));
            ZeroMemory(&processInformation, sizeof(processInformation));
            startupInfo.cb = sizeof(startupInfo);
            startupInfo.lpDesktop = const_cast<WCHAR*>(s_szDefaultDesktop);
            wsprintfW(szCommandLine, L"rundll32 shsvcs.dll,FUSCompatibilityEntry terminate %d", static_cast<DWORD>(processBasicInformation.UniqueProcessId));
            if (CreateProcessAsUserW(hToken,
                                     NULL,
                                     szCommandLine,
                                     NULL,
                                     NULL,
                                     FALSE,
                                     0,
                                     NULL,
                                     NULL,
                                     &startupInfo,
                                     &processInformation) != FALSE)
            {
                DWORD   dwWaitResult;
                HANDLE  hArray[2];

                //  Assume that this whole thing failed.

                status = STATUS_UNSUCCESSFUL;
                TBOOL(CloseHandle(processInformation.hThread));

                //  Wait on both process objects. If the process to be terminated
                //  is signaled then the rundll32 stub did its job. If the rundll32
                //  stub is signaled then find out what its exit code is and either
                //  continue waiting on the process to be terminated or return back
                //  a code to the caller indicating success or failure. Failure
                //  forces the process to be terminated abruptly.

                hArray[0] = hProcess;
                hArray[1] = processInformation.hProcess;
                dwWaitResult = WaitForMultipleObjects(ARRAYSIZE(hArray),
                                                      hArray,
                                                      FALSE,
                                                      10000);

                //  If the process to be terminated is signaled then we're done.

                if (dwWaitResult == WAIT_OBJECT_0)
                {
                    status = STATUS_SUCCESS;
                }

                //  If the rundll32 stub is signaled then find out what it found.

                else if (dwWaitResult == WAIT_OBJECT_0 + 1)
                {
                    DWORD   dwExitCode;

                    dwExitCode = STILL_ACTIVE;
                    if (GetExitCodeProcess(processInformation.hProcess, &dwExitCode) != FALSE)
                    {
                        ASSERTMSG((dwExitCode == CGracefulTerminateApplication::NO_WINDOWS_FOUND) || (dwExitCode == CGracefulTerminateApplication::WAIT_WINDOWS_FOUND), "Unexpected process exit code in CBadApplicationManager::TerminateGracefully");

                        //  If the rundll32 stub says it found some windows then
                        //  wait for the process to terminate itself.

                        if (dwExitCode == CGracefulTerminateApplication::WAIT_WINDOWS_FOUND)
                        {

                            //  If the process terminates within the timeout period
                            //  then we're done.

                            if (WaitForSingleObject(hProcess, 10000) == WAIT_OBJECT_0)
                            {
                                status = STATUS_SUCCESS;
                            }
                        }
                    }
                }
                TBOOL(CloseHandle(processInformation.hProcess));
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseHandle(hToken));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Cleanup
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases used resources in the class. Used by both the
//              constructor and the thread - whoever wins.
//
//  History:    2000-12-12  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Cleanup (void)

{
    if (_fRegisteredNotification)
    {
        (BOOL)WinStationUnRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd);
        _fRegisteredNotification = false;
    }
    if (_hwnd != NULL)
    {
        TBOOL(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
    if (_atom != 0)
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atom), _hInstance));
        _atom = 0;
    }
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_Logon
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Nothing at present.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Handle_Logon (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_Logoff
//
//  Arguments:  dwSessionID     =   Session ID that is logging off.
//
//  Returns:    <none>
//
//  Purpose:    Remove any restore processes we have in the list. The user
//              is logging off so they shouldn't come back. Releases the last
//              user to actively connect to the machine.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Handle_Logoff (DWORD dwSessionID)

{
    int                         i;
    CSingleThreadedExecution    listLock(_lock);

    for (i = _restoreApplications.GetCount() - 1; i >= 0; --i)
    {
        CRestoreApplication     *pRestoreApplication;

        pRestoreApplication = static_cast<CRestoreApplication*>(_restoreApplications.Get(i));
        if ((pRestoreApplication != NULL) &&
            pRestoreApplication->IsEqualSessionID(dwSessionID))
        {
            TSTATUS(_restoreApplications.Remove(i));
        }
    }
    ReleaseHandle(_hTokenLastUser);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_Connect
//
//  Arguments:  dwSessionID     =   Session ID connecting.
//              hToken          =   Handle to token of user connecting.
//
//  Returns:    <none>
//
//  Purpose:    Handles BAM3. This is the save for restoration all processes
//              that use resources that aren't easily shared and restore all
//              processes that were saved which aren't easily shared.
//
//              It's optimized for not closing the processes of the same user
//              should that user re-connect. This allows the screen saver to
//              kick in and return to welcome without killing the user's
//              processes unnecessarily.
//
//              Also handles BAM4.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Handle_Connect (DWORD dwSessionID, HANDLE hToken)

{
    if ((_hTokenLastUser != NULL) && (hToken != NULL))
    {
        PSID                pSIDLastUser, pSIDCurrentUser;
        CTokenInformation   tokenLastUser(_hTokenLastUser);
        CTokenInformation   tokenCurrentUser(hToken);

        pSIDLastUser = tokenLastUser.GetUserSID();
        pSIDCurrentUser = tokenCurrentUser.GetUserSID();
        if ((pSIDLastUser != NULL) && (pSIDCurrentUser != NULL) && !EqualSid(pSIDLastUser, pSIDCurrentUser))
        {
            int                     i;
            DWORD                   dwSessionIDMatch;
            ULONG                   ulReturnLength;
            CRestoreApplication     *pRestoreApplication;

            if (NT_SUCCESS(NtQueryInformationToken(_hTokenLastUser,
                                                   TokenSessionId,
                                                   &dwSessionIDMatch,
                                                   sizeof(dwSessionIDMatch),
                                                   &ulReturnLength)))
            {

                //  Walk the _badApplications list.

                _lock.Acquire();
                i = _badApplications.GetCount() - 1;
                while (i >= 0)
                {
                    BAD_APPLICATION_INFO    badApplicationInfo;

                    if (NT_SUCCESS(_badApplications.Get(&badApplicationInfo, i)))
                    {
                        bool    fTerminateProcess;

                        fTerminateProcess = false;

                        //  Look for BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE processes
                        //  which have token session IDs that match the _hTokenLastUser
                        //  session ID. These processes must be terminated and added to
                        //  a list to be restarted on reconnection.

                        if ((badApplicationInfo.bamType == BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE) &&
                            (badApplicationInfo.dwSessionID == dwSessionIDMatch))
                        {
                            pRestoreApplication = new CRestoreApplication;
                            if (pRestoreApplication != NULL)
                            {
                                if (NT_SUCCESS(pRestoreApplication->GetInformation(badApplicationInfo.hProcess)))
                                {
                                    TSTATUS(_restoreApplications.Add(pRestoreApplication));
                                    fTerminateProcess = true;
                                }
                                pRestoreApplication->Release();
                            }
                        }

                        //  Look for BAM_TYPE_SWITCH_TO_NEW_USER (even though this is
                        //  a connect/reconnect). Always kill these processes.

                        if (badApplicationInfo.bamType == BAM_TYPE_SWITCH_TO_NEW_USER)
                        {
                            fTerminateProcess = true;
                        }
                        if (fTerminateProcess)
                        {

                            //  In any case release the lock, kill the process
                            //  remove it from the watch list. Then reset the
                            //  index back to the end of the list. Make sure to
                            //  account for the "--i;" instruction below by not
                            //  decrementing by 1.

                            _lock.Release();
                            TSTATUS(PerformTermination(badApplicationInfo.hProcess, true));
                            _lock.Acquire();
                            TBOOL(CloseHandle(badApplicationInfo.hProcess));
                            TSTATUS(_badApplications.Remove(i));
                            i = _badApplications.GetCount();
                        }
                    }
                    --i;
                }
                _lock.Release();
            }

            //  Now walk the restore list looking for matches against the
            //  connecting session ID. Restore these processes.

            _lock.Acquire();
            i = _restoreApplications.GetCount() - 1;
            while (i >= 0)
            {
                pRestoreApplication = static_cast<CRestoreApplication*>(_restoreApplications.Get(i));
                if ((pRestoreApplication != NULL) &&
                    pRestoreApplication->IsEqualSessionID(dwSessionID))
                {
                    HANDLE  hProcess;

                    _lock.Release();
                    if (NT_SUCCESS(pRestoreApplication->Restore(&hProcess)))
                    {
                        CBadApplication     badApplication(pRestoreApplication->GetCommandLine());

                        TBOOL(CloseHandle(hProcess));
                    }
                    _lock.Acquire();
                    TSTATUS(_restoreApplications.Remove(i));
                    i = _restoreApplications.GetCount();
                }
                --i;
            }
            _lock.Release();
        }
    }
    if (hToken != NULL)
    {
        _dwSessionIDLastConnect = static_cast<DWORD>(-1);
    }
    else
    {
        _dwSessionIDLastConnect = dwSessionID;
    }
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_Disconnect
//
//  Arguments:  dwSessionID     =   Session ID that is disconnecting.
//              hToken          =   Token of the user disconnecting.
//
//  Returns:    <none>
//
//  Purpose:    If the session isn't the same as the last connected session
//              then release the last user token and save the current one.
//
//  History:    2000-10-24  vtan        created
//  --------------------------------------------------------------------------

void    CBadApplicationManager::Handle_Disconnect (DWORD dwSessionID, HANDLE hToken)

{
    if (_dwSessionIDLastConnect != dwSessionID)
    {
        ReleaseHandle(_hTokenLastUser);
        if (hToken != NULL)
        {
            TBOOL(DuplicateHandle(GetCurrentProcess(),
                                  hToken,
                                  GetCurrentProcess(),
                                  &_hTokenLastUser,
                                  0,
                                  FALSE,
                                  DUPLICATE_SAME_ACCESS));
        }
    }
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::Handle_WM_WTSSESSION_CHANGE
//
//  Arguments:  wParam  =   Type of session change.
//              lParam  =   Pointer to WTSSESSION_NOTIFICATION struct.
//
//  Returns:    LRESULT
//
//  Purpose:    Handles WM_WTSSESSION_CHANGE messages.
//
//  History:    2000-10-23  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CBadApplicationManager::Handle_WM_WTSSESSION_CHANGE (WPARAM wParam, LPARAM lParam)

{
    ULONG                       ulReturnLength;
    WINSTATIONUSERTOKEN         winStationUserToken;

    winStationUserToken.ProcessId = reinterpret_cast<HANDLE>(GetCurrentProcessId());
    winStationUserToken.ThreadId = reinterpret_cast<HANDLE>(GetCurrentThreadId());
    winStationUserToken.UserToken = NULL;
    (BOOLEAN)WinStationQueryInformation(SERVERNAME_CURRENT,
                                        lParam,
                                        WinStationUserToken,
                                        &winStationUserToken,
                                        sizeof(winStationUserToken),
                                        &ulReturnLength);
    switch (wParam)
    {
        case WTS_SESSION_LOGOFF:
            Handle_Logoff(lParam);
            break;
        case WTS_SESSION_LOGON:
            Handle_Logon();
            //  Fall thru to connect case.
        case WTS_CONSOLE_CONNECT:
        case WTS_REMOTE_CONNECT:
            Handle_Connect(lParam, winStationUserToken.UserToken);
            break;
        case WTS_CONSOLE_DISCONNECT:
        case WTS_REMOTE_DISCONNECT:
            Handle_Disconnect(lParam, winStationUserToken.UserToken);
            break;
        default:
            break;
    }
    if (winStationUserToken.UserToken != NULL)
    {
        TBOOL(CloseHandle(winStationUserToken.UserToken));
    }
    return(1);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::NotificationWindowProc
//
//  Arguments:  See the platform SDK under WindowProc.
//
//  Returns:    LRESULT
//
//  Purpose:    Handles messages for the Notification window.
//
//  History:    2000-10-23  vtan        created
//  --------------------------------------------------------------------------

LRESULT CALLBACK    CBadApplicationManager::NotificationWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    LRESULT                 lResult;
    CBadApplicationManager  *pThis;

    pThis = reinterpret_cast<CBadApplicationManager*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT    *pCreateStruct;

            pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pCreateStruct->lpCreateParams));
            lResult = 0;
            break;
        }
        case WM_WTSSESSION_CHANGE:
            lResult = pThis->Handle_WM_WTSSESSION_CHANGE(wParam, lParam);
            break;
        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }
    return(lResult);
}

//  --------------------------------------------------------------------------
//  CBadApplicationManager::RegisterThreadProc
//
//  Arguments:  pParameter  =   Object pointer.
//
//  Returns:    DWORD
//
//  Purpose:    Opens the TermSrvReadyEvent and waits on it. Once ready it
//              registers for a notifications.
//
//  History:    2000-10-23  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CBadApplicationManager::RegisterThreadProc (void *pParameter)

{
    int                     iCounter;
    HANDLE                  hTermSrvReadyEvent;
    HMODULE                 hModule;
    CBadApplicationManager  *pThis;

    pThis = reinterpret_cast<CBadApplicationManager*>(pParameter);
    hModule = pThis->_hModule;
    ASSERTMSG(hModule != NULL, "NULL HMODULE in CBadApplicationManager::RegisterThreadProc");
    iCounter = 0;
    hTermSrvReadyEvent = OpenEvent(SYNCHRONIZE,
                                   FALSE,
                                   TEXT("TermSrvReadyEvent"));
    while ((hTermSrvReadyEvent == NULL) && (iCounter < 60))
    {
        ++iCounter;
        Sleep(1000);
        hTermSrvReadyEvent = OpenEvent(SYNCHRONIZE,
                                       FALSE,
                                       TEXT("TermSrvReadyEvent"));
    }
    if (hTermSrvReadyEvent != NULL)
    {
        if (WaitForSingleObject(hTermSrvReadyEvent, 60000) == WAIT_OBJECT_0)
        {
            pThis->_fRegisteredNotification = (WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, pThis->_hwnd, NOTIFY_FOR_ALL_SESSIONS) != FALSE);
        }
        TBOOL(CloseHandle(hTermSrvReadyEvent));
    }
    pThis->Release();
    FreeLibraryAndExitThread(hModule, 0);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationmanager.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationManager.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Classes to manage bad applications in the fast user switching environment.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationManager_
#define     _BadApplicationManager_

#include <lpcfus.h>

#include "BadApplication.h"
#include "DynamicArray.h"
#include "KernelResources.h"
#include "Thread.h"

//  --------------------------------------------------------------------------
//  CBadApplicationManager
//
//  Purpose:    Implements managing of bad applications started on this
//              machine. This object should only exist once.
//
//  History:    2000-08-25  vtan        created
//  --------------------------------------------------------------------------

class   CBadApplicationManager : public CThread
{
    private:
        typedef struct
        {
            HANDLE                      hProcess;
            BAM_TYPE                    bamType;
            DWORD                       dwSessionID;
            CBadApplication             badApplication;
        } BAD_APPLICATION_INFO, *PBAD_APPLICATION_INFO;
    public:
                                            CBadApplicationManager (HINSTANCE hInstance);
        virtual                             ~CBadApplicationManager (void);

                NTSTATUS                    Terminate (void);
                bool                        QueryRunning (const CBadApplication& badApplication, DWORD dwSessionID);
                NTSTATUS                    RegisterRunning (const CBadApplication& badApplication, HANDLE hProcess, BAM_TYPE bamType);
                NTSTATUS                    QueryInformation (const CBadApplication& badApplication, HANDLE& hProcess);
                NTSTATUS                    RequestSwitchUser (void);

        static  NTSTATUS                    PerformTermination (HANDLE hProcess, bool fAllowForceTerminate);
    protected:
        virtual DWORD                       Entry (void);
    private:
        static  NTSTATUS                    TerminateForcibly (HANDLE hProcess);
        static  NTSTATUS                    TerminateGracefully (HANDLE hProcess);

                void                        Cleanup (void);
                void                        Handle_Logon (void);
                void                        Handle_Logoff (DWORD dwSessionID);
                void                        Handle_Connect (DWORD dwSessionID, HANDLE hToken);
                void                        Handle_Disconnect (DWORD dwSessionID, HANDLE hToken);
                LRESULT                     Handle_WM_WTSSESSION_CHANGE (WPARAM wParam, LPARAM lParam);
        static  LRESULT CALLBACK            NotificationWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static  DWORD   WINAPI              RegisterThreadProc (void *pParameter);
    private:
                HINSTANCE                   _hInstance;
                HMODULE                     _hModule;
                ATOM                        _atom;
                HWND                        _hwnd;
                bool                        _fTerminateWatcherThread,
                                            _fRegisteredNotification;
                DWORD                       _dwSessionIDLastConnect;
                HANDLE                      _hTokenLastUser;
                CCriticalSection            _lock;
                CEvent                      _hEvent;
                CDynamicArray               _badApplications;
                CDynamicCountedObjectArray  _restoreApplications;

        static  const int                   INDEX_EVENT;
        static  const int                   INDEX_HANDLES;
        static  const int                   INDEX_RESERVED;
        static  const WCHAR                 s_szDefaultDesktop[];
};

#endif  /*  _BadApplicationManager_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\bamservice.h ===
//  --------------------------------------------------------------------------
//  Module Name: BAMService.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that are called from the shell services DLL
//  to interact with the FUS service.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _BAMService_
#define     _BAMService_

//  --------------------------------------------------------------------------
//  CThemeService
//
//  Purpose:    Class that implements entry points for the common shell
//              service to invoke BAM service functionality.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

class   CBAMService
{
    public:
        static  NTSTATUS    Main (DWORD dwReason);
        static  NTSTATUS    RegisterServer (void);
        static  NTSTATUS    UnregisterServer (void);
};

#endif  /*  _BAMService_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationservice.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationService.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the bad application manager
//  service specifics.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "BadApplicationService.h"

const TCHAR     CBadApplicationService::s_szName[]   =   TEXT("FastUserSwitchingCompatibility");

//  --------------------------------------------------------------------------
//  CBadApplicationService::CBadApplicationService
//
//  Arguments:  pAPIConnection  =   CAPIConnection passed to base class.
//              pServerAPI      =   CServerAPI passed to base class.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CBadApplicationService.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationService::CBadApplicationService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI) :
    CService(pAPIConnection, pServerAPI, GetName())

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationService::~CBadApplicationService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CBadApplicationService.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

CBadApplicationService::~CBadApplicationService (void)

{
}

//  --------------------------------------------------------------------------
//  CBadApplicationService::GetName
//
//  Arguments:  <none>
//
//  Returns:    const TCHAR*
//
//  Purpose:    Returns the name of the service (ThemeService).
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

const TCHAR*    CBadApplicationService::GetName (void)

{
    return(s_szName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\bamservice.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BAMService.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that are called from the shell services DLL
//  to interact with the BAM service.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "BAMService.h"
#include <shlwapi.h>
#include <shlwapip.h>

#include "BadApplicationAPIRequest.h"
#include "BadApplicationAPIServer.h"
#include "BadApplicationService.h"
#include "Resource.h"

extern  HINSTANCE   g_hInstance;

//  --------------------------------------------------------------------------
//  CThemeService::Main
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Performs initialization and clean up on process attach and
//              detach. Not interested in anything else.
//
//  History:    2000-10-12  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CBAMService::Main (DWORD dwReason)

{
    UNREFERENCED_PARAMETER(dwReason);

    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::DllRegisterServer
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Register entry point to allow the BAM server to install
//              itself into the registry.
//
//  History:    2000-12-04  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CBAMService::RegisterServer (void)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;

#ifdef _WIN64

    //  In upgrade cases for 64-bit, remove the service

    (NTSTATUS)CService::Remove(CBadApplicationService::GetName());

#else
    
    //  This is 32-bit only. Check if this is REALLY 32-bit and not 32-bit on 64-bit.

    if (!IsOS(OS_WOW6432))
    {
        static  const TCHAR     s_szDependencies[]  =   TEXT("TermService\0");

        //  Now install the new service by name.

        status = CService::Install(CBadApplicationService::GetName(),
                                   TEXT("%SystemRoot%\\System32\\svchost.exe -k netsvcs"),
                                   NULL,
                                   NULL,
                                   TEXT("shsvcs.dll"),
                                   s_szDependencies,
                                   TEXT("netsvcs"),
                                   TEXT("BadApplicationServiceMain"),
                                   SERVICE_DEMAND_START,
                                   g_hInstance,
                                   IDS_BAMSERVER_DISPLAYNAME,
                                   IDS_BAMSERVER_DESCRIPTION);
    }

#endif

    return(status);
}

//  --------------------------------------------------------------------------
//  ::DllUnregisterServer
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Unregister entry point to allow the BAM server to uninstall
//              itself from the registry.
//
//  History:    2000-12-04  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CBAMService::UnregisterServer (void)

{
    (NTSTATUS)CService::Remove(CBadApplicationService::GetName());
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::BadApplicationServiceMain
//
//  Arguments:  dwArgc      =   Number of arguments.
//              lpszArgv    =   Argument array.
//
//  Returns:    <none>
//
//  Purpose:    ServiceMain entry point for BAM server.
//
//  History:    2000-11-28  vtan        created
//              2001-01-02  vtan        scoped to the BAM service
//  --------------------------------------------------------------------------

#ifdef      _X86_

void    WINAPI  BadApplicationServiceMain (DWORD dwArgc, LPWSTR *lpszArgv)

{
    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpszArgv);

    NTSTATUS    status;

    //  Because svchost doesn't unload the DLL ever we need to call static
    //  initializers here so that if the service is stopped and restarted
    //  the static member variables can be initialized. Statically destruct
    //  what was initialized. The initialize code accounts for already
    //  initialized member variables.

    status = CBadApplicationAPIRequest::StaticInitialize(g_hInstance);
    if (NT_SUCCESS(status))
    {
        CBadApplicationAPIServer    *pBadApplicationAPIServer;

        pBadApplicationAPIServer = new CBadApplicationAPIServer;
        if (pBadApplicationAPIServer != NULL)
        {
            CAPIConnection  *pAPIConnection;

            pAPIConnection = new CAPIConnection(pBadApplicationAPIServer);
            if (pAPIConnection != NULL)
            {
                CBadApplicationService  *pBadApplicationService;

                pBadApplicationService = new CBadApplicationService(pAPIConnection, pBadApplicationAPIServer);
                if (pBadApplicationService != NULL)
                {
                    static  SID_IDENTIFIER_AUTHORITY    s_SecurityWorldAuthority    =   SECURITY_WORLD_SID_AUTHORITY;

                    PSID    pSIDWorld;

                    //  Explicitly add access for S-1-1-0 <everybody> as PORT_CONNECT.

                    if (AllocateAndInitializeSid(&s_SecurityWorldAuthority,
                                                 1,
                                                 SECURITY_WORLD_RID,
                                                 0, 0, 0, 0, 0, 0, 0,
                                                 &pSIDWorld) != FALSE)
                    {
                        TSTATUS(pAPIConnection->AddAccess(pSIDWorld, PORT_CONNECT));
                        (void*)FreeSid(pSIDWorld);
                    }
                    pBadApplicationService->Start();
                    pBadApplicationService->Release();
                }
                pAPIConnection->Release();
            }
            pBadApplicationAPIServer->Release();
        }
        TSTATUS(CBadApplicationAPIRequest::StaticTerminate());
    }
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\badapplicationservice.h ===
//  --------------------------------------------------------------------------
//  Module Name: BadApplicationService.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the bad application manager
//  service specifics.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _BadApplicationService_
#define     _BadApplicationService_

#include "Service.h"

//  --------------------------------------------------------------------------
//  CBadApplicationService
//
//  Purpose:    Implements bad application manager server specific
//              functionality to the CService class.
//
//  History:    2000-12-04  vtan        created
//  --------------------------------------------------------------------------

class   CBadApplicationService : public CService
{
    private:
                                CBadApplicationService (void);
    public:
                                CBadApplicationService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI);
        virtual                 ~CBadApplicationService (void);
    public:
        static  const TCHAR*    GetName (void);
    private:
        static  const TCHAR     s_szName[];
};

#endif  /*  _BadApplicationService_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\gracefulterminateapplication.h ===
//  --------------------------------------------------------------------------
//  Module Name: GracefulTerminateApplication.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manager terminating applications gracefully.
//
//  History:    2000-10-27  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifndef     _GracefulTerminateApplication_
#define     _GracefulTerminateApplication_

#include <lpcfus.h>

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication
//
//  Purpose:    Class that works on the user side to try to gracefully
//              terminate a bad process.
//
//  History:    2000-10-27  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

class   CGracefulTerminateApplication
{
    public:
        enum
        {
            NO_WINDOWS_FOUND    =   47647,
            WAIT_WINDOWS_FOUND  =   48517
        };
    public:
                                    CGracefulTerminateApplication (void);
                                    ~CGracefulTerminateApplication (void);

                void                Terminate (DWORD dwProcessID);
        static  void                Prompt (HINSTANCE hInstance, HANDLE hProcess);
    private:
        static  bool                ShowPrompt (HINSTANCE hInstance, const WCHAR *pszImageName);
        static  bool                CanTerminateFirstInstance (HANDLE hPort, const WCHAR *pszImageName, WCHAR *pszUser, int cchUser);
        static  bool                TerminatedFirstInstance (HANDLE hPort, const WCHAR *pszImageName);
        static  BOOL    CALLBACK    EnumWindowsProc (HWND hwnd, LPARAM lParam);
    private:
                DWORD               _dwProcessID;
                bool                _fFoundWindow;
};

#endif  /*  _GracefulTerminateApplication_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\gracefulterminateapplication.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: GracefulTerminateApplication.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manager terminating applications gracefully.
//
//  History:    2000-10-27  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "GracefulTerminateApplication.h"

#include "KernelResources.h"
#include "Thread.h"
#include "WarningDialog.h"

//  --------------------------------------------------------------------------
//  CProgressDialog
//
//  Purpose:    A class to manage displaying a progress dialog on a separate
//              thread if a certain period of time elapses. This is so that
//              in case the process doesn't terminate in a period of time
//              a dialog indicating wait is shown so the user is not left
//              staring at a blank screen.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

class   CProgressDialog : public CThread
{
    private:
                                    CProgressDialog (void);
    public:
                                    CProgressDialog (CWarningDialog *pWarningDialog);
        virtual                     ~CProgressDialog (void);

                void                SignalTerminated (void);
    protected:
        virtual DWORD               Entry (void);
    private:
                CWarningDialog*     _pWarningDialog;
                CEvent              _event;
};

//  --------------------------------------------------------------------------
//  CProgressDialog::CProgressDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CProgressDialog. Keeps a reference to the
//              given CWarningDialog.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

CProgressDialog::CProgressDialog (CWarningDialog *pWarningDialog) :
    _pWarningDialog(NULL),
    _event(NULL)

{
    if (IsCreated())
    {
        pWarningDialog->AddRef();
        _pWarningDialog = pWarningDialog;
        Resume();
    }
}

//  --------------------------------------------------------------------------
//  CProgressDialog::~CProgressDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the CWarningDialog reference.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

CProgressDialog::~CProgressDialog (void)

{
    _pWarningDialog->Release();
    _pWarningDialog = NULL;
}

//  --------------------------------------------------------------------------
//  CProgressDialog::SignalTerminated
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Signals the internal event that the process being watched is
//              termination. This is necessary because there is no handle to
//              the actual process to watch as it's kept on the server side
//              and not given to us the client. However, the result of the
//              termination is. Signaling this object will release the waiting
//              thread and cause it to exit.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

void    CProgressDialog::SignalTerminated (void)

{
    TSTATUS(_event.Set());
}

//  --------------------------------------------------------------------------
//  CProgressDialog::Entry
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Thread which waits for the internal event to be signaled. If
//              the event is signaled it will "cancel" the 3 second wait and
//              the thread will exit. Otherwise the wait times out and the
//              progress dialog is shown - waiting for termination.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

DWORD   CProgressDialog::Entry (void)

{
    DWORD   dwWaitResult;

    //  Wait for the event to be signaled or for it to timeout. If signaled
    //  then the process is terminated and no progress is required. Otherwise
    //  prepare to show progress while the process is being terminated.

    if (NT_SUCCESS(_event.Wait(2000, &dwWaitResult)) && (WAIT_TIMEOUT == dwWaitResult))
    {
        _pWarningDialog->ShowProgress(100, 7500);
    }
    return(0);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::CGracefulTerminateApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CGracefulTerminateApplication.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

CGracefulTerminateApplication::CGracefulTerminateApplication (void) :
    _dwProcessID(0),
    _fFoundWindow(false)

{
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::~CGracefulTerminateApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CGracefulTerminateApplication.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

CGracefulTerminateApplication::~CGracefulTerminateApplication (void)

{
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::Terminate
//
//  Arguments:  dwProcessID     =   Process ID of process to terminate.
//
//  Returns:    <none>
//
//  Purpose:    Walk the window list for top level windows that correspond
//              to this process ID and are visible. Close them. The callback
//              handles the work and this function returns the result in the
//              process exit code which the server examines.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

void    CGracefulTerminateApplication::Terminate (DWORD dwProcessID)

{
    DWORD   dwExitCode;

    _dwProcessID = dwProcessID;
    TBOOL(EnumWindows(EnumWindowsProc, reinterpret_cast<LPARAM>(this)));
    if (_fFoundWindow)
    {
        dwExitCode = WAIT_WINDOWS_FOUND;
    }
    else
    {
        dwExitCode = NO_WINDOWS_FOUND;
    }
    ExitProcess(dwExitCode);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::Prompt
//
//  Arguments:  hInstance   =   HINSTANCE of this DLL.
//              hProcess    =   Inherited handle to parent process.
//
//  Returns:    <none>
//
//  Purpose:    Shows a prompt that handles termination of the parent of this
//              process. The parent is assumed to be a bad application type 1
//              that caused this stub to be executed via the
//              "rundll32 shsvcs.dll,FUSCompatibilityEntry prompt" command.
//              Because there can only be a single instance of the type 1
//              application running and the parent of this process hasn't
//              registered yet querying for this process by image name will
//              always find the correct process.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

void    CGracefulTerminateApplication::Prompt (HINSTANCE hInstance, HANDLE hProcess)

{
    bool                        fTerminated;
    ULONG                       ulReturnLength;
    PROCESS_BASIC_INFORMATION   processBasicInformation;

    //  Read the parent's image name from the RTL_USER_PROCESS_PARAMETERS.

    fTerminated = false;
    if (hProcess != NULL)
    {
        if (NT_SUCCESS(NtQueryInformationProcess(hProcess,
                                                 ProcessBasicInformation,
                                                 &processBasicInformation,
                                                 sizeof(processBasicInformation),
                                                 &ulReturnLength)))
        {
            SIZE_T  dwNumberOfBytesRead;
            PEB     peb;

            if (ReadProcessMemory(hProcess,
                                  processBasicInformation.PebBaseAddress,
                                  &peb,
                                  sizeof(peb),
                                  &dwNumberOfBytesRead) != FALSE)
            {
                RTL_USER_PROCESS_PARAMETERS     processParameters;

                if (ReadProcessMemory(hProcess,
                                      peb.ProcessParameters,
                                      &processParameters,
                                      sizeof(processParameters),
                                      &dwNumberOfBytesRead) != FALSE)
                {
                    WCHAR   *pszImageName;

                    pszImageName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, processParameters.ImagePathName.Length + (sizeof('\0') * sizeof(WCHAR))));
                    if (pszImageName != NULL)
                    {
                        if (ReadProcessMemory(hProcess,
                                              processParameters.ImagePathName.Buffer,
                                              pszImageName,
                                              processParameters.ImagePathName.Length,
                                              &dwNumberOfBytesRead) != FALSE)
                        {
                            pszImageName[processParameters.ImagePathName.Length / sizeof(WCHAR)] = L'\0';

                            //  And show a prompt for this process.

                            fTerminated = ShowPrompt(hInstance, pszImageName);
                        }
                        (HLOCAL)LocalFree(pszImageName);
                    }
                }
            }
        }
        TBOOL(CloseHandle(hProcess));
    }
    ExitProcess(fTerminated);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::ShowPrompt
//
//  Arguments:  hInstance       =   HINSTANCE of this DLL.
//              pszImagename    =   Image name of process to terminate.
//
//  Returns:    bool
//
//  Purpose:    Shows the appropriate prompt for termination of the first
//              instance of a BAM type 1 process. If the current user does
//              not have administrator privileges then a "STOP" dialog is
//              shown that the user must get the other user to close the
//              program. Otherwise the "PROMPT" dialog is shown which gives
//              the user the option to terminate the process.
//
//              If termination is requested and the termatinion fails the
//              another warning dialog to that effect is shown.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CGracefulTerminateApplication::ShowPrompt (HINSTANCE hInstance, const WCHAR *pszImageName)

{
    bool                            fTerminated;
    ULONG                           ulConnectionInfoLength;
    HANDLE                          hPort;
    UNICODE_STRING                  portName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[32];

    fTerminated = false;
    RtlInitUnicodeString(&portName, FUS_PORT_NAME);
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    lstrcpyW(szConnectionInfo, FUS_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    if (NT_SUCCESS(NtConnectPort(&hPort,
                                 &portName,
                                 &sqos,
                                 NULL,
                                 NULL,
                                 NULL,
                                 szConnectionInfo,
                                 &ulConnectionInfoLength)))
    {
        bool            fCanTerminateFirstInstance;
        CWarningDialog  *pWarningDialog;
        WCHAR           szUser[256];

        //  Get the user's privilege level for this operation. This API also
        //  returns the current user for the BAM type 1 process.

        fCanTerminateFirstInstance = CanTerminateFirstInstance(hPort, pszImageName, szUser, ARRAYSIZE(szUser));
        pWarningDialog = new CWarningDialog(hInstance, NULL, pszImageName, szUser);
        if (pWarningDialog != NULL)
        {

            //  Show the appropriate dialog based on the privilege level.

            if (pWarningDialog->ShowPrompt(fCanTerminateFirstInstance) == IDOK)
            {
                CProgressDialog     *pProgressDialog;

                //  Create a progress dialog object in case of delayed termination.
                //  This will create the watcher thread.

                pProgressDialog = new CProgressDialog(pWarningDialog);
                if ((pProgressDialog != NULL) && !pProgressDialog->IsCreated())
                {
                    pProgressDialog->Release();
                    pProgressDialog = NULL;
                }

                //  Attempt to terminate the process if requested by the user.

                fTerminated = TerminatedFirstInstance(hPort, pszImageName);

                //  Once this function returns signal the event (in case the
                //  thread is still waiting). If the thread is still waiting this
                //  effectively cancels the dialog. Either way if the dialog is
                //  shown then close it, wait for the thread to exit and release
                //  the reference to destroy the object.

                if (pProgressDialog != NULL)
                {
                    pProgressDialog->SignalTerminated();
                    pWarningDialog->CloseDialog();
                    pProgressDialog->WaitForCompletion(INFINITE);
                    pProgressDialog->Release();
                }

                //  If there was some failure then let the user know.

                if (!fTerminated)
                {
                    pWarningDialog->ShowFailure();
                }
            }
            pWarningDialog->Release();
        }
        TBOOL(CloseHandle(hPort));
    }
    return(fTerminated);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::CanTerminateFirstInstance
//
//  Arguments:  hPort           =   Port to server.
//              pszImageName    =   Image name of process to terminate.
//              pszUser         =   User of process (returned).
//              cchUser         =   Count of characters for buffer.
//
//  Returns:    bool
//
//  Purpose:    Asks the server whether the current user has privileges to
//              terminate the BAM type 1 process of the given image name
//              which is known to be running. The API returns whether the
//              operation is allowed and who the current user of the process
//              is.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CGracefulTerminateApplication::CanTerminateFirstInstance (HANDLE hPort, const WCHAR *pszImageName, WCHAR *pszUser, int cchUser)

{
    bool    fCanTerminate;

    fCanTerminate = false;
    if ((hPort != NULL) && (pszImageName != NULL))
    {
        FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_QUERYUSERPERMISSION;
        portMessageIn.apiBAM.apiSpecific.apiQueryUserPermission.in.pszImageName = pszImageName;
        portMessageIn.apiBAM.apiSpecific.apiQueryUserPermission.in.cchImageName = lstrlen(pszImageName) + sizeof('\0');
        portMessageIn.apiBAM.apiSpecific.apiQueryUserPermission.in.pszUser = pszUser;
        portMessageIn.apiBAM.apiSpecific.apiQueryUserPermission.in.cchUser = cchUser;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
        if (NT_SUCCESS(NtRequestWaitReplyPort(hPort, &portMessageIn.portMessage, &portMessageOut.portMessage)) &&
            NT_SUCCESS(portMessageOut.apiBAM.apiGeneric.status))
        {
            fCanTerminate = portMessageOut.apiBAM.apiSpecific.apiQueryUserPermission.out.fCanShutdownApplication;
            pszUser[cchUser - sizeof('\0')] = L'\0';
        }
        else
        {
            pszUser[0] = L'\0';
        }
    }
    return(fCanTerminate);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::TerminatedFirstInstance
//
//  Arguments:  hPort           =   Port to server.
//              pszImageName    =   Image name to terminate.
//
//  Returns:    bool
//
//  Purpose:    Asks the server to terminate the first running instance of the
//              BAM type 1 process.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CGracefulTerminateApplication::TerminatedFirstInstance (HANDLE hPort, const WCHAR *pszImageName)

{
    bool    fTerminated;

    fTerminated = false;
    if (hPort != NULL)
    {
        FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_TERMINATERUNNING;
        portMessageIn.apiBAM.apiSpecific.apiTerminateRunning.in.pszImageName = pszImageName;
        portMessageIn.apiBAM.apiSpecific.apiTerminateRunning.in.cchImageName = lstrlen(pszImageName) + sizeof('\0');
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
        if (NT_SUCCESS(NtRequestWaitReplyPort(hPort, &portMessageIn.portMessage, &portMessageOut.portMessage)) &&
            NT_SUCCESS(portMessageOut.apiBAM.apiGeneric.status))
        {
            fTerminated = portMessageOut.apiBAM.apiSpecific.apiTerminateRunning.out.fResult;
        }
    }
    return(fTerminated);
}

//  --------------------------------------------------------------------------
//  CGracefulTerminateApplication::EnumWindowsProc
//
//  Arguments:  See the platform SDK under EnumWindowsProc.
//
//  Returns:    See the platform SDK under EnumWindowsProc.
//
//  Purpose:    Top level window enumerator callback which compares the
//              process IDs of the windows and whether they are visible. If
//              there is a match on BOTH counts the a WM_CLOSE message is
//              posted to the window to allow a graceful termination.
//
//  History:    2000-10-27  vtan        created
//  --------------------------------------------------------------------------

BOOL    CALLBACK    CGracefulTerminateApplication::EnumWindowsProc (HWND hwnd, LPARAM lParam)

{
    DWORD                           dwThreadID, dwProcessID;
    CGracefulTerminateApplication   *pThis;

    pThis = reinterpret_cast<CGracefulTerminateApplication*>(lParam);
    dwThreadID = GetWindowThreadProcessId(hwnd, &dwProcessID);
    if ((dwProcessID == pThis->_dwProcessID) && IsWindowVisible(hwnd))
    {
        pThis->_fFoundWindow = true;
        TBOOL(PostMessage(hwnd, WM_CLOSE, 0, 0));
    }
    return(TRUE);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\contextactivation.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ContextActivation.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to implement creating, destroy and scoping a fusion activation
//  context.
//
//  History:    2000-10-09  vtan        created
//              2000-11-04  vtan        copied from winlogon
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "ContextActivation.h"

//  --------------------------------------------------------------------------
//  CContextActivation::s_hActCtx
//
//  Purpose:    The global activation context for this process.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CContextActivation::s_hActCtx   =   INVALID_HANDLE_VALUE;

//  --------------------------------------------------------------------------
//  CContextActivation::CContextActivation
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Activate the global activation context for this process.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

CContextActivation::CContextActivation (void)

{
    (BOOL)ActivateActCtx(s_hActCtx, &ulCookie);
}

//  --------------------------------------------------------------------------
//  CContextActivation::~CContextActivation
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Deactivates the global activation context for this process.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

CContextActivation::~CContextActivation (void)

{
    (BOOL)DeactivateActCtx(0, ulCookie);
}

//  --------------------------------------------------------------------------
//  CContextActivation::Create
//
//  Arguments:  pszPath     =   Path to the manifest.
//
//  Returns:    <none>
//
//  Purpose:    Creates an activation context for this process from a given
//              manifest. If the creation fails use NULL.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

void    CContextActivation::Create (const TCHAR *pszPath)

{
    ACTCTX  actCtx;

    ZeroMemory(&actCtx, sizeof(actCtx));
    actCtx.cbSize = sizeof(actCtx);
    actCtx.lpSource = pszPath;
    s_hActCtx = CreateActCtx(&actCtx);
    if (INVALID_HANDLE_VALUE == s_hActCtx)
    {
        s_hActCtx = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CContextActivation::Destroy
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destroy an activation context created in
//              CContextActivation::Create.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

void    CContextActivation::Destroy (void)

{
    if (s_hActCtx != NULL)
    {
        ReleaseActCtx(s_hActCtx);
        s_hActCtx = INVALID_HANDLE_VALUE;
    }
}

//  --------------------------------------------------------------------------
//  CContextActivation::HasContext
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether a fusion activation context is available.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

bool    CContextActivation::HasContext (void)

{
    return(s_hActCtx != NULL);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\contextactivation.h ===
//  --------------------------------------------------------------------------
//  Module Name: ContextActivation.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to implement creating, destroy and scoping a fusion activation
//  context.
//
//  History:    2000-10-09  vtan        created
//              2000-11-04  vtan        copied from winlogon
//  --------------------------------------------------------------------------

#ifndef     _ContextActivation_
#define     _ContextActivation_

//  --------------------------------------------------------------------------
//  CContextActivation
//
//  Purpose:    A class that handles activation context management. The
//              static functions managing context creation and destruction.
//              The member function manage context activation and
//              deactivation.
//
//  History:    2000-10-09  vtan        created
//  --------------------------------------------------------------------------

class   CContextActivation
{
    public:
                            CContextActivation (void);
                            ~CContextActivation (void);

        static  void        Create (const TCHAR *pszPath);
        static  void        Destroy (void);
        static  bool        HasContext (void);
    private:
        static  HANDLE      s_hActCtx;
                ULONG       ulCookie;
};

#endif  /*  _ContextActivation_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\restoreapplication.h ===
//  --------------------------------------------------------------------------
//  Module Name: RestoreApplication.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to implement holding information required to restore an application
//  and to actually restore it.
//
//  History:    2000-10-26  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifndef     _RestoreApplication_
#define     _RestoreApplication_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CRestoreApplication
//
//  Purpose:    Class to manage information required to restore an application
//              that was terminated because of a different user switch.
//
//  History:    2000-10-26  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

class   CRestoreApplication : public CCountedObject
{
    public:
                                CRestoreApplication (void);
                                ~CRestoreApplication (void);

                NTSTATUS        GetInformation (HANDLE hProcess);

                bool            IsEqualSessionID (DWORD dwSessionID)    const;
                const WCHAR*    GetCommandLine (void)                   const;
                NTSTATUS        Restore (HANDLE *phProcess)             const;
    private:
                NTSTATUS        GetProcessParameters (HANDLE hProcess, RTL_USER_PROCESS_PARAMETERS *pProcessParameters);
                NTSTATUS        GetUnicodeString (HANDLE hProcess, const UNICODE_STRING& string, WCHAR** ppsz);

                NTSTATUS        GetToken (HANDLE hProcess);
                NTSTATUS        GetSessionID (HANDLE hProcess);
                NTSTATUS        GetCommandLine (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetEnvironment (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetCurrentDirectory (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetDesktop (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetTitle (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetFlags (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
                NTSTATUS        GetStdHandles (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters);
    private:
                HANDLE          _hToken;
                DWORD           _dwSessionID;
                WCHAR           *_pszCommandLine;
                void            *_pEnvironment;
                WCHAR           *_pszCurrentDirectory;
                WCHAR           *_pszDesktop;
                WCHAR           *_pszTitle;
                DWORD           _dwFlags;
                WORD            _wShowWindow;
                HANDLE          _hStdInput;
                HANDLE          _hStdOutput;
                HANDLE          _hStdError;

        static  const WCHAR     s_szDefaultDesktop[];
};

#endif  /*  _RestoreApplication_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\warningdialog.h ===
//  --------------------------------------------------------------------------
//  Module Name: WarningDialog.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manage dialog presentation for warnings and errors on termination
//  of bad applications.
//
//  History:    2000-08-31  vtan        created
//              2000-11-04  vtan        moved from fusapi to fussrv
//  --------------------------------------------------------------------------

#ifndef     _WarningDialog_
#define     _WarningDialog_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CWarningDialog
//
//  Purpose:    Implements a class that presents warning and error dialogs in
//              the FUS client DLL.
//
//  History:    2000-08-31  vtan        created
//  --------------------------------------------------------------------------

class   CWarningDialog : public CCountedObject
{
    private:
                                        CWarningDialog (void);
    public:
                                        CWarningDialog (HINSTANCE hInstance, HWND hwndParent, const WCHAR *pszApplication, const WCHAR *pszUser);
                                        ~CWarningDialog (void);

                INT_PTR                 ShowPrompt (bool fCanShutdownApplication);
                void                    ShowFailure (void);
                void                    ShowProgress (DWORD dwTickRefresh, DWORD dwTickMaximum);

                void                    CloseDialog (void);
    private:
                void                    CenterWindow (HWND hwnd);

                void                    Handle_Prompt_WM_INITDIALOG (HWND hwnd);
        static  INT_PTR     CALLBACK    PromptDialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

                void                    Handle_Progress_WM_INITDIALOG (HWND hwnd);
                void                    Handle_Progress_WM_DESTROY (HWND hwnd);
        static  INT_PTR     CALLBACK    ProgressDialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static  void        CALLBACK    ProgressTimerProc (HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
    private:
                HINSTANCE               _hInstance;
                HMODULE                 _hModuleComctlv6;
                HWND                    _hwndParent;
                HWND                    _hwnd;
                bool                    _fCanShutdownApplication;
                UINT                    _uiTimerID;
                DWORD                   _dwTickStart,
                                        _dwTickRefresh,
                                        _dwTickMaximum;
                WCHAR                   _szApplication[MAX_PATH];
                const WCHAR             *_pszUser;
};

#endif  /*  _WarningDialog_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\apdiag\cmmn.h ===
#include <windows.h>

extern BOOL g_fPaused;
extern HWND g_hwndDlg;
extern HANDLE g_hEvent;

DWORD WINAPI Do(PVOID pv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\apdiag\ids.h ===
#define IDC_EDIT1           1000
#define IDC_PAUSERESUME     1001
#define IDC_CLEAR           1002
#define IDC_COPYALL         1003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\warningdialog.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: WarningDialog.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manage dialog presentation for warnings and errors on termination
//  of bad applications.
//
//  History:    2000-08-31  vtan        created
//              2000-11-06  vtan        moved from fusapi to fussrv
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "WarningDialog.h"

#include <commctrl.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include "resource.h"

#include "ContextActivation.h"

static  const int   TEMP_STRING_SIZE    =   512;
static  const int   PROGRESS_TIMER_ID   =   48517;

//  --------------------------------------------------------------------------
//  CWarningDialog::CWarningDialog
//
//  Arguments:  hInstance       =   HINSTANCE of the hosting DLL.
//              hwndParent      =   HWND of the parenting window/dialog.
//              pszApplication  =   Path to the application known to be bad.
//              pszUser         =   User of the application known to be bad.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CWarningDialog. This stores the static
//              parameters and converts the path to a friendly display name
//              using shlwapi!SHGetFileDescriptionW. If the friendly display
//              name cannot be obtained the executable name is used.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

CWarningDialog::CWarningDialog (HINSTANCE hInstance, HWND hwndParent, const WCHAR *pszApplication, const WCHAR *pszUser) :
    _hInstance(hInstance),
    _hModuleComctlv6(NULL),
    _hwndParent(hwndParent),
    _hwnd(NULL),
    _fCanShutdownApplication(false),
    _uiTimerID(0),
    _dwTickStart(0),
    _dwTickRefresh(0),
    _dwTickMaximum(0),
    _pszUser(pszUser)

{
    UINT    uiDisplayNameCount;
    WCHAR   szTemp[MAX_PATH];

    //  Borrow winlogon's manifest. This needs to be changed to a resource
    //  within the server dll.

    static  const TCHAR     s_szLogonManifest[]  =   TEXT("WindowsLogon.manifest");

    TCHAR   szPath[MAX_PATH];

    if (GetSystemDirectory(szPath, ARRAYSIZE(szPath)) != 0)
    {
        if ((lstrlen(szPath) + sizeof('\\') + lstrlen(s_szLogonManifest)) < ARRAYSIZE(szPath))
        {
            lstrcat(szPath, TEXT("\\"));
            lstrcat(szPath, s_szLogonManifest);
            CContextActivation::Create(szPath);
        }
    }

    uiDisplayNameCount = ARRAYSIZE(_szApplication);

    //  If the path is quoted then remove the quotes.

    if (pszApplication[0] == L'\"')
    {
        int     i, iStart;

        iStart = i = sizeof('\"');
        while ((pszApplication[i] != L'\"') && (pszApplication[i] != L'\0'))
        {
            ++i;
        }
        lstrcpyW(szTemp, pszApplication + iStart);
        szTemp[i - iStart] = L'\0';
    }

    //  Otherwise just copy the path as is.

    else
    {
        lstrcpyW(szTemp, pszApplication);
    }
    if (SHGetFileDescriptionW(szTemp, NULL, NULL, _szApplication, &uiDisplayNameCount) == FALSE)
    {
        const WCHAR     *pszFileName;

        pszFileName = PathFindFileNameW(szTemp);
        if (pszFileName == NULL)
        {
            pszFileName = pszApplication;
        }
        (WCHAR*)lstrcpynW(_szApplication, pszFileName, ARRAYSIZE(_szApplication));
    }

    //  Bring in comctl32.dll while the manifest is active. This will
    //  bring in comctlv6.dll which will register its window classes so
    //  the dialogs can be themed.

    if (CContextActivation::HasContext())
    {
        CContextActivation  context;

        _hModuleComctlv6 = LoadLibrary(TEXT("comctl32.dll"));
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::~CWarningDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CWarningDialog. Releases used resources.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

CWarningDialog::~CWarningDialog (void)

{
    if (_hModuleComctlv6 != NULL)
    {
        TBOOL(FreeLibrary(_hModuleComctlv6));
        _hModuleComctlv6 = NULL;
    }
    CContextActivation::Destroy();
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ShowPrompt
//
//  Arguments:  fCanShutdownApplication     =   Decides which dialog to show.
//
//  Returns:    INT_PTR
//
//  Purpose:    Displays the appropriate warning dialog to the user based
//              on their privilege level (fCanShutdownApplication).
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

INT_PTR     CWarningDialog::ShowPrompt (bool fCanShutdownApplication)

{
    CContextActivation  context;

    _fCanShutdownApplication = fCanShutdownApplication;
    return(DialogBoxParam(_hInstance,
                          MAKEINTRESOURCE(fCanShutdownApplication ? IDD_BADAPP_CLOSE : IDD_BADAPP_STOP),
                          _hwndParent,
                          PromptDialogProc,
                          reinterpret_cast<LPARAM>(this)));
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ShowFailure
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Shows the failure to shut down the application dialog on the
//              assumption that the process cannot be terminated.
//
//  History:    2000-09-01  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::ShowFailure (void)

{
    WCHAR   *pszTemp;

    pszTemp = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, TEMP_STRING_SIZE * 3 * sizeof(TCHAR)));
    if (pszTemp != NULL)
    {
        WCHAR   *pszText, *pszCaption;

        pszText = pszTemp + TEMP_STRING_SIZE;
        pszCaption = pszText + TEMP_STRING_SIZE;
        if ((LoadString(_hInstance,
                        IDS_TERMINATEPROCESS_FAILURE,
                        pszTemp,
                        TEMP_STRING_SIZE) != 0) &&
            (LoadString(_hInstance,
                        IDS_WARNING_CAPTION,
                        pszCaption,
                        TEMP_STRING_SIZE) != 0))
        {
            LPCTSTR             pszArray[2];
            CContextActivation  context;

            pszArray[0] = _szApplication;
            pszArray[1] = _pszUser;
            (DWORD)FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 pszTemp,
                                 0,
                                 0,
                                 pszText,
                                 TEMP_STRING_SIZE,
                                 reinterpret_cast<va_list*>(&pszArray));
            (int)MessageBox(_hwndParent, pszText, pszCaption, MB_OK | MB_ICONERROR);
        }
        (HLOCAL)LocalFree(pszTemp);
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ShowProgress
//
//  Arguments:  dwTickRefresh   =   Number of ticks for each refresh.
//              dwTickMaximum   =   Number of ticks for the progress dialog.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the comctl32 progress control and invokes the
//              dialogs for the progress. It's self terminating after the
//              maximum number of ticks have been reached.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::ShowProgress (DWORD dwTickRefresh, DWORD dwTickMaximum)

{
    CContextActivation  context;

    INITCOMMONCONTROLSEX    iccEx;

    //  Init comctl32 to get the progress control.

    iccEx.dwSize = sizeof(iccEx);
    iccEx.dwICC = ICC_PROGRESS_CLASS;
    if (InitCommonControlsEx(&iccEx) != FALSE)
    {
        _dwTickRefresh = dwTickRefresh;
        _dwTickMaximum  = dwTickMaximum;
        (INT_PTR)DialogBoxParam(_hInstance,
                                MAKEINTRESOURCE(IDD_PROGRESS),
                                _hwndParent,
                                ProgressDialogProc,
                                reinterpret_cast<LPARAM>(this));
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::CloseDialog
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Ends the current dialog (with IDCANCEL) if being shown. If
//              there was a timing mechanism on the dialog then make sure it
//              is visible for at least 2 seconds.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::CloseDialog (void)

{
    if (_hwnd != NULL)
    {
        if (_dwTickStart != 0)
        {
            DWORD   dwTickElapsed;

            dwTickElapsed = GetTickCount() - _dwTickStart;
            if (dwTickElapsed < 2000)
            {
                Sleep(2000 - dwTickElapsed);
            }
        }
        TBOOL(EndDialog(_hwnd, IDCANCEL));
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::CenterWindow
//
//  Arguments:  hwnd    =   HWND to center.
//
//  Returns:    <none>
//
//  Purpose:    Centers the given (assumed top level) window on the primary
//              monitor.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::CenterWindow (HWND hwnd)

{
    RECT    rc;

    TBOOL(GetWindowRect(hwnd, &rc));
    rc.left = (GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2;
    rc.top  = (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 3;
    TBOOL(SetWindowPos(hwnd, HWND_TOP, rc.left, rc.top, 0, 0, SWP_NOSIZE));
    TBOOL(SetForegroundWindow(hwnd));
}

//  --------------------------------------------------------------------------
//  CWarningDialog::Handle_Prompt_WM_INITDIALOG
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the strings in the text fields of the dialog. It
//              uses the correct dialog for the access level.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::Handle_Prompt_WM_INITDIALOG (HWND hwnd)

{
    TCHAR   *pszTemp1;

    _hwnd = hwnd;
    pszTemp1 = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, TEMP_STRING_SIZE * 2 * sizeof(TCHAR)));
    if (pszTemp1 != NULL)
    {
        TCHAR       *pszTemp2;
        LPCTSTR     pszArray[5];

        pszTemp2 = pszTemp1 + TEMP_STRING_SIZE;
        if (_fCanShutdownApplication)
        {
            (UINT)GetDlgItemText(hwnd, IDC_BADAPP_CLOSE, pszTemp1, TEMP_STRING_SIZE);
            pszArray[0] = pszArray[2] = pszArray[3] = pszArray[4] = _pszUser;
            pszArray[1] = _szApplication;
            (DWORD)FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 pszTemp1,
                                 0,
                                 0,
                                 pszTemp2,
                                 TEMP_STRING_SIZE,
                                 reinterpret_cast<va_list*>(&pszArray));
            TBOOL(SetDlgItemText(hwnd, IDC_BADAPP_CLOSE, pszTemp2));
        }
        else
        {
            (UINT)GetDlgItemText(hwnd, IDC_BADAPP_STOP, pszTemp1, TEMP_STRING_SIZE);
            pszArray[0] = pszArray[2] = _pszUser;
            pszArray[1] = _szApplication;
            (DWORD)FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 pszTemp1,
                                 0,
                                 0,
                                 pszTemp2,
                                 TEMP_STRING_SIZE,
                                 reinterpret_cast<va_list*>(&pszArray));
            TBOOL(SetDlgItemText(hwnd, IDC_BADAPP_STOP, pszTemp2));
        }
        (HLOCAL)LocalFree(pszTemp1);
    }
    _dwTickStart = 0;
    CenterWindow(hwnd);
}

//  --------------------------------------------------------------------------
//  CWarningDialog::PromptDialogProc
//
//  Arguments:  See the platform SDK under DlgProc.
//
//  Returns:    See the platform SDK under DlgProc.
//
//  Purpose:    Handles messages to the dialog. IDOK and IDCANCEL are treated
//              as IDCANCEL when incoming. IDC_BADAPP_CLOSEPROGRAM is treated
//              as IDOK back to the caller. You must tab to the button or
//              click on it to get the desired effect.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

INT_PTR     CALLBACK    CWarningDialog::PromptDialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    INT_PTR         iResult;
    CWarningDialog  *pThis;

    pThis = reinterpret_cast<CWarningDialog*>(GetWindowLongPtr(hwnd, DWLP_USER));
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CWarningDialog*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis->Handle_Prompt_WM_INITDIALOG(hwnd);
            iResult = TRUE;
            break;
        case WM_DESTROY:
            pThis->_hwnd = NULL;
            iResult = TRUE;
            break;
        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                case IDOK:
                    TBOOL(EndDialog(hwnd, IDCANCEL));
                    break;
                case IDC_BADAPP_CLOSEPROGRAM:
                    TBOOL(EndDialog(hwnd, IDOK));
                    break;
                default:
                    break;
            }
            iResult = TRUE;
            break;
        default:
            iResult = FALSE;
            break;
    }
    return(iResult);
}

//  --------------------------------------------------------------------------
//  CWarningDialog::Handle_Progress_WM_INITDIALOG
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the strings in the text fields of the dialog.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::Handle_Progress_WM_INITDIALOG (HWND hwnd)

{
    HWND    hwndProgress;
    TCHAR   *pszTemp1;

    _hwnd = hwnd;
    pszTemp1 = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, 2048 * sizeof(TCHAR)));
    if (pszTemp1 != NULL)
    {
        TCHAR       *pszTemp2;
        LPCTSTR     pszArray[2];

        pszTemp2 = pszTemp1 + TEMP_STRING_SIZE;
        (UINT)GetDlgItemText(hwnd, IDC_PROGRESS_CLOSE, pszTemp1, TEMP_STRING_SIZE);
        pszArray[0] = _szApplication;
        pszArray[1] = _pszUser;
        (DWORD)FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                             pszTemp1,
                             0,
                             0,
                             pszTemp2,
                             TEMP_STRING_SIZE,
                             reinterpret_cast<va_list*>(&pszArray));
        TBOOL(SetDlgItemText(hwnd, IDC_PROGRESS_CLOSE, pszTemp2));
        (HLOCAL)LocalFree(pszTemp1);
    }
    CenterWindow(hwnd);
    hwndProgress = GetDlgItem(hwnd, IDC_PROGRESS_PROGRESSBAR);
    if (hwndProgress != NULL)
    {
        (LRESULT)SendMessage(hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, _dwTickMaximum));
        _uiTimerID = SetTimer(hwnd, PROGRESS_TIMER_ID, _dwTickRefresh, ProgressTimerProc);
        _dwTickStart = GetTickCount();
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::Handle_Progress_WM_DESTROY
//
//  Arguments:  hwnd    =   HWND of the dialog.
//
//  Returns:    <none>
//
//  Purpose:    Removes the timer from the associated progress dialog if one
//              was created for the dialog.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CWarningDialog::Handle_Progress_WM_DESTROY (HWND hwnd)

{
    if (_uiTimerID != 0)
    {
        TBOOL(KillTimer(hwnd, _uiTimerID));
        _uiTimerID = 0;
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ProgressTimerProc
//
//  Arguments:  See the platform SDK under TimerProc.
//
//  Returns:    See the platform SDK under TimerProc.
//
//  Purpose:    Timer procedure that it called back periodically. This
//              function animates the progress bar by setting it's completion
//              state to the amount of time that has elapsed. The progress
//              bar is based purely on time.
//
//              If the time elapsed exceeds the maximum time then end the
//              dialog.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

void    CALLBACK    CWarningDialog::ProgressTimerProc (HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)

{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(idEvent);

    HWND            hwndProgress;
    CWarningDialog  *pThis;

    pThis = reinterpret_cast<CWarningDialog*>(GetWindowLongPtr(hwnd, DWLP_USER));
    hwndProgress = GetDlgItem(hwnd, IDC_PROGRESS_PROGRESSBAR);
    if (hwndProgress != NULL)
    {
        (LRESULT)SendMessage(hwndProgress, PBM_SETPOS, dwTime - pThis->_dwTickStart, 0);
        if ((dwTime - pThis->_dwTickStart) > pThis->_dwTickMaximum)
        {
            TBOOL(EndDialog(hwnd, IDCANCEL));
        }
    }
}

//  --------------------------------------------------------------------------
//  CWarningDialog::ProgressDialogProc
//
//  Arguments:  See the platform SDK under DlgProc.
//
//  Returns:    See the platform SDK under DlgProc.
//
//  Purpose:    Handles messages for the progress dialog.
//
//  History:    2000-11-04  vtan    created
//  --------------------------------------------------------------------------

INT_PTR     CALLBACK    CWarningDialog::ProgressDialogProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    UNREFERENCED_PARAMETER(wParam);

    INT_PTR         iResult;
    CWarningDialog  *pThis;

    pThis = reinterpret_cast<CWarningDialog*>(GetWindowLongPtr(hwnd, DWLP_USER));
    switch (uMsg)
    {
        case WM_INITDIALOG:
            pThis = reinterpret_cast<CWarningDialog*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            pThis->Handle_Progress_WM_INITDIALOG(hwnd);
            iResult = TRUE;
            break;
        case WM_DESTROY:
            pThis->Handle_Progress_WM_DESTROY(hwnd);
            pThis->_hwnd = NULL;
            iResult = TRUE;
            break;
        default:
            iResult = FALSE;
            break;
    }
    return(iResult);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shsrvice.inc ===
CCSHELL_DIR= $(PROJECT_ROOT)

MSC_WARNING_LEVEL=/W4

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED= $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

SHSRVICE=$(PROJECT_ROOT)\services\hdsrv
SHSRVICE_INC_PATH=$(SHSRVICE)\inc;$(SHSRVICE)\idl\$(O)

INCLUDES=                           \
         $(INCLUDES);               \
         $(TERMSRV_INC_PATH);       \
         $(DS_INC_PATH);            \
         $(PROJECT_ROOT)\services;  \
         $(SHSRVICE_INC_PATH)

# what the heck is this for?!?
!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DRBDEBUG
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\bamsrv\restoreapplication.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: RestoreApplication.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to implement holding information required to restore an application
//  and to actually restore it.
//
//  History:    2000-10-26  vtan        created
//              2000-11-04  vtan        split into separate file
//  --------------------------------------------------------------------------

#ifdef      _X86_

#include "StandardHeader.h"
#include "RestoreApplication.h"

#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CRestoreApplication::CRestoreApplication
//
//  Purpose:    Static const string to the user desktop..
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

const WCHAR     CRestoreApplication::s_szDefaultDesktop[]   =   L"WinSta0\\Default";

//  --------------------------------------------------------------------------
//  CRestoreApplication::CRestoreApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CRestoreApplication.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

CRestoreApplication::CRestoreApplication (void) :
    _hToken(NULL),
    _dwSessionID(static_cast<DWORD>(-1)),
    _pszCommandLine(NULL),
    _pEnvironment(NULL),
    _pszCurrentDirectory(NULL),
    _pszDesktop(NULL),
    _pszTitle(NULL),
    _dwFlags(0),
    _wShowWindow(0),
    _hStdInput(NULL),
    _hStdOutput(NULL),
    _hStdError(NULL)

{
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::~CRestoreApplication
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CRestoreApplication. Release any resources.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

CRestoreApplication::~CRestoreApplication (void)

{
    ReleaseMemory(_pszTitle);
    ReleaseMemory(_pszDesktop);
    ReleaseMemory(_pszCurrentDirectory);
    ReleaseMemory(_pEnvironment);
    ReleaseMemory(_pszCommandLine);
    ReleaseHandle(_hToken);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetInformation
//
//  Arguments:  hProcessIn  =   Handle to the process to get information.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Gets information about the currently running process to
//              allow it to be re-run in the case when the user re-connects.
//              This effectively restores the process but it's not identical
//              to how it was originally run.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetInformation (HANDLE hProcessIn)

{
    NTSTATUS    status;
    HANDLE      hProcess;

    if (DuplicateHandle(GetCurrentProcess(),
                        hProcessIn,
                        GetCurrentProcess(),
                        &hProcess,
                        PROCESS_VM_READ | PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION,
                        FALSE,
                        0) != FALSE)
    {
        status = GetToken(hProcess);
        if (NT_SUCCESS(status))
        {
            status = GetSessionID(hProcess);
            if (NT_SUCCESS(status))
            {
                RTL_USER_PROCESS_PARAMETERS     processParameters;

                status = GetProcessParameters(hProcess, &processParameters);
                if (NT_SUCCESS(status))
                {
                    status = GetCommandLine(hProcess, processParameters);
                    if (NT_SUCCESS(status))
                    {
                        TSTATUS(GetEnvironment(hProcess, processParameters));
                        TSTATUS(GetCurrentDirectory(hProcess, processParameters));
                        TSTATUS(GetDesktop(hProcess, processParameters));
                        TSTATUS(GetTitle(hProcess, processParameters));
                        TSTATUS(GetFlags(hProcess, processParameters));
                        TSTATUS(GetStdHandles(hProcess, processParameters));
                    }
                }
            }
        }
        TBOOL(CloseHandle(hProcess));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::IsEqualSessionID
//
//  Arguments:  dwSessionID     =   Session ID to check.
//
//  Returns:    bool
//
//  Purpose:    Returns whether the given session ID is the same as the
//              process that needs restoration. This assists in determining
//              whether restoration is required.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

bool    CRestoreApplication::IsEqualSessionID (DWORD dwSessionID)    const

{
    return(_dwSessionID == dwSessionID);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetCommandLine
//
//  Arguments:  <none>
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns the pointer to the internal storage for the command
//              line of the process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

const WCHAR*    CRestoreApplication::GetCommandLine (void)                  const

{
    return(_pszCommandLine);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::Restore
//
//  Arguments:  phProcess   =   Receives the handle to the restored process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Restores the process whose information was gathered with
//              GetInformation to as close as possibly to the original start
//              state. Relevant information was saved off to allow an
//              effective restore.
//
//              The handle returned is optional. If requested a non-NULL
//              phProcess must be passed in and it is the caller's
//              responsibility to close that handle. If not required then
//              NULL is passed in and the handle is closed.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::Restore (HANDLE *phProcess)             const

{
    NTSTATUS                status;
    STARTUPINFO             startupInfo;
    PROCESS_INFORMATION     processInformation;

    ZeroMemory(&startupInfo, sizeof(startupInfo));
    ZeroMemory(&processInformation, sizeof(processInformation));
    startupInfo.cb = sizeof(startupInfo);
    startupInfo.lpDesktop = _pszDesktop;
    startupInfo.lpTitle = _pszTitle;
    startupInfo.dwFlags = _dwFlags;
    startupInfo.wShowWindow = _wShowWindow;
    if (ImpersonateLoggedOnUser(_hToken) != FALSE)
    {
        if (CreateProcessAsUser(_hToken,
                                NULL,
                                _pszCommandLine,
                                NULL,
                                NULL,
                                FALSE,
                                0,
                                NULL,
                                _pszCurrentDirectory,
                                &startupInfo,
                                &processInformation) != FALSE)
        {
            if (phProcess != NULL)
            {
                *phProcess = processInformation.hProcess;
            }
            else
            {
                TBOOL(CloseHandle(processInformation.hProcess));
            }
            TBOOL(CloseHandle(processInformation.hThread));
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(RevertToSelf());
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetProcessParameters
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reads the RTL_USER_PROCESS_PARAMETERS information from the
//              given process. Addresses in this struct belong to the given
//              process address space.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetProcessParameters (HANDLE hProcess, RTL_USER_PROCESS_PARAMETERS* pProcessParameters)

{
    NTSTATUS                    status;
    ULONG                       ulReturnLength;
    PROCESS_BASIC_INFORMATION   processBasicInformation;

    status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &processBasicInformation,
                                       sizeof(processBasicInformation),
                                       &ulReturnLength);
    if (NT_SUCCESS(status))
    {
        SIZE_T  dwNumberOfBytesRead;
        PEB     peb;

        if ((ReadProcessMemory(hProcess,
                               processBasicInformation.PebBaseAddress,
                               &peb,
                               sizeof(peb),
                               &dwNumberOfBytesRead) != FALSE) &&
            (ReadProcessMemory(hProcess,
                               peb.ProcessParameters,
                               pProcessParameters,
                               sizeof(*pProcessParameters),
                               &dwNumberOfBytesRead) != FALSE))
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetUnicodeString
//
//  Arguments:  hProcess    =   Handle to the process.
//              string      =   UNICODE_STRING to read from process.
//              psz         =   Received newly allocated memory for string.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reads the given UNICODE_STRING from the process and allocates
//              memory to hold this string and copies it. The string is
//              NULL terminated.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetUnicodeString (HANDLE hProcess, const UNICODE_STRING& string, WCHAR** ppsz)

{
    NTSTATUS    status;
    WCHAR       *psz;

    psz = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, string.Length + (sizeof('\0') * sizeof(WCHAR))));
    if (psz != NULL)
    {
        SIZE_T  dwNumberOfBytesRead;

        if (ReadProcessMemory(hProcess,
                              string.Buffer,
                              psz,
                              string.Length,
                              &dwNumberOfBytesRead) != FALSE)
        {
            psz[string.Length / sizeof(WCHAR)] = L'\0';
            status = STATUS_SUCCESS;
        }
        else
        {
            ReleaseMemory(psz);
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    *ppsz = psz;
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetToken
//
//  Arguments:  hProcess    =   Handle to process to get token of.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores internally the token of the give process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetToken (HANDLE hProcess)

{
    NTSTATUS    status;

    if ((OpenProcessToken(hProcess,
                          TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_QUERY,
                          &_hToken) != FALSE))
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetSessionID
//
//  Arguments:  hProcess    =   Handle to the process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the session ID associated with the process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetSessionID (HANDLE hProcess)

{
    NTSTATUS                        status;
    ULONG                           ulReturnLength;
    PROCESS_SESSION_INFORMATION     processSessionInformation;

    status = NtQueryInformationProcess(hProcess,
                                       ProcessSessionInformation,
                                       &processSessionInformation,
                                       sizeof(processSessionInformation),
                                       &ulReturnLength);
    if (NT_SUCCESS(status))
    {
        _dwSessionID = processSessionInformation.SessionId;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetCommandLine
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the command line (that started the process) from the
//              given process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetCommandLine (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    return(GetUnicodeString(hProcess, processParameters.CommandLine, &_pszCommandLine));
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetEnvironment
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the environment block for the given process. Currently
//              this is NOT implemented.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetEnvironment (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    UNREFERENCED_PARAMETER(hProcess);
    UNREFERENCED_PARAMETER(processParameters);

    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetCurrentDirectory
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the current directory of the given process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetCurrentDirectory (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    return(GetUnicodeString(hProcess, processParameters.CurrentDirectory.DosPath, &_pszCurrentDirectory));
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetDesktop
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the window station and desktop that the given process
//              was started on.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetDesktop (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    NTSTATUS    status;

    status = GetUnicodeString(hProcess, processParameters.DesktopInfo, &_pszDesktop);
    if (!NT_SUCCESS(status))
    {
        _pszDesktop = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, sizeof(s_szDefaultDesktop)));
        if (_pszDesktop != NULL)
        {
            CopyMemory(_pszDesktop, s_szDefaultDesktop, sizeof(s_szDefaultDesktop));
            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetTitle
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the window title used to start the given process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetTitle (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    return(GetUnicodeString(hProcess, processParameters.WindowTitle, &_pszTitle));
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetFlags
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the flags and wShowWindow used to start the given
//              process.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetFlags (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    UNREFERENCED_PARAMETER(hProcess);

    _dwFlags = processParameters.WindowFlags;
    _wShowWindow = static_cast<WORD>(processParameters.ShowWindowFlags);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CRestoreApplication::GetStdHandles
//
//  Arguments:  hProcess            =   Handle to the process.
//              processParameters   =   Process parameters returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Stores the standard handles that may have been used to start
//              the given process. Currently NOT implemented.
//
//  History:    2000-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CRestoreApplication::GetStdHandles (HANDLE hProcess, const RTL_USER_PROCESS_PARAMETERS& processParameters)

{
    UNREFERENCED_PARAMETER(hProcess);
    UNREFERENCED_PARAMETER(processParameters);

    return(STATUS_SUCCESS);
}

#endif  /*  _X86_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\dll\shellservicesexports.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ShellServicesExports.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that exported from shsvcs.dll.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include "ServerAPI.h"
#include "BAMService.h"
#include "HDService.h"
#include "ThemeService.h"

HINSTANCE   g_hInstance     =   NULL;

//  --------------------------------------------------------------------------
//  ::DllMain
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Performs initialization and clean up on process attach and
//              detach. Not interested in anything else.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  DllMain (HINSTANCE hInstance, DWORD fdwReason, LPVOID lpvReserved)

{
    UNREFERENCED_PARAMETER(lpvReserved);

    NTSTATUS    status;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
            status = CServerAPI::StaticInitialize();
            if (NT_SUCCESS(status))
            {
                status = CThemeService::Main(fdwReason);
                if (NT_SUCCESS(status))
                {
                    status = CBAMService::Main(fdwReason);
                    if (NT_SUCCESS(status))
                    {
                        CHDService::Main(fdwReason);
                    }
                }
            }
            break;
        case DLL_PROCESS_DETACH:
            CHDService::Main(fdwReason);
            TSTATUS(CBAMService::Main(fdwReason));
            TSTATUS(CThemeService::Main(fdwReason));
            TSTATUS(CServerAPI::StaticTerminate());
            status = STATUS_SUCCESS;
            break;
        default:
            status = STATUS_SUCCESS;
            break;
    }
    return(NT_SUCCESS(status));
}

//  --------------------------------------------------------------------------
//  ::DllInstall
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllInstall (BOOL fInstall, LPCWSTR pszCmdLine)

{
    return(CHDService::Install(fInstall, pszCmdLine));
}

//  --------------------------------------------------------------------------
//  ::DllRegisterServer
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Register entry point to allow any service to install itself
//              into the registry.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllRegisterServer (void)

{
    HRESULT     hr;
    NTSTATUS    status1, status2;

    status1 = CThemeService::RegisterServer();
    status2 = CBAMService::RegisterServer();
    hr = CHDService::RegisterServer();
    if (!NT_SUCCESS(status1))
    {
        hr = HRESULT_FROM_NT(status1);
    }
    else if (!NT_SUCCESS(status2))
    {
        hr = HRESULT_FROM_NT(status2);
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  ::DllUnregisterServer
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Unregister entry point to allow any service to uninstall
//              itself from the registry.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllUnregisterServer (void)

{
    HRESULT     hr;
    NTSTATUS    status1, status2;

    hr = CHDService::UnregisterServer();
    status2 = CBAMService::UnregisterServer();
    status1 = CThemeService::UnregisterServer();
    if (!NT_SUCCESS(status1))
    {
        hr = HRESULT_FROM_NT(status1);
    }
    else if (!NT_SUCCESS(status2))
    {
        hr = HRESULT_FROM_NT(status2);
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  ::DllCanUnloadNow
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Returns whether the DLL can unload because there are no
//              outstanding COM object references.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllCanUnloadNow (void)

{
    return(CHDService::CanUnloadNow());
}

//  --------------------------------------------------------------------------
//  ::DllGetClassObject
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Returns a constructed COM object of the specified class.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

HRESULT     WINAPI  DllGetClassObject (REFCLSID rclsid, REFIID riid, void** ppv)

{
    return(CHDService::GetClassObject(rclsid, riid, ppv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\apdiag\main.cpp ===
#include "ids.h"
#include "cmmn.h"

#include <windows.h>

BOOL g_fPaused = FALSE;
HWND g_hwndDlg = NULL;
HANDLE g_hEvent = NULL;

LRESULT CALLBACK MainDlgProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR szCmdLine, int iCmdShow)
{
    MSG msg;
    WNDCLASSEX wndclass;
    static WCHAR szAppName[] = TEXT("APDIAG");

    hPrevInstance;
    szCmdLine;

    wndclass.cbSize        = sizeof (wndclass);
    wndclass.style         = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc   = MainDlgProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = DLGWINDOWEXTRA;
    wndclass.hInstance     = hInstance;
    wndclass.hIcon         = LoadIcon(hInstance, szAppName);
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wndclass.lpszMenuName  = NULL;
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm       = LoadIcon(hInstance, szAppName);

    RegisterClassEx(&wndclass);

    g_hwndDlg = CreateDialog(hInstance, szAppName, 0, NULL);

    ShowWindow(g_hwndDlg, iCmdShow);

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}

// Copied from shell32
BOOL _TestTokenMembership(HANDLE hToken, ULONG ulRID)
{
    static  SID_IDENTIFIER_AUTHORITY    sSystemSidAuthority     =   SECURITY_NT_AUTHORITY;

    PSID pSIDLocalGroup;
    BOOL fResult = FALSE;
    if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 ulRID,
                                 0, 0, 0, 0, 0, 0,
                                 &pSIDLocalGroup) != FALSE)
    {
        if (CheckTokenMembership(hToken, pSIDLocalGroup, &fResult) == FALSE)
        {
            fResult = FALSE;
        }

        FreeSid(pSIDLocalGroup);
    }
    return fResult;
}

LRESULT CALLBACK MainDlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    BOOL fDoDefault = TRUE;

    static BOOL fInited = FALSE;

    switch (iMsg)
    {
        case WM_CREATE:
            g_fPaused = FALSE;
            break;

        case WM_ACTIVATE:
            if (!fInited)
            {
                // Run this only for Admins
                if (_TestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS))
                {
                    CreateThread(NULL, 0, Do, 0, 0, NULL);

                    fInited = TRUE;
                }
                else
                {
                    MessageBox(hwnd,
                        TEXT("You need to be an Administrator to run this application."),
                        TEXT("Autoplay Diagnostic Tools"), MB_OK | MB_ICONEXCLAMATION);
                }
            }
            break;            

        case WM_COMMAND:
            if (BN_CLICKED == HIWORD(wParam))
            {
                switch (LOWORD(wParam))
                {
                    case IDC_PAUSERESUME:
                        if (g_fPaused)
                        {
                            // Resuming
                            SendMessage(GetDlgItem(hwnd, IDC_PAUSERESUME), WM_SETTEXT, 0,
                                (LPARAM)TEXT("&Pause"));
                        }
                        else
                        {
                            // Pausing
                            SendMessage(GetDlgItem(hwnd, IDC_PAUSERESUME), WM_SETTEXT, 0,
                                (LPARAM)TEXT("&Resume"));
                        }

                        g_fPaused = !g_fPaused;
                        break;

                    case IDC_CLEAR:
                        SendMessage(GetDlgItem(hwnd, IDC_EDIT1), WM_SETTEXT, 0,
                            (LPARAM)TEXT(""));
                        break;

                    case IDC_COPYALL:
                    {
                        if (OpenClipboard(hwnd))
                        {
                            BOOL fGoOn = FALSE;
                            BOOL fFreeMem = TRUE;
                            LRESULT cch = SendMessage(GetDlgItem(hwnd, IDC_EDIT1),
                                WM_GETTEXTLENGTH, 0, 0);

                            HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE |
                                GMEM_DDESHARE, (cch + 1) * sizeof(WCHAR));

                            if (hMem)
                            {
                                PVOID pv = GlobalLock(hMem);

                                if (pv)
                                {
                                    if (SendMessage(GetDlgItem(hwnd, IDC_EDIT1),
                                        WM_GETTEXT, (WPARAM)(cch + 1), (LPARAM)pv))
                                    {
                                        fGoOn = TRUE;
                                    }

                                    GlobalUnlock(hMem);
                                }
                            }

                            if (fGoOn)
                            {
                                HANDLE h = SetClipboardData(CF_UNICODETEXT, hMem);

                                if (h)
                                {
                                    fFreeMem = FALSE;
                                }
                            }

                            if (fFreeMem)
                            {
                                GlobalFree(hMem);
                            }

                            CloseClipboard();
                        }
                        break;
                    }
                }
            }
            break;

        case WM_DESTROY:
            if (g_hEvent)
            {
                CloseHandle(g_hEvent);
            }

            PostQuitMessage(0);
            fDoDefault = FALSE;
            break;
    }

    if (fDoDefault)
    {
        lres = DefWindowProc(hwnd, iMsg, wParam, lParam);
    }

    return lres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\apsample\resource.h ===
//
#define IDD_DIALOG1                     101

#define IDC_EDIT1                       1000

#define IDC_QCA_CHECKBOX                2000
#define IDC_QCA_EDIT                    2001
#define IDC_QCA_AUTORUNINF_CHECKBOX     2002
#define IDC_QCA_AUDIOCD_CHECKBOX        2004
#define IDC_QCA_DVDMOVIE_CHECKBOX       2008
#define IDC_QCA_BLANKCD_CHECKBOX        2016
#define IDC_QCA_BLANKDVD_CHECKBOX       2032

#define IDC_IQCA_CHECKBOX               3000
#define IDC_IQCA_EDIT                   3001
#define IDC_IQCA_AUTORUNINF_CHECKBOX    3002
#define IDC_IQCA_AUDIOCD_CHECKBOX       3004
#define IDC_IQCA_DVDMOVIE_CHECKBOX      3008
#define IDC_IQCA_BLANKCD_CHECKBOX       3016
#define IDC_IQCA_BLANKDVD_CHECKBOX      3032

#define IDC_AUTOPLAY_CHECKBOX           4000
#define IDC_AUTOPLAY_EVENTHANDLER_EDIT  4001
#define IDC_AUTOPLAY_CLSID_EDIT         4002
#define IDC_AUTOPLAY_ONOFF_CHECKBOX     4003

#define IDC_DUMMY                       -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\dbg.h ===
///////////////////////////////////////////////////////////////////////////////
// MISC
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG

#include <windows.h> // required to avoid error while building platform.h
#include <platform.h> // for __endexcept
#pragma warning(disable: 4127)

#endif

///////////////////////////////////////////////////////////////////////////////
// ASSERT
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
    // to use within classes that define this member fct
    #define ASSERTVALIDSTATE() _DbgAssertValidState()

    #ifdef RBDEBUG
        #ifndef _RBDEBUG_H
            #include "rbdebug.h"
        #endif

        #ifdef _X86_
            #define ASSERT(a) do { CRBDebug::Init(); if ((a)) {;} else { \
                if (RBD_ASSERT_BEEP & CRBDebug::_dwFlags) { Beep(1000, 500); } \
                else {;} \
                if (RBD_ASSERT_TRACE & CRBDebug::_dwFlags) \
                { TRACE(TF_ASSERT, TEXT("ASSERT: " TEXT(#a))); } else {;} \
                if (RBD_ASSERT_STOP &  CRBDebug::_dwFlags) { _try { _asm int 3 } \
                _except (EXCEPTION_EXECUTE_HANDLER) {;} } else {;} \
            }} while (0)
        #else
            #define ASSERT(a) do { CRBDebug::Init(); if ((a)) {;} else { \
                if (RBD_ASSERT_BEEP & CRBDebug::_dwFlags) { Beep(1000, 500); } \
                else {;} \
                if (RBD_ASSERT_TRACE & CRBDebug::_dwFlags) \
                { TRACE(TF_ASSERT, TEXT("ASSERT: " TEXT(#a))); } else {;} \
                if (RBD_ASSERT_STOP &  CRBDebug::_dwFlags) { _try { DebugBreak(); } \
                _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } else {;} \
            }} while (0)
        #endif
    #else
        #ifdef _X86_
            #define ASSERT(a) do { if ((a)) {;} else { Beep(1000, 500); \
                _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } } \
                while (0)
        #else
            #define ASSERT(a) do { if ((a)) {;} else { Beep(1000, 500); \
                _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} \
                __endexcept } } while (0)
        #endif
    #endif

#else
    #define ASSERT(a)
    #define ASSERTVALIDSTATE()
#endif

///////////////////////////////////////////////////////////////////////////////
// TRACE
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG

    #ifdef RBDEBUG
        #ifndef _RBDEBUG_H
            #include "rbdebug.h"
        #endif

        #define TRACE CRBDebug::SetTraceFileAndLine(__FILE__, __LINE__); \
            CRBDebug::TraceMsg
    #else
        #define TRACE DbgTrace
    #endif

#else
    #define TRACE   1 ? (void)0 : (void)
#endif

///////////////////////////////////////////////////////////////////////////////
// Others
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
    #define INCDEBUGCOUNTER(a) ++(a)
    #define DECDEBUGCOUNTER(a) --(a)

    #define DEBUG_ONLY(a) a

    void __cdecl DbgTrace(DWORD dwFlags, LPTSTR pszMsg, ...);
#else
    #define INCDEBUGCOUNTER(a)
    #define DECDEBUGCOUNTER(a)
    #define DEBUG_ONLY(a)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\fact.h ===
#ifndef _FACT_H_
#define _FACT_H_

#include <objbase.h>
#include "factdata.h"

class CCOMBase;
class CCOMBaseFactory;

class CCOMBaseFactory : public IClassFactory
{
///////////////////////////////////////////////////////////////////////////////
// COM Interfaces
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    
    // IClassFactory
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, REFIID riid,
        void** ppv);
    virtual STDMETHODIMP LockServer(BOOL fLock);

///////////////////////////////////////////////////////////////////////////////
// 
public:
    CCOMBaseFactory(const CFactoryData* pFactoryData);
    ~CCOMBaseFactory() {}

public: // only for use in dll.cpp, or internally
    static HRESULT _RegisterAll();
    static HRESULT _UnregisterAll();
    static HRESULT _CanUnloadNow();
    static HRESULT _CheckForUnload();

///////////////////////////////////////////////////////////////////////////////
// Helpers
private:
    static BOOL _IsLocked();
    static HRESULT _LockServer(BOOL fLock);

    static void _COMFactoryCB(BOOL fIncrement);

public: // only for use in dll.cpp
    static HRESULT _GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);
    static BOOL                 _fCritSectInit;

public: // only for use in COM exe server
    static BOOL _ProcessConsoleCmdLineParams(int argc, wchar_t* argv[],
        BOOL* pfRun, BOOL* pfEmbedded);
//    static BOOL _ProcessWindowsCmdLineParams(LPWSTR pszCmdLine);
    static void _WaitForAllClientsToGo();
    static BOOL _RegisterFactories(BOOL fEmbedded);
    static BOOL _UnregisterFactories(BOOL fEmbedded);
    static BOOL _SuspendFactories();
    static BOOL _ResumeFactories();

public:
    const CFactoryData*         _pFactoryData;
    static const CFactoryData*  _pDLLFactoryData;
    static const DWORD          _cDLLFactoryData;
    static struct OUTPROCINFO*  _popinfo;
    static HMODULE              _hModule;
    static CRITICAL_SECTION     _cs;

private:
    ULONG                       _cRef;

    static LONG                 _cComponents;   
    static LONG                 _cServerLocks;

	static DWORD                _dwThreadID;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\apsample\main.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "resource.h"

#include "shpriv.h"

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

HINSTANCE g_hinst = 0;

// {4456E541-7CAB-45ee-AB09-3FF379FA9AA4}
static const CLSID CLSID_App = { 0x4456e541, 0x7cab, 0x45ee, { 0xab, 0x9, 0x3f, 0xf3, 0x79, 0xfa, 0x9a, 0xa4}};

#define INVALID_DWORD ((DWORD)-1)

class CAppDialog : public IClassFactory, public IHWEventHandler, public IQueryCancelAutoPlay
{
public:
	CAppDialog();
	HRESULT DoModal(HWND hwnd);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IClassFactory
	STDMETHODIMP CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
	STDMETHODIMP LockServer(BOOL fLock);

    // IHWEventHandler
    STDMETHODIMP Initialize(LPCWSTR pszParams);
    STDMETHODIMP HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID,
        LPCWSTR pszEventType);
    STDMETHODIMP HandleEventWithContent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID,
        LPCWSTR pszEventType, LPCWSTR pszContentTypeHandler, IDataObject* pdataobject);

    // IQueryCancelAutoPlay
    STDMETHODIMP AllowAutoPlay(LPCWSTR pszPath, DWORD dwContentType, LPCWSTR pszLabel, DWORD dwSerialNumber);

private:
	~CAppDialog();

	static INT_PTR CALLBACK s_DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT_PTR CALLBACK DlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
	void _OnInitDlg();
	void _OnDestroyDlg();
    LRESULT _OnQueryCancelAutoplay(WPARAM wParam, LPARAM lParam);

    void _OnQueryCancelAutoplayWindowsMessageChanged();
    void _OnQueryCancelAutoplayIntfChanged();
    void _OnAutoplayChanged();

    void _PrintMsg(LPCWSTR pszMsg);

	LONG _cRef;
	DWORD _dwRegisterClass;
	DWORD _dwRegisterROT;
    DWORD _dwRegisterROT2;

	HWND _hdlg;
};

CAppDialog::CAppDialog() : _cRef(1), _dwRegisterClass(INVALID_DWORD), _dwRegisterROT(INVALID_DWORD), _dwRegisterROT2(INVALID_DWORD), _hdlg(NULL)//, _hdlgLV(NULL)
{
	InitCommonControls();
}

CAppDialog::~CAppDialog()
{
}

HRESULT CAppDialog::QueryInterface(REFIID riid, void **ppv)
{
	HRESULT hr;
	if (riid == IID_IUnknown)
	{
		*ppv = static_cast<IClassFactory *>(this);
		AddRef();
		hr = S_OK;
	}
	else if (riid == IID_IClassFactory)
	{
		*ppv = static_cast<IClassFactory *>(this);
		AddRef();
		hr = S_OK;
	}
	else if (riid == IID_IHWEventHandler)
	{
		*ppv = static_cast<IHWEventHandler *>(this);
		AddRef();
		hr = S_OK;
	}
	else if (riid == IID_IQueryCancelAutoPlay)
	{
		*ppv = static_cast<IQueryCancelAutoPlay *>(this);
		AddRef();
		hr = S_OK;
	}
	else
	{
		*ppv = NULL;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP_(ULONG) CAppDialog::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAppDialog::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CAppDialog::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    if (punkOuter)
    {
	    *ppv = NULL;
        return CLASS_E_NOAGGREGATION;
    }
	return QueryInterface(riid, ppv);
}

STDMETHODIMP CAppDialog::LockServer(BOOL /*fLock*/)
{
    return S_OK;
}

STDMETHODIMP CAppDialog::Initialize(LPCWSTR /*pszParams*/)
{
    return S_OK;
}

STDMETHODIMP CAppDialog::HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID,
    LPCWSTR pszEventType)
{
    WCHAR szText[4096];

    wsprintf(szText, TEXT("%s, %s, %s"), pszDeviceID, pszAltDeviceID, pszEventType);

    _PrintMsg(szText);

    return S_OK;
}

STDMETHODIMP CAppDialog::HandleEventWithContent(LPCWSTR /*pszDeviceID*/, LPCWSTR /*pszAltDeviceID*/,
    LPCWSTR /*pszEventType*/, LPCWSTR /*pszContentTypeHandler*/, IDataObject* /*pdataobject*/)
{
    return S_OK;
}

void CAppDialog::_PrintMsg(LPCWSTR pszMsg)
{
    SendMessage(GetDlgItem(_hdlg, IDC_EDIT1), EM_SETSEL, (WPARAM)-2, (WPARAM)-2);
    SendMessage(GetDlgItem(_hdlg, IDC_EDIT1), EM_REPLACESEL, 0, (LPARAM)pszMsg);
    SendMessage(GetDlgItem(_hdlg, IDC_EDIT1), EM_SETSEL, (WPARAM)-2, (WPARAM)-2);
    SendMessage(GetDlgItem(_hdlg, IDC_EDIT1), EM_REPLACESEL, 0, (LPARAM)TEXT("\r\n"));
}

DWORD _BuildFilterFlag(HWND hwndDlg, int iResourceBase)
{
    DWORD dwRet = 0;

    for (int i = 0; i < 5; ++i)
    {
        if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwndDlg, iResourceBase + (1 << (i + 1)))))
        {
            dwRet |= (1 << (i + 1));
        }
    }

    return dwRet;
}

STDMETHODIMP CAppDialog::AllowAutoPlay(LPCWSTR pszPath, DWORD dwContentType,
    LPCWSTR /*pszLabel*/, DWORD /*dwSerialNumber*/)
{
    HRESULT hr = S_OK;
    WCHAR szText[4096];

    wsprintf(szText, TEXT("IQueryCancelAutoPlay::AllowAutoPlay called for drive '%s' and ContentType (0x%08X)"),
        pszPath, dwContentType);

    _PrintMsg(szText);

    // Are we registered?
    if (INVALID_DWORD != _dwRegisterROT2)
    {
        // Yes
        WCHAR szDrive[MAX_PATH];

        if (GetDlgItemText(_hdlg, IDC_IQCA_EDIT, szDrive, ARRAYSIZE(szDrive)))
        {
            // Same drive?
            if (!lstrcmpi(szDrive, pszPath))
            {
                // Yes
                DWORD dwFilter = _BuildFilterFlag(_hdlg, 3000);

                if (dwFilter & dwContentType)
                {
                    wsprintf(szText, TEXT("    Filter (0x%08X) matches ContentType -> Cancel AutoRun! (S_FALSE)"),
                        dwFilter);
                    hr = S_FALSE;         
                }
                else
                {
                    wsprintf(szText, TEXT("    Filter (0x%08X) does *NOT* match ContentType -> No cancel (S_OK)"));
                }

                _PrintMsg(szText);
            }
        }
    }

    return hr;
}

HRESULT CAppDialog::DoModal(HWND hwnd)
{
    DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_DIALOG1), hwnd, s_DlgProc, (LPARAM)this);
    return S_OK;
}

typedef HRESULT (*CREATEHARDWAREEVENTMONIKER)(REFCLSID clsid, LPCTSTR pszEventHandler, IMoniker **ppmoniker);

void CAppDialog::_OnInitDlg()
{
    SetDlgItemText(_hdlg, IDC_AUTOPLAY_CLSID_EDIT, TEXT("{4456E541-7CAB-45ee-AB09-3FF379FA9AA4}"));
}

void CAppDialog::_OnDestroyDlg()
{
	if (INVALID_DWORD != _dwRegisterClass)
	{
		CoRevokeClassObject(_dwRegisterClass);
		_dwRegisterClass = INVALID_DWORD;
	}

	if (INVALID_DWORD != _dwRegisterROT)
	{
		IRunningObjectTable *prot;
		if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
		{
			prot->Revoke(_dwRegisterROT);
			_dwRegisterROT = INVALID_DWORD;
			prot->Release();
		}
	}

	if (INVALID_DWORD != _dwRegisterROT2)
	{
		IRunningObjectTable *prot;
		if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
		{
			prot->Revoke(_dwRegisterROT2);
			_dwRegisterROT2 = INVALID_DWORD;
			prot->Release();
		}
	}
}

INT_PTR CALLBACK CAppDialog::s_DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAppDialog *pcd = (CAppDialog*) GetWindowLongPtr(hdlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pcd = (CAppDialog *) lParam;
        pcd->_hdlg = hdlg;
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR) pcd);
    }

    return pcd ? pcd->DlgProc(uMsg, wParam, lParam) : FALSE;
}

LRESULT CAppDialog::_OnQueryCancelAutoplay(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;

    WCHAR szText[4096];

    wsprintf(szText, TEXT("QueryCancelAutoPlay Windows Message Received for drive '0x%08X' and ContentType (0x%08X)"),
        wParam, lParam);

    _PrintMsg(szText);

    if (BST_CHECKED == Button_GetCheck(GetDlgItem(_hdlg, IDC_QCA_CHECKBOX)))
    {
        WCHAR szDrive[MAX_PATH];

        if (GetDlgItemText(_hdlg, IDC_QCA_EDIT, szDrive, ARRAYSIZE(szDrive)))
        {
            int iDrive = -1;

            if ((TEXT('a') <= szDrive[0]) && (TEXT('z') >= szDrive[0]))
            {
                iDrive = szDrive[0] - TEXT('a');
            }
            else
            {
                if ((TEXT('A') <= szDrive[0]) && (TEXT('Z') >= szDrive[0]))
                {
                    iDrive = szDrive[0] - TEXT('A');
                }
            }

            if (-1 != iDrive)
            {
                if (wParam == (WPARAM)iDrive)
                {
                    DWORD dwFilter = _BuildFilterFlag(_hdlg, IDC_QCA_CHECKBOX);

                    lRet = (lParam & dwFilter);

                    if (lRet)
                    {
                        wsprintf(szText, TEXT("    Filter (0x%08X) matches ContentType -> Cancel AutoRun! (ret = 0x%08X)"),
                            dwFilter, lRet);
                    }
                    else
                    {
                        wsprintf(szText, TEXT("    Filter (0x%08X) does *NOT* match ContentType -> No cancel (ret = 0x%08X)"),
                            dwFilter, lRet);
                    }
                }

                _PrintMsg(szText);
            }
        }
    }

    return lRet;
}

typedef HRESULT (*SHCREATEQUERYCANCELAUTOPLAYMONIKER)(IMoniker** ppmoniker);

void CAppDialog::_OnQueryCancelAutoplayIntfChanged()
{
    BOOL fEnable = (BST_CHECKED == Button_GetCheck(GetDlgItem(_hdlg, IDC_IQCA_CHECKBOX)));

    EnableWindow(GetDlgItem(_hdlg, IDC_IQCA_EDIT               ), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_IQCA_AUTORUNINF_CHECKBOX), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_IQCA_AUDIOCD_CHECKBOX   ), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_IQCA_DVDMOVIE_CHECKBOX  ), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_IQCA_BLANKCD_CHECKBOX   ), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_IQCA_BLANKDVD_CHECKBOX  ), fEnable);

    // Are we registered?
    if (INVALID_DWORD == _dwRegisterROT2)
    {
        // Nope
        // Do we need to register?
        if (fEnable)
        {
            // Yes
            HINSTANCE hinstShell32 = LoadLibrary(TEXT("shell32.dll"));

            if (hinstShell32)
            {
                SHCREATEQUERYCANCELAUTOPLAYMONIKER fct = (SHCREATEQUERYCANCELAUTOPLAYMONIKER)GetProcAddress(
                    hinstShell32, "SHCreateQueryCancelAutoPlayMoniker");

                if (fct)
                {
	                IMoniker* pmoniker;
    
                    HRESULT hr = fct(&pmoniker);

	                if (SUCCEEDED(hr))
	                {
		                IRunningObjectTable *prot;

		                if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
		                {
			                prot->Register(ROTFLAGS_REGISTRATIONKEEPSALIVE,
                                static_cast<IClassFactory *>(this), pmoniker, &_dwRegisterROT2);

                            _PrintMsg(TEXT("Registered for IQueryCancelAutoplay!"));

			                prot->Release();
		                }

		                pmoniker->Release();
	                }
                }

                FreeLibrary(hinstShell32);
            }
        }
    }
    else
    {
        // Yes
        // Do we need to unregister?
        if (!fEnable)
        {
            // Yes
		    IRunningObjectTable *prot;

		    if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
		    {
			    prot->Revoke(_dwRegisterROT2);

                _PrintMsg(TEXT("Unregistered for IQueryCancelAutoplay!"));

			    _dwRegisterROT2 = INVALID_DWORD;
			    prot->Release();
		    }
        }
    }
}

void CAppDialog::_OnQueryCancelAutoplayWindowsMessageChanged()
{
    BOOL fEnable = (BST_CHECKED == Button_GetCheck(GetDlgItem(_hdlg, IDC_QCA_CHECKBOX)));

    EnableWindow(GetDlgItem(_hdlg, IDC_QCA_EDIT               ), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_QCA_AUTORUNINF_CHECKBOX), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_QCA_AUDIOCD_CHECKBOX   ), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_QCA_DVDMOVIE_CHECKBOX  ), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_QCA_BLANKCD_CHECKBOX   ), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_QCA_BLANKDVD_CHECKBOX  ), fEnable);
}

void CAppDialog::_OnAutoplayChanged()
{
    BOOL fEnable = (BST_CHECKED == Button_GetCheck(GetDlgItem(_hdlg, IDC_AUTOPLAY_CHECKBOX)));
    BOOL fRegister = (BST_CHECKED == Button_GetCheck(GetDlgItem(_hdlg, IDC_AUTOPLAY_ONOFF_CHECKBOX)));

    EnableWindow(GetDlgItem(_hdlg, IDC_AUTOPLAY_EVENTHANDLER_EDIT), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_AUTOPLAY_CLSID_EDIT), fEnable);
    EnableWindow(GetDlgItem(_hdlg, IDC_AUTOPLAY_ONOFF_CHECKBOX), fEnable);

    // Are we registered?
    if (INVALID_DWORD == _dwRegisterROT)
    {
        // Nope
        // Do we need to register?
        if (fEnable && fRegister)
        {
            // Yes
            HINSTANCE hinstShSvcs = LoadLibrary(TEXT("shsvcs.dll"));

            if (hinstShSvcs)
            {
                CREATEHARDWAREEVENTMONIKER fct = (CREATEHARDWAREEVENTMONIKER)GetProcAddress(
                    hinstShSvcs, "CreateHardwareEventMoniker");

                if (fct)
                {
                    WCHAR szEventHandler[64];
                    WCHAR szCLSID[39];
	                IMoniker* pmoniker;

                    if (GetDlgItemText(_hdlg, IDC_AUTOPLAY_EVENTHANDLER_EDIT, szEventHandler,
                        ARRAYSIZE(szEventHandler)))
                    {
                        if (GetDlgItemText(_hdlg, IDC_AUTOPLAY_CLSID_EDIT, szCLSID,
                            ARRAYSIZE(szCLSID)))
                        {
                            CLSID clsid;
                            HRESULT hr = CLSIDFromString(szCLSID, &clsid);

	                        if (SUCCEEDED(hr))
	                        {
                                hr = fct(clsid, szEventHandler, &pmoniker);

	                            if (SUCCEEDED(hr))
	                            {
		                            IRunningObjectTable *prot;

		                            if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
		                            {
                                        if (SUCCEEDED(prot->Register(ROTFLAGS_ALLOWANYCLIENT | ROTFLAGS_REGISTRATIONKEEPSALIVE,
                                            static_cast<IClassFactory *>(this), pmoniker, &_dwRegisterROT)))
                                        {
                                            _PrintMsg(TEXT("Registered to Cancel Autoplay!"));
                                        }

			                            prot->Release();
		                            }

		                            pmoniker->Release();
	                            }

            /*	                CoRegisterClassObject(CLSID_App, static_cast<IClassFactory *>(this),
                                    CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &_dwRegisterClass);*/
                            }
                        }
                    }
                }

                FreeLibrary(hinstShSvcs);
            }
        }
    }
    else
    {
        // Yes
        // Do we need to unregister?
        if (!(fEnable && fRegister))
        {
            // Yes
		    IRunningObjectTable *prot;

		    if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
		    {
			    prot->Revoke(_dwRegisterROT);

                _PrintMsg(TEXT("Unregistered to Cancel Autoplay!"));

                _dwRegisterROT = INVALID_DWORD;
			    prot->Release();
		    }
        }
    }
}

INT_PTR CAppDialog::DlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static UINT uQCA = 0;

    if (!uQCA)
    {
        uQCA = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
    }

    if (uMsg == uQCA)
    {
        INT_PTR iRet= _OnQueryCancelAutoplay(wParam, lParam);

        SetWindowLongPtr(_hdlg, DWLP_MSGRESULT, iRet);

        return TRUE;
    }
    else
    {
        switch (uMsg)
        {
        case WM_INITDIALOG:
            _OnInitDlg();
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    return EndDialog(_hdlg, TRUE);

                case IDC_QCA_CHECKBOX:
                    _OnQueryCancelAutoplayWindowsMessageChanged();
                    return FALSE;

                case IDC_IQCA_CHECKBOX:
                    _OnQueryCancelAutoplayIntfChanged();
                    return FALSE;

                case IDC_AUTOPLAY_CHECKBOX:
                    _OnAutoplayChanged();
                    return FALSE;

                case IDC_AUTOPLAY_ONOFF_CHECKBOX:
                    _OnAutoplayChanged();
                    return FALSE;
            }
            break;

	    case WM_DESTROY:
		    _OnDestroyDlg();
		    break;

        default:
            return FALSE;
        }
    }

    return TRUE;
}


int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPSTR /*lpCmdLine*/, int /*nCmdShow*/)
{
	g_hinst = hInstance;

    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);

    if (SUCCEEDED(hr))
    {
	    CAppDialog *pdlg = new CAppDialog();

	    if (pdlg)
	    {
		    pdlg->DoModal(NULL);
		    pdlg->Release();
	    }

        CoUninitialize();
    }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\factdata.h ===
#ifndef _FACTDATA_H_
#define _FACTDATA_H_

#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
//  Component creation function
typedef void (*COMFACTORYCB)(BOOL fIncrement);

typedef HRESULT (*FPCREATEINSTANCE)(COMFACTORYCB, IUnknown*, IUnknown**);

#define THREADINGMODEL_FREE             0x00000001
#define THREADINGMODEL_APARTMENT        0x00000002
#define THREADINGMODEL_NEUTRAL          0x00000004

#define THREADINGMODEL_BOTH             (THREADINGMODEL_FREE | THREADINGMODEL_APARTMENT)

extern const CLSID APPID_ShellHWDetection;

///////////////////////////////////////////////////////////////////////////////
// CFactoryData
//   Information CFactory needs to create a component supported by the DLL
class CFactoryData
{
public:
    // The class ID for the component
    const CLSID* _pCLSID;

    // Pointer to the function that creates it
    FPCREATEINSTANCE CreateInstance;

    // Name of the component to register in the registry
    LPCWSTR _pszRegistryName;

    // ProgID
    LPCWSTR _pszProgID;

    // Version-independent ProgID
    LPCWSTR _pszVerIndProgID;

    // ThreadingModel
    DWORD _dwThreadingModel;

    // For CoRegisterClassObject (used only for COM Exe server)
    DWORD _dwClsContext;

    // For CoRegisterClassObject (used only for COM Exe server)
    DWORD _dwFlags;

    // LocalService
    LPCWSTR _pszLocalService;

    // AppID
    const CLSID* _pAppID;

    // Helper function for finding the class ID
    BOOL IsClassID(REFCLSID rclsid) const
    { return (*_pCLSID == rclsid);}

    //
    BOOL IsInprocServer() const
    { return !_dwClsContext || ((CLSCTX_INPROC_SERVER |
                    CLSCTX_INPROC_HANDLER) & _dwClsContext); }

    BOOL IsLocalServer() const
    { return ((CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER) & _dwClsContext) && !_pszLocalService; }

    BOOL IsLocalService() const
    { return ((CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER) & _dwClsContext) &&
        _pszLocalService;  }
};

#endif //_FACTDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\apdiag\piping.cpp ===
#include "ids.h"
#include "cmmn.h"

#include <tchar.h>
#include <io.h>
#include <objbase.h>

#ifndef UNICODE
#error This has to be UNICODE
#endif

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

static SECURITY_ATTRIBUTES     _sa = {0};
static ACL*                    _pacl = NULL;
static SID*                    _psidLocalUsers = NULL;
static SECURITY_DESCRIPTOR*    _psd = NULL;

HRESULT _InitSecurityDescriptor();

VOID InstanceThread(LPVOID lpvParam) 
{ 
    BYTE bRequest[4096]; 
    DWORD cbBytesRead;
    BOOL fSuccess;
    HANDLE hPipe = (HANDLE)lpvParam; 

    fSuccess = ReadFile(hPipe, bRequest, sizeof(bRequest), &cbBytesRead,
        NULL);

    if (fSuccess && cbBytesRead)
    {
        if (!g_fPaused)
        {
            SendMessage(GetDlgItem(g_hwndDlg, IDC_EDIT1), EM_SETSEL, (WPARAM)-2,
                (WPARAM)-2);

            SendMessage(GetDlgItem(g_hwndDlg, IDC_EDIT1), EM_REPLACESEL, 0,
                (LPARAM)(LPWSTR)bRequest);
        }
    }

    DisconnectNamedPipe(hPipe); 
    CloseHandle(hPipe); 
} 

DWORD WINAPI Do(PVOID )
{
    TCHAR szPipeName[MAX_PATH] = TEXT("\\\\.\\pipe\\ShellService_Diagnostic");
    
    HRESULT hres = _InitSecurityDescriptor();

    if (SUCCEEDED(hres))
    {
        g_hEvent = CreateEvent(NULL, TRUE, TRUE, TEXT("ShellService_Diagnostic"));

        if (g_hEvent)
        {
            // The main loop creates an instance of the named pipe and 
            // then waits for a client to connect to it. When the client 
            // connects, a thread is created to handle communications 
            // with that client, and the loop is repeated.
            do
            { 
                HANDLE hPipe = CreateNamedPipe( 
                    szPipeName,               // pipe name 
                    PIPE_ACCESS_DUPLEX,       // read/write access 
                    PIPE_TYPE_MESSAGE |       // message type pipe 
                    PIPE_READMODE_MESSAGE |   // message-read mode 
                    PIPE_WAIT,                // blocking mode 
                    PIPE_UNLIMITED_INSTANCES, // max. instances  
                    256,                      // output buffer size 
                    4096,                     // input buffer size 
                    10 * 1000,                // client time-out
                    &_sa);

                if (hPipe != INVALID_HANDLE_VALUE) 
                {
                    // Wait for the client to connect; if it succeeds, 
                    // the function returns a nonzero value. If the function returns 
                    // zero, GetLastError returns ERROR_PIPE_CONNECTED. 

                    BOOL fConnected = ConnectNamedPipe(hPipe, NULL) ?  TRUE :
                        (GetLastError() == ERROR_PIPE_CONNECTED); 

                    if (fConnected) 
                    { 
                        DWORD dwThreadId; 

                        // Create a thread for this client. 
                        HANDLE hThread = CreateThread( 
                            NULL,              // no security attribute 
                            0,                 // default stack size 
                            (LPTHREAD_START_ROUTINE) InstanceThread, 
                            (LPVOID) hPipe,    // thread parameter 
                            0,                 // not suspended 
                            &dwThreadId);      // returns thread ID 

                        if (hThread) 
                        {
                            CloseHandle(hThread);
                        }
                    } 
                    else
                    {
                        // The client could not connect, so close the pipe. 
                        CloseHandle(hPipe);
                    }
                }
            }
#pragma warning(push)
#pragma warning(disable : 4127)
            while (1);
#pragma warning(pop)
        }
    }

    return 0;
}

HRESULT _InitSecurityDescriptor()
{
    HRESULT hres;

    if (_pacl)
    {
        hres = S_OK;
    }
    else
    {
        hres = E_FAIL;
        SID_IDENTIFIER_AUTHORITY sidAuthNT = SECURITY_WORLD_SID_AUTHORITY;

        if (AllocateAndInitializeSid(&sidAuthNT, 1, SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0, (void**)&_psidLocalUsers))
        {
            DWORD cbacl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) -
                sizeof(DWORD/*ACCESS_ALLOWED_ACE.SidStart*/) +
                GetLengthSid(_psidLocalUsers);

            _pacl = (ACL*)LocalAlloc(LPTR, cbacl);

            if (_pacl)
            {
                if (InitializeAcl(_pacl, cbacl, ACL_REVISION))
                {
                    if (AddAccessAllowedAce(_pacl, ACL_REVISION, FILE_ALL_ACCESS,
                        _psidLocalUsers))
                    {
                        _psd = (SECURITY_DESCRIPTOR*)LocalAlloc(LPTR,
                            sizeof(SECURITY_DESCRIPTOR));

                        if (_psd)
                        {
                            if (InitializeSecurityDescriptor(_psd,
                                SECURITY_DESCRIPTOR_REVISION))
                            {
                                if (SetSecurityDescriptorDacl(_psd, TRUE,
                                    _pacl, FALSE))
                                {
                                    if (IsValidSecurityDescriptor(_psd))
                                    {
                                        _sa.nLength = sizeof(_sa);
                                        _sa.lpSecurityDescriptor = _psd;
                                        _sa.bInheritHandle = TRUE;

                                        hres = S_OK;
                                    }
                                }
                            }
                        }
                        else
                        {
                            hres = E_OUTOFMEMORY;
                        }
                    }
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }    

        if (FAILED(hres))
        {
            if (_psidLocalUsers)
            {
                FreeSid(_psidLocalUsers);
            }

            if (_pacl)
            {
                LocalFree((HLOCAL)_pacl);
            }

            if (_psd)
            {
                LocalFree((HLOCAL)_psd);
            }
        }
    }
  
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\hdservice.h ===
#ifndef     _HDService_
#define     _HDService_

class   CHDService
{
    public:
        static  void        Main (DWORD dwReason);
        static  HRESULT     Install (BOOL fInstall, LPCWSTR pszCmdLine);
        static  HRESULT     RegisterServer (void);
        static  HRESULT     UnregisterServer (void);
        static  HRESULT     CanUnloadNow (void);
        static  HRESULT     GetClassObject (REFCLSID rclsid, REFIID riid, void** ppv);
};

#endif  /*  _HDService_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\namellst.h ===
#ifndef _NAMELLST_H_
#define _NAMELLST_H_

#include <objbase.h>

#include "mischlpr.h"

///////////////////////////////////////////////////////////////////////////////
//
class CNamedElem : public CRefCounted
{
public:
    HRESULT GetName(LPTSTR psz, DWORD cch, DWORD* pcchRequired);

    virtual HRESULT Init(LPCTSTR pszElemName) PURE;

#ifdef DEBUG
    LPCTSTR DbgGetName();
#endif

protected:
    CNamedElem();
    virtual ~CNamedElem();

    HRESULT _SetName(LPCTSTR pszElemName);
    HRESULT _FreeName();

protected:
    LPTSTR      _pszElemName;

    // for access to _pelemNext
    friend class CNamedElemList;
};

///////////////////////////////////////////////////////////////////////////////
//
class CFillEnum : public CRefCounted
{
public:
    virtual HRESULT Next(LPTSTR pszElemName, DWORD cchElemName,
        DWORD* pcchRequired) = 0;
};
///////////////////////////////////////////////////////////////////////////////
//
typedef HRESULT (*NAMEDELEMCREATEFCT)(CNamedElem** ppelem);

// return values:
//      S_OK when everything's all right
//      S_FALSE when no more items
//      E_BUFFERTOOSMALL if buffer too small
typedef HRESULT (*NAMEDELEMGETFILLENUMFCT)(CFillEnum** ppfillenum);

///////////////////////////////////////////////////////////////////////////////
//
class CElemSlot : public CRefCounted
{
public:
    HRESULT Init(CNamedElem* pelem, CElemSlot* pesPrev, CElemSlot* pesNext);
    HRESULT Remove();

    HRESULT GetNamedElem(CNamedElem** ppelem);
    void SetPrev(CElemSlot* pes);

    CElemSlot* GetNextValid();
    CElemSlot* GetPrevValid();

    BOOL IsValid();

public:
    CElemSlot();
    virtual ~CElemSlot();

private:
    // Payload
    CNamedElem*         _pelem;

    // Impl details
    BOOL                _fValid;
    CElemSlot*          _pesPrev;
    CElemSlot*          _pesNext;
};

///////////////////////////////////////////////////////////////////////////////
//
class CNamedElemEnum : public CRefCounted
{
public:
    HRESULT Next(CNamedElem** ppelem);

public:
    CNamedElemEnum();
    virtual ~CNamedElemEnum();

private:
    HRESULT _Init(CElemSlot* pesHead, CRefCountedCritSect* pcsList);

private:
    CElemSlot*              _pesCurrent;
    BOOL                    _fFirst;
    CRefCountedCritSect*    _pcsList;

    // for access to _Init
    friend class CNamedElemList;
};

///////////////////////////////////////////////////////////////////////////////
//
class CNamedElemList : public CRefCounted
{
public:
    HRESULT Init(NAMEDELEMCREATEFCT createfct,
        NAMEDELEMGETFILLENUMFCT enumfct);

    // Returns S_FALSE if cannot find it
    HRESULT Get(LPCTSTR pszElemName, CNamedElem** ppelem);

    // Returns S_OK if was already existing
    //         S_FALSE if was just added
    HRESULT GetOrAdd(LPCTSTR pszElemName, CNamedElem** ppelem);

    HRESULT Add(LPCTSTR pszElemName, CNamedElem** ppelem);
    HRESULT Remove(LPCTSTR pszElemName);

    HRESULT ReEnum();
    HRESULT EmptyList();

    HRESULT GetEnum(CNamedElemEnum** ppenum);

#ifdef DEBUG
    HRESULT InitDebug(LPWSTR pszDebugName);
    void AssertAllElemsRefCount1();
    void AssertNoDuplicate();
#endif

public:
    CNamedElemList();
    virtual ~CNamedElemList();

private:
    HRESULT _Add(LPCTSTR pszElemName, CNamedElem** ppelem);
    HRESULT _GetTail(CElemSlot** ppes);
    HRESULT _GetElemSlot(LPCTSTR pszElemName, CElemSlot** ppes);
    HRESULT _Remove(LPCTSTR pszElemName);
    HRESULT _EmptyList();
    CElemSlot* _GetValidHead();

private:
    CElemSlot*              _pesHead;
    NAMEDELEMCREATEFCT      _createfct;
    NAMEDELEMGETFILLENUMFCT _enumfct;

    CRefCountedCritSect*    _pcs;

#ifdef DEBUG
    WCHAR                   _szDebugName[100];
#endif
};

#endif //_NAMELLST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\mischlpr.h ===
#ifndef _MISCHLPR_H_
#define _MISCHLPR_H_

#include <objbase.h>

#include "dbg.h"
#include "tfids.h"

#define UNREF_PARAM(a)
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

class CRefCounted
{
#ifdef DEBUG
private:
    void _TraceHelper(LPCTSTR pszOper, ULONG cRef, LPCTSTR pszObjName,
        LPCSTR pszFile, const int iLine)
    {
        LPTSTR pszFinal;
        WCHAR szwBuf[MAX_PATH + 12];
        CHAR szBuf[MAX_PATH + 12];
        int c = lstrlenA(pszFile);
        LPCSTR pszFileName;

        while (c && ('\\' != *(pszFile + c)))
        {
            --c;
        }

        pszFileName = pszFile + c + 1;

        wsprintfA(szBuf, "<%s, %d>", pszFileName, iLine);
        
#ifdef UNICODE
        pszFinal = szwBuf;

        MultiByteToWideChar(CP_ACP, 0, szBuf, lstrlenA(szBuf) + 1, szwBuf,
            sizeof(szwBuf) / sizeof(WCHAR));
#else
        pszFinal = szBuf;
#endif
        
        if (pszObjName)
        {
            TRACE(TF_RCADDREF | TF_NOFILEANDLINE, TEXT("%s {%s} %s: %d"),
                pszFinal, pszObjName, pszOper, cRef);
        }
        else
        {
            TRACE(TF_NOFILEANDLINE | TF_RCADDREF, TEXT("%s %s: %d"), pszFinal,
                pszOper, cRef);
        }
        
    }

protected:
    void _RCCreate(LPCSTR pszFile, const int iLine)
    {
        _TraceHelper(TEXT(" Create"), 1, _pszRCAddRefName, pszFile, iLine);
    }

    LPTSTR              _pszRCAddRefName;

public:
    ULONG _RCGetRefCount()
    {
        return _cRef;
    }

    virtual ULONG RCAddRef(LPCSTR pszFile, const int iLine)
    {
        ULONG cRef = ::InterlockedIncrement((LONG*)&_cRef);

        _TraceHelper(TEXT(" AddRef"), cRef, _pszRCAddRefName, pszFile, iLine);
    
        return cRef;
    }

    virtual ULONG RCRelease(LPCSTR pszFile, const int iLine)
    {
        ULONG cRef = ::InterlockedDecrement((LONG*)&_cRef);

        _TraceHelper(TEXT("Release"), cRef, _pszRCAddRefName, pszFile, iLine);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }

#define RCAddRef() RCAddRef(__FILE__, __LINE__)
#define RCRelease() RCRelease(__FILE__, __LINE__)

#else
public:
    ULONG RCAddRef() { return ::InterlockedIncrement((LONG*)&_cRef); }
    ULONG RCRelease()
    {
        ULONG cRef = ::InterlockedDecrement((LONG*)&_cRef);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }
#endif

    CRefCounted() : _cRef(1)
#ifdef DEBUG
        , _pszRCAddRefName(NULL)
#endif
    {}
    virtual ~CRefCounted() {}

private:
    ULONG _cRef;
};

class CRefCountedCritSect : public CRefCounted, public CRITICAL_SECTION
{};

class CCriticalSection : CRITICAL_SECTION
{
public:
    void Init()
    {
        InitializeCriticalSection(this);
        _fInited = TRUE;

#ifdef DEBUG
        _iLevel = 0;
#endif
    }
    void Enter()
    {
        ASSERT(_fInited);
        EnterCriticalSection(this);
#ifdef DEBUG
        ++_iLevel;
#endif
    }
    void Leave()
    {
        ASSERT(_fInited);
#ifdef DEBUG
        --_iLevel;
#endif
        LeaveCriticalSection(this);
    }

    void Delete()
    {
        if (_fInited)
        {
            _fInited = FALSE;
            DeleteCriticalSection(this);
        }
    }

    BOOL IsInitialized()
    {
        return _fInited;
    }

    BOOL _fInited;
#ifdef DEBUG
    BOOL IsInside()
    {
        ASSERT(_fInited);

        return _iLevel;
    }

    DWORD _iLevel;
#endif
};

class CThreadTask
{
public:
    virtual ~CThreadTask() {}

public:
    // Uses CreateThread, delete 'this' at the end
    HRESULT RunWithTimeout(DWORD dwTimeout);

    // Uses Thread Pool, delete 'this' at the end
    HRESULT Run();

    // Run on 'this' thread, does NOT delete 'this' at the end
    HRESULT RunSynchronously();

protected:
    virtual HRESULT _DoStuff() = 0;

private:
    static DWORD WINAPI _ThreadProc(void* pv);
};

template<typename TDataPtr>
HRESULT _AllocMemoryChunk(DWORD cbSize, TDataPtr* pdataOut)
{
    HRESULT hr;

    *pdataOut = (TDataPtr)LocalAlloc(LPTR, cbSize);

    if (*pdataOut)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

template<typename TDataPtr>
HRESULT _DupMemoryChunk(TDataPtr pdata, DWORD cbSize, TDataPtr* pdataOut)
{
    HRESULT hr;
    *pdataOut = (TDataPtr)LocalAlloc(LPTR, cbSize);

    if (*pdataOut)
    {
        CopyMemory((void*)*pdataOut, pdata, cbSize);

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

template<typename TDataPtr>
HRESULT _FreeMemoryChunk(TDataPtr pdata)
{
    HRESULT hr = S_OK;

    if (LocalFree((HLOCAL)pdata))
    {
        hr = E_FAIL;
    }

    return hr;
}

#endif //_MISCHLPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\str.h ===
#ifndef _STR_H
#define _STR_H

#include <objbase.h>

HRESULT _StringFromGUID(const GUID* pguid, LPWSTR psz, DWORD cch);
HRESULT _GUIDFromString(LPCWSTR psz, GUID* pguid);

#endif //_STR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\rbdebug.h ===
#ifndef _RBDEBUG_H
#define _RBDEBUG_H

#include <objbase.h>

// Registry Based Debug

// We first look in HKCU, then HKLM (there's no HKCU for a service)
// + HKCU\Software\Microsoft\Debug\MyApp.exe
//      . RBD_FLAGS = ...
//      + File
//          . FileName = ... (e.g.: c:\mytrace.txt)
//      + Pipe
//          . MachineName = ... [Default: "." (local machine)] (e.g.: stephstm_dev)
//          . PipeName = ... [Default: MyApp.exe (name of the app)] (e.g.: MyPipe)

#define RBD_TRACE_NONE          0x00000000
#define RBD_TRACE_OUTPUTDEBUG   0x00000001
#define RBD_TRACE_TOFILEANSI    0x00000002
#define RBD_TRACE_TOFILE        0x00000004
#define RBD_TRACE_TOPIPE        0x00000008
#define RBD_TRACE_MASK          0x000000FF

#define RBD_ASSERT_NONE         0x00000000
#define RBD_ASSERT_STOP         0x00000100
#define RBD_ASSERT_TRACE        0x00000200
#define RBD_ASSERT_BEEP         0x00000400
#define RBD_ASSERT_MASK         0x0000FF00

#define TF_ASSERT           0x80000000
#define TF_NOFILEANDLINE    0x40000000
#define TF_THREADID         0x20000000
#define TF_TIME             0x10000000

class CRBDebug
{
public:
    static void SetTraceFileAndLine(LPCSTR pszFile, const int iLine);
    static void __cdecl TraceMsg(DWORD dwFlags, LPTSTR pszMsg, ...);

    static HRESULT Init();

private:
    static HRESULT _Init();
    static HRESULT _InitFile(HKEY hkeyRoot);
    static HRESULT _InitPipe(HKEY hkeyRoot);
    static void _Trace(LPTSTR pszMsg);

public:
    static BOOL             _fInited;
    static DWORD            _dwTraceFlags;
    static DWORD            _dwFlags;
    static TCHAR*           _pszTraceFile;
    static TCHAR*           _pszTracePipe;
    static TCHAR*           _pszModuleName;
    static HANDLE           _hfileTraceFile;
    // + 12: yep, limited to files of less than 10 billion lines...
    // + 13: for threadid
    // + 17: for time
    static TCHAR            _szFileAndLine[MAX_PATH + 12 + 13 + 17];
    static CRITICAL_SECTION _cs;
};

#endif // _RBDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\tfids.h ===
///////////////////////////////////////////////////////////////////////////////
// !!!!!!!! Do not use 0x10000000, 0x20000000, 0x40000000, 0x80000000 !!!!!!!!!
// see rbdebug.h
///////////////////////////////////////////////////////////////////////////////

// Generic Service stuff
#define TF_SERVICE                  0x00000001
// Generic Service stuff, but with more granularity
#define TF_SERVICEDETAILED          0x00000002

#define TF_SERVICEASPROCESS         0x00000004

// Shell HW Detection stuff, related to service
#define TF_SHHWDTCTSVC              0x00000010
// Shell HW Detection stuff, related to detection
#define TF_SHHWDTCTDTCT             0x00000020
#define TF_SHHWDTCTDTCTDETAILED     0x00000040
#define TF_SHHWDTCTDTCTREG          0x00000080

// COM Server stuff
#define TF_COMSERVER                0x00001000

#define TF_COMSERVERSTGINFO         0x00002000
#define TF_COMSERVERDEVINFO         0x00004000

#define TF_NAMEDELEMLISTMODIF       0x00100000

#define TF_RCADDREF                 0x00200000

#define TF_USERS                    0x00400000

#define TF_LEAK                     0x00800000

#define TF_SVCSYNC                  0x01000000

#define TF_WIA                      0x02000000
#define TF_ADVISE                   0x04000000
#define TF_VOLUME                   0x08000000

#define TF_SESSION                  0x08000000

///////////////////////////////////////////////////////////////////////////////
// !!!!!!!! Do not use 0x10000000, 0x20000000, 0x40000000, 0x80000000 !!!!!!!!!
// see rbdebug.h
///////////////////////////////////////////////////////////////////////////////

/*
Diagnostic ranges:

0000 - 0050: Hardware Events
0051 - 0100: Content
0101 - 0150: Handler identification and execution
0151 - 0200: Autoplay Settings
0201 - 0250: User Settings
0251 - 0300: Custom Properties
0301 - 0350: Volume stuff
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\reg.h ===
#ifndef _REG_H
#define _REG_H

#include <objbase.h>

#define MAX_KEY                 MAX_PATH
#define MAX_VALUE               MAX_PATH

HRESULT _RegOpenKey(HKEY hkey, LPCWSTR pszKey, HKEY* phkey);
HRESULT _RegCreateKey(HKEY hkey, LPCWSTR pszKey, HKEY* phkey, DWORD* pdwDisp);
HRESULT _RegCloseKey(HKEY hkey);

HRESULT _RegQueryType(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwType);

HRESULT _RegQueryGeneric(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    PBYTE pbValue, DWORD cbValue);
HRESULT _RegQueryGenericWithType(HKEY hkey, LPCWSTR pszSubKey,
    LPCWSTR pszValueName, DWORD* pdwType, PBYTE pbValue, DWORD cbValue);

HRESULT _RegQueryValueSize(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pcbValue);
HRESULT _RegQueryString(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    LPWSTR pszValue, DWORD cchValue);
HRESULT _RegQueryDWORD(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwValue);
HRESULT _RegEnumStringValue(HKEY hkey, DWORD dwIndex, LPWSTR pszValue,
    DWORD cchValue);
HRESULT _RegEnumStringKey(HKEY hkey, DWORD dwIndex, LPWSTR pszKey,
    DWORD cchKey);

HRESULT _RegDeleteValue(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName);

HRESULT _RegSetString(HKEY hkey, LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT _RegSetDWORD(HKEY hkey, LPCWSTR pszValueName, DWORD dwValue);
HRESULT _RegSetBinary(HKEY hkey, LPCWSTR pszValueName, PVOID pvValue, DWORD cbValue);
HRESULT _RegSetKeyAndString(HKEY hkey, LPCWSTR pszKey, LPCWSTR pszSubkey,
    LPCWSTR pszValueName, LPCWSTR pszValue);
HRESULT _RegSubkeyExists(HKEY hkey, LPCWSTR pszPath, LPCWSTR pszSubkey);

#endif //_REG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\unk.h ===
#ifndef _UNK_H_
#define _UNK_H_

#include <objbase.h>

typedef void (*COMFACTORYCB)(BOOL fIncrement);

class CCOMBase
{
public:
    virtual HRESULT UnkInit() { return S_OK; }
};

struct INTFMAPENTRY
{
    const IID*  piid;
    DWORD       dwOffset;
};

template <class CCOMBASE>
class CUnkTmpl : public CCOMBASE
{
public:
    CUnkTmpl(IUnknown*) : _cRef(1) {}
    ~CUnkTmpl() { if (_cfcb) { _cfcb(FALSE); } }

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv)
    {
        HRESULT hres;

        if (IID_IUnknown == riid)
        {
            IUnknown* punk;

            *ppv = (IUnknown*)(((PBYTE)this) + _pintfmap[0].dwOffset);

            punk = (IUnknown*)(*ppv);
            punk->AddRef();

            hres = S_OK;
        }
        else
        {
            hres = _GetInterfaceFromMap(riid, ppv);
        }

        return hres;
    }

	STDMETHODIMP_(ULONG) AddRef() { return ::InterlockedIncrement((LONG*)&_cRef); }
	STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = ::InterlockedDecrement((LONG*)&_cRef);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }

protected:
    HRESULT _GetInterfaceFromMap(REFIID riid, void** ppv)
    {
        HRESULT hres = E_NOINTERFACE;

        for (DWORD dw = 0; dw < _cintfmap; ++dw)
        {
            if (riid == *(_pintfmap[dw].piid))
            {
                IUnknown* punk = (IUnknown*)(((PBYTE)this) +
                    _pintfmap[dw].dwOffset);
                punk->AddRef();
                *ppv = punk;
                hres = S_OK;
                break;
            }
        }

        return hres;
    }

public:
    static HRESULT UnkCreateInstance(COMFACTORYCB cfcb,
        IUnknown* pUnknownOuter, IUnknown** ppunkNew)
    {
        HRESULT hres = E_OUTOFMEMORY;

        if (!_cfcb)
        {
            _cfcb = cfcb;
        }

        CUnkTmpl<CCOMBASE>* pNew = new CUnkTmpl<CCOMBASE>(pUnknownOuter);

        if (pNew)
        {
            hres = pNew->UnkInit();

            if (FAILED(hres))
            {
                delete pNew;
            }
            else
            {
                *ppunkNew = (IUnknown*)(((PBYTE)pNew) +
                    pNew->_pintfmap[0].dwOffset);
            }
        }

        return hres;
    }

private:
    ULONG                       _cRef;

    static COMFACTORYCB         _cfcb;
    static const INTFMAPENTRY*  _pintfmap;
    static const DWORD          _cintfmap;
};

// for now: begin
#ifndef OFFSETOFCLASS
//***   OFFSETOFCLASS -- (stolen from ATL)
// we use STATIC_CAST not SAFE_CAST because the compiler gets confused
// (it doesn't constant-fold the ,-op in SAFE_CAST so we end up generating
// code for the table!)

#define OFFSETOFCLASS(base, derived) \
    ((DWORD)(DWORD_PTR)(static_cast<base*>((derived*)8))-8)
#endif
// for now: end

#define _INTFMAPENTRY(Cthis, Ifoo) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Ifoo, Cthis) }

#define _INTFMAPENTRY2(Cthis, Ifoo, Iimpl) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#endif // _UNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\sfstr.h ===
#include <objbase.h>

// Review 500?
#define E_BUFFERTOOSMALL MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 500)
#define E_SOURCEBUFFERTOOSMALL MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 501)

// SafeStrCpyN & SafeStrCatN return values:
//      S_OK:               Success and guaranteed NULL terminated.
//      E_INVALIDARG:       If any ptr is NULL, or cchDest <= 0.
//      E_BUFFERTOOSMALL:   If cchDest is too small.  Content of pszDest is
//                          undefined.

HRESULT SafeStrCpyN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest);
HRESULT SafeStrCatN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest);

// Same return values as for the corresponding SafeStrCxxN, and
//      FAILED(hres):       *ppchLeft and *ppszEnd are undefined.
// 
// *pcchLeft = nb char left in pszDest including the '\0\ just put there
// *ppszEnd = points to the '\0' just put there
//
HRESULT SafeStrCpyNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft);
HRESULT SafeStrCatNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft);

// Comment: Do not use to copy only N first char of a string.  Will return
//      failure if does not encounter '\0' in source.

HRESULT SafeStrCpyNReq(LPWSTR pszDest, LPWSTR pszSrc, DWORD cchDest,
    DWORD* pcchRequired);

// SafeStrCpyNExact & SafeStrCpyNExactEx return values:
//      Same as SaStrCpyN, plus:
//      E_SOURCEBUFFERTOOSMALL: The source buffer did not contain at least
//                              cchExact chars
//
// cchExact has to include the NULL terminator
HRESULT SafeStrCpyNExact(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact);
HRESULT SafeStrCpyNExactEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact, LPWSTR* ppszEnd, DWORD* pcchLeft);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\inc\users.h ===
#pragma once

#include "mischlpr.h"

#include <winsta.h>

// In between _CoGetCallingUserHKCU and _CoCloseCallingUserHKCU
// we impersonate the calling user

// phThreadToken is out only
HRESULT _CoGetCallingUserHKCU(HANDLE* phThreadToken, HKEY* phkey);
HRESULT _CoCloseCallingUserHKCU(HANDLE hThreadToken, HKEY hkey);

HRESULT _GetCurrentUserHKCU(HANDLE* phThreadToken, HKEY* phkey);
HRESULT _CloseCurrentUserHKCU(HANDLE hThreadToken, HKEY hkey);

HRESULT _CoCreateInstanceInConsoleSession(REFCLSID rclsid,
    IUnknown* punkOuter, DWORD dwClsContext, REFIID riid, void** ppv);

HRESULT _GiveAllowForegroundToConsoleShell();

class CImpersonateBase
{
public:
    virtual HRESULT Impersonate() = 0;
    virtual HRESULT RevertToSelf() = 0;
};

class CImpersonateTokenBased : public CImpersonateBase
{
public:
    CImpersonateTokenBased();
    virtual ~CImpersonateTokenBased();

public:
    HRESULT Impersonate();
    HRESULT RevertToSelf();

protected:
    virtual HRESULT _GetToken(HANDLE* phToken) = 0;

private:
    HRESULT _RevertToSelf();

private:

    HANDLE          _hToken;
};

class CImpersonateConsoleSessionUser : public CImpersonateTokenBased
{
protected:
    HRESULT _GetToken(HANDLE* phToken);
};

class CImpersonateEveryone : public CImpersonateTokenBased, public CRefCounted
{
protected:
    HRESULT _GetToken(HANDLE* phToken);
};

class CImpersonateCOMCaller : public CImpersonateBase
{
public:
    CImpersonateCOMCaller();
    ~CImpersonateCOMCaller();

public:
    HRESULT Impersonate();
    HRESULT RevertToSelf();

private:
    HRESULT _RevertToSelf();

private:
    BOOL    _fImpersonating;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\dll.cpp ===
#include "fact.h"
#include "HDService.h"

///////////////////////////////////////////////////////////////////////////////
// Exported functions

//  These are static C++ member functions that are called from the common exported functions.

extern  HINSTANCE   g_hInstance;

void    CHDService::Main (DWORD dwReason)

{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        CCOMBaseFactory::_hModule = (HINSTANCE)g_hInstance;

        if (!CCOMBaseFactory::_fCritSectInit)
        {
            InitializeCriticalSection(&CCOMBaseFactory::_cs);
            CCOMBaseFactory::_fCritSectInit = TRUE;
        }
    }
    else
    {
        if (DLL_PROCESS_DETACH == dwReason)
        {
            if (CCOMBaseFactory::_fCritSectInit)
            {
                DeleteCriticalSection(&CCOMBaseFactory::_cs);
            }            
        }
    }
}

HRESULT     CHDService::RegisterServer (void)

{
    return CCOMBaseFactory::_RegisterAll();
}

HRESULT     CHDService::UnregisterServer (void)

{
    return CCOMBaseFactory::_UnregisterAll();
}

HRESULT     CHDService::CanUnloadNow (void)

{
    return CCOMBaseFactory::_CanUnloadNow();
}

HRESULT     CHDService::GetClassObject (REFCLSID rclsid, REFIID riid, void** ppv)

{
    return CCOMBaseFactory::_GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\dbg.cpp ===
#include "dbg.h"

#ifdef DEBUG

void __cdecl DbgTrace(DWORD, LPTSTR pszMsg, ...)
{
    TCHAR szBuf[4096];
    va_list vArgs;

    va_start(vArgs, pszMsg);

    wvsprintf(szBuf, pszMsg, vArgs);

    va_end(vArgs);

    OutputDebugString(szBuf);
    OutputDebugString(TEXT("\n"));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\guids.cpp ===
#include <objbase.h>

// {02506D0A-A7F5-419d-94D2-ED26F0753654}
extern "C" const IID IID_IService =
    {0x02506d0a, 0xa7f5, 0x419d,
    {0x94, 0xd2, 0xed, 0x26, 0xf0, 0x75, 0x36, 0x54}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\mischlpr.cpp ===
#include "mischlpr.h"

HRESULT CThreadTask::RunWithTimeout(DWORD /*dwTimeout*/)
{
    return E_NOTIMPL;
}

HRESULT CThreadTask::Run()
{
    BOOL fResult;
    HRESULT hr = S_OK;

    fResult = QueueUserWorkItem(_ThreadProc, this, WT_EXECUTELONGFUNCTION);
    if (!fResult)
    {
        DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}

HRESULT CThreadTask::RunSynchronously()
{
    return _DoStuff();
}

//static
DWORD WINAPI CThreadTask::_ThreadProc(void* pv)
{
    DWORD dwRet;
    CThreadTask* pTask = (CThreadTask*)pv;

    dwRet = (DWORD)(pTask->_DoStuff());

    delete pTask;

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\fact.cpp ===
///////////////////////////////////////////////////////////////////////////////
// CCOMBaseFactory
//    Base class for reusing a single class factory for all components in a DLL

#include "fact.h"
#include "unk.h"
#include "regsvr.h"

#include "dbg.h"

struct OUTPROCINFO
{
    // Reserved (used only for COM Exe server)
    IClassFactory* _pfact;
    DWORD _dwRegister;
};

LONG CCOMBaseFactory::_cServerLocks = 0;
LONG CCOMBaseFactory::_cComponents = 0;
HMODULE CCOMBaseFactory::_hModule = NULL;
CRITICAL_SECTION CCOMBaseFactory::_cs = {0};

OUTPROCINFO* CCOMBaseFactory::_popinfo = NULL;
DWORD CCOMBaseFactory::_dwThreadID = 0;
BOOL CCOMBaseFactory::_fCritSectInit = FALSE;

///////////////////////////////////////////////////////////////////////////////
// IUnknown implementation
STDMETHODIMP CCOMBaseFactory::QueryInterface(REFIID iid, void** ppv)
{   
    IUnknown* punk = NULL;
    HRESULT hres = S_OK;

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        punk = this;
        punk->AddRef();
    }
    else
    {
        hres = E_NOINTERFACE;
    }

    *ppv = punk;

    return hres;
}

STDMETHODIMP_(ULONG) CCOMBaseFactory::AddRef()
{
    return ::InterlockedIncrement((LONG*)&_cRef);
}

STDMETHODIMP_(ULONG) CCOMBaseFactory::Release()
{
    ULONG cRef = ::InterlockedDecrement((LONG*)&_cRef);

    if (!cRef)
    {
        delete this;
    }

    return cRef;
}

///////////////////////////////////////////////////////////////////////////////
// IFactory implementation
STDMETHODIMP CCOMBaseFactory::CreateInstance(IUnknown* pUnknownOuter,
    REFIID riid, void** ppv)
{
    HRESULT hres = CLASS_E_NOAGGREGATION;

    // We don't support aggregation at all for now
    if (!pUnknownOuter)
    {
        // Aggregate only if the requested IID is IID_IUnknown.
        if ((pUnknownOuter != NULL) && (riid != IID_IUnknown))
        {
            hres = CLASS_E_NOAGGREGATION;
        }
        else
        {
            // Create the component.
            IUnknown* punkNew;

            hres = _pFactoryData->CreateInstance(
                CCOMBaseFactory::_COMFactoryCB, pUnknownOuter, &punkNew);

            if (SUCCEEDED(hres))
            {
                _COMFactoryCB(TRUE);

                // Get the requested interface.
//                hres = pNewComponent->NondelegatingQueryInterface(iid, ppv);
                hres = punkNew->QueryInterface(riid, ppv);

                // Release the reference held by the class factory.
//                pNewComponent->NondelegatingRelease();
                punkNew->Release();
            }
        }
    }

    return hres;
}

STDMETHODIMP CCOMBaseFactory::LockServer(BOOL fLock)
{
    return _LockServer(fLock);
}

///////////////////////////////////////////////////////////////////////////////
// Install/Unintall
//static
HRESULT CCOMBaseFactory::_RegisterAll()
{
    for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
    {
        RegisterServer(_hModule,
           *(_pDLLFactoryData[dw]._pCLSID),
           _pDLLFactoryData[dw]._pszRegistryName,
           _pDLLFactoryData[dw]._pszVerIndProgID,
           _pDLLFactoryData[dw]._pszProgID,
           _pDLLFactoryData[dw]._dwThreadingModel,
           _pDLLFactoryData[dw].IsInprocServer(),
           _pDLLFactoryData[dw].IsLocalServer(),
           _pDLLFactoryData[dw].IsLocalService(),
           _pDLLFactoryData[dw]._pszLocalService,
           _pDLLFactoryData[dw]._pAppID);
    }

    return S_OK;
}

//static
HRESULT CCOMBaseFactory::_UnregisterAll()
{
    for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
    {
        UnregisterServer(*(_pDLLFactoryData[dw]._pCLSID),
            _pDLLFactoryData[dw]._pszVerIndProgID,
            _pDLLFactoryData[dw]._pszProgID);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CCOMBaseFactory implementation
CCOMBaseFactory::CCOMBaseFactory(const CFactoryData* pFactoryData) : _cRef(1),
    _pFactoryData(pFactoryData)
{}

//static
BOOL CCOMBaseFactory::_IsLocked()
{
    // Always need to be called from within Critical Section

    return (_cServerLocks > 0);
}

//static
HRESULT CCOMBaseFactory::_CanUnloadNow()
{
    HRESULT hres = S_OK;

    // Always need to be called from within Critical Section

    if (_IsLocked())
    {
        hres = S_FALSE;
    }
    else
    {
        if (_cComponents)
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

//static
HRESULT CCOMBaseFactory::_CheckForUnload()
{
    // Always need to be called from within Critical Section

    if (S_OK == _CanUnloadNow())
    {
        ::PostThreadMessage(_dwThreadID, WM_QUIT, 0, 0);
    }

    return S_OK;
}

//static
HRESULT CCOMBaseFactory::_LockServer(BOOL fLock)
{
    HRESULT hres = S_OK;

    EnterCriticalSection(&_cs);

    if (fLock) 
    {
        ++_cServerLocks;
    }
    else
    {
        --_cServerLocks;

        hres = _CheckForUnload();
    }

    LeaveCriticalSection(&_cs);

    return hres;
}

//static
void CCOMBaseFactory::_COMFactoryCB(BOOL fIncrement)
{
    EnterCriticalSection(&_cs);

    if (fIncrement) 
    {
        ++_cComponents;
    }
    else
    {
        --_cComponents;
        _CheckForUnload();
    }

    LeaveCriticalSection(&_cs);
}

///////////////////////////////////////////////////////////////////////////////
// 
// static
HRESULT CCOMBaseFactory::_GetClassObject(REFCLSID rclsid, REFIID riid,
    void** ppv)
{
    HRESULT hres = S_OK;

    ASSERT(_fCritSectInit);

    if ((riid != IID_IUnknown) && (riid != IID_IClassFactory))
    {
        hres = E_NOINTERFACE;
    }
    else
    {
        hres = CLASS_E_CLASSNOTAVAILABLE;

        // Traverse the array of data looking for this class ID.
        for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
        {
            const CFactoryData* pData = &_pDLLFactoryData[dw];

            if (pData->IsClassID(rclsid) && pData->IsInprocServer())
            {
                // Found the ClassID in the array of components we can
                // create.  So create a class factory for this component.
                // Pass the CDLLFactoryData structure to the class factory
                // so that it knows what kind of components to create.
                *ppv = (IUnknown*) new CCOMBaseFactory(pData);

                if (*ppv == NULL)
                {
                    hres = E_OUTOFMEMORY;
                }
                else
                {
                    hres = S_OK;
                }

                break;
            }
        }
    }

    return hres;
}

//static
BOOL CCOMBaseFactory::_ProcessConsoleCmdLineParams(int argc, wchar_t* argv[],
    BOOL* pfRun, BOOL* pfEmbedded)
{
    _dwThreadID = GetCurrentThreadId();

    if (argc > 1)
    {
        if (!lstrcmpi(argv[1], TEXT("-i")) ||
            !lstrcmpi(argv[1], TEXT("/i")))
        {
            CCOMBaseFactory::_RegisterAll();

            *pfRun = FALSE;
        }
        else
        {
            if (!lstrcmpi(argv[1], TEXT("-u")) ||
                !lstrcmpi(argv[1], TEXT("/u")))
            {
                CCOMBaseFactory::_UnregisterAll();

                *pfRun = FALSE;
            }
            else
            {
                if (!lstrcmpi(argv[1], TEXT("-Embedding")) ||
                    !lstrcmpi(argv[1], TEXT("/Embedding")))
                {
                    *pfRun = TRUE;
                    *pfEmbedded = TRUE;
                }
            }
        }
    }
    else
    {
        *pfEmbedded = FALSE;
        *pfRun = TRUE;
    }

    return TRUE;
}

//static
BOOL CCOMBaseFactory::_RegisterFactories(BOOL fEmbedded)
{
    HRESULT hres = S_OK;
    
    if (!_fCritSectInit)
    {
        InitializeCriticalSection(&CCOMBaseFactory::_cs);
        _fCritSectInit = TRUE;
    }

    if (!fEmbedded)
    {
        hres = _LockServer(TRUE);
    }

    _popinfo = (OUTPROCINFO*)LocalAlloc(LPTR, sizeof(OUTPROCINFO) * _cDLLFactoryData);

    if (_popinfo)
    {
        for (DWORD dw = 0; SUCCEEDED(hres) && (dw < _cDLLFactoryData); ++dw)
        {
            const CFactoryData* pData = &_pDLLFactoryData[dw];

            if (pData->IsLocalServer() || pData->IsLocalService())
            {
                _popinfo[dw]._pfact = NULL ;
                _popinfo[dw]._dwRegister = NULL ;

                IClassFactory* pfact = new CCOMBaseFactory(pData);

                if (pfact)
                {
                    DWORD dwRegister;

                    hres = ::CoRegisterClassObject(*pData->_pCLSID,
                        static_cast<IUnknown*>(pfact), pData->_dwClsContext,
                        pData->_dwFlags, &dwRegister);

                    if (SUCCEEDED(hres))
                    {
                        _popinfo[dw]._pfact = pfact;
                        _popinfo[dw]._dwRegister = dwRegister;
                    }
                    else
                    {
                        pfact->Release();
                    }            
                }
                else
                {
                    hres = E_OUTOFMEMORY;
                }
            }
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return SUCCEEDED(hres);
}

//static
BOOL CCOMBaseFactory::_SuspendFactories()
{
    return SUCCEEDED(::CoSuspendClassObjects());
}

//static
BOOL CCOMBaseFactory::_ResumeFactories()
{
    return SUCCEEDED(::CoResumeClassObjects());
}

//static
BOOL CCOMBaseFactory::_UnregisterFactories(BOOL fEmbedded)
{
    HRESULT hres = S_OK;

    ASSERT(_popinfo);

    for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
    {
        if (_popinfo[dw]._pfact)
        {
            _popinfo[dw]._pfact->Release();

            HRESULT hresTmp = ::CoRevokeClassObject(_popinfo[dw]._dwRegister);

            if (FAILED(hresTmp) && (S_OK == hres))
            {
                hres = hresTmp;
            }
        }
    }

    if (!fEmbedded)
    {
        HRESULT hresTmp = _LockServer(FALSE);

        if (FAILED(hresTmp) && (S_OK == hres))
        {
            hres = hresTmp;
        }
    }

    return SUCCEEDED(hres);
}

//static
void CCOMBaseFactory::_WaitForAllClientsToGo()
{
    MSG msg;

    while (::GetMessage(&msg, 0, 0, 0))
    {
        ::DispatchMessage(&msg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\rbdebug.cpp ===
#include <objbase.h>

#include "rbdebug.h"

BOOL CRBDebug::_fInited = FALSE;
DWORD CRBDebug::_dwFlags = 0;
DWORD CRBDebug::_dwTraceFlags = 0;
TCHAR* CRBDebug::_pszTraceFile = new TCHAR[MAX_PATH];
TCHAR* CRBDebug::_pszModuleName = new TCHAR[MAX_PATH];
HANDLE CRBDebug::_hfileTraceFile = INVALID_HANDLE_VALUE;
TCHAR* CRBDebug::_pszTracePipe = new TCHAR[MAX_PATH];
TCHAR  CRBDebug::_szFileAndLine[] = {0};
CRITICAL_SECTION CRBDebug::_cs = {0}; 
    
#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT CRBDebug::_InitFile(HKEY hkeyRoot)
{
    HRESULT hres = E_FAIL;
    HKEY hkeyFile;

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyRoot, TEXT("File"), 0,
        MAXIMUM_ALLOWED, &hkeyFile))
    {
        DWORD dwSize = MAX_PATH * sizeof(TCHAR);

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyFile, TEXT("FileName"),
            0, NULL, (PBYTE)_pszTraceFile, &dwSize))
        {
            _hfileTraceFile = CreateFile(_pszTraceFile,
                GENERIC_WRITE, FILE_SHARE_READ, NULL,
                OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

            if (INVALID_HANDLE_VALUE != _hfileTraceFile)
            {
                SetFilePointer(_hfileTraceFile, 0, 0,
                    FILE_END);

                hres = S_OK;
            }
        }

        RegCloseKey(hkeyFile);
    }

    return hres;
}

HRESULT CRBDebug::_InitPipe(HKEY hkeyRoot)
{
    HRESULT hres = S_OK;
    HKEY hkeyFile;
    TCHAR szMachineName[MAX_PATH];
    TCHAR szPipeName[MAX_PATH];

    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyRoot, TEXT("Pipe"), 0,
        MAXIMUM_ALLOWED, &hkeyFile))
    {
        DWORD dwSize = sizeof(szMachineName);

        if (ERROR_SUCCESS != RegQueryValueEx(hkeyFile, TEXT("MachineName"),
            0, NULL, (PBYTE)szMachineName, &dwSize))
        {
            lstrcpy(szMachineName, TEXT("."));
        }

        dwSize = sizeof(szPipeName);

        if (ERROR_SUCCESS != RegQueryValueEx(hkeyFile, TEXT("PipeName"),
            0, NULL, (PBYTE)szPipeName, &dwSize))
        {
            lstrcpy(szPipeName, _pszModuleName);
        }

        RegCloseKey(hkeyFile);
    }
    else
    {
        // Defaults
        lstrcpy(szMachineName, TEXT("."));
        lstrcpy(szPipeName, _pszModuleName);
    }

    wsprintf(_pszTracePipe, TEXT("\\\\%s\\pipe\\%s"), szMachineName, szPipeName);

    return hres;
}

// static
HRESULT CRBDebug::_Init()
{
    HRESULT hres = S_FALSE;

    if (!_fInited)
    {
        // Read the flags
        WCHAR szKey[MAX_PATH];
        WCHAR szModule[MAX_PATH];
        BOOL fKeyExist = FALSE;

        hres = E_FAIL;

        InitializeCriticalSection(&_cs);

        lstrcpy(szKey, L"Software\\Microsoft\\Debug\\");

        if (GetModuleFileName(GetModuleHandle(NULL), szModule, MAX_PATH))
        {
            HKEY hkey;
            LONG lSuccess;
            int c = lstrlen(szModule);

            while (c && (L'\\' != szModule[c]))
            {
                --c;
            }

            lstrcpy(_pszModuleName, szModule + c + 1);
            lstrcat(szKey, _pszModuleName);

            lSuccess = RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0,
                MAXIMUM_ALLOWED, &hkey);

            if (ERROR_SUCCESS != lSuccess)
            {
                lSuccess = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0,
                    MAXIMUM_ALLOWED, &hkey);
            }

            if (ERROR_SUCCESS == lSuccess)
            {
                DWORD dwSize = sizeof(DWORD);
    
                fKeyExist = TRUE;

                if (ERROR_SUCCESS == RegQueryValueEx(hkey, L"RBD_FLAGS", 0,
                    NULL, (PBYTE)&_dwFlags, &dwSize))
                {
                    if (_dwFlags & RBD_TRACE_OUTPUTDEBUG)
                    {
                        hres = S_OK;
                    }

                    if ((_dwFlags & RBD_TRACE_TOFILE) ||
                        (_dwFlags & RBD_TRACE_TOFILEANSI))
                    {
                        hres = _InitFile(hkey);

                        if (FAILED(hres))
                        {
                            _dwFlags &= ~RBD_TRACE_TOFILE;
                        }
                    }

                    if (_dwFlags & RBD_TRACE_TOPIPE)
                    {
                        hres = _InitPipe(hkey);

                        if (FAILED(hres))
                        {
                            _dwFlags &= ~RBD_TRACE_TOPIPE;
                        }
                    }
                }
                else
                {
                    _dwFlags = RBD_TRACE_OUTPUTDEBUG | RBD_ASSERT_STOP;

                    hres = S_FALSE;
                }

                if (ERROR_SUCCESS != RegQueryValueEx(hkey, L"TRACE_FLAGS", 0,
                    NULL, (PBYTE)&_dwTraceFlags, &dwSize))
                {
                    // Default...
                    _dwTraceFlags = 0;
                }

                RegCloseKey(hkey);
            }
        }

        if (!fKeyExist)
        {
            // If we can't find a key for this app then we revert to default
            // behavior
            _dwFlags = RBD_TRACE_OUTPUTDEBUG | RBD_ASSERT_STOP;

            hres = S_FALSE;
        }

        if (SUCCEEDED(hres))
        {    
            _fInited = TRUE;
        }
    }

    return hres;
}

// static
void __cdecl CRBDebug::TraceMsg(DWORD dwFlags, LPTSTR pszMsg, ...)
{
    HRESULT hres = S_OK;

    if (!_fInited)
    {
        hres = _Init();
    }

    if (SUCCEEDED(hres))
    {
        if ((_dwTraceFlags & dwFlags) &&
            (TF_NOFILEANDLINE != (_dwTraceFlags & dwFlags)))
        {
            if (!((_dwTraceFlags & TF_NOFILEANDLINE) ||
                (dwFlags & TF_NOFILEANDLINE)))
            {
                // File and line
                _Trace(_szFileAndLine);
            }
            {
                TCHAR szBuf[4096];
                va_list vArgs;

                va_start(vArgs, pszMsg);

                wvsprintf(szBuf, pszMsg, vArgs);

                va_end(vArgs);

                lstrcat(szBuf, TEXT("\r\n"));

                _Trace(szBuf);
            }
        }
    }

    LeaveCriticalSection(&_cs);
}

// static
void CRBDebug::SetTraceFileAndLine(LPCSTR pszFile, const int iLine)
{
    HRESULT hres = S_OK;

    if (!_fInited)
    {
        hres = _Init();
    }

    EnterCriticalSection(&_cs);

    if (SUCCEEDED(hres))
    {
        LPTSTR pszFinal;
        WCHAR szwBuf[MAX_PATH + 12 + 17];
        CHAR szBuf[MAX_PATH + 12 + 17];
        int c = lstrlenA(pszFile);
        LPCSTR pszFileName;
        DWORD dwTimeOffset = 0;

        while (c && ('\\' != *(pszFile + c)))
        {
            --c;
        }

        pszFileName = pszFile + c + 1;

        if (_dwTraceFlags & TF_TIME)
        {
            DWORD dwTick = GetTickCount();
            DWORD dwMilliSec = dwTick % 1000;

            dwTick -= dwMilliSec;
            dwTick /= 1000;
            DWORD dwSec = dwTick % 60;

            dwTick -= dwSec;
            dwTick /= 60;
            DWORD dwMin = dwTick % 60;

            dwTick -= dwMin;
            dwTick /= 60;
            DWORD dwHour = dwTick;

            wsprintfA(szBuf, "{%04d:%02d:%02d.%03d}", dwHour, dwMin, dwSec,
                dwMilliSec);

            dwTimeOffset = 16;
        }

        if (_dwTraceFlags & TF_THREADID)
        {
            wsprintfA(szBuf + dwTimeOffset, "~0x%08X~[%s, %d]",
                GetCurrentThreadId(), pszFileName, iLine);
        }
        else
        {
            wsprintfA(szBuf + dwTimeOffset, "[%s, %d] ", pszFileName, iLine);
        }
#ifdef UNICODE
        pszFinal = szwBuf;

        MultiByteToWideChar(CP_ACP, 0, szBuf, lstrlenA(szBuf) + 1, szwBuf,
            sizeof(szwBuf) / sizeof(WCHAR));
#else
        pszFinal = szBuf;
#endif

        lstrcpyn(_szFileAndLine, pszFinal, ARRAYSIZE(_szFileAndLine));
    }
}

void CRBDebug::_Trace(LPTSTR pszMsg)
{
    if (RBD_TRACE_OUTPUTDEBUG & _dwFlags)
    {
        OutputDebugString(pszMsg);
    }

#ifdef UNICODE
    if (RBD_TRACE_TOFILE & _dwFlags)
#else
    if ((RBD_TRACE_TOFILE & _dwFlags) || (RBD_TRACE_TOFILEANSI & _dwFlags))
#endif
    {
        DWORD dwWritten = 0;

        WriteFile(_hfileTraceFile, pszMsg, lstrlen(pszMsg) * sizeof(TCHAR),
            &dwWritten, NULL);
    }
    else
    {
#ifdef UNICODE
        if (RBD_TRACE_TOFILEANSI & _dwFlags)
        {
            CHAR szBuf[4096];
            DWORD dwWritten = 0;

            WideCharToMultiByte(CP_ACP, 0, pszMsg,
                (lstrlen(pszMsg) + 1) * sizeof(WCHAR), szBuf, sizeof(szBuf), NULL,
                NULL);

            WriteFile(_hfileTraceFile, szBuf, lstrlenA(szBuf), &dwWritten,
                NULL);
        }
#endif
    }

    if (RBD_TRACE_TOPIPE & _dwFlags)
    {
        CallNamedPipe(_pszTracePipe, pszMsg, lstrlen(pszMsg) * sizeof(TCHAR),
            NULL, 0, NULL, NMPWAIT_NOWAIT);
    }
}

// static
HRESULT CRBDebug::Init()
{
    return CRBDebug::_Init();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\regsvr.h ===
#ifndef _REGSVR_H_
#define _REGSVR_H_

#include <objbase.h>

HRESULT RegisterServer(HMODULE hModule, REFCLSID rclsid,
    LPCWSTR pszFriendlyName, LPCWSTR pszVerIndProgID, LPCWSTR pszProgID,
    DWORD dwThreadingModel, BOOL fInprocServer, BOOL fLocalServer,
    BOOL fLocalService, LPCWSTR pszLocalService, const CLSID* pclsidAppID);

HRESULT UnregisterServer(REFCLSID rclsid, LPCWSTR pszVerIndProgID,
    LPCWSTR pszProgID);

HRESULT RegisterAppID(const CLSID* pclsidAppID);

#endif //_REGSVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\namellst.cpp ===
#include "namellst.h"

#include "sfstr.h"

#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

//=============================================================================
//=============================================================================
//==                          CNamedElem                                     ==
//=============================================================================
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// Public
HRESULT CNamedElem::GetName(LPTSTR psz, DWORD cch, DWORD* pcchRequired)
{
    return SafeStrCpyNReq(psz, _pszElemName, cch, pcchRequired);
}

#ifdef DEBUG
LPCTSTR CNamedElem::DbgGetName()
{
    return _pszElemName;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// Protected
CNamedElem::CNamedElem() : _pszElemName(NULL)
{}

CNamedElem::~CNamedElem()
{
    if (_pszElemName)
    {
        _FreeName();
    }
}

HRESULT CNamedElem::_SetName(LPCTSTR pszElemName)
{
    ASSERT(!_pszElemName);
    HRESULT hres;
    DWORD cch = lstrlen(pszElemName) + 1;

    ASSERT(cch);

    _pszElemName = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));

    if (_pszElemName)
    {
        hres = SafeStrCpyN(_pszElemName, pszElemName, cch);

#ifdef DEBUG
        if (SUCCEEDED(hres))
        {
            _pszRCAddRefName = _pszElemName;
            // __FILE__ and __LINE__ should come from original file
            CRefCounted::_RCCreate(__FILE__, __LINE__);
        }
#endif
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT CNamedElem::_FreeName()
{
    ASSERT(_pszElemName);
    LocalFree((HLOCAL)_pszElemName);
    return S_OK;
}

//=============================================================================
//=============================================================================
//==                          CNamedElemList                                 ==
//=============================================================================
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// Public
HRESULT CNamedElemList::Init(NAMEDELEMCREATEFCT createfct,
    NAMEDELEMGETFILLENUMFCT enumfct)
{
    HRESULT hres;

    _createfct = createfct;
    _enumfct = enumfct;

    _pcs = new CRefCountedCritSect();

    if (_pcs)
    {
        InitializeCriticalSection(_pcs);

        hres = S_OK;
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT CNamedElemList::GetOrAdd(LPCTSTR pszElemName, CNamedElem** ppelem)
{
    HRESULT hres = E_INVALIDARG;

    *ppelem = NULL;

    if (pszElemName)
    {
        CElemSlot* pes;

        EnterCriticalSection(_pcs);

        hres = _GetElemSlot(pszElemName, &pes);

        if (SUCCEEDED(hres))
        {
            if (S_FALSE != hres)
            {
                // Got one
                hres = pes->GetNamedElem(ppelem);

                pes->RCRelease();
            }
            else
            {
                // None found
                hres = _Add(pszElemName, ppelem);

                if (SUCCEEDED(hres))
                {
#ifdef DEBUG
                    TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Added to '%s': '%s'"),
                        _szDebugName, pszElemName);
#endif
                    hres = S_FALSE;
                }
            }
        }

        LeaveCriticalSection(_pcs);
    }

    return hres;
}

HRESULT CNamedElemList::Get(LPCTSTR pszElemName, CNamedElem** ppelem)
{
    HRESULT hres = E_INVALIDARG;

    *ppelem = NULL;

    if (pszElemName)
    {
        CElemSlot* pes;

        EnterCriticalSection(_pcs);

        hres = _GetElemSlot(pszElemName, &pes);

        if (SUCCEEDED(hres))
        {
            if (S_FALSE != hres)
            {
                // Got one
                hres = pes->GetNamedElem(ppelem);

                pes->RCRelease();
            }
        }

        LeaveCriticalSection(_pcs);
    }

    return hres;
}

HRESULT CNamedElemList::Add(LPCTSTR pszElemName, CNamedElem** ppelem)
{
    HRESULT hres = E_INVALIDARG;

    if (pszElemName)
    {
        EnterCriticalSection(_pcs);

        hres = _Add(pszElemName, ppelem);

        LeaveCriticalSection(_pcs);

#ifdef DEBUG
        if (SUCCEEDED(hres))
        {
            TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Added to '%s': '%s'"),
                _szDebugName, pszElemName);
        }
#endif
    }

    return hres;
}

HRESULT CNamedElemList::Remove(LPCTSTR pszElemName)
{
    HRESULT hres = E_INVALIDARG;

    if (pszElemName)
    {
        EnterCriticalSection(_pcs);

        hres = _Remove(pszElemName);

        LeaveCriticalSection(_pcs);

#ifdef DEBUG
        if (SUCCEEDED(hres))
        {
            if (S_FALSE != hres)
            {
                TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Removed from '%s': '%s'"),
                    _szDebugName, pszElemName);
            }
            else
            {
                TRACE(TF_NAMEDELEMLISTMODIF,
                    TEXT("TRIED to remove from '%s': '%s'"),
                    _szDebugName, pszElemName);
            }
        }
#endif
    }

    return hres;
}

HRESULT CNamedElemList::ReEnum()
{
    HRESULT hres = E_FAIL;

    if (_enumfct)
    {
#ifdef DEBUG
        TRACE(TF_NAMEDELEMLISTMODIF, TEXT("ReEnum '%s' beginning"),
            _szDebugName);
#endif
        EnterCriticalSection(_pcs);
    
        hres = _EmptyList();

        if (SUCCEEDED(hres))
        {
            CFillEnum* pfillenum;

            hres = _enumfct(&pfillenum);

            if (SUCCEEDED(hres))
            {
                TCHAR szElemName[MAX_PATH];
                LPTSTR pszElemName = szElemName;
                DWORD cchReq;

                do
                {
                    hres = pfillenum->Next(szElemName, ARRAYSIZE(szElemName),
                        &cchReq);

                    if (S_FALSE != hres)
                    {
                        if (E_BUFFERTOOSMALL == hres)
                        {
                            pszElemName = (LPTSTR)LocalAlloc(LPTR, cchReq *
                                sizeof(TCHAR));

                            if (pszElemName)
                            {
                                hres = pfillenum->Next(pszElemName, cchReq,
                                    &cchReq);
                            }
                            else
                            {
                                hres = E_OUTOFMEMORY;
                            }
                        }

                        if (SUCCEEDED(hres) && (S_FALSE != hres))
                        {
                            hres = _Add(pszElemName, NULL);
							if (FAILED(hres))
                            {
                                // continue enum even if a device is not fully installed
                                hres = S_OK;
                            }


#ifdef DEBUG
                            if (SUCCEEDED(hres))
                            {
                                TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Added to '%s': '%s'"),
                                    _szDebugName, pszElemName);
                            }
#endif
                        }

                        if (pszElemName && (pszElemName != szElemName))
                        {
                            LocalFree((HLOCAL)pszElemName);
                        }
                    }
                }
                while (SUCCEEDED(hres) && (S_FALSE != hres));

                pfillenum->RCRelease();
            }
        }

        LeaveCriticalSection(_pcs);

#ifdef DEBUG
        if (SUCCEEDED(hres))
        {
            TRACE(TF_NAMEDELEMLISTMODIF, TEXT("ReEnumed '%s'"), _szDebugName);
        }
#endif
    }

    return hres;
}

HRESULT CNamedElemList::EmptyList()
{
    HRESULT hres;

    EnterCriticalSection(_pcs);

    hres = _EmptyList();

    LeaveCriticalSection(_pcs);

#ifdef DEBUG
    if (SUCCEEDED(hres))
    {
        TRACE(TF_NAMEDELEMLISTMODIF, TEXT("Emptied '%s'"), _szDebugName);
    }
#endif

    return hres;
}

HRESULT CNamedElemList::GetEnum(CNamedElemEnum** ppenum)
{
    HRESULT hres;

    CNamedElemEnum* penum = new CNamedElemEnum();

    if (penum)
    {
        CElemSlot* pesTail;

        EnterCriticalSection(_pcs);

        hres = _GetTail(&pesTail);

        if (SUCCEEDED(hres))
        {
            hres = penum->_Init(pesTail, _pcs);

            if (SUCCEEDED(hres))
            {
                *ppenum = penum;
            }
            else
            {
                delete penum;
            }

            if (pesTail)
            {
                pesTail->RCRelease();
            }
        }

        LeaveCriticalSection(_pcs);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

CNamedElemList::CNamedElemList() : _pcs(NULL), _pesHead(NULL)
{
#ifdef DEBUG
    _pszRCAddRefName = _szDebugName;
    _szDebugName[0] = 0;
#endif
}

CNamedElemList::~CNamedElemList()
{
    _EmptyList();

    if (_pcs)
    {
        DeleteCriticalSection(_pcs);

        _pcs->RCRelease();
    }
}
///////////////////////////////////////////////////////////////////////////////
// Private
// All these fcts have to be called from within The critical section
HRESULT CNamedElemList::_Add(LPCTSTR pszElemName, CNamedElem** ppelem)
{
    CNamedElem* pelem;
    HRESULT hres = _createfct(&pelem);

    if (SUCCEEDED(hres))
    {
        hres = pelem->Init(pszElemName);

        if (SUCCEEDED(hres))
        {
            CElemSlot* pes = new CElemSlot();

            if (pes)
            {
                // This takes an additionnal ref on pelem
                hres = pes->Init(pelem, NULL, _pesHead);

                if (SUCCEEDED(hres))
                {
                    if (_pesHead)
                    {
                        _pesHead->SetPrev(pes);
                    }

                    _pesHead = pes;
                }
                else
                {
                    pes->RCRelease();
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }

        pelem->RCRelease();

        if (FAILED(hres))
        {
            pelem = NULL;
        }
    }
    
    if (ppelem)
    {
        if (pelem)
        {
            pelem->RCAddRef();
        }

        *ppelem = pelem;
    }

    return hres;
}

HRESULT CNamedElemList::_GetTail(CElemSlot** ppes)
{
    HRESULT hr;
    CElemSlot* pesLastValid = _GetValidHead();
        
    if (pesLastValid)
    {
        CElemSlot* pesOld = pesLastValid;

        while (NULL != (pesLastValid = pesLastValid->GetNextValid()))
        {
            pesOld->RCRelease();

            pesOld = pesLastValid;
        }

        pesLastValid = pesOld;

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    // pesLastValid is already RCAddRef'ed
    *ppes = pesLastValid;

    return hr;
}

HRESULT CNamedElemList::_GetElemSlot(LPCTSTR pszElemName, CElemSlot** ppes)
{
    HRESULT hres = S_FALSE;

    CElemSlot* pes = _GetValidHead();
    CElemSlot* pesOld = pes;

    while (pes && SUCCEEDED(hres) && (S_FALSE == hres))
    {
        CNamedElem* pelem;

        hres = pes->GetNamedElem(&pelem);

        if (SUCCEEDED(hres))
        {
            TCHAR szElemName[MAX_PATH];
            LPTSTR pszElemNameLocal = szElemName;
            DWORD cchReq;

            hres = pelem->GetName(szElemName, ARRAYSIZE(szElemName), &cchReq);

            if (E_BUFFERTOOSMALL == hres)
            {
                pszElemNameLocal = (LPTSTR)LocalAlloc(LPTR, cchReq *
                    sizeof(TCHAR));

                if (pszElemNameLocal)
                {
                    hres = pelem->GetName(pszElemNameLocal, cchReq, &cchReq);
                }
                else
                {
                    hres = E_OUTOFMEMORY;
                }
            }

            pelem->RCRelease();

            if (SUCCEEDED(hres))
            {
                if (!lstrcmpi(pszElemNameLocal, pszElemName))
                {
                    // Found it!
                    pes->RCAddRef();

                    *ppes = pes;

                    hres = S_OK;
                }
                else
                {
                    pes = pes->GetNextValid();

                    hres = S_FALSE;
                }
            }

            if (pszElemNameLocal && (pszElemNameLocal != szElemName))
            {
                LocalFree((HLOCAL)pszElemNameLocal);
            }
        }

        pesOld->RCRelease();
        pesOld = pes;
    }

    return hres;
}

HRESULT CNamedElemList::_Remove(LPCTSTR pszElemName)
{
    ASSERT(pszElemName);
    CElemSlot* pes;

    HRESULT hres = _GetElemSlot(pszElemName, &pes);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        if (pes == _pesHead)
        {
            // New head
            _pesHead = pes->GetNextValid();

            if (_pesHead)
            {
                // We do not keep a ref on the head
                _pesHead->RCRelease();
            }
        }

        hres = pes->Remove();

        // 2: one to balance the _GetElemSlot and one to remove from list
        pes->RCRelease();
        pes->RCRelease();
    }

    return hres;
}

HRESULT CNamedElemList::_EmptyList()
{
    HRESULT hres = S_FALSE;

    CElemSlot* pes = _GetValidHead();

    while (SUCCEEDED(hres) && pes)
    {
        CElemSlot* pesOld = pes;

        hres = pes->Remove();

        pes = pes->GetNextValid();

        pesOld->RCRelease();
    }

    _pesHead = NULL;

    return hres;
}

CElemSlot* CNamedElemList::_GetValidHead()
{
    CElemSlot* pes = _pesHead;

    if (pes)
    {
        if (pes->IsValid())
        {
            pes->RCAddRef();
        }
        else
        {
            pes = pes->GetNextValid();
        }
    }
    
    return pes;
}

#ifdef DEBUG
HRESULT CNamedElemList::InitDebug(LPWSTR pszDebugName)
{
    HRESULT hres = SafeStrCpyN(_szDebugName, pszDebugName,
        ARRAYSIZE(_szDebugName));
    
    if (SUCCEEDED(hres))
    {
        _RCCreate(__FILE__, __LINE__);
    }

    return hres;
}

void CNamedElemList::AssertNoDuplicate()
{
    EnterCriticalSection(_pcs);

    CElemSlot* pes = _GetValidHead();

    while (pes)
    {
        CElemSlot* pesOld = pes;
        CNamedElem* pelem;
        WCHAR szName[1024];

        HRESULT hres = pes->GetNamedElem(&pelem);
        
        if (SUCCEEDED(hres))
        {
            DWORD cchReq;
            hres = pelem->GetName(szName, ARRAYSIZE(szName), &cchReq);

            if (SUCCEEDED(hres))
            {
                CElemSlot* pesIn = pes->GetNextValid();

                while (pesIn)
                {
                    CElemSlot* pesInOld = pesIn;
                    CNamedElem* pelemIn;
                    WCHAR szNameIn[1024];

                    hres = pesIn->GetNamedElem(&pelemIn);
        
                    if (SUCCEEDED(hres))
                    {
                        DWORD cchReqIn;
                        hres = pelemIn->GetName(szNameIn, ARRAYSIZE(szNameIn),
                            &cchReqIn);

                        if (SUCCEEDED(hres))
                        {
                            ASSERT(lstrcmp(szName, szNameIn));
                        }

                        pelemIn->RCRelease();
                    }

                    pesIn = pesIn->GetNextValid();

                    pesInOld->RCRelease();
                }
            }

            pelem->RCRelease();
        }

        pes = pes->GetNextValid();

        pesOld->RCRelease();
    }

    LeaveCriticalSection(_pcs);
}

void CNamedElemList::AssertAllElemsRefCount1()
{
    EnterCriticalSection(_pcs);

    ASSERT(1 == _RCGetRefCount());

    CElemSlot* pes = _GetValidHead();

    while (pes)
    {
        CElemSlot* pesOld = pes;

        // Actually check for 2, since it was just AddRefed
        ASSERT(2 == pes->_RCGetRefCount());

        CNamedElem* pelem;

        HRESULT hres = pes->GetNamedElem(&pelem);
        
        if (SUCCEEDED(hres))
        {
            ASSERT(2 == pelem->_RCGetRefCount());

            pelem->RCRelease();
        }

        pes = pes->GetNextValid();

        pesOld->RCRelease();
    }

    LeaveCriticalSection(_pcs);
}
#endif
//=============================================================================
//=============================================================================
//==                          CNamedElemEnum                                 ==
//=============================================================================
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// Public
HRESULT CNamedElemEnum::Next(CNamedElem** ppelem)
{
    HRESULT hres = S_FALSE;

    EnterCriticalSection(_pcsList);

    if (_pesCurrent)
    {
        CElemSlot* pes = _pesCurrent;

        *ppelem = NULL;

        if (pes)
        {
            if (!_fFirst || !pes->IsValid())
            {
                pes = pes->GetPrevValid();
            }
        }

        if (!_fFirst && _pesCurrent)
        {
            _pesCurrent->RCRelease();
        }

        if (pes)
        {
            hres = pes->GetNamedElem(ppelem);
        }

        _pesCurrent = pes;

        _fFirst = FALSE;
    }

    LeaveCriticalSection(_pcsList);

    return hres;
}

CNamedElemEnum::CNamedElemEnum() : _pesCurrent(NULL), _pcsList(NULL)
{
#ifdef DEBUG
    static TCHAR _szDebugName[] = TEXT("CNamedElemEnum");

    _pszRCAddRefName = _szDebugName;
#endif
}

CNamedElemEnum::~CNamedElemEnum()
{
    if (_pcsList)
    {
        _pcsList->RCRelease();
    }

    if (_pesCurrent)
    {
        _pesCurrent->RCRelease();
    }
}
///////////////////////////////////////////////////////////////////////////////
// Private
HRESULT CNamedElemEnum::_Init(CElemSlot* pesHead, CRefCountedCritSect* pcsList)
{
    pcsList->RCAddRef();

    _pcsList = pcsList;
    _fFirst = TRUE;

    _pesCurrent = pesHead;

    if (_pesCurrent)
    {
        _pesCurrent->RCAddRef();
    }

    return S_OK;
}

//=============================================================================
//=============================================================================
//==                          CElemSlot                                      ==
//=============================================================================
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// Public
HRESULT CElemSlot::Init(CNamedElem* pelem, CElemSlot* pesPrev,
    CElemSlot* pesNext)
{
    _pelem = pelem;
    pelem->RCAddRef();
    
    _fValid = TRUE;
    _pesPrev = pesPrev;
    _pesNext = pesNext;

    return S_OK;
}

HRESULT CElemSlot::Remove()
{
    _fValid = FALSE;
    _pelem->RCRelease();
    _pelem = NULL; 

    return S_OK;
}

HRESULT CElemSlot::GetNamedElem(CNamedElem** ppelem)
{
    ASSERT(_fValid);

    _pelem->RCAddRef();
    *ppelem = _pelem;
    
    return S_OK;
}

void CElemSlot::SetPrev(CElemSlot* pes)
{
    _pesPrev = pes;
}

CElemSlot* CElemSlot::GetNextValid()
{
    CElemSlot* pes = _pesNext;

    while (pes && !pes->IsValid())
    {
        pes = pes->_pesNext;
    }

    if (pes)
    {
        pes->RCAddRef();
    }
    
    return pes;
}

CElemSlot* CElemSlot::GetPrevValid()
{
    CElemSlot* pes = _pesPrev;

    while (pes && !pes->IsValid())
    {
        pes = pes->_pesPrev;
    }

    if (pes)
    {
        pes->RCAddRef();
    }
    
    return pes;
}

BOOL CElemSlot::IsValid()
{
    return _fValid;
}

CElemSlot::CElemSlot() : _fValid(FALSE), _pesPrev(NULL), _pesNext(NULL)
{
#ifdef DEBUG
    static TCHAR _szDebugName[] = TEXT("CElemSlot");

    _pszRCAddRefName = _szDebugName;
#endif
}

CElemSlot::~CElemSlot()
{
    ASSERT(!_fValid);

    if (_pesPrev)
    {
        _pesPrev->_pesNext = _pesNext;
    }

    if (_pesNext)
    {
        _pesNext->_pesPrev = _pesPrev;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\regsvr.cpp ===
#include "regsvr.h"

#include "reg.h"
#include "str.h"
#include "sfstr.h"

#include "factdata.h"

#include <sddl.h>


#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
// Internal helper functions prototypes
LONG _RecursiveDeleteKey(HKEY hKeyParent, LPCWSTR szKeyChild);

///////////////////////////////////////////////////////////////////////////////
// Constants

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39;


///////////////////////////////////////////////////////////////////////////////
// Public function implementation

HRESULT RegisterAppID(const CLSID* pclsidAppID)
{
    WCHAR szAppID[CLSID_STRING_SIZE];
    WCHAR szKey[MAX_KEY] = TEXT("AppID\\");

    HRESULT hres = _StringFromGUID(pclsidAppID, szAppID, ARRAYSIZE(szAppID));
    if (SUCCEEDED(hres))
    {
        hres = SafeStrCatN(szKey, szAppID, ARRAYSIZE(szKey));
        if (SUCCEEDED(hres))
        {
            // Add the CLSID key and the FriendlyName
            HKEY hkey;
            hres= _RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey, NULL);
            if (S_OK == hres)
            {
                hres = _RegSetString(hkey, L"LocalService", L"ShellHWDetection");

                if (SUCCEEDED(hres))
                {
                    PSECURITY_DESCRIPTOR pSD;
                    ULONG cbSD;

                    //
                    // NTRAID#NTBUG9-258937-2001/01/17-jeffreys
                    //
                    // Set the launch permissions to prevent COM from ever
                    // launching the service. The only time we want the service
                    // to launch is at system startup.
                    //
                    // Don't think the owner and group matter, but they must be
                    // present, or COM thinks the security descriptor is invalid.
                    // O:SY --> Owner = LocalSystem
                    // G:BA --> Group = Local Administrators group
                    //
                    // The DACL has a single Deny ACE
                    // D:(D;;1;;;WD) --> Deny COM_RIGHTS_EXECUTE (1) to Everyone (WD)
                    //
                    if (ConvertStringSecurityDescriptorToSecurityDescriptorW(L"O:SYG:BAD:(D;;1;;;WD)", SDDL_REVISION, &pSD, &cbSD))
                    {
                        hres = _RegSetBinary(hkey, L"LaunchPermission", pSD, cbSD);
                        LocalFree(pSD);
                    }
                    else
                    {
                        hres = E_OUTOFMEMORY;
                    }
                }

                RegCloseKey(hkey);
            }
        }
    }
    return hres;
}

// Register the component in the registry.
HRESULT RegisterServer(HMODULE hModule, REFCLSID rclsid,
    LPCWSTR pszFriendlyName, LPCWSTR pszVerIndProgID, LPCWSTR pszProgID,
    DWORD dwThreadingModel, BOOL fInprocServer, BOOL fLocalServer,
    BOOL fLocalService, LPCWSTR pszLocalService, const CLSID* pclsidAppID)
{
    WCHAR szCLSID[CLSID_STRING_SIZE];
    WCHAR szKey[MAX_KEY] = TEXT("CLSID\\");

    HRESULT hres = _StringFromGUID(&rclsid, szCLSID, ARRAYSIZE(szCLSID));
    if (SUCCEEDED(hres))
    {
        LPWSTR pszModel = NULL;
        WCHAR szFree[] = TEXT("Free");
        WCHAR szApartment[] = TEXT("Apartment");
        WCHAR szNeutral[] = TEXT("Neutral");
        WCHAR szBoth[] = TEXT("Both");

        hres = SafeStrCatN(szKey, szCLSID, ARRAYSIZE(szKey));

        // Boring set of operations....
        if (SUCCEEDED(hres))
        {
            // Add the CLSID key and the FriendlyName
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey, NULL, NULL,
                pszFriendlyName);
        }

        if (SUCCEEDED(hres))
        {
            switch (dwThreadingModel)
            {
                case THREADINGMODEL_BOTH:
                    pszModel = szBoth;
                    break;
                case THREADINGMODEL_FREE:
                    pszModel = szFree;
                    break;
                case THREADINGMODEL_APARTMENT:
                    pszModel = szApartment;
                    break;
                case THREADINGMODEL_NEUTRAL:
                    pszModel = szNeutral;
                    break;

                default:
                    hres = E_FAIL;
                    break;
            }
        }

        if (SUCCEEDED(hres))
        {
	        // Add the server filename subkey under the CLSID key.
            if (fInprocServer)
            {
	            WCHAR szModule[MAX_PATH];
	            DWORD dwResult = GetModuleFileName(hModule, szModule,
                    ARRAYSIZE(szModule));

                if (dwResult)
                {
                    // Register as Inproc
                    hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                        TEXT("InprocServer32"), NULL, szModule);

                    if (SUCCEEDED(hres))
                    {
                        hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                            TEXT("InprocServer32"), TEXT("ThreadingModel"),
                            pszModel);
                    }
                }
            }
        }

        if (SUCCEEDED(hres))
        {
	        // Add the server filename subkey under the CLSID key.
            if (fLocalServer)
            {
	            WCHAR szModule[MAX_PATH];
                // Note the NULL as 1st arg.  This way a DLL can register a
                // factory as part of an EXE.  Obviously, if this is done
                // from 2 EXE's, only the last one will win...
	            DWORD dwResult = GetModuleFileName(NULL, szModule,
                    ARRAYSIZE(szModule));

                if (dwResult)
                {
                    // Register as LocalServer
                    hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                        TEXT("LocalServer32"), NULL, szModule);

                    if (SUCCEEDED(hres))
                    {
                        hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                            TEXT("LocalServer32"), TEXT("ThreadingModel"),
                            pszModel);
                    }
                }
            }
        }

        if (SUCCEEDED(hres))
        {
	        // Add the server filename subkey under the CLSID key.
            if (fLocalService)
            {
                // Register as LocalServer
                hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                    TEXT("LocalService"), NULL, pszLocalService);

                if (SUCCEEDED(hres))
                {
                    hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                        TEXT("LocalService"), TEXT("ThreadingModel"),
                        pszModel);
                }

                {
                    // We had this bug for a while that a LocalServer32 key was
                    // also installed
                    // Delete it on upgrade (stephstm: Jun/02/2000)
                    // Remove this code when nobody will upgrade from
                    // builds earlier than 2242
                    WCHAR szKeyLocal[MAX_KEY];

                    SafeStrCpyN(szKeyLocal, szKey, ARRAYSIZE(szKeyLocal));

                    SafeStrCatN(szKeyLocal, TEXT("\\LocalServer32"),
                        ARRAYSIZE(szKeyLocal));

                    _RecursiveDeleteKey(HKEY_CLASSES_ROOT, szKeyLocal);
                }
            }
        }
        
        if (SUCCEEDED(hres))
        {
            // Add the ProgID subkey under the CLSID key.
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                TEXT("ProgID"), NULL, pszProgID);
        }

        if (SUCCEEDED(hres))
        {
	        // Add the version-independent ProgID subkey under CLSID
            // key.
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey,
                TEXT("VersionIndependentProgID"), NULL, pszVerIndProgID);
        }

        if (SUCCEEDED(hres))
        {
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszVerIndProgID,
                NULL, NULL, pszFriendlyName);
        }

        if (SUCCEEDED(hres))
        {
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszVerIndProgID,
                TEXT("CLSID"), NULL, szCLSID);
        }

        if (SUCCEEDED(hres))
        {
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszVerIndProgID,
                TEXT("CurVer"), NULL, pszProgID);
        }

        if (SUCCEEDED(hres))
        {
	        // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszProgID,
                NULL, NULL, pszFriendlyName);
        }

        if (SUCCEEDED(hres))
        {
	        // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT
            hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, pszProgID,
                TEXT("CLSID"), NULL, szCLSID);
        }

        if (SUCCEEDED(hres))
        {
            if (pclsidAppID)
            {
                // do the AppID.

                WCHAR szAppID[CLSID_STRING_SIZE];
                hres = _StringFromGUID(pclsidAppID, szAppID, ARRAYSIZE(szAppID));
                if (SUCCEEDED(hres))
                {
                    hres = _RegSetKeyAndString(HKEY_CLASSES_ROOT, szKey, NULL, TEXT("AppID"), szAppID);
                }

                RegisterAppID(pclsidAppID);
            }
        }
    }
    
    return hres;
}

// Remove the component from the registry.
HRESULT UnregisterServer(REFCLSID rclsid, LPCWSTR pszVerIndProgID,
    LPCWSTR pszProgID)
{
	WCHAR szCLSID[CLSID_STRING_SIZE];
	WCHAR szKey[MAX_KEY] = TEXT("CLSID\\");
   
    HRESULT hres = _StringFromGUID(&rclsid, szCLSID, ARRAYSIZE(szCLSID));

    if (SUCCEEDED(hres))
    {
        SafeStrCatN(szKey, szCLSID, ARRAYSIZE(szKey));

	    // Delete the CLSID Key - CLSID\{...}
	    _RecursiveDeleteKey(HKEY_CLASSES_ROOT, szKey);

	    // Delete the version-independent ProgID Key.
	    _RecursiveDeleteKey(HKEY_CLASSES_ROOT, pszVerIndProgID);

	    // Delete the ProgID key.
	    _RecursiveDeleteKey(HKEY_CLASSES_ROOT, pszProgID);
    }

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Internal helper functions

// Delete a key and all of its descendents.
LONG _RecursiveDeleteKey(HKEY hKeyParent, LPCWSTR pszKeyChild)
{
	HKEY hkeyChild;
	LONG lRes = RegOpenKeyEx(hKeyParent, pszKeyChild, 0, KEY_ALL_ACCESS,
        &hkeyChild);

	if (ERROR_SUCCESS == lRes)
	{
	    // Enumerate all of the decendents of this child.
	    WCHAR szBuffer[MAX_PATH];
	    DWORD dwSize = ARRAYSIZE(szBuffer);

	    while ((ERROR_SUCCESS == lRes) && (S_OK == RegEnumKeyEx(hkeyChild, 0,
            szBuffer, &dwSize, NULL, NULL, NULL, NULL)))
	    {
		    // Delete the decendents of this child.
		    lRes = _RecursiveDeleteKey(hkeyChild, szBuffer);

		    dwSize = ARRAYSIZE(szBuffer);
	    }

	    // Close the child.
	    RegCloseKey(hkeyChild);
    }

    if (ERROR_SUCCESS == lRes)
    {
    	// Delete this child.
        lRes = RegDeleteKey(hKeyParent, pszKeyChild);
    }

	return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\reg.cpp ===
#include "reg.h"

#include "sfstr.h"

#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _RegOpenKey(HKEY hkey, LPCWSTR pszKey, HKEY* phkey)
{
    HRESULT hres;

    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, pszKey, 0, MAXIMUM_ALLOWED, phkey))
    {
        hres = S_OK;
    }
    else
    {
        hres = S_FALSE;
        *phkey = NULL;
    }

    return hres;
}

HRESULT _RegCreateKey(HKEY hkey, LPCWSTR pszKey, HKEY* phkey, DWORD* pdwDisp)
{
    HRESULT hres;

    if (ERROR_SUCCESS == RegCreateKeyEx(hkey, pszKey, 0, 0,
        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, phkey, pdwDisp))
    {
        hres = S_OK;
    }
    else
    {
        hres = S_FALSE;
        *phkey = NULL;
    }

    return hres;
}


HRESULT _RegCloseKey(HKEY hkey)
{
    RegCloseKey(hkey);

    return S_OK;
}

HRESULT _RegQueryType(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwType)
{
    HRESULT hres = S_FALSE;
    HKEY hkeyLocal = hkey;

    *pdwType = 0;

    if (pszSubKey)
    {
        hres = _RegOpenKey(hkey, pszSubKey, &hkeyLocal);
    }
    else
    {
        hres = S_OK;
    }

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyLocal, pszValueName, 0,
            pdwType, NULL, NULL))
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
        }

        if (pszSubKey)
        {
            _RegCloseKey(hkeyLocal);
        }
    }

    return hres;
}

HRESULT _RegQueryDWORD(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pdwValue)
{
    return _RegQueryGeneric(hkey, pszSubKey, pszValueName, (PBYTE)pdwValue,
        sizeof(*pdwValue));
}

HRESULT _RegQueryGeneric(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    PBYTE pbValue, DWORD cbValue)
{
    HRESULT hres = S_FALSE;
    HKEY hkeyLocal = hkey;

    if (pszSubKey)
    {
        hres = _RegOpenKey(hkey, pszSubKey, &hkeyLocal);
    }
    else
    {
        hres = S_OK;
    }

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyLocal, pszValueName, 0, NULL,
            pbValue, &cbValue))
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
        }

        if (pszSubKey)
        {
            _RegCloseKey(hkeyLocal);
        }
    }

    return hres;
}

HRESULT _RegQueryGenericWithType(HKEY hkey, LPCWSTR pszSubKey,
    LPCWSTR pszValueName, DWORD* pdwType, PBYTE pbValue, DWORD cbValue)
{
    HRESULT hres = S_FALSE;
    HKEY hkeyLocal = hkey;

    if (pszSubKey)
    {
        hres = _RegOpenKey(hkey, pszSubKey, &hkeyLocal);
    }
    else
    {
        hres = S_OK;
    }

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyLocal, pszValueName, 0,
            pdwType, pbValue, &cbValue))
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
        }

        if (pszSubKey)
        {
            _RegCloseKey(hkeyLocal);
        }
    }

    return hres;
}

HRESULT _RegDeleteValue(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName)
{
    HRESULT hr = S_FALSE;
    HKEY hkeyLocal = hkey;

    if (pszSubKey)
    {
        hr = _RegOpenKey(hkey, pszSubKey, &hkeyLocal);
    }
    else
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        if (ERROR_SUCCESS == RegDeleteValue(hkeyLocal, pszValueName))
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }

        if (pszSubKey)
        {
            _RegCloseKey(hkeyLocal);
        }
    }

    return hr;
}

HRESULT _RegQueryValueSize(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    DWORD* pcbValue)
{
    HRESULT hres = S_FALSE;
    HKEY hkeyLocal = hkey;

    if (pszSubKey)
    {
        hres = _RegOpenKey(hkey, pszSubKey, &hkeyLocal);
    }
    else
    {
        hres = S_OK;
    }

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyLocal, pszValueName, 0, NULL,
            NULL, pcbValue))
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
        }

        if (pszSubKey)
        {
            _RegCloseKey(hkeyLocal);
        }
    }

    return hres;
}

HRESULT _RegSetGeneric(HKEY hkey, LPCWSTR pszValueName, DWORD dwType,
    PBYTE pbValue, DWORD cbValue)
{
    HRESULT hres = S_FALSE;

    if (ERROR_SUCCESS == RegSetValueEx(hkey, pszValueName, 0, dwType, pbValue,
        cbValue))
    {
        hres = S_OK;
    }

    return hres;
}

HRESULT _RegSetString(HKEY hkey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    DWORD cb = (lstrlen(pszValue) + 1) * sizeof(WCHAR);

    return _RegSetGeneric(hkey, pszValueName, REG_SZ, (PBYTE)pszValue, cb);
}

HRESULT _RegSetDWORD(HKEY hkey, LPCWSTR pszValueName, DWORD dwValue)
{
    return _RegSetGeneric(hkey, pszValueName, REG_DWORD, (PBYTE)&dwValue,
        sizeof(dwValue));
}

HRESULT _RegSetBinary(HKEY hkey, LPCWSTR pszValueName, PVOID pvValue, DWORD cbValue)
{
    return _RegSetGeneric(hkey, pszValueName, REG_BINARY, (LPBYTE)pvValue, cbValue);
}

HRESULT _RegQueryString(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValueName,
    LPWSTR pszValue, DWORD cchValue)
{
    DWORD cb = cchValue * sizeof(WCHAR);

    return _RegQueryGeneric(hkey, pszSubKey, pszValueName, (PBYTE)pszValue,
        cb);
}

HRESULT _RegEnumStringValue(HKEY hkey, DWORD dwIndex, LPWSTR pszValue,
    DWORD cchValue)
{
    HRESULT hres = S_FALSE;
    LONG lRes;

    if (ERROR_SUCCESS == (lRes = RegEnumValue(hkey, dwIndex, pszValue,
        &cchValue, 0, 0, 0, 0)))
    {
        hres = S_OK;
    }
    else
    {
        if ((ERROR_SUCCESS != lRes) && (ERROR_NO_MORE_ITEMS != lRes))
        {
            hres = E_FAIL;
        }
    }

    return hres;
}

HRESULT _RegEnumStringKey(HKEY hkey, DWORD dwIndex, LPWSTR pszKey,
    DWORD cchKey)
{
    HRESULT hres = S_FALSE;
    LONG lRes;

    if (ERROR_SUCCESS == (lRes = RegEnumKeyEx(hkey, dwIndex, pszKey,
        &cchKey, NULL, NULL, NULL, NULL)))
    {
        hres = S_OK;
    }
    else
    {
        if (ERROR_NO_MORE_ITEMS != lRes)
        {
            hres = E_FAIL;
        }
    }

    return hres;
}

HRESULT _RegSetKeyAndString(HKEY hkey, LPCWSTR pszKey, LPCWSTR pszSubkey,
    LPCWSTR pszValueName, LPCWSTR pszValue)
{
    ASSERT(pszKey && *pszKey);

    WCHAR szKeyBuf[MAX_KEY];
    LPWSTR pszNext;
    DWORD cchLeft;
    HRESULT hres = SafeStrCpyNEx(szKeyBuf, pszKey, ARRAYSIZE(szKeyBuf),
        &pszNext, &cchLeft);

    if (SUCCEEDED(hres))
    {
        HKEY hkeyNew;

	    if (pszSubkey)
	    {
            hres = SafeStrCpyNEx(pszNext, TEXT("\\"), cchLeft, &pszNext,
                &cchLeft);

            if (SUCCEEDED(hres))
            {
                hres = SafeStrCpyNEx(pszNext, pszSubkey, cchLeft, &pszNext,
                    &cchLeft);
            }
	    }

        if (SUCCEEDED(hres))
        {
	        // Create and open key and subkey.
	        hres= _RegCreateKey(hkey, szKeyBuf, &hkeyNew, NULL);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
	            if (pszValue)
	            {
                    hres = _RegSetString(hkeyNew, pszValueName, pszValue);
	            }

	            RegCloseKey(hkeyNew);
            }
        }
    }

	return hres;
}

HRESULT _RegSubkeyExists(HKEY hkey, LPCWSTR pszPath, LPCWSTR pszSubkey)
{
	WCHAR szKeyBuf[MAX_PATH];
    LPWSTR pszNext;
    DWORD cchLeft;

	// Copy keyname into buffer.
	HRESULT hres = SafeStrCpyNEx(szKeyBuf, pszPath, ARRAYSIZE(szKeyBuf),
        &pszNext, &cchLeft);

    if (SUCCEEDED(hres))
    {
	    HKEY hkey2;

	    if (pszSubkey)
	    {
		    hres = SafeStrCpyNEx(pszNext, TEXT("\\"),  cchLeft, &pszNext,
                &cchLeft);

            if (SUCCEEDED(hres))
            {
		        hres = SafeStrCpyNEx(pszNext, pszSubkey,  cchLeft, &pszNext,
                    &cchLeft);
            }
	    }

        if (SUCCEEDED(hres))
        {
	        // Determine if key exists by trying to open it.
	        hres = _RegOpenKey(hkey, szKeyBuf, &hkey2);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
    		    _RegCloseKey(hkey2);
            }
        }
    }

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\str.cpp ===
#include "str.h"

#include "sfstr.h"

#include "dbg.h"

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _StringFromGUID(const GUID* pguid, LPWSTR psz, DWORD cch)
{
    LPOLESTR pstr;
    HRESULT hres = StringFromCLSID(*pguid, &pstr);

    if (SUCCEEDED(hres))
    {
        // check size of string
        hres = SafeStrCpyN(psz, pstr, cch);

        CoTaskMemFree(pstr);
    }

    return hres;
}

HRESULT _GUIDFromString(LPCWSTR psz, GUID* pguid)
{
    return CLSIDFromString((LPOLESTR)psz, pguid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\sfstr.cpp ===
#include "sfstr.h"

#include "dbg.h"

HRESULT _SafeStrCpyN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest)
{
    ASSERT(pszDest && pszSrc && (cchDest > 0));
    HRESULT hres = E_BUFFERTOOSMALL;

    // Need room for NULL terminator
    --cchDest;

    while (cchDest && *pszSrc)
    {
        *pszDest = *pszSrc;

        ++pszDest;
        ++pszSrc;
        --cchDest;
    }

    // Did we reach the end?
    if (!*pszSrc)
    {
        // Yep
        *pszDest = 0;
        hres = S_OK;
    }
    
    return hres;    
}

HRESULT SafeStrCpyN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && (cchDest > 0))
    {
        hres = _SafeStrCpyN(pszDest, pszSrc, cchDest);
    }

    return hres;
}

HRESULT SafeStrCatN(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && (cchDest > 0))
    {
        LPWSTR psz = pszDest;

        hres = E_BUFFERTOOSMALL;

        while (cchDest && *psz)
        {
            ++psz;
            --cchDest;
        }

        if (cchDest)
        {
            hres = _SafeStrCpyN(psz, pszSrc, cchDest);
        }
    }
    
    return hres;
}

HRESULT _SafeStrCpyNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    ASSERT(pszDest && pszSrc && (cchDest > 0) && ppszEnd && pcchLeft);

    HRESULT hres = E_BUFFERTOOSMALL;

    // Need room for NULL terminator
    --cchDest;

    while (cchDest && *pszSrc)
    {
        *pszDest = *pszSrc;

        ++pszDest;
        ++pszSrc;
        --cchDest;
    }

    // Did we reach the end?
    if (!*pszSrc)
    {
        // Yep
        *pszDest = 0;
        *ppszEnd = pszDest;
        *pcchLeft = (cchDest + 1);

        hres = S_OK;
    }
    
    return hres;
}

HRESULT SafeStrCpyNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && (cchDest > 0) && ppszEnd && pcchLeft)
    {
        hres = _SafeStrCpyNEx(pszDest, pszSrc, cchDest, ppszEnd, pcchLeft);
    }

    return hres;
}

HRESULT SafeStrCatNEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && (cchDest > 0) && ppszEnd && pcchLeft)
    {
        LPWSTR psz = pszDest;

        hres = E_BUFFERTOOSMALL;

        while (cchDest && *psz)
        {
            ++psz;
            --cchDest;
        }

        if (cchDest)
        {
            hres = _SafeStrCpyNEx(psz, pszSrc, cchDest, ppszEnd, pcchLeft);
        }
    }
    
    return hres;
}

HRESULT SafeStrCpyNReq(LPWSTR pszDest, LPWSTR pszSrc, DWORD cchDest,
    DWORD* pcchRequired)
{
    HRESULT hres = E_INVALIDARG;

    if (pszDest && pszSrc && cchDest && pcchRequired)
    {
        hres = SafeStrCpyN(pszDest, pszSrc, cchDest);

        if (E_BUFFERTOOSMALL == hres)
        {
            *pcchRequired = lstrlen(pszSrc) + 1;
        }
        else
        {
            *pcchRequired = 0;
        }
    }

    return hres;
}

HRESULT _SafeStrCpyNExactEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact, LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT((ppszEnd && pcchLeft) || (!ppszEnd && !pcchLeft));

    if (pszDest && pszSrc && (cchDest > 0) && (cchExact > 0))
    {
        // Need room for NULL terminator
        --cchDest;
        --cchExact;

        while (cchDest && cchExact && *pszSrc)
        {
            *pszDest = *pszSrc;

            ++pszDest;
            ++pszSrc;
            --cchDest;
            --cchExact;
        }

        // Did we stop because we copied the Exact # of chars to copy?
        if (!cchExact)
        {
            // Yep, NULL terminate it!
            *pszDest = 0;

            if (ppszEnd)
            {
                *ppszEnd = pszDest;
                *pcchLeft = (cchDest + 1);
            }

            hres = S_OK;
        }
        else
        {
            // Did we stop because we met the end of the sources string before
            // copying cchExact chars?
            if (!*pszSrc)
            {
                // Yes
                hres = E_SOURCEBUFFERTOOSMALL;
            }
            else
            {
                // No
                hres = E_BUFFERTOOSMALL;
            }
        }
    }
    
    return hres;
}

HRESULT SafeStrCpyNExact(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact)
{
    return _SafeStrCpyNExactEx(pszDest, pszSrc, cchDest, cchExact, NULL, NULL);
}

HRESULT SafeStrCpyNExactEx(LPWSTR pszDest, LPCWSTR pszSrc, DWORD cchDest,
    DWORD cchExact, LPWSTR* ppszEnd, DWORD* pcchLeft)
{
    HRESULT hres = E_INVALIDARG;

    if (ppszEnd && pcchLeft)
    {
        hres = _SafeStrCpyNExactEx(pszDest, pszSrc, cchDest, cchExact, ppszEnd,
            pcchLeft);
    }
    
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\lib\users.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <lmaccess.h>
#include <lmapibuf.h>

#include <winsta.h>
#include <dsgetdc.h>

#include <userenv.h>
#include <userenvp.h>

extern "C"
{
#include <syslib.h>
}

#ifdef ASSERT
#undef ASSERT
#endif

#include "users.h"

#include "sfstr.h"
#include "str.h"
#include "mischlpr.h"

#include "dbg.h"
#include "tfids.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT _GetUserHKCU(HANDLE hThreadToken, LPCWSTR pszUserName, HKEY* phkey)
{
    HRESULT hr;
    PROFILEINFO profileinfo = {0};

    *phkey = NULL;

    profileinfo.dwSize     = sizeof(profileinfo);
    profileinfo.dwFlags    = PI_NOUI | PI_LITELOAD;
    profileinfo.lpUserName = (LPWSTR)pszUserName;

    if (LoadUserProfile(hThreadToken, &profileinfo))
    {
        *phkey = (HKEY)(profileinfo.hProfile);
        hr = S_OK;

        TRACE(TF_USERS, TEXT("Loaded user profile"));
    }
    else
    {
        hr = S_FALSE;

        TRACE(TF_USERS,
            TEXT("FAILED to load user profile: GLE = 0x%08X"),
            GetLastError());
    }

    return hr;
}

HRESULT _GetThreadTokenAndUserName(HANDLE* phThreadToken,
    LPWSTR pszUserName, DWORD cchUserName)
{
    HRESULT hr = E_FAIL;

    if (OpenThreadToken(GetCurrentThread(),
        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
        TRUE, phThreadToken))
    {
#ifdef DEBUG
        // For information only
        DWORD dwImp = 0;
        DWORD dwBytesReturned;

        if (GetTokenInformation(*phThreadToken, TokenImpersonationLevel,
            &dwImp, sizeof(DWORD), &dwBytesReturned))
        {
            switch (dwImp)
            {
                case SecurityAnonymous:
                    TRACE(TF_USERS, TEXT("SecurityAnonymous"));
                    break;

                case SecurityIdentification:
                    TRACE(TF_USERS, TEXT("SecurityIdentification"));
                    break;

                case SecurityImpersonation:
                    TRACE(TF_USERS, TEXT("SecurityImpersonation"));
                    break;

                case SecurityDelegation:
                    TRACE(TF_USERS, TEXT("SecurityDelegation"));
                    break;

                default:
                    TRACE(TF_USERS, TEXT("Error. Unable to determine impersonation level"));
                    break;
            }
        }
        else
        {
            TRACE(TF_USERS, TEXT("Unable to read impersonation level"));
        }
#endif
        if (GetUserName(pszUserName, &cchUserName))
        {
            TRACE(TF_USERS, TEXT("UserName: %s"), pszUserName);
            hr = S_OK;
        }
        else
        {
            TRACE(TF_USERS, TEXT("Failed to get username"));
        }
    }
    else
    {
        TRACE(TF_USERS, TEXT("Unable to read thread token (%d)"),
            GetLastError());
    }

    return hr;
}

HRESULT _GetCurrentUserHKCU(HANDLE* phThreadToken, HKEY* phkey)
{
    HRESULT hr = E_INVALIDARG;

    if (phkey && phThreadToken)
    {
        CImpersonateConsoleSessionUser icsu;

        hr = icsu.Impersonate();

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szUserName[UNLEN + 1];

            hr = _GetThreadTokenAndUserName(phThreadToken,
                szUserName, ARRAYSIZE(szUserName));

            icsu.RevertToSelf();

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _GetUserHKCU(*phThreadToken, szUserName, phkey);
            }
        }
        else
        {
            TRACE(TF_USERS, TEXT("WinStationQueryInformation FAILED"));
        }
    }

    if (FAILED(hr) || (S_FALSE == hr))
    {
        TRACE(TF_USERS, TEXT("_GetCurrentUserHKCU FAILED or S_FALSE'D: 0x%08X"), hr);
    }
    else
    {
        TRACE(TF_USERS, TEXT("_GetCurrentUserHKCU SUCCEEDED"));
    }

    return hr;
}

HRESULT _CloseCurrentUserHKCU(HANDLE hThreadToken, HKEY hkey)
{
    UnloadUserProfile(hThreadToken, hkey);

    CloseHandle(hThreadToken);

    return S_OK;
}

HRESULT _CoGetCallingUserHKCU(HANDLE* phThreadToken, HKEY* phkey)
{
    HRESULT hr = E_INVALIDARG;

    if (phkey && phThreadToken)
    {
        CImpersonateCOMCaller icc;

        // You must call this before trying to open a thread token!
        hr = icc.Impersonate();
        
        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szUserName[UNLEN + 1];

            hr = _GetThreadTokenAndUserName(phThreadToken,
                szUserName, ARRAYSIZE(szUserName));

            icc.RevertToSelf();

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _GetUserHKCU(*phThreadToken, szUserName, phkey);
            }
        }
        else
        {
            TRACE(TF_USERS, TEXT("CoImpersonateClient failed: 0x%08X"), hr);
        }
    }

    if (FAILED(hr) || (S_FALSE == hr))
    {
        TRACE(TF_USERS, TEXT("_CoGetCallingUserHKCU FAILED or S_FALSE'D: 0x%08X"), hr);
    }
    else
    {
        TRACE(TF_USERS, TEXT("_CoGetCallingUserHKCU SUCCEEDED"));
    }

    return hr;
}

HRESULT _CoCloseCallingUserHKCU(HANDLE hThreadToken, HKEY hkey)
{
    UnloadUserProfile(hThreadToken, hkey);

    CloseHandle(hThreadToken);

    return S_OK;
}

#define SESSION_MONIKER TEXT("Session:Console!clsid:")

HRESULT _CoCreateInstanceInConsoleSession(REFCLSID rclsid, IUnknown* punkOuter,
    DWORD /*dwClsContext*/, REFIID riid, void** ppv)
{
    IBindCtx* pbc;
    HRESULT hr = CreateBindCtx(0, &pbc);

    *ppv = NULL;

    if (SUCCEEDED(hr)) 
    {
        WCHAR szCLSID[39];

        hr = _StringFromGUID(&rclsid, szCLSID, ARRAYSIZE(szCLSID));

        if (SUCCEEDED(hr))
        {
            ULONG ulEaten;
            IMoniker* pmoniker;
            WCHAR szDisplayName[ARRAYSIZE(SESSION_MONIKER) + ARRAYSIZE(szCLSID)] =
                SESSION_MONIKER;

            // We want something like: "Session:Console!clsid:760befd0-5b0b-44d7-957e-969af35ce954"
            szCLSID[ARRAYSIZE(szCLSID) - 2] = 0;

            // Form display name string
            hr = SafeStrCatN(szDisplayName, szCLSID + 1, ARRAYSIZE(szDisplayName));

            if (SUCCEEDED(hr))
            {
                // Parse the name and get a moniker:
                hr = MkParseDisplayName(pbc, szDisplayName, &ulEaten, &pmoniker);

                if (SUCCEEDED(hr))
                {
                    IClassFactory* pcf;

                    hr = pmoniker->BindToObject(pbc, NULL, IID_IClassFactory, (void**)&pcf);

                    if (SUCCEEDED(hr))
                    {
                        hr = pcf->CreateInstance(punkOuter, riid, ppv);

                        TRACE(TF_USERS,
                            TEXT("pcf->CreateInstance returned: hr = 0x%08X"), hr);

                        pcf->Release();
                    }
                    else
                    {
                        TRACE(TF_USERS, TEXT("pmoniker->BindToObject returned: hr = 0x%08X"), hr);
                    }

                    pmoniker->Release();
                }
            }
        }
        else
        {
            TRACE(TF_USERS, TEXT("MkParseDisplayName returned: hr = 0x%08X"), hr);
        }

        pbc->Release();
    }
    else
    {
        TRACE(TF_USERS, TEXT("CreateBindCtxt returned: hr = 0x%08X"), hr);
    }

    return hr;
}

HRESULT CImpersonateTokenBased::Impersonate()
{
    HRESULT hr = S_FALSE;

    if (!_hToken)
    {
        hr = _GetToken(&_hToken);
    }

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        if (ImpersonateLoggedOnUser(_hToken))
        {
            hr = S_OK;
        }
        else
        {
            TRACE(TF_USERS, TEXT("Impersonate FAILED"));
        }
    }

    return hr;
}

HRESULT CImpersonateTokenBased::RevertToSelf()
{
    return _RevertToSelf();
}

HRESULT CImpersonateTokenBased::_RevertToSelf()
{
    if (_hToken)
    {
        ::RevertToSelf();
        CloseHandle(_hToken);
        _hToken = NULL;
    }

    return S_OK;
}

CImpersonateTokenBased::CImpersonateTokenBased()
{
    _hToken = NULL;
}

CImpersonateTokenBased::~CImpersonateTokenBased()
{
    _RevertToSelf();
}

HRESULT CImpersonateConsoleSessionUser::_GetToken(HANDLE* phToken)
{
    HRESULT hr;
    ULONG ulReturnLength;
    WINSTATIONUSERTOKEN wsUserToken = {0};

    // Yep, the next casts are intentional...
    wsUserToken.ProcessId = (HANDLE)(DWORD_PTR)GetCurrentProcessId();
    wsUserToken.ThreadId = (HANDLE)(DWORD_PTR)GetCurrentThreadId();
    wsUserToken.UserToken = NULL;

    BOOL fActiveConsole = WinStationQueryInformation(SERVERNAME_CURRENT,
        USER_SHARED_DATA->ActiveConsoleId, WinStationUserToken,
        &wsUserToken, sizeof(wsUserToken), &ulReturnLength);

    if (fActiveConsole)
    {
        *phToken = wsUserToken.UserToken;
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CImpersonateEveryone::_GetToken(HANDLE* phToken)
{
    HRESULT hr = S_FALSE;

    PSID gAdminSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
 
    NTSTATUS ntstatus = RtlAllocateAndInitializeSid(
            &NtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &gAdminSid);

    if (NT_SUCCESS(ntstatus))
    {
        HANDLE hTokenProcess;

        ntstatus = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_ALL_ACCESS,
                        &hTokenProcess);

        if (NT_SUCCESS(ntstatus))
        {
            TOKEN_GROUPS TokenGroups = {0};

            TokenGroups.GroupCount = 1 ;
            TokenGroups.Groups[0].Attributes = 0 ;
            TokenGroups.Groups[0].Sid = gAdminSid ;

            ntstatus = NtFilterToken(
                        hTokenProcess,
                        DISABLE_MAX_PRIVILEGE,
                        &TokenGroups,
                        NULL,
                        NULL,
                        phToken);

            NtClose(hTokenProcess);

            hr = S_OK;
        }

        RtlFreeSid(gAdminSid);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CImpersonateCOMCaller::Impersonate()
{
    HRESULT hr = CoImpersonateClient();

    if (SUCCEEDED(hr))
    {
        _fImpersonating = TRUE;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CImpersonateCOMCaller::RevertToSelf()
{
    return _RevertToSelf();
}

HRESULT CImpersonateCOMCaller::_RevertToSelf()
{
    if (_fImpersonating)
    {
        CoRevertToSelf();
        _fImpersonating = FALSE;
    }

    return S_OK;
}

CImpersonateCOMCaller::CImpersonateCOMCaller() : _fImpersonating(FALSE)
{}

CImpersonateCOMCaller::~CImpersonateCOMCaller()
{
    _RevertToSelf();
}

HRESULT _GiveAllowForegroundToConsoleShell()
{
    HANDLE hImpersonationToken;
    DWORD dwSessionID = USER_SHARED_DATA->ActiveConsoleId;

    if (GetWinStationUserToken(dwSessionID, &hImpersonationToken))
    {
        HANDLE hUserToken;

        if (DuplicateTokenEx(hImpersonationToken, 0, NULL,
            SecurityImpersonation, TokenPrimary, &hUserToken))
        {
            STARTUPINFO StartupInfo = {0};
            PROCESS_INFORMATION ProcessInfo = {0};
            WCHAR szCommand[] = TEXT("rundll32.exe shell32.dll,Activate_RunDLL");

            StartupInfo.cb = sizeof(StartupInfo);
            StartupInfo.wShowWindow = SW_SHOW;
            StartupInfo.lpDesktop = L"WinSta0\\Default";

            if (CreateProcessAsUser(hUserToken, NULL, szCommand,
                NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL,
                &StartupInfo, &ProcessInfo))
            {
                CloseHandle(ProcessInfo.hProcess);
                CloseHandle(ProcessInfo.hThread);
            }

            CloseHandle(hUserToken);
        }

        CloseHandle(hImpersonationToken);
    }
 
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\cstmprop.h ===
///////////////////////////////////////////////////////////////////////////////
// HWDeviceCustomProperties
///////////////////////////////////////////////////////////////////////////////
#ifndef _CSTMPROP_H
#define _CSTMPROP_H

#include "unk.h"

#include <shpriv.h>

//extern const CLSID CLSID_HWDeviceCustomProperties;

class CHWDeviceCustomPropertiesImpl : public CCOMBase,
    public IHWDeviceCustomProperties
{
public:
    // Interface IHWDeviceCustomProperties
    STDMETHODIMP InitFromDeviceID(LPCWSTR pszDeviceID, DWORD dwFlags);
    STDMETHODIMP InitFromDevNode(LPCWSTR pszDevNode, DWORD dwFlags);

    STDMETHODIMP GetDWORDProperty(LPCWSTR pszPropName, DWORD* pdwProp);

    STDMETHODIMP GetStringProperty(LPCWSTR pszPropName, LPWSTR* ppszProp);

    STDMETHODIMP GetMultiStringProperty(LPCWSTR pszPropName,
        BOOL fMergeMultiSz, WORD_BLOB** ppblob);

    STDMETHODIMP GetBlobProperty(LPCWSTR pszPropName, BYTE_BLOB** ppblob);

public:
    CHWDeviceCustomPropertiesImpl();
    ~CHWDeviceCustomPropertiesImpl();

private:
    class CHWDeviceInst*    _phwdevinst;
    class CNamedElem*       _pelemToRelease;
    DWORD                   _dwFlags;
    BOOL                    _fInited;
};

typedef CUnkTmpl<CHWDeviceCustomPropertiesImpl> CHWDeviceCustomProperties;

#endif // _CSTMPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\pipeclnt\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <io.h>
#include <objbase.h>

#ifndef UNICODE
#error This has to be UNICODE
#endif

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

int Do(int argc, wchar_t* argv[]);

static BOOL fUnicode = TRUE;
static SECURITY_ATTRIBUTES     _sa = {0};
static ACL*                    _pacl = NULL;
static SID*                    _psidLocalUsers = NULL;
static SECURITY_DESCRIPTOR*    _psd = NULL;

HRESULT _InitSecurityDescriptor();

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    return Do(argc, argv);
}
}

VOID InstanceThread(LPVOID lpvParam) 
{ 
    BYTE bRequest[4096]; 
    DWORD cbBytesRead;
    BOOL fSuccess;
    HANDLE hPipe = (HANDLE)lpvParam; 

/*    EnterCriticalSection(&g_cs);
    
    ++g_cReply;
    cReply = g_cReply;

    LeaveCriticalSection(&g_cs);*/

    fSuccess = ReadFile(hPipe, bRequest, sizeof(bRequest), &cbBytesRead,
        NULL);

    if (fSuccess && cbBytesRead)
    {
//        printf(TEXT("[%08u]"), cReply);

        if (fUnicode)
        {
            wprintf((LPWSTR)bRequest);
        }
        else
        {
            printf((LPSTR)bRequest);
        }
    }

    DisconnectNamedPipe(hPipe); 
    CloseHandle(hPipe); 
} 

int Do(int argc, wchar_t* argv[])
{
    if (argc >= 3)
    {
        TCHAR szPipeName[MAX_PATH];

        wsprintf(szPipeName, TEXT("\\\\%s\\pipe\\%s"), argv[1], argv[2]);

        if (4 == argc)
        {
            if (lstrcmpi(argv[3], TEXT("/a")))
            {
                fUnicode = FALSE;
            }
        }

        // The main loop creates an instance of the named pipe and 
        // then waits for a client to connect to it. When the client 
        // connects, a thread is created to handle communications 
        // with that client, and the loop is repeated.
        do
        { 
            HRESULT hres = _InitSecurityDescriptor();
    
            if (SUCCEEDED(hres))
            {
                HANDLE hPipe = CreateNamedPipe( 
                    szPipeName,             // pipe name 
                    PIPE_ACCESS_DUPLEX,       // read/write access 
                    PIPE_TYPE_MESSAGE |       // message type pipe 
                    PIPE_READMODE_MESSAGE |   // message-read mode 
                    PIPE_WAIT,                // blocking mode 
                    PIPE_UNLIMITED_INSTANCES, // max. instances  
                    256,                      // output buffer size 
                    4096,      // input buffer size 
                    10 * 1000,                // client time-out 
                    &_sa);

                if (hPipe != INVALID_HANDLE_VALUE) 
                {
                    // Wait for the client to connect; if it succeeds, 
                    // the function returns a nonzero value. If the function returns 
                    // zero, GetLastError returns ERROR_PIPE_CONNECTED. 

                    BOOL fConnected = ConnectNamedPipe(hPipe, NULL) ?  TRUE :
                        (GetLastError() == ERROR_PIPE_CONNECTED); 

                    if (fConnected) 
                    { 
                        DWORD dwThreadId; 

                        // Create a thread for this client. 
                        HANDLE hThread = CreateThread( 
                            NULL,              // no security attribute 
                            0,                 // default stack size 
                            (LPTHREAD_START_ROUTINE) InstanceThread, 
                            (LPVOID) hPipe,    // thread parameter 
                            0,                 // not suspended 
                            &dwThreadId);      // returns thread ID 

                        if (hThread) 
                        {
                            BOOL f = CloseHandle(hThread);
                        }
                    } 
                    else
                    {
                        // The client could not connect, so close the pipe. 
                        CloseHandle(hPipe);
                    }
                }
            }
        }
        while (1);
    }
    else
    {
        wprintf(L"\nUsage: \n\n");
        wprintf(L"pipeclnt MachineName PipeName [/a]\n\n");
        wprintf(L"  MachineName: e.g.: stephstm_dev (no leading '\\\\')\n");
        wprintf(L"               Use '.' for local machine\n");
        wprintf(L"  PipeName:    The pipename, usually the debuggee module name\n");
        wprintf(L"  [/a]:        Treat the incoming data as ANSI (default is UNICODE)\n\n");
    }

    return 0;
}

HRESULT _InitSecurityDescriptor()
{
    HRESULT hres;

    if (_pacl)
    {
        hres = S_OK;
    }
    else
    {
        hres = E_FAIL;
        SID_IDENTIFIER_AUTHORITY sidAuthNT = SECURITY_WORLD_SID_AUTHORITY;

        if (AllocateAndInitializeSid(&sidAuthNT, 1, SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0, (void**)&_psidLocalUsers))
        {
            DWORD cbacl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) -
                sizeof(DWORD/*ACCESS_ALLOWED_ACE.SidStart*/) +
                GetLengthSid(_psidLocalUsers);

            _pacl = (ACL*)LocalAlloc(LPTR, cbacl);

            if (_pacl)
            {
                if (InitializeAcl(_pacl, cbacl, ACL_REVISION))
                {
                    if (AddAccessAllowedAce(_pacl, ACL_REVISION, FILE_ALL_ACCESS,
                        _psidLocalUsers))
                    {
                        _psd = (SECURITY_DESCRIPTOR*)LocalAlloc(LPTR,
                            sizeof(SECURITY_DESCRIPTOR));

                        if (_psd)
                        {
                            if (InitializeSecurityDescriptor(_psd,
                                SECURITY_DESCRIPTOR_REVISION))
                            {
                                if (SetSecurityDescriptorDacl(_psd, TRUE,
                                    _pacl, FALSE))
                                {
                                    if (IsValidSecurityDescriptor(_psd))
                                    {
                                        _sa.nLength = sizeof(_sa);
                                        _sa.lpSecurityDescriptor = _psd;
                                        _sa.bInheritHandle = TRUE;

                                        hres = S_OK;
                                    }
                                }
                            }
                        }
                        else
                        {
                            hres = E_OUTOFMEMORY;
                        }
                    }
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }    

        if (FAILED(hres))
        {
            if (_psidLocalUsers)
            {
                FreeSid(_psidLocalUsers);
            }

            if (_pacl)
            {
                LocalFree((HLOCAL)_pacl);
            }

            if (_psd)
            {
                LocalFree((HLOCAL)_psd);
            }
        }
    }
  
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\cstmpropu.cpp ===
#include "cstmprop.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CHWDeviceCustomPropertiesIME[] =
{
    _INTFMAPENTRY(CHWDeviceCustomProperties, IHWDeviceCustomProperties),
};

const INTFMAPENTRY* CHWDeviceCustomProperties::_pintfmap =
    CHWDeviceCustomPropertiesIME;
const DWORD CHWDeviceCustomProperties::_cintfmap =
    (sizeof(CHWDeviceCustomPropertiesIME) /
    sizeof(CHWDeviceCustomPropertiesIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHWDeviceCustomProperties::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\cmmn.h ===
#ifndef _CMMN_H_
#define _CMMN_H_

#include "namellst.h"
#include "mischlpr.h"

#include <objbase.h>
#include <dbt.h>
#include <cfgmgr32.h>
#include <devioctl.h>

#define MAX_SURPRISEREMOVALFN   50

///////////////////////////////////////////////////////////////////////////////
//
extern const GUID guidVolumeClass;
extern const GUID guidDiskClass;
extern const GUID guidCdRomClass;
extern const GUID guidImagingDeviceClass;
extern const GUID guidVideoCameraClass;
extern const GUID guidInvalid;

///////////////////////////////////////////////////////////////////////////////
//
class CHandleNotifTarget
{
public:
    virtual HRESULT HNTHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType) = 0;

    HRESULT HNTInitSurpriseRemoval();
    BOOL HNTIsSurpriseRemovalAware();

    CHandleNotifTarget();
    virtual ~CHandleNotifTarget();
private:
    BOOL                                _fSurpriseRemovalAware;
};

enum HWEDLIST
{
    HWEDLIST_INVALID = -1,
    HWEDLIST_HANDLENOTIF,
    HWEDLIST_VOLUME,
    HWEDLIST_DISK,
    HWEDLIST_MTPT,
    HWEDLIST_MISCDEVINTF,
    HWEDLIST_MISCDEVNODE,
    HWEDLIST_ADVISECLIENT,
    HWEDLIST_COUNT_OF_LISTS, //always last, not a list
};

class CHWEventDetectorHelper
{
public:
    static HRESULT Init();
    static HRESULT Cleanup();

    static void TraceDiagnosticMsg(LPTSTR pszMsg, ...);
    static HRESULT CheckDiagnosticAppPresence();
    static HRESULT SetServiceStatusHandle(SERVICE_STATUS_HANDLE ssh);
    static HRESULT CreateLists();
    static HRESULT DeleteLists();
    static HRESULT FillLists();
    static HRESULT EmptyLists();

    static HRESULT GetList(HWEDLIST hwedlist, CNamedElemList** ppnel);

    static HRESULT RegisterDeviceNotification(PVOID pvNotificationFilter,
        HDEVNOTIFY* phdevnotify, BOOL fAllInterfaceClasses);

    static HRESULT InitDockState();
    static HRESULT DockStateChanged(BOOL* pfDockStateChanged);

    static HRESULT GetImpersonateEveryone(class CImpersonateEveryone** ppieo);

#ifdef DEBUG
public:
    static void _DbgAssertValidState();
#endif

public:
    static BOOL                     _fDiagnosticAppPresent;

private:
    static DWORD                    _dwDiagAppLastCheck;
    static SERVICE_STATUS_HANDLE    _ssh;
    static BOOL                     _fListCreated;
    static CNamedElemList*          _rgpnel[];
    static DWORD                    _cpnel;
    static BOOL                     _fDocked;
    static CImpersonateEveryone*    _pieo;
    static CCriticalSection         _cs;
    static BOOL                     _fInited;
};

///////////////////////////////////////////////////////////////////////////////
//
typedef HRESULT (*INTERFACEENUMFILTERCALLBACK)(LPCWSTR pszDeviceIntfID);

class CIntfFillEnum
{
public:
    HRESULT Next(LPWSTR pszElemName, DWORD cchElemName, DWORD* pcchRequired);
    HRESULT _Init(const GUID* pguidInterface, INTERFACEENUMFILTERCALLBACK iecb);

public:
    CIntfFillEnum();
    ~CIntfFillEnum();

private:
    LPWSTR                          _pszNextInterface;
    LPWSTR                          _pszDeviceInterface;
    INTERFACEENUMFILTERCALLBACK     _iecb;
};

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _DeviceInstIsRemovable(DEVINST devinst, BOOL* pfRemovable);

HANDLE _GetDeviceHandle(LPCTSTR psz, DWORD dwDesiredAccess);
void _CloseDeviceHandle(HANDLE hDevice);

HRESULT _GetDeviceNumberInfoFromHandle(HANDLE h, DEVICE_TYPE* pdevtype,
    ULONG* pulDeviceNumber, ULONG* pulPartitionNumber);

HRESULT _GetVolumeName(LPCWSTR pszDeviceID, LPWSTR pszVolumeName,
    DWORD cchVolumeName);

HRESULT _GetDeviceIDFromMtPtName(LPCWSTR pszMtPt, LPWSTR pszDeviceID,
    DWORD cchDeviceID);

HRESULT _GetDeviceIDFromHDevNotify(HDEVNOTIFY hdevnotify,
    LPWSTR pszDeviceID, DWORD cchDeviceID, DWORD* pcchRequired);

HRESULT _GetDeviceID(LPCWSTR pszName, LPWSTR pszDeviceID,
    DWORD cchDeviceID);

HRESULT _GetHWDeviceInstFromDeviceOrVolumeIntfID(LPCWSTR pszDeviceIntfID,
    class CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease);

HRESULT _GetHWDeviceInstFromVolumeIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease);
HRESULT _GetHWDeviceInstFromDeviceIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease);
HRESULT _GetHWDeviceInstFromDeviceNode(LPCWSTR pszDeviceNode,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease);

HRESULT _GetVolume(LPCWSTR pszVolume, class CVolume** ppvol);

HRESULT _GetAltDeviceID(LPCWSTR pszDeviceID, LPWSTR pszDeviceIDAlt,
    DWORD cchDeviceIDAlt);

HRESULT _CoTaskMemCopy(LPCWSTR pszSrc, LPWSTR* ppszDest);
void _CoTaskMemFree(void* pv);

HRESULT DupString(LPCWSTR pszSrc, LPWSTR* ppszDest);

HRESULT _GetDeviceInstance(LPCWSTR pszDeviceIntfID, DEVINST* pdevinst,
    GUID* pguidInterface);

HRESULT _GetDeviceInstanceFromDevNode(LPCWSTR pszDeviceNode,
    DEVINST* pdevinst);

HRESULT _MachineIsDocked(BOOL* pfDocked);

HRESULT _BuildMoniker(LPCWSTR pszEventHandler, REFCLSID rclsid,
    DWORD dwSessionID, IMoniker** ppmoniker);

///////////////////////////////////////////////////////////////////////////////
//
#define DIAGNOSTIC(__allargs) { if (CHWEventDetectorHelper::_fDiagnosticAppPresent) \
    { CHWEventDetectorHelper::TraceDiagnosticMsg __allargs ; } else \
    { ; } }
    
#endif //_CMMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\cmmn.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT

#include "cmmn.h"

#include <shlwapi.h>

#include "hwdev.h"
#include "hnotif.h"
#include "vol.h"
#include "mtpts.h"
#include "miscdev.h"
#include "drvbase.h"
#include "regnotif.h"
#include "users.h"
#include "logging.h"

#include "sfstr.h"
#include "dbg.h"

#include "tfids.h"

#include <setupapi.h>

#pragma warning(disable: 4201)
#include <winioctl.h>
#pragma warning(default: 4201)

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
const GUID guidVolumeClass =
    {0x53f5630d, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

const GUID guidDiskClass =
    {0x53f56307, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

const GUID guidCdRomClass = 
    {0x53f56308L, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

const GUID guidImagingDeviceClass =
    {0x6bdd1fc6L, 0x810f, 0x11d0,
    {0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f}};

const GUID guidVideoCameraClass =
    {0x6994AD05L, 0x93EF, 0x11D0,
    {0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96}};

const GUID guidInvalid = 
    {0xFFFFFFFFL, 0xFFFF, 0xFFFF,
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};

///////////////////////////////////////////////////////////////////////////////
//
BOOL                    CHWEventDetectorHelper::_fDiagnosticAppPresent = FALSE;
DWORD                   CHWEventDetectorHelper::_dwDiagAppLastCheck = (DWORD)-1;
SERVICE_STATUS_HANDLE   CHWEventDetectorHelper::_ssh = NULL;
BOOL                    CHWEventDetectorHelper::_fListCreated = FALSE;
CNamedElemList*         CHWEventDetectorHelper::
    _rgpnel[HWEDLIST_COUNT_OF_LISTS] = {0};

// For the debugger extension
DWORD                   CHWEventDetectorHelper::_cpnel =
    ARRAYSIZE(CHWEventDetectorHelper::_rgpnel);

BOOL                    CHWEventDetectorHelper::_fDocked = FALSE;
CImpersonateEveryone*   CHWEventDetectorHelper::_pieo = NULL;
CCriticalSection        CHWEventDetectorHelper::_cs;
BOOL                    CHWEventDetectorHelper::_fInited = FALSE;

#ifdef DEBUG
DWORD                   _cDbgDeviceHandle = 0;
#endif
///////////////////////////////////////////////////////////////////////////////
//
HRESULT _DeviceInstIsRemovable(DEVINST devinst, BOOL* pfRemovable)
{
    DWORD dwCap;
    DWORD cbCap = sizeof(dwCap);

    CONFIGRET cr = CM_Get_DevNode_Registry_Property_Ex(devinst,
        CM_DRP_CAPABILITIES, NULL, &dwCap, &cbCap, 0, NULL);

    if (CR_SUCCESS == cr)
    {
        if (CM_DEVCAP_REMOVABLE & dwCap)
        {
            *pfRemovable = TRUE;
        }
        else
        {
            *pfRemovable = FALSE;
        }
    }
    else
    {
        *pfRemovable = FALSE;
    }

    return S_OK;
}

HANDLE _GetDeviceHandle(LPCTSTR psz, DWORD dwDesiredAccess)
{
    HANDLE hDevice = CreateFile(psz, dwDesiredAccess,
       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    
#ifdef DEBUG
    if (INVALID_HANDLE_VALUE != hDevice)
    {
        ++_cDbgDeviceHandle;

        TRACE(TF_LEAK, TEXT("_GetDeviceHandle: %d"), _cDbgDeviceHandle);
    }
#endif

    return hDevice;
}

void _CloseDeviceHandle(HANDLE hDevice)
{
    CloseHandle(hDevice);

#ifdef DEBUG
    if (INVALID_HANDLE_VALUE != hDevice)
    {
        --_cDbgDeviceHandle;

        TRACE(TF_LEAK, TEXT("_CloseDeviceHandle: %d"), _cDbgDeviceHandle);
    }
#endif
}

HRESULT _GetVolumeName(LPCWSTR pszDeviceID, LPWSTR pszVolumeName,
    DWORD cchVolumeName)
{
    WCHAR szDeviceIDWithSlash[MAX_DEVICEID];
    LPWSTR pszNext;
    DWORD cchLeft;

    HRESULT hres = SafeStrCpyNEx(szDeviceIDWithSlash, pszDeviceID,
        ARRAYSIZE(szDeviceIDWithSlash), &pszNext, &cchLeft);

    if (SUCCEEDED(hres))
    {
        hres = SafeStrCpyN(pszNext, TEXT("\\"), cchLeft);

        if (SUCCEEDED(hres))
        {
            if (GetVolumeNameForVolumeMountPoint(szDeviceIDWithSlash,
                pszVolumeName, cchVolumeName))
            {
                hres = S_OK;
            }
            else
            {
                *pszVolumeName = 0;

                hres = S_FALSE;
            }
        }
    }

    return hres;
}

HRESULT _GetHWDeviceInstFromVolumeIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

    *pphwdevinst = NULL;
    *ppelemToRelease = NULL;

    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->Get(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            CVolume* pvol = (CVolume*)pelem;

            hres = pvol->GetHWDeviceInst(pphwdevinst);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                *ppelemToRelease = pelem;
            }
            else
            {
                pelem->RCRelease();
            }
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetHWDeviceInstFromDeviceNode(LPCWSTR pszDeviceNode,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MISCDEVNODE, &pnel);

    *pphwdevinst = NULL;
    *ppelemToRelease = NULL;

    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->GetOrAdd(pszDeviceNode, &pelem);

        if (SUCCEEDED(hres))
        {
            CMiscDeviceNode* pmiscdevnode =
                (CMiscDeviceNode*)pelem;

            hres = pmiscdevnode->GetHWDeviceInst(pphwdevinst);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                *ppelemToRelease = pelem;
            }
            else
            {
                pelem->RCRelease();
            }
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetHWDeviceInstFromDeviceIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MISCDEVINTF, &pnel);

    *pphwdevinst = NULL;
    *ppelemToRelease = NULL;

    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->Get(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            CMiscDeviceInterface* pmiscdevintf =
                (CMiscDeviceInterface*)pelem;

            hres = pmiscdevintf->GetHWDeviceInst(pphwdevinst);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                *ppelemToRelease = pelem;
            }
            else
            {
                pelem->RCRelease();
            }
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetHWDeviceInstFromDeviceOrVolumeIntfID(LPCWSTR pszDeviceIntfID,
    CHWDeviceInst** pphwdevinst, CNamedElem** ppelemToRelease)
{
    HRESULT hres = _GetHWDeviceInstFromVolumeIntfID(pszDeviceIntfID,
        pphwdevinst, ppelemToRelease);

    if (S_FALSE == hres)
    {
        // Not a volume ID, try other devices
        hres = _GetHWDeviceInstFromDeviceIntfID(pszDeviceIntfID,
            pphwdevinst, ppelemToRelease);
    }

    return hres;
}

HRESULT _GetDeviceIDFromMtPtName(LPCWSTR pszMtPt, LPWSTR pszDeviceID,
    DWORD cchDeviceID)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);

    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->Get(pszMtPt, &pelem);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            CMtPt* pmtpt = (CMtPt*)pelem;

            hres = pmtpt->GetVolumeName(pszDeviceID, cchDeviceID);

            pelem->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetDeviceIDFromHDevNotify(HDEVNOTIFY hdevnotify,
    LPWSTR pszDeviceID, DWORD cchDeviceID, DWORD* pcchRequired)
{
    // This should be a drive not a volume.  Cannot get Media arrival/removal
    // from volume.
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_HANDLENOTIF, &pnel);

    if (S_OK == hres)
    {
        CNamedElemEnum* penum;

        hres = pnel->GetEnum(&penum);

        if (SUCCEEDED(hres))
        {
            CNamedElem* pelem;
            BOOL fFoundIt = FALSE;

            while (!fFoundIt && SUCCEEDED(hres = penum->Next(&pelem)) &&
                (S_FALSE != hres))
            {
                CHandleNotif* phnotif = (CHandleNotif*)pelem;

                HDEVNOTIFY hdevnotifyLocal = phnotif->GetDeviceNotifyHandle();

                if (hdevnotifyLocal == hdevnotify)
                {
                    // Found it
                    hres = phnotif->GetName(pszDeviceID, cchDeviceID,
                        pcchRequired);

                    fFoundIt = TRUE;
                }

                pelem->RCRelease();
            }

            penum->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetDeviceID(LPCWSTR pszName, LPWSTR pszDeviceID, DWORD cchDeviceID)
{
    HRESULT hres;

    if (*pszName && (TEXT('\\') == *pszName) &&
        *(pszName + 1) && (TEXT('\\') == *(pszName + 1)) &&
        *(pszName + 2) && (TEXT('?') == *(pszName + 2)))
    {
        hres = SafeStrCpyN(pszDeviceID, pszName, cchDeviceID);
    }
    else
    {
        hres = _GetDeviceIDFromMtPtName(pszName, pszDeviceID, cchDeviceID);
    }

    return hres;
}

HRESULT _GetVolume(LPCWSTR pszVolume, CVolume** ppvol)
{
    WCHAR szDeviceID[MAX_DEVICEID];
    HRESULT hr = _GetDeviceID(pszVolume, szDeviceID, ARRAYSIZE(szDeviceID));

    *ppvol = NULL;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        CNamedElemList* pnel;
        hr = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

        if (S_OK == hr)
        {
            CNamedElem* pelem;
            hr = pnel->Get(szDeviceID, &pelem);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                *ppvol = (CVolume*)pelem;

                // Do not release
            }

            pnel->RCRelease();
        }
    }

    return hr;
}

HRESULT _GetAltDeviceID(LPCWSTR pszDeviceID, LPWSTR pszDeviceIDAlt,
    DWORD cchDeviceIDAlt)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);

    if (S_OK == hres)
    {
        CNamedElemEnum* penum;

        hres = pnel->GetEnum(&penum);

        if (SUCCEEDED(hres))
        {
            BOOL fFoundIt = FALSE;
            CNamedElem* pelem;

            while (!fFoundIt && SUCCEEDED(hres = penum->Next(&pelem)) &&
                (S_FALSE != hres))
            {
                CMtPt* pmtpt = (CMtPt*)pelem;
                WCHAR szDeviceIDVolume[MAX_DEVICEID];

                hres = pmtpt->GetVolumeName(szDeviceIDVolume,
                    ARRAYSIZE(szDeviceIDVolume));

                if (SUCCEEDED(hres))
                {
                    if (!lstrcmp(szDeviceIDVolume, pszDeviceID))
                    {
                        // Use me!
                        DWORD cchReq;
                        fFoundIt = TRUE;

                        hres = pmtpt->GetName(pszDeviceIDAlt,
                            cchDeviceIDAlt, &cchReq);
                    }
                }

                pelem->RCRelease();
            }

            penum->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT _GetDeviceNumberInfoFromHandle(HANDLE hDevice, DEVICE_TYPE* pdevtype,
    ULONG* pulDeviceNumber, ULONG* pulPartitionNumber)
{
    HRESULT hr;
    STORAGE_DEVICE_NUMBER sdn = {0};
    DWORD dwDummy;

    BOOL b = DeviceIoControl(hDevice, IOCTL_STORAGE_GET_DEVICE_NUMBER,
        NULL, 0, &sdn, sizeof(sdn), &dwDummy, NULL);

    if (b)
    {
        *pdevtype = sdn.DeviceType;
        *pulDeviceNumber = sdn.DeviceNumber;
        *pulPartitionNumber = sdn.PartitionNumber;

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _CoTaskMemCopy(LPCWSTR pszSrc, LPWSTR* ppszDest)
{
    HRESULT hres = S_OK;

    *ppszDest = (LPWSTR)CoTaskMemAlloc((lstrlen(pszSrc) + 1) * sizeof(WCHAR));

    if (*ppszDest)
    {
        lstrcpy(*ppszDest, pszSrc);
    }
    else
    {
        *ppszDest = NULL;
        hres  = E_OUTOFMEMORY;
    }

    return hres;
}

void _CoTaskMemFree(void* pv)
{
    if (pv)
    {
        CoTaskMemFree(pv);
    }
}

HRESULT DupString(LPCWSTR pszSrc, LPWSTR* ppszDest)
{
    HRESULT hres;
    *ppszDest = (LPWSTR)LocalAlloc(LPTR, (lstrlen(pszSrc) + 1) *
        sizeof(WCHAR));

    if (*ppszDest)
    {
        lstrcpy(*ppszDest, pszSrc);
        hres = S_OK;
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _GetDeviceInstance(LPCWSTR pszDeviceIntfID, DEVINST* pdevinst,
    GUID* pguidInterface)
{
    HRESULT hres = S_FALSE;

    // not thread safe
    static WCHAR szDeviceIntfIDLast[MAX_DEVICEID] = TEXT("");
    static DEVINST devinstLast;
    static GUID guidInterfaceLast;

    // Cached
    if (!lstrcmpi(szDeviceIntfIDLast, pszDeviceIntfID))
    {
        // Yep
        *pdevinst = devinstLast;
        *pguidInterface = guidInterfaceLast;

        hres = S_OK;
    }
    else
    {
        // No
        HDEVINFO hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

        *pdevinst = NULL;

        if (INVALID_HANDLE_VALUE != hdevinfo)
        {
            SP_DEVICE_INTERFACE_DATA sdid = {0};

            sdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface(hdevinfo, pszDeviceIntfID, 0, &sdid))
            {
                DWORD cbsdidd = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                    (MAX_DEVICE_ID_LEN * sizeof(WCHAR));

                SP_DEVINFO_DATA sdd = {0};
                SP_DEVICE_INTERFACE_DETAIL_DATA* psdidd =
                    (SP_DEVICE_INTERFACE_DETAIL_DATA*)LocalAlloc(LPTR, cbsdidd);

                if (psdidd)
                {
                    psdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                    sdd.cbSize = sizeof(SP_DEVINFO_DATA);

                    // SetupDiGetDeviceInterfaceDetail (below) requires that the
                    // cbSize member of SP_DEVICE_INTERFACE_DETAIL_DATA be set
                    // to the size of the fixed part of the structure, and to pass
                    // the size of the full thing as the 4th param.

                    if (SetupDiGetDeviceInterfaceDetail(hdevinfo, &sdid, psdidd,
                        cbsdidd, NULL, &sdd))
                    {
                        *pdevinst = sdd.DevInst;
                        *pguidInterface = sdid.InterfaceClassGuid;

                        hres = S_OK;
                    }

                    LocalFree((HLOCAL)psdidd);
                }
            }

            SetupDiDestroyDeviceInfoList(hdevinfo);
        }

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            // Cache it
            if (SUCCEEDED(SafeStrCpyN(szDeviceIntfIDLast, pszDeviceIntfID,
                ARRAYSIZE(szDeviceIntfIDLast))))
            {
                devinstLast = *pdevinst;
                guidInterfaceLast = *pguidInterface;
            }
            else
            {
                szDeviceIntfIDLast[0] = 0;
            }
        }
        else
        {
            szDeviceIntfIDLast[0] = 0;
        }
    }

    return hres;
}

HRESULT _GetDeviceInstanceFromDevNode(LPCWSTR pszDeviceNode, DEVINST* pdevinst)
{
    HRESULT hres = S_FALSE;
    HDEVINFO hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    *pdevinst = NULL;

    if (INVALID_HANDLE_VALUE != hdevinfo)
    {
        SP_DEVINFO_DATA sdd = {0};
        sdd.cbSize = sizeof(SP_DEVINFO_DATA);

        if (SetupDiOpenDeviceInfo(hdevinfo, pszDeviceNode, NULL, 0, &sdd))
        {
            *pdevinst = sdd.DevInst;
            hres = S_OK;
        }

        SetupDiDestroyDeviceInfoList(hdevinfo);
    }

    return hres;
}


///////////////////////////////////////////////////////////////////////////////
//
void CHWEventDetectorHelper::TraceDiagnosticMsg(LPWSTR pszMsg, ...)
{
    // Big buffer, but there's no wvsnprintf, and device names can get
    // really big.
    WCHAR szBuf[2048];
    int cch;

    int cch2 = wsprintf(szBuf, TEXT("~0x%08X~"), GetCurrentThreadId());

    va_list vArgs;

    va_start(vArgs, pszMsg);

    cch = wvsprintf(szBuf + cch2, pszMsg, vArgs) + cch2;

    va_end(vArgs);

    if (cch < ARRAYSIZE(szBuf) - 2)
    {
        szBuf[cch] = TEXT('\r');
        szBuf[cch + 1] = TEXT('\n');
        szBuf[cch + 2] = 0;

        cch += 3;
    }

#ifndef FEATURE_USELIVELOGGING
    WriteToLogFileW(szBuf);
#else // FEATURE_USELIVELOGGING
    CallNamedPipe(TEXT("\\\\.\\pipe\\ShellService_Diagnostic"), szBuf,
        cch * sizeof(WCHAR), NULL, 0, NULL, NMPWAIT_NOWAIT);
#endif // FEATURE_USELIVELOGGING
}


//static
HRESULT CHWEventDetectorHelper::CheckDiagnosticAppPresence()
{
    DWORD dwNow = GetTickCount();
    BOOL fPerformCheckNow = FALSE;

    if (dwNow < _dwDiagAppLastCheck)
    {
        // We wrapped, or init case of -1
        fPerformCheckNow = TRUE;
    }
    else
    {
        if (dwNow > (_dwDiagAppLastCheck + 15 * 1000))
        {
            fPerformCheckNow = TRUE;
        }
    }

    if (fPerformCheckNow)
    {
#ifndef FEATURE_USELIVELOGGING
        DWORD dwType;
        DWORD dwUseLogFile = 0;
        DWORD cbSize = sizeof(dwUseLogFile);
        BOOL fReCheck = ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\ShellHWDetection"), TEXT("LogFile"), &dwType, (void *)&dwUseLogFile, &cbSize)) &&
                  (REG_DWORD == dwType) &&
                  (sizeof(dwUseLogFile) == cbSize) &&
                  (0 != dwUseLogFile));
#else // FEATURE_USELIVELOGGING
        HANDLE hEvent = OpenEvent(SYNCHRONIZE, FALSE,
            TEXT("ShellService_Diagnostic"));

        BOOL fReCheck = hEvent;

        CloseHandle(hEvent);
#endif // FEATURE_USELIVELOGGING

        if (fReCheck)
        {
            // Yep, it's there!
            if (!_fDiagnosticAppPresent)
            {
                TRACE(TF_SHHWDTCTDTCT, TEXT("Diagnostic App appeared!"));
            }

            _fDiagnosticAppPresent = TRUE;
        }
        else
        {
            if (_fDiagnosticAppPresent)
            {
                TRACE(TF_SHHWDTCTDTCT, TEXT("Diagnostic App disappeared!"));
            }

            _fDiagnosticAppPresent = FALSE;
        }

        _dwDiagAppLastCheck = dwNow;
    }

    return S_OK;
}

//static
HRESULT CHWEventDetectorHelper::SetServiceStatusHandle(
    SERVICE_STATUS_HANDLE ssh)
{
    _ssh = ssh;

    return S_OK;
}

//static
HRESULT CHWEventDetectorHelper::GetList(HWEDLIST hwedlist,
    CNamedElemList** ppnel)
{
    HRESULT hres;
    CNamedElemList* pnel = _rgpnel[hwedlist];

    if (pnel)
    {
        pnel->RCAddRef();
    }

    *ppnel = pnel;

    hres = *ppnel ? S_OK : E_FAIL;

    if (S_FALSE == hres)
    {
        TRACE(TF_SHHWDTCTDTCT, TEXT("CHWEventDetectorHelper::GetList S_FALSE'd"));
    }

    return hres;
}

//static
HRESULT CHWEventDetectorHelper::DeleteLists()
{
    for (DWORD dw = 0; dw < ARRAYSIZE(_rgpnel); ++dw)
    {
        if (_rgpnel[dw])
        {
            _rgpnel[dw]->EmptyList();

            _rgpnel[dw]->RCRelease();
            _rgpnel[dw] = NULL;
        }
    }

    return S_OK;
}

//static
HRESULT CHWEventDetectorHelper::CreateLists()
{
    HRESULT hres = S_FALSE;

    if (!_fListCreated)
    {
        for (DWORD dw = 0; SUCCEEDED(hres) && (dw < ARRAYSIZE(_rgpnel)); ++dw)
        {
            _rgpnel[dw] = new CNamedElemList();

            if (!_rgpnel[dw])
            {
                hres = E_OUTOFMEMORY;

                // should RCRelease the already allocated ones
            }
        }

        if (SUCCEEDED(hres))
        {
            // Initialize them ALL first
            hres = _rgpnel[HWEDLIST_HANDLENOTIF]->Init(
                CHandleNotif::Create, NULL);

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_VOLUME]->Init(CVolume::Create,
                    CVolume::GetFillEnum);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_DISK]->Init(
                    CDisk::Create, CDisk::GetFillEnum);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_MISCDEVINTF]->Init(
                    CMiscDeviceInterface::Create, NULL);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_MISCDEVNODE]->Init(
                    CMiscDeviceNode::Create, NULL);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_MTPT]->Init(CMtPt::Create, NULL);
            }

            if (SUCCEEDED(hres))
            {
                hres = _rgpnel[HWEDLIST_ADVISECLIENT]->Init(CAdviseClient::Create, NULL);
            }

#ifdef DEBUG
            if (SUCCEEDED(hres))
            {
                _rgpnel[HWEDLIST_HANDLENOTIF]->InitDebug(TEXT("CHandleNotif"));
                _rgpnel[HWEDLIST_VOLUME]->InitDebug(TEXT("CVolume"));
                _rgpnel[HWEDLIST_DISK]->InitDebug(TEXT("CDisk"));
                _rgpnel[HWEDLIST_MISCDEVINTF]->InitDebug(TEXT("CMiscDeviceInterface"));
                _rgpnel[HWEDLIST_MISCDEVNODE]->InitDebug(TEXT("CMiscDeviceNode"));
                _rgpnel[HWEDLIST_MTPT]->InitDebug(TEXT("CMtPt"));
                _rgpnel[HWEDLIST_ADVISECLIENT]->InitDebug(TEXT("CAdviseClient"));                
            }
#endif
            if (SUCCEEDED(hres))
            {
                _fListCreated = TRUE;

                TRACE(TF_SHHWDTCTDTCT, TEXT("CNamedElemList's created"));
            }
        }
    }

    return hres;
}

//static
HRESULT CHWEventDetectorHelper::FillLists()
{
    ASSERT(_fListCreated);

    // Enumerate those having an enumerator
    HRESULT hres = _rgpnel[HWEDLIST_DISK]->ReEnum();

    if (SUCCEEDED(hres))
    {
        hres = _rgpnel[HWEDLIST_VOLUME]->ReEnum();
    }

    return hres;
}

//static
HRESULT CHWEventDetectorHelper::EmptyLists()
{
    for (DWORD dw = 0; dw < HWEDLIST_COUNT_OF_LISTS; ++dw)
    {
        _rgpnel[dw]->EmptyList();
    }

   _fListCreated = FALSE;

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// static 
HRESULT CHWEventDetectorHelper::InitDockState()
{
    BOOL fDocked;
    HRESULT hr = _MachineIsDocked(&fDocked);

    if (SUCCEEDED(hr) && (S_FALSE != hr)) 
    {
        CHWEventDetectorHelper::_fDocked = fDocked;
    }

    return hr;
}

// static 
HRESULT CHWEventDetectorHelper::DockStateChanged(BOOL* pfDockStateChanged)
{
    BOOL fDocked;
    HRESULT hr = _MachineIsDocked(&fDocked);

    if (SUCCEEDED(hr) && (S_FALSE != hr)) 
    {
        if (fDocked != _fDocked)
        {
            *pfDockStateChanged = TRUE;
        }

        // Update it too
        CHWEventDetectorHelper::_fDocked = fDocked;
    }

    return hr;
}

//static
HRESULT CHWEventDetectorHelper::RegisterDeviceNotification(
    PVOID pvNotificationFilter, HDEVNOTIFY* phdevnotify,
    BOOL fAllInterfaceClasses)
{
    HRESULT hres;
    DWORD dwFlags;

    ASSERT(_ssh);

    if (fAllInterfaceClasses)
    {
        dwFlags = DEVICE_NOTIFY_ALL_INTERFACE_CLASSES;
    }
    else
    {
        dwFlags = 0;
    }

    TRACE(TF_SHHWDTCTDTCTDETAILED,
        TEXT("Entered CHWEventDetectorImpl::RegisterDeviceNotification"));

#ifndef DEBUG
    dwFlags |= DEVICE_NOTIFY_SERVICE_HANDLE;

    *phdevnotify = ::RegisterDeviceNotification(_ssh, pvNotificationFilter,
        dwFlags);
#else
    if (IsWindow((HWND)_ssh))
    {
        dwFlags |= DEVICE_NOTIFY_WINDOW_HANDLE;

        *phdevnotify = ::RegisterDeviceNotification(_ssh, pvNotificationFilter,
            dwFlags);
    }
    else
    {
        dwFlags |= DEVICE_NOTIFY_SERVICE_HANDLE;

        *phdevnotify = ::RegisterDeviceNotification(_ssh, pvNotificationFilter,
            dwFlags);
    }
#endif

    if (*phdevnotify)
    {
        TRACE(TF_SHHWDTCTDTCTDETAILED,
            TEXT("RegisterDeviceNotification SUCCEEDED: 0x%08X"),
            *phdevnotify);

        hres = S_OK;
    }
    else
    {
        hres = S_FALSE;
    }    

    return hres;
}

// static
HRESULT CHWEventDetectorHelper::Init()
{
    _cs.Init();

    _fInited = TRUE;

    return S_OK;
}

// static
HRESULT CHWEventDetectorHelper::Cleanup()
{
    _cs.Enter();

    CloseLogFile();

    if (_pieo)
    {
        _pieo->RCRelease();
        _pieo = NULL;
    }

    _fInited = FALSE;

    _cs.Leave();

    _cs.Delete();

    return S_OK;
}

// static
HRESULT CHWEventDetectorHelper::GetImpersonateEveryone(
    CImpersonateEveryone** ppieo)
{
    HRESULT hr;

    *ppieo = NULL;

    if (_fInited)
    {
        _cs.Enter();

        if (!_pieo)
        {
            _pieo = new CImpersonateEveryone();
        }

        if (_pieo)
        {
            _pieo->RCAddRef();

            *ppieo = _pieo;

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        _cs.Leave();
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

#ifdef DEBUG
void CHWEventDetectorHelper::_DbgAssertValidState()
{
    for (DWORD dw = 0; dw < ARRAYSIZE(_rgpnel); ++dw)
    {
        if (_rgpnel[dw])
        {
//          Need to disable this since there is 2 services using this data,
//          and it is now feasible to have a refcount diff than 1 at the end
//          of an operation.
//            _rgpnel[dw]->AssertAllElemsRefCount1();
            _rgpnel[dw]->AssertNoDuplicate();
        }
    }
}
#endif
///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHandleNotifTarget::HNTInitSurpriseRemoval()
{
    _fSurpriseRemovalAware = TRUE;

    return S_OK;
}

BOOL CHandleNotifTarget::HNTIsSurpriseRemovalAware()
{
    return _fSurpriseRemovalAware;
}

CHandleNotifTarget::CHandleNotifTarget() : _fSurpriseRemovalAware(FALSE)
{}

CHandleNotifTarget::~CHandleNotifTarget()
{}
///////////////////////////////////////////////////////////////////////////////
// Interface enumerator
HRESULT CIntfFillEnum::Next(LPWSTR pszElemName, DWORD cchElemName,
    DWORD* pcchRequired)
{
    ASSERT (pszElemName && cchElemName && pcchRequired);
    HRESULT hr = S_FALSE;
    BOOL fFound = FALSE;

    while (SUCCEEDED(hr) && !fFound && _pszNextInterface && *_pszNextInterface)
    {
        // Do we have a filter?
        if (_iecb)
        {
            // Yep
            hr = (_iecb)(_pszNextInterface);
        }
        else
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // Was it filtered out?
            if (S_FALSE != hr)
            {
                // No
                hr = SafeStrCpyNReq(pszElemName, _pszNextInterface,
                    cchElemName, pcchRequired);

                if (SUCCEEDED(hr))
                {
                    fFound = TRUE;

                    _pszNextInterface += lstrlen(_pszNextInterface) + 1;
                }
            }
            else
            {
                // Yes, lopp again
                _pszNextInterface += lstrlen(_pszNextInterface) + 1;
            }
        }
    }

    return hr;
}

HRESULT CIntfFillEnum::_Init(const GUID* pguidInterface,
    INTERFACEENUMFILTERCALLBACK iecb)
{
    HRESULT hr;
    HMACHINE hMachine = NULL;
    ULONG ulSize;
    ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;

    CONFIGRET cr = CM_Get_Device_Interface_List_Size_Ex(&ulSize,
        (GUID*)pguidInterface, NULL, ulFlags, hMachine);

    _iecb = iecb;

    if ((CR_SUCCESS == cr) && (ulSize > 1))
    {
        _pszNextInterface = _pszDeviceInterface =
            (LPTSTR)LocalAlloc(LPTR, ulSize * sizeof(TCHAR));

        if (_pszDeviceInterface)
        {
            cr = CM_Get_Device_Interface_List_Ex((GUID*)pguidInterface, NULL,
                _pszDeviceInterface, ulSize, ulFlags, hMachine);

            if (CR_SUCCESS == cr)
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

CIntfFillEnum::CIntfFillEnum() : _pszDeviceInterface(NULL),
    _pszNextInterface(NULL)
{}

CIntfFillEnum::~CIntfFillEnum()
{
    if (_pszDeviceInterface)
    {
        LocalFree((HLOCAL)_pszDeviceInterface);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _MachineIsDocked(BOOL* pfDocked)
{
    HRESULT hr;
    HW_PROFILE_INFO hpi;

    if (GetCurrentHwProfile(&hpi)) 
    {
        DWORD dwDockInfo = hpi.dwDockInfo &
            (DOCKINFO_DOCKED | DOCKINFO_UNDOCKED);

        if ((DOCKINFO_DOCKED | DOCKINFO_UNDOCKED) == dwDockInfo)
        {
            // Not dockable
            *pfDocked = FALSE;
        }
        else
        {
            *pfDocked = (DOCKINFO_DOCKED & dwDockInfo);

#ifdef DEBUG
            // Make sure we understand how this works
            if (!(*pfDocked))
            {
                ASSERT(DOCKINFO_UNDOCKED & dwDockInfo);
            }
#endif
        }

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
       
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _BuildMoniker(LPCWSTR /*pszEventHandler*/, REFCLSID rclsid,
    DWORD dwSessionID, IMoniker** ppmoniker)
{
    IMoniker* pmonikerClass;
    HRESULT hr = CreateClassMoniker(rclsid, &pmonikerClass);

    *ppmoniker = NULL;

    if (SUCCEEDED(hr))
    {
        IMoniker* pmonikerSession;
        WCHAR szSessionID[30];

        // should be safe
        wsprintf(szSessionID, TEXT("session:%d"), dwSessionID);

        hr = CreateItemMoniker(TEXT("!"), szSessionID, &pmonikerSession);

        if (SUCCEEDED(hr))
        {
            hr = pmonikerClass->ComposeWith(pmonikerSession, FALSE, ppmoniker);

            // Do not Release, we return it!

            pmonikerSession->Release();
        }

        pmonikerClass->Release();
    }

    return hr;
}

EXTERN_C HRESULT WINAPI CreateHardwareEventMoniker(REFCLSID clsid, LPCTSTR pszEventHandler, IMoniker **ppmoniker)
{
    HRESULT hr;

    if (ppmoniker)
    {
        if (pszEventHandler && *pszEventHandler)
        {
            DWORD dwSessionID = NtCurrentPeb()->SessionId;

            hr = _BuildMoniker(pszEventHandler, clsid, dwSessionID, ppmoniker);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\cstmprop.cpp ===
#include "cstmprop.h"

#include "hwdev.h"
#include "dtctreg.h"

#include "svcsync.h"
#include "cmmn.h"

#include "str.h"
#include "misc.h"

#include "tfids.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

STDMETHODIMP CHWDeviceCustomPropertiesImpl::InitFromDeviceID(
    LPCWSTR pszDeviceID, DWORD dwFlags)
{
    HRESULT hr;

    if (pszDeviceID && *pszDeviceID)
    {
        if ((0 == dwFlags) || (HWDEVCUSTOMPROP_USEVOLUMEPROCESSING == dwFlags))
        {
            if (!_fInited)
            {
                CHWEventDetectorHelper::CheckDiagnosticAppPresence();

                _dwFlags = dwFlags;

                if (HWDEVCUSTOMPROP_USEVOLUMEPROCESSING == dwFlags)
                {
                    DIAGNOSTIC((TEXT("[0257]Using HWDEVCUSTOMPROP_USEVOLUMEPROCESSING")));

                    WCHAR szDeviceIDReal[MAX_DEVICEID];

                    hr = _GetDeviceID(pszDeviceID, szDeviceIDReal,
                        ARRAYSIZE(szDeviceIDReal));

                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        DIAGNOSTIC((TEXT("[0258]DeviceID converted from %s to %s"), pszDeviceID, szDeviceIDReal));

                        hr = _GetHWDeviceInstFromVolumeIntfID(szDeviceIDReal,
                            &_phwdevinst, &_pelemToRelease);
                    }
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0258]NOT using HWDEVCUSTOMPROP_USEVOLUMEPROCESSING")));

                    hr = _GetHWDeviceInstFromDeviceIntfID(pszDeviceID,
                        &_phwdevinst, &_pelemToRelease);
                }

                if (SUCCEEDED(hr))
                {
                    if (S_FALSE != hr)
                    {
                        DIAGNOSTIC((TEXT("[0259]Custom Property: Initialization SUCCEEDED")));

                        _fInited = TRUE;
                    }
                    else
                    {
                        DIAGNOSTIC((TEXT("[0260]Custom Property: Initialization FAILED")));
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::InitFromDevNode(
    LPCWSTR pszDevNode, DWORD dwFlags)
{
    HRESULT hr;

    if (pszDevNode && *pszDevNode)
    {
        if ((0 == dwFlags))
        {
            if (!_fInited)
            {
                CHWEventDetectorHelper::CheckDiagnosticAppPresence();

                _dwFlags = dwFlags;

                hr = _GetHWDeviceInstFromDeviceNode(pszDevNode, &_phwdevinst,
                    &_pelemToRelease);

                if (SUCCEEDED(hr))
                {
                    if (S_FALSE != hr)
                    {
                        DIAGNOSTIC((TEXT("[0270]Custom Property: Initialization SUCCEEDED")));

                        _fInited = TRUE;
                    }
                    else
                    {
                        DIAGNOSTIC((TEXT("[0271]Custom Property: Initialization FAILED")));
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::GetDWORDProperty(
    LPCWSTR pszPropName, DWORD* pdwProp)
{
    HRESULT hr;

    if (_fInited)
    {
        *pdwProp = (DWORD)-1;

        if (pszPropName && *pszPropName && pdwProp)
        {
            DWORD dwType;
            DWORD dwProp;

            hr = _GetDevicePropertyGeneric(_phwdevinst, pszPropName,
                FALSE, &dwType, (PBYTE)&dwProp, sizeof(dwProp));

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (REG_DWORD == dwType)
                {
                    DIAGNOSTIC((TEXT("[0261]Found Property: '%s'"), pszPropName));
                    *pdwProp = dwProp;
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0262]Found Property: '%s', but NOT REG_DWORD type"), pszPropName));
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;    
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::GetStringProperty(
    LPCWSTR pszPropName, LPWSTR* ppszProp)
{
    HRESULT hr;

    if (_fInited)
    {
        if (pszPropName && *pszPropName && ppszProp)
        {
            DWORD dwType;

            hr = _GetDevicePropertyStringNoBuf(_phwdevinst, pszPropName,
                FALSE, &dwType, ppszProp);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (dwType != REG_SZ)
                {
                    DIAGNOSTIC((TEXT("[0264]Found Property: '%s', but NOT REG_SZ type"), pszPropName));
                    CoTaskMemFree(*ppszProp);

                    *ppszProp = NULL;
                    hr = E_FAIL;
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0263]Found Property: '%s'"), pszPropName));
                }
            }
            else
            {
                *ppszProp = NULL;
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::GetMultiStringProperty(
    LPCWSTR pszPropName, BOOL fMergeMultiSz, WORD_BLOB** ppblob)
{
    HRESULT hr;

    if (_fInited)
    {
        if (pszPropName && *pszPropName && ppblob)
        {
            hr = _GetDevicePropertyGenericAsMultiSz(_phwdevinst, pszPropName,
                fMergeMultiSz, ppblob);

            if (FAILED(hr) || (S_FALSE == hr))
            {
                *ppblob = NULL;
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

STDMETHODIMP CHWDeviceCustomPropertiesImpl::GetBlobProperty(
    LPCWSTR pszPropName, BYTE_BLOB** ppblob)
{
    HRESULT hr;

    if (_fInited)
    {
        if (pszPropName && *pszPropName && ppblob)
        {
            hr = _GetDevicePropertyGenericAsBlob(_phwdevinst, pszPropName,
                ppblob);

            if (FAILED(hr) || (S_FALSE == hr))
            {
                *ppblob = NULL;
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

CHWDeviceCustomPropertiesImpl::CHWDeviceCustomPropertiesImpl() :
    _fInited(FALSE), _pelemToRelease(NULL), _phwdevinst(NULL), _dwFlags(0)
{
    _CompleteShellHWDetectionInitialization();
}

CHWDeviceCustomPropertiesImpl::~CHWDeviceCustomPropertiesImpl()
{
    if (_pelemToRelease)
    {
        _pelemToRelease->RCRelease();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\devinfo.h ===
///////////////////////////////////////////////////////////////////////////////
// HW Device
///////////////////////////////////////////////////////////////////////////////
#ifndef _DEVINFO_H
#define _DEVINFO_H

#include "unk.h"

#include <shpriv.h>

//extern const CLSID CLSID_HWDevice;

class CHWDeviceImpl : public CCOMBase, public IHWDevice
{
public:
    // Interface IHWDevice
    STDMETHODIMP Init(LPCWSTR pszDeviceID);

    STDMETHODIMP GetDeviceString(DWORD dwType,
        LPWSTR* ppsz);

    STDMETHODIMP GetDeviceEventString(LPCWSTR pszEventType, DWORD dwType,
        LPWSTR* ppsz);

    STDMETHODIMP AutoplayHandler(LPCWSTR pszEventType,
        LPCWSTR pszHandler);

public:
    CHWDeviceImpl();
    ~CHWDeviceImpl();

private:
    LPWSTR          _pszDeviceID;
    BOOL            _fInited;
};

typedef CUnkTmpl<CHWDeviceImpl> CHWDevice;

#endif // _DEVINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\devinfo.cpp ===
#include "devinfo.h"

#include "vol.h"
#include "dtct.h"
#include "dtctreg.h"

#include "svcsync.h"

#include "cmmn.h"
#include "misc.h"

#include "tfids.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

STDMETHODIMP CHWDeviceImpl::Init(LPCWSTR pszDeviceID)
{
    HRESULT hr;

    if (!_fInited)
    {
        if (pszDeviceID && *pszDeviceID)
        {
            hr = DupString(pszDeviceID, &_pszDeviceID);

            if (SUCCEEDED(hr))
            {
                _fInited = TRUE;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        // Cannot reinit
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CHWDeviceImpl::AutoplayHandler(LPCWSTR pszEventType,
    LPCWSTR pszHandler)
{
    return _ExecuteHandler(_pszDeviceID, pszEventType,
        pszHandler);
}

CHWDeviceImpl::CHWDeviceImpl() : _pszDeviceID(NULL), _fInited(FALSE)
{
    _CompleteShellHWDetectionInitialization();
}

CHWDeviceImpl::~CHWDeviceImpl()
{
    if (_pszDeviceID)
    {
        LocalFree(_pszDeviceID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\devinfou.cpp ===
#include "devinfo.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY hwdeviceIME[] =
{
    _INTFMAPENTRY(CHWDevice, IHWDevice),
};

const INTFMAPENTRY* CHWDevice::_pintfmap = hwdeviceIME;
const DWORD CHWDevice::_cintfmap =
    (sizeof(hwdeviceIME)/sizeof(hwdeviceIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHWDevice::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\drvbase.h ===
#ifndef _DRVBASE_H
#define _DRVBASE_H

#include "namellst.h"

#include <objbase.h>
#include <devioctl.h>

class CDisk : public CNamedElem
{
public:
    HRESULT Init(LPCWSTR pszElemName);
    HRESULT GetDeviceNumber(ULONG* puldeviceNumber);
    HRESULT GetDeviceType(DEVICE_TYPE* pdevtype);

protected:
    HRESULT _Init();

protected:
    CDisk();

public:
    static HRESULT Create(CNamedElem** ppelem);
    static HRESULT GetFillEnum(CFillEnum** ppfillenum);

protected:
    DEVICE_TYPE                         _devtype;
    ULONG                               _ulDeviceNumber;
    ULONG                               _ulPartitionNumber;

    BOOL                                _fDeviceNumberInited;
};

#endif //_DRVBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\dispatch.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT

#include "dtct.h"

#include "hwdev.h"

#include "dtctreg.h"

#include "users.h"

#include "cmmn.h"
#include "sfstr.h"
#include "reg.h"
#include "misc.h"

#include "dbg.h"
#include "tfids.h"

#include <shpriv.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// {C1FB73D0-EC3A-4ba2-B512-8CDB9187B6D1}
const CLSID IID_IHWEventHandler =
    {0xC1FB73D0, 0xEC3A, 0x4ba2,
    {0xB5, 0x12, 0x8C, 0xDB, 0x91, 0x87, 0xB6, 0xD1}};

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _CreateAndInitEventHandler(LPCWSTR pszHandler, CLSID* pclsid,
    IHWEventHandler** ppihweh)
{
    IHWEventHandler* pihweh;
    HRESULT hres = _CoCreateInstanceInConsoleSession(*pclsid, NULL,
        CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IHWEventHandler, &pihweh));

    *ppihweh = NULL;

    if (SUCCEEDED(hres))
    {
        LPWSTR pszInitCmdLine;
        hres = _GetInitCmdLine(pszHandler, &pszInitCmdLine);

        if (SUCCEEDED(hres))
        {
            if (S_FALSE == hres)
            {
                ASSERT(!pszInitCmdLine);
                hres = pihweh->Initialize(TEXT(""));
            }
            else
            {
                hres = pihweh->Initialize(pszInitCmdLine);
            }

            if (SUCCEEDED(hres))
            {
                *ppihweh = pihweh;
            }

            if (pszInitCmdLine)
            {
                LocalFree((HLOCAL)pszInitCmdLine);
            }
        }

        if (FAILED(hres))
        {
            pihweh->Release();
            *ppihweh = NULL;
        }
    }

    return hres;
}

struct EXECUTEHANDLERDATA
{
    CLSID       clsidHandler;
    LPWSTR      pszDeviceIDForAutoplay;
    LPWSTR      pszEventType;
    union
    {
        LPWSTR      pszHandler;
        LPWSTR      pszInitCmdLine;
    };
};

HRESULT _CreateExecuteHandlerData(EXECUTEHANDLERDATA** ppehd)
{
    HRESULT hres;

    *ppehd = (EXECUTEHANDLERDATA*)LocalAlloc(LPTR, sizeof(EXECUTEHANDLERDATA));

    if (*ppehd)
    {
        hres = S_OK;
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT _FreeEHDStrings(EXECUTEHANDLERDATA* pehd)
{
    if (pehd->pszHandler)
    {
        LocalFree((HLOCAL)pehd->pszHandler);
        pehd->pszHandler = NULL;
    }

    if (pehd->pszDeviceIDForAutoplay)
    {
        LocalFree((HLOCAL)pehd->pszDeviceIDForAutoplay);
        pehd->pszDeviceIDForAutoplay = NULL;
    }

    if (pehd->pszEventType)
    {
        LocalFree((HLOCAL)pehd->pszEventType);
        pehd->pszEventType = NULL;
    }

    return S_OK;
}

HRESULT _FreeExecuteHandlerData(EXECUTEHANDLERDATA* pehd)
{
    _FreeEHDStrings(pehd);

    LocalFree((HLOCAL)pehd);

    return S_OK;
}

HRESULT _SetExecuteHandlerData(EXECUTEHANDLERDATA* pehd,
    LPCWSTR pszDeviceIDForAutoplay, LPCWSTR pszEventType,
    LPCWSTR pszHandlerOrInitCmdLine, const CLSID* pclsidHandler)
{
    HRESULT hres = DupString(pszHandlerOrInitCmdLine, &(pehd->pszHandler));

    if (SUCCEEDED(hres))
    {
        hres = DupString(pszDeviceIDForAutoplay,
            &(pehd->pszDeviceIDForAutoplay));

        if (SUCCEEDED(hres))
        {
            hres = DupString(pszEventType, &(pehd->pszEventType));

            if (SUCCEEDED(hres))
            {
                pehd->clsidHandler = *pclsidHandler;
            }
        }
    }

    if (FAILED(hres))
    {
        // Free everything
        _FreeEHDStrings(pehd);
    }

    return hres;
}

DWORD WINAPI _ExecuteHandlerThreadProc(void* pv)
{
    EXECUTEHANDLERDATA* pehd = (EXECUTEHANDLERDATA*)pv;
    IHWEventHandler* pihweh;

    DIAGNOSTIC((TEXT("[0100]Attempting to execute handler for:  %s %s %s"),
        pehd->pszDeviceIDForAutoplay, pehd->pszEventType,
        pehd->pszHandler));

    TRACE(TF_SHHWDTCTDTCT,
        TEXT("_ExecuteHandlerThreadProc for: %s %s %s"),
        pehd->pszDeviceIDForAutoplay, pehd->pszEventType,
        pehd->pszHandler);

    HRESULT hres = _CreateAndInitEventHandler(pehd->pszHandler,
        &(pehd->clsidHandler), &pihweh);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        WCHAR szDeviceIDAlt[MAX_PATH];

        DIAGNOSTIC((TEXT("[0101]Got Handler Interface")));

        TRACE(TF_SHHWDTCTDTCT, TEXT("Got Handler Interface"));

        hres = _GetAltDeviceID(pehd->pszDeviceIDForAutoplay, szDeviceIDAlt,
            ARRAYSIZE(szDeviceIDAlt));

        if (S_FALSE == hres)
        {
            szDeviceIDAlt[0] = 0;
        }

        if (SUCCEEDED(hres))
        {
            hres = pihweh->HandleEvent(pehd->pszDeviceIDForAutoplay,
                szDeviceIDAlt, pehd->pszEventType);

            DIAGNOSTIC((TEXT("[0103]IHWEventHandler::HandleEvent returned: hr = 0x%08X"), hres));

            TRACE(TF_SHHWDTCTDTCT,
                TEXT("pIEventHandler->HandleEvent result: 0x%08X"), hres);
        }

        pihweh->Release();
    }
    else
    {
        DIAGNOSTIC((TEXT("[0102]Did not get Handler Interface: hr = 0x%08X"), hres));

        TRACE(TF_SHHWDTCTDTCT,
            TEXT("Did not get Handler Interface: 0x%08X"), hres);
    }

    _FreeExecuteHandlerData(pehd);

    TRACE(TF_SHHWDTCTDTCT, TEXT("Exiting _ExecuteHandlerThreadProc"));

    return (DWORD)hres;
}

HRESULT _DelegateToExecuteHandlerThread(EXECUTEHANDLERDATA* pehd,
    LPTHREAD_START_ROUTINE pThreadProc, HANDLE* phThread)
{
    HRESULT hres;

    // set thread stack size?
    *phThread = CreateThread(NULL, 0, pThreadProc, pehd, 0, NULL);

    if (*phThread)
    {
        hres = S_OK;
    }
    else
    {
        hres = E_FAIL;
    }

    return hres;
}

HRESULT _ExecuteHandlerHelper(LPCWSTR pszDeviceIDForAutoplay,
    LPCWSTR pszEventType,
    LPCWSTR pszHandlerOrInitCmdLine, LPTHREAD_START_ROUTINE pThreadProc,
    const CLSID* pclsidHandler, HANDLE* phThread)
{
    // Let's prepare to delegate to other thread
    EXECUTEHANDLERDATA* pehd;

    HRESULT hres = _CreateExecuteHandlerData(&pehd);

    *phThread = NULL;

    if (SUCCEEDED(hres))
    {
        hres = _SetExecuteHandlerData(pehd, pszDeviceIDForAutoplay,
            pszEventType, pszHandlerOrInitCmdLine,
            pclsidHandler);

        if (SUCCEEDED(hres))
        {
            hres = _DelegateToExecuteHandlerThread(pehd,
                pThreadProc, phThread);
        }

        if (FAILED(hres))
        {
            _FreeExecuteHandlerData(pehd);
        }
    }

    return hres;
}

HRESULT _ExecuteHandler(LPCWSTR pszDeviceIDForAutoplay, LPCWSTR pszEventType,
    LPCWSTR pszHandler)
{
    CLSID clsidHandler;
    HRESULT hres = _GetHandlerCLSID(pszHandler, &clsidHandler);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        HANDLE hThread;

        hres = _ExecuteHandlerHelper(pszDeviceIDForAutoplay, pszEventType,
            pszHandler, _ExecuteHandlerThreadProc,
            &clsidHandler, &hThread);

        if (SUCCEEDED(hres))
        {
            CloseHandle(hThread);
        }
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
DWORD WINAPI _PromptUserThreadProc(void* pv)
{
    IHWEventHandler* pihweh;
    EXECUTEHANDLERDATA* pehd = (EXECUTEHANDLERDATA*)pv;

    DIAGNOSTIC((TEXT("[0110]Will prompt user for preferences")));

    TRACE(TF_SHHWDTCTDTCT, TEXT("Entered _PromptUserThreadProc"));

    HRESULT hr = _CoCreateInstanceInConsoleSession(pehd->clsidHandler, NULL,
        CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IHWEventHandler, &pihweh));

    if (SUCCEEDED(hr))
    {
        hr = pihweh->Initialize(pehd->pszInitCmdLine);

        if (SUCCEEDED(hr))
        {
            WCHAR szDeviceIDAlt[MAX_PATH];
            TRACE(TF_SHHWDTCTDTCT, TEXT("Got Handler Interface"));

            hr = _GetAltDeviceID(pehd->pszDeviceIDForAutoplay, szDeviceIDAlt,
                ARRAYSIZE(szDeviceIDAlt));

            if (S_FALSE == hr)
            {
                szDeviceIDAlt[0] = 0;
            }

            if (SUCCEEDED(hr))
            {
                hr = pihweh->HandleEvent(pehd->pszDeviceIDForAutoplay,
                    szDeviceIDAlt, pehd->pszEventType);
            }
        }

        pihweh->Release();
    }

    _FreeExecuteHandlerData(pehd);

    TRACE(TF_SHHWDTCTDTCT, TEXT("Exiting _PromptUserThreadProc"));

    return (DWORD)hr;
}


HRESULT _PromptUser(LPCWSTR pszDeviceIDForAutoplay, LPCWSTR pszEventType,
    LPCWSTR pszInitCmdLine)
{
    HANDLE hThread;

    HRESULT hr = _ExecuteHandlerHelper(pszDeviceIDForAutoplay, pszEventType,
        pszInitCmdLine, _PromptUserThreadProc,
        &CLSID_ShellAutoplay, &hThread);

    if (SUCCEEDED(hr))
    {
        CloseHandle(hThread);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//

struct QUERYRUNNINGOBJECTSTRUCT
{
    IHWEventHandler* phweh;
    WCHAR szDeviceIntfID[MAX_DEVICEID];
    WCHAR szEventType[MAX_EVENTTYPE];
};

DWORD WINAPI _QueryRunningObjectThreadProc(void* pv)
{
    QUERYRUNNINGOBJECTSTRUCT* pqro = (QUERYRUNNINGOBJECTSTRUCT*)pv;
    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    if (SUCCEEDED(hr))
    {
        hr = pqro->phweh->HandleEvent(pqro->szDeviceIntfID, TEXT(""), pqro->szEventType);

        CoUninitialize();
    }

    pqro->phweh->Release();
    LocalFree((HLOCAL)pqro);

    return (DWORD)hr;
}

HRESULT _QueryRunningObject(IHWEventHandler* phweh, LPCWSTR pszDeviceIntfID,
    LPCWSTR pszEventType, LPCWSTR pszHandler, BOOL* pfHandlesEvent)
{
    HRESULT hr;
    QUERYRUNNINGOBJECTSTRUCT* pqro = (QUERYRUNNINGOBJECTSTRUCT*)LocalAlloc(LPTR,
        sizeof(QUERYRUNNINGOBJECTSTRUCT));

    *pfHandlesEvent = FALSE;

    if (pqro)
    {
        phweh->AddRef();
        pqro->phweh = phweh;

        hr = SafeStrCpyN(pqro->szDeviceIntfID, pszDeviceIntfID,
            ARRAYSIZE(pqro->szDeviceIntfID));

        if (SUCCEEDED(hr))
        {
            hr = SafeStrCpyN(pqro->szEventType, pszEventType,
                ARRAYSIZE(pqro->szEventType));
        }

        if (SUCCEEDED(hr))
        {
            HANDLE hThread = CreateThread(NULL, 0, _QueryRunningObjectThreadProc, pqro,
                0, NULL);

            if (hThread)
            {
                // Wait 3 sec to see if wants to process it.  If not, it's
                // fair play for us.
                DWORD dwWait = WaitForSingleObject(hThread, 3000);
            
                if (WAIT_OBJECT_0 == dwWait)
                {
                    // Return within time and did not failed
                    DWORD dwExitCode;

                    if (GetExitCodeThread(hThread, &dwExitCode))
                    {
                        HRESULT hrHandlesEvent = (HRESULT)dwExitCode;
                    
                        // WIA will return S_FALSE if they do NOT want to process
                        // the event
                        if (SUCCEEDED(hrHandlesEvent) && (S_FALSE != hrHandlesEvent))
                        {
                            DIAGNOSTIC((TEXT("[0124]Already running handler will handle event (%s)"), pszHandler));

                            TRACE(TF_WIA,
                                TEXT("Already running handler will handle event"));

                            *pfHandlesEvent = TRUE;
                        }
                        else
                        {
                            DIAGNOSTIC((TEXT("[0125]Already running handler will *NOT* handle event(%s)"), pszHandler));
                            TRACE(TF_WIA,
                                TEXT("WIA.HandleEventOverride will NOT Handle Event"));
                        }

                        hr = S_OK;
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
                else
                {
                    if (WAIT_TIMEOUT == dwWait)
                    {
                        DIAGNOSTIC((TEXT("[0126]Timed out on already running handler ( > 3 sec)")));
                        TRACE(TF_WIA,
                            TEXT("Timed out waiting on already running object (%s)"), pszHandler);
                    }

                    hr = S_FALSE;
                }

                CloseHandle(hThread);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (FAILED(hr))
        {
            pqro->phweh->Release();
            LocalFree((HLOCAL)pqro);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT _FindAlreadyRunningHandler(LPCWSTR pszDeviceIntfID,
    LPCWSTR pszEventType, LPCWSTR pszEventHandler, BOOL* pfHandlesEvent)
{
    CImpersonateConsoleSessionUser icsu;

    HRESULT hr = icsu.Impersonate();

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        IBindCtx* pbindctx;

        hr = CreateBindCtx(0, &pbindctx);

        *pfHandlesEvent = FALSE;

        if (SUCCEEDED(hr))
        {
            IRunningObjectTable* prot;

            hr = pbindctx->GetRunningObjectTable(&prot);

            if (SUCCEEDED(hr))
            {
                WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlers\\"));
                hr = SafeStrCatN(szKeyName, pszEventHandler, ARRAYSIZE(szKeyName));

                if (SUCCEEDED(hr))
                {
                    HKEY hkey;

                    hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        WCHAR szHandler[MAX_HANDLER];
                        DWORD dwIndex = 0;

                        while (!*pfHandlesEvent && SUCCEEDED(hr) &&
                            SUCCEEDED(hr = _RegEnumStringValue(hkey, dwIndex,
                            szHandler, ARRAYSIZE(szHandler))) &&
                            (S_FALSE != hr))
                        {
                            CLSID clsid;

                            hr = _GetHandlerCancelCLSID(szHandler, &clsid);

                            if (SUCCEEDED(hr) && (S_FALSE != hr))
                            {
                                IMoniker* pmoniker;

                                hr = _BuildMoniker(pszEventHandler, clsid,
                                    (USER_SHARED_DATA->ActiveConsoleId), &pmoniker);

                                if (SUCCEEDED(hr))
                                {
                                    IUnknown* punk;

                                    hr = prot->GetObject(pmoniker, &punk);

                                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                                    {
                                        IHWEventHandler* phweh;

                                        hr = punk->QueryInterface(
                                            IID_IHWEventHandler, (void**)&phweh);

                                        if (SUCCEEDED(hr))
                                        {
                                            hr = _QueryRunningObject(phweh,
                                                pszDeviceIntfID, pszEventType,
                                                szHandler, pfHandlesEvent);

                                            phweh->Release();
                                        }

                                        punk->Release();
                                    }
                                    else
                                    {
                                        // if it can't find it, it return s failure
                                        hr = S_FALSE;
                                    }
                                
                                    pmoniker->Release();
                                }
                            }

                            ++dwIndex;
                        }

                        _RegCloseKey(hkey);
                    }
                }

                prot->Release();
            }

            pbindctx->Release();
        }

        icsu.RevertToSelf();
    }

    return hr;
}

HRESULT _FinalDispatch(LPCWSTR pszDeviceIntfID, LPCWSTR pszEventType,
    LPCWSTR pszEventHandler)
{
    DIAGNOSTIC((TEXT("[0111]Looking for already running handler for: %s, %s, %s"),
        pszDeviceIntfID, pszEventType, pszEventHandler));

    BOOL fHandlesEvent;
    HRESULT hres = _FindAlreadyRunningHandler(pszDeviceIntfID, pszEventType,
        pszEventHandler, &fHandlesEvent);

    if (SUCCEEDED(hres) && !fHandlesEvent)
    {
        WCHAR szHandler[MAX_HANDLER];

        hres = _GetUserDefaultHandler(pszDeviceIntfID, pszEventHandler,
            szHandler, ARRAYSIZE(szHandler), GUH_USEWINSTA0USER);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            // We have a handler
            TRACE(TF_SHHWDTCTDTCT, TEXT("Found Handler: %s"), szHandler);
            BOOL fPrompt = FALSE;
            BOOL fCheckAlwaysDoThis = FALSE;
            BOOL fExecuteHandler = FALSE;

            if (HANDLERDEFAULT_GETFLAGS(hres) &
                HANDLERDEFAULT_USERCHOSENDEFAULT)
            {
                // We have a user chosen default...
                if (HANDLERDEFAULT_GETFLAGS(hres) &
                    HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED)
                {
                    // ... but we have more recent apps that were installed
                    fPrompt = TRUE;
                }
                else
                {
                    if (lstrcmp(szHandler, TEXT("MSTakeNoAction")))
                    {
                        // The handler is *not* "Take no action"
                        if (!lstrcmp(szHandler, TEXT("MSPromptEachTime")))
                        {
                            // The handler is "Prompt each time"
                            fPrompt = TRUE;
                        }
                        else
                        {
                            fExecuteHandler = TRUE;
                        }
                    }
                }
            }
            else
            {
                // If we do not have a user chosen handler, then we always
                // prompt
                fPrompt = TRUE;
            }

            if (fPrompt)
            {
                if (HANDLERDEFAULT_GETFLAGS(hres) &
                    HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED)
                {
                    // There are more recent handlers
                    if (HANDLERDEFAULT_GETFLAGS(hres) &
                        HANDLERDEFAULT_USERCHOSENDEFAULT)
                    {
                        // The user chose a default handler
                        if (!(HANDLERDEFAULT_GETFLAGS(hres) &
                            HANDLERDEFAULT_DEFAULTSAREDIFFERENT))
                        {
                            // The handlers are the same, check the checkbox
                            fCheckAlwaysDoThis = TRUE;
                        }
                    }
                }

                _GiveAllowForegroundToConsoleShell();

                if (fCheckAlwaysDoThis)
                {
                    // Notice the '*' at the end of the string
                    hres = _PromptUser(pszDeviceIntfID, pszEventType,
                        TEXT("PromptEachTimeNoContent*"));                
                }
                else
                {
                    hres = _PromptUser(pszDeviceIntfID, pszEventType,
                        TEXT("PromptEachTimeNoContent"));
                }
            }
            else
            {
                if (fExecuteHandler)
                {
                    hres = _ExecuteHandler(pszDeviceIntfID, pszEventType,
                        szHandler);
                }
            }
        }
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _IsWIAHandlingEvent(LPCWSTR pszDeviceIDForAutoplay,
    LPCWSTR pszEventType, BOOL* pfWIAHandlingEvent)
{
    CLSID clsid = {0};
    HRESULT hr = CLSIDFromProgID(TEXT("WIA.HandleEventOverride"), &clsid);

    *pfWIAHandlingEvent = FALSE;

    if (SUCCEEDED(hr))
    {
        HANDLE hThread;

        hr = _ExecuteHandlerHelper(pszDeviceIDForAutoplay, pszEventType,
            TEXT(""), _ExecuteHandlerThreadProc, &clsid, &hThread);

        if (SUCCEEDED(hr))
        {
            // Wait 3 sec to see if WIA wants to process it.  If not, it's
            // fair play for us.
            DWORD dwWait = WaitForSingleObject(hThread, 3000);
            
            if (WAIT_OBJECT_0 == dwWait)
            {
                // Return within time and did not failed
                DWORD dwExitCode;

                if (GetExitCodeThread(hThread, &dwExitCode))
                {
                    HRESULT hrWIA = (HRESULT)dwExitCode;
                    
                    // WIA will return S_FALSE if they do NOT want to process
                    // the event
                    if (SUCCEEDED(hrWIA) && (S_FALSE != hrWIA))
                    {
                        DIAGNOSTIC((TEXT("[0114]WIA will handle event")));

                        TRACE(TF_WIA,
                            TEXT("WIA.HandleEventOverride will Handle Event"));
                        *pfWIAHandlingEvent = TRUE;
                    }
                    else
                    {
                        TRACE(TF_WIA,
                            TEXT("WIA.HandleEventOverride will NOT Handle Event"));
                    }
                }
            }
            else
            {
                if (WAIT_TIMEOUT == dwWait)
                {
                    TRACE(TF_WIA,
                        TEXT("Timed out waiting on WIA.HandleEventOverride"));
                }
            }

            CloseHandle(hThread);
        }
        else
        {
            TRACE(TF_WIA,
                TEXT("_ExecuteHandlerHelper failed for WIA.HandleEventOverride"));
        }
    }
    else
    {
        TRACE(TF_WIA,
            TEXT("Could not get CLSID for WIA.HandleEventOverride"));
    }

    return hr;
}

HRESULT _DispatchToHandler(LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst,
    LPCWSTR pszEventType, BOOL* pfHasHandler)
{
    WCHAR szDeviceHandler[MAX_DEVICEHANDLER];
    HRESULT hres = _GetDeviceHandler(phwdevinst, szDeviceHandler,
        ARRAYSIZE(szDeviceHandler));

    *pfHasHandler = FALSE;

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        WCHAR szEventHandler[MAX_EVENTHANDLER];

        DIAGNOSTIC((TEXT("[0115]Found DeviceHandler: %s"), szDeviceHandler));

        TRACE(TF_SHHWDTCTDTCT,
            TEXT("Found Device Handler: %s"), szDeviceHandler);

        if (SUCCEEDED(hres))
        {
            DIAGNOSTIC((TEXT("[0117]Device does NOT Support Content")));
            TRACE(TF_SHHWDTCTDTCT, TEXT("Device does NOT Support Content"));

            BOOL fWIAHandlingEvent = FALSE;
            GUID guidInterface;
            HRESULT hres2 = phwdevinst->GetInterfaceGUID(&guidInterface);

            if (SUCCEEDED(hres2))
            {
                if ((guidInterface == guidImagingDeviceClass) ||
                    (guidInterface == guidVideoCameraClass))
                {
                    _IsWIAHandlingEvent(pszDeviceIntfID, pszEventType,
                        &fWIAHandlingEvent);
                }
            }

            if (!fWIAHandlingEvent)
            {
                hres = _GetEventHandlerFromDeviceHandler(szDeviceHandler,
                    pszEventType, szEventHandler, ARRAYSIZE(szEventHandler));

                if (SUCCEEDED(hres))
                {
                    if (S_FALSE != hres)
                    {
                        *pfHasHandler = TRUE;

                        hres = _FinalDispatch(pszDeviceIntfID, pszEventType,
                            szEventHandler);

                        TRACE(TF_SHHWDTCTDTCTDETAILED,
                            TEXT("  _GetEventHandlerFromDeviceHandler returned: %s"),
                            szEventHandler);
                    }
                }
            }
            else
            {
                DIAGNOSTIC((TEXT("[0123]WIA will handle event")));
                TRACE(TF_SHHWDTCTDTCTDETAILED, TEXT("  WIA will handle event"));
            }
        }
    }
    else
    {
        DIAGNOSTIC((TEXT("[0112]Did NOT find DeviceHandler: 0x%08X"), hres));
        TRACE(TF_SHHWDTCTDTCT, TEXT("Did not find Device Handler: 0x%08X"),
            hres);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\dtct.cpp ===
#include "dtct.h"

#include "svcsync.h"

#include "cmmn.h"

#include "misc.h"
#include "str.h"

#include "mischlpr.h"
#include "dbg.h"
#include "tfids.h"

#include "regnotif.h"

#include <ioevent.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
// {5390E909-5BDF-4218-BB1F-9A41B3143214}
extern const CLSID CLSID_HWEventDetector =
    {0x5390e909, 0x5bdf, 0x4218,
    {0xbb, 0x1f, 0x9a, 0x41, 0xb3, 0x14, 0x32, 0x14}};

///////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CHWEventDetectorImpl::InitMinimum(DWORD UNREF_PARAM(cArg),
    LPWSTR* UNREF_PARAM(ppszArgs), LPCWSTR pszEventRelinquishControl,
    DWORD* pdwCtrlAccept, BOOL* pfWantsDeviceEvents)
{
    HRESULT hres;

    ASSERTVALIDSTATE();

    if (pszEventRelinquishControl && *pszEventRelinquishControl &&
        pdwCtrlAccept && pfWantsDeviceEvents)
    {
        _hEventRelinquishControl = OpenEvent(SYNCHRONIZE, FALSE,
            pszEventRelinquishControl);

        if (_hEventRelinquishControl)
        {
            hres = _RegisterFactories();

            if (SUCCEEDED(hres))
            {
                *pdwCtrlAccept = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN |
                    SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SESSIONCHANGE;

                *pfWantsDeviceEvents = TRUE;
            }
        }
        else
        {
            hres = E_FAIL;
        }
    }
    else
    {
        hres = E_INVALIDARG;
    }

    ASSERTVALIDSTATE();

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::InitDeviceEventHandler(
    SERVICE_STATUS_HANDLE ssh)
{
    HRESULT hres = E_INVALIDARG;

    TRACE(TF_SHHWDTCTSVC, TEXT("Entered CHWEventDetectorImpl::InitDeviceEventHandler"));

    ASSERTVALIDSTATE();

    if (ssh)
    {
        hres = CHWEventDetectorHelper::SetServiceStatusHandle(ssh);
    }

    ASSERTVALIDSTATE();

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::InitFinal()
{
    HRESULT hres;
    HANDLE hProcess = GetCurrentProcess();

    TRACE(TF_SHHWDTCTSVC, TEXT("Entered CHWEventDetectorImpl::InitFinal"));

    ASSERTVALIDSTATE();

    ASSERT(!g_hShellHWDetectionThread);

    if (DuplicateHandle(hProcess, GetCurrentThread(), hProcess,
        &g_hShellHWDetectionThread, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        TRACE(TF_SVCSYNC,
            TEXT("About to set ShellHWDetection thread priority to LOWEST from itself"));

        if (SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST))
        {
            hres = CHWEventDetectorHelper::InitDockState();

            CHWEventDetectorHelper::Init();

            if (SUCCEEDED(hres))
            {
                hres = _RegisterForNotif();

                TRACE(TF_SVCSYNC,
                    TEXT("Completed registration, about to set ShellHWDetection thread priority to NORMAL from itself"));

                SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

                _hEventInitCompleted = CreateEvent(NULL, TRUE, FALSE,
                    g_szShellHWDetectionInitCompleted);

                if (_hEventInitCompleted)
                {
                    TRACE(TF_SVCSYNC,
                        TEXT("Completed intialization, setting event"));

                    hres = S_OK;

                    SetEvent(_hEventInitCompleted);
                }
            }
        }
        else
        {
            hres = E_FAIL;
        }
    }
    else
    {
        hres = E_FAIL;
    }

    ASSERTVALIDSTATE();

    TRACE(TF_SHHWDTCTSVC, TEXT("Exited CHWEventDetectorImpl::InitFinal: 0x%08X"),
        hres);

    return hres;
}
///////////////////////////////////////////////////////////////////////////////
//
// return S_FALSE and a non-zero dwWaitHint if pending
STDMETHODIMP CHWEventDetectorImpl::HandleServiceControl(DWORD dwControlCode,
    DWORD* pdwWaitHint)
{
    HRESULT hres;

    ASSERTVALIDSTATE();

    *pdwWaitHint = 0;

    switch (dwControlCode)
    {
        case SERVICE_CONTROL_PAUSE:
            hres = _UnregisterForNotif();
            hres = _SuspendFactories();
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
        {
            // In case _CompleteShellHWDetectionInitialization was never called
            HANDLE hTmp = InterlockedCompareExchangePointer(
                &g_hShellHWDetectionThread, NULL,
                g_hShellHWDetectionThread);

            if (hTmp)
            {
                CloseHandle(hTmp);
            }

            if (_hEventInitCompleted)
            {
                CloseHandle(_hEventInitCompleted);
                _hEventInitCompleted = NULL;
            }

            hres = _UnregisterForNotif();
            hres = CHWEventDetectorHelper::DeleteLists();
            hres = _UnregisterFactories();

            CHWEventDetectorHelper::Cleanup();

            break;
        }

        case SERVICE_CONTROL_CONTINUE:
            hres = _RegisterForNotif();
            hres = _ResumeFactories();
            break;

        default:
            // do not return S_FALSE here
            hres = S_OK;
            break;
    }

    ASSERTVALIDSTATE();

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::HandleDeviceEvent(DWORD dwEventType,
    LPVOID pEventData)
{
    HRESULT hres = S_FALSE;

    ASSERTVALIDSTATE();

    CHWEventDetectorHelper::CheckDiagnosticAppPresence();

    if (pEventData)
    {
        DEV_BROADCAST_HDR* dbhdr = (DEV_BROADCAST_HDR*)pEventData;

        if (DBT_DEVTYP_DEVICEINTERFACE == dbhdr->dbch_devicetype)
        {
            DEV_BROADCAST_DEVICEINTERFACE* pdbdi =
                (DEV_BROADCAST_DEVICEINTERFACE*)pEventData;

            WCHAR szGUID[MAX_GUIDSTRING];
            LPWSTR pszEventType = TEXT("Unknown");

            if (SUCCEEDED(_StringFromGUID(&(pdbdi->dbcc_classguid), szGUID,
                ARRAYSIZE(szGUID))))
            {
                switch (dwEventType)
                {
                    case DBT_DEVICEARRIVAL:
                        pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEARRIVAL");
                        DIAGNOSTIC((TEXT("[0000]Processing Interface Arrival Event: %s, %s"), pszEventType, szGUID));
                        break;

                    case DBT_DEVICEREMOVECOMPLETE:
                        pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEREMOVECOMPLETE");
                        DIAGNOSTIC((TEXT("[0001]Processing Interface Removal Event: %s, %s"), pszEventType, szGUID));
                        break;
#ifdef DEBUG
                    case DBT_DEVICEQUERYREMOVEFAILED: pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEQUERYREMOVEFAILED"); break;
                    case DBT_DEVICEREMOVEPENDING: pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEREMOVEPENDING"); break;
                    case DBT_DEVICEQUERYREMOVE: pszEventType = TEXT("DBT_DEVTYP_DEVICEINTERFACE + DBT_DEVICEQUERYREMOVE"); break;
#endif
                }


                TRACE(TF_SHHWDTCTDTCT, TEXT("Processing Interface Event: %s, %s"),
                    pszEventType, szGUID);
            }
            
            hres = _HandleInterfaceEvent(pdbdi, dwEventType);
        }
        else
        {
            if (DBT_DEVTYP_HANDLE == dbhdr->dbch_devicetype)
            {
                DEV_BROADCAST_HANDLE* pdbh = (DEV_BROADCAST_HANDLE*)pEventData;

#ifdef DEBUG
                LPWSTR pszEventType = TEXT("Unknown");
                WCHAR szGUID[MAX_GUIDSTRING];

                if (DBT_CUSTOMEVENT == dwEventType)
                {
                    HRESULT hrTmp = S_FALSE;

                    if (GUID_IO_MEDIA_ARRIVAL == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_MEDIA_ARRIVAL");
                    else if (GUID_IO_MEDIA_REMOVAL == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_MEDIA_REMOVAL");
                    else if (GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_LOCK");
                    else if (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_LOCK_FAILED");
                    else if (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_UNLOCK");
                    else if (GUID_IO_VOLUME_NAME_CHANGE == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_NAME_CHANGE");
                    else if (GUID_IO_VOLUME_CHANGE == pdbh->dbch_eventguid) pszEventType = TEXT("GUID_IO_VOLUME_CHANGE");
                    else
                    {
                        hrTmp = _StringFromGUID(&(pdbh->dbch_eventguid), szGUID, ARRAYSIZE(szGUID));
                        pszEventType = szGUID;
                    }

                    if (SUCCEEDED(hrTmp))
                    {
                        TRACE(TF_SHHWDTCTDTCT,
                            TEXT("Processing Broadcast Event: %s, hdevnotify = 0x%08X"),
                            pszEventType, pdbh->dbch_hdevnotify);
                    }
                }
                else
                {
                    pszEventType = TEXT("unknown");

                    switch (dwEventType)
                    {
                        case DBT_DEVICEARRIVAL: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEARRIVAL"); break;
                        case DBT_DEVICEQUERYREMOVE: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEQUERYREMOVE"); break;
                        case DBT_DEVICEQUERYREMOVEFAILED: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEQUERYREMOVEFAILED"); break;
                        case DBT_DEVICEREMOVEPENDING: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEREMOVEPENDING"); break;
                        case DBT_DEVICEREMOVECOMPLETE: pszEventType = TEXT("DBT_DEVTYP_HANDLE + DBT_DEVICEREMOVECOMPLETE"); break;
                    }
                    TRACE(TF_SHHWDTCTDTCT, TEXT("Processing Unknown Broadcast Event: %s, dwEventType = 0x%08X"), pszEventType, dwEventType);
                }
#endif
                hres = _HandleBroadcastHandleEvent(pdbh, dwEventType);
            }
            else
            {
            }
        }
    }

    ASSERTVALIDSTATE();

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::Run()
{
    ASSERTVALIDSTATE();

    // Nothing to do for now.
    return S_OK;
}

STDMETHODIMP CHWEventDetectorImpl::HandlePowerEvent(
    DWORD UNREF_PARAM(dwEventType), LPVOID UNREF_PARAM(pEventData))
{
    HRESULT hres = E_UNEXPECTED;

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::HandleHWProfileEvent(
    DWORD UNREF_PARAM(dwEventType), LPVOID UNREF_PARAM(pEventData))
{
    HRESULT hres = E_UNEXPECTED;

    return hres;
}

STDMETHODIMP CHWEventDetectorImpl::HandleSessionChange(
    DWORD dwEventType, LPVOID UNREF_PARAM(pvEventData))
{
    HRESULT hres;

    switch (dwEventType)
    {
    case WTS_SESSION_LOGOFF:
        //
        //  When this happens, we need to check our handles to see which
        //  Explorer process went away and free its handle.
        //
        hres = CHardwareDevicesImpl::_AdviseCheckClients( );
        break;

    default:
        hres = S_OK;
        break;
    }

    return hres;
}

#ifdef DEBUG
void CHWEventDetectorImpl::_DbgAssertValidState()
{
    CHWEventDetectorHelper::_DbgAssertValidState();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\drvbase.cpp ===
#include "drvbase.h"

#include "cmmn.h"

#include <dbt.h>

HRESULT CDisk::Init(LPCWSTR pszElemName)
{
    HRESULT hr = _SetName(pszElemName);

    return hr;
}

HRESULT CDisk::GetDeviceNumber(ULONG* puldeviceNumber)
{
    HRESULT hr = _Init();

    if (SUCCEEDED(hr))
    {
        if (((DEVICE_TYPE)-1) != _devtype)
        {
            *puldeviceNumber = _ulDeviceNumber;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;    
}

HRESULT CDisk::GetDeviceType(DEVICE_TYPE* pdevtype)
{
    HRESULT hr = _Init();

    if (SUCCEEDED(hr))
    {
        if (((DEVICE_TYPE)-1) != _devtype)
        {
            *pdevtype = _devtype;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT _GetDeviceNumberInfo(LPCWSTR pszDeviceID, DEVICE_TYPE* pdevtype,
    ULONG* pulDeviceNumber, ULONG* pulPartitionNumber)
{
    HRESULT hr;

    HANDLE hDevice = _GetDeviceHandle(pszDeviceID, FILE_READ_ATTRIBUTES);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        HDEVNOTIFY hdevnotify;
        DEV_BROADCAST_HANDLE dbhNotifFilter = {0};
        BOOL fRegistered = FALSE;

        dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        dbhNotifFilter.dbch_handle = hDevice;

        hr = CHWEventDetectorHelper::RegisterDeviceNotification(
            &dbhNotifFilter, &hdevnotify, FALSE);

        if (SUCCEEDED(hr))
        {
            fRegistered = TRUE;

            hr = _GetDeviceNumberInfoFromHandle(hDevice, pdevtype,
                pulDeviceNumber, pulPartitionNumber);
        }

        _CloseDeviceHandle(hDevice);

        if (fRegistered)
        {
            UnregisterDeviceNotification(hdevnotify);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CDisk::_Init()
{
    HRESULT hr = S_OK;

    if (!_fDeviceNumberInited)
    {
        hr = _GetDeviceNumberInfo(_pszElemName, &_devtype, &_ulDeviceNumber,
            &_ulPartitionNumber);

        _fDeviceNumberInited = TRUE;
    }

    return hr;
}

CDisk::CDisk() : _devtype((DEVICE_TYPE)-1),
    _ulDeviceNumber((ULONG)-1), _ulPartitionNumber((ULONG)-1),
    _fDeviceNumberInited(FALSE)
{}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// static
HRESULT CDisk::Create(CNamedElem** ppelem)
{
    HRESULT hr = S_OK;
    *ppelem = new CDisk();

    if (!(*ppelem))
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

class CDiskFillEnum : public CFillEnum
{
public:
    HRESULT _Init();
    HRESULT Next(LPTSTR pszElemName, DWORD cchElemName, DWORD* pcchRequired);

private:
    CIntfFillEnum       _intffillenumDisk;
    CIntfFillEnum       _intffillenumCDROM;
    BOOL                _fDiskDone;
};

//static
HRESULT CDisk::GetFillEnum(CFillEnum** ppfillenum)
{
    HRESULT hres;

    CDiskFillEnum* pfillenum = new CDiskFillEnum();

    if (pfillenum)
    {
        hres = pfillenum->_Init();

        if (FAILED(hres))
        {
            delete pfillenum;
            pfillenum = NULL;
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    *ppfillenum = pfillenum;

    return hres;
}

HRESULT CDiskFillEnum::_Init()
{
    _fDiskDone = FALSE;

    return _intffillenumDisk._Init(&guidDiskClass, NULL);
}

HRESULT CDiskFillEnum::Next(LPTSTR pszElemName, DWORD cchElemName,
    DWORD* pcchRequired)
{
    HRESULT hr;
    BOOL fDoCDROM = FALSE;
        
    if (!_fDiskDone)
    {
        hr = _intffillenumDisk.Next(pszElemName, cchElemName,
            pcchRequired);

        if (S_FALSE == hr)
        {
            hr = _intffillenumCDROM._Init(&guidCdRomClass, NULL);

            _fDiskDone = TRUE;

            if (SUCCEEDED(hr))
            {
                fDoCDROM = TRUE;
            }
        }
    }
    else
    {
        fDoCDROM = TRUE;
        hr = S_OK;
    }

    if (fDoCDROM)
    {
        hr = _intffillenumCDROM.Next(pszElemName, cchElemName,
            pcchRequired);        
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\dtctreg.cpp ===
#include "dtctreg.h"

#include "hwdev.h"

#include "pnp.h"

#include "cmmn.h"

#include "sfstr.h"
#include "reg.h"
#include "misc.h"

#include "shobjidl.h"
#include "shpriv.h"

#include "users.h"

#include "strsafe.h"
#include "str.h"
#include "dbg.h"

#include "mischlpr.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT _GetValueToUse(LPWSTR pszKeyName, LPWSTR psz, DWORD cch)
{
    HKEY hkey;
    HRESULT hr = _RegOpenKey(HKEY_LOCAL_MACHINE, pszKeyName, &hkey);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // For now we take the first one.
        hr = _RegEnumStringValue(hkey, 0, psz, cch);

        _RegCloseKey(hkey);
    }

    return hr; 
}

// Return Values:
//      S_FALSE: Can't find it
HRESULT _GetEventHandlerFromKey(LPCWSTR pszKeyName, LPCWSTR pszEventType,
    LPWSTR pszEventHandler, DWORD cchEventHandler)
{
    WCHAR szEventHandler[MAX_KEY];
    DWORD cchLeft;
    LPWSTR pszNext;
    HRESULT hr = SafeStrCpyNEx(szEventHandler, pszKeyName,
        ARRAYSIZE(szEventHandler), &pszNext, &cchLeft);

    if (SUCCEEDED(hr))
    {
        hr = SafeStrCpyNEx(pszNext, TEXT("\\EventHandlers\\"), cchLeft,
            &pszNext, &cchLeft);

        if (SUCCEEDED(hr))
        {
            hr = SafeStrCpyN(pszNext, pszEventType, cchLeft);

            if (SUCCEEDED(hr))
            {
                hr = _GetValueToUse(szEventHandler, pszEventHandler,
                    cchEventHandler);
            }
        }
    }

    return hr;
}

// Return Values:
//      S_FALSE: Can't find it
HRESULT _GetEventHandlerFromDeviceHandler(LPCWSTR pszDeviceHandler,
    LPCWSTR pszEventType, LPWSTR pszEventHandler, DWORD cchEventHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("DeviceHandlers\\"));
    HRESULT hr = SafeStrCatN(szKeyName, pszDeviceHandler,
        ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr))
    {
        hr = _GetEventHandlerFromKey(szKeyName, pszEventType, pszEventHandler,
            cchEventHandler);
    }

    return hr;
}

HRESULT _GetStuffFromHandlerHelper(LPCWSTR pszHandler, LPCWSTR pszValueName,
    LPWSTR psz, DWORD cch)
{
    HKEY hkey;
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("Handlers\\"));
    HRESULT hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = _RegQueryString(hkey, pszHandler,
            pszValueName, psz, cch);

        _RegCloseKey(hkey);
    }

    return hr;
}

HRESULT _GetActionFromHandler(LPCWSTR pszHandler, LPWSTR pszAction,
    DWORD cchAction)
{
    HRESULT hr = _GetStuffFromHandlerHelper(pszHandler, TEXT("Action"),
        pszAction, cchAction);

    if (SUCCEEDED(hr) && (S_FALSE == hr))
    {
        hr = _GetStuffFromHandlerHelper(pszHandler, TEXT("FriendlyName"),
            pszAction, cchAction);        
    }

    return hr;
}

HRESULT _GetProviderFromHandler(LPCWSTR pszHandler, LPWSTR pszProvider,
    DWORD cchProvider)
{
    HRESULT hr = _GetStuffFromHandlerHelper(pszHandler, TEXT("Provider"),
        pszProvider, cchProvider);

    if (SUCCEEDED(hr) && (S_FALSE == hr))
    {
        hr = SafeStrCpyN(pszProvider, TEXT("<need provider>"), cchProvider);
    }

    return hr;
}

HRESULT _GetIconLocationFromHandler(LPCWSTR pszHandler,
    LPWSTR pszIconLocation, DWORD cchIconLocation)
{
    return _GetStuffFromHandlerHelper(pszHandler, TEXT("DefaultIcon"),
        pszIconLocation, cchIconLocation);
}

HRESULT _GetInvokeProgIDFromHandler(LPCWSTR pszHandler,
    LPWSTR pszInvokeProgID, DWORD cchInvokeProgID)
{
    return _GetStuffFromHandlerHelper(pszHandler, TEXT("InvokeProgID"),
        pszInvokeProgID, cchInvokeProgID);
}

HRESULT _GetInvokeVerbFromHandler(LPCWSTR pszHandler,
    LPWSTR pszInvokeVerb, DWORD cchInvokeVerb)
{
    return _GetStuffFromHandlerHelper(pszHandler, TEXT("InvokeVerb"),
        pszInvokeVerb, cchInvokeVerb);
}

HRESULT _GetEventKeyName(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszEventKeyName, DWORD cchEventKeyName)
{
    WCHAR szDeviceIDReal[MAX_DEVICEID];
    HRESULT hr = _GetDeviceID(pszDeviceID, szDeviceIDReal,
        ARRAYSIZE(szDeviceIDReal));

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        CHWDeviceInst* phwdevinst;
        CNamedElem* pelemToRelease;
        hr = _GetHWDeviceInstFromDeviceOrVolumeIntfID(szDeviceIDReal,
            &phwdevinst, &pelemToRelease);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szDeviceHandler[MAX_DEVICEHANDLER];

            hr = _GetDeviceHandler(phwdevinst, szDeviceHandler,
                ARRAYSIZE(szDeviceHandler));

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                LPWSTR pszNext;
                DWORD cchLeft;

                hr = SafeStrCpyNEx(pszEventKeyName,
                    SHDEVICEEVENTROOT(TEXT("DeviceHandlers\\")),
                    cchEventKeyName, &pszNext, &cchLeft);

                if (SUCCEEDED(hr))
                {
                    hr = SafeStrCpyNEx(pszNext, szDeviceHandler,
                        cchLeft, &pszNext, &cchLeft);

                    if (SUCCEEDED(hr))
                    {
                        hr = SafeStrCpyNEx(pszNext, TEXT("\\EventHandlers\\"),
                            cchLeft, &pszNext, &cchLeft);

                        if (SUCCEEDED(hr))
                        {
                            hr = SafeStrCpyN(pszNext, pszEventType, cchLeft);
                        }
                    }
                }
            }   
            pelemToRelease->RCRelease();
        }
    }

    if (FAILED(hr) || (S_FALSE == hr))
    {
        *pszEventKeyName = NULL;
    }

    return hr;
}

HRESULT _GetEventString(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPCWSTR pszValueName, LPWSTR psz, DWORD cch)
{
    WCHAR szKeyName[MAX_KEY];

    HRESULT hr = _GetEventKeyName(pszDeviceID, pszEventType, szKeyName,
        ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        HKEY hkey;
        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _RegQueryString(hkey, NULL, pszValueName, psz, cch);

            _RegCloseKey(hkey);
        }
    }

    return hr;
}

HRESULT _GetEventFriendlyName(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszFriendlyName, DWORD cchFriendlyName)
{
    return _GetEventString(pszDeviceID, pszEventType, TEXT("FriendlyName"),
        pszFriendlyName, cchFriendlyName);
}

HRESULT _GetEventIconLocation(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszIconLocation, DWORD cchIconLocation)
{
    return _GetEventString(pszDeviceID, pszEventType, TEXT("DefaultIcon"),
        pszIconLocation, cchIconLocation);
}

///////////////////////////////////////////////////////////////////////////////
//

// Return values:
//      S_FALSE: Did not find it
//      S_OK:    Found it
//
// If finds it, the subkey is appended to pszKey

HRESULT _CheckForSubKeyExistence(LPWSTR pszKey, DWORD cchKey, LPCWSTR pszSubKey)
{
    LPWSTR pszNext;
    DWORD cchLeft;

    HRESULT hr = SafeStrCatNEx(pszKey, TEXT("\\"), cchKey, &pszNext,
        &cchLeft);

    if (SUCCEEDED(hr))
    {
        hr = SafeStrCpyNEx(pszNext, pszSubKey, cchLeft, &pszNext,
            &cchLeft);

        if (SUCCEEDED(hr))
        {
            // Check if it exist
            HKEY hkey;

            hr = _RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                _RegCloseKey(hkey);
            }
        }
    }
    
    return hr;
}

HRESULT _GetDevicePropertySize(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pcbSize)
{
    // Instance
    DEVINST devinst;

    HRESULT hr = phwdevinst->GetDeviceInstance(&devinst);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        BYTE rgb[1];
        ULONG ulData = sizeof(rgb);
        ULONG ulFlags = 0;

        if (fUseMergeMultiSz)
        {
            ulFlags = CM_CUSTOMDEVPROP_MERGE_MULTISZ;
        }

        CONFIGRET cr = CM_Get_DevNode_Custom_Property(devinst, pszPropName,
            NULL, rgb, &ulData, ulFlags);

        if (CR_SUCCESS != cr)
        {
            if (CR_BUFFER_SMALL == cr)
            {
                hr = S_OK;

                *pcbSize = ulData;
            }
            else
            {
                // If we do not have the data at the instance level, let's try it
                // at the DeviceGroup level.

                // DeviceGroup
                WCHAR szDeviceGroup[MAX_DEVICEGROUP];

                ulData = sizeof(szDeviceGroup);
                cr = CM_Get_DevNode_Custom_Property(devinst, TEXT("DeviceGroup"),
                    NULL, (PBYTE)szDeviceGroup, &ulData, 0);

                if (CR_SUCCESS == cr)
                {
                    WCHAR szKey[MAX_KEY] =
                        SHDEVICEEVENTROOT(TEXT("DeviceGroups\\"));
            
                    hr = SafeStrCatN(szKey, szDeviceGroup, ARRAYSIZE(szKey));

                    if (SUCCEEDED(hr))
                    {
                        hr = _GetPropertySizeHelper(szKey, pszPropName,
                            pcbSize);
                    }
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }
    }

    if (S_FALSE == hr)
    {
        // If we do not have the data at the instance level, nor the device
        // group level, let's try it at the DeviceClass level.

        // DeviceClass
        GUID guidInterface;

        hr = phwdevinst->GetInterfaceGUID(&guidInterface);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szKey[MAX_KEY];
            LPWSTR pszNext;
            DWORD cchLeft;

            hr = SafeStrCpyNEx(szKey,
                SHDEVICEEVENTROOT(TEXT("DeviceClasses\\")), ARRAYSIZE(szKey),
                &pszNext, &cchLeft);

            if (SUCCEEDED(hr))
            {
                hr = _StringFromGUID(&guidInterface, pszNext, cchLeft);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _GetPropertySizeHelper(szKey, pszPropName, pcbSize);
                }
            }
        }
    }

    return hr;
}

HRESULT _GetDevicePropertyGeneric(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pdwType, LPBYTE pbData,
    DWORD cbData)
{
    // Instance
    DEVINST devinst;

    HRESULT hr = phwdevinst->GetDeviceInstance(&devinst);

    if (CHWEventDetectorHelper::_fDiagnosticAppPresent)
    {
        WCHAR szPnpID[MAX_PNPID];
        WCHAR szGUID[MAX_GUIDSTRING];
        GUID guid;

        HRESULT hrTmp = phwdevinst->GetPnpID(szPnpID, ARRAYSIZE(szPnpID));

        if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
        {
            DIAGNOSTIC((TEXT("[0269]Device PnP ID: %s"), szPnpID));
        }

        hrTmp = phwdevinst->GetInterfaceGUID(&guid);

        if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
        {
            hrTmp = _StringFromGUID(&guid, szGUID, ARRAYSIZE(szGUID));

            if (SUCCEEDED(hrTmp))
            {
                DIAGNOSTIC((TEXT("[0270]Device Class ID: %s"), szGUID));
            }
        }
    }

    *pdwType = 0;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        ULONG ulData = cbData;
        ULONG ulType;
        ULONG ulFlags = 0;

        if (fUseMergeMultiSz)
        {
            ulFlags = CM_CUSTOMDEVPROP_MERGE_MULTISZ;
        }

        CONFIGRET cr = CM_Get_DevNode_Custom_Property(devinst, pszPropName,
            &ulType, pbData, &ulData, ulFlags);

        if (CR_SUCCESS != cr)
        {
            // If we do not have the data at the instance level, let's try it
            // at the DeviceGroup level.

            // DeviceGroup
            WCHAR szDeviceGroup[MAX_DEVICEGROUP];

            DIAGNOSTIC((TEXT("[0252]Did NOT get Custom Property (%s) at device instance level"),
                pszPropName));

            ulData = sizeof(szDeviceGroup);
            cr = CM_Get_DevNode_Custom_Property(devinst, TEXT("DeviceGroup"),
                NULL, (PBYTE)szDeviceGroup, &ulData, 0);

            if (CR_SUCCESS == cr)
            {
                WCHAR szKey[MAX_KEY] =
                    SHDEVICEEVENTROOT(TEXT("DeviceGroups\\"));
            
                hr = SafeStrCatN(szKey, szDeviceGroup, ARRAYSIZE(szKey));

                if (SUCCEEDED(hr))
                {
                    hr = _GetPropertyHelper(szKey, pszPropName, pdwType,
                        pbData, cbData);

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            DIAGNOSTIC((TEXT("[0253]Got Custom Property (%s) at DeviceGroup level (%s)"),
                                pszPropName, szDeviceGroup));
                        }
                        else
                        {
                            DIAGNOSTIC((TEXT("[0254]Did NOT get Custom Property (%s) at DeviceGroup level (%s)"),
                                pszPropName, szDeviceGroup));
                        }
                    }
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0251]Got Custom Property (%s) at device instance level"), pszPropName));
            *pdwType = (DWORD)ulType;
        }
    }

    if (S_FALSE == hr)
    {
        // If we do not have the data at the instance level, nor the device
        // group level, let's try it at the DeviceClass level.

        // DeviceClass
        GUID guidInterface;

        hr = phwdevinst->GetInterfaceGUID(&guidInterface);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            WCHAR szKey[MAX_KEY];
            LPWSTR pszNext;
            DWORD cchLeft;

            hr = SafeStrCpyNEx(szKey,
                SHDEVICEEVENTROOT(TEXT("DeviceClasses\\")), ARRAYSIZE(szKey),
                &pszNext, &cchLeft);

            if (SUCCEEDED(hr))
            {
                hr = _StringFromGUID(&guidInterface, pszNext, cchLeft);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _GetPropertyHelper(szKey, pszPropName, pdwType,
                        pbData, cbData);

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            DIAGNOSTIC((TEXT("[0255]Got Custom Property (%s) at DeviceClass level (%s)"),
                                pszPropName, pszNext));
                        }
                        else
                        {
                            DIAGNOSTIC((TEXT("[0256]Did NOT get Custom Property (%s) at DeviceClass level (%s)"),
                                pszPropName, pszNext));
                        }
                    }
                }
            }
        }
    }

    return hr;
}

HRESULT _GetDevicePropertyAsString(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, LPCWSTR psz, DWORD cch)
{
    DWORD dwType;
    DWORD cbData = cch * sizeof(WCHAR);

    return _GetDevicePropertyGeneric(phwdevinst, pszPropName, FALSE, &dwType,
        (PBYTE)psz, cbData);
}

HRESULT _GetDevicePropertyGenericAsMultiSz(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, WORD_BLOB** ppblob)
{
    DWORD cbSize = NULL;
    HRESULT hr = _GetDevicePropertySize(phwdevinst, pszPropName, FALSE,
        &cbSize);

    *ppblob = NULL;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        WORD_BLOB* pblob = (WORD_BLOB*)CoTaskMemAlloc(
            sizeof(WORD_BLOB) + cbSize + sizeof(WCHAR));

        if (pblob)
        {
            DWORD dwType;
            DWORD cbSize2 = cbSize + sizeof(WCHAR);

            pblob->clSize = (cbSize + sizeof(WCHAR))/2;

            hr = _GetDevicePropertyGeneric(phwdevinst, pszPropName,
                fUseMergeMultiSz, &dwType, (PBYTE)(pblob->asData),
                cbSize2);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (REG_MULTI_SZ == dwType)
                {
                    DIAGNOSTIC((TEXT("[0265]Found Property: '%s'"), pszPropName));
                    *ppblob = pblob;
                    pblob = NULL;
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0266]Found Property: '%s', but NOT REG_MULTI_SZ type"), pszPropName));
                    hr = E_FAIL;
                }
            }

            if (pblob)
            {
                // It did not get assigned
                CoTaskMemFree(pblob);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT _GetDevicePropertyGenericAsBlob(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BYTE_BLOB** ppblob)
{
    DWORD cbSize = NULL;
    HRESULT hr = _GetDevicePropertySize(phwdevinst, pszPropName, FALSE,
        &cbSize);

    *ppblob = NULL;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        BYTE_BLOB* pblob = (BYTE_BLOB*)CoTaskMemAlloc(
            sizeof(BYTE_BLOB) + cbSize);

        if (pblob)
        {
            DWORD dwType;

            pblob->clSize = cbSize;

            hr = _GetDevicePropertyGeneric(phwdevinst, pszPropName,
                FALSE, &dwType, (PBYTE)pblob->abData, pblob->clSize);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (REG_BINARY == dwType)
                {
                    DIAGNOSTIC((TEXT("[0267]Found Property: '%s'"), pszPropName));

                    *ppblob = pblob;
                    pblob = NULL;
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0268]Found Property: '%s', but NOT REG_BINARY type"), pszPropName));

                    hr = E_FAIL;
                }
            }

            if (pblob)
            {
                // It did not get assigned
                CoTaskMemFree(pblob);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT _GetDevicePropertyStringNoBuf(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pdwType,
    LPWSTR* ppszProp)
{
    DWORD cbSize = NULL;
    HRESULT hr = _GetDevicePropertySize(phwdevinst, pszPropName, FALSE,
        &cbSize);

    *ppszProp = NULL;

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        LPWSTR psz;

        cbSize += sizeof(WCHAR);

        psz = (LPWSTR)CoTaskMemAlloc(cbSize);

        if (psz)
        {
            hr = _GetDevicePropertyGeneric(phwdevinst, pszPropName,
                fUseMergeMultiSz, pdwType, (PBYTE)psz, cbSize);

            if (FAILED(hr) || (S_FALSE == hr))
            {
                CoTaskMemFree(psz);
            }
            else
            {
                *ppszProp = psz;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

// Return Values:
//      S_FALSE: Can't find it

HRESULT _GetDeviceHandler(CHWDeviceInst* phwdevinst, LPWSTR pszDeviceHandler,
    DWORD cchDeviceHandler)
{
    return _GetDevicePropertyAsString(phwdevinst, TEXT("DeviceHandlers"),
        pszDeviceHandler, cchDeviceHandler);
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _OpenHandlerRegKey(LPCWSTR pszHandler, HKEY* phkey)
{
    WCHAR szKey[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("Handlers\\"));
    HRESULT hr = SafeStrCatN(szKey, pszHandler, ARRAYSIZE(szKey));

    if (SUCCEEDED(hr))
    {
        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKey, phkey);
    }

    return hr;
}

HRESULT _CloseHandlerRegKey(HKEY hkey)
{
    return _RegCloseKey(hkey);
}

HRESULT _GetHandlerCancelCLSID(LPCWSTR pszHandler, CLSID* pclsid)
{
    HKEY hkey;
    HRESULT hr = _OpenHandlerRegKey(pszHandler, &hkey);

    if (SUCCEEDED(hr))
    {
        WCHAR szProgID[MAX_PROGID];

        hr = _RegQueryString(hkey, NULL, TEXT("CLSIDForCancel"), szProgID,
            ARRAYSIZE(szProgID));

        if (SUCCEEDED(hr))
        {
            if (S_FALSE != hr)
            {
                hr = _GUIDFromString(szProgID, pclsid);

                DIAGNOSTIC((TEXT("[0162]Got Handler Cancel CLSID (from CLSIDForCancel): %s"), szProgID));
                TRACE(TF_SHHWDTCTDTCTREG, TEXT("Got Handler Cancel CLSID"));
            }
            else
            {
                hr = _GetHandlerCLSID(pszHandler, pclsid);

                if (CHWEventDetectorHelper::_fDiagnosticAppPresent)
                {
                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            hr = _StringFromGUID(pclsid, szProgID, ARRAYSIZE(szProgID));

                            if (SUCCEEDED(hr))
                            {
                                DIAGNOSTIC((TEXT("[0164]Got Handler Cancel CLSID: %s"), szProgID));
                            }
                        }
                    }
                }
            }
        }

        _CloseHandlerRegKey(hkey);
    }

    return hr;
}

HRESULT _GetHandlerCLSID(LPCWSTR pszHandler, CLSID* pclsid)
{
    HKEY hkey;
    HRESULT hr = _OpenHandlerRegKey(pszHandler, &hkey);

    if (SUCCEEDED(hr))
    {
        WCHAR szProgID[MAX_PROGID];

        hr = _RegQueryString(hkey, NULL, TEXT("ProgID"), szProgID,
            ARRAYSIZE(szProgID));

        if (SUCCEEDED(hr))
        {
            if (S_FALSE != hr)
            {
                hr = CLSIDFromProgID(szProgID, pclsid);

                DIAGNOSTIC((TEXT("[0160]Got Handler ProgID: %s"), szProgID));

                TRACE(TF_SHHWDTCTDTCTREG, TEXT("Got Handler ProgID: %s"),
                    szProgID);
            }
            else
            {
                // Not there, maybe we have CLSID value?
                // Reuse szProgID
                hr = _RegQueryString(hkey, NULL, TEXT("CLSID"), szProgID,
                    ARRAYSIZE(szProgID));

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _GUIDFromString(szProgID, pclsid);

                    DIAGNOSTIC((TEXT("[0161]Got Handler CLSID: %s"), szProgID));
                    TRACE(TF_SHHWDTCTDTCTREG, TEXT("Got Handler CLSID"));
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0163]Did NOT get Handler ProgID or CLSID")));
                }
            }
        }

        _CloseHandlerRegKey(hkey);
    }

    return hr;
}

// Return values:
//      S_FALSE: Cannot find an InitCmdLine
//
HRESULT _GetInitCmdLine(LPCWSTR pszHandler, LPWSTR* ppsz)
{
    HKEY hkey;
    HRESULT hr = _OpenHandlerRegKey(pszHandler, &hkey);

    *ppsz = NULL;

    if (SUCCEEDED(hr))
    {
        DWORD cb = NULL;
        hr = _RegQueryValueSize(hkey, NULL, TEXT("InitCmdLine"), &cb);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            LPWSTR psz = (LPWSTR)LocalAlloc(LPTR, cb);

            if (psz)
            {
                hr = _RegQueryString(hkey, NULL, TEXT("InitCmdLine"), psz,
                    cb / sizeof(WCHAR));

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    DIAGNOSTIC((TEXT("[0158]Got InitCmdLine for Handler (%s): '%s'"), pszHandler, psz));

                    *ppsz = psz;
                }
                else
                {
                    LocalFree((HLOCAL)psz);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0159]NO InitCmdLine for Handler (%s)"), pszHandler));
        }

        _CloseHandlerRegKey(hkey);
    }

    return hr;
}

HRESULT _MakeUserDefaultValueString(LPCWSTR pszDeviceID,
    LPCWSTR pszEventHandler, LPWSTR pszUserDefault, DWORD cchUserDefault)
{
    DWORD cchLeft;
    LPWSTR pszNext;
    HRESULT hr = SafeStrCpyNEx(pszUserDefault, pszDeviceID, cchUserDefault,
        &pszNext, &cchLeft);

    if (SUCCEEDED(hr))
    {
        hr = SafeStrCpyNEx(pszNext, TEXT("+"), cchLeft, &pszNext, &cchLeft);

        if (SUCCEEDED(hr))
        {
            hr = SafeStrCpyN(pszNext, pszEventHandler, cchLeft);
        }
    }

    return hr;
}

// from setenum.cpp
HRESULT _GetKeyLastWriteTime(LPCWSTR pszHandler, FILETIME* pft);

HRESULT _HaveNewHandlersBeenInstalledSinceUserSelection(LPCWSTR pszEventHandler,
    FILETIME* pftUserSelection, BOOL* pfNewHandlersSinceUserSelection)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlers\\"));
    HRESULT hr = SafeStrCatN(szKeyName, pszEventHandler,
        ARRAYSIZE(szKeyName));

    ULARGE_INTEGER ulUserSelection;
    ulUserSelection.LowPart = pftUserSelection->dwLowDateTime;
    ulUserSelection.HighPart = pftUserSelection->dwHighDateTime;

    *pfNewHandlersSinceUserSelection = FALSE;

    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            DWORD dw = 0;
            BOOL fGoOut = FALSE;

            do
            {
                WCHAR szHandler[MAX_HANDLER];
                hr = _RegEnumStringValue(hkey, dw, szHandler,
                    ARRAYSIZE(szHandler));

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    FILETIME ft;

                    hr = _GetKeyLastWriteTime(szHandler, &ft);
                    
                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        ULARGE_INTEGER ul;
                        ul.LowPart = ft.dwLowDateTime;
                        ul.HighPart = ft.dwHighDateTime;

                        if (ul.QuadPart > ulUserSelection.QuadPart)
                        {
                            *pfNewHandlersSinceUserSelection = TRUE;
                            hr = S_OK;
                            fGoOut = TRUE;
                        }
                    }
                }
                else
                {
                    fGoOut = TRUE;
                }

                ++dw;
            }
            while (!fGoOut);

            if (S_FALSE == hr)
            {
                hr = S_OK;
            }

            _RegCloseKey(hkey);
        }
    }
   
    return hr;
}

struct _USERSELECTIONHIDDENDATA
{
    _USERSELECTIONHIDDENDATA() : dw(0) {}

    FILETIME    ft;
    // Set this to zero so that RegSetValueEx will not NULL terminate out stuff 
    DWORD       dw;
};

// See comment for _MakeFinalUserDefaultHandler
HRESULT _GetHandlerAndFILETIME(HKEY hkeyUser, LPCWSTR pszKeyName,
    LPCWSTR pszUserDefault, LPWSTR pszHandler, DWORD cchHandler, FILETIME* pft)
{
    DWORD cb;    
    HRESULT hr = _RegQueryValueSize(hkeyUser, pszKeyName, pszUserDefault, &cb);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        BYTE* pb = (BYTE*)LocalAlloc(LPTR, cb);

        if (pb)
        {
            hr = _RegQueryGeneric(hkeyUser, pszKeyName, pszUserDefault, pb,
                cb);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                // We should have something like this:
                // MyHandler\0<_USERSELECTIONHIDDENDATA struct>
                hr = StringCchCopy(pszHandler, cchHandler, (LPWSTR)pb);

                if (SUCCEEDED(hr))
                {
                    DWORD cbString = (lstrlen(pszHandler) + 1) * sizeof(WCHAR);

                    // Make sure we're dealing with the right thing
                    if ((cb >= cbString + sizeof(_USERSELECTIONHIDDENDATA)) &&
                        (cb <= cbString + sizeof(_USERSELECTIONHIDDENDATA) + sizeof(void*)))
                    {
                        // Yep!  So _USERSELECTIONHIDDENDATA should be at the end of the blob
                        _USERSELECTIONHIDDENDATA* pushd = (_USERSELECTIONHIDDENDATA*)
                            (pb + (cb - sizeof(_USERSELECTIONHIDDENDATA)));

                        *pft = pushd->ft;
                    }
                    else
                    {
                        *pszHandler = 0;
                        hr = S_FALSE;
                    }
                }
            }

            LocalFree(pb);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT _GetEventHandlerDefault(HKEY hkeyUser, LPCWSTR pszEventHandler,
    LPWSTR pszHandler, DWORD cchHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlersDefaultSelection\\"));

    return _RegQueryString(hkeyUser, szKeyName, pszEventHandler, pszHandler,
            cchHandler);
}

HRESULT _GetUserDefaultHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventHandler,
    LPWSTR pszHandler, DWORD cchHandler, BOOL fImpersonateCaller)
{
    WCHAR szUserDefault[MAX_USERDEFAULT] = TEXT("H:");
    HRESULT hr = _MakeUserDefaultValueString(pszDeviceID, pszEventHandler,
        &(szUserDefault[2]), ARRAYSIZE(szUserDefault) - 2);

    if (cchHandler)
    {
        *pszHandler = 0;
    }

    if (SUCCEEDED(hr))
    {
        WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("UserChosenExecuteHandlers\\"));
        HKEY hkeyUser;
        HANDLE hThreadToken;

        if (GUH_IMPERSONATEUSER == fImpersonateCaller)
        {
            hr = _CoGetCallingUserHKCU(&hThreadToken, &hkeyUser);
        }
        else
        {
            hr = _GetCurrentUserHKCU(&hThreadToken, &hkeyUser);
        }

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            FILETIME ft;
            DWORD dwHandlerDefaultFlag = 0;

            hr = _GetHandlerAndFILETIME(hkeyUser, szKeyName,
                szUserDefault, pszHandler, cchHandler, &ft);

            if (SUCCEEDED(hr))
            {
                if (S_FALSE == hr)
                {
                    // we do not have a UserChosenDefault
                    hr = SafeStrCpyN(pszHandler, TEXT("MSPromptEachTime"),
                        cchHandler);
                }
                else
                {
                    // we have a user chosen default
                    dwHandlerDefaultFlag |= HANDLERDEFAULT_USERCHOSENDEFAULT;
                }
            }

            if (SUCCEEDED(hr))
            {
                if (HANDLERDEFAULT_USERCHOSENDEFAULT & dwHandlerDefaultFlag)
                {
                    BOOL fNewHandlersSinceUserSelection;
                    hr = _HaveNewHandlersBeenInstalledSinceUserSelection(
                        pszEventHandler, &ft, &fNewHandlersSinceUserSelection);

                    if (SUCCEEDED(hr))
                    {
                        if (fNewHandlersSinceUserSelection)
                        {
                            dwHandlerDefaultFlag |=
                                HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED;
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                BOOL fUseEventHandlerDefault = FALSE;

                if (!(HANDLERDEFAULT_USERCHOSENDEFAULT & dwHandlerDefaultFlag))
                {
                    fUseEventHandlerDefault = TRUE;
                }
                else
                {
                    if (HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED &
                        dwHandlerDefaultFlag)
                    {
                        fUseEventHandlerDefault = TRUE;
                    }
                }

                if (fUseEventHandlerDefault)
                {
                    WCHAR szHandlerLocal[MAX_HANDLER];
                    hr = _GetEventHandlerDefault(hkeyUser, pszEventHandler,
                        szHandlerLocal, ARRAYSIZE(szHandlerLocal));

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE != hr)
                        {
                            dwHandlerDefaultFlag |=
                                HANDLERDEFAULT_EVENTHANDLERDEFAULT;

                            if (HANDLERDEFAULT_USERCHOSENDEFAULT &
                                dwHandlerDefaultFlag)
                            {
                                if (lstrcmp(szHandlerLocal, pszHandler))
                                {
                                    dwHandlerDefaultFlag |=
                                        HANDLERDEFAULT_DEFAULTSAREDIFFERENT;
                                }
                            }
                            else
                            {
                                dwHandlerDefaultFlag |=
                                    HANDLERDEFAULT_DEFAULTSAREDIFFERENT;
                            }

                            hr = StringCchCopy(pszHandler, cchHandler,
                                szHandlerLocal);
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Let's build the return value
                hr = HANDLERDEFAULT_MAKERETURNVALUE(dwHandlerDefaultFlag);
            }

            if (GUH_IMPERSONATEUSER == fImpersonateCaller)
            {
                _CoCloseCallingUserHKCU(hThreadToken, hkeyUser);
            }
            else
            {
                _CloseCurrentUserHKCU(hThreadToken, hkeyUser);
            }
        }
    }

    return hr;
}

HRESULT _GetHandlerForNoContent(LPCWSTR pszEventHandler, LPWSTR pszHandler,
    DWORD cchHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlers\\"));
    HRESULT hr = SafeStrCatN(szKeyName, pszEventHandler, ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr))
    {
        hr = _GetValueToUse(szKeyName, pszHandler, cchHandler);
    }

    return hr;
}

// We want to store the time this default is set.  We'll need it to check if
// other handlers for this event were installed after the user made a choice.
// If that's the case, we'll reprompt the user.
// *!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!
// We store the time as a FILETIME *after* the '\0' string terminator.  This is
// so it will be hidden in RegEdit.
// stephstm (2002-04-12)
// *!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!
HRESULT _MakeFinalUserDefaultHandler(LPCWSTR pszHandler, BYTE** ppb,
    DWORD* pcb)
{
    HRESULT hr;
    DWORD cch = lstrlen(pszHandler) + 1;
    
    DWORD cbOffset = cch * sizeof(WCHAR);

    // Round up to be aligned on all platforms
    cbOffset = (cbOffset + sizeof(void*)) / sizeof(void*) * sizeof(void*);

    DWORD cb = cbOffset + sizeof(_USERSELECTIONHIDDENDATA);

    BYTE* pb = (BYTE*)LocalAlloc(LPTR, cb);

    if (pb)
    {
        hr = StringCchCopy((LPWSTR)pb, cch, pszHandler);

        if (SUCCEEDED(hr))
        {
            _USERSELECTIONHIDDENDATA ushd;

            GetSystemTimeAsFileTime(&(ushd.ft));

            CopyMemory(pb + cb - sizeof(_USERSELECTIONHIDDENDATA), &ushd,
                sizeof(ushd));
        }

        if (SUCCEEDED(hr))
        {
            *ppb = pb;
            *pcb = cb;
        }
        else
        {
            LocalFree(pb);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT _DeleteUserDefaultHandler(HKEY hkeyUser, LPCWSTR pszDeviceID,
    LPCWSTR pszEventHandler)
{
    WCHAR szUserDefault[MAX_USERDEFAULT] = TEXT("H:");
    HRESULT hr = _MakeUserDefaultValueString(pszDeviceID, pszEventHandler,
        &(szUserDefault[2]), ARRAYSIZE(szUserDefault) - 2);

    if (SUCCEEDED(hr))
    {
        WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("UserChosenExecuteHandlers\\"));

        hr = _RegDeleteValue(hkeyUser, szKeyName, szUserDefault);
    }

    return hr;
}

HRESULT _SetSoftUserDefaultHandler(LPCWSTR pszDeviceID,
    LPCWSTR pszEventHandler, LPCWSTR pszHandler)
{
    HKEY hkey;
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlersDefaultSelection\\"));

    HKEY hkeyUser;
    HANDLE hThreadToken;

    HRESULT hr = _CoGetCallingUserHKCU(&hThreadToken, &hkeyUser);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        DWORD dwDisp;

        hr = _RegCreateKey(hkeyUser, szKeyName, &hkey, &dwDisp);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _RegSetString(hkey, pszEventHandler, pszHandler);

            _DeleteUserDefaultHandler(hkeyUser, pszDeviceID, pszEventHandler);

            _RegCloseKey(hkey);
        }

        _CoCloseCallingUserHKCU(hThreadToken, hkeyUser);
    }

    return hr;
}

HRESULT _DeleteSoftUserDefaultHandler(HKEY hkeyUser, LPCWSTR pszEventHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlersDefaultSelection\\"));

    return _RegDeleteValue(hkeyUser, szKeyName, pszEventHandler);
}

HRESULT _SetUserDefaultHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventHandler,
    LPCWSTR pszHandler)
{
    WCHAR szUserDefault[MAX_USERDEFAULT] = TEXT("H:");
    HRESULT hr = _MakeUserDefaultValueString(pszDeviceID, pszEventHandler,
        &(szUserDefault[2]), ARRAYSIZE(szUserDefault) - 2);

    if (SUCCEEDED(hr))
    {
        HKEY hkey;
        WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("UserChosenExecuteHandlers\\"));

        HKEY hkeyUser;
        HANDLE hThreadToken;

        hr = _CoGetCallingUserHKCU(&hThreadToken, &hkeyUser);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (!lstrcmp(pszHandler, TEXT("MSPromptEachTime")))
            {
                hr = _DeleteUserDefaultHandler(hkeyUser, pszDeviceID,
                    pszEventHandler);
            }
            else
            {
                DWORD dwDisp;

                hr = _RegCreateKey(hkeyUser, szKeyName, &hkey, &dwDisp);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    BYTE* pb;
                    DWORD cb;

                    hr = _MakeFinalUserDefaultHandler(pszHandler, &pb, &cb);

                    if (SUCCEEDED(hr))
                    {
                        // See comment above _MakeFinalUserDefaultHandler
                        // StephStm: 2002-04-09
                        if (ERROR_SUCCESS == RegSetValueEx(hkey, szUserDefault, 0,
                            REG_SZ, pb, cb))
                        {
                            _DeleteSoftUserDefaultHandler(hkeyUser,
                                pszEventHandler);

                            hr = S_OK;
                        }
                        else
                        {
                            hr = S_FALSE;
                        }

                        LocalFree(pb);
                    }

                    _RegCloseKey(hkey);
                }
            }

            _CoCloseCallingUserHKCU(hThreadToken, hkeyUser);
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\dtctu.cpp ===
#include "dtct.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY hweventdetectorIME[] =
{
    _INTFMAPENTRY(CHWEventDetector, IService),
};

const INTFMAPENTRY* CHWEventDetector::_pintfmap = hweventdetectorIME;
const DWORD CHWEventDetector::_cintfmap =
    (sizeof(hweventdetectorIME)/sizeof(hweventdetectorIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHWEventDetector::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\dtctimp.cpp ===
#include "dtct.h"

#include "fact.h"

#include "vol.h"
#include "hnotif.h"
#include "miscdev.h"
#include "dtctreg.h"
#include "regnotif.h"

#include "cmmn.h"
#include "sfstr.h"
#include "misc.h"
#include "str.h"

#include "dbg.h"
#include "tfids.h"

#include <ioevent.h>
#include <dbt.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
HRESULT _HandleDeviceEvent(LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst,
    LPCWSTR pszEventType, BOOL* pfHasHandler)
{
    HRESULT hres = _DispatchToHandler(pszDeviceIntfID, phwdevinst,
        pszEventType, pfHasHandler);

    if (SUCCEEDED(hres))
    {
        TRACE(TF_SHHWDTCTDTCT, TEXT("_DispatchToHandler SUCCEEDED"));
    }
    else
    {
        TRACE(TF_SHHWDTCTDTCT, TEXT("_DispatchToHandler FAILED: 0x%08X"),
            hres);

        hres = S_FALSE;
    }

    return hres;
}

// {A5DCBF10-6530-11D2-901F-00C04FB951ED}
const CLSID guidInterfaceUSB =
    {0xA5DCBF10, 0x6530, 0x11D2,
    {0x90, 0x1F, 0x00, 0xC0, 0x4F, 0xB9, 0x51, 0xED}};

// {53F5630A-B6BF-11D0-94F2-00A0C91EFB8B}
const CLSID guidInterfacePartition =
    {0x53F5630A, 0xB6BF, 0x11D0,
    {0x94, 0xF2, 0x00, 0xA0, 0xC9, 0x1E, 0xFB, 0x8B}};

HRESULT _IsInterfaceInList(const GUID* pguidInterface, const CLSID* rgList[], DWORD cList,
    BOOL* pfPresent)
{
    *pfPresent = FALSE;

    for (DWORD dw = 0; !(*pfPresent) && (dw < cList); ++dw)
    {
        if (*(rgList[dw]) == *pguidInterface)
        {
            *pfPresent = TRUE;
        }
    }

    return S_OK;
}

const CLSID* _rgpguidRejectedInterface[] =
{
    &guidInterfacePartition,
};

HRESULT _IsInterfaceRejected(GUID* pguidInterface, BOOL* pfRejected)
{
    return _IsInterfaceInList(pguidInterface, _rgpguidRejectedInterface,
        ARRAYSIZE(_rgpguidRejectedInterface), pfRejected);
}

const CLSID* _rgpguidSpecialInterface[] =
{
    &guidInterfaceUSB,
};

HRESULT _IsInterfaceSpecial(GUID* pguidInterface, BOOL* pfSpecial)
{
    return _IsInterfaceInList(pguidInterface, _rgpguidSpecialInterface,
        ARRAYSIZE(_rgpguidRejectedInterface), pfSpecial);
}

HRESULT _TryAutoplay(LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst,
    DWORD dwEventType)
{
    LPCWSTR pszEventType = NULL;
    HRESULT hres;

    if (DBT_DEVICEARRIVAL == dwEventType)
    {
        pszEventType = TEXT("DeviceArrival");
    }   
    else
    {
        if (DBT_DEVICEREMOVECOMPLETE == dwEventType)
        {
            pszEventType = TEXT("DeviceRemoval");
        }   
        else
        {
            ASSERT(FALSE);
        }
    }

    if (pszEventType)
    {
        // Useless in this case
        BOOL fHasHandler;

        hres = _HandleDeviceEvent(pszDeviceIntfID, phwdevinst,
            pszEventType, &fHasHandler);
    }
    else
    {
        hres = S_FALSE;
    }

    return hres;
}

const CLSID* _rgpguidRequiringAdviseInterface[] =
{
    &guidInterfaceUSB,
    &guidVideoCameraClass,
    &guidImagingDeviceClass,
};

HRESULT _IsInterfaceRequiringAdvise(GUID* pguidInterface, BOOL* pfRequiringAdvise)
{
    return _IsInterfaceInList(pguidInterface, _rgpguidRequiringAdviseInterface,
        ARRAYSIZE(_rgpguidRequiringAdviseInterface), pfRequiringAdvise);
}

// If it's one of the few interfaces requiring advise, or if the device has a
// DeviceHandler we send notifications
HRESULT _AdviseDeviceArrivedOrRemovedHelper(GUID* pguidInterface,
    LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst, DWORD dwEventType)
{
    BOOL fAdvise;
    HRESULT hr = _IsInterfaceRequiringAdvise(pguidInterface, &fAdvise);

    // This should never get here
    ASSERT(guidVolumeClass != *pguidInterface);

    if (SUCCEEDED(hr))
    {
        DWORD dwDeviceFlags = HWDDF_HASDEVICEHANDLER_UNDETERMINED;

        if (phwdevinst)
        {
            WCHAR szDeviceHandler[MAX_DEVICEHANDLER];
            HRESULT hrTmp = _GetDeviceHandler(phwdevinst, szDeviceHandler,
                ARRAYSIZE(szDeviceHandler));

            if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
            {
                fAdvise = TRUE;
                dwDeviceFlags &= ~HWDDF_HASDEVICEHANDLER_UNDETERMINED;
                dwDeviceFlags |= HWDDF_HASDEVICEHANDLER;
            }
        }

        if (fAdvise)
        {
            BOOL fRemovableDevice;
            LPCWSTR pszDeviceEvent;

            if (DBT_DEVICEARRIVAL == dwEventType)
            {
                pszDeviceEvent = TEXT("DeviceArrival");
            }
            else
            {
                ASSERT(DBT_DEVICEREMOVECOMPLETE == dwEventType);

                pszDeviceEvent = TEXT("DeviceRemoval");
            }

            dwDeviceFlags |= HWDDF_REMOVABLEDEVICE_UNDETERMINED;

            if (phwdevinst)
            {
                hr = phwdevinst->IsRemovableDevice(&fRemovableDevice);

                if (SUCCEEDED(hr))
                {
                    if (fRemovableDevice)
                    {
                        dwDeviceFlags &= ~HWDDF_REMOVABLEDEVICE_UNDETERMINED;
                        dwDeviceFlags |= HWDDF_REMOVABLEDEVICE;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = CHardwareDevicesImpl::_AdviseDeviceArrivedOrRemoved(
                    pszDeviceIntfID, pguidInterface, dwDeviceFlags,
                    pszDeviceEvent);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

HRESULT _ProcessInterface(GUID* pguidInterface, LPCWSTR pszDeviceIntfID,
    DWORD dwEventType)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_MISCDEVINTF, &pnel);

    if (SUCCEEDED(hr))
    {
        if (DBT_DEVICEARRIVAL == dwEventType)
        {
            CNamedElem* pelem;

            hr = pnel->GetOrAdd(pszDeviceIntfID, &pelem);

            if (SUCCEEDED(hr))
            {
                BOOL fRemoveFromList = TRUE;
                CMiscDeviceInterface* pmdi = (CMiscDeviceInterface*)pelem;

                // If we're adding it, let's finish its initialization
                hr = pmdi->InitInterfaceGUID(pguidInterface);

                if (SUCCEEDED(hr))
                {
                    CHWDeviceInst* phwdevinst;

                    hr = pmdi->GetHWDeviceInst(&phwdevinst);

                    if (SUCCEEDED(hr) && (S_FALSE != hr))
                    {
                        BOOL f;
                        
                        _AdviseDeviceArrivedOrRemovedHelper(pguidInterface,
                            pszDeviceIntfID, phwdevinst, dwEventType);

                        hr = phwdevinst->IsRemovableDevice(&f);

                        if (SUCCEEDED(hr) & f)
                        {
                            hr = _IsInterfaceSpecial(pguidInterface, &f);

                            if (SUCCEEDED(hr) & f)
                            {
                                hr = phwdevinst->ShouldAutoplayOnSpecialInterface(
                                    pguidInterface, &f);

                                if (FAILED(hr) || (S_FALSE == hr))
                                {
                                    f = FALSE;
                                }
                            }
                            else
                            {
                                f = TRUE;
                            }

                            if (f)
                            {
                                hr = _TryAutoplay(pszDeviceIntfID, phwdevinst,
                                    dwEventType);

                                fRemoveFromList = FALSE;
                            }
                        }
                    }
                }

                if (fRemoveFromList)
                {
                    hr = pnel->Remove(pszDeviceIntfID);
                }

                pelem->RCRelease();
            }
        }
        else
        {
            CNamedElem* pelem;

            hr = pnel->Get(pszDeviceIntfID, &pelem);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                CHWDeviceInst* phwdevinst;
                CMiscDeviceInterface* pmdi = (CMiscDeviceInterface*)pelem;
                hr = pmdi->GetHWDeviceInst(&phwdevinst);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    _AdviseDeviceArrivedOrRemovedHelper(pguidInterface,
                        pszDeviceIntfID, phwdevinst, dwEventType);

                    hr = _TryAutoplay(pszDeviceIntfID, phwdevinst,
                        dwEventType);

                    // If we're removing it, let's remove it from the list
                    HRESULT hr2 = pnel->Remove(pszDeviceIntfID);

                    hr = FAILED(hr2) ? hr2 : hr;
                }

                pelem->RCRelease();
            }
            else
            {
                _AdviseDeviceArrivedOrRemovedHelper(pguidInterface,
                    pszDeviceIntfID, NULL, dwEventType);
            }
        }

        pnel->RCRelease();
    }

    return hr;
}

HRESULT CHWEventDetectorImpl::_HandleInterfaceEvent(
    DEV_BROADCAST_DEVICEINTERFACE* pdbdi, DWORD dwEventType)
{
    HRESULT hres = S_FALSE;

    if (pdbdi->dbcc_name[0])
    {
        BOOL fSpecialCased;

        hres = _IsInterfaceSpecialCased(&(pdbdi->dbcc_classguid),
            &fSpecialCased);

        if (SUCCEEDED(hres))
        {
            if (fSpecialCased)
            {
                TRACE(TF_SHHWDTCTDTCT, TEXT("---> Special case"));

                hres = _ProcessInterfaceSpecialCased(&(pdbdi->dbcc_classguid),
                    pdbdi->dbcc_name, dwEventType);
            }
            else
            {
                if ((DBT_DEVICEARRIVAL == dwEventType) ||
                    (DBT_DEVICEREMOVECOMPLETE == dwEventType))
                {
                    BOOL fRejected;

                    hres = _IsInterfaceRejected(&(pdbdi->dbcc_classguid),
                        &fRejected);

                    if (SUCCEEDED(hres))
                    {
                        if (!fRejected)
                        {
                            TRACE(TF_SHHWDTCTDTCT, TEXT("---> Regular processing"));

                            hres = _ProcessInterface(&(pdbdi->dbcc_classguid),
                                pdbdi->dbcc_name, dwEventType);
                        }
                        else
                        {
                            TRACE(TF_SHHWDTCTDTCT, TEXT("---> Rejected"));
                        }
                    }
                }
                else
                {
                    TRACE(TF_SHHWDTCTDTCT, TEXT("---> Not deviceArrival/Removal"));
                }
            }
        }
    }
    else
    {
        // why do we get this?
    }

    return hres;
}

// This is for volumes only
// static
HRESULT CHWEventDetectorImpl::HandleVolumeMediaEvent(LPCWSTR pszDeviceIDVolume,
    CHWDeviceInst* phwdevinst, LPCWSTR pszEventType, 
    BOOL* pfHasHandler)
{
    return _HandleDeviceEvent(pszDeviceIDVolume, phwdevinst, pszEventType,
        pfHasHandler);
}

// This is for volumes only
HRESULT CHWEventDetectorImpl::_HandleBroadcastHandleEvent(
    DEV_BROADCAST_HANDLE* pdbh, DWORD dwEventType)
{
    HRESULT hres = S_OK;

    if (DBT_CUSTOMEVENT == dwEventType)
    {
        if ((GUID_IO_VOLUME_MOUNT == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_DISMOUNT == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_DISMOUNT_FAILED == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid) ||
            (GUID_IO_MEDIA_ARRIVAL == pdbh->dbch_eventguid) ||
            (GUID_IO_MEDIA_REMOVAL == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_CHANGE == pdbh->dbch_eventguid) ||
            (GUID_IO_VOLUME_NAME_CHANGE == pdbh->dbch_eventguid))
        {
            hres = CHandleNotif::HandleBroadcastHandleEvent(pdbh, dwEventType);
        }
        else
        {
#ifdef DEBUG
            WCHAR szGUID[MAX_GUIDSTRING];

            if (SUCCEEDED(_StringFromGUID(&(pdbh->dbch_eventguid), szGUID,
                ARRAYSIZE(szGUID))))
            {
                TRACE(TF_SHHWDTCTDTCT,
                    TEXT("UNHANDLED! DBT_CUSTOMEVENT + %s for '0x%08X'"),
                    szGUID, pdbh->dbch_handle);
            }
#endif
        }
    }
    else
    {
        if ((DBT_DEVICEQUERYREMOVE == dwEventType) ||
            (DBT_DEVICEREMOVEPENDING == dwEventType) ||
            (DBT_DEVICEQUERYREMOVEFAILED == dwEventType) ||
            (DBT_DEVICEREMOVECOMPLETE == dwEventType))
        {
            hres = CHandleNotif::HandleBroadcastHandleEvent(pdbh, dwEventType);
        }
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHWEventDetectorImpl::_RegisterForNotif()
{
    HRESULT hres = CHWEventDetectorHelper::CreateLists();
    
    if (SUCCEEDED(hres))
    {
        hres = CHWEventDetectorHelper::FillLists();

        if (SUCCEEDED(hres))
        {
            // Register for all Device Interface Events
            DEV_BROADCAST_DEVICEINTERFACE dbdNotifFilter = {0};

            dbdNotifFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            dbdNotifFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
            dbdNotifFilter.dbcc_classguid = guidInvalid;

            hres = CHWEventDetectorHelper::RegisterDeviceNotification(
                &dbdNotifFilter, &_hdevnotifyAllInterfaces, TRUE);
        }
    }

    return hres;
}

HRESULT CHWEventDetectorImpl::_UnregisterForNotif()
{
    CHWEventDetectorHelper::EmptyLists();
    UnregisterDeviceNotification(_hdevnotifyAllInterfaces);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHWEventDetectorImpl::_RegisterFactories()
{
    // TRUE: we want it to stay around
    HRESULT hres = (CCOMBaseFactory::_RegisterFactories(TRUE) ? S_OK : E_FAIL);

    TRACE(TF_COMSERVER, TEXT("CHWEventDetectorImpl::_RegisterFactories returns: 0x%08X"), hres);

    return hres;
}

HRESULT CHWEventDetectorImpl::_UnregisterFactories()
{
    // TRUE: we wanted it to stay around
    HRESULT hres = (CCOMBaseFactory::_UnregisterFactories(TRUE) ? S_OK : E_FAIL);
    
    TRACE(TF_COMSERVER, TEXT("CHWEventDetectorImpl::_UnregisterFactories returns: 0x%08X"), hres);

    return hres;
}

HRESULT CHWEventDetectorImpl::_SuspendFactories()
{
    HRESULT hres = (CCOMBaseFactory::_SuspendFactories() ? S_OK : E_FAIL);
    
    TRACE(TF_COMSERVER, TEXT("CHWEventDetectorImpl::_SuspendFactories returns: 0x%08X"), hres);

    return hres;
}

HRESULT CHWEventDetectorImpl::_ResumeFactories()
{
    HRESULT hres = (CCOMBaseFactory::_ResumeFactories() ? S_OK : E_FAIL);
    
    TRACE(TF_COMSERVER, TEXT("CHWEventDetectorImpl::_ResumeFactories returns: 0x%08X"), hres);

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
CHWEventDetectorImpl::CHWEventDetectorImpl() : _hEventRelinquishControl(NULL),
    _hdevnotifyAllInterfaces(NULL), _hEventInitCompleted(NULL)
{}

CHWEventDetectorImpl::~CHWEventDetectorImpl()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\dtct.h ===
///////////////////////////////////////////////////////////////////////////////
// Hardware Event Detector
///////////////////////////////////////////////////////////////////////////////
#ifndef _SHHWDTCT_H
#define _SHHWDTCT_H

#include "unk.h"
#include "service.h"
#include "namellst.h"

#include <dbt.h>

#define HINT_NONE       0
#define HINT_NEW        1

extern const CLSID CLSID_HWEventDetector;

class CHWEventDetectorImpl : public CCOMBase, public IService
{
public:
    // Interface IService
    STDMETHODIMP InitMinimum(DWORD cArg, LPWSTR* ppszArgs,
        LPCWSTR pszEventRelinquishControl, DWORD* pdwCtrlAccept,
        BOOL* pfWantsDeviceEvents);
    STDMETHODIMP InitDeviceEventHandler(SERVICE_STATUS_HANDLE ssh);
    STDMETHODIMP InitFinal();

    STDMETHODIMP Run();

    // return S_FALSE and a non-zero dwWaitHint if pending
    STDMETHODIMP HandleServiceControl(DWORD dwControlCode, DWORD* pdwWaitHint);

    STDMETHODIMP HandlePowerEvent(DWORD dwEventType, LPVOID pEventData);
    STDMETHODIMP HandleDeviceEvent(DWORD dwEventType, LPVOID pEventData);
    STDMETHODIMP HandleHWProfileEvent(DWORD dwEventType, LPVOID pEventData);
    STDMETHODIMP HandleSessionChange(DWORD dwEventType, LPVOID pvEventData);

public:
    CHWEventDetectorImpl();
    ~CHWEventDetectorImpl();

    static HRESULT HandleVolumeMediaEvent(LPCWSTR pszDeviceIDVolume,
        class CHWDeviceInst* phwdevinst, LPCWSTR pszEventType,
        BOOL* pfHasHandler);

private:
    HRESULT _HandleInterfaceEvent(DEV_BROADCAST_DEVICEINTERFACE* pdbdi,
        DWORD dwEventType);
    HRESULT _HandleBroadcastHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType);

    HRESULT _RegisterForNotif();
    HRESULT _UnregisterForNotif();

    // COM Server stuff
    HRESULT _RegisterFactories();
    HRESULT _UnregisterFactories();
    HRESULT _SuspendFactories();
    HRESULT _ResumeFactories();

private:
    HANDLE                          _hEventRelinquishControl;
    HDEVNOTIFY                      _hdevnotifyAllInterfaces;
    HANDLE                          _hEventInitCompleted;

#ifdef DEBUG
    void _DbgAssertValidState();
#endif
};

typedef CUnkTmpl<CHWEventDetectorImpl> CHWEventDetector;

// for now
HRESULT _ExecuteHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPCWSTR pszHandler);

HRESULT _FinalDispatch(LPCWSTR pszDeviceIntfID, LPCWSTR pszEventType,
    LPCWSTR pszEventHandler);

HRESULT _DispatchToHandler(LPCWSTR pszDeviceIntfID,
    class CHWDeviceInst* phwdevinst, LPCWSTR pszEventType,
    BOOL* pfHasHandler);

HRESULT _ProcessInterfaceSpecialCased(GUID* pguidInterface,
    LPCWSTR pszDeviceID, DWORD dwEventType);
HRESULT _IsInterfaceSpecialCased(GUID* pguidClass, BOOL* pfSpecialCased);

HRESULT _TryAutoplay(LPCWSTR pszDeviceIntfID, CHWDeviceInst* phwdevinst,
    DWORD dwEventType);

#endif // _SHHWDTCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\dtctreg.h ===
#include <objbase.h>

class CHWDeviceInst;

//=============================================================================
HRESULT _GetEventHandlerFromDeviceHandler(LPCWSTR pszDeviceHandler,
    LPCWSTR pszEventType, LPWSTR pszEventHandler, DWORD cchEventHandler);

//=============================================================================
HRESULT _GetActionFromHandler(LPCWSTR pszHandler, LPWSTR pszAction,
    DWORD cchAction);

HRESULT _GetProviderFromHandler(LPCWSTR pszHandler, LPWSTR pszProvider,
    DWORD cchProvider);

HRESULT _GetIconLocationFromHandler(LPCWSTR pszHandler,
    LPWSTR pszIconLocation, DWORD cchIconLocation);

HRESULT _GetInvokeProgIDFromHandler(LPCWSTR pszHandler,
    LPWSTR pszInvokeProgID, DWORD cchInvokeProgID);

HRESULT _GetInvokeVerbFromHandler(LPCWSTR pszHandler,
    LPWSTR pszInvokeVerb, DWORD cchInvokeVerb);

// Uses the CTSTR_ flags in shpriv.idl
HRESULT _GetEventFriendlyName(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszFriendlyName, DWORD cchFriendlyName);

HRESULT _GetEventIconLocation(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszIconLocation, DWORD cchIconLocation);

//=============================================================================
HRESULT _GetDeviceHandler(CHWDeviceInst* phwdevinst,
    LPWSTR pszDeviceHandler, DWORD cchDeviceHandler);

//=============================================================================
HRESULT _GetHandlerCLSID(LPCWSTR pszEventHandler, CLSID* pclsid);
HRESULT _GetHandlerCancelCLSID(LPCWSTR pszHandler, CLSID* pclsid);
HRESULT _GetInitCmdLine(LPCWSTR pszEventHandler, LPWSTR* ppsz);

//=============================================================================
#define GUH_IMPERSONATEUSER     TRUE
#define GUH_USEWINSTA0USER      FALSE

HRESULT _GetUserDefaultHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventHandler,
    LPWSTR pszHandler, DWORD cchHandler, BOOL fImpersonateCaller);
HRESULT _SetUserDefaultHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventHandler,
    LPCWSTR pszHandler);
HRESULT _SetSoftUserDefaultHandler(LPCWSTR pszDeviceID,
    LPCWSTR pszEventHandler, LPCWSTR pszHandler);

HRESULT _GetHandlerForNoContent(LPCWSTR pszEventHandler, LPWSTR pszHandler,
    DWORD cchHandler);

//=============================================================================
HRESULT _FindDeepestSubkeyName(LPCWSTR pszSubKey, CHWDeviceInst* phwdevinst,
    LPWSTR pszKey, DWORD cchKey);

//=============================================================================
HRESULT _GetDevicePropertyAsString(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, LPCWSTR psz, DWORD cch);

HRESULT _GetDevicePropertyStringNoBuf(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pdwType,
    LPWSTR* ppszProp);

HRESULT _GetDevicePropertyGenericAsBlob(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BYTE_BLOB** ppblob);

HRESULT _GetDevicePropertyGenericAsMultiSz(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, WORD_BLOB** ppblob);

HRESULT _GetDevicePropertyGeneric(CHWDeviceInst* phwdevinst,
    LPCWSTR pszPropName, BOOL fUseMergeMultiSz, DWORD* pdwType, LPBYTE pbData,
    DWORD cbData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\gdtinfo.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <shpriv.h>

HRESULT _GetDriveTypeInfo(HANDLE hDevice, DWORD* pdwDriveType, BOOL* pfFloppy)
{
    HRESULT hr;
    FILE_FS_DEVICE_INFORMATION ffsdi = {0};
    IO_STATUS_BLOCK iosb;

    NTSTATUS ntstatus = NtQueryVolumeInformationFile(hDevice, &iosb, &ffsdi,
        sizeof(ffsdi), FileFsDeviceInformation);

    if (NT_SUCCESS(ntstatus))
    {
        switch (ffsdi.DeviceType)
        {
            case FILE_DEVICE_CD_ROM:
            case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
            case FILE_DEVICE_CHANGER:

                *pdwDriveType = HWDTS_CDROM;
                break;

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:

                if (FILE_REMOVABLE_MEDIA & ffsdi.Characteristics)
                {
                    *pdwDriveType = HWDTS_REMOVABLEDISK;

                    if (FILE_FLOPPY_DISKETTE & ffsdi.Characteristics)
                    {
                        *pfFloppy = TRUE;
                    }
                }
                else
                {
                    *pdwDriveType = HWDTS_FIXEDDISK;
                }

                break;

            default:
                // What the hell???
                *pdwDriveType = HWDTS_FIXEDDISK;
                break;
        }

        hr = S_OK;
    }
    else
    {
        *pdwDriveType = HWDTS_FIXEDDISK;

        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\hnotif.cpp ===
#include "hnotif.h"
#include "hwdev.h"

#include "misc.h"
#include "mischlpr.h"
#include "dbg.h"
#include "tfids.h"

#include <ioevent.h>
#include <dbt.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT CHandleNotif::Init(LPCWSTR pszElemName)
{
    return _SetName(pszElemName);
}

HRESULT CHandleNotif::InitNotif(CHandleNotifTarget* phnt)
{
    ASSERT(!_phnt);

    _phnt = phnt;

    return _Register();
}

HDEVNOTIFY CHandleNotif::GetDeviceNotifyHandle()
{
    return _hdevnotify;
}

CHandleNotifTarget* CHandleNotif::GetHandleNotifTarget()
{
    return _phnt;
}

//
// Application gets DBT_DEVICEQUERYREMOVE message with the handle of the device
// that's being removed. It should just close the handle to the device.
//
// If everything goes OK it gets DBT_DEVICEREMOVEPENDING to notify that remove
// is complete. Here it unregisters the notification that it did on the handle.
//
// If query-remove fails because somebody else in the system vetoed it, it gets
// DBT_QUERYREMOVEFAILED. Here it should first unregister the notification and
// reopen the device (if it's still interested) and register again for device
// change notification (DBT_DEVTYP_HANDLE) on the new handle.
//
HRESULT CHandleNotif::HNHandleEvent(DEV_BROADCAST_HANDLE* UNREF_PARAM(pdbh),
    DWORD dwEventType, BOOL* pfSurpriseRemoval)
{
    HRESULT hres;

    *pfSurpriseRemoval = FALSE;

    switch (dwEventType)
    {
        case DBT_DEVICEQUERYREMOVE:
            TRACE(TF_SHHWDTCTDTCT, TEXT("DBT_DEVICEQUERYREMOVE for '%s'"), _pszElemName);
            hres = S_OK;
            break;

        case DBT_DEVICEREMOVEPENDING:
            TRACE(TF_SHHWDTCTDTCT, TEXT("DBT_DEVICEREMOVEPENDING for '%s'"), _pszElemName);
            _fSurpriseRemoval = FALSE;
            hres = _Unregister();
            break;

        case DBT_DEVICEQUERYREMOVEFAILED:
            TRACE(TF_SHHWDTCTDTCT, TEXT("DBT_DEVICEQUERYREMOVEFAILED for '%s'"), _pszElemName);
            _fSurpriseRemoval = TRUE;
            hres = _Unregister();

            if (SUCCEEDED(hres))
            {
                hres = _Register();
            }
            break;

        case DBT_DEVICEREMOVECOMPLETE:
            TRACE(TF_SHHWDTCTDTCT, TEXT("DBT_DEVICEREMOVECOMPLETE for '%s'"), _pszElemName);
            if (_fSurpriseRemoval)
            {
                *pfSurpriseRemoval = TRUE;
                hres = _Unregister();
            }

            hres = S_FALSE;

            break;

        default:
            hres = S_FALSE;
            break;
    }

    return hres;
}

//static
HRESULT CHandleNotif::_HandleDeviceArrivalRemoval(
    DEV_BROADCAST_HANDLE* UNREF_PARAM(pdbh), DWORD UNREF_PARAM(dwEventType),
    CNamedElem* UNREF_PARAM(pelem))
{
#ifdef ENABLE_SURPRISEREMOVAL
    HRESULT hres = S_OK;

    BOOL fSurpriseRemoval = FALSE;
    CHandleNotif* phn = (CHandleNotif*)pelem;
    CHandleNotifTarget* phnt = phn->GetHandleNotifTarget();

    if (phnt)
    {
        if (fSurpriseRemoval && phnt->HNTIsSurpriseRemovalAware())
        {
            // Use me!
            DWORD cchReq;
            WCHAR szDeviceIntfID[MAX_DEVICEID];
            WCHAR szFriendlyName[30];

            hres = pelem->GetName(szDeviceIntfID,
                ARRAYSIZE(szDeviceIntfID), &cchReq);

            if (SUCCEEDED(hres))
            {
                CHWDeviceInst* phwdevinst;
                CNamedElem* pelemToRelease;
                hres = _GetHWDeviceInstFromDeviceOrVolumeIntfID(
                    szDeviceIntfID, &phwdevinst, &pelemToRelease);

                if (SUCCEEDED(hres) && (S_FALSE != hres))
                {
                    hres = phwdevinst->GetFriendlyName(szFriendlyName,
                        ARRAYSIZE(szFriendlyName));

                    if (SUCCEEDED(hres) && (S_FALSE != hres))
                    {
                        TRACE(TF_SHHWDTCTDTCT, TEXT("! ! ! Surprise removal for: '%s' ! ! !"),
                            szFriendlyName);
                    }
                    else
                    {
                        TRACE(TF_SHHWDTCTDTCT, TEXT("! ! ! Surprise removal for (no FriendlyName): '%s' ! ! !"),
                            szDeviceIntfID);
                    }

                    pelemToRelease->RCRelease();
                }
            }
        }
    }
#endif

    return S_OK;
}

//static
HRESULT CHandleNotif::_HandleDeviceLockUnlock(DEV_BROADCAST_HANDLE* pdbh,
    DWORD, CNamedElem* pelem)
{
    HRESULT hres = S_OK;
    CHandleNotif* phn = (CHandleNotif*)pelem;

    if (GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid)
    {
#ifdef DEBUG
        TRACE(TF_SHHWDTCTDTCT,
            TEXT("DBT_CUSTOMEVENT + GUID_IO_VOLUME_LOCK for '%s'"),
            pelem->DbgGetName());
#endif

        // nothing to do
        ++(phn->_cLockAttempts);
    }
    else
    {
        if (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid)
        {
#ifdef DEBUG
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("DBT_CUSTOMEVENT + GUID_IO_VOLUME_LOCK_FAILED for '%s'"),
                pelem->DbgGetName());
#endif

            --(phn->_cLockAttempts);

            if (0 == (phn->_cLockAttempts))
            {
                hres = phn->_Unregister();

                if (SUCCEEDED(hres))
                {
                    hres = phn->_Register();
                }
            }
        }
        else
        {
            if (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid)
            {
#ifdef DEBUG
                TRACE(TF_SHHWDTCTDTCT,
                    TEXT("DBT_CUSTOMEVENT + GUID_IO_VOLUME_UNLOCK for '%s'"),
                    pelem->DbgGetName());
#endif

                // Play it safe...
                (phn->_cLockAttempts) = 0;

                hres = phn->_Unregister();

                if (SUCCEEDED(hres))
                {
                    hres = phn->_Register();
                }
            }
        }
    }

    return hres;
}

//static
HRESULT CHandleNotif::HandleBroadcastHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
    DWORD dwEventType)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_HANDLENOTIF,
        &pnel);

    if (S_OK == hres)
    {
        // Find the elem in the list
        CNamedElemEnum* penum;

        hres = pnel->GetEnum(&penum);

        if (SUCCEEDED(hres))
        {
            CNamedElem* pelem;
            BOOL fFoundIt = FALSE;

            while (!fFoundIt && SUCCEEDED(hres = penum->Next(&pelem)) &&
                (S_FALSE != hres))
            {
                CHandleNotif* phn = (CHandleNotif*)pelem;

                if (phn->GetDeviceNotifyHandle() == pdbh->dbch_hdevnotify)
                {
                    // Found it!
                    BOOL fSurpriseRemoval;
                    CHandleNotifTarget* phnt = phn->GetHandleNotifTarget();

                    hres = phn->HNHandleEvent(pdbh, dwEventType, &fSurpriseRemoval);

                    if (SUCCEEDED(hres))
                    {
                        if ((GUID_IO_MEDIA_ARRIVAL == pdbh->dbch_eventguid) ||
                            (GUID_IO_MEDIA_REMOVAL == pdbh->dbch_eventguid))
                        {
                            hres = _HandleDeviceArrivalRemoval(pdbh, dwEventType,
                                pelem);
                        }
                        else
                        {
                            if ((GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid) ||
                                (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid) ||
                                (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid))
                            {
                                hres = _HandleDeviceLockUnlock(pdbh, dwEventType,
                                    pelem);
                            }
                        }

                        if (SUCCEEDED(hres))
                        {
                            hres = phnt->HNTHandleEvent(pdbh, dwEventType);

                            // phnt has the same life span as pelem, no need to
                            // RCAddRef/RCRelease
                        }
                    }

                    fFoundIt = TRUE;
                }

                pelem->RCRelease();
            }

            penum->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
//static
HRESULT CHandleNotif::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CHandleNotif();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHandleNotif::_Register()
{
    HRESULT hres = S_FALSE;
    DEV_BROADCAST_HANDLE dbhNotifFilter = {0};

    dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;

    dbhNotifFilter.dbch_handle = _GetDeviceHandle(_pszElemName,
        FILE_READ_ATTRIBUTES);

    if (INVALID_HANDLE_VALUE != dbhNotifFilter.dbch_handle)
    {
        hres = CHWEventDetectorHelper::RegisterDeviceNotification(
            &dbhNotifFilter, &_hdevnotify, FALSE);

        _CloseDeviceHandle(dbhNotifFilter.dbch_handle);
    }

    TRACE(TF_SHHWDTCTDTCT, TEXT("--- Registered for '%s'"), _pszElemName);

    return hres;
}

HRESULT CHandleNotif::_Unregister()
{
    if (_hdevnotify)
    {
        UnregisterDeviceNotification(_hdevnotify);
        _hdevnotify = NULL;

        TRACE(TF_SHHWDTCTDTCT, TEXT("--- UNRegistered for '%s'"), _pszElemName);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
CHandleNotif::CHandleNotif() : _hdevnotify(NULL), _phnt(NULL), 
    _fSurpriseRemoval(TRUE), _cLockAttempts(0)
{}

CHandleNotif::~CHandleNotif()
{
    _Unregister();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\hnotif.h ===
#include "namellst.h"

#include "cmmn.h"

#include <dbt.h>

class CHandleNotif : public CNamedElem
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CHandleNotif
    HRESULT HNHandleEvent(DEV_BROADCAST_HANDLE* pdbh, DWORD dwEventType,
        BOOL* pfSurpriseRemoval);
    HRESULT InitNotif(CHandleNotifTarget* phnt);
    HDEVNOTIFY GetDeviceNotifyHandle();
    CHandleNotifTarget* GetHandleNotifTarget();

    static HRESULT HandleBroadcastHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType);
    static HRESULT _HandleDeviceArrivalRemoval(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType, CNamedElem* pelem);
    static HRESULT _HandleDeviceLockUnlock(DEV_BROADCAST_HANDLE* pdbh,
        DWORD dwEventType, CNamedElem* pelem);

public:
    static HRESULT Create(CNamedElem** ppelem);

public:
    CHandleNotif();
    ~CHandleNotif();

private:
    HRESULT _Register();
    HRESULT _Unregister();
    HRESULT _CloseDevice();

private:
    BOOL                                _fSurpriseRemoval;
    CHandleNotifTarget*                 _phnt;
    HDEVNOTIFY                          _hdevnotify;

    DWORD                               _cLockAttempts;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\hwdev.cpp ===
#include "hwdev.h"

#include "setupapi.h"

#include "dtctreg.h"
#include "reg.h"

#include "namellst.h"
#include "sfstr.h"
#include "str.h"
#include "cmmn.h"
#include "misc.h"

#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHWDeviceInst::Init(DEVINST devinst)
{
    _devinst = devinst;

    return S_OK;
}

HRESULT CHWDeviceInst::InitInterfaceGUID(const GUID* pguidInterface)
{
    _guidInterface = *pguidInterface;
    
    return S_OK;
}

HRESULT CHWDeviceInst::GetDeviceInstance(DEVINST* pdevinst)
{
    HRESULT hr;

    if (_devinst)
    {
        *pdevinst = _devinst;
        hr = S_OK;
    }
    else
    {
        *pdevinst = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHWDeviceInst::GetPnpID(LPWSTR pszPnpID, DWORD cchPnpID)
{
    HRESULT hr = _InitPnpInfo();

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = SafeStrCpyN(pszPnpID, _szPnpID, cchPnpID);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHWDeviceInst::GetPnpInstID(LPWSTR pszPnpInstID, DWORD cchPnpInstID)
{
    HRESULT hr = _InitPnpInfo();

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = SafeStrCpyN(pszPnpInstID, _szPnpInstID, cchPnpInstID);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHWDeviceInst::GetInterfaceGUID(GUID* pguidInterface)
{
    ASSERT(guidInvalid != _guidInterface);

    *pguidInterface = _guidInterface;

    return S_OK;
}

HRESULT CHWDeviceInst::IsRemovableDevice(BOOL* pfRemovable)
{
    return _DeviceInstIsRemovable(_devinst, pfRemovable);    
}

HRESULT CHWDeviceInst::ShouldAutoplayOnSpecialInterface(
    const GUID* pguidInterface, BOOL* pfShouldAutoplay)
{
    WCHAR szGUID[MAX_GUIDSTRING];
    HRESULT hr = _StringFromGUID(pguidInterface, szGUID,
        ARRAYSIZE(szGUID));

    *pfShouldAutoplay = FALSE;

    if (SUCCEEDED(hr))
    {
        WCHAR szGUIDFromReg[MAX_GUIDSTRING];
        DWORD dwType;
    
        hr = _GetDevicePropertyGeneric(this,
            TEXT("AutoplayOnSpecialInterface"), FALSE, &dwType, (PBYTE)szGUIDFromReg,
            sizeof(szGUIDFromReg));

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (REG_SZ == dwType)
            {
                if (!lstrcmpi(szGUIDFromReg, szGUID))
                {
                    *pfShouldAutoplay = TRUE;
                }
            }
        }

        if (*pfShouldAutoplay)
        {
            DIAGNOSTIC((TEXT("[0314]Autoplay on Special Interface %s -> Autoplay!"), szGUID));
        }
        else
        {
            DIAGNOSTIC((TEXT("[0315]*NO* Autoplay on Special Interface %s -> No Autoplay!"), szGUID));
        }
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
CHWDeviceInst::CHWDeviceInst() : _devinst(0), _guidInterface(guidInvalid),
    _fFriendlyNameInited(FALSE)
{}

CHWDeviceInst::~CHWDeviceInst()
{}
///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHWDeviceInst::_InitPnpInfo()
{
    HRESULT hres;

    // This require the _devinst to be set
    if (0 != _devinst)
    {
        hres = _InitPnpIDAndPnpInstID();

        if (FAILED(hres))
        {
            // Probably not a removable device
            hres = S_FALSE;
        }

        hres = _InitFriendlyName();
    }
    else
    {
        hres = S_FALSE;
    }

    return hres;
}

HRESULT CHWDeviceInst::_InitFriendlyName()
{
    HRESULT hres;

    if (!_fFriendlyNameInited)
    {
        hres = S_FALSE;
        DWORD cb = sizeof(_szFriendlyName);

        CONFIGRET cr = CM_Get_DevNode_Registry_Property_Ex(_devinst,
            CM_DRP_FRIENDLYNAME, NULL, _szFriendlyName, &cb, 0, NULL);

        if (CR_SUCCESS == cr)
        {
            hres = S_OK;
        }
        else
        {
            cb = sizeof(_szFriendlyName);

            cr = CM_Get_DevNode_Registry_Property_Ex(_devinst,
                CM_DRP_DEVICEDESC, NULL, _szFriendlyName, &cb, 0, NULL);

            if (CR_SUCCESS == cr)
            {
                hres = S_OK;
            }
            else
            {
                _szFriendlyName[0] = 0;
            }
        }

        _fFriendlyNameInited = TRUE;
    }
    else
    {
        if (!_szFriendlyName[0])
        {
            hres = S_FALSE;
        }
        else
        {
            hres = S_OK;
        }
    }

    return hres;
}

HRESULT _FindInstID(LPWSTR pszPnpID, DWORD* pcch)
{
    DWORD cToFind = 2;
    LPWSTR psz = pszPnpID;

    *pcch = 0;

    while (*psz && cToFind)
    {
        if ((TEXT('\\') == *psz))
        {
            --cToFind;
        }

        if (cToFind)
        {
            ++psz;
        }
    }

    if (*psz)
    {
        *pcch = (DWORD)(psz - pszPnpID);
    }

    return S_OK;
}

HRESULT _GetPnpIDHelper(DEVINST devinst, LPWSTR pszPnpID, DWORD cchPnpID)
{
    HRESULT hres = S_FALSE;
    HMACHINE hMachine = NULL;

    CONFIGRET cr = CM_Get_Device_ID_Ex(devinst, pszPnpID,
        cchPnpID, 0, hMachine);

    if (CR_SUCCESS == cr)
    {
        hres = S_OK;
    }

    return hres;
}

HRESULT CHWDeviceInst::_InitPnpIDAndPnpInstID()
{
    HRESULT hres = _GetPnpIDHelper(_devinst, _szPnpID, ARRAYSIZE(_szPnpID));

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        DWORD cchInstIDOffset;
        hres = _FindInstID(_szPnpID, &cchInstIDOffset);

        if (SUCCEEDED(hres))
        {
            *(_szPnpID + cchInstIDOffset) = 0;

            hres = SafeStrCpyN(_szPnpInstID, _szPnpID + cchInstIDOffset + 1,
                ARRAYSIZE(_szPnpInstID));
        }
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "dtct.h"

#include "devinfo.h"
#include "settings.h"
#include "cstmprop.h"
#include "regnotif.h"

const CLSID APPID_ShellHWDetection = { /* b1b9cbb2-b198-47e2-8260-9fd629a2b2ec */
    0xb1b9cbb2,
    0xb198,
    0x47e2,
    {0x82, 0x60, 0x9f, 0xd6, 0x29, 0xa2, 0xb2, 0xec}
};

CFactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_HWEventDetector,
        CHWEventDetector::UnkCreateInstance,
		L"Shell.HWEventDetector",           // Friendly name
		L"Shell.HWEventDetector.1",         // ProgID
		L"Shell.HWEventDetector",           // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        // this is not a COM server, so following are N/A
        NULL,                         // CoRegisterClassObject context
        NULL,                         // CoRegisterClassObject flags
        NULL,                         // ServiceName
        NULL,
    },
    {
        &CLSID_HWEventSettings,
        CAutoplayHandler::UnkCreateInstance,
        L"AutoplayHandler",                // Friendly name
        L"AutoplayHandler.1",              // ProgID
        L"AutoplayHandler",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
    {
        &CLSID_AutoplayHandlerProperties,
        CAutoplayHandlerProperties::UnkCreateInstance,
        L"AutoplayHandlerProperties",                // Friendly name
        L"AutoplayHandlerProperties.1",              // ProgID
        L"AutoplayHandlerProperties",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
    {
        &CLSID_HWDevice,
        CHWDevice::UnkCreateInstance,
        L"HWDevice",                // Friendly name
        L"HWDevice.1",              // ProgID
        L"HWDevice",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
    {
        &CLSID_HardwareDevices,
        CHardwareDevices::UnkCreateInstance,
        L"HardwareDeviceNotif",                // Friendly name
        L"HardwareDeviceNotif.1",              // ProgID
        L"HardwareDeviceNotif",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
    {
        &CLSID_HWDeviceCustomProperties,
        CHWDeviceCustomProperties::UnkCreateInstance,
        L"HWDeviceCustomProperties",                // Friendly name
        L"HWDeviceCustomProperties.1",              // ProgID
        L"HWDeviceCustomProperties",                // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Free
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        L"ShellHWDetection",
        &APPID_ShellHWDetection,
    },
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\hwdev.h ===
#ifndef _HWDEV_H
#define _HWDEV_H

#include "namellst.h"

#include "cmmn.h"
#include "misc.h"

///////////////////////////////////////////////////////////////////////////////
//
// This will enumerate all the Device that we're interested in and create
// additionnal objects to do specialized work
//
///////////////////////////////////////////////////////////////////////////////

class CHWDeviceInst //: public CDeviceElem
{
public:
    // CHWDeviceInst
    HRESULT Init(DEVINST devinst);
    HRESULT InitInterfaceGUID(const GUID* pguidInterface);

    HRESULT GetPnpID(LPWSTR pszPnpID, DWORD cchPnpID);
    HRESULT GetDeviceInstance(DEVINST* pdevinst);
    HRESULT GetPnpInstID(LPWSTR pszPnpInstID, DWORD cchPnpInstID);
    HRESULT GetInterfaceGUID(GUID* pguidInterface);

    HRESULT IsRemovableDevice(BOOL* pfRemovable);
    HRESULT ShouldAutoplayOnSpecialInterface(const GUID* pguidInterface,
        BOOL* pfShouldAutoplay);

public:
    CHWDeviceInst();
    ~CHWDeviceInst();

private:
    HRESULT _GetPnpIDRecurs(DEVINST devinst, LPWSTR pszPnpID,
                                   DWORD cchPnpID);
    HRESULT _InitFriendlyName();
    HRESULT _InitPnpInfo();
    HRESULT _InitPnpIDAndPnpInstID();

private:
    DEVINST                             _devinst;
    // For now MAX_SURPRISEREMOVALFN
    WCHAR                               _szFriendlyName[MAX_SURPRISEREMOVALFN];
    WCHAR                               _szPnpID[MAX_PNPID];
    WCHAR                               _szPnpInstID[MAX_PNPINSTID];

    GUID                                _guidInterface;

    BOOL                                _fFriendlyNameInited;
};

#endif //_HWDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\logging.cpp ===
/*****************************************************************************\
    FILE: logging.cpp

    DESCRIPTION:
        Logging helper functions

    BryanSt 4/23/2001 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2001-2001. All rights reserved.
\*****************************************************************************/

#include <shlwapi.h> // SHGetValue, wnsprintf, SHFormatDateTime


#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))
#endif // ARRAYSIZE


HANDLE g_hLogFile = INVALID_HANDLE_VALUE;
void WriteToLogFileA(LPCSTR pszMessage, ...)
{
    va_list vaParamList;
    va_start(vaParamList, pszMessage);

    if (INVALID_HANDLE_VALUE == g_hLogFile)
    {
        TCHAR szPath[MAX_PATH];

        if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
        {
            PathAppend(szPath, TEXT("AutoPlay.log"));
            g_hLogFile = CreateFile(szPath, (GENERIC_READ | GENERIC_WRITE), FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (INVALID_HANDLE_VALUE != g_hLogFile)
            {
                CHAR szTimeDate[MAX_PATH];
                CHAR szHeader[MAX_PATH];
                FILETIME ftCurrentUTC;
                FILETIME ftCurrent;
                SYSTEMTIME stCurrent;
                DWORD cbWritten;

                SetFilePointer(g_hLogFile, 0, NULL, FILE_END);
                
                GetLocalTime(&stCurrent);
                SystemTimeToFileTime(&stCurrent, &ftCurrent);
                LocalFileTimeToFileTime(&ftCurrent, &ftCurrentUTC);
                SHFormatDateTimeA(&ftCurrentUTC, NULL, szTimeDate, ARRAYSIZE(szTimeDate));

                TCHAR szProcess[MAX_PATH];
                if (!GetModuleFileName(NULL, szProcess, ARRAYSIZE(szProcess)))
                {
                    szProcess[0] = 0;
                }

                wnsprintfA(szHeader, ARRAYSIZE(szHeader), "\r\n\r\n%hs - (%ls)\r\n", szTimeDate, /*szUserName,*/ szProcess);
                WriteFile(g_hLogFile, szHeader, lstrlenA(szHeader), &cbWritten, NULL);
            }

        }
    }

    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        CHAR szMessage[4000];
        DWORD cbWritten;
        wvsprintfA(szMessage, pszMessage, vaParamList);
        WriteFile(g_hLogFile, szMessage, lstrlenA(szMessage), &cbWritten, NULL);
        FlushFileBuffers(g_hLogFile);
    }

    va_end(vaParamList);
}


void WriteToLogFileW(LPCWSTR pszMessage)
{
    DWORD cchSize = (lstrlen(pszMessage) + 1);
    LPSTR pszMessageAnsi = (LPSTR) LocalAlloc(LPTR, cchSize);

    if (pszMessageAnsi)
    {
        SHUnicodeToAnsi(pszMessage, pszMessageAnsi, cchSize);
        WriteToLogFileA(pszMessageAnsi);
    }
}


void CloseLogFile(void)
{
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        HANDLE hLogFile = g_hLogFile;
        g_hLogFile = INVALID_HANDLE_VALUE;
        CloseHandle(hLogFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\miscdev.cpp ===
#include "miscdev.h"

HRESULT CMiscDeviceInterface::Init(LPCWSTR pszElemName)
{
    HRESULT hr = _SetName(pszElemName);

    if (SUCCEEDED(hr))
    {
        DEVINST devinst;
        GUID guidDummy;

        hr = _GetDeviceInstance(pszElemName, &devinst, &guidDummy);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _hwdevinst.Init(devinst);
        }
    }

    return hr;
}

HRESULT CMiscDeviceInterface::InitInterfaceGUID(const GUID* pguidInterface)
{
    return _hwdevinst.InitInterfaceGUID(pguidInterface);
}

HRESULT CMiscDeviceInterface::GetHWDeviceInst(CHWDeviceInst** pphwdevinst)
{
    *pphwdevinst = &_hwdevinst;

    return S_OK;
}

//static
HRESULT CMiscDeviceInterface::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CMiscDeviceInterface();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
CMiscDeviceInterface::CMiscDeviceInterface()
{}

CMiscDeviceInterface::~CMiscDeviceInterface()
{}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CMiscDeviceNode::Init(LPCWSTR pszElemName)
{
    HRESULT hr = _SetName(pszElemName);

    if (SUCCEEDED(hr))
    {
        DEVINST devinst;

        hr = _GetDeviceInstanceFromDevNode(pszElemName, &devinst);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _hwdevinst.Init(devinst);
        }
    }

    return hr;
}

HRESULT CMiscDeviceNode::GetHWDeviceInst(CHWDeviceInst** pphwdevinst)
{
    *pphwdevinst = &_hwdevinst;

    return S_OK;
}

//static
HRESULT CMiscDeviceNode::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CMiscDeviceNode();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
CMiscDeviceNode::CMiscDeviceNode()
{}

CMiscDeviceNode::~CMiscDeviceNode()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\logging.h ===
/*****************************************************************************\
    FILE: logging.h

    DESCRIPTION:
        Logging helper functions

    BryanSt 4/23/2001 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2001-2001. All rights reserved.
\*****************************************************************************/

#ifndef _LOGGING_H
#define _LOGGING_H

void WriteToLogFileA(LPCSTR pszMessage, ...);
void WriteToLogFileW(LPCWSTR pszMessage);
void CloseLogFile(void);


#endif // _LOGGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\misc.h ===
#ifndef _MISC_H
#define _MISC_H

// From MAX_DEVICE_ID_LEN = 200 in cfgmgr32.h
#define MAX_DEVICEID            200

#define MAX_PNPID               MAX_PATH
#define MAX_PNPINSTID           MAX_PATH

// According to documentation
#define MAX_PROGID              39

#define MAX_GUIDSTRING          39

#define MAX_AUTOPLAYGENERIC     64

#define MAX_EVENTHANDLER        MAX_AUTOPLAYGENERIC
#define MAX_DEVICEHANDLER       MAX_AUTOPLAYGENERIC
#define MAX_DEVICEGROUP         MAX_AUTOPLAYGENERIC
#define MAX_EVENTTYPE           MAX_AUTOPLAYGENERIC
#define MAX_EVENTFRIENDLYNAME   MAX_AUTOPLAYGENERIC
#define MAX_HANDLER             MAX_AUTOPLAYGENERIC
#define MAX_ACTION              MAX_AUTOPLAYGENERIC
#define MAX_PROVIDER            MAX_AUTOPLAYGENERIC

#define MAX_INVOKEPROGID        260
#define MAX_INVOKEVERB          MAX_AUTOPLAYGENERIC

#define MAX_USERDEFAULT         MAX_DEVICEID + MAX_AUTOPLAYGENERIC + 10

#define MAX_FRIENDLYNAME        MAX_AUTOPLAYGENERIC

#define MAX_VOLUMENAME          50

#define HINT_NONE               0
#define HINT_NEW                1

#define SHDEVICEEVENTROOT(a) TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoplayHandlers\\") ##a

#endif //_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\mtpts.h ===
#include "namellst.h"
#include "cmmn.h"

#include "misc.h"

#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

class CMtPt : public CNamedElem
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CMtPt
    HRESULT InitVolume(LPCWSTR pszDeviceIDVolume);
    HRESULT GetVolumeName(LPWSTR pszDeviceIDVolume, DWORD cchDeviceIDVolume);

public:
    static HRESULT Create(CNamedElem** ppelem);

public:
    CMtPt();
    ~CMtPt();

private:
    // Drive that host this volume (might be null, in this case no autoplay)
    WCHAR                   _szDeviceIDVolume[MAX_DEVICEID];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\miscdev.h ===
#include "namellst.h"

#include "hwdev.h"

#include "cmmn.h"
#include "misc.h"

class CMiscDeviceInterface : public CNamedElem
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CMiscDeviceInterface
    HRESULT InitInterfaceGUID(const GUID* pguidInterface);
    HRESULT GetHWDeviceInst(CHWDeviceInst** pphwdevinst);

public:
    static HRESULT Create(CNamedElem** ppelem);

public:
    CMiscDeviceInterface();
    ~CMiscDeviceInterface();

private:
    CHWDeviceInst                       _hwdevinst;
};

class CMiscDeviceNode : public CNamedElem
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CMiscDeviceNode
    HRESULT GetHWDeviceInst(CHWDeviceInst** pphwdevinst);

public:
    static HRESULT Create(CNamedElem** ppelem);

public:
    CMiscDeviceNode();
    ~CMiscDeviceNode();

private:
    CHWDeviceInst                       _hwdevinst;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\pnp.h ===
#ifndef _PNP_H
#define _PNP_H

#include <objbase.h>

HRESULT _GetPropertyHelper(LPCWSTR pszKey, LPCWSTR pszPropName, DWORD* pdwType,
    PBYTE pbData, DWORD cbData);

HRESULT _GetPropertySizeHelper(LPCWSTR pszKey, LPCWSTR pszPropName,
    DWORD* pcbSize);

#endif //_PNP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\pnp.cpp ===
#include "pnp.h"

#include "reg.h"
#include "sfstr.h"

#include "misc.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// Temporary fct to use while PnP team writes the real one
//
// First we look under the DeviceNode for the value and if not there
// we go to the "database".
//
//
HRESULT _GetPropertyHelper(LPCWSTR pszKey, LPCWSTR pszPropName, DWORD* pdwType,
    PBYTE pbData, DWORD cbData)
{
    HKEY hkey;
    HRESULT hr = _RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = _RegQueryGenericWithType(hkey, NULL, pszPropName, pdwType,
            pbData, cbData);

        _RegCloseKey(hkey);
    }

    return hr;
}

HRESULT _GetPropertySizeHelper(LPCWSTR pszKey, LPCWSTR pszPropName,
    DWORD* pcbSize)
{
    HKEY hkey;
    HRESULT hr = _RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        hr = _RegQueryValueSize(hkey, NULL, pszPropName, pcbSize);

        _RegCloseKey(hkey);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\mtpts.cpp ===
#include "mtpts.h"

#include "vol.h"

#include "sfstr.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT CMtPt::Init(LPCWSTR pszElemName)
{
    return _SetName(pszElemName);
}

HRESULT CMtPt::InitVolume(LPCWSTR pszDeviceIDVolume)
{
    return SafeStrCpyN(_szDeviceIDVolume, pszDeviceIDVolume,
        ARRAYSIZE(_szDeviceIDVolume));
}

HRESULT CMtPt::GetVolumeName(LPWSTR pszDeviceIDVolume, DWORD cchDeviceIDVolume)
{
    return SafeStrCpyN(pszDeviceIDVolume, _szDeviceIDVolume,
        cchDeviceIDVolume);
}

//static
HRESULT CMtPt::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CMtPt();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

CMtPt::CMtPt()
{
    _szDeviceIDVolume[0] = 0;
}

CMtPt::~CMtPt()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\setenumu.cpp ===
#include "setenum.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CEnumAutoplayHandlerIME[] =
{
    _INTFMAPENTRY(CEnumAutoplayHandler, IEnumAutoplayHandler),
};

const INTFMAPENTRY* CEnumAutoplayHandler::_pintfmap = CEnumAutoplayHandlerIME;
const DWORD CEnumAutoplayHandler::_cintfmap =
    (sizeof(CEnumAutoplayHandlerIME)/sizeof(CEnumAutoplayHandlerIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CEnumAutoplayHandler::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\setenum.cpp ===
#include "setenum.h"

#include "dtctreg.h"
#include "cmmn.h"

#include "misc.h"
#include "reg.h"
#include "sfstr.h"

#include "tfids.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

STDMETHODIMP CEnumAutoplayHandlerImpl::Next(LPWSTR* ppszHandler,
    LPWSTR* ppszAction, LPWSTR* ppszProvider, LPWSTR* ppszIconLocation)
{
    HRESULT hr;

    *ppszHandler = NULL;
    *ppszAction = NULL;
    *ppszProvider = NULL;
    *ppszIconLocation = NULL;

    if (!_fTakeNoActionDone)
    {
        LPCWSTR pszHandler = TEXT("MSTakeNoAction");
        WCHAR szAction[MAX_ACTION];
        WCHAR szProvider[MAX_PROVIDER];
        WCHAR szIconLocation[MAX_ICONLOCATION];

        if (_rghkiHandlers)
        {
            if (_dwIndex < _cHandlers)
            {
                pszHandler = _rghkiHandlers[_dwIndex].szHandler;
            }
            else
            {
                _fTakeNoActionDone = TRUE;
            }
        }
        else
        {
            _fTakeNoActionDone = TRUE;
        }

        hr = _GetActionFromHandler(pszHandler, szAction, ARRAYSIZE(szAction));

        if (SUCCEEDED(hr))
        {
            hr = _GetIconLocationFromHandler(pszHandler, szIconLocation,
                ARRAYSIZE(szIconLocation));

            if (SUCCEEDED(hr))
            {
                hr = _GetProviderFromHandler(pszHandler, szProvider,
                    ARRAYSIZE(szProvider));

                if (SUCCEEDED(hr))
                {
                    hr = _CoTaskMemCopy(pszHandler, ppszHandler);

                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szAction,
                            ppszAction);

                        if (SUCCEEDED(hr))
                        {
                            hr = _CoTaskMemCopy(szIconLocation,
                                ppszIconLocation);

                            if (SUCCEEDED(hr))
                            {
                                hr = _CoTaskMemCopy(szProvider,
                                    ppszProvider);
                            }
                        }
                    }
                }
            }
        }

        if (FAILED(hr))
        {
            if (*ppszHandler)
            {
                CoTaskMemFree((PVOID)*ppszHandler);
                *ppszHandler = NULL;
            }
            if (*ppszAction)
            {
                CoTaskMemFree((PVOID)*ppszAction);
                *ppszAction = NULL;
            }
            if (*ppszProvider)
            {
                CoTaskMemFree((PVOID)*ppszProvider);
                *ppszProvider = NULL;
            }
            if (*ppszIconLocation)
            {
                CoTaskMemFree((PVOID)*ppszIconLocation);
                *ppszIconLocation = NULL;
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    ++_dwIndex;
    
    return hr;
}

HRESULT _GetKeyLastWriteTime(LPCWSTR pszHandler, FILETIME* pft)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("Handlers\\"));

    HRESULT hr = SafeStrCatN(szKeyName, pszHandler, ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (ERROR_SUCCESS != RegQueryInfoKey(hkey,
                NULL,           // class buffer
                0,              // size of class buffer
                NULL,           // reserved
                NULL,           // number of subkeys
                NULL,           // longest subkey name
                NULL,           // longest class string
                NULL,           // number of value entries
                NULL,           // longest value name
                NULL,           // longest value data
                NULL,           // descriptor length
                pft             // last write time
                ))
            {
                // Bad.  Set it to right now
                GetSystemTimeAsFileTime(pft);
            }

            hr = S_OK;

            _RegCloseKey(hkey);
        }
    }
    
    return hr;
}

HRESULT CEnumAutoplayHandlerImpl::_Init(LPWSTR pszEventHandler)
{
    WCHAR szKeyName[MAX_KEY] = SHDEVICEEVENTROOT(TEXT("EventHandlers\\"));
    HRESULT hr = SafeStrCatN(szKeyName, pszEventHandler,
        ARRAYSIZE(szKeyName));

    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = _RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hkey);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (ERROR_SUCCESS == RegQueryInfoKey(hkey,
                NULL,           // class buffer
                0,              // size of class buffer
                NULL,           // reserved
                NULL,           // number of subkeys
                NULL,           // longest subkey name
                NULL,           // longest class string
                &_cHandlers,    // number of value entries
                NULL,           // longest value name
                NULL,           // longest value data
                NULL,           // descriptor length
                NULL            // last write time
                ))
            {
                hr = _AllocMemoryChunk<_HANDLERKEYINFO*>(_cHandlers *
                    sizeof(_HANDLERKEYINFO), &_rghkiHandlers);

                if (SUCCEEDED(hr))
                {
                    for (DWORD dw = 0; SUCCEEDED(hr) && (dw < _cHandlers); ++dw)
                    {
                        hr = _RegEnumStringValue(hkey, dw, _rghkiHandlers[dw].szHandler,
                            ARRAYSIZE(_rghkiHandlers[dw].szHandler));

                        if (SUCCEEDED(hr))
                        {
                            if (S_FALSE != hr)
                            {
                                hr = _GetKeyLastWriteTime(
                                    _rghkiHandlers[dw].szHandler,
                                    &(_rghkiHandlers[dw].ftLastWriteTime));
                            }
                            else
                            {
                                // There's less then there was when we queried for it...
                                _cHandlers = dw;

                                break;
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // We don't care if this fails
                        _SortHandlers();
                    }
                    else
                    {
                        _FreeMemoryChunk<_HANDLERKEYINFO*>(_rghkiHandlers);
                        _rghkiHandlers = NULL;
                        _cHandlers = 0;
                    }
                }
                else
                {
                    _cHandlers = 0;
                }
            }
            else
            {
                hr = S_FALSE;
            }

            _RegCloseKey(hkey);
        }
    }
   
    return hr;
}

HRESULT CEnumAutoplayHandlerImpl::_SwapHandlerKeyInfo(DWORD dwLeft,
    DWORD dwRight)
{
    _HANDLERKEYINFO hkiTmp = _rghkiHandlers[dwLeft];

    _rghkiHandlers[dwLeft] = _rghkiHandlers[dwRight];
    _rghkiHandlers[dwRight] = hkiTmp;

    return S_OK;
}

HRESULT CEnumAutoplayHandlerImpl::_SortHandlers()
{
    HRESULT hr;

    if (_rghkiHandlers)
    {
        hr = S_OK;

        for (DWORD dwOuter = 0; dwOuter < _cHandlers; ++dwOuter)
        {
            _HANDLERKEYINFO* phkiOuter = &(_rghkiHandlers[dwOuter]);
            ULARGE_INTEGER ulOuter;
            ulOuter.LowPart = phkiOuter->ftLastWriteTime.dwLowDateTime;
            ulOuter.HighPart = phkiOuter->ftLastWriteTime.dwHighDateTime;

            for (DWORD dwInner = dwOuter + 1; dwInner < _cHandlers; ++dwInner)
            {
                _HANDLERKEYINFO* phkiInner = &(_rghkiHandlers[dwInner]);

                ULARGE_INTEGER ulInner;
                ulInner.LowPart = phkiInner->ftLastWriteTime.dwLowDateTime;
                ulInner.HighPart = phkiInner->ftLastWriteTime.dwHighDateTime;
            
                if (ulOuter.QuadPart > ulInner.QuadPart)
                {
                    hr = _SwapHandlerKeyInfo(dwOuter, dwInner);
                }
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

CEnumAutoplayHandlerImpl::CEnumAutoplayHandlerImpl() : _dwIndex(0), _rghkiHandlers(NULL),
    _cHandlers(0), _fTakeNoActionDone(FALSE)
{}

CEnumAutoplayHandlerImpl::~CEnumAutoplayHandlerImpl()
{
    if (_rghkiHandlers)
    {
        _FreeMemoryChunk<_HANDLERKEYINFO*>(_rghkiHandlers);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\setenum.h ===
///////////////////////////////////////////////////////////////////////////////
// HW Event Handler Enum
///////////////////////////////////////////////////////////////////////////////
#ifndef _SETENUM_H
#define _SETENUM_H

#include "unk.h"
#include "misc.h"

#include <shpriv.h>

class CEnumAutoplayHandlerImpl : public CCOMBase, public IEnumAutoplayHandler
{
public:
    // Interface IEnumAutoplayHandler
	STDMETHODIMP Next(LPWSTR* ppszHandler, LPWSTR* ppszAction,
        LPWSTR* ppszProvider, LPWSTR* ppszIconLocation);

public:
    HRESULT _Init(LPWSTR pszEventHandler);
    CEnumAutoplayHandlerImpl();
    ~CEnumAutoplayHandlerImpl();

private:
    HRESULT _SwapHandlerKeyInfo(DWORD dwLeft, DWORD dwRight);
    HRESULT _SortHandlers();

private:
    struct _HANDLERKEYINFO
    {
        WCHAR           szHandler[MAX_HANDLER];
        FILETIME        ftLastWriteTime;
    };

    DWORD               _dwIndex;
    DWORD               _cHandlers;
    _HANDLERKEYINFO*    _rghkiHandlers;
    BOOL                _fTakeNoActionDone;
};

typedef CUnkTmpl<CEnumAutoplayHandlerImpl> CEnumAutoplayHandler;

#endif // _SETENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\regnotif.cpp ===
#include "regnotif.h"

#include "svcsync.h"
#include "mtpts.h"
#include "vol.h"

#include "namellst.h"

#include "users.h"
#include "sfstr.h"
#include "tfids.h"
#include "dbg.h"

#include <shpriv.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#define MAGICTOKENOFFSET ((DWORD)0x57EF57EF)

LONG  CHardwareDevicesImpl::_lAdviseToken = MAGICTOKENOFFSET;
DWORD CHardwareDevicesImpl::_chwdevcb = 0;

#define MAX_ADVISETOKEN      11

#pragma warning(disable: 4700 4701)
HRESULT _VolumeAddedOrUpdatedHelper(IHardwareDeviceCallback* pdevchngcb, CVolume* pvol,
    BOOL fAdded)
{
    DWORD cchReq;
    HRESULT hr;

    WCHAR szVolName[MAX_DEVICEID];
    WCHAR szVolGUID[50];
    WCHAR szLabel[MAX_LABEL];
    WCHAR szFileSystem[MAX_FILESYSNAME];
    WCHAR szAutorunIconLocation[MAX_ICONLOCATION];
    WCHAR szAutorunLabel[MAX_LABEL];
    WCHAR szIconLocationFromService[MAX_ICONLOCATION];
    WCHAR szNoMediaIconLocationFromService[MAX_ICONLOCATION];
    // We can now have a @%SystemRoot%\system32\shell32.dll,-1785 for MUI stuff
    WCHAR szLabelFromService[MAX_ICONLOCATION];

    VOLUMEINFO volinfo = {0};

    ASSERT(pvol);

    volinfo.pszDeviceIDVolume = szVolName;
    volinfo.pszVolumeGUID = szVolGUID;
    volinfo.pszLabel = szLabel;
    volinfo.pszFileSystem = szFileSystem;

    volinfo.dwState = pvol->_dwState;

    hr = pvol->GetName(szVolName, ARRAYSIZE(szVolName), &cchReq);

    TRACE(TF_ADVISE,
        TEXT("Called _VolumeAddedOrUpdatedHelper for Vol = %s, CB = 0x%08X, Added = %d"),
        szVolName, pdevchngcb, fAdded);

    if (SUCCEEDED(hr))
    {
        hr = pvol->GetVolumeConstInfo(szVolGUID,
            ARRAYSIZE(szVolGUID), &(volinfo.dwVolumeFlags), &(volinfo.dwDriveType),
            &(volinfo.dwDriveCapability));
    }

    if (SUCCEEDED(hr))
    {
        hr = pvol->GetVolumeMediaInfo(szLabel, ARRAYSIZE(szLabel), 
            szFileSystem, ARRAYSIZE(szFileSystem), &(volinfo.dwFileSystemFlags),
            &(volinfo.dwMaxFileNameLen), &(volinfo.dwRootAttributes), &(volinfo.dwSerialNumber), 
            &(volinfo.dwDriveState), &(volinfo.dwMediaState), &(volinfo.dwMediaCap));
    }

    if (SUCCEEDED(hr))
    {
        hr = pvol->GetIconAndLabelInfo(szAutorunIconLocation,
            ARRAYSIZE(szAutorunIconLocation), szAutorunLabel,
            ARRAYSIZE(szAutorunLabel), szIconLocationFromService,
            ARRAYSIZE(szIconLocationFromService), szNoMediaIconLocationFromService,
            ARRAYSIZE(szNoMediaIconLocationFromService), szLabelFromService,
            ARRAYSIZE(szLabelFromService));

        if (SUCCEEDED(hr))
        {
            if (*szAutorunIconLocation)
            {
                volinfo.pszAutorunIconLocation = szAutorunIconLocation;
            }

            if (*szAutorunLabel)
            {
                volinfo.pszAutorunLabel = szAutorunLabel;
            }

            if (*szIconLocationFromService)
            {
                volinfo.pszIconLocationFromService = szIconLocationFromService;
            }

            if (*szNoMediaIconLocationFromService)
            {
                volinfo.pszNoMediaIconLocationFromService = szNoMediaIconLocationFromService;
            }

            if (*szLabelFromService)
            {
                volinfo.pszLabelFromService = szLabelFromService;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pdevchngcb->VolumeAddedOrUpdated(fAdded, &volinfo);
    }

    return hr;
}
#pragma warning(default: 4700 4701)

STDMETHODIMP CHardwareDevicesImpl::EnumVolumes(
    DWORD dwFlags, IHardwareDevicesVolumesEnum** ppenum)
{
    HRESULT hr;

    *ppenum = NULL;

    if ((HWDEV_GETCUSTOMPROPERTIES == dwFlags) || (0 == dwFlags))
    {
        CHardwareDevicesVolumesEnum* phwdve = new CHardwareDevicesVolumesEnum(NULL);

        if (phwdve)
        {
            hr = phwdve->_Init(dwFlags);

            if (SUCCEEDED(hr))
            {
                *ppenum = phwdve;
            }
            else
            {
                phwdve->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    ASSERT((*ppenum && SUCCEEDED(hr)) || (!*ppenum && FAILED(hr)));
    return hr;
}

STDMETHODIMP CHardwareDevicesImpl::EnumMountPoints(
    IHardwareDevicesMountPointsEnum** ppenum)
{
    HRESULT hr;
    CHardwareDevicesMountPointsEnum* phwdmtpte = new CHardwareDevicesMountPointsEnum(NULL);

    *ppenum = NULL;

    if (phwdmtpte)
    {
        hr = phwdmtpte->_Init();

        if (SUCCEEDED(hr))
        {
            *ppenum = phwdmtpte;
        }
        else
        {
            phwdmtpte->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    ASSERT((*ppenum && SUCCEEDED(hr)) || (!*ppenum && FAILED(hr)));
    return hr;
}

STDMETHODIMP CHardwareDevicesImpl::EnumDevices(IHardwareDevicesEnum** /*ppenum*/)
{
    return E_NOTIMPL;
}

HRESULT _GetStringAdviseToken(LONG lAdviseToken, LPWSTR szAdviseToken, DWORD cchAdviseToken)
{
    HRESULT hr;

    if (cchAdviseToken >= MAX_ADVISETOKEN)
    {
        // 0x12345678
        wsprintf(szAdviseToken, TEXT("0x%08X"), lAdviseToken);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CHardwareDevicesImpl::Advise(DWORD dwProcessID,
    ULONG_PTR hThread, ULONG_PTR pfctCallback, DWORD* pdwToken)
{
    HRESULT hr;

    TRACE(TF_ADVISE, TEXT(">>>Called ") TEXT(__FUNCTION__) TEXT(", 0x%08X, 0x%08X, 0x%08X"),
        dwProcessID, hThread, pfctCallback);
    
    if (dwProcessID && hThread && pfctCallback && pdwToken)
    {
        LONG lAdviseToken = InterlockedIncrement(&_lAdviseToken);
        WCHAR szAdviseToken[MAX_ADVISETOKEN];

        hr = _GetStringAdviseToken(lAdviseToken, szAdviseToken,
            ARRAYSIZE(szAdviseToken));
    
        if (SUCCEEDED(hr))
        {
            CNamedElemList* pnel;
            hr = CHWEventDetectorHelper::GetList(HWEDLIST_ADVISECLIENT, &pnel);

            if (S_OK == hr)
            {
                CNamedElem* pelem;

                hr = pnel->GetOrAdd(szAdviseToken, &pelem);

                if (SUCCEEDED(hr))
                {
                    CAdviseClient* pac = (CAdviseClient*)pelem;

                    hr = pac->_Init(dwProcessID,
                        hThread, pfctCallback);

                    if (SUCCEEDED(hr))
                    {
                        *pdwToken = lAdviseToken;
                    }
                    else
                    {
                        pnel->Remove(szAdviseToken);
                    }

                    pelem->RCRelease();
                }

                pnel->RCRelease();
            }
        }

        if (SUCCEEDED(hr))
        {
            TRACE(TF_ADVISE, TEXT(">>>Advise SUCCEEDED, token = 0x%08X"), lAdviseToken);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (FAILED(hr))
    {
        TRACE(TF_ADVISE, TEXT(">>>Advise FAILED"));
    }

    return hr;
}

STDMETHODIMP CHardwareDevicesImpl::Unadvise(DWORD dwToken)
{
    HRESULT hr;

    if (dwToken >= (MAGICTOKENOFFSET))
    {
        WCHAR szAdviseToken[MAX_ADVISETOKEN];

        hr = _GetStringAdviseToken(dwToken, szAdviseToken,
            ARRAYSIZE(szAdviseToken));

        if (SUCCEEDED(hr))
        {
            CNamedElemList* pnel;
            hr = CHWEventDetectorHelper::GetList(HWEDLIST_ADVISECLIENT, &pnel);

            if (S_OK == hr)
            {
                pnel->Remove(szAdviseToken);

                pnel->RCRelease();
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        TRACE(TF_ADVISE, TEXT(">>>UNAdvise SUCCEEDED, token = 0x%08X"),
            dwToken);
    }
    else
    {
        TRACE(TF_ADVISE, TEXT(">>>UNAdvise FAILED, token = 0x%08X"),
            dwToken);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
class CThreadTaskBroadcastEvent : public CThreadTask
{
public:
    CThreadTaskBroadcastEvent() : _pshhe(NULL)
    {}

    virtual ~CThreadTaskBroadcastEvent()
    {
        if (_pshhe)
        {
            _FreeMemoryChunk<SHHARDWAREEVENT*>(_pshhe);
        }
    }

protected:
    HRESULT _Broadcast()
    {
        CNamedElemList* pnel;
        HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_ADVISECLIENT, &pnel);

        if (S_OK == hr)
        {
            CNamedElemEnum* penum;

            hr = pnel->GetEnum(&penum);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                CNamedElem* pelem;

                while (SUCCEEDED(hr) && SUCCEEDED(hr = penum->Next(&pelem)) &&
                    (S_FALSE != hr))
                {
                    CAdviseClient* pac = (CAdviseClient*)pelem;
                    void* pv;

                    HRESULT hrTmp = pac->WriteMemoryChunkInOtherProcess(_pshhe,
                        _pshhe->cbSize, &pv);

                    if (SUCCEEDED(hrTmp))
                    {
                        hrTmp = pac->QueueUserAPC(pv);
                    }

                    if (FAILED(hrTmp))
                    {
                        WCHAR szAdviseToken[MAX_ADVISETOKEN];
                        DWORD cchReq;

                        TRACE(TF_ADVISE,
                            TEXT(__FUNCTION__) TEXT(": Trying to removed token because failed CB, hr = 0x%08X"),
                            hrTmp);

                        if (SUCCEEDED(pelem->GetName(szAdviseToken, ARRAYSIZE(szAdviseToken),
                            &cchReq)))
                        {
                            TRACE(TF_ADVISE, TEXT("    ") TEXT(__FUNCTION__) TEXT(": Token = %s"),
                                szAdviseToken);

                            pnel->Remove(szAdviseToken);
                        }
                    }

                    pelem->RCRelease();
                }

                penum->RCRelease();
            }

            pnel->RCRelease();
        }

        return hr;
    }

protected:
    SHHARDWAREEVENT*    _pshhe;
};

class CThreadTaskMountPointEvent : public CThreadTaskBroadcastEvent
{
public:
    HRESULT InitAdded(LPCWSTR pszMtPt, LPCWSTR pszDeviceIDVolume)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + sizeof(MTPTADDED);
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            MTPTADDED* pmtptadded = (MTPTADDED*)_pshhe->rgbPayLoad;

            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_MOUNTPOINTARRIVED;

            hr = SafeStrCpyN(pmtptadded->szMountPoint, pszMtPt,
                ARRAYSIZE(pmtptadded->szMountPoint));

            if (SUCCEEDED(hr))
            {
                hr = SafeStrCpyN(pmtptadded->szDeviceIDVolume, pszDeviceIDVolume,
                    ARRAYSIZE(pmtptadded->szDeviceIDVolume));

                if (SUCCEEDED(hr))
                {
                    // We give the Shell AllowSetForegroundWindow privilege
                    _GiveAllowForegroundToConsoleShell();
                }
            }
        }

        return hr;
    }

    HRESULT InitRemoved(LPCWSTR pszMtPt)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + MAX_PATH * sizeof(WCHAR);
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_MOUNTPOINTREMOVED;

            hr = SafeStrCpyN((LPWSTR)_pshhe->rgbPayLoad, pszMtPt,
                MAX_PATH);
        }

        return hr;
    }

    HRESULT _DoStuff()
    {
        return _Broadcast();
    }
};

class CThreadTaskCheckClients : public CThreadTask
{
public:
    HRESULT _DoStuff()
    {
        CNamedElemList* pnel;

        //
        //  Get the list of notify clients.
        //

        HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_ADVISECLIENT, &pnel);
        if (S_OK == hres)
        {
            CNamedElemEnum* penum;

            hres = pnel->GetEnum(&penum);
            if (SUCCEEDED(hres))
            {
                CNamedElem* pelem;

                //
                //  Enumerate the advised clients.
                //

                while (SUCCEEDED(hres = penum->Next(&pelem)) && (S_FALSE != hres))
                {
                    CAdviseClient* pac = (CAdviseClient*)pelem;

                    //
                    //  Is the process still alive?
                    //

                    HRESULT hrTmp = pac->IsProcessStillAlive( );
                    if (S_OK != hrTmp)
                    {
                        WCHAR szAdviseToken[MAX_ADVISETOKEN];
                        DWORD cchReq;

                        //
                        //  Nope (or there is some problem with it)... so remove it from the list.
                        //

                        TRACE(TF_ADVISE, TEXT(__FUNCTION__) TEXT(": Trying to removed token because process died, pac = %p"), pac);

                        hrTmp = pelem->GetName(szAdviseToken, ARRAYSIZE(szAdviseToken), &cchReq);
                        if (SUCCEEDED(hrTmp))
                        {
                            TRACE(TF_ADVISE, TEXT("    ") TEXT(__FUNCTION__) TEXT(": Token = %s"), szAdviseToken);

                            pnel->Remove(szAdviseToken);
                        }
                    }

                    pelem->RCRelease();
                }

                //
                //  Reset the HRESULT if it is the expected exit condition.
                //

                if ( S_FALSE == hres )
                {
                    hres = S_OK;
                }

                penum->RCRelease();
            }

            pnel->RCRelease();
        }

        return hres;
    }
};

class CThreadTaskVolumeEvent : public CThreadTaskBroadcastEvent
{
public:
    HRESULT InitAdded(VOLUMEINFO2* pvolinfo2, LPCWSTR pszMtPts, DWORD cchMtPts)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + pvolinfo2->cbSize;
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_VOLUMEARRIVED;

            CopyMemory(_pshhe->rgbPayLoad, pvolinfo2, pvolinfo2->cbSize);

            _pszDeviceIDVolume = ((VOLUMEINFO2*)_pshhe->rgbPayLoad)->szDeviceIDVolume;

            if (SUCCEEDED(hr) && pszMtPts)
            {
                hr = _DupMemoryChunk<LPCWSTR>(pszMtPts, cchMtPts * sizeof(WCHAR),
                    &_pszMtPts);
            }
        }

        return hr;
    }

    HRESULT InitUpdated(VOLUMEINFO2* pvolinfo2)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + pvolinfo2->cbSize;
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_VOLUMEUPDATED;

            CopyMemory(_pshhe->rgbPayLoad, pvolinfo2, pvolinfo2->cbSize);

            _pszDeviceIDVolume = ((VOLUMEINFO2*)_pshhe->rgbPayLoad)->szDeviceIDVolume;

            // We give the Shell AllowSetForegroundWindow privilege
            _GiveAllowForegroundToConsoleShell();
        }

        return hr;
    }

    HRESULT InitRemoved(LPCWSTR pszDeviceIDVolume, LPCWSTR pszMtPts, DWORD cchMtPts)
    {
        ASSERT(!_pshhe);
        DWORD cbSize = sizeof(SHHARDWAREEVENT) + MAX_DEVICEID * sizeof(WCHAR);
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = SHHARDWAREEVENT_VOLUMEREMOVED;
            _pszDeviceIDVolume = ((VOLUMEINFO2*)_pshhe->rgbPayLoad)->szDeviceIDVolume;

            hr = SafeStrCpyN((LPWSTR)_pshhe->rgbPayLoad, pszDeviceIDVolume,
                MAX_DEVICEID);

            if (SUCCEEDED(hr) && pszMtPts)
            {
                hr = _DupMemoryChunk<LPCWSTR>(pszMtPts, cchMtPts * sizeof(WCHAR),
                    &_pszMtPts);
            }
        }

        return hr;
    }

    HRESULT _DoStuff()
    {
        HRESULT hr;

        switch (_pshhe->dwEvent)
        {
            case SHHARDWAREEVENT_VOLUMEARRIVED:
            case SHHARDWAREEVENT_VOLUMEUPDATED:
            {
                hr = _SendVolumeInfo();

                if (SUCCEEDED(hr) && (SHHARDWAREEVENT_VOLUMEARRIVED == _pshhe->dwEvent))
                {
                    // We need to enum the mountpoints too.  We were not
                    // registered to get the notif since this volume was not there
                    hr = _SendMtPtsInfo();
                }
                
                break;
            }
            case SHHARDWAREEVENT_VOLUMEREMOVED:
            {
                hr = _SendMtPtsInfo();

                if (SUCCEEDED(hr))
                {
                    hr = _SendVolumeInfo();
                }

                break;
            }
            default:
            {
                TRACE(TF_ADVISE, TEXT("DoStuff with unknown SHHARDWAREEVENT_* value"));
                hr = E_FAIL;
                break;
            }
        }

        return hr;
    }

private:
    HRESULT _SendMtPtsInfo()
    {
        if (_pszMtPts)
        {
            for (LPCWSTR psz = _pszMtPts; *psz; psz += (lstrlen(psz) + 1))
            {
                CThreadTaskMountPointEvent task;
                HRESULT hr;

                if (SHHARDWAREEVENT_VOLUMEREMOVED == _pshhe->dwEvent)
                {
                    hr = task.InitRemoved(psz);
                }
                else
                {
                    hr = task.InitAdded(psz, _pszDeviceIDVolume);
                }

                if (SUCCEEDED(hr))
                {
                    task.RunSynchronously();
                }
            }
        }

        return S_OK;
    }

    HRESULT _SendVolumeInfo()
    {
        return _Broadcast();
    }

public:
    CThreadTaskVolumeEvent() : _pszMtPts(NULL)
    {}

    ~CThreadTaskVolumeEvent()
    {
        if (_pszMtPts)
        {
            _FreeMemoryChunk<LPCWSTR>(_pszMtPts);
        }
    }

private:
    LPCWSTR             _pszMtPts;
    LPCWSTR             _pszDeviceIDVolume;
};

class CThreadTaskGenericEvent : public CThreadTaskBroadcastEvent
{
public:
    HRESULT Init(LPCWSTR pszPayload, DWORD dwEvent)
    {
        ASSERT(!_pshhe);
        //  maybe use lstrlen()?
        DWORD cbSize = (DWORD)(sizeof(SHHARDWAREEVENT) + (pszPayload ?  MAX_DEVICEID * sizeof(WCHAR) : 0));
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            LPWSTR pszPayloadLocal = (LPWSTR)_pshhe->rgbPayLoad;

            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = dwEvent;

            if (pszPayload)
            {
                hr = SafeStrCpyN(pszPayloadLocal, pszPayload, MAX_DEVICEID);
            }
        }

        return hr;
    }

    HRESULT _DoStuff()
    {
        return _Broadcast();
    }
};

class CThreadTaskDeviceEvent : public CThreadTaskBroadcastEvent
{
public:
    HRESULT Init(LPCWSTR pszDeviceIntfID, GUID* pguidInterface,
        DWORD dwDeviceFlags, DWORD dwEvent)
    {
        ASSERT(!_pshhe);

        DWORD cbSize = (DWORD)(sizeof(SHHARDWAREEVENT) + (sizeof(HWDEVICEINFO)));
        HRESULT hr = _AllocMemoryChunk<SHHARDWAREEVENT*>(cbSize, &_pshhe);
    
        if (SUCCEEDED(hr))
        {
            HWDEVICEINFO* phwdevinfo = (HWDEVICEINFO*)_pshhe->rgbPayLoad;

            _pshhe->cbSize = cbSize;
            _pshhe->dwEvent = dwEvent;

            hr = SafeStrCpyN(phwdevinfo->szDeviceIntfID, pszDeviceIntfID,
                ARRAYSIZE(phwdevinfo->szDeviceIntfID));

            if (SUCCEEDED(hr))
            {
                phwdevinfo->cbSize = sizeof(*phwdevinfo);
                phwdevinfo->guidInterface = *pguidInterface;
                phwdevinfo->dwDeviceFlags = dwDeviceFlags;
            }
        }

        return hr;
    }

    HRESULT _DoStuff()
    {
        return _Broadcast();
    }
};

HRESULT CHardwareDevicesImpl::_AdviseDeviceArrivedOrRemoved(
    LPCWSTR pszDeviceIntfID, GUID* pguidInterface, DWORD dwDeviceFlags,
    LPCWSTR pszEventType)
{
    HRESULT hr;
    CThreadTaskDeviceEvent* pTask = new CThreadTaskDeviceEvent();

    if (pTask)
    {
        DWORD dwEvent;

        if (!lstrcmpi(pszEventType, TEXT("DeviceArrival")))
        {
            dwEvent =  SHHARDWAREEVENT_DEVICEARRIVED;
        }
        else
        {
            dwEvent =  SHHARDWAREEVENT_DEVICEREMOVED;
        }
            
        hr = pTask->Init(pszDeviceIntfID, pguidInterface, dwDeviceFlags,
            dwEvent);

        if (SUCCEEDED(hr))
        {
            pTask->Run();
        }
        else
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//static
HRESULT CHardwareDevicesImpl::_AdviseVolumeArrivedOrUpdated(
    VOLUMEINFO2* pvolinfo2, LPCWSTR pszMtPts, DWORD cchMtPts, BOOL fAdded)
{
    HRESULT hr;
    TRACE(TF_ADVISE, TEXT(">>>_AdviseVolumeArrivedOrUpdated: fAdded = %d"), fAdded);

    CThreadTaskVolumeEvent* pTask = new CThreadTaskVolumeEvent();

    if (pTask)
    {
        if (fAdded)
        {
            hr = pTask->InitAdded(pvolinfo2, pszMtPts, cchMtPts);
        }
        else
        {
            hr = pTask->InitUpdated(pvolinfo2);
        }

        if (SUCCEEDED(hr))
        {
            pTask->Run();
        }
        else
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// static
HRESULT CHardwareDevicesImpl::_AdviseVolumeRemoved(LPCWSTR pszDeviceIDVolume,
    LPCWSTR pszMtPts, DWORD cchMtPts)
{
    HRESULT hr;
    TRACE(TF_ADVISE, TEXT(">>>_AdviseVolumeRemoved"));

    CThreadTaskVolumeEvent* pTask = new CThreadTaskVolumeEvent();

    if (pTask)
    {
        hr = pTask->InitRemoved(pszDeviceIDVolume, pszMtPts, cchMtPts);

        if (SUCCEEDED(hr))
        {
            pTask->Run();
        }
        else
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;    
}

//static
HRESULT CHardwareDevicesImpl::_AdviseVolumeMountingEvent(
    LPCWSTR pszDeviceIDVolume, DWORD dwEvent)
{
    TRACE(TF_ADVISE, TEXT(">>>_AdviseVolumeMountingEvent: %s, dwEvent = 0x%08X"),
        pszDeviceIDVolume, dwEvent);

    HRESULT hr;
    CThreadTaskGenericEvent* pTask = new CThreadTaskGenericEvent();

    if (pTask)
    {
        hr = pTask->Init(pszDeviceIDVolume, dwEvent);

        if (SUCCEEDED(hr))
        {
            pTask->Run();
        }
        else
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//static
HRESULT CHardwareDevicesImpl::_AdviseMountPointHelper(LPCWSTR pszMtPt,
    LPCWSTR pszDeviceIDVolume, BOOL fAdded)
{
    TRACE(TF_ADVISE, TEXT(">>>_AdviseMountPointHelper: %s, fAdded = %d"),
        pszMtPt, fAdded);

    HRESULT hr;
    CThreadTaskMountPointEvent* pTask = new CThreadTaskMountPointEvent();

    if (pTask)
    {
        if (fAdded)
        {
            hr = pTask->InitAdded(pszMtPt, pszDeviceIDVolume);
        }
        else
        {
            hr = pTask->InitRemoved(pszMtPt);            
        }

        if (SUCCEEDED(hr))
        {
            pTask->Run();
        }
        else
        {
            delete pTask;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;    
}
//static
HRESULT CHardwareDevicesImpl::_AdviseCheckClients(void)
{
    HRESULT hr;

    CThreadTaskCheckClients* pTask = new CThreadTaskCheckClients();

    if (pTask)
    {
        pTask->Run( );
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Impl
CHardwareDevicesImpl::CHardwareDevicesImpl()
{
    _CompleteShellHWDetectionInitialization();
}

CHardwareDevicesImpl::~CHardwareDevicesImpl()
{}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CHardwareDevicesEnumImpl::Next(
    LPWSTR* /*ppszDeviceID*/,
    GUID* /*pguidDeviceID*/)
{
    return E_NOTIMPL;
}

CHardwareDevicesEnumImpl::CHardwareDevicesEnumImpl()
{}

CHardwareDevicesEnumImpl::~CHardwareDevicesEnumImpl()
{}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHardwareDevicesVolumesEnumImpl::_Init(DWORD dwFlags)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

    _dwFlags = dwFlags;

    if (S_OK == hr)
    {
        hr = pnel->GetEnum(&_penum);

        pnel->RCRelease();
    }

    return hr;
}

STDMETHODIMP CHardwareDevicesVolumesEnumImpl::Next(VOLUMEINFO* pvolinfo)
{
    HRESULT hr;
    
    if (pvolinfo)
    {
        if (_penum)
        {
            CNamedElem* pelem;

            hr = _penum->Next(&pelem);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                // Const Info
                WCHAR szVolName[MAX_DEVICEID];
                WCHAR szVolGUID[50];
                WCHAR szLabel[MAX_LABEL];
                WCHAR szFileSystem[MAX_FILESYSNAME];
                WCHAR szAutorunIconLocation[MAX_ICONLOCATION];
                WCHAR szAutorunLabel[MAX_LABEL];
                WCHAR szIconLocationFromService[MAX_ICONLOCATION];
                WCHAR szNoMediaIconLocationFromService[MAX_ICONLOCATION];
                // We can now have a @%SystemRoot%\system32\shell32.dll,-1785 for MUI stuff
                WCHAR szLabelFromService[MAX_ICONLOCATION];
                CVolume* pvol = (CVolume*)pelem;

                // Misc
                DWORD cchReq;

                ZeroMemory(pvolinfo, sizeof(VOLUMEINFO));

                hr = pvol->GetName(szVolName, ARRAYSIZE(szVolName), &cchReq);

                if (SUCCEEDED(hr))
                {
                    hr = pvol->GetVolumeConstInfo(szVolGUID,
                        ARRAYSIZE(szVolGUID), &(pvolinfo->dwVolumeFlags),
                        &(pvolinfo->dwDriveType),
                        &(pvolinfo->dwDriveCapability));
                }

                if (SUCCEEDED(hr))
                {
                    hr = pvol->GetVolumeMediaInfo(szLabel, ARRAYSIZE(szLabel), 
                        szFileSystem, ARRAYSIZE(szFileSystem),
                        &(pvolinfo->dwFileSystemFlags),
                        &(pvolinfo->dwMaxFileNameLen),
                        &(pvolinfo->dwRootAttributes),
                        &(pvolinfo->dwSerialNumber), &(pvolinfo->dwDriveState),
                        &(pvolinfo->dwMediaState), &(pvolinfo->dwMediaCap));
                }

                if (SUCCEEDED(hr))
                {
                    if (HWDEV_GETCUSTOMPROPERTIES & _dwFlags)
                    {
                        szAutorunIconLocation[0] = 0;
                        szAutorunLabel[0] = 0;
                        szIconLocationFromService[0] = 0;
                        szNoMediaIconLocationFromService[0] = 0;
                        szLabelFromService[0] = 0;

                        hr = pvol->GetIconAndLabelInfo(szAutorunIconLocation,
                            ARRAYSIZE(szAutorunIconLocation), szAutorunLabel,
                            ARRAYSIZE(szAutorunLabel),
                            szIconLocationFromService,
                            ARRAYSIZE(szIconLocationFromService),
                            szNoMediaIconLocationFromService,
                            ARRAYSIZE(szNoMediaIconLocationFromService),
                            szLabelFromService,
                            ARRAYSIZE(szLabelFromService));

                        if (SUCCEEDED(hr))
                        {
                            if (*szAutorunIconLocation)
                            {
                                hr = _CoTaskMemCopy(szAutorunIconLocation,
                                    &(pvolinfo->pszAutorunIconLocation));
                            }
                            if (SUCCEEDED(hr) && *szAutorunLabel)
                            {
                                hr = _CoTaskMemCopy(szAutorunLabel,
                                    &(pvolinfo->pszAutorunLabel));
                            }
                            if (SUCCEEDED(hr) && *szIconLocationFromService)
                            {
                                hr = _CoTaskMemCopy(szIconLocationFromService,
                                    &(pvolinfo->pszIconLocationFromService));
                            }
                            if (SUCCEEDED(hr) && *szNoMediaIconLocationFromService)
                            {
                                hr = _CoTaskMemCopy(szNoMediaIconLocationFromService,
                                    &(pvolinfo->pszNoMediaIconLocationFromService));
                            }
                            if (SUCCEEDED(hr) && *szLabelFromService)
                            {
                                hr = _CoTaskMemCopy(szLabelFromService,
                                    &(pvolinfo->pszLabelFromService));
                            }
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = _CoTaskMemCopy(szVolName, &(pvolinfo->pszDeviceIDVolume));

                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szVolGUID, &(pvolinfo->pszVolumeGUID));
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szLabel, &(pvolinfo->pszLabel));
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szFileSystem, &(pvolinfo->pszFileSystem));
                    }
                }

                if (FAILED(hr))
                {
                    _CoTaskMemFree(pvolinfo->pszDeviceIDVolume);
                    _CoTaskMemFree(pvolinfo->pszVolumeGUID);
                    _CoTaskMemFree(pvolinfo->pszLabel);
                    _CoTaskMemFree(pvolinfo->pszFileSystem);

                    _CoTaskMemFree(pvolinfo->pszAutorunIconLocation);
                    _CoTaskMemFree(pvolinfo->pszAutorunLabel);
                    _CoTaskMemFree(pvolinfo->pszIconLocationFromService);
                    _CoTaskMemFree(pvolinfo->pszNoMediaIconLocationFromService);
                    _CoTaskMemFree(pvolinfo->pszLabelFromService);

                    ZeroMemory(pvolinfo, sizeof(VOLUMEINFO));
                }
            
                pelem->RCRelease();
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

CHardwareDevicesVolumesEnumImpl::CHardwareDevicesVolumesEnumImpl() :
    _penum(NULL)
{}

CHardwareDevicesVolumesEnumImpl::~CHardwareDevicesVolumesEnumImpl()
{
    if (_penum)
    {
        _penum->RCRelease();
    }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
HRESULT CHardwareDevicesMountPointsEnumImpl::_Init()
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);

    if (S_OK == hr)
    {
        hr = pnel->GetEnum(&_penum);

        pnel->RCRelease();
    }

    return hr;
}

STDMETHODIMP CHardwareDevicesMountPointsEnumImpl::Next(
    LPWSTR* ppszMountPoint,     // "c:\", or "d:\MountFolder\"
    LPWSTR* ppszDeviceIDVolume) // \\?\STORAGE#Volume#...{...GUID...}
{
    HRESULT hr;
    
    *ppszMountPoint = NULL;
    *ppszDeviceIDVolume = NULL;

    if (_penum)
    {
        CNamedElem* pelem;

        hr = _penum->Next(&pelem);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            // Const Info
            WCHAR szMtPtName[MAX_PATH];
            WCHAR szVolName[MAX_DEVICEID];
            CMtPt* pmtpt = (CMtPt*)pelem;

            // Misc
            DWORD cchReq;

            hr = pmtpt->GetName(szMtPtName, ARRAYSIZE(szMtPtName), &cchReq);

            if (SUCCEEDED(hr))
            {
                hr = pmtpt->GetVolumeName(szVolName, ARRAYSIZE(szVolName));
            }

            if (SUCCEEDED(hr))
            {
                hr = _CoTaskMemCopy(szMtPtName, ppszMountPoint);

                if (SUCCEEDED(hr))
                {
                    hr = _CoTaskMemCopy(szVolName, ppszDeviceIDVolume);
                }
                else
                {
                    CoTaskMemFree(*ppszMountPoint);
                    *ppszMountPoint = NULL;
                }
            }

            pelem->RCRelease();
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

CHardwareDevicesMountPointsEnumImpl::CHardwareDevicesMountPointsEnumImpl() :
    _penum(NULL)
{}

CHardwareDevicesMountPointsEnumImpl::~CHardwareDevicesMountPointsEnumImpl()
{
    if (_penum)
    {
        _penum->RCRelease();
    }
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CAdviseClient::Init(LPCWSTR pszElemName)
{
    ASSERT(pszElemName);

    return _SetName(pszElemName);
}

HRESULT CAdviseClient::_Cleanup()
{
    if (_hProcess)
    {
        CloseHandle(_hProcess);
        _hProcess = NULL;
    }

    if (_hThread)
    {
        CloseHandle(_hThread);
        _hThread = NULL;
    }

    return S_OK;
}

HRESULT CAdviseClient::_Init(DWORD dwProcessID, ULONG_PTR hThread,
    ULONG_PTR pfctCallback)
{
    HRESULT hr = E_FAIL;

    _Cleanup();

    _pfct = (PAPCFUNC)pfctCallback;

    // rename hProcess!
    _hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | SYNCHRONIZE |
        PROCESS_DUP_HANDLE, FALSE, dwProcessID);

    if (_hProcess)
    {
        if (DuplicateHandle(_hProcess, (HANDLE)hThread,
            GetCurrentProcess(), &_hThread, THREAD_ALL_ACCESS, FALSE, 0))
        {
            hr = S_OK;
        }
    }

    return hr;        
}

HRESULT CAdviseClient::WriteMemoryChunkInOtherProcess(SHHARDWAREEVENT* pshhe,
    DWORD cbSize, void** ppv)
{
    HRESULT hr = E_FAIL;
    void* pv = VirtualAllocEx(_hProcess, NULL, cbSize,
        MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
        PAGE_READWRITE);

    *ppv = NULL;

    if (pv)
    {
        SIZE_T cbWritten;

        if (WriteProcessMemory(_hProcess, pv, pshhe, cbSize, &cbWritten)
            && (cbWritten == cbSize))
        {
            *ppv = pv;
            hr = S_OK;
        }
        else
        {
            VirtualFreeEx(_hProcess, pv, 0, MEM_RELEASE);
        }
    }
    else
    {
        // Out of mem, but in the other process...
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CAdviseClient::QueueUserAPC(void* pv)
{
    HRESULT hr;

    if (::QueueUserAPC(_pfct, _hThread, (ULONG_PTR)pv))
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CAdviseClient::IsProcessStillAlive(void)
{
    HRESULT hr;

    DWORD dwResult = WaitForSingleObject( _hProcess, 0 );
    switch (dwResult) 
    {
    case WAIT_OBJECT_0:
        hr = S_FALSE;   // process has died.
        break;

    case WAIT_TIMEOUT:
        hr = S_OK;      // process is still alive
        break;

    default:
        {
            //  problem with handle
            DWORD dwErr = GetLastError( );
            hr = HRESULT_FROM_WIN32( dwErr );
        }
        break;
    }

    return hr;
}

CAdviseClient::CAdviseClient() : _hProcess(NULL), _hThread(NULL), _pfct(NULL)
{}

CAdviseClient::~CAdviseClient()
{
    _Cleanup();
}
// static
HRESULT CAdviseClient::Create(CNamedElem** ppelem)
{
    HRESULT hr = S_OK;
    *ppelem = new CAdviseClient();

    if (!(*ppelem))
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\settings.h ===
///////////////////////////////////////////////////////////////////////////////
// Autoplay Handler
///////////////////////////////////////////////////////////////////////////////
#ifndef _SETTINGS_H
#define _SETTINGS_H

#include "unk.h"
#include "misc.h"

#include <shpriv.h>

class CAutoplayHandlerImpl : public CCOMBase, public IAutoplayHandler
{
public:
    // Interface IAutoplayHandler
    STDMETHODIMP Init(LPCWSTR pszDeviceID, LPCWSTR pszEventType);
    STDMETHODIMP InitWithContent(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
		LPCWSTR pszContentTypeHandler);

    STDMETHODIMP EnumHandlers(IEnumAutoplayHandler** ppenum);

    STDMETHODIMP GetDefaultHandler(LPWSTR* ppszHandler);
    STDMETHODIMP SetDefaultHandler(LPCWSTR pszHandler);

public:
    CAutoplayHandlerImpl();

private:
    HRESULT _Init(LPCWSTR pszDeviceID, LPCWSTR pszEventType);

private:
    WCHAR           _szEventHandler[MAX_EVENTHANDLER];
    WCHAR           _szDeviceIDReal[MAX_DEVICEID];
    BOOL            _fInited;
};

typedef CUnkTmpl<CAutoplayHandlerImpl> CAutoplayHandler;

class CAutoplayHandlerPropertiesImpl : public CCOMBase,
    public IAutoplayHandlerProperties
{
public:
    // Interface IAutoplayHandlerProperties
    STDMETHODIMP Init(LPCWSTR pszHandler);

    STDMETHODIMP GetInvokeProgIDAndVerb(LPWSTR* ppszInvokeProgID,
		LPWSTR* ppszInvokeVerb);

public:
    CAutoplayHandlerPropertiesImpl();

private:
    WCHAR           _szHandler[MAX_HANDLER];
    BOOL            _fInited;
};

typedef CUnkTmpl<CAutoplayHandlerPropertiesImpl> CAutoplayHandlerProperties;

#endif // _SETTINGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\settings.cpp ===
#include "settings.h"

#include "setenum.h"
#include "dtctreg.h"

#include "svcsync.h"

#include "sfstr.h"
#include "cmmn.h"
#include "misc.h"
#include <shlwapi.h>

#include "tfids.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT _GetEventHandlerHelper(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPWSTR pszEventHandler, DWORD cchEventHandler)
{
    CHWDeviceInst* phwdevinst;
    CNamedElem* pelemToRelease;
    HRESULT hr = _GetHWDeviceInstFromDeviceOrVolumeIntfID(pszDeviceID,
        &phwdevinst, &pelemToRelease);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        WCHAR szDeviceHandler[MAX_DEVICEHANDLER];

        hr = _GetDeviceHandler(phwdevinst, szDeviceHandler,
            ARRAYSIZE(szDeviceHandler));

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _GetEventHandlerFromDeviceHandler(szDeviceHandler,
                pszEventType, pszEventHandler, cchEventHandler);
        }

        pelemToRelease->RCRelease();
    }

    return hr;
}

HRESULT CAutoplayHandlerImpl::_Init(LPCWSTR pszDeviceID, LPCWSTR pszEventType)
{
    HRESULT hr = _GetDeviceID(pszDeviceID, _szDeviceIDReal,
        ARRAYSIZE(_szDeviceIDReal));
    
    if (SUCCEEDED(hr))
    {
        hr = _GetEventHandlerHelper(_szDeviceIDReal, pszEventType,
            _szEventHandler, ARRAYSIZE(_szEventHandler));

        if (SUCCEEDED(hr))
        {
            if (S_FALSE != hr)
            {
                _fInited = TRUE;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            TRACE(TF_SHHWDTCTDTCTREG,
                TEXT("_Init, _GetEventHandlerHelper FAILED or S_FALSE'd: 0x%08X"),
                hr);
        }
    }
    else
    {
        TRACE(TF_SHHWDTCTDTCTREG, TEXT("_Init, _GetDeviceID FAILED: 0x%08X"),
            hr);
    }

    return hr;
}

STDMETHODIMP CAutoplayHandlerImpl::Init(LPCWSTR pszDeviceID,
    LPCWSTR pszEventType)
{
    return _Init(pszDeviceID, pszEventType);
}

STDMETHODIMP CAutoplayHandlerImpl::InitWithContent(LPCWSTR pszDeviceID,
    LPCWSTR /*pszEventType*/, LPCWSTR pszContentTypeHandler)
{
    HRESULT hr = _GetDeviceID(pszDeviceID, _szDeviceIDReal,
        ARRAYSIZE(_szDeviceIDReal));

    if (SUCCEEDED(hr))
    {
        if (!lstrcmpi(pszContentTypeHandler, TEXT("CDAudioContentHandler")))
        {
            hr = SafeStrCpyN(_szEventHandler, TEXT("PlayCDAudioOnArrival"), ARRAYSIZE(_szEventHandler));
        }
        else if (!lstrcmpi(pszContentTypeHandler, TEXT("DVDMovieContentHandler")))
        {
            hr = SafeStrCpyN(_szEventHandler, TEXT("PlayDVDMovieOnArrival"), ARRAYSIZE(_szEventHandler));
        }
        else if (!lstrcmpi(pszContentTypeHandler, TEXT("BlankCDContentHandler")))
        {
            hr = SafeStrCpyN(_szEventHandler, TEXT("HandleCDBurningOnArrival"), ARRAYSIZE(_szEventHandler));
        }
        else if (!lstrcmpi(pszContentTypeHandler, TEXT("MusicFilesContentHandler")))
        {
            hr = SafeStrCpyN(_szEventHandler, TEXT("PlayMusicFilesOnArrival"), ARRAYSIZE(_szEventHandler));
        }
        else if (!lstrcmpi(pszContentTypeHandler, TEXT("PicturesContentHandler")))
        {
            hr = SafeStrCpyN(_szEventHandler, TEXT("ShowPicturesOnArrival"), ARRAYSIZE(_szEventHandler));
        }
        else if (!lstrcmpi(pszContentTypeHandler, TEXT("VideoFilesContentHandler")))
        {
            hr = SafeStrCpyN(_szEventHandler, TEXT("PlayVideoFilesOnArrival"), ARRAYSIZE(_szEventHandler));
        }
        else if (!lstrcmpi(pszContentTypeHandler, TEXT("MixedContentHandler")))
        {
            hr = SafeStrCpyN(_szEventHandler, TEXT("MixedContentOnArrival"), ARRAYSIZE(_szEventHandler));
        }
        else
        {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            _fInited = TRUE;
        }
    }
    else
    {
        TRACE(TF_SHHWDTCTDTCTREG, TEXT("_Init, _GetDeviceID FAILED: 0x%08X"),
            hr);
    }
    
    return hr;
}

STDMETHODIMP CAutoplayHandlerImpl::GetDefaultHandler(LPWSTR* ppszHandler)
{
    HRESULT hr;

    TRACE(TF_SHHWDTCTDTCTREG, TEXT("Entered CAutoplayHandlerImpl"));

    if (ppszHandler)
    {
        *ppszHandler = NULL;

        if (_fInited)
        {
            WCHAR szHandler[MAX_HANDLER];

            hr = _GetUserDefaultHandler(_szDeviceIDReal, _szEventHandler,
                szHandler, ARRAYSIZE(szHandler), GUH_IMPERSONATEUSER);

            if (SUCCEEDED(hr))
            {
                if (S_FALSE != hr)
                {
                    // Watch out!  The hr from _GetUserDefaultHandler is more
                    // than just S_OK/S_FALSE.  Keep its value, unless we fail!
                    HRESULT hrTmp = _CoTaskMemCopy(szHandler, ppszHandler);

                    if (FAILED(hrTmp))
                    {
                        hr = hrTmp;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

#define SOFTPREFIX      TEXT("[soft]")

STDMETHODIMP CAutoplayHandlerImpl::SetDefaultHandler(LPCWSTR pszHandler)
{
    HRESULT hr;

    if (_fInited)
    {
        if (pszHandler && *pszHandler)
        {
            if (StrNCmp(SOFTPREFIX, pszHandler, (ARRAYSIZE(SOFTPREFIX) - 1)))
            {
                hr = _SetUserDefaultHandler(_szDeviceIDReal, _szEventHandler,
                    pszHandler);
            }
            else
            {
                hr = _SetSoftUserDefaultHandler(_szDeviceIDReal,
                    _szEventHandler, pszHandler + ARRAYSIZE(SOFTPREFIX) - 1);
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CAutoplayHandlerImpl::EnumHandlers(IEnumAutoplayHandler** ppenum)
{
    HRESULT hr;

    *ppenum = NULL;

    if (_fInited)
    {
        CEnumAutoplayHandler* penum = new CEnumAutoplayHandler(NULL);

        if (penum)
        {
            hr = penum->_Init(_szEventHandler);

            if (SUCCEEDED(hr))
            {
                *ppenum = penum;
            }
            else
            {
                delete penum;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

CAutoplayHandlerImpl::CAutoplayHandlerImpl() : _fInited(FALSE)
{
    _CompleteShellHWDetectionInitialization();
}

//
CAutoplayHandlerPropertiesImpl::CAutoplayHandlerPropertiesImpl() : _fInited(FALSE)
{
    _CompleteShellHWDetectionInitialization();
}

STDMETHODIMP CAutoplayHandlerPropertiesImpl::Init(LPCWSTR pszHandler)
{
    HRESULT hr;

    if (pszHandler && *pszHandler)
    {
        if (!_fInited)
        {
            hr = SafeStrCpyN(_szHandler, pszHandler, ARRAYSIZE(_szHandler));

            if (SUCCEEDED(hr))
            {
                _fInited = TRUE;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CAutoplayHandlerPropertiesImpl::GetInvokeProgIDAndVerb(
    LPWSTR* ppszInvokeProgID, LPWSTR* ppszInvokeVerb)
{
    HRESULT hr;

    if (ppszInvokeProgID && ppszInvokeVerb)
    {
        *ppszInvokeProgID = NULL;
        *ppszInvokeVerb = NULL;

        if (_fInited)
        {
            WCHAR szInvokeProgID[MAX_INVOKEPROGID];

            hr = _GetInvokeProgIDFromHandler(_szHandler, szInvokeProgID,
                ARRAYSIZE(szInvokeProgID));

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                WCHAR szInvokeVerb[MAX_INVOKEVERB];

                hr = _GetInvokeVerbFromHandler(_szHandler, szInvokeVerb,
                    ARRAYSIZE(szInvokeVerb));

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _CoTaskMemCopy(szInvokeProgID, ppszInvokeProgID);

                    if (SUCCEEDED(hr))
                    {
                        hr = _CoTaskMemCopy(szInvokeVerb, ppszInvokeVerb);

                        if (FAILED(hr))
                        {
                            if (*ppszInvokeProgID)
                            {
                                CoTaskMemFree((PVOID)*ppszInvokeProgID);
                                *ppszInvokeProgID = NULL;
                            }
                        }
                    }
                }
            }

            if (S_FALSE == hr)
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\regnotif.h ===
///////////////////////////////////////////////////////////////////////////////
// HardwareDevices Registration
///////////////////////////////////////////////////////////////////////////////
#ifndef _REGNOTIF_H
#define _REGNOTIF_H

#include "unk.h"
#include "namellst.h"

#include <shpriv.h>

extern const CLSID CLSID_HardwareDevices;

class CHardwareDevicesImpl : public CCOMBase, public IHardwareDevices
{
public:
    // Interface IHardwareDevices
    STDMETHODIMP EnumVolumes(DWORD dwFlags, IHardwareDevicesVolumesEnum** ppenum);
    STDMETHODIMP EnumMountPoints(IHardwareDevicesMountPointsEnum** ppenum);
    STDMETHODIMP EnumDevices(IHardwareDevicesEnum** ppenum);
 
    STDMETHODIMP Advise(DWORD dwProcessID, ULONG_PTR hThread,
        ULONG_PTR pfctCallback, DWORD* pdwToken);
    STDMETHODIMP Unadvise(DWORD dwToken);

public:
    static HRESULT _AdviseVolumeArrivedOrUpdated(
        VOLUMEINFO2* pvolinfo2, LPCWSTR pszMtPts, DWORD cchMtPts, BOOL fAdded);
    static HRESULT _AdviseVolumeRemoved(LPCWSTR pszDeviceIDVolume,
        LPCWSTR pszMtPts, DWORD cchMtPts);
    static HRESULT _AdviseMountPointHelper(LPCWSTR pszMtPt,
        LPCWSTR pszDeviceIDVolume, BOOL fAdded);
    static HRESULT _AdviseVolumeMountingEvent(LPCWSTR pszDeviceIDVolume,
        DWORD dwEvent);
    static HRESULT _AdviseCheckClients(void);
    static HRESULT _AdviseDeviceArrivedOrRemoved(LPCWSTR pszDeviceIntfID,
        GUID* pguidInterface, DWORD dwDeviceFlags, LPCWSTR pszEventType);

public:
    CHardwareDevicesImpl();
    ~CHardwareDevicesImpl();

private:
    static DWORD _chwdevcb;
    static LONG  _lAdviseToken;
};

typedef CUnkTmpl<CHardwareDevicesImpl> CHardwareDevices;

///////////////////////////////////////////////////////////////////////////////
//
class CHardwareDevicesEnumImpl : public CCOMBase, public IHardwareDevicesEnum
{
public:
    // Interface IHardwareDevicesEnum
	STDMETHODIMP Next(
		LPWSTR* ppszDeviceID,
		GUID* pguidDeviceID);

public:
    CHardwareDevicesEnumImpl();
    ~CHardwareDevicesEnumImpl();
};

typedef CUnkTmpl<CHardwareDevicesEnumImpl> CHardwareDevicesEnum;

///////////////////////////////////////////////////////////////////////////////
//
class CHardwareDevicesVolumesEnumImpl : public CCOMBase,
    public IHardwareDevicesVolumesEnum
{
public:
    // Interface IHardwareDevicesVolumesEnum
	STDMETHODIMP Next(VOLUMEINFO* pvolinfo);

public: // for CHardwareDevicesImpl usage only
    HRESULT _Init(DWORD dwFlags);

public:
    CHardwareDevicesVolumesEnumImpl();
    ~CHardwareDevicesVolumesEnumImpl();

private:
    class CNamedElemEnum*       _penum;
    DWORD                       _dwFlags;
};

typedef CUnkTmpl<CHardwareDevicesVolumesEnumImpl> CHardwareDevicesVolumesEnum;

///////////////////////////////////////////////////////////////////////////////
//
class CHardwareDevicesMountPointsEnumImpl : public CCOMBase,
    public IHardwareDevicesMountPointsEnum
{
public:
    // Interface IHardwareDevicesMountPointsEnum
	STDMETHODIMP Next(
        LPWSTR* ppszMountPoint,     // "c:\", or "d:\MountFolder\"
        LPWSTR* ppszDeviceIDVolume);// \\?\STORAGE#Volume#...{...GUID...}

public: // for CHardwareDevicesImpl usage only
    HRESULT _Init();

public:
    CHardwareDevicesMountPointsEnumImpl();
    ~CHardwareDevicesMountPointsEnumImpl();

private:
    class CNamedElemEnum*       _penum;
};

typedef CUnkTmpl<CHardwareDevicesMountPointsEnumImpl>
    CHardwareDevicesMountPointsEnum;

///////////////////////////////////////////////////////////////////////////////
//
class CAdviseClient : public CNamedElem
{
public:
    HRESULT Init(LPCWSTR pszElemName);

    HRESULT _Init(DWORD dwProcessID, ULONG_PTR hThread,
        ULONG_PTR pfctCallback);
    HRESULT _Cleanup();
    HRESULT WriteMemoryChunkInOtherProcess(SHHARDWAREEVENT* pshhe,
        DWORD cbSize, void** ppv);
    HRESULT QueueUserAPC(void* pv);
    HRESULT IsProcessStillAlive(void);

protected:
    CAdviseClient();
    ~CAdviseClient();

public:
    static HRESULT Create(CNamedElem** ppelem);

private:
    PAPCFUNC    _pfct;
    HANDLE      _hProcess;
    HANDLE      _hThread;
};

#endif // _REGNOTIF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\regnotifu.cpp ===
#include "regnotif.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CHardwareDevicesIME[] =
{
    _INTFMAPENTRY(CHardwareDevices, IHardwareDevices),
};

const INTFMAPENTRY* CHardwareDevices::_pintfmap = CHardwareDevicesIME;
const DWORD CHardwareDevices::_cintfmap =
    (sizeof(CHardwareDevicesIME)/sizeof(CHardwareDevicesIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHardwareDevices::_cfcb = NULL;

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CHardwareDevicesVolumesEnumIME[] =
{
    _INTFMAPENTRY(CHardwareDevicesVolumesEnum, IHardwareDevicesVolumesEnum),
};

const INTFMAPENTRY* CHardwareDevicesVolumesEnum::_pintfmap =
    CHardwareDevicesVolumesEnumIME;
const DWORD CHardwareDevicesVolumesEnum::_cintfmap =
    (sizeof(CHardwareDevicesVolumesEnumIME) /
    sizeof(CHardwareDevicesVolumesEnumIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHardwareDevicesVolumesEnum::_cfcb = NULL;

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CHardwareDevicesMountPointsEnumIME[] =
{
    _INTFMAPENTRY(CHardwareDevicesMountPointsEnum,
        IHardwareDevicesMountPointsEnum),
};

const INTFMAPENTRY* CHardwareDevicesMountPointsEnum::_pintfmap =
    CHardwareDevicesMountPointsEnumIME;
const DWORD CHardwareDevicesMountPointsEnum::_cintfmap =
    (sizeof(CHardwareDevicesMountPointsEnumIME) /
    sizeof(CHardwareDevicesMountPointsEnumIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHardwareDevicesMountPointsEnum::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\tstdrv\td_envlctnt\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <io.h>
#include <objbase.h>

#include <Y:\n5\public\internal\shell\inc\shpriv.h>

#ifndef UNICODE
#error This has to be UNICODE
#endif

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

int DoTest(int argc, wchar_t* argv[]);

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    return DoTest(argc, argv);
}
}

int DoTest(int , wchar_t* argv[])
{
    HRESULT hres = CoInitialize(NULL);

    wprintf(TEXT("%s\n"), argv[0]);

    if (SUCCEEDED(hres))
    {
        const IID IID_IStorageInfo =
            {0xDD0D40D0, 0x920D, 0x41eb,
            {0x9E, 0xDB, 0xA0, 0x98, 0x10, 0x1F, 0x19, 0x76}};
        const CLSID CLSID_StorageInfo =
            {0x22b88a46, 0xcb9b, 0x480e,
            {0x89, 0x1c, 0x96, 0x20, 0xfd, 0x87, 0x1, 0xcf}};

        IStorageInfo* pisi;

        hres = CoCreateInstance(CLSID_StorageInfo, NULL, CLSCTX_LOCAL_SERVER,
            IID_IStorageInfo, (void**)&pisi);
        
        if (SUCCEEDED(hres))
        {
            IEnumVolumeContent* penum;

            hres = pisi->EnumVolumeContent(TEXT("Test"), &penum);

            if (SUCCEEDED(hres))
            {
                LPWSTR psz1;
                LPWSTR psz2;

            	while (SUCCEEDED(hres = penum->Next(&psz1, &psz2)) && (S_FALSE != hres))
                {
                    wprintf(TEXT("%s: %s\n"), psz1, psz2);

                    CoTaskMemFree((VOID*)psz1);
                    CoTaskMemFree((VOID*)psz2);
                }

                penum->Release();
            }

            pisi->Release();
        }

    	CoUninitialize();
	}

    return !SUCCEEDED(hres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\svcsync.cpp ===
#include "svcsync.h"

#include "dbg.h"
#include "tfids.h"

extern HANDLE g_hShellHWDetectionThread = NULL;
extern const WCHAR g_szShellHWDetectionInitCompleted[] =
    TEXT("ShellHWDetectionInitCompleted");

HRESULT _CompleteShellHWDetectionInitialization()
{
    static BOOL fCompleted = FALSE;

    if (!fCompleted)
    {
        HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE,
                g_szShellHWDetectionInitCompleted);

        TRACE(TF_SVCSYNC,
            TEXT("ShellHWDetection Initialization NOT completed yet"));

        if (hEvent)
        {
            DWORD dwWait = WaitForSingleObject(hEvent, 0);

            if (WAIT_OBJECT_0 == dwWait)
            {
                // It's signaled!
                fCompleted = TRUE;

                TRACE(TF_SVCSYNC,
                    TEXT("ShellHWDetectionInitCompleted event was already signaled!"));
            }
            else
            {
                // Not signaled
                TRACE(TF_SVCSYNC,
                    TEXT("ShellHWDetectionInitCompleted event was NOT already signaled!"));
                
                // Just in case race condition of 2 threads in this fct
                HANDLE hTmp = InterlockedCompareExchangePointer(
                    &g_hShellHWDetectionThread, NULL,
                    g_hShellHWDetectionThread);

                if (hTmp)
                {
                    if (!SetThreadPriority(hTmp, THREAD_PRIORITY_NORMAL))
                    {
                        TRACE(TF_SVCSYNC,
                            TEXT("FAILED to set ShellHWDetection thread priority to NORMAL from ShellCOMServer"));
                    }
                    else
                    {
                        TRACE(TF_SVCSYNC,
                            TEXT("Set ShellHWDetection thread priority to NORMAL from ShellCOMServer"));
                    }
                }

                Sleep(0);

                dwWait = WaitForSingleObject(hEvent, 30000);

                if (hTmp)
                {
                    // No code should need this handle anymore.  If it's
                    // signaled it was signaled by the other thread, and will
                    // not be used over there anymore.
                    CloseHandle(hTmp);
                }

                if (WAIT_OBJECT_0 == dwWait)
                {
                    // It's signaled!
                    fCompleted = TRUE;

                    TRACE(TF_SVCSYNC,
                        TEXT("ShellHWDetection Initialization COMPLETED"));
                }               
                else
                {
                    // Out of luck, the ShellHWDetection service cannot
                    // complete its initialization...
                    TRACE(TF_SVCSYNC,
                        TEXT("ShellHWDetection Initialization lasted more than 30 sec: FAILED, dwWait = 0x%08X"),
                        dwWait);
                }
            }

            CloseHandle(hEvent);
        }
    }

    return (fCompleted ? S_OK : E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\special.cpp ===
#include "dtct.h"

#include "regnotif.h"
#include "vol.h"

#include "cmmn.h"

#include <dbt.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT _ProcessInterfaceDiskGenericArrival(LPCWSTR pszDeviceIntfID,
    BOOL )
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_DISK, &pnel);

    if (SUCCEEDED(hr))
    {
        CNamedElem* pelem;

        hr = pnel->GetOrAdd(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hr))
        {
            pelem->RCRelease();
        }

        pnel->RCRelease();
    }
       
    return hr;
}

HRESULT _ProcessInterfaceVolumeArrival(LPCWSTR pszDeviceIntfID)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

    if (SUCCEEDED(hr))
    {
        CNamedElem* pelem;
        
        hr = pnel->GetOrAdd(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hr))
        {
            // Was it already there, or just added?
            if (S_FALSE == hr)
            {
                // Added
                CVolume* pvol = (CVolume*)pelem;

                hr = pvol->HandleArrival();
            }
            
            pelem->RCRelease();
        }
        else
        {
            if (E_FAIL == hr)
            {
                hr = S_FALSE;
            }
        }

        pnel->RCRelease();
    }
       
    return hr;
}

HRESULT _ProcessInterfaceVolumeRemoval(LPCWSTR pszDeviceIntfID)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_VOLUME, &pnel);

    if (SUCCEEDED(hr))
    {
        CNamedElem* pelem;
        
        hr = pnel->Get(pszDeviceIntfID, &pelem);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            CHWDeviceInst* phwdevinst;
            CVolume* pvol = (CVolume*)pelem;

            pvol->HandleRemoval();

            hr = pvol->GetHWDeviceInst(&phwdevinst);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _TryAutoplay(pszDeviceIntfID, phwdevinst,
                    DBT_DEVICEREMOVECOMPLETE);
            }

            // If we're removing it, let's remove it from the list
            HRESULT hr2 = pnel->Remove(pszDeviceIntfID);

            hr = FAILED(hr2) ? hr2 : hr;

            pelem->RCRelease();
        }

        pnel->RCRelease();
    }
       
    return hr;
}

HRESULT _ProcessInterfaceCDROMArrival(LPCWSTR pszDeviceIntfID)
{
    return _ProcessInterfaceDiskGenericArrival(pszDeviceIntfID, TRUE);
}

HRESULT _ProcessInterfaceDiskArrival(LPCWSTR pszDeviceIntfID)
{
    return _ProcessInterfaceDiskGenericArrival(pszDeviceIntfID, FALSE);
}

HRESULT _ProcessInterfaceDiskRemoval(LPCWSTR pszDeviceIntfID)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_DISK, &pnel);

    if (S_OK == hr)
    {
        hr = pnel->Remove(pszDeviceIntfID);

        pnel->RCRelease();
    }
       
    return hr;
}

typedef HRESULT (*PROCESSINTERFACESPECIALCASEDFCT)(LPCWSTR pszDeviceIntfID);

struct INTERFACESPECIALCASED
{
    const GUID*                         pguid;
    PROCESSINTERFACESPECIALCASEDFCT     piscfctArrival;
    PROCESSINTERFACESPECIALCASEDFCT     piscfctRemoval;
};

const INTERFACESPECIALCASED _rgInterfaceSpecialCased[] =
{
    { &guidVolumeClass, _ProcessInterfaceVolumeArrival, _ProcessInterfaceVolumeRemoval, },
    { &guidCdRomClass, _ProcessInterfaceCDROMArrival, _ProcessInterfaceDiskRemoval, },
    { &guidDiskClass, _ProcessInterfaceDiskArrival, _ProcessInterfaceDiskRemoval, },
};

HRESULT _IsInterfaceSpecialCased(GUID* pguidClass, BOOL* pfSpecialCased)
{
    *pfSpecialCased = FALSE;

    for (DWORD dw = 0; !(*pfSpecialCased) &&
        (dw < ARRAYSIZE(_rgInterfaceSpecialCased)); ++dw)
    {
        if (*pguidClass == *(_rgInterfaceSpecialCased[dw].pguid))
        {
            *pfSpecialCased = TRUE;
        }
    }

    return S_OK;
}

HRESULT _ProcessInterfaceSpecialCased(GUID* pguidInterface,
    LPCWSTR pszDeviceIntfID, DWORD dwEventType)
{
    HRESULT hr;

    if ((DBT_DEVICEARRIVAL == dwEventType) ||
        (DBT_DEVICEREMOVECOMPLETE == dwEventType))
    {
        BOOL fExit = FALSE;

        hr = E_UNEXPECTED;

        for (DWORD dw = 0; !fExit &&
            (dw < ARRAYSIZE(_rgInterfaceSpecialCased)); ++dw)
        {
            if (*pguidInterface == *(_rgInterfaceSpecialCased[dw].pguid))
            {
                PROCESSINTERFACESPECIALCASEDFCT piscfct;

                if (DBT_DEVICEARRIVAL == dwEventType)
                {
                    piscfct = _rgInterfaceSpecialCased[dw].piscfctArrival;
                }
                else
                {
                    piscfct = _rgInterfaceSpecialCased[dw].piscfctRemoval;
                }

                fExit = TRUE;

                hr = (piscfct)(pszDeviceIntfID);
            }
        }

        if (!fExit)
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        // Don't care about others for now
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\vol.h ===
#include "namellst.h"

#include "hwdev.h"

#include "cmmn.h"

#include "misc.h"

#include <objbase.h>
#include <shpriv.h>

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////

class CVolume : public CNamedElem, public CHandleNotifTarget
{
public:
    // CNamedElem
    HRESULT Init(LPCWSTR pszElemName);

    // CHandleNotifTarget
    HRESULT HNTHandleEvent(DEV_BROADCAST_HANDLE* pdbh, DWORD dwEventType);

    // CVolume
    //      Returns S_FALSE if can't find it
    HRESULT GetHWDeviceInst(CHWDeviceInst** pphwdevinst);

    HRESULT GetDeviceType(DEVICE_TYPE* pdevtype);
    HRESULT GetDeviceNumber(ULONG* puldeviceNumber);
    
    HRESULT GetVolumeConstInfo(LPWSTR pszVolumeGUID, DWORD cchVolumeGUID,
        DWORD* pdwVolumeFlags, DWORD* pdwDriveType, DWORD* pdwDriveCap);

    HRESULT GetVolumeMediaInfo(LPWSTR pszLabel, DWORD cchLabel, 
        LPWSTR pszFileSystem, DWORD cchFileSystem, DWORD* pdwFileSystemFlags,
        DWORD* pdwMaxFileNameLen, DWORD* pdwRootAttributes,
        DWORD* pdwSerialNumber, DWORD* pdwDriveState, DWORD* pdwMediaState,
        DWORD* pdwMediaCap);

    HRESULT GetIconAndLabelInfo(LPWSTR pszAutorunIconLocation,
        DWORD cchAutorunIconLocation, LPWSTR pszAutorunLabel, DWORD cchAutorunLabel,
        LPWSTR pszIconLocationFromService, DWORD cchIconLocationFromService,
        LPWSTR pszNoMediaIconLocationFromService,
        DWORD cchNoMediaIconLocationFromService,
        LPWSTR pszLabelFromService, DWORD cchLabelFromService);

    HRESULT HandleArrival();
    HRESULT HandleRemoval();

    // Caller needs to free the returned ppsz
    HRESULT GetAllMountPoints(LPWSTR* ppsz);

    HRESULT MediaIsAccessible(BOOL* pfAccessible);

public:
    static HRESULT Create(CNamedElem** ppelem);
    static HRESULT GetFillEnum(CFillEnum** ppfillenum);

public:
    CVolume();
    ~CVolume();

private:
    HRESULT _InitHelper(LPCWSTR pszElemName);
    void _HandleAccessDenied();

    HRESULT _CreateMountPoints();
    HRESULT _UpdateMountPoints();
    HRESULT _GetMountPoints(LPWSTR* ppsz, DWORD* pcch);
    HRESULT _CreateMtPt(LPWSTR pszMtPt);
    HRESULT _RemoveMtPt(LPWSTR pszMtPt);

    HRESULT _RegisterNotif();
    HRESULT _UnregisterNotif();

    HRESULT _InitDriveType(HANDLE hDevice);
    HRESULT _InitHWDeviceInst();
    HRESULT _UpdateConstInfo(HANDLE hDevice);
    HRESULT _UpdateMediaInfo(HANDLE hDevice, BOOL fImpersonate);
    HRESULT _UpdateMediaInfoOnRemove();

    HRESULT _UpdateSoftEjectCaps();
    HRESULT _UpdateRemovableDevice();
    HRESULT _UpdateHasMedia(HANDLE hDevice);
    HRESULT _UpdateSpecialFilePresence();
    HRESULT _UpdateTrackInfo(HANDLE hDevice);
    HRESULT _FillMMC2CD(HANDLE hDevice);
    HRESULT _UpdateMMC2CDInfo(HANDLE hDevice);

    HRESULT _ExtractAutorunIconAndLabel();

    HRESULT _GetDeviceHandleSafe(HANDLE* phDevice, BOOL fGenericReadRequired);
    HRESULT _CloseDeviceHandleSafe(HANDLE hDevice);

    HRESULT _HandleMediaArrival();
    HRESULT _HandleMediaRemoval();
    HRESULT _HandleVolumeChange();

    HRESULT _AdviseVolumeChangeHelper(BOOL fAdded);
    HRESULT _AdviseMountPointHelper(LPCWSTR pszMountPoint, BOOL fAdded);
    HRESULT _AdviseVolumeMountingEvent(DWORD dwEvent);
    HRESULT _GetVOLUMEINFO2(VOLUMEINFO2** ppvolinfo2);

    HRESULT _ShouldTryAutoplay(BOOL* pfTry);

    HRESULT _GetDeviceIDDisk(LPWSTR pszDeviceIDDisk,
        DWORD cchDeviceIDDisk);

    HRESULT _DVDRAMHack(HANDLE hDevice);

public:
    DWORD                               _dwState;

private:
    DWORD                               _dwMediaPresentFromEvent;

    DWORD                               _dwMediaState;
    DWORD                               _dwMediaCap;

    WCHAR                               _szVolumeGUID[50];
    DWORD                               _dwVolumeFlags;
    DWORD                               _dwDriveType;
    DWORD                               _dwDriveCap;
    DWORD                               _dwDriveState;
    WCHAR                               _szDeviceIDDisk[MAX_DEVICEID];

    WCHAR                               _szLabel[MAX_LABEL];
    DWORD                               _dwSerialNumber;
    DWORD                               _dwMaxFileNameLen;
    DWORD                               _dwFileSystemFlags;
    WCHAR                               _szFileSystem[MAX_FILESYSNAME];

    DWORD                               _dwRootAttributes;

    DEVICE_TYPE                         _devtype;
    ULONG                               _ulDeviceNumber;
    ULONG                               _ulPartitionNumber;

    LPWSTR                              _pszMountPoints;
    DWORD                               _cchMountPoints;

    CHWDeviceInst                       _hwdevinst;
    BOOL                                _fHWDevInstInited;

    DWORD*                              _prgMMC2Features;
    BOOL                                _fFirstTime;

    CCriticalSection                    _cs;

    DEVINST                             _devinst;

    HDEVNOTIFY                          _hdevnotify;
#ifdef DEBUG
    BOOL                                _fGenericReadRequired;
#endif

    BOOL                                _fProcessMediaArrived;

public: //for now, and for CStorageInfoImpl only
    WCHAR                               _szAutorunIconLocation[MAX_ICONLOCATION];
    WCHAR                               _szAutorunLabel[MAX_LABEL];
};

class CVolumeFillEnum : public CFillEnum
{
public:
    HRESULT Next(LPWSTR pszElemName, DWORD cchElemName, DWORD* pcchRequired);

public:
    HRESULT _Init();

private:
    CIntfFillEnum   _intffillenum;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\svcsync.h ===
#include <objbase.h>

extern HANDLE g_hShellHWDetectionThread;
extern const WCHAR g_szShellHWDetectionInitCompleted[];

HRESULT _CompleteShellHWDetectionInitialization();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\sources.inc ===
USE_MSVCRT=1
UMTYPE=windows

!include ..\..\shsrvice.inc
SOURCES_USED = $(SOURCES_USED) ..\..\shsrvice.inc

TARGETNAME=shhwdtct
TARGETPATH=obj

SOURCES = \
    ..\cmmn.cpp      \
    ..\cstmprop.cpp  \
    ..\cstmpropu.cpp \
    ..\devinfo.cpp   \
    ..\devinfou.cpp  \
    ..\dispatch.cpp  \
    ..\drvbase.cpp   \
    ..\dtct.cpp      \
    ..\dtctimp.cpp   \
    ..\dtctreg.cpp   \
    ..\dtctu.cpp     \
    ..\factdata.cpp  \
    ..\gdtinfo.cpp   \
    ..\logging.cpp   \
    ..\hnotif.cpp    \
    ..\hwdev.cpp     \
    ..\miscdev.cpp   \
    ..\mtpts.cpp     \
    ..\pnp.cpp       \
    ..\regnotif.cpp  \
    ..\regnotifu.cpp \
    ..\setenum.cpp   \
    ..\setenumu.cpp  \
    ..\settings.cpp  \
    ..\settingsu.cpp \
    ..\special.cpp   \
    ..\svcsync.cpp   \
    ..\vol.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\settingsu.cpp ===
#include "settings.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CAutoplayHandlerIME[] =
{
    _INTFMAPENTRY(CAutoplayHandler, IAutoplayHandler),
};

const INTFMAPENTRY* CAutoplayHandler::_pintfmap = CAutoplayHandlerIME;
const DWORD CAutoplayHandler::_cintfmap =
    (sizeof(CAutoplayHandlerIME)/sizeof(CAutoplayHandlerIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CAutoplayHandler::_cfcb = NULL;

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY CAutoplayHandlerPropertiesIME[] =
{
    _INTFMAPENTRY(CAutoplayHandlerProperties, IAutoplayHandlerProperties),
};

const INTFMAPENTRY* CAutoplayHandlerProperties::_pintfmap = CAutoplayHandlerPropertiesIME;
const DWORD CAutoplayHandlerProperties::_cintfmap =
    (sizeof(CAutoplayHandlerPropertiesIME)/sizeof(CAutoplayHandlerPropertiesIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CAutoplayHandlerProperties::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shhwdtct\vol.cpp ===
#include "vol.h"

#include "hwdev.h"
#include "hnotif.h"
#include "mtpts.h"
#include "regnotif.h"
#include "drvbase.h"
#include "dtctreg.h"
#include "users.h"

//
// ISSUE-2001/01/08-StephStm  that's bad, vol should not depend on dtct...
//
#include "dtct.h"

#include "reg.h"
#include "sfstr.h"
#include "misc.h"

#pragma warning(disable: 4201)
#include <winioctl.h>
#pragma warning(default: 4201)

#include <ntddcdrm.h>
#include <ntddmmc.h>
#include <ioevent.h>
#include <shpriv.h>

#include <setupapi.h>

#include "mischlpr.h"
#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#define STATE_DRIVETYPE                 0x00000001
#define STATE_UPDATECONSTINFO           0x00000002
#define STATE_DEVICENUMBERINFO          0x00000004
#define STATE_DEVICEINST                0x00000008
#define STATE_HWDEVICEINST              0x00000010
#define STATE_MEDIAINFO                 0x00000020
#define STATE_GVIFAILED                 0x10000000
#define STATE_GFAFAILED                 0x20000000
#define STATE_UPDATEHASMEDIAFAILED      0x40000000

#define INVALID_DWORD                   ((DWORD)-1)

#define MPFE_UNDETERMINED               ((DWORD)0x0DEF0DEF)
#define MPFE_FALSE                      ((DWORD)0)
#define MPFE_TRUE                       ((DWORD)1)

///////////////////////////////////////////////////////////////////////////////
// Public
// No need for the critical section, since it will not be added to the
// NamedList until init is finsihed and has succeeded.  Until it's in the
// namedlist, no code can grab a pointer to this object and call it.
HRESULT CVolume::Init(LPCWSTR pszElemName)
{
    HRESULT hres = _SetName(pszElemName);

    if (SUCCEEDED(hres))
    {
        CImpersonateEveryone* pieo;

        hres = CHWEventDetectorHelper::GetImpersonateEveryone(&pieo);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            hres = pieo->Impersonate();

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                hres = _InitHelper(pszElemName);

                pieo->RevertToSelf();
            }

            pieo->RCRelease();
        }
    }

    return hres;
}

HRESULT _IsDeviceFullyInstalled(LPCWSTR pszDeviceIntfID, BOOL* pfDeviceFullyInstalled)
{
    HRESULT hr = E_FAIL;
    HDEVINFO hdevinfo = SetupDiCreateDeviceInfoList(NULL, NULL);

    *pfDeviceFullyInstalled = FALSE;

    if (INVALID_HANDLE_VALUE != hdevinfo)
    {
        SP_DEVICE_INTERFACE_DATA sdid = {0};

        sdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        if (SetupDiOpenDeviceInterface(hdevinfo, pszDeviceIntfID, 0, &sdid))
        {
            DWORD cbsdidd = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                (MAX_DEVICE_ID_LEN * sizeof(WCHAR));

            SP_DEVINFO_DATA sdd = {0};
            SP_DEVICE_INTERFACE_DETAIL_DATA* psdidd =
                (SP_DEVICE_INTERFACE_DETAIL_DATA*)LocalAlloc(LPTR, cbsdidd);

            if (psdidd)
            {
                psdidd->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                sdd.cbSize = sizeof(SP_DEVINFO_DATA);

                // SetupDiGetDeviceInterfaceDetail (below) requires that the
                // cbSize member of SP_DEVICE_INTERFACE_DETAIL_DATA be set
                // to the size of the fixed part of the structure, and to pass
                // the size of the full thing as the 4th param.

                if (SetupDiGetDeviceInterfaceDetail(hdevinfo, &sdid, psdidd,
                    cbsdidd, NULL, &sdd))
                {
                    DWORD dw;

                    if (SetupDiGetDeviceRegistryProperty(hdevinfo, &sdd,
                        SPDRP_INSTALL_STATE, 0, (PBYTE)&dw, sizeof(dw), NULL))
                    {
                        TRACE(TF_VOLUME, TEXT(">>>> Got SPDRP_INSTALL_STATE property: 0x%08X"), dw);

                        if (CM_INSTALL_STATE_INSTALLED == dw)
                        {
                            *pfDeviceFullyInstalled = TRUE;
                        }

                        hr = S_OK;
                    }
                }

                LocalFree((HLOCAL)psdidd);
            }
        }

        SetupDiDestroyDeviceInfoList(hdevinfo);
    }

    return hr;
}

HRESULT CVolume::_InitHelper(LPCWSTR pszElemName)
{
    BOOL fDeviceFullyInstalled;
    HRESULT hres = _IsDeviceFullyInstalled(_pszElemName, &fDeviceFullyInstalled);

    if (SUCCEEDED(hres))
    {
        if (!fDeviceFullyInstalled)
        {
            TRACE(TF_VOLUME,
                TEXT("!!!!!!!!!!!! Device not fully installed!\n   %s"),
                pszElemName);

            hres = E_FAIL;
        }
        else
        {
            HANDLE hDevice;
            BOOL fCloseHandle = TRUE;

            hres = _GetDeviceHandleSafe(&hDevice, FALSE);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                hres = _InitDriveType(hDevice);

                if (SUCCEEDED(hres))
                {
                    _dwState |= STATE_DRIVETYPE;

                    hres = S_OK;

                    if ((HWDTS_FIXEDDISK != _dwDriveType) &&
                        (HWDTS_FLOPPY35 != _dwDriveType) &&
                        (HWDTS_FLOPPY525 != _dwDriveType))
                    {
                        _CloseDeviceHandleSafe(hDevice);

                        fCloseHandle = FALSE;

                        // Removable disk drives + CD require access to
                        // the media to query all the required info
                        hres = _GetDeviceHandleSafe(&hDevice, TRUE);
                    }

                    if (SUCCEEDED(hres) && (S_FALSE != hres))
                    {
                        hres = _UpdateConstInfo(hDevice);

                        if (SUCCEEDED(hres))
                        {
                            _dwState |= STATE_UPDATECONSTINFO;
                        }

                        if ((HWDTS_FLOPPY35 != _dwDriveType) &&
                            (HWDTS_FLOPPY525 != _dwDriveType))
                        {
                            if (SUCCEEDED(hres))
                            {
                                fCloseHandle = TRUE;

                                hres = _GetDeviceNumberInfoFromHandle(hDevice,
                                    &_devtype, &_ulDeviceNumber,
                                    &_ulPartitionNumber);

                                if (SUCCEEDED(hres))
                                {
                                    if (S_FALSE != hres)
                                    {
                                        _dwState |= STATE_DEVICENUMBERINFO;
                                    }

                                    GUID guidDummy;

                                    hres = _GetDeviceInstance(pszElemName,
                                        &_devinst, &guidDummy);

                                    if (SUCCEEDED(hres) && (S_FALSE != hres))
                                    {
                                        _dwState |= STATE_DEVICEINST;

                                        hres = _InitHWDeviceInst();

                                        if (SUCCEEDED(hres) && (S_FALSE != hres))
                                        {
                                            hres = _UpdateSoftEjectCaps();

                                            if (SUCCEEDED(hres))
                                            {
                                                hres = _UpdateRemovableDevice();
                                            }
                                        }
                                    }
                                }

                                // We need to do this anyway, even if the
                                // DeviceNumber stuff and/or the deviceInst stuff
                                // fails.  Otherwise we'll have a very sorry volume.
                                if (SUCCEEDED(hres))
                                {
                                    hres = _UpdateMediaInfo(hDevice, FALSE);

                                    if (SUCCEEDED(hres))
                                    {
                                        if (S_FALSE != hres)
                                        {
                                            _dwState |= STATE_MEDIAINFO;
                                        }

                                        hres = _RegisterNotif();
                                    }
                                }
                            }
                        }

                        if (SUCCEEDED(hres))
                        {
                            hres = _CreateMountPoints();
                        }
                    }
                    else
                    {
                        _HandleAccessDenied();
                    }
                }

                if (fCloseHandle)
                {
                    _CloseDeviceHandleSafe(hDevice);
                }
            }
            else
            {
                _HandleAccessDenied();
            }
        }
    }

    return hres;
}

void CVolume::_HandleAccessDenied()
{
    if (ERROR_ACCESS_DENIED == GetLastError())
    {
        _dwVolumeFlags |= HWDVF_STATE_ACCESSDENIED;
    }
}

// *pdwFloppy
//      0: not a floppy
//     35: 3.5" flopy
//    525: 5.25" floppy
HRESULT _DeviceIsFloppy(HANDLE hDevice, DWORD* pdwFloppy, BOOL* pfFloppySupportsSoftEject)
{
    HRESULT hres = S_FALSE;
    DISK_GEOMETRY dg[12] = {0};
    DWORD cbBuf = sizeof(dg);
    DWORD dwReturned;

    *pdwFloppy = 0;
    *pfFloppySupportsSoftEject = FALSE;

    // Should be IOCTL_..._DISK_GEOMETRY...
    if (DeviceIoControl(hDevice, IOCTL_DISK_GET_MEDIA_TYPES,
        NULL, 0, dg, cbBuf, &dwReturned, NULL))
    {
        DWORD cMediaInfo = dwReturned / sizeof(DISK_GEOMETRY);

        for (DWORD dw = 0; !(*pdwFloppy) && (dw < cMediaInfo); ++dw)
        {
            switch (dg[dw].MediaType)
            {
                case F5_1Pt2_512: // Cap: 1200
                case F5_360_512: // Cap: 360
                case F5_320_512: // Cap: 360
                case F5_320_1024: // Cap: 360
                case F5_180_512: // Cap: 360
                case F5_160_512: // Cap: 360
                    *pdwFloppy = 525;
                    break;

                case F3_120M_512:  // Cap: 120MB
                    *pfFloppySupportsSoftEject = TRUE;

                case F3_1Pt44_512: // Cap: 1440
                case F3_2Pt88_512: // Cap: 2880
                case F3_20Pt8_512: // Cap: 2880
                case F3_720_512:  // Cap: 720
                    *pdwFloppy = 35;
                    break;
                //
                // Japanese specific device types from here.
                //
                case F5_1Pt23_1024: // Cap: 1200
                case F5_640_512: // Cap: 260
                case F5_720_512: // Cap: 360
                    *pdwFloppy = 525;
                    break;

                case F3_640_512: // Cap: 720
                case F3_1Pt2_512: // Cap: 1440 
                case F3_1Pt23_1024: // Cap: 1440
                    *pdwFloppy = 35;
                    break;

                case F3_128Mb_512: // Cap: ?
                case F3_230Mb_512: // Cap: ?
                case F3_200Mb_512:
                    *pdwFloppy = 35;
                    break;
            }

            if (*pdwFloppy)
            {
                hres = S_OK;
            }
        }
    }

    return hres;
}

HRESULT _GetDriveTypeInfo(HANDLE hDevice, DWORD* pdwDriveType, BOOL* pfFloppy);

HRESULT CVolume::_InitDriveType(HANDLE hDevice)
{
    BOOL fFloppy = FALSE;

    HRESULT hr = _GetDriveTypeInfo(hDevice, &_dwDriveType, &fFloppy);

    if (SUCCEEDED(hr))
    {
        if (fFloppy)
        {
            DWORD dwFloppy;
            BOOL fFloppySupportsSoftEject;

            hr = _DeviceIsFloppy(hDevice, &dwFloppy, &fFloppySupportsSoftEject);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (fFloppySupportsSoftEject)
                {
                    _dwDriveCap |= HWDDC_FLOPPYSOFTEJECT;
                }

                switch (dwFloppy)
                {
                    case 35:
                        _dwDriveType = HWDTS_FLOPPY35;
                        break;
                    case 525:
                        _dwDriveType = HWDTS_FLOPPY525;
                }
            }
        }
    }

    return hr;
}

HRESULT _GetRemovableDeviceInstRecurs(DEVINST devinst,
    DEVINST* pdevinst)
{
    BOOL fRemovable;
    HRESULT hres = _DeviceInstIsRemovable(devinst, &fRemovable);

    if (SUCCEEDED(hres))
    {
        if (fRemovable)
        {
            // Found it!
            *pdevinst = devinst;
        }
        else
        {
            // Recurse
            DEVINST devinstParent;

            CONFIGRET cr = CM_Get_Parent_Ex(&devinstParent, devinst, 0,
                NULL);

            if (CR_SUCCESS == cr)
            {
                hres = _GetRemovableDeviceInstRecurs(devinstParent, pdevinst);
            }
            else
            {
                hres = S_FALSE;
            }
        }
    }

    return hres;
}

HRESULT CVolume::_GetDeviceIDDisk(LPWSTR pszDeviceIDDisk,
    DWORD cchDeviceIDDisk)
{
    HRESULT hr;

    if (_szDeviceIDDisk[0])
    {
        hr = SafeStrCpyN(pszDeviceIDDisk, _szDeviceIDDisk, cchDeviceIDDisk);
    }
    else
    {
        if (((ULONG)-1) != _ulDeviceNumber)
        {
            CNamedElemList* pnel;
            hr = CHWEventDetectorHelper::GetList(HWEDLIST_DISK, &pnel);

            if (S_OK == hr)
            {
                CNamedElemEnum* penum;

                hr = pnel->GetEnum(&penum);

                if (SUCCEEDED(hr))
                {
                    CNamedElem* pelem;
                    BOOL fFoundIt = FALSE;

                    while (!fFoundIt && SUCCEEDED(hr = penum->Next(&pelem)) &&
                        (S_FALSE != hr))
                    {
                        CDisk* pdisk = (CDisk*)pelem;
                        ULONG ulDeviceNumber;

                        hr = pdisk->GetDeviceNumber(&ulDeviceNumber);

                        if (SUCCEEDED(hr) && (S_FALSE != hr))
                        {
                            if (_ulDeviceNumber == ulDeviceNumber)
                            {
                                DEVICE_TYPE devtype;

                                hr = pdisk->GetDeviceType(&devtype);

                                if (SUCCEEDED(hr) && (S_FALSE != hr))
                                {
                                    if (_devtype == devtype)
                                    {
                                        // Use me!
                                        DWORD cchReq;

                                        hr = pelem->GetName(pszDeviceIDDisk,
                                            cchDeviceIDDisk, &cchReq);

                                        fFoundIt = TRUE;
                                    }
                                }
                            }
                        }

                        pelem->RCRelease();
                    }

                    penum->RCRelease();
                }

                pnel->RCRelease();
            }
        }
        else
        {
            hr = S_FALSE;
        }

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            if (FAILED(SafeStrCpyN(_szDeviceIDDisk, pszDeviceIDDisk,
                ARRAYSIZE(_szDeviceIDDisk))))
            {
                _szDeviceIDDisk[0] = 0;
            }
        }
    }

    return hr;
}

HRESULT CVolume::_InitHWDeviceInst()
{
    WCHAR szDeviceIDDisk[MAX_DEVICEID];

    HRESULT hr = _GetDeviceIDDisk(szDeviceIDDisk, ARRAYSIZE(szDeviceIDDisk));

    if (SUCCEEDED(hr))
    {
        DEVINST devinstFinal = 0;
        GUID guidDummy;

        if (S_FALSE != hr)
        {
            DEVINST devinstDisk;

            hr = _GetDeviceInstance(szDeviceIDDisk, &devinstDisk, &guidDummy);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _GetRemovableDeviceInstRecurs(devinstDisk, &devinstFinal);

                if (SUCCEEDED(hr))
                {
                    if (S_FALSE == hr)
                    {
                        // Maybe this is not a removable device (not talking
                        // about removable disk).
                        BOOL fFoundProp;
                        WCHAR szProp[1];
                        ULONG ulData = sizeof(szProp);

                        // First check if the disk interface has customn properties associated with it.
                        CONFIGRET cr = CM_Get_DevNode_Custom_Property(devinstDisk, TEXT("DeviceGroup"),
                            NULL, (PBYTE)szProp, &ulData, 0);

                        if ((CR_SUCCESS == cr) || (CR_BUFFER_SMALL == cr))
                        {
                            fFoundProp = TRUE;
                        }
                        else
                        {
                            ulData = sizeof(szProp);
                            cr = CM_Get_DevNode_Custom_Property(devinstDisk, TEXT("Icons"),
                                NULL, (PBYTE)szProp, &ulData, 0);

                            if ((CR_SUCCESS == cr) || (CR_BUFFER_SMALL == cr))
                            {
                                fFoundProp = TRUE;
                            }
                            else
                            {
                                fFoundProp = FALSE;
                            }
                        }

                        if (fFoundProp)
                        {
                            devinstFinal = devinstDisk;
                            hr = S_OK;
                        }
                        else
                        {
                            // Let's get the parent devinst of this devinst.
                            if (CR_SUCCESS == CM_Get_Parent_Ex(&devinstFinal,
                                devinstDisk, 0, NULL))
                            {
                                hr = S_OK;
                                DIAGNOSTIC((TEXT("[0303]Got DeviceInst from parent of disk")));

                                TRACE(TF_VOLUME,
                                    TEXT("HWDevInst: Got devinst from parent of Disk for Disk\n    %s"),
                                    _pszElemName);
                            }
                        }
                    }
                    else
                    {
                        DIAGNOSTIC((TEXT("[0302]Got DeviceInst from Removable Device")));

                        TRACE(TF_VOLUME,
                            TEXT("HWDevInst: Got devinst from Removable Device for Volume\n    %s"),
                            _pszElemName);
                    }
                }
            }
            else
            {
                DIAGNOSTIC((TEXT("[0304]Did NOT get DeviceInst from the disk")));

                TRACE(TF_VOLUME,
                    TEXT("HWDevInst: Did not get a devinst from the Disk for Volume\n    %s"),
                    _pszElemName);
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0305]Got DeviceInst from Volume itself")));

            TRACE(TF_VOLUME,
                TEXT("HWDevInst: Did not get a Disk, get devinst from Volume itself for Volume\n    (%s)"),
                _pszElemName);

            // We did not get a device number for the volume
            // Let's get the device instance from the volume then, maybe there's no
            // volume-disk-device hierarchy
            hr = _GetDeviceInstance(_pszElemName, &devinstFinal, &guidDummy);
        }

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = _hwdevinst.Init(devinstFinal);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                hr = _hwdevinst.InitInterfaceGUID(&guidVolumeClass);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    _fHWDevInstInited = TRUE;
                }
            }
        }
    }

    return hr;
}

HRESULT CVolume::GetHWDeviceInst(CHWDeviceInst** pphwdevinst)
{
    HRESULT hr;

    if (_fHWDevInstInited)
    {
        *pphwdevinst = &_hwdevinst;
        hr = S_OK;
    }
    else
    {
        *pphwdevinst = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::GetDeviceNumber(ULONG* puldeviceNumber)
{
    HRESULT hr;

    if (((DEVICE_TYPE)-1) != _devtype)
    {
        *puldeviceNumber = _ulDeviceNumber;
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;    
}

HRESULT CVolume::GetDeviceType(DEVICE_TYPE* pdevtype)
{
    HRESULT hr;

    if (((DEVICE_TYPE)-1) != _devtype)
    {
        *pdevtype = _devtype;
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::_ShouldTryAutoplay(BOOL* pfTry)
{
    HRESULT hr;

    if (_dwMediaState & HWDMS_PRESENT)
    {
        if (_dwMediaState & HWDMS_FORMATTED)
        {
            if (!(_dwMediaCap & HWDMC_HASDVDMOVIE))
            {
                if (!(_dwMediaCap & HWDMC_HASAUTORUNINF) ||
                    (_dwMediaCap & HWDMC_HASUSEAUTOPLAY))
                {
                    WCHAR szVolumeGUID[MAX_PATH + 50];
                    LPWSTR pszFile;

                    if (_dwMediaCap & HWDMC_HASUSEAUTOPLAY)
                    {
                        DIAGNOSTIC((TEXT("[0316]Autorun.inf, BUT as a UseAutoPLAY entry -> try Autoplay!")));
                    }

                    hr = SafeStrCpyN(szVolumeGUID, _szVolumeGUID,
                        ARRAYSIZE(szVolumeGUID));

                    *pfTry = TRUE;

                    if (SUCCEEDED(hr))
                    {
                        HKEY hkey;
                        pszFile = szVolumeGUID + lstrlen(szVolumeGUID);

                        TRACE(TF_LEAK, TEXT("Special files - BEGIN"));

                        hr = _RegOpenKey(HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoplayHandlers\\CancelAutoplay\\Files"),
                            &hkey);

                        if (SUCCEEDED(hr) && (S_FALSE != hr))
                        {
                            DWORD dwIndex = 0;

                            while ((*pfTry) && SUCCEEDED(hr = _RegEnumStringValue(hkey, dwIndex, pszFile,
                                (DWORD)(ARRAYSIZE(szVolumeGUID) - (pszFile - szVolumeGUID)))) &&
                                (S_FALSE != hr))
                            {
                                WIN32_FIND_DATA w32fd;
                                HANDLE h;

                                h = FindFirstFile(szVolumeGUID, &w32fd);

                                if (INVALID_HANDLE_VALUE != h)
                                {
                                    FindClose(h);

                                    *pfTry = FALSE;

                                    DIAGNOSTIC((TEXT("[0307]Detected special file : '%s' (%s) -> No Autoplay!"),
                                        w32fd.cFileName, pszFile));

                                    TRACE(TF_VOLUME,
                                        TEXT("Detected %s (%s) -> No Autoplay!"),
                                        w32fd.cFileName , pszFile);
                                }
                                
                                ++dwIndex;
                            }

                            _RegCloseKey(hkey);
                        }

                        TRACE(TF_LEAK, TEXT("Special files - END"));
                    }
                }
                else
                {
                    DIAGNOSTIC((TEXT("[0313]Autorun.inf -> No Content Autoplay!")));
                    hr = S_OK;
                    *pfTry = FALSE;
                }
            }
            else
            {
                DIAGNOSTIC((TEXT("[0312]DVD Movie -> No Content Autoplay!")));
                hr = S_OK;
                *pfTry = FALSE;
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0317]Media *NOT* formatted -> No Content Autoplay!")));
            hr = S_OK;
            *pfTry = FALSE;
        }
    }
    else
    {
        DIAGNOSTIC((TEXT("[0306]NO media -> No Content Autoplay!")));
        hr = S_OK;
        *pfTry = FALSE;
    }

    return hr;
}

HRESULT CVolume::_HandleMediaArrival()
{
    HANDLE hDevice;

    DIAGNOSTIC((TEXT("[0002]Processing Media Arrival Event: %s"), _pszElemName));

    HRESULT hr = _GetDeviceHandleSafe(&hDevice, TRUE);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        _dwMediaPresentFromEvent = MPFE_TRUE;
        
        _cs.Enter();

        hr = _UpdateMediaInfo(hDevice, TRUE);

        _cs.Leave();

        if (SUCCEEDED(hr))
        {
            if (_fHWDevInstInited)
            {
                // Try Autoplay?
                BOOL fTryAutoplay;

                hr = _ShouldTryAutoplay(&fTryAutoplay);

                if (SUCCEEDED(hr))
                {
                    if (fTryAutoplay)
                    {
                        BOOL fHasHandler;

                        hr = CHWEventDetectorImpl::HandleVolumeMediaEvent(
                            _pszElemName, &_hwdevinst, TEXT("MediaArrival"),
                            &fHasHandler);

                        if (SUCCEEDED(hr) && fHasHandler)
                        {
                            _dwVolumeFlags |= HWDVF_STATE_HASAUTOPLAYHANDLER;
                        }
                    }
                    else
                    {
                        _dwVolumeFlags |= HWDVF_STATE_DONOTSNIFFCONTENT;
                    }
                }
            }
            else
            {
                DIAGNOSTIC((TEXT("[0308]Cannot find hardware device for this volume -> No Autoplay!")));
            }

            if (SUCCEEDED(hr))
            {
                _AdviseVolumeChangeHelper(FALSE);
            }
        }

        _CloseDeviceHandleSafe(hDevice);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::_AdviseVolumeMountingEvent(DWORD dwEvent)
{
    return CHardwareDevicesImpl::_AdviseVolumeMountingEvent(_pszElemName,
        dwEvent);
}

HRESULT CVolume::_AdviseVolumeChangeHelper(BOOL fAdded)
{
    HRESULT hr;
    VOLUMEINFO2* pvolinfo2;

    _cs.Enter();

    hr = _GetVOLUMEINFO2(&pvolinfo2);

    _cs.Leave();

    if (SUCCEEDED(hr))
    {
        LPWSTR pszMtPts;
        DWORD cchMtPts;
        hr = _GetMountPoints(&pszMtPts, &cchMtPts);

        if (SUCCEEDED(hr))
        {
            CHardwareDevicesImpl::_AdviseVolumeArrivedOrUpdated(pvolinfo2,
                pszMtPts, cchMtPts, fAdded);

            if (S_FALSE != hr)
            {
                LocalFree((HLOCAL)pszMtPts);
            }
        }

        _FreeMemoryChunk<VOLUMEINFO2*>(pvolinfo2);
    }

    return hr;
}

HRESULT CVolume::_HandleMediaRemoval()
{
    HRESULT hr;

    DIAGNOSTIC((TEXT("[0003]Processing Media Removal Event: %s"), _pszElemName));

    _dwMediaPresentFromEvent = MPFE_FALSE;

    _cs.Enter();

    hr = _UpdateMediaInfoOnRemove();

    _cs.Leave();

    if (SUCCEEDED(hr))
    {
        _AdviseVolumeChangeHelper(FALSE);

        if (_fHWDevInstInited)
        {
            // Useless in this case, since there's no content, so we won't sniff
            BOOL fHasHandler;

            hr = CHWEventDetectorImpl::HandleVolumeMediaEvent(_pszElemName,
                &_hwdevinst, TEXT("MediaRemoval"), &fHasHandler);
        }
        else
        {
            DIAGNOSTIC((TEXT("[0309]Cannot find hardware device for this volume -> No Autoplay!")));
        }
    }

    return hr;
}

HRESULT CVolume::_HandleVolumeChange()
{
    HANDLE hDevice;
    HRESULT hr = _GetDeviceHandleSafe(&hDevice, TRUE);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        _cs.Enter();

        hr = _UpdateMediaInfo(hDevice, TRUE);

        _cs.Leave();

        if (SUCCEEDED(hr))
        {
            _AdviseVolumeChangeHelper(FALSE);
        }

        _CloseDeviceHandleSafe(hDevice);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::HNTHandleEvent(DEV_BROADCAST_HANDLE* pdbh,
    DWORD dwEventType)
{
    HRESULT hres = S_OK;

    if (DBT_CUSTOMEVENT == dwEventType)
    {
        if (GUID_IO_MEDIA_ARRIVAL == pdbh->dbch_eventguid)
        {
            // This notification arrive very soon when the media is inserted
            // in the device.  Often the Volume driver has not been loaded on
            // the drive and calls like GetVolumeInformation will fail.
            // Instead of doing something right now, flag the event, and
            // process on the first GUID_IO_VOLUME_MOUNT below.
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_MEDIA_ARRIVAL"));

            hres = _HandleMediaArrival();
            _fProcessMediaArrived = TRUE;
        }
        else if (GUID_IO_MEDIA_REMOVAL == pdbh->dbch_eventguid)
        {
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_MEDIA_REMOVAL"));

            hres = _HandleMediaRemoval();
        }
        else if (GUID_IO_VOLUME_MOUNT == pdbh->dbch_eventguid)
        {
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_VOLUME_MOUNT"));

            if (_fProcessMediaArrived)
            {
                _fProcessMediaArrived = FALSE;

//              hres = _HandleMediaArrival();
            }

            if (_dwVolumeFlags & HWDVF_STATE_DISMOUNTED)
            {
                _dwVolumeFlags &= ~HWDVF_STATE_DISMOUNTED;

                hres = _AdviseVolumeMountingEvent(
                    SHHARDWAREEVENT_VOLUMEMOUNTED);
            }
        }
        else if (GUID_IO_VOLUME_NAME_CHANGE == pdbh->dbch_eventguid)
        {
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_VOLUME_NAME_CHANGE"));

            _cs.Enter();

            hres = _UpdateMountPoints();

            _cs.Leave();
        }
        else if (GUID_IO_VOLUME_CHANGE == pdbh->dbch_eventguid)
        {
            TRACE(TF_SHHWDTCTDTCT,
                TEXT("****CVolume GUID_IO_VOLUME_CHANGE"));

            hres = _HandleVolumeChange();
        }
        else if (GUID_IO_VOLUME_DISMOUNT == pdbh->dbch_eventguid)
        {
            _dwVolumeFlags |= HWDVF_STATE_DISMOUNTED;

            hres = _AdviseVolumeMountingEvent(
                SHHARDWAREEVENT_VOLUMEDISMOUNTED);
        }
        else if (GUID_IO_VOLUME_DISMOUNT_FAILED == pdbh->dbch_eventguid)
        {
            _dwVolumeFlags &= ~HWDVF_STATE_DISMOUNTED;

            hres = _AdviseVolumeMountingEvent(
                SHHARDWAREEVENT_VOLUMEMOUNTED);
        }
    }

    return hres;
}

HRESULT CVolume::_GetDeviceHandleSafe(HANDLE* phDevice,
    BOOL fGenericReadRequired)
{
    ASSERT(!_hdevnotify);
    HRESULT hr;
    HANDLE hDevice = _GetDeviceHandle(_pszElemName,
        fGenericReadRequired ? GENERIC_READ : FILE_READ_ATTRIBUTES);

    *phDevice = INVALID_HANDLE_VALUE;

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DEV_BROADCAST_HANDLE dbhNotifFilter = {0};

        dbhNotifFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        dbhNotifFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        dbhNotifFilter.dbch_handle = hDevice;

        hr = CHWEventDetectorHelper::RegisterDeviceNotification(
                &dbhNotifFilter, &_hdevnotify, FALSE);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            *phDevice = hDevice;

#ifdef DEBUG
            _fGenericReadRequired = fGenericReadRequired;
#endif
        }
        else
        {
            _CloseDeviceHandle(hDevice);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CVolume::_CloseDeviceHandleSafe(HANDLE hDevice)
{
    ASSERT(_hdevnotify);

    _CloseDeviceHandle(hDevice);
    UnregisterDeviceNotification(_hdevnotify);

    _hdevnotify = NULL;

    return S_OK;
}

HRESULT CVolume::_UnregisterNotif()
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_HANDLENOTIF,
        &pnel);

    if (S_OK == hres)
    {
        hres = pnel->Remove(_pszElemName);

        if (_szDeviceIDDisk[0])
        {
            hres = pnel->Remove(_szDeviceIDDisk);
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT CVolume::_RegisterNotif()
{
    CNamedElemList* pnel;

    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_HANDLENOTIF,
        &pnel);

    if (S_OK == hres)
    {
        CNamedElem* pelem;

        // register for handle notification
        hres = pnel->GetOrAdd(_pszElemName, &pelem);

        // Was it already there or added?
        if (SUCCEEDED(hres) && (S_FALSE == hres))
        {
            // Added.  Initialize it.
            CHandleNotif* phnotif = (CHandleNotif*)pelem;

            hres = phnotif->InitNotif(this);

            if (SUCCEEDED(hres))
            {
                if (HWDTS_REMOVABLEDISK == _dwDriveType)
                {
                    // Removable disk drives receive their notifications for
                    // media arrival/removal on the disk interface, not the
                    // volume one, so register for this too.
                    WCHAR szDeviceIDDisk[MAX_DEVICEID];

                    hres = _GetDeviceIDDisk(szDeviceIDDisk,
                        ARRAYSIZE(szDeviceIDDisk));

                    if (SUCCEEDED(hres) && (S_FALSE != hres)) 
                    {
                        CNamedElem* pelem2;

                        // register for handle notification
                        hres = pnel->GetOrAdd(szDeviceIDDisk, &pelem2);

                        // Was it already there or added?
                        if (SUCCEEDED(hres) && (S_FALSE == hres))
                        {
                            // Added.  Initialize it.
                            CHandleNotif* phnotif2 = (CHandleNotif*)pelem2;

                            hres = phnotif2->InitNotif(this);

                            if (FAILED(hres))
                            {
                                pnel->Remove(szDeviceIDDisk);
                            }

                            pelem2->RCRelease();
                        }
                    }
                }
            }

            if (FAILED(hres))
            {
                pnel->Remove(_pszElemName);
            }

            pelem->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT CVolume::_RemoveMtPt(LPWSTR pszMtPt)
{
    CNamedElemList* pnel;
    HRESULT hr = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);
    
    if (S_OK == hr)
    {
        hr = pnel->Remove(pszMtPt);

        pnel->RCRelease();
    }

    return hr;
}

HRESULT CVolume::_CreateMtPt(LPWSTR pszMtPt)
{
    CNamedElemList* pnel;
    HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);
    
    if (S_OK == hres)
    {
        CNamedElem* pelem;
        hres = pnel->GetOrAdd(pszMtPt, &pelem);

        if (SUCCEEDED(hres))
        {
            // Init one way or the other
            CMtPt* pmtpt = (CMtPt*)pelem;

            hres = pmtpt->InitVolume(_pszElemName);

            if (FAILED(hres))
            {
                pnel->Remove(pszMtPt);
            }

            pelem->RCRelease();
        }

        pnel->RCRelease();
    }

    return hres;
}

HRESULT CVolume::_AdviseMountPointHelper(LPCWSTR pszMountPoint, BOOL fAdded)
{
    // I'd like to not call this from outside the crit sect
    ASSERT(_cs.IsInside());

    WCHAR szDeviceIDVolume[MAX_DEVICEID];
    DWORD cchReq;

    HRESULT hr = GetName(szDeviceIDVolume, ARRAYSIZE(szDeviceIDVolume), &cchReq);

    if (SUCCEEDED(hr))
    {
        CHardwareDevicesImpl::_AdviseMountPointHelper(pszMountPoint,
            szDeviceIDVolume, fAdded);                
    }

    return hr;
}

HRESULT CVolume::_UpdateMountPoints()
{
    LPWSTR pszMtPtNew;
    DWORD cchMtPtNew;
    HRESULT hr = _GetMountPoints(&pszMtPtNew, &cchMtPtNew);

#ifdef DEBUG
    if (_pszMountPoints)
    {
        TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: OLD mountPoints for %s:"), _pszElemName);

        for (LPWSTR psz = _pszMountPoints; *psz; psz += lstrlen(psz) + 1)
        {
            TRACE(TF_VOLUME, TEXT("    %s"), psz);
        }
    }
#endif

    if (SUCCEEDED(hr))
    {
        if (S_FALSE != hr)
        {
#ifdef DEBUG
            TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: NEW mountPoints:"));

            for (LPWSTR psz = pszMtPtNew; *psz; psz += lstrlen(psz) + 1)
            {
                TRACE(TF_VOLUME, TEXT("    %s"), psz);
            }
#endif
            // Was there at least one?
            if (_pszMountPoints)
            {
                // Yep, find the removed ones
                for (LPWSTR pszOld = _pszMountPoints; *pszOld;
                    pszOld += lstrlen(pszOld) + 1)
                {
                    BOOL fFoundInNew = FALSE;

                    for (LPWSTR pszNew = pszMtPtNew; !fFoundInNew && *pszNew;
                        pszNew += lstrlen(pszNew) + 1)
                    {
                        if (!lstrcmpi(pszNew, pszOld))
                        {
                            fFoundInNew = TRUE;
                        }
                    }

                    if (!fFoundInNew)
                    {
                        TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: Found DELETED one: %s"), pszOld);

                        // That's a deleted one
                        _RemoveMtPt(pszOld);

                        _AdviseMountPointHelper(pszOld, FALSE);
                    }
                }
            }
            else
            {
                TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: There was NO mountpoints before"));
            }

            // Find the new ones
            for (LPWSTR pszNew = pszMtPtNew; *pszNew;
                pszNew += lstrlen(pszNew) + 1)
            {
                BOOL fFoundInOld = FALSE;

                if (_pszMountPoints)
                {
                    for (LPWSTR pszOld = _pszMountPoints;
                        !fFoundInOld && *pszOld; pszOld += lstrlen(pszOld) + 1)
                    {
                        if (!lstrcmpi(pszNew, pszOld))
                        {
                            fFoundInOld = TRUE;
                        }
                    }
                }

                if (!fFoundInOld)
                {
                    TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: Found ADDED one: %s"), pszNew);

                    // That's a new one
                    _CreateMtPt(pszNew);

                    _AdviseMountPointHelper(pszNew, TRUE);
                }
            }

            LocalFree(_pszMountPoints);
            _pszMountPoints = pszMtPtNew;
            _cchMountPoints = cchMtPtNew;
        }
        else
        {
            TRACE(TF_VOLUME, TEXT("_UpdateMountPoints: NO MountPoints left, remove all old ones"));

            if (_pszMountPoints && *_pszMountPoints)
            {
                for (LPWSTR pszOld = _pszMountPoints; *pszOld;
                    pszOld += lstrlen(pszOld) + 1)
                {
                    _RemoveMtPt(pszOld);

                    _AdviseMountPointHelper(pszOld, FALSE);
                }

                LocalFree(_pszMountPoints);
                _pszMountPoints = NULL;
                _cchMountPoints = 0;
            }
        }
    }

    return hr;
}

HRESULT CVolume::GetAllMountPoints(LPWSTR* ppsz)
{
    HRESULT hr;

    _cs.Enter();

    if (_cchMountPoints && _pszMountPoints)
    {
        *ppsz = (LPWSTR)LocalAlloc(LPTR, _cchMountPoints * sizeof(WCHAR));

        if (*ppsz)
        {
            CopyMemory(*ppsz, _pszMountPoints, _cchMountPoints * sizeof(WCHAR));
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    _cs.Leave();

    return hr;
}

HRESULT CVolume::_CreateMountPoints()
{
    HRESULT hr = _GetMountPoints(&_pszMountPoints, &_cchMountPoints);

    if (SUCCEEDED(hr))
    {
        if (S_FALSE != hr)
        {
            for (LPWSTR psz = _pszMountPoints; *psz;
                psz += lstrlen(psz) + 1)
            {
                _CreateMtPt(psz);
                // go on even if error
            }
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}

// Caller must free returned data using LocalFree
HRESULT CVolume::_GetMountPoints(LPWSTR* ppsz, DWORD* pcch)
{
    HRESULT hr;
    LPWSTR psz = NULL;
    DWORD cch;

    *ppsz = NULL;
    *pcch = 0;

    if (GetVolumePathNamesForVolumeName(_szVolumeGUID, NULL, 0, &cch))
    {
        // no mountpoint, we're done
        hr = S_FALSE; 
    }
    else
    {
        // Expected, even wanted...
        if (ERROR_MORE_DATA == GetLastError())
        {
            psz = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));

            if (psz)
            {
                if (GetVolumePathNamesForVolumeName(_szVolumeGUID,
                    psz, cch, &cch))
                {
                    *ppsz = psz;
                    *pcch = cch;
                    hr = S_OK;
                }
                else
                {
                    LocalFree(psz);
                    hr = S_FALSE; 
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = S_FALSE; 
        }
    }

    return hr;
}

HRESULT _DeviceMediaIsAccessible(HANDLE hDevice, BOOL* pfAccessible)
{
    HRESULT hres = S_FALSE;
    DWORD dwDummy;

    *pfAccessible = FALSE;

    // requires GENERIC_READ access on the handle
    BOOL b = DeviceIoControl(hDevice, IOCTL_STORAGE_CHECK_VERIFY, NULL, 0, NULL, 0, &dwDummy, NULL);
    if (ERROR_MEDIA_CHANGED == GetLastError())
    {
        // try one more time, ERROR_MEDIA_CHANGED means it's still pending for a little bit.
        b = DeviceIoControl(hDevice, IOCTL_STORAGE_CHECK_VERIFY, NULL, 0, NULL, 0, &dwDummy, NULL);
    }

    if (b)
    {
        *pfAccessible = TRUE;
        hres = S_OK;
    }
    else
    {
        // ERROR_NOT_READY == GetLastError() means no media
        if (ERROR_NOT_READY == GetLastError())
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

HRESULT CVolume::_UpdateHasMedia(HANDLE hDevice)
{
    HRESULT hr = S_FALSE;

    switch (_dwDriveType)
    {
        case HWDTS_FIXEDDISK:
            _dwMediaState |= HWDMS_PRESENT;
            hr = S_OK;
            break;

        case HWDTS_REMOVABLEDISK:
        case HWDTS_CDROM:
        {
#if 0
 This does not work on my laptop
            if (_dwDriveCap & HWDDC_CAPABILITY_SUPPORTDETECTION)
            {
                // It's MMC2
                if (_dwMediaCap & (HWDMC_CDROM | HWDMC_CDRECORDABLE |
                    HWDMC_CDREWRITABLE | HWDMC_DVDROM | HWDMC_DVDRECORDABLE |
                    HWDMC_DVDRAM))
                {
                    _dwMediaState |= HWDMS_PRESENT;
                }
                else
                {
                    _dwMediaState &= ~HWDMS_PRESENT;
                }
            }
            else
#endif
            if (MPFE_UNDETERMINED != _dwMediaPresentFromEvent)
            {
                hr = S_OK;

                if (MPFE_TRUE == _dwMediaPresentFromEvent)
                {
                    _dwMediaState |= HWDMS_PRESENT;
                }
                else
                {
                    _dwMediaState &= ~HWDMS_PRESENT;
                }
            }
            else
            {
                BOOL fAccessible;

                ASSERT(_fGenericReadRequired);

                hr = _DeviceMediaIsAccessible(hDevice, &fAccessible);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    if (fAccessible)
                    {
                        _dwMediaState |= HWDMS_PRESENT;
                    }
                    else
                    {
                        _dwMediaState &= ~HWDMS_PRESENT;
                    }
                }
                else
                {
                    _dwMediaState &= ~HWDMS_PRESENT;
                }
            }

            break;
        }

        default:
        // ISSUE-2000/10/23-StephStm: We do not handle CD Changer, maybe we should            
        //
        // case HWDTS_CDCHANGER:
        case HWDTS_FLOPPY35:
        case HWDTS_FLOPPY525:
            _dwMediaState &= ~HWDMS_PRESENT;
            break;
    }

    return hr;
}

HRESULT CVolume::_ExtractAutorunIconAndLabel()
{
    WCHAR szInfFile[MAX_PATH + 50];
    LPWSTR pszNext;
    DWORD cchLeft;

    HRESULT hr = SafeStrCpyNEx(szInfFile, _szVolumeGUID, ARRAYSIZE(szInfFile),
        &pszNext, &cchLeft);

    if (SUCCEEDED(hr))
    {
        hr = SafeStrCpyN(pszNext, TEXT("Autorun.inf"), cchLeft);

        if (SUCCEEDED(hr))
        {
            WCHAR szDummy[4];
#if defined(_X86_)
            LPWSTR pszSection = TEXT("AutoRun.x86");
#elif defined(_AMD64_)
            LPWSTR pszSection = TEXT("AutoRun.Amd64");
#elif defined(_IA64_)
            LPWSTR pszSection = TEXT("AutoRun.Ia64");
#else
#error "No Target Architecture"
#endif

            // Flush some buffer somewhere
            WritePrivateProfileString(NULL, NULL, NULL, szInfFile);

            if (!GetPrivateProfileString(pszSection, TEXT("Icon"), TEXT(""),
                _szAutorunIconLocation, ARRAYSIZE(_szAutorunIconLocation),
                szInfFile))
            {
                pszSection = TEXT("AutoRun");

                _HandleAccessDenied();

                if (!GetPrivateProfileString(pszSection, TEXT("Icon"),
                    TEXT(""), _szAutorunIconLocation,
                    ARRAYSIZE(_szAutorunIconLocation), szInfFile))
                {
                    _szAutorunIconLocation[0] = 0;
                    _HandleAccessDenied();
                }
            }

            if (!GetPrivateProfileString(pszSection, TEXT("Label"), TEXT(""),
                _szAutorunLabel, ARRAYSIZE(_szAutorunLabel), szInfFile))
            {
                _szAutorunLabel[0] = 0;
                _HandleAccessDenied();
            }

            if (GetPrivateProfileString(pszSection, TEXT("Open"), TEXT(""),
                szDummy, ARRAYSIZE(szDummy), szInfFile) ||
                GetPrivateProfileString(pszSection, TEXT("ShellExecute"), TEXT(""),
                szDummy, ARRAYSIZE(szDummy), szInfFile))
            {
                _dwMediaCap |= HWDMC_HASAUTORUNCOMMAND;
            }
            else
            {
                _HandleAccessDenied();
            }

            if (GetPrivateProfileString(pszSection, TEXT("UseAutoPLAY"), TEXT(""),
                szDummy, ARRAYSIZE(szDummy), szInfFile))
            {
                _dwMediaCap |= HWDMC_HASUSEAUTOPLAY;
            }
            else
            {
                _HandleAccessDenied();
            }
        }
    }

    return hr;
}

HRESULT CVolume::_UpdateSpecialFilePresence()
{
    struct SPECIALFILEINFO
    {
        LPCWSTR     pszFile;
        DWORD       dwCapBit;
    };

    HRESULT hr;
    WCHAR szPath[50 + 1 + ARRAYSIZE(TEXT("video_ts\\video_ts.ifo"))];

    static const SPECIALFILEINFO rgsfi[] =
    {
        { TEXT("autorun.inf"), HWDMC_HASAUTORUNINF }, 
        { TEXT("desktop.ini"), HWDMC_HASDESKTOPINI }, 
        { TEXT("video_ts\\video_ts.ifo"), HWDMC_HASDVDMOVIE }, 
    };

    LPWSTR pszNext;
    DWORD cchLeft;

    hr = SafeStrCpyNEx(szPath, _szVolumeGUID,
        ARRAYSIZE(szPath), &pszNext, &cchLeft);

    if (SUCCEEDED(hr))
    {
        for (DWORD dw = 0; dw < ARRAYSIZE(rgsfi); ++dw)
        {
            hr = SafeStrCpyN(pszNext, rgsfi[dw].pszFile, cchLeft);

            if (SUCCEEDED(hr))
            {
                DWORD dwGFA = GetFileAttributes(szPath);
        
                if (-1 != dwGFA)
                {
                    _dwMediaCap |= (rgsfi[dw].dwCapBit);
                }
                else
                {
                    _HandleAccessDenied();
                }
            }
        }
    }
    
    // To fix bug 425431
    if (HWDMC_HASDVDMOVIE & _dwMediaCap)
    {
        // This better be a CD/DVD drive.
        if (HWDTS_CDROM != _dwDriveType)
        {
            // No.  Remove the flag otherwise, Hard Disks get a Play verb
            // when they have the ts_video\video_ts.ifo file in their root.
            _dwMediaCap &= ~HWDMC_HASDVDMOVIE;
        }
    }

    return hr;
}

#define TRACK_TYPE_MASK 0x04
#define AUDIO_TRACK     0x00
#define DATA_TRACK      0x04

HRESULT CVolume::_UpdateTrackInfo(HANDLE hDevice)
{
    HRESULT hr;

    ASSERT(!(_dwMediaCap & (HWDMC_HASDATATRACKS | HWDMC_HASAUDIOTRACKS)));

    hr = S_OK;
    // To be compatible with Win95, we'll only return TRUE from this
    // function if the disc has ONLY audio tracks (and NO data tracks).

    // FEATURE: Post NT-SUR beta 1, we should consider adding a new
    // DriveType flag for "contains data tracks" and revamp the commands
    // available on a CD-ROM drive.  The current code doesn't handle
    // mixed audio/data and audio/autorun discs very usefully. --JonBe

    // First try the new IOCTL which gives us a ULONG with bits indicating
    // the presence of either/both data & audio tracks

    CDROM_DISK_DATA data;
    DWORD dwDummy;

    // Requires GENERIC_READ access on the handle
    if (DeviceIoControl(hDevice, IOCTL_CDROM_DISK_TYPE, NULL, 0, &data,
        sizeof(data), &dwDummy, NULL))
    {
        if (data.DiskData & CDROM_DISK_AUDIO_TRACK)
        {
            _dwMediaCap |= HWDMC_HASAUDIOTRACKS;
        }

        if (data.DiskData & CDROM_DISK_DATA_TRACK)
        {
            _dwMediaCap |= HWDMC_HASDATATRACKS;
        }
    }
    else
    {
        // else that failed, so try to look for audio tracks the old way, by
        // looking throught the table of contents manually.  Note that data tracks
        // are supposed to be hidden in the TOC by CDFS now on mixed audio/data
        // discs (at least if the data tracks follow the audio tracks).
        CDROM_TOC  toc = {0};

        if (!DeviceIoControl(hDevice, IOCTL_CDROM_READ_TOC, NULL, 0, &toc,
            sizeof(toc), &dwDummy, NULL))
        {
            SUB_Q_CHANNEL_DATA subq = {0};
            CDROM_SUB_Q_DATA_FORMAT df = {0};

            // We might not have been able to read the TOC because the drive
            // was busy playing audio.  Lets try querying the audio position.
            df.Format = IOCTL_CDROM_CURRENT_POSITION;
            df.Track = 0;

            if (DeviceIoControl(hDevice, IOCTL_CDROM_READ_Q_CHANNEL, &df,
                sizeof(df), &subq, sizeof(subq), &dwDummy, NULL))
            {
                if (AUDIO_DATA_TRACK & subq.CurrentPosition.Control)
                {
                    _dwMediaCap |= HWDMC_HASDATATRACKS;
                }
                else
                {
                    _dwMediaCap |= HWDMC_HASAUDIOTRACKS;
                }
            }

            // Is there the equivalent of IOCTL_CDROM_READ_Q_CHANNEL for data?
            _dwMediaCap |= HWDMC_HASDATATRACKS_UNDETERMINED;
        }
        else
        {
            int nTracks = (toc.LastTrack - toc.FirstTrack) + 1;
            int iTrack = 0;

            // Now iterate through the tracks looking for Audio data
            while ((iTrack < nTracks) &&
                ((_dwMediaCap & (HWDMC_HASDATATRACKS | HWDMC_HASDATATRACKS)) !=
                (HWDMC_HASDATATRACKS | HWDMC_HASDATATRACKS))
                )
            {
                if ((toc.TrackData[iTrack].Control & TRACK_TYPE_MASK) == AUDIO_TRACK)
                {
                    _dwMediaCap |= HWDMC_HASAUDIOTRACKS;
                }
                else
                {
                    if ((toc.TrackData[iTrack].Control & TRACK_TYPE_MASK) == DATA_TRACK)
                    {
                        _dwMediaCap |= HWDMC_HASDATATRACKS;
                    }
                }
                ++iTrack;
            }
        }
    }

    return hr;
}

HRESULT CVolume::_UpdateMediaInfoOnRemove()
{
    _dwMediaCap = 0;
    _dwMediaState = 0;

    _szAutorunIconLocation[0] = 0;
    _szAutorunLabel[0] = 0;
    _dwSerialNumber = 0xBADBADBD;

    SafeStrCpyN(_szLabel, TEXT("Invalid"), ARRAYSIZE(_szLabel));
    SafeStrCpyN(_szFileSystem, TEXT("Invalid"), ARRAYSIZE(_szFileSystem));
    _dwRootAttributes = 0xBADBADBD;
    _dwMaxFileNameLen = 0xBADBADBD;
    _dwFileSystemFlags = 0xBADBADBD;

    _dwVolumeFlags &= ~(HWDVF_STATE_HASAUTOPLAYHANDLER |
        HWDVF_STATE_DONOTSNIFFCONTENT | HWDVF_STATE_JUSTDOCKED);

    return S_OK;
}

HRESULT CVolume::_UpdateMediaInfo(HANDLE hDevice, BOOL fImpersonate)
{
    HRESULT hr;
    CImpersonateEveryone* pieo = NULL;

    if (fImpersonate)
    {
        hr = CHWEventDetectorHelper::GetImpersonateEveryone(&pieo);

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = pieo->Impersonate();

            if (FAILED(hr) || (S_FALSE == hr))
            {
                pieo->RCRelease();
                pieo = NULL;
            }
        }
    }
    else
    {
        hr = S_OK;
    }

    _dwVolumeFlags &= ~(HWDVF_STATE_HASAUTOPLAYHANDLER |
        HWDVF_STATE_DONOTSNIFFCONTENT | HWDVF_STATE_JUSTDOCKED);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        if (HWDTS_CDROM == _dwDriveType)
        {
            ASSERT(_fGenericReadRequired);

            // optimization
            if (_fFirstTime)
            {
                // already updated by _UpdateConstInfo
                _fFirstTime = FALSE;
            }
            else
            {
                _dwMediaCap = 0;

                hr = _UpdateMMC2CDInfo(hDevice);
            }
        }
        else
        {
            _dwMediaCap = 0;
        }

        if (SUCCEEDED(hr))
        {
            hr = _UpdateHasMedia(hDevice);

            if (SUCCEEDED(hr) && (_dwMediaState & HWDMS_PRESENT))
            {
                if (GetVolumeInformation(_szVolumeGUID, _szLabel,
                        ARRAYSIZE(_szLabel), &_dwSerialNumber,
                        &_dwMaxFileNameLen, &_dwFileSystemFlags, _szFileSystem,
                        ARRAYSIZE(_szFileSystem)))
                {
                    // use this?
                    // UINT err = SetErrorMode(SEM_FAILCRITICALERRORS);

                    // Root folder attributes
                    _dwRootAttributes = GetFileAttributes(_szVolumeGUID);

                    if (-1 != _dwRootAttributes)
                    {
                        // File presence
                        hr = _UpdateSpecialFilePresence();

                        if (SUCCEEDED(hr))
                        {
                            if (HWDTS_CDROM == _dwDriveType)
                            {
                                hr = _UpdateTrackInfo(hDevice);
                            }

                            if (HWDMC_HASAUTORUNINF & _dwMediaCap)
                            {
                                hr = _ExtractAutorunIconAndLabel();

                                // not critical
                                if (FAILED(hr))
                                {
                                    hr = S_FALSE;
                                }
                            }
                        }
                    }
                    else
                    {
                        _HandleAccessDenied();
                        _dwState |= STATE_GFAFAILED;

                        hr = S_FALSE;
                    }

                    _dwMediaState |= HWDMS_FORMATTED;
                }
                else
                {
                    _HandleAccessDenied();
                    // To help us debug, even in retail
                    _dwState |= STATE_GVIFAILED;
                    _dwSerialNumber = GetLastError();

                    _dwMediaState &= ~HWDMS_FORMATTED;

                    hr = S_FALSE;
                }
            }
            else
            {
                _dwState |= STATE_UPDATEHASMEDIAFAILED;

                _dwMediaCap = 0;

                hr = S_FALSE;
            }
        }

        if (S_FALSE == hr)
        {
            // We don't care if they fail
            SafeStrCpyN(_szLabel, TEXT("Invalid"), ARRAYSIZE(_szLabel));
            SafeStrCpyN(_szFileSystem, TEXT("Invalid"), ARRAYSIZE(_szFileSystem));
            _dwRootAttributes = 0xBADBADBD;
            _dwMaxFileNameLen = 0xBADBADBD;
            _dwFileSystemFlags = 0xBADBADBD;
        }

        if (fImpersonate)
        {
            pieo->RevertToSelf();
            pieo->RCRelease();
        }
    }

    return hr;
}

const FEATURE_NUMBER _rgfnInteresting[] = 
{
    // FeatureProfileList needs to remain the first one
    FeatureProfileList, //                  = 0x0000,
    FeatureCdRead, //                       = 0x001e,
    FeatureDvdRead, //                      = 0x001f,
    FeatureRandomWritable, //               = 0x0020,
    FeatureIncrementalStreamingWritable, // = 0x0021,
    FeatureFormattable, //                  = 0x0023,
    FeatureDefectManagement, //             = 0x0024,
    FeatureRestrictedOverwrite, //          = 0x0026,
    FeatureCdTrackAtOnce, //                = 0x002d,
    FeatureCdMastering,  //                 = 0x002e,
    FeatureDvdRecordableWrite, //           = 0x002f,
    FeatureCDAudioAnalogPlay, //            = 0x0103,
};

struct CAPABILITYFEATURESMAP
{
    DWORD                   dwCapability;
    DWORD                   dwCapabilityDependent;
    const FEATURE_NUMBER*   prgFeature;
    DWORD                   cFeature;
};

const FEATURE_NUMBER rgfnWRITECAP[] =
{
    FeatureProfileList,
};

const FEATURE_NUMBER rgfnCDROM[] =
{
    FeatureCdRead,
};

const FEATURE_NUMBER rgfnCDRECORDABLE[] =
{
    FeatureIncrementalStreamingWritable,
    FeatureCdTrackAtOnce,
    FeatureCdMastering,
};

const FEATURE_NUMBER rgfnCDREWRITABLE[] =
{
    FeatureFormattable,
};

const FEATURE_NUMBER rgfnDVDROM[] =
{
    FeatureDvdRead,
};

const FEATURE_NUMBER rgfnDVDRECORDABLE[] =
{
    FeatureDvdRecordableWrite,
};

const FEATURE_NUMBER rgfnDVDREWRITABLE[] =
{
    FeatureFormattable,
};

const FEATURE_NUMBER rgfnDVDRAM[] =
{
    FeatureRandomWritable,
    FeatureDefectManagement,
};

const FEATURE_NUMBER rgfnANALOGAUDIOOUT[] =
{
    FeatureCDAudioAnalogPlay,
};

const CAPABILITYFEATURESMAP _rgcapfeaturemap[] =
{
    {
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        0,
        rgfnWRITECAP,
        ARRAYSIZE(rgfnWRITECAP),
    },
    {
        HWDMC_CDROM,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnCDROM,
        ARRAYSIZE(rgfnCDROM),
    },
    {
        HWDMC_CDRECORDABLE,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnCDRECORDABLE,
        ARRAYSIZE(rgfnCDRECORDABLE),
    },
    {
        HWDMC_CDREWRITABLE,
        HWDMC_CDRECORDABLE,
        rgfnCDREWRITABLE,
        ARRAYSIZE(rgfnCDREWRITABLE),
    },
    {
        HWDMC_DVDROM,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnDVDROM,
        ARRAYSIZE(rgfnDVDROM),
    },
    {
        HWDMC_DVDRECORDABLE,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnDVDRECORDABLE,
        ARRAYSIZE(rgfnDVDRECORDABLE),
    },
    {
        HWDMC_DVDREWRITABLE,
        HWDMC_DVDRECORDABLE,
        rgfnDVDREWRITABLE,
        ARRAYSIZE(rgfnDVDREWRITABLE),
    },
    {
        HWDMC_DVDRAM,
        HWDMC_DVDROM,
        rgfnDVDRAM,
        ARRAYSIZE(rgfnDVDRAM),
    },
    {
        HWDMC_ANALOGAUDIOOUT,
        HWDMC_WRITECAPABILITY_SUPPORTDETECTION,
        rgfnANALOGAUDIOOUT,
        ARRAYSIZE(rgfnANALOGAUDIOOUT),
    },
};

#define MMC2_NOTSUPPORTED       0
#define MMC2_DRIVESUPPORTED     1
#define MMC2_MEDIASUPPORTED     2

HRESULT CVolume::_FillMMC2CD(HANDLE hDevice)
{
    HRESULT hr;

    if (!_prgMMC2Features)
    {
        _prgMMC2Features = (DWORD*)LocalAlloc(LPTR,
            ARRAYSIZE(_rgfnInteresting) * sizeof(DWORD));
    }

    if (_prgMMC2Features)
    {
        DWORD cbHeader = sizeof(GET_CONFIGURATION_HEADER) +
            sizeof(FEATURE_HEADER);
        GET_CONFIGURATION_HEADER* pheader = (GET_CONFIGURATION_HEADER*)
            LocalAlloc(LPTR, cbHeader);

        if (pheader)
        {
            GET_CONFIGURATION_IOCTL_INPUT gcii;

            gcii.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;
            gcii.Reserved[0] = NULL;
            gcii.Reserved[1] = NULL;

            for (DWORD dw = 0; dw < ARRAYSIZE(_rgfnInteresting); ++dw)
            {
                FEATURE_HEADER* pfh;

                DWORD cbReturned;
                gcii.Feature = _rgfnInteresting[dw];

                _prgMMC2Features[dw] = MMC2_NOTSUPPORTED;

                // Requires GENERIC_READ access on the handle
                if (DeviceIoControl(hDevice, IOCTL_CDROM_GET_CONFIGURATION,
                    &gcii, sizeof(GET_CONFIGURATION_IOCTL_INPUT), pheader,
                    cbHeader, &cbReturned, NULL))
                {
                    pfh = (FEATURE_HEADER*)(pheader->Data);

                    WORD w = (pfh->FeatureCode[0]) << 8 | (pfh->FeatureCode[1]);

                    if (w == _rgfnInteresting[dw])
                    {
                        _prgMMC2Features[dw] = MMC2_DRIVESUPPORTED;

                        if (pfh->Current)
                        {
                            _prgMMC2Features[dw] |= MMC2_MEDIASUPPORTED;
                        }
                        else
                        {
                            _prgMMC2Features[dw] &= ~MMC2_MEDIASUPPORTED;
                        }
                    }
                }
            }

            LocalFree(pheader);
        }       

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Rainier drive exposes features which perfectly matches DVD-RAM
// required feature set.  But they are CD-R/RW.  For drives
// we think are DVD-RAM, check if they also expose a DVD_RAM profile.
// We cannot use profiles all the way because they are not reliable.
// The same Rainier drive that expose bug 446652 exposes only
// the CDRewritable profile but it does support CDRecordable and
// CD-ROM.

HRESULT CVolume::_DVDRAMHack(HANDLE hDevice)
{
    BOOL fSupported = FALSE;
    BOOL fCurrent = FALSE;

    if (HWDDC_DVDRAM & _dwDriveCap)
    {
        // Do the check
        const DWORD cbHeaderInitial = sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_HEADER);

        DWORD cbReturned;
        DWORD cbHeader = cbHeaderInitial;
        BYTE rgbBuffer[cbHeaderInitial];
        GET_CONFIGURATION_IOCTL_INPUT input;
        GET_CONFIGURATION_HEADER* pheader = (GET_CONFIGURATION_HEADER*)rgbBuffer;

        ZeroMemory(&input, sizeof(GET_CONFIGURATION_IOCTL_INPUT));
        ZeroMemory(rgbBuffer, sizeof(rgbBuffer));

        // Ask for the profile list
        input.Feature = FeatureProfileList;

        // We want only this feature back
        input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL;

        BOOL f = DeviceIoControl(hDevice,
                             IOCTL_CDROM_GET_CONFIGURATION,
                             &input,
                             sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                             pheader,
                             cbHeader,             
                             &cbReturned,
                             NULL);
        
        if (f)
        {
            cbHeader = pheader->DataLength[0] << 24 |
                       pheader->DataLength[1] << 16 |
                       pheader->DataLength[2] << 8  |
                       pheader->DataLength[3] << 0;

            GET_CONFIGURATION_HEADER* pheader2 = (GET_CONFIGURATION_HEADER*)LocalAlloc(LPTR, 
                cbHeader);

            if (pheader2)
            {
                // We want all the profiles back
                input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL;

                f = DeviceIoControl(hDevice,
                                     IOCTL_CDROM_GET_CONFIGURATION,
                                     &input,
                                     sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                                     pheader2,
                                     cbHeader,             
                                     &cbReturned,
                                     NULL);

                if (f)
                {
                    FEATURE_DATA_PROFILE_LIST* pproflist =
                        (FEATURE_DATA_PROFILE_LIST*)pheader2->Data;

                    for (DWORD dw = 0; dw < (DWORD)(pproflist->Header.AdditionalLength / 4); ++dw)
                    {
                        FEATURE_DATA_PROFILE_LIST_EX* pprofile = &(pproflist->Profiles[dw]);

                        if (ProfileDvdRam == (pprofile->ProfileNumber[0] << 8 |
                            pprofile->ProfileNumber[1] << 0))
                        {
                            // It does support it!  Is it current?
                            fSupported = TRUE;
                        
                            if (pprofile->Current)
                            {
                                fCurrent = TRUE;
                            }

                            break;
                        }
                    }
                }

                LocalFree(pheader2);
            }
        }

        if (fSupported)
        {
            if (!fCurrent)
            {
                _dwMediaCap &= ~HWDMC_DVDRAM;
            }
        }
        else
        {
            _dwDriveCap &= ~HWDDC_DVDRAM;
            _dwMediaCap &= ~HWDMC_DVDRAM;
        }
    }

    return S_OK;
}

// Not worth updating only Const Info vs Media Info, do both
HRESULT CVolume::_UpdateMMC2CDInfo(HANDLE hDevice)
{
    HRESULT hr = _FillMMC2CD(hDevice);

    if (SUCCEEDED(hr))
    {
        for (DWORD dwCap = 0; dwCap < ARRAYSIZE(_rgcapfeaturemap); ++dwCap)
        {
            DWORD dwGoOn = MMC2_NOTSUPPORTED;

            if (_rgcapfeaturemap[dwCap].dwCapabilityDependent)
            {
                // This capability is dependent on another one, let's
                // check if the other is on
                if (_dwDriveCap &
                    _rgcapfeaturemap[dwCap].dwCapabilityDependent)
                {
                    dwGoOn |= MMC2_DRIVESUPPORTED;

                    if (_dwMediaCap &
                        _rgcapfeaturemap[dwCap].dwCapabilityDependent)
                    {
                        dwGoOn |= MMC2_MEDIASUPPORTED;
                    }
                }
            }
            else
            {
                dwGoOn = MMC2_DRIVESUPPORTED | MMC2_MEDIASUPPORTED;
            }

            for (DWORD dwFeature = 0;
                dwFeature < (_rgcapfeaturemap[dwCap].cFeature);
                ++dwFeature)
            {
                for (DWORD dwFeatureOn = 0; (MMC2_DRIVESUPPORTED & dwGoOn) &&
                        (dwFeatureOn < ARRAYSIZE(_rgfnInteresting));
                    ++dwFeatureOn)
                {
                    if (_rgfnInteresting[dwFeatureOn] ==
                        _rgcapfeaturemap[dwCap].prgFeature[dwFeature])
                    {
                        if (_prgMMC2Features[dwFeatureOn] &
                            MMC2_DRIVESUPPORTED)
                        {
                            if (!(dwGoOn & MMC2_MEDIASUPPORTED) ||
                                !(_prgMMC2Features[dwFeatureOn] &
                                MMC2_MEDIASUPPORTED))
                            {
                                dwGoOn &= ~MMC2_MEDIASUPPORTED;
                            }
                        }
                        else
                        {
                            dwGoOn = MMC2_NOTSUPPORTED;
                        }

                        break;
                    }
                }

                if (MMC2_DRIVESUPPORTED & dwGoOn)
                {
                    _dwDriveCap |= _rgcapfeaturemap[dwCap].dwCapability;

                    if (MMC2_MEDIASUPPORTED & dwGoOn)
                    {
                        _dwMediaCap |= _rgcapfeaturemap[dwCap].
                            dwCapability;
                    }
                    else
                    {
                        _dwMediaCap &= ~(_rgcapfeaturemap[dwCap].
                            dwCapability);
                    }
                }
                else
                {
                    _dwDriveCap &= ~(_rgcapfeaturemap[dwCap].dwCapability);
                    _dwMediaCap &= ~(_rgcapfeaturemap[dwCap].dwCapability);
                }
            }
        }
    }

    _DVDRAMHack(hDevice);

    return hr;
}

HRESULT CVolume::MediaIsAccessible(BOOL* pfAccessible)
{
    *pfAccessible = !!(_dwMediaState & HWDMS_PRESENT);

    return S_OK;
}

HRESULT CVolume::_UpdateRemovableDevice()
{
    HRESULT hr = S_OK;

    if (_fHWDevInstInited)
    {
        BOOL fRemovable;

        hr = _hwdevinst.IsRemovableDevice(&fRemovable);

        if (SUCCEEDED(hr))
        {
            if (fRemovable)
            {
                _dwDriveCap |= HWDDC_REMOVABLEDEVICE;
            }
        }
    }

    return hr;
}

HRESULT CVolume::_UpdateSoftEjectCaps()
{
    HRESULT hr = S_OK;

    if (_fHWDevInstInited)
    {
        DWORD dw;
        DWORD dwType;

        hr = _GetDevicePropertyGeneric(&_hwdevinst, TEXT("NoSoftEject"),
            FALSE, &dwType, (PBYTE)&dw, sizeof(dw));

        if (SUCCEEDED(hr) && (S_FALSE != hr))
        {
            hr = S_OK;

            if (REG_DWORD == dwType)
            {
                if (1 == dw)
                {
                    _dwDriveCap |= HWDDC_NOSOFTEJECT;
                }
            }
        }
    }

    return hr;
}

HRESULT CVolume::_UpdateConstInfo(HANDLE hDevice)
{
    HRESULT hr;

    _dwVolumeFlags = 0;

    if (HWDTS_CDROM == _dwDriveType)
    {
        _dwVolumeFlags = HWDVF_STATE_SUPPORTNOTIFICATION;

        hr = _UpdateMMC2CDInfo(hDevice);
    }
    else
    {
        if (HWDTS_REMOVABLEDISK == _dwDriveType)
        {
            _dwVolumeFlags = HWDVF_STATE_SUPPORTNOTIFICATION;
        }
        else
        {
            if ((HWDTS_FLOPPY35 != _dwDriveType) &&
                (HWDTS_FLOPPY525 != _dwDriveType))
            {
                // Do something for the 120MB floppy
                _dwVolumeFlags = HWDVF_STATE_SUPPORTNOTIFICATION;
            }
        }

        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        hr = _GetVolumeName(_pszElemName, _szVolumeGUID,
            ARRAYSIZE(_szVolumeGUID));
    }

    if (SUCCEEDED(hr))
    {
        if (HWDTS_CDROM != _dwDriveType)
        {
            _dwDriveCap |= HWDMC_WRITECAPABILITY_SUPPORTDETECTION |
                HWDDC_RANDOMWRITE;
        }
    }

    return hr;
}

HRESULT CVolume::GetVolumeConstInfo(LPWSTR pszVolumeGUID, DWORD cchVolumeGUID,
    DWORD* pdwVolumeFlags, DWORD* pdwDriveType, DWORD* pdwDriveCap)
{
    HRESULT hr;

    _cs.Enter();

    hr = SafeStrCpyN(pszVolumeGUID, _szVolumeGUID, cchVolumeGUID);

    if (SUCCEEDED(hr))
    {
        if (!(_dwVolumeFlags & HWDVF_STATE_ACCESSDENIED))
        {
            *pdwVolumeFlags = _dwVolumeFlags;
            *pdwDriveType = _dwDriveType;
            *pdwDriveCap = _dwDriveCap;
        }
        else
        {
            *pdwVolumeFlags = HWDVF_STATE_ACCESSDENIED;
            *pdwDriveType = 0xBADBADBD;
            *pdwDriveCap = 0xBADBADBD;
        }
    }

    _cs.Leave();

    return hr;
}

HRESULT CVolume::GetVolumeMediaInfo(LPWSTR pszLabel, DWORD cchLabel, 
    LPWSTR pszFileSystem, DWORD cchFileSystem, DWORD* pdwFileSystemFlags,
    DWORD* pdwMaxFileNameLen, DWORD* pdwRootAttributes, DWORD* pdwSerialNumber,
    DWORD* pdwDriveState, DWORD* pdwMediaState, DWORD* pdwMediaCap)
{
    HRESULT hr;

    _cs.Enter();

    if (!(_dwVolumeFlags & HWDVF_STATE_ACCESSDENIED))
    {
        if (_dwMediaState & HWDMS_PRESENT)
        {
            hr = SafeStrCpyN(pszLabel, _szLabel, cchLabel);

            if (SUCCEEDED(hr))
            {
                hr = SafeStrCpyN(pszFileSystem, _szFileSystem, cchFileSystem);
            }

            if (SUCCEEDED(hr))
            {
                *pdwFileSystemFlags = _dwFileSystemFlags;
                *pdwMaxFileNameLen = _dwMaxFileNameLen; 
                *pdwRootAttributes = _dwRootAttributes;
                *pdwSerialNumber = _dwSerialNumber;

                *pdwDriveState = _dwDriveState;

                *pdwMediaState = _dwMediaState;
            }
        }
        else
        {
            *pdwMediaState = _dwMediaState;

            // We don't care if they fail
            SafeStrCpyN(pszLabel, TEXT("Invalid"), cchLabel);
            SafeStrCpyN(pszFileSystem, TEXT("Invalid"), cchFileSystem);
            *pdwSerialNumber = 0xBADBADBD;
            *pdwMaxFileNameLen = 0xBADBADBD;
            *pdwFileSystemFlags = 0xBADBADBD;
            *pdwRootAttributes = 0xBADBADBD;
            *pdwDriveState = 0xBADBADBD;

            hr = S_OK;
        }

        *pdwMediaCap = _dwMediaCap;
    }
    else
    {
        *pdwMediaState = 0xBADBADBD;

        // We don't care if they fail
        SafeStrCpyN(pszLabel, TEXT("Access Denied"), cchLabel);
        SafeStrCpyN(pszFileSystem, TEXT("Access Denied"), cchFileSystem);
        *pdwSerialNumber = 0xBADBADBD;
        *pdwMaxFileNameLen = 0xBADBADBD;
        *pdwFileSystemFlags = 0xBADBADBD;
        *pdwRootAttributes = 0xBADBADBD;
        *pdwDriveState = 0xBADBADBD;
        *pdwMediaCap = 0xBADBADBD;

        hr = S_OK;
    }

    _cs.Leave();

    return hr;
}

HRESULT CVolume::GetIconAndLabelInfo(LPWSTR pszAutorunIconLocation,
    DWORD cchAutorunIconLocation, LPWSTR pszAutorunLabel, DWORD cchAutorunLabel,
    LPWSTR pszIconLocationFromService, DWORD cchIconLocationFromService,
    LPWSTR pszNoMediaIconLocationFromService, DWORD cchNoMediaIconLocationFromService,
    LPWSTR pszLabelFromService, DWORD cchLabelFromService)
{
    HRESULT hrTmp;

    *pszAutorunIconLocation = NULL;
    *pszAutorunLabel = NULL;
    *pszIconLocationFromService = NULL;
    *pszNoMediaIconLocationFromService = NULL;
    *pszLabelFromService = NULL;

    _cs.Enter();

    if (!(_dwVolumeFlags & HWDVF_STATE_ACCESSDENIED))
    {
        if (_dwMediaCap & HWDMC_HASAUTORUNINF)
        {
            if (_szAutorunIconLocation[0])
            {
                hrTmp = SafeStrCpyN(pszAutorunIconLocation, _szAutorunIconLocation,
                    cchAutorunIconLocation);

                if (FAILED(hrTmp))
                {
                    *pszAutorunIconLocation = 0;
                }
            }

            if (_szAutorunLabel[0])
            {
                hrTmp = SafeStrCpyN(pszAutorunLabel, _szAutorunLabel,
                    cchAutorunLabel);

                if (FAILED(hrTmp))
                {
                    *pszAutorunLabel = 0;
                }
            }
        }

        if (_fHWDevInstInited)
        {
            WORD_BLOB* pblob;

            hrTmp = _GetDevicePropertyGenericAsMultiSz(&_hwdevinst, TEXT("Icons"),
                TRUE, &pblob);

            if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
            {
                hrTmp = SafeStrCpyN(pszIconLocationFromService, pblob->asData,
                    cchIconLocationFromService);

                if (FAILED(hrTmp))
                {
                    *pszIconLocationFromService = 0;
                }

                CoTaskMemFree(pblob);
            }
            else
            {
                *pszIconLocationFromService = 0;
                hrTmp = S_FALSE;
            }

            hrTmp = _GetDevicePropertyGenericAsMultiSz(&_hwdevinst, TEXT("NoMediaIcons"),
                TRUE, &pblob);

            if (SUCCEEDED(hrTmp) && (S_FALSE != hrTmp))
            {
                hrTmp = SafeStrCpyN(pszNoMediaIconLocationFromService, pblob->asData,
                    cchNoMediaIconLocationFromService);

                if (FAILED(hrTmp))
                {
                    *pszNoMediaIconLocationFromService = 0;
                }

                CoTaskMemFree(pblob);
            }
            else
            {
                *pszNoMediaIconLocationFromService = 0;
                hrTmp = S_FALSE;
            }

            if (SUCCEEDED(hrTmp))
            {
                hrTmp = _GetDevicePropertyAsString(&_hwdevinst, TEXT("Label"),
                    pszLabelFromService, cchLabelFromService);

                if (FAILED(hrTmp) || (S_FALSE == hrTmp))
                {
                    *pszLabelFromService = 0;
                }
            }
        }
    }

    _cs.Leave();

    return S_OK;
}

HRESULT CVolume::_GetVOLUMEINFO2(VOLUMEINFO2** ppvolinfo2)
{
    ASSERT(_cs.IsInside());

    DWORD cchReq;

    // We allocate this buffer just to be stack friendly, otherwise it could
    // have been on the stack
    VOLUMEINFO2* pvolinfo2;
    
    HRESULT hr = _AllocMemoryChunk<VOLUMEINFO2*>(MAX_VOLUMEINFO2, &pvolinfo2);

    *ppvolinfo2 = NULL;

    if (SUCCEEDED(hr))
    {
        pvolinfo2->cbSize = MAX_VOLUMEINFO2;

        hr = GetName(pvolinfo2->szDeviceIDVolume,
            ARRAYSIZE(pvolinfo2->szDeviceIDVolume), &cchReq);

        if (SUCCEEDED(hr))
        {
            // Const info
            hr = SafeStrCpyN(pvolinfo2->szVolumeGUID, _szVolumeGUID,
                ARRAYSIZE(pvolinfo2->szVolumeGUID));

            if (_dwVolumeFlags & HWDVF_STATE_ACCESSDENIED)
            {
                pvolinfo2->dwVolumeFlags = HWDVF_STATE_ACCESSDENIED;
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    pvolinfo2->dwVolumeFlags = _dwVolumeFlags;
                    pvolinfo2->dwDriveType = _dwDriveType;
                    pvolinfo2->dwDriveCapability = _dwDriveCap;
                }

                pvolinfo2->dwState = _dwState;

                // Media info
                if (SUCCEEDED(hr))
                {
                    // This fct should be called from within the Volume critsect
                    if (_dwMediaState & HWDMS_PRESENT)
                    {
                        hr = SafeStrCpyN(pvolinfo2->szLabel, _szLabel,
                            ARRAYSIZE(pvolinfo2->szLabel));

                        if (SUCCEEDED(hr))
                        {
                            hr = SafeStrCpyN(pvolinfo2->szFileSystem, _szFileSystem,
                                ARRAYSIZE(pvolinfo2->szFileSystem));
                        }

                        if (SUCCEEDED(hr))
                        {
                            pvolinfo2->dwFileSystemFlags = _dwFileSystemFlags;
                            pvolinfo2->dwMaxFileNameLen = _dwMaxFileNameLen; 
                            pvolinfo2->dwRootAttributes = _dwRootAttributes;
                            pvolinfo2->dwSerialNumber = _dwSerialNumber;

                            pvolinfo2->dwDriveState = _dwDriveState;
                            pvolinfo2->dwMediaCap = _dwMediaCap;

                            pvolinfo2->dwMediaState = _dwMediaState;
                        }
                    }
                    else
                    {
                        pvolinfo2->dwMediaState = _dwMediaState;

                        // We don't care if they fail
                        SafeStrCpyN(pvolinfo2->szLabel, TEXT("Invalid"),
                            ARRAYSIZE(pvolinfo2->szLabel));
                        SafeStrCpyN(pvolinfo2->szFileSystem, TEXT("Invalid"),
                            ARRAYSIZE(pvolinfo2->szFileSystem));
                        pvolinfo2->dwSerialNumber = 0xBADBADBD;
                        pvolinfo2->dwMaxFileNameLen = 0xBADBADBD;
                        pvolinfo2->dwFileSystemFlags = 0xBADBADBD;
                        pvolinfo2->dwRootAttributes = 0xBADBADBD;
                        pvolinfo2->dwDriveState = 0xBADBADBD;

                        hr = S_OK;
                    }

                    pvolinfo2->dwMediaCap = _dwMediaCap;
                }

                if (SUCCEEDED(hr))
                {
                    DWORD offset = 0;
                    WCHAR szAutorunIconLocation[MAX_ICONLOCATION];
                    WCHAR szAutorunLabel[MAX_LABEL];
                    WCHAR szIconLocationFromService[MAX_ICONLOCATION];
                    WCHAR szNoMediaIconLocationFromService[MAX_ICONLOCATION];
                    // We can now have a @%SystemRoot%\system32\shell32.dll,-1785 for MUI stuff
                    WCHAR szLabelFromService[MAX_ICONLOCATION];

                    pvolinfo2->oAutorunIconLocation = INVALID_DWORD;
                    pvolinfo2->oAutorunLabel = INVALID_DWORD;
                    pvolinfo2->oIconLocationFromService = INVALID_DWORD;
                    pvolinfo2->oNoMediaIconLocationFromService = INVALID_DWORD;
                    pvolinfo2->oLabelFromService = INVALID_DWORD;

                    hr = GetIconAndLabelInfo(szAutorunIconLocation,
                        ARRAYSIZE(szAutorunIconLocation), szAutorunLabel,
                        ARRAYSIZE(szAutorunLabel), szIconLocationFromService,
                        ARRAYSIZE(szIconLocationFromService), szNoMediaIconLocationFromService,
                        ARRAYSIZE(szNoMediaIconLocationFromService), szLabelFromService,
                        ARRAYSIZE(szLabelFromService));

                    if (SUCCEEDED(hr))
                    {
                         // The following five strings are optional
                        if (*szAutorunIconLocation)
                        {
                            pvolinfo2->oAutorunIconLocation = offset;

                            offset += lstrlen(szAutorunIconLocation) + 1;

                            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oAutorunIconLocation,
                                szAutorunIconLocation);
                        }

                        if (*szAutorunLabel)
                        {
                            pvolinfo2->oAutorunIconLocation = offset;

                            offset += lstrlen(szAutorunLabel) + 1;

                            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oAutorunIconLocation,
                                szAutorunLabel);
                        }

                        if (*szIconLocationFromService)
                        {
                            pvolinfo2->oIconLocationFromService = offset;

                            offset += lstrlen(szIconLocationFromService) + 1;

                            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oIconLocationFromService,
                                szIconLocationFromService);
                        }

                        if (*szNoMediaIconLocationFromService)
                        {
                            pvolinfo2->oNoMediaIconLocationFromService = offset;

                            offset += lstrlen(szNoMediaIconLocationFromService) + 1;

                            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oNoMediaIconLocationFromService,
                                szNoMediaIconLocationFromService);
                        }

                        if (*szLabelFromService)
                        {
                            pvolinfo2->oLabelFromService = offset;

                            offset += lstrlen(szLabelFromService) + 1;

                            lstrcpy(pvolinfo2->szOptionalStrings + pvolinfo2->oLabelFromService,
                                szLabelFromService);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppvolinfo2 = pvolinfo2;
        }
        else
        {
            _FreeMemoryChunk<VOLUMEINFO2*>(pvolinfo2);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CVolume::HandleRemoval()
{
    WCHAR szDeviceIDVolume[MAX_DEVICEID];
    DWORD cchReq;

    HRESULT hr = GetName(szDeviceIDVolume, ARRAYSIZE(szDeviceIDVolume), &cchReq);

    if (SUCCEEDED(hr))
    {
        // This will launch a thread
        CHardwareDevicesImpl::_AdviseVolumeRemoved(szDeviceIDVolume,
            _pszMountPoints, _cchMountPoints);
    }

    return hr;
}

HRESULT CVolume::HandleArrival()
{
    BOOL fJustDocked = FALSE;

    HRESULT hr = CHWEventDetectorHelper::DockStateChanged(&fJustDocked);

    if (SUCCEEDED(hr))
    {
        //
        // ISSUE-2001/01/13-StephStm  Pass the Docking change in there so
        //                            that the Shell knows if it should
        //                            Autorun or not.
        //
        if (_fHWDevInstInited)
        {
            BOOL fTryAutoplay = TRUE;

            if ((_dwDriveType & HWDTS_CDROM) ||
                (_dwDriveType & HWDTS_REMOVABLEDISK))
            {
                if (_dwMediaState & HWDMS_PRESENT)
                {
                    // Not removable disk, but device
                    BOOL fRemovable;

                    hr = _hwdevinst.IsRemovableDevice(&fRemovable);

                    if (SUCCEEDED(hr))
                    {
                        if (fRemovable)
                        {
                            // We need to Autoplay these since cameras
                            // are removable-disk devices.  And we want
                            // to autorun them when they come in.
                            fTryAutoplay = TRUE;
                        }
                        else
                        {
                            // For removable-disk drives/CD drives with
                            // media inserted when they are plugged,
                            // we do not Autoplay.
                            fTryAutoplay = FALSE;

                            DIAGNOSTIC((TEXT("[0311]Non removable device plugged with media in it -> No Autoplay!")));
                        }
                    }
                }
            }
            if (!fJustDocked && fTryAutoplay)
            {
                HANDLE hDevice;

                // Get a handle to regsiter for notification so that the
                // FindFirstFile does not veto a PnP/Driver transition
                hr = _GetDeviceHandleSafe(&hDevice, FALSE);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    hr = _ShouldTryAutoplay(&fTryAutoplay);

                    if (SUCCEEDED(hr))
                    {
                        if (fTryAutoplay)
                        {
                            BOOL fHasHandler;

                            hr = CHWEventDetectorImpl::HandleVolumeMediaEvent(
                                _pszElemName, &_hwdevinst, TEXT("DeviceArrival"),
                                &fHasHandler);

                            if (SUCCEEDED(hr) && fHasHandler)
                            {
                                _dwVolumeFlags |= HWDVF_STATE_HASAUTOPLAYHANDLER;
                            }
                        }
                        else
                        {
                            _dwVolumeFlags |= HWDVF_STATE_DONOTSNIFFCONTENT;
                        }
                    }

                    _CloseDeviceHandleSafe(hDevice);
                }
            }
            else
            {
                if (fJustDocked)
                {
                    DIAGNOSTIC((TEXT("[0301]Just docked -> No Autoplay!")));
                    TRACE(TF_VOLUME, TEXT("Just docked -> No Autoplay!"));

                    _dwVolumeFlags |= HWDVF_STATE_JUSTDOCKED;
                }
            }
        }
        else
        {
            DIAGNOSTIC((TEXT("[0310]Cannot find hardware device for this volume -> No Autoplay!")));
            hr = S_FALSE;
        }

        if (SUCCEEDED(hr))
        {
            _AdviseVolumeChangeHelper(TRUE);
        }
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
CVolume::CVolume() : _dwMediaState(0),
    _devtype((DEVICE_TYPE)-1), _ulDeviceNumber((ULONG)-1),
    _ulPartitionNumber((ULONG)-1), _fHWDevInstInited(FALSE), _dwDriveType(0),
    _dwDriveCap(0), _dwVolumeFlags(0), _prgMMC2Features(NULL),
    _fFirstTime(TRUE), _dwMediaCap(0), _pszMountPoints(NULL), _dwDriveState(0),
    _fProcessMediaArrived(FALSE), _hdevnotify(NULL), _dwState(0),
    _dwMediaPresentFromEvent(MPFE_UNDETERMINED)
{
    _szVolumeGUID[0] = 0;
    _szDeviceIDDisk[0] = 0;

    _cs.Init();
}

CVolume::~CVolume()
{
    _UnregisterNotif();

    if (_pszMountPoints)
    {
        CNamedElemList* pnel;
        HRESULT hres = CHWEventDetectorHelper::GetList(HWEDLIST_MTPT, &pnel);

        if (S_OK == hres)
        {
            for (LPWSTR psz = _pszMountPoints; *psz; psz += (lstrlen(psz) + 1))
            {
                hres = pnel->Remove(psz);
            }            

            pnel->RCRelease();
        }

        LocalFree(_pszMountPoints);
    }

    if (_prgMMC2Features)
    {
        LocalFree(_prgMMC2Features);
    }

    _cs.Delete();
}
///////////////////////////////////////////////////////////////////////////////
//
//static
HRESULT CVolume::Create(CNamedElem** ppelem)
{
    HRESULT hres = S_OK;

    *ppelem = new CVolume();

    if (!(*ppelem))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

//static
HRESULT CVolume::GetFillEnum(CFillEnum** ppfillenum)
{
    HRESULT hres;

    CVolumeFillEnum* pfillenum = new CVolumeFillEnum();

    if (pfillenum)
    {
        hres = pfillenum->_Init();

        if (FAILED(hres))
        {
            delete pfillenum;
            pfillenum = NULL;
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    *ppfillenum = pfillenum;

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CVolumeFillEnum::Next(LPWSTR pszElemName, DWORD cchElemName,
    DWORD* pcchRequired)
{
    return _intffillenum.Next(pszElemName, cchElemName, pcchRequired);
}

HRESULT CVolumeFillEnum::_Init()
{
    return _intffillenum._Init(&guidVolumeClass, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shsrvice\svchost.cpp ===
#include "shsrvice.h"
#include "HDService.h"

void WINAPI HardwareDetectionServiceMain(DWORD cArg, LPWSTR* ppszArgs)
{
    // Not used for now
    CGenericServiceManager::_fSVCHosted = TRUE;

    CGenericServiceManager::_ServiceMain(cArg, ppszArgs);
}

HRESULT CHDService::Install(BOOL fInstall, LPCWSTR)
{
    CGenericServiceManager::_fSVCHosted = TRUE;

    if (fInstall)
    {
        CGenericServiceManager::Install();
    }
    else
    {
        CGenericServiceManager::UnInstall();
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shsrvice\shsrvice.h ===
#include "service.h"

///////////////////////////////////////////////////////////////////////////////
//
struct CTRLEVENT;

struct SERVICEENTRY
{
    HANDLE                      _hEventRelinquishControl;
    IService*                   _pservice;
    SERVICE_STATUS              _servicestatus;
    SERVICE_STATUS_HANDLE       _ssh;
    BOOL                        _fWantsDeviceEvents;
    CTRLEVENT*                  _peventQueueHead;
    CTRLEVENT*                  _peventQueueTail;
    BOOL                        _fSkipTerminatingEvents;
    HANDLE                      _hEventSynchProcessing;
#ifdef DEBUG
    DWORD                       _cEvents;
    WCHAR                       _szServiceName[256];
#endif
};

///////////////////////////////////////////////////////////////////////////////
//
class CGenericServiceManager
{
public:
    static HRESULT Install();
    static HRESULT UnInstall();

public:
    // call in WinMain only
    static HRESULT Init();
    static HRESULT Cleanup();
    static HRESULT StartServiceCtrlDispatcher();

public:
    // call publicly in process.cpp only
    static void WINAPI _ServiceMain(DWORD cArg, LPWSTR* ppszArgs);
    static DWORD WINAPI _ServiceHandler(DWORD dwControl, DWORD dwEventType,
        LPVOID pEventData, LPVOID lpContext);
    static HRESULT _HandleWantsDeviceEvents(LPCWSTR pszServiceName,
        BOOL fWantsDeviceEvents);

private:
    static HRESULT _ProcessServiceControlCodes(SERVICEENTRY* pse);

    static HRESULT _GetServiceIndex(LPCWSTR pszServiceName, DWORD* pdw);
    static HRESULT _GetServiceCLSID(LPCWSTR pszServiceName, CLSID* pclsid);
    static HRESULT _CreateIService(LPCWSTR pszServiceName,
        IService** ppservice);

    static HRESULT _InitServiceEntry(LPCWSTR pszServiceName,
        SERVICEENTRY** ppse);
    static HRESULT _CleanupServiceEntry(SERVICEENTRY* pse);

    static HRESULT _RegisterServiceCtrlHandler(LPCWSTR pszServiceName,
        SERVICEENTRY* pse);
    static BOOL _SetServiceStatus(SERVICEENTRY* pse);

    static HRESULT _HandleServiceControls(SERVICEENTRY* pse, DWORD dwControl,
        DWORD dwEventType, PVOID pvEventData);
    static HRESULT _HandlePreState(SERVICEENTRY* pse, DWORD dwControl);
    static HRESULT _HandlePostState(SERVICEENTRY* pse, DWORD dwControl,
        BOOL fPending);

    static HRESULT _QueueEvent(SERVICEENTRY* pse, DWORD dwControl,
        DWORD dwEventType, PVOID pEventData);
    static HRESULT _DeQueueEvent(SERVICEENTRY* pse, CTRLEVENT** ppevent);
    static HRESULT _MakeEvent(DWORD dwControl, DWORD dwEventType,
        PVOID pvEventData, CTRLEVENT** ppevent);
    static HRESULT _EventNeedsToBeProcessedSynchronously(DWORD dwControl,
        DWORD dwEventType, LPVOID pvEventData, SERVICEENTRY* pse,
        BOOL* pfBool);

    static HRESULT _Init();
    static HRESULT _Cleanup();

public:
    static SERVICE_TABLE_ENTRY  _rgste[];

    struct SUBSERVICE
    {
        LPWSTR          pszProgID;
        UINT            uFriendlyName;
        LPWSTR          pszDependencies; // double null-terminated array of
                                         // null-separated names
        LPWSTR          pszLoadOrderGroup;
        UINT            uDescription;
        SERVICEENTRY    se;
    };

    static SUBSERVICE           _rgsubservice[];

    static BOOL                 _fSVCHosted;    

private:
    static DWORD                _cste;

    static CRITICAL_SECTION     _cs;

    static BOOL                 _fInitializationDone;
    static ULONG                _cRefCS;
    static HANDLE               _hEventInitCS;

#ifdef DEBUG
public:
    static BOOL                 _fRunAsService;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shsrvice\shsrvice.cpp ===
#include "shsrvice.h"
#include "service.h"

#include "mischlpr.h"

#include "sfstr.h"
#include "reg.h"

#include "resource.h"

#include "dbg.h"
#include "tfids.h"

#include <dbt.h>
#include <initguid.h>
#include <ioevent.h>

#include <shlwapi.h>
#include <shlwapip.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))
#define MAX_EVENTNAME   100

struct CTRLEVENT
{
    CTRLEVENT*  peventNext;
    DWORD       dwControl;
    DWORD       dwEventType;
    BYTE        rgbEventData[1];
};

const LPWSTR pszSVCHostGroup = TEXT("netsvcs");

///////////////////////////////////////////////////////////////////////////////
//
SERVICE_TABLE_ENTRY CGenericServiceManager::_rgste[] = 
{
    { TEXT("ShellHWDetection"), CGenericServiceManager::_ServiceMain },
    { NULL, NULL },
};

CGenericServiceManager::SUBSERVICE CGenericServiceManager::_rgsubservice[] =
{
    { TEXT("Shell.HWEventDetector"), IDS_SHELLHWDETECTION_FRIENDLYNAME,
      TEXT("RpcSs\0"), TEXT("ShellSvcGroup"), IDS_SHELLHWDETECTION_DESCRIPTION,
      {0} },
};

// "- 1": Last entry of both arrays are NULL terminators
DWORD CGenericServiceManager::_cste =
    ARRAYSIZE(CGenericServiceManager::_rgste) - 1;

CRITICAL_SECTION CGenericServiceManager::_cs = {0};

BOOL CGenericServiceManager::_fInitializationDone = FALSE;
ULONG CGenericServiceManager::_cRefCS = 0;
HANDLE CGenericServiceManager::_hEventInitCS = NULL;

BOOL CGenericServiceManager::_fSVCHosted = FALSE;

#ifdef DEBUG
BOOL CGenericServiceManager::_fRunAsService = TRUE;
#endif
///////////////////////////////////////////////////////////////////////////////
//
HRESULT _GetServiceEventName(LPCWSTR pszServiceName, LPWSTR pszEventName,
    DWORD cchEventName);

///////////////////////////////////////////////////////////////////////////////
//

// static
BOOL _IsAlreadyInstalled(LPCWSTR pszRegStr, LPCWSTR pszServiceName)
{
    LPCWSTR psz = pszRegStr;
    BOOL fThere = FALSE;

    do
    {
        if (!lstrcmp(psz, pszServiceName))
        {
            fThere = TRUE;
            break;
        }

        psz += lstrlen(psz) + 1;
    }
    while (*psz);

    return fThere;
}

HRESULT _UnInstall(LPCWSTR pszServiceName)
{
    HRESULT hres = E_FAIL;
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    // Need to do it for all services
    if (hSCM)
    {
        hres = S_OK;

        SC_HANDLE hService = OpenService(hSCM, pszServiceName,
            DELETE);

        if (hService)
        {
            DeleteService(hService);
            CloseServiceHandle(hService);
        }
        else
        {
            // Don't fail, if somebody manually removed the service n
            // from the reg, then all n + x services will not uninstall.
            hres = S_FALSE;
        }

        CloseServiceHandle(hSCM);
    }
   
    return hres;
}

HRESULT _InstSetSVCHostInfo(LPWSTR pszServiceName)
{
    HRESULT hres = E_FAIL;
    HKEY hkey;
    DWORD dwDisp;
    BOOL fAlreadyThere = FALSE;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"),
        0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hkey,
        &dwDisp))
    {
        DWORD cbSize;
        DWORD cbSizeNew;
        BOOL fEmpty = FALSE;
        LPWSTR pszNew;

        if (ERROR_SUCCESS != RegQueryValueEx(hkey, pszSVCHostGroup, 0, NULL,
            NULL, &cbSize))
        {
            fEmpty = TRUE;
            // Set cbSize to the size of the 2nd NULL terminator
            cbSize = sizeof(WCHAR);
        }

        cbSizeNew = cbSize + (lstrlen(pszServiceName) + 1) * sizeof(WCHAR);
        pszNew = (LPWSTR)LocalAlloc(LPTR, cbSizeNew);

        if (pszNew)
        {
            DWORD cbSize2 = cbSizeNew;

            hres = S_OK;

            if (!fEmpty)
            {
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, pszSVCHostGroup, 0,
                    NULL, (PBYTE)pszNew, &cbSize2))
                {
                    if (cbSize2 == cbSize)
                    {
                        fAlreadyThere = _IsAlreadyInstalled(pszNew,
                            pszServiceName);
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                }
                else
                {
                    hres = E_FAIL;
                }
            }
            else
            {
                cbSize2 = sizeof(WCHAR);
            }

            if (SUCCEEDED(hres) && !fAlreadyThere)
            {
                lstrcpy(pszNew + (cbSize2 / sizeof(WCHAR)) - 1,
                    pszServiceName);

                if (ERROR_SUCCESS != RegSetValueEx(hkey, pszSVCHostGroup, 0,
                    REG_MULTI_SZ, (PBYTE)pszNew, cbSizeNew))
                {
                    hres = E_FAIL;
                }
            }

            LocalFree((HLOCAL)pszNew);
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }

        // We should have an entry in the SUBSERVICE array for this...
        if (SUCCEEDED(hres))
        {
            HKEY hkey2;

            if (ERROR_SUCCESS == RegCreateKeyEx(hkey, pszSVCHostGroup,
                0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL,
                &hkey2, &dwDisp))
            {
                DWORD dwSec = 0x00000001;
                DWORD cbSec = sizeof(dwSec);

                // We set this magic value of 1 and svchost.exe will 
                // call CoInitializeSecurity for us
                if (ERROR_SUCCESS != RegSetValueEx(hkey2,
                    TEXT("CoInitializeSecurityParam"), 0, REG_DWORD,
                    (PBYTE)&dwSec, cbSec))
                {
                    hres = E_FAIL;
                }
            }

            RegCloseKey(hkey2);
        }

        RegCloseKey(hkey);
    }

    return hres;
}

HRESULT _InstSetParameters(LPWSTR pszServiceName)
{
    HKEY hkeyServices;
    HRESULT hres = E_FAIL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\"), 0,
            MAXIMUM_ALLOWED, &hkeyServices))
    {
        HKEY hkeySvc;

        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyServices, pszServiceName, 0,
            MAXIMUM_ALLOWED, &hkeySvc))
        {
            HKEY hkeyParam;

            if (ERROR_SUCCESS == RegCreateKeyEx(hkeySvc,
                TEXT("Parameters"), 0, NULL,
                REG_OPTION_NON_VOLATILE,
                MAXIMUM_ALLOWED, NULL, &hkeyParam, NULL))
            {
                // Watch out!  Hard coded path and filename!
                WCHAR szServiceDll[] =
                    TEXT("%SystemRoot%\\System32\\shsvcs.dll");

                if (ERROR_SUCCESS == RegSetValueEx(hkeyParam,
                    TEXT("ServiceDll"), 0, REG_EXPAND_SZ,
                    (PBYTE)szServiceDll, sizeof(szServiceDll)))
                {
                    WCHAR szServiceMain[] =
                        TEXT("HardwareDetectionServiceMain");

                    if (ERROR_SUCCESS == RegSetValueEx(
                        hkeyParam, TEXT("ServiceMain"), 0,
                        REG_SZ, (PBYTE)szServiceMain,
                        sizeof(szServiceMain)))
                    {
                        hres = S_OK;
                    }
                }

                RegCloseKey(hkeyParam);
            }

            RegCloseKey(hkeySvc);
        }

        RegCloseKey(hkeyServices);
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::UnInstall()
{
    HRESULT hr = S_FALSE;

    for (DWORD dw = 0; SUCCEEDED(hr) && (dw < _cste); ++dw)
    {
        hr = _UnInstall(_rgste[dw].lpServiceName);
    }

    return hr;
}

HRESULT _GetFriendlyStrings(CGenericServiceManager::SUBSERVICE* psubservice,
    LPWSTR pszFriendlyName, DWORD cchFriendlyName, LPWSTR pszDescription,
    DWORD cchDescription)
{
    *pszFriendlyName = 0;
    *pszDescription = 0;

    HMODULE hmodule = GetModuleHandle(TEXT("shsvcs.dll"));

    if (hmodule)
    {
        LoadString(hmodule, psubservice->uFriendlyName, pszFriendlyName,
            cchFriendlyName);

        LoadString(hmodule, psubservice->uDescription, pszDescription,
            cchDescription);
    }

    return S_OK;
}

// static
HRESULT CGenericServiceManager::Install()
{
    HRESULT     hres = S_FALSE;
        
    if (!IsOS(OS_WOW6432))
    {
        hres = E_FAIL;
        SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
        WCHAR szFileName[MAX_PATH];
        DWORD dwStartType = SERVICE_AUTO_START;

        if (hSCM)
        {
            WCHAR szFriendlyName[200];
            // Doc says limit is 1024 bytes
            WCHAR szDescription[1024 / sizeof(WCHAR)];

            // Need to do it for all services
            hres = S_OK;

            if (!_fSVCHosted)
            {
                if (GetModuleFileName(NULL, szFileName, ARRAYSIZE(szFileName)))
                {
                    for (DWORD dw = 0; SUCCEEDED(hres) && (dw < _cste); ++dw)
                    {
                        _GetFriendlyStrings(&(_rgsubservice[dw]), szFriendlyName,
                            ARRAYSIZE(szFriendlyName), szDescription,
                            ARRAYSIZE(szDescription));

                        SC_HANDLE hService = CreateService(hSCM,
                            _rgste[dw].lpServiceName,
                            szFriendlyName,
                            0,
                            SERVICE_WIN32_SHARE_PROCESS,
                            dwStartType, SERVICE_ERROR_IGNORE, 
                            szFileName,
                            _rgsubservice[dw].pszLoadOrderGroup, 
                            NULL, _rgsubservice[dw].pszDependencies,
                            NULL, NULL);

                        if (hService)
                        {
                            SERVICE_DESCRIPTION sd;

                            sd.lpDescription = szDescription;

                            ChangeServiceConfig2(hService,
                                SERVICE_CONFIG_DESCRIPTION, &sd);

                            CloseServiceHandle(hService);
                        }
                        else
                        {
                            hres = E_FAIL;
                        }
                    }
                }
            }
            else
            {
                for (DWORD dw = 0; SUCCEEDED(hres) && (dw < _cste); ++dw)
                {
                    WCHAR szCmd[MAX_PATH] =
                        TEXT("%SystemRoot%\\System32\\svchost.exe -k ");

                    hres = SafeStrCatN(szCmd, pszSVCHostGroup, ARRAYSIZE(szCmd));

                    if (SUCCEEDED(hres))
                    {
                        _GetFriendlyStrings(&(_rgsubservice[dw]), szFriendlyName,
                            ARRAYSIZE(szFriendlyName), szDescription,
                            ARRAYSIZE(szDescription));

                        SC_HANDLE hService = CreateService(hSCM,
                            _rgste[dw].lpServiceName,
                            szFriendlyName,
                            0,
                            SERVICE_WIN32_SHARE_PROCESS,
                            dwStartType, SERVICE_ERROR_IGNORE, 
                            szCmd,
                            _rgsubservice[dw].pszLoadOrderGroup, 
                            NULL, _rgsubservice[dw].pszDependencies,
                            NULL, NULL);

                        if (hService)
                        {
                            SERVICE_DESCRIPTION sd;

                            sd.lpDescription = szDescription;

                            ChangeServiceConfig2(hService,
                                SERVICE_CONFIG_DESCRIPTION, &sd);

                            CloseServiceHandle(hService);

                            hres = _InstSetParameters(_rgste[dw].lpServiceName);

                            if (SUCCEEDED(hres))
                            {
                                hres = _InstSetSVCHostInfo(
                                    _rgste[dw].lpServiceName);
                            }
                        }
                        else
                        {
                            if (ERROR_SERVICE_EXISTS == GetLastError())
                            {
                                // We had this problem on upgrade.  The service is
                                // already there, so CreateService fails.  As a result the
                                // StartType was not switched from Demand Start to Auto Start.
                                // The following lines will do just that.
                                // This code should be expanded for general upgraded cases.
                                // All the other values in the structure should be passed here.
                                hService = OpenService(hSCM,
                                    _rgste[dw].lpServiceName, SERVICE_CHANGE_CONFIG);

                                if (hService)
                                {
                                    if (ChangeServiceConfig(
                                        hService,           // handle to service
                                        SERVICE_NO_CHANGE,  // type of service
                                        dwStartType,        // when to start service
                                        SERVICE_NO_CHANGE,  // severity of start failure
                                        szCmd,              // service binary file name
                                        _rgsubservice[dw].pszLoadOrderGroup, // load ordering group name
                                        NULL,               // tag identifier
                                        NULL,               // array of dependency names
                                        NULL,               // account name
                                        NULL,               // account password
                                        NULL                // display name
                                        ))
                                    {
                                        // Do this un upgrade too
                                        hres = _InstSetSVCHostInfo(
                                            _rgste[dw].lpServiceName);

                                        if (SUCCEEDED(hres))
                                        {
                                            hres = _InstSetParameters(_rgste[dw].lpServiceName);
                                        }
                                    }
                                    else
                                    {
                                        hres = E_FAIL;
                                    }

                                    SERVICE_DESCRIPTION sd;

                                    sd.lpDescription = szDescription;

                                    ChangeServiceConfig2(hService,
                                        SERVICE_CONFIG_DESCRIPTION, &sd);

                                    CloseServiceHandle(hService);
                                }

                            }
                            else
                            {
                                hres = E_FAIL;
                            }
                        }
                    }
                }
            }

            CloseServiceHandle(hSCM);
        }
 
        // We don't need the ShellCOMServer anymore, so let's nuke it away on upgrades
        _UnInstall(TEXT("ShellCOMServer"));
    
        // Also remove the following reg entry on upgrade
        _RegDeleteValue(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost"), TEXT("shsvc"));
    }

    return hres;    
}

// static
HRESULT CGenericServiceManager::Init()
{
    return _Init();
}

// static
HRESULT CGenericServiceManager::Cleanup()
{
    return _Cleanup();
}

///////////////////////////////////////////////////////////////////////////////
// Private
// static
HRESULT CGenericServiceManager::_Init()
{
    HRESULT hres = E_FAIL;
    ASSERT(ARRAYSIZE(_rgste) == (ARRAYSIZE(_rgsubservice) + 1));

    if (!InterlockedCompareExchange((LONG*)&_fInitializationDone, TRUE,
        FALSE))
    {
        _hEventInitCS = CreateEvent(NULL, TRUE, FALSE,
            TEXT("CGenericServiceManager__Init"));

        if (_hEventInitCS)
        {
            InitializeCriticalSection(&_cs);

            SetEvent(_hEventInitCS);

            hres = S_OK;
        }
    }
    else
    {
        HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE,
            TEXT("CGenericServiceManager__Init"));

        if (hEvent)
        {
            WaitForSingleObject(hEvent, INFINITE);

            CloseHandle(hEvent);

            hres = S_OK;
        }
    }

    if (SUCCEEDED(hres))
    {
        ::InterlockedIncrement((LONG*)&_cRefCS);

        // Per thread
        hres = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::_Cleanup()
{
    if (_fInitializationDone)
    {
        ULONG cRef = ::InterlockedDecrement((LONG*)&_cRefCS);

        if (!cRef)
        {
            DeleteCriticalSection(&_cs);
            CloseHandle(_hEventInitCS);
        }

        // Per thread
        CoUninitialize();

        InterlockedExchange((LONG*)&_fInitializationDone, FALSE);
    }

    return S_OK;
}

__inline void _TraceServiceCode(DWORD
#ifdef DEBUG
                                dwControl
#endif
                                )
{
#ifdef DEBUG
    LPWSTR pszControl = TEXT("Unknown");

    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP: pszControl = TEXT("SERVICE_CONTROL_STOP"); break;
        case SERVICE_CONTROL_PAUSE: pszControl = TEXT("SERVICE_CONTROL_PAUSE"); break;
        case SERVICE_CONTROL_CONTINUE: pszControl = TEXT("SERVICE_CONTROL_CONTINUE"); break;
        case SERVICE_CONTROL_INTERROGATE: pszControl = TEXT("SERVICE_CONTROL_INTERROGATE"); break;
        case SERVICE_CONTROL_SHUTDOWN: pszControl = TEXT("SERVICE_CONTROL_SHUTDOWN"); break;
        case SERVICE_CONTROL_PARAMCHANGE: pszControl = TEXT("SERVICE_CONTROL_PARAMCHANGE"); break;
        case SERVICE_CONTROL_NETBINDADD: pszControl = TEXT("SERVICE_CONTROL_NETBINDADD"); break;
        case SERVICE_CONTROL_NETBINDREMOVE: pszControl = TEXT("SERVICE_CONTROL_NETBINDREMOVE"); break;
        case SERVICE_CONTROL_NETBINDENABLE: pszControl = TEXT("SERVICE_CONTROL_NETBINDENABLE"); break;
        case SERVICE_CONTROL_NETBINDDISABLE: pszControl = TEXT("SERVICE_CONTROL_NETBINDDISABLE"); break;
        case SERVICE_CONTROL_DEVICEEVENT: pszControl = TEXT("SERVICE_CONTROL_DEVICEEVENT"); break;
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE: pszControl = TEXT("SERVICE_CONTROL_HARDWAREPROFILECHANGE"); break;
        case SERVICE_CONTROL_POWEREVENT: pszControl = TEXT("SERVICE_CONTROL_POWEREVENT"); break;
        case SERVICE_CONTROL_SESSIONCHANGE: pszControl = TEXT("SERVICE_CONTROL_SESSIONCHANGE"); break;
    }

    TRACE(TF_SERVICE, TEXT("Received Service Control code: %s (0x%08X)"),
        pszControl, dwControl);
#endif
}

///////////////////////////////////////////////////////////////////////////////
// Private
//static 
DWORD WINAPI CGenericServiceManager::_ServiceHandler(DWORD dwControl,
    DWORD dwEventType, LPVOID pvEventData, LPVOID lpContext)
{
    // We don't want to deny any request, so return NO_ERROR whatever happens
    DWORD dwRet = NO_ERROR;

    // This is called on the main thread not the thread of the specific
    // service, so keep it short and sweet
    SERVICEENTRY* pse = (SERVICEENTRY*)lpContext;

    if (pse)
    {
        BOOL fProcess = FALSE;
        BOOL fSynch = FALSE;
        HRESULT hres = S_OK;

        switch (dwControl)
        {
            case SERVICE_CONTROL_STOP:
            case SERVICE_CONTROL_SHUTDOWN:
                TRACE(TF_SERVICE, TEXT("Received SERVICE_CONTROL_SHUTDOWN or STOP, will skip all other terminating events"));

                if (!pse->_fSkipTerminatingEvents)
                {
                    fProcess = TRUE;
                    pse->_fSkipTerminatingEvents = TRUE;
                }
                else
                {
                    TRACE(TF_SERVICE, TEXT("Skipping terminating event"));
                }

                break;

            case SERVICE_CONTROL_INTERROGATE:
                // Special case SERVICE_CONTROL_INTERROGATE.  We don't really need the
                // IService impl to process this.  The service will also be more
                // responsive this way.  The state can be queried in the middle of
                // execution.
                TRACE(TF_SERVICE, TEXT("Received SERVICE_CONTROL_INTERROGATE"));

                _SetServiceStatus(pse);
                break;

            default:
                if (!pse->_fSkipTerminatingEvents)
                {
                    fProcess = TRUE;

                    hres = _EventNeedsToBeProcessedSynchronously(dwControl,
                        dwEventType, pvEventData, pse, &fSynch);
                }
                break;
        }

        if (SUCCEEDED(hres) && fProcess)
        {
            _TraceServiceCode(dwControl);

            EnterCriticalSection(&_cs);

            hres = _QueueEvent(pse, dwControl, dwEventType, pvEventData);

            if (SUCCEEDED(hres))
            {
                // Let the service process events
                SetEvent(pse->_hEventRelinquishControl);

                ResetEvent(pse->_hEventSynchProcessing);
            }

            LeaveCriticalSection(&_cs);

            if (SUCCEEDED(hres) && fSynch)
            {
                Sleep(0);

                TRACE(TF_SERVICE,
                    TEXT("=========== Processing SYNCHRONOUSLY ==========="));

                // We have to wait before we return... (at most 20 sec)
                DWORD dwWait = WaitForSingleObject(pse->_hEventSynchProcessing,
                   20000);

                if (WAIT_TIMEOUT == dwWait)
                {
                    TRACE(TF_SERVICE,
                        TEXT("=========== WAIT TIMED OUT ==========="));
                }

                TRACE(TF_SERVICE,
                    TEXT("=========== FINISHED processing SYNCHRONOUSLY ==========="));

#ifdef DEBUG
                // If we get the notifs from a windowproc, return TRUE,
                // or else we'll deny any request to remove, lock, ...
                if (!_fRunAsService)
                {
                    if (SERVICE_CONTROL_DEVICEEVENT == dwControl)
                    {
                        dwRet = TRUE;
                    }
                }
#endif
            }
        }
    }

    return dwRet;
}

//static
void WINAPI CGenericServiceManager::_ServiceMain(DWORD cArg, LPWSTR* ppszArgs)
{
    SERVICEENTRY* pse;
    LPCWSTR pszServiceName = *ppszArgs;

    HRESULT hres = _Init();

    if (SUCCEEDED(hres))
    {
        hres = _InitServiceEntry(pszServiceName, &pse);

        if (SUCCEEDED(hres))
        {
            hres = _RegisterServiceCtrlHandler(pszServiceName, pse);

            if (SUCCEEDED(hres))
            {
                pse->_servicestatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
                pse->_servicestatus.dwCurrentState = SERVICE_START_PENDING;

                _SetServiceStatus(pse);

                hres = _CreateIService(pszServiceName, &(pse->_pservice));

                if (SUCCEEDED(hres))
                {
                    WCHAR szEventName[MAX_EVENTNAME];
                    hres = _GetServiceEventName(pszServiceName, szEventName,
                        ARRAYSIZE(szEventName));

                    if (SUCCEEDED(hres))
                    {
                        hres = pse->_pservice->InitMinimum(cArg, ppszArgs,
                            szEventName, &(pse->_servicestatus.dwControlsAccepted),
                            &(pse->_fWantsDeviceEvents));

                        if (SUCCEEDED(hres))
                        {
                            hres = _HandleWantsDeviceEvents(pszServiceName,
                                pse->_fWantsDeviceEvents);

                            if (SUCCEEDED(hres))
                            {
                                if (pse->_fWantsDeviceEvents)
                                {
                                    hres = pse->_pservice->InitDeviceEventHandler(
                                        pse->_ssh);
                                }

                                if (SUCCEEDED(hres))
                                {
                                    pse->_servicestatus.dwCurrentState =
                                        SERVICE_RUNNING;

                                    _SetServiceStatus(pse);

                                    hres = pse->_pservice->InitFinal();

                                    if (SUCCEEDED(hres))
                                    {
                                        do
                                        {
                                            hres = pse->_pservice->Run();

                                            if (SUCCEEDED(hres))
                                            {
                                                // The service has finished its business or it
                                                // relinquished control because
                                                // _hEventRelinquishControl is set
                                                //
                                                // If it relinquished control because of a
                                                // service control event, then let's process it
                                                DWORD dwWait = WaitForSingleObject(
                                                    pse->_hEventRelinquishControl,
                                                    INFINITE);

                                                TRACE(TF_SERVICEDETAILED,
                                                    TEXT("WaitForSingleObj returned with: 0x%08X"),
                                                    dwWait);

                                                if (WAIT_OBJECT_0 == dwWait)
                                                {
                                                    // Process all Service Control codes
                                                    // received.
                                                    hres = _ProcessServiceControlCodes(
                                                        pse);
                                                }
                                                else
                                                {
                                                    hres = E_FAIL;
                                                }
                                            }
                                        }
                                        while (SUCCEEDED(hres) &&
                                            (SERVICE_STOPPED !=
                                            pse->_servicestatus.dwCurrentState));
                                    }
                                }
                            }
                            // What do we do with hres?
                        }
                    }    
                }
            }
            else
            {
#ifdef DEBUG
                TRACE(TF_SERVICEDETAILED,
                    TEXT("%s: _RegisterServiceCtrlHandler FAILED: 0x%08X"),
                    pse->_szServiceName, hres);
#endif
            }

            _CleanupServiceEntry(pse);
        }

        if (SUCCEEDED(hres) &&
            (SERVICE_STOPPED == pse->_servicestatus.dwCurrentState))
        {
            _SetServiceStatus(pse);
        }

        _Cleanup();
    }

    TRACE(TF_SERVICE, TEXT("Exiting _ServiceMain for Service: %s"), pszServiceName);
}

//static
HRESULT CGenericServiceManager::_ProcessServiceControlCodes(SERVICEENTRY* pse)
{
    HRESULT hres;
    BOOL fEndLoop = FALSE;

    TRACE(TF_SERVICEDETAILED, TEXT("Entered _ProcessServiceControlCodes"));

    do
    {
        CTRLEVENT*  pevent;

        EnterCriticalSection(&_cs);

        TRACE(TF_SERVICEDETAILED, TEXT("Entered _ProcessServiceControlCodes' Critical Section"));

        hres = _DeQueueEvent(pse, &pevent);

        TRACE(TF_SERVICE, TEXT("DeQueued Event: 0x%08X"), hres);

        if (!pse->_peventQueueHead)
        {
            ASSERT(!pse->_cEvents);

            fEndLoop = TRUE;

            ResetEvent(pse->_hEventRelinquishControl);
        }

        LeaveCriticalSection(&_cs);

        if (SUCCEEDED(hres))
        {
            ///////////////////////////////////////////////////////////////////
            // If we're here then we should have received some service control,
            // or the IService decided it had nothing more to process
            //
            TRACE(TF_SERVICEDETAILED, TEXT("Will call _HandleServiceControls (dwControl = 0x%08X)"),
                pevent->dwControl);

            hres = _HandleServiceControls(pse, pevent->dwControl, 
                pevent->dwEventType, (PVOID)(pevent->rgbEventData));

            if (SERVICE_CONTROL_DEVICEEVENT == pevent->dwControl)
            {
                // Never ever return something else than NO_ERROR (S_OK) for these
                hres = NO_ERROR;
            }

            TRACE(TF_SERVICE, TEXT("_HandleServiceControls returned: 0x%08X"), hres);

            LocalFree((HLOCAL)pevent);
        }

        if (fEndLoop)
        {
            TRACE(TF_SERVICEDETAILED, TEXT("Resetting RelinquishEvent"));

            SetEvent(pse->_hEventSynchProcessing);
        }
    }
    while (!fEndLoop && SUCCEEDED(hres));

    TRACE(TF_SERVICEDETAILED, TEXT("Exiting _ProcessServiceControlCodes"));

    return hres;
}

#pragma warning(push)
// FALSE positive below: fPending
#pragma warning(disable : 4701)
//static
HRESULT CGenericServiceManager::_HandleServiceControls(SERVICEENTRY* pse,
    DWORD dwControl, DWORD dwEventType, PVOID pvEventData)
{
    HRESULT hres = _HandlePreState(pse, dwControl);

    TRACE(TF_SERVICEDETAILED, TEXT("_HandlePreState returned: 0x%08X, status: 0x%08X"), hres,
        pse->_servicestatus.dwCurrentState);

    if (SUCCEEDED(hres))
    {
        if (S_OK == hres)
        {
            switch (dwControl)
            {
                case SERVICE_CONTROL_STOP:
                case SERVICE_CONTROL_PAUSE:
                case SERVICE_CONTROL_CONTINUE:
                case SERVICE_CONTROL_SHUTDOWN:
                {
                    BOOL fPending;

                    do
                    {
                        // This will return S_FALSE if it's pending
                        hres = pse->_pservice->HandleServiceControl(dwControl,
                            &(pse->_servicestatus.dwWaitHint));

                        if (SUCCEEDED(hres))
                        {
                            if (S_FALSE == hres)
                            {
                                ASSERT(pse->_servicestatus.dwWaitHint);

                                fPending = TRUE;
                            }
                            else
                            {
                                fPending = FALSE;
                            }

                            TRACE(TF_SERVICE, TEXT("Will call _HandlePostState (fPending = %d)"),
                                fPending);

                            hres = _HandlePostState(pse, dwControl, fPending);

                            TRACE(TF_SERVICE, TEXT("_HandlePostState returned: 0x%08X, status: 0x%08X"),
                                hres, pse->_servicestatus.dwCurrentState);
                        }
                    }
                    while (SUCCEEDED(hres) && fPending);

                    break;
                }

                case SERVICE_CONTROL_DEVICEEVENT:
                    TRACE(TF_SERVICE, TEXT("Received SERVICE_CONTROL_DEVICEEVENT"));

                    if (!(pse->_fSkipTerminatingEvents))
                    {
                        hres = pse->_pservice->HandleDeviceEvent(dwEventType,
                            pvEventData);
                    }
                    else
                    {
                        hres = S_OK;
                    }
                    
                    break;

                case SERVICE_CONTROL_SESSIONCHANGE:
                    TRACE(TF_SERVICE, TEXT("Received: SERVICE_CONTROL_SESSIONCHANGE"));

                    if (!(pse->_fSkipTerminatingEvents))
                    {
                        hres = pse->_pservice->HandleSessionChange(dwEventType, pvEventData);
                    }
                    else
                    {
                        hres = S_OK;
                    }

                    break;

                default:
                    TRACE(TF_SERVICE, TEXT("Received unhandled service control"));

                    hres = S_FALSE;
                    break;
            }
        }
    }

    return hres;
}
#pragma warning(pop)

// static
HRESULT CGenericServiceManager::_GetServiceIndex(LPCWSTR pszServiceName,
    DWORD* pdw)
{
    HRESULT hres = E_FAIL;

    ASSERT(pszServiceName);
    ASSERT(pdw);

    for (DWORD dw = 0; FAILED(hres) && (dw < _cste); ++dw)
    {
        if (!lstrcmp(pszServiceName, _rgste[dw].lpServiceName))
        {
            // Found it
            *pdw = dw;

            hres = S_OK;
        }
    }    

    return hres;
}

HRESULT CGenericServiceManager::_GetServiceCLSID(LPCWSTR pszServiceName,
    CLSID* pclsid)
{
    ASSERT(pszServiceName);
    ASSERT(pclsid);

    DWORD dw;
    HRESULT hres = _GetServiceIndex(pszServiceName, &dw);

    if (SUCCEEDED(hres))
    {
        // Found it
        hres = CLSIDFromProgID(_rgsubservice[dw].pszProgID, pclsid);
    }

    return hres;
}

HRESULT CGenericServiceManager::_CreateIService(LPCWSTR pszServiceName,
    IService** ppservice)
{
    CLSID clsid;
    HRESULT hres = _GetServiceCLSID(pszServiceName, &clsid);

    *ppservice = NULL;

    if (SUCCEEDED(hres))
    {
        hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
            IID_PPV_ARG(IService, ppservice));
    }

    return hres;
}

HRESULT CGenericServiceManager::_InitServiceEntry(LPCWSTR pszServiceName,
    SERVICEENTRY** ppse)
{
    DWORD dw;
    HRESULT hres = _GetServiceIndex(pszServiceName, &dw);

    if (SUCCEEDED(hres))
    {
        WCHAR szEventName[MAX_EVENTNAME];

        *ppse = &(_rgsubservice[dw].se);

        ZeroMemory(*ppse, sizeof(**ppse));

        hres = _GetServiceEventName(pszServiceName, szEventName,
            ARRAYSIZE(szEventName));

        if (SUCCEEDED(hres))
        {
            (*ppse)->_hEventRelinquishControl = CreateEvent(NULL, TRUE, FALSE,
                szEventName);

            if (!((*ppse)->_hEventRelinquishControl))
            {
                hres = E_FAIL;
            }

            if (SUCCEEDED(hres))
            {
                (*ppse)->_hEventSynchProcessing = CreateEvent(NULL, TRUE, TRUE,
                    NULL);

                if (!((*ppse)->_hEventSynchProcessing))
                {
                    hres = E_FAIL;
                }
            }

            if (FAILED(hres))
            {
                _CleanupServiceEntry(*ppse);
            }
        }
    }

    return hres;
}

HRESULT CGenericServiceManager::_CleanupServiceEntry(SERVICEENTRY* pse)
{
    if (pse->_pservice)
    {
        pse->_pservice->Release();
    }

    if (pse->_hEventRelinquishControl)
    {
        CloseHandle(pse->_hEventRelinquishControl);
    }

    if (pse->_hEventSynchProcessing)
    {
        CloseHandle(pse->_hEventSynchProcessing);
    }

    return S_OK;
}

//static
HRESULT CGenericServiceManager::_HandlePreState(SERVICEENTRY* pse,
    DWORD dwControl)
{
    HRESULT hres;
    BOOL fSetServiceStatus = TRUE;

    // _HandleServiceControls will loop until we are not in a pending state.
    // All incoming ctrl events are queued, and will be processed on this same
    // thread, so we should never enter this fct in a pending state.
    ASSERT(SERVICE_STOP_PENDING != pse->_servicestatus.dwCurrentState);
    ASSERT(SERVICE_START_PENDING != pse->_servicestatus.dwCurrentState);
    ASSERT(SERVICE_CONTINUE_PENDING != pse->_servicestatus.dwCurrentState);
    ASSERT(SERVICE_PAUSE_PENDING != pse->_servicestatus.dwCurrentState);

    // Should have been processed in _ServiceHandler
    ASSERT(SERVICE_CONTROL_INTERROGATE != dwControl);

    // We cleanup a bit.  If the request is incompatible with the current state
    // then we return S_FALSE to instruct _HandleServiceControls to not call
    // the IService impl for nothing.
    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP:
            switch (pse->_servicestatus.dwCurrentState)
            {
                case SERVICE_STOPPED:
                    hres = S_FALSE;
                    break;

                case SERVICE_RUNNING:
                case SERVICE_PAUSED:
                default:
                    pse->_servicestatus.dwCurrentState = SERVICE_STOP_PENDING;
                    hres = S_OK;
                    break;
            }
            break;
        case SERVICE_CONTROL_PAUSE:
            ASSERT(SERVICE_STOPPED != pse->_servicestatus.dwCurrentState);

            switch (pse->_servicestatus.dwCurrentState)
            {
                case SERVICE_PAUSED:
                    hres = S_FALSE;
                    break;

                case SERVICE_STOPPED:
                    // Weird, think about it...
                    hres = S_FALSE;
                    break;

                case SERVICE_RUNNING:
                default:
                    pse->_servicestatus.dwCurrentState = SERVICE_PAUSE_PENDING;
                    hres = S_OK;
                    break;
            }
            break;
        case SERVICE_CONTROL_CONTINUE:
            ASSERT(SERVICE_STOPPED != pse->_servicestatus.dwCurrentState);

            switch (pse->_servicestatus.dwCurrentState)
            {
                case SERVICE_RUNNING:
                    hres = S_FALSE;
                    break;

                case SERVICE_STOPPED:
                    // Weird, think about it...
                    hres = S_FALSE;
                    break;

                case SERVICE_PAUSED:
                default:
                    pse->_servicestatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
                    hres = S_OK;
                    break;
            }
            break;

        case SERVICE_CONTROL_SHUTDOWN:

            fSetServiceStatus = FALSE;

            hres = S_OK;
            break;

        case SERVICE_CONTROL_DEVICEEVENT:

            fSetServiceStatus = FALSE;

            if (pse->_fWantsDeviceEvents)
            {
                hres = S_OK;
            }
            else
            {
                hres = S_FALSE;
            }
            break;

        case SERVICE_CONTROL_SESSIONCHANGE:

            fSetServiceStatus = FALSE;

            hres = S_OK;
            
            break;

        default:
            hres = S_FALSE;
            break;
    }

    if (fSetServiceStatus)
    {
        _SetServiceStatus(pse);
    }

    return hres;
}

//static
HRESULT CGenericServiceManager::_HandlePostState(SERVICEENTRY* pse,
    DWORD dwControl, BOOL fPending)
{
    HRESULT hres = S_FALSE;

    // All incoming ctrl events are queued, and will be processed on this same
    // thread, so if we are pending, the dwControl should be compatible with
    // our current pending state.  We call _SetServiceStatus to update the
    // dwWaitHint.

    // We should already be in a pending state.  This should have been set
    // by _HandlePreState.  Just make sure of this.

    // Should have been processed in _ServiceHandler
    ASSERT(SERVICE_CONTROL_INTERROGATE != dwControl);

    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP:
            ASSERT(SERVICE_STOP_PENDING == pse->_servicestatus.dwCurrentState);

            if (!fPending)
            {
                pse->_servicestatus.dwCurrentState = SERVICE_STOPPED;
            }

            break;

        case SERVICE_CONTROL_PAUSE:
            ASSERT(SERVICE_PAUSE_PENDING ==
                pse->_servicestatus.dwCurrentState);

            if (!fPending)
            {
                pse->_servicestatus.dwCurrentState = SERVICE_PAUSED;
            }

            break;

        case SERVICE_CONTROL_CONTINUE:
            ASSERT(SERVICE_CONTINUE_PENDING ==
                pse->_servicestatus.dwCurrentState);

            if (!fPending)
            {
                pse->_servicestatus.dwCurrentState = SERVICE_RUNNING;
            }

            break;

        case SERVICE_CONTROL_SHUTDOWN:
            ASSERT(!fPending);

            pse->_servicestatus.dwCurrentState = SERVICE_STOPPED;

            break;
    }

    if (SERVICE_STOPPED != pse->_servicestatus.dwCurrentState)
    {
        _SetServiceStatus(pse);
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::_EventNeedsToBeProcessedSynchronously(
    DWORD dwControl, DWORD dwEventType, LPVOID pvEventData, SERVICEENTRY*,
    BOOL* pfBool)
{
    *pfBool = FALSE;

    if (SERVICE_CONTROL_DEVICEEVENT == dwControl)
    {
        if (pvEventData)
        {
            DEV_BROADCAST_HDR* dbhdr = (DEV_BROADCAST_HDR*)pvEventData;

            if (DBT_DEVTYP_HANDLE == dbhdr->dbch_devicetype)
            {
                if (DBT_DEVICEQUERYREMOVE == dwEventType)
                {
                    TRACE(TF_SERVICE, TEXT("Received DBT_DEVICEQUERYREMOVE"));

                    *pfBool = TRUE;
                }
                else
                {
                    if (DBT_CUSTOMEVENT == dwEventType)
                    {
                        DEV_BROADCAST_HANDLE* pdbh =
                            (DEV_BROADCAST_HANDLE*)dbhdr;

                        if ((GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid))
                        {
                            TRACE(TF_SERVICE, TEXT("------------Received GUID_IO_VOLUME_LOCK------------"));
                        }

                        if ((GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid))
                        {
                            TRACE(TF_SERVICE, TEXT("------------Received GUID_IO_VOLUME_LOCK_FAILED------------"));
                        }

                        if ((GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid))
                        {
                            TRACE(TF_SERVICE, TEXT("------------Received GUID_IO_VOLUME_UNLOCK------------"));
                        }

                        if ((GUID_IO_VOLUME_LOCK == pdbh->dbch_eventguid) ||
                            (GUID_IO_VOLUME_LOCK_FAILED == pdbh->dbch_eventguid) ||
                            (GUID_IO_VOLUME_UNLOCK == pdbh->dbch_eventguid))
                        {
                            *pfBool = TRUE;
                        }
                    }
                }
            }
        }
    }

    return S_OK;
}

// static
HRESULT CGenericServiceManager::_MakeEvent(DWORD dwControl, DWORD dwEventType,
    PVOID pvEventData, CTRLEVENT** ppevent)
{
    HRESULT hres = S_OK;

    DWORD cbSize = sizeof(CTRLEVENT);
    CTRLEVENT* pevent;

    if (SERVICE_CONTROL_DEVICEEVENT == dwControl)
    {
        if (pvEventData)
        {
            cbSize += ((DEV_BROADCAST_HDR*)pvEventData)->dbch_size;
        }
    }

    pevent = (CTRLEVENT*)LocalAlloc(LPTR, cbSize);

    if (pevent)
    {
        // Payload
        pevent->dwControl = dwControl;
        pevent->dwEventType = dwEventType;

        *ppevent = pevent;

        if (cbSize > sizeof(CTRLEVENT))
        {
            if (pvEventData)
            {
                CopyMemory(pevent->rgbEventData, pvEventData,
                    cbSize - sizeof(CTRLEVENT));
            }
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::_QueueEvent(SERVICEENTRY* pse, DWORD dwControl,
    DWORD dwEventType, PVOID pvEventData)
{
    CTRLEVENT* pevent;
    HRESULT hres = _MakeEvent(dwControl, dwEventType, pvEventData, &pevent);

    if (SUCCEEDED(hres))
    {
        // We add at tail, remove at head
        // Prev: closer to head
        // Next: closer to tail

        pevent->peventNext = NULL;

        if (pse->_peventQueueTail)
        {
            ASSERT(!(pse->_peventQueueTail->peventNext));
            pse->_peventQueueTail->peventNext = pevent;
        }

        pse->_peventQueueTail = pevent;

        if (!pse->_peventQueueHead)
        {
            pse->_peventQueueHead = pse->_peventQueueTail;
        }

#ifdef DEBUG
        ++(pse->_cEvents);

        if (1 == pse->_cEvents)
        {
            ASSERT(pse->_peventQueueHead == pse->_peventQueueTail);
        }
        else
        {
            if (0 == pse->_cEvents)
            {
                ASSERT(!pse->_peventQueueHead && !pse->_peventQueueTail);
            }
            else
            {
                ASSERT(pse->_peventQueueHead && pse->_peventQueueTail && 
                    (pse->_peventQueueHead != pse->_peventQueueTail));
            }
        }
#endif
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::_DeQueueEvent(SERVICEENTRY* pse,
    CTRLEVENT** ppevent)
{
    ASSERT(pse->_peventQueueHead);

    // We add at tail, remove at head
    // Prev: closer to head
    // Next: closer to tail

    CTRLEVENT* peventRet = pse->_peventQueueHead;
    CTRLEVENT* peventNewHead = peventRet->peventNext;

    // Any elem left after removing head?
    if (!peventNewHead)
    {   
        // No
        pse->_peventQueueTail = NULL;
    }

    pse->_peventQueueHead = peventNewHead;

    peventRet->peventNext = NULL;
    *ppevent = peventRet;

#ifdef DEBUG
    --(pse->_cEvents);

    if (1 == pse->_cEvents)
    {
        ASSERT(pse->_peventQueueHead == pse->_peventQueueTail);
    }
    else
    {
        if (0 == pse->_cEvents)
        {
            ASSERT(!pse->_peventQueueHead && !pse->_peventQueueTail);
        }
        else
        {
            ASSERT(pse->_peventQueueHead && pse->_peventQueueTail && 
                (pse->_peventQueueHead != pse->_peventQueueTail));
        }
    }
#endif

    return S_OK;
}

HRESULT _GetServiceEventName(LPCWSTR pszServiceName, LPWSTR pszEventName,
    DWORD cchEventName)
{
    LPWSTR pszNext;
    DWORD cchLeft;
    HRESULT hres = SafeStrCpyNEx(pszEventName, pszServiceName, cchEventName,
        &pszNext, &cchLeft);

    if (SUCCEEDED(hres))
    {
        hres = SafeStrCpyN(pszNext, TEXT("'sEvent"), cchLeft);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shsrvice\process.cpp ===
#include "shsrvice.h"

#include "mischlpr.h"

#include "dbg.h"
#include "tfids.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#define SC_PAUSE        0
#define SC_CONTINUE     1
#define SC_STOP         2
#define SC_SHUTDOWN     3
#define SC_INTERROGATE  4

DWORD rgdwControlCodes[] =
{
    SERVICE_CONTROL_PAUSE, //                  0x00000002
    SERVICE_CONTROL_CONTINUE, //               0x00000003
    SERVICE_CONTROL_STOP, //                   0x00000001
    SERVICE_CONTROL_SHUTDOWN, //               0x00000005
    SERVICE_CONTROL_INTERROGATE, //            0x00000004
};

static SERVICEENTRY* g_pseWantsDeviceEvents = NULL;
static SERVICEENTRY** g_ppse = NULL;
static HWND g_hwnd = NULL;
static HANDLE* g_phEvent = NULL;

LRESULT _FakeWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

DWORD WINAPI _ServiceMainCaller(PVOID pvParam)
{
    LPWSTR* ppsz = (LPWSTR*)pvParam;

    TRACE(TF_SERVICEASPROCESS, TEXT("%s: _ServiceMainCaller called"),
        (LPWSTR)*ppsz);
    
    CGenericServiceManager::_ServiceMain(1, (LPWSTR*)pvParam);

    return 0;
}

DWORD _ServiceIndexFromServiceName(SERVICE_TABLE_ENTRY* pste,
    LPCWSTR pszServiceName)
{
    DWORD dw = 0;

    while (pste[dw].lpServiceName)
    {
        if (!lstrcmp(pste[dw].lpServiceName, pszServiceName))
        {
            break;
        }
        else
        {
            ++dw;
        }
    }

    return dw;
}

//static
HRESULT CGenericServiceManager::_RegisterServiceCtrlHandler(
    LPCWSTR pszServiceName, SERVICEENTRY* pse)
{
    ASSERT(pse);

    TRACE(TF_SERVICEASPROCESS, TEXT("%s: _RegisterServiceCtrlHandler called"),
        pszServiceName);

    g_ppse[_ServiceIndexFromServiceName(_rgste, pszServiceName)] = pse;

#ifdef DEBUG
    lstrcpy(pse->_szServiceName, pszServiceName);
#endif        

    return S_OK;
}

// static
HRESULT CGenericServiceManager::_HandleWantsDeviceEvents(
    LPCWSTR pszServiceName, BOOL UNREF_PARAM(fWantsDeviceEvents))
{
    HRESULT hres = E_FAIL;
    DWORD dwWait;
    DWORD dwService = _ServiceIndexFromServiceName(_rgste, pszServiceName);

    TRACE(TF_SERVICEASPROCESS, TEXT("%s: _HandleWantsDeviceEvents (1)"),
        pszServiceName);

    // We need to release the main service thread, so that it can create
    // the fake wnd that will receive the WM_DEVICECHANGE msgs to fake
    // the SERVICE_CONTROL_DEVICEEVENT.
    SetEvent(g_phEvent[dwService]);

    TRACE(TF_SERVICEASPROCESS, TEXT("%s: _HandleWantsDeviceEvents (2)"),
        pszServiceName);
    // Let's relinquish our remaining time slice.  Or else we won't wait on
    // the following line.
    // That's not fool proof (might not work) but this is test code...
    Sleep(0);

    TRACE(TF_SERVICEASPROCESS, TEXT("%s: _HandleWantsDeviceEvents (3)"),
        pszServiceName);
    // We wait until the main service thread is done with the window creation.
    // Then g_hwnd wil lbe set and we'll be able to use it to register for
    // notif.
    dwWait = WaitForSingleObject(g_phEvent[dwService], INFINITE);

    TRACE(TF_SERVICEASPROCESS, TEXT("%s: _HandleWantsDeviceEvents (4)"),
        pszServiceName);
    if (WAIT_OBJECT_0 == dwWait)
    {
        hres = S_OK;
    }

    CloseHandle(g_phEvent[dwService]);

    g_phEvent[dwService] = NULL;

    return hres;
}

// static
HRESULT CGenericServiceManager::StartServiceCtrlDispatcher()
{
    HRESULT hres = E_FAIL;
    HANDLE* phEvents;
    
    g_ppse = (SERVICEENTRY**)LocalAlloc(LPTR, sizeof(SERVICEENTRY*) * _cste);

    phEvents = (HANDLE*)LocalAlloc(LPTR, sizeof(HANDLE) * _cste * 5);

    g_phEvent = (HANDLE*)LocalAlloc(LPTR, sizeof(HANDLE) * _cste);

    if (g_ppse && phEvents && g_phEvent)
    {
        for (DWORD dwService = 0; dwService < _cste; ++dwService)
        {
            WCHAR szEventName[256];
            LPWSTR pszServiceName = _rgste[dwService].lpServiceName;

            hres = S_OK;

            lstrcpy(szEventName, _rgste[dwService].lpServiceName);
            lstrcat(szEventName, TEXT(".SC_PAUSE"));

            phEvents[dwService * 5 + SC_PAUSE] = CreateEvent(NULL, TRUE,
                FALSE, szEventName);

            lstrcpy(szEventName, _rgste[dwService].lpServiceName);
            lstrcat(szEventName, TEXT(".SC_CONTINUE"));

            phEvents[dwService * 5 + SC_CONTINUE] = CreateEvent(NULL, TRUE,
                FALSE, szEventName);

            lstrcpy(szEventName, _rgste[dwService].lpServiceName);
            lstrcat(szEventName, TEXT(".SC_STOP"));

            phEvents[dwService * 5 + SC_STOP] = CreateEvent(NULL, TRUE,
                FALSE, szEventName);

            lstrcpy(szEventName, _rgste[dwService].lpServiceName);
            lstrcat(szEventName, TEXT(".SC_SHUTDOWN"));

            phEvents[dwService * 5 + SC_SHUTDOWN] = CreateEvent(NULL, TRUE,
                FALSE, szEventName);

            lstrcpy(szEventName, _rgste[dwService].lpServiceName);
            lstrcat(szEventName, TEXT(".SC_INTERROGATE"));

            phEvents[dwService * 5 + SC_INTERROGATE] = CreateEvent(NULL, TRUE,
                FALSE, szEventName);

            for (DWORD dwEvent = SC_PAUSE; SUCCEEDED(hres) &&
                (dwEvent <= SC_INTERROGATE); ++dwEvent)
            {
                if (!phEvents[(dwService * 5) + dwEvent])
                {
                    hres = E_FAIL;
                }
            }

            if (SUCCEEDED(hres))
            {
                g_phEvent[dwService] = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (g_phEvent[dwService])
                {
                    CreateThread(NULL, 0, _ServiceMainCaller,
                        (LPWSTR*)&(_rgste[dwService].lpServiceName), 0, NULL);

                    // We have to wait for the IService impl to be CoCreated and
                    // queried for fWantsDeviceEvents.  So we block here.
                    // _HandleWantsDeviceEvents will unblock us when 
                    // fWantsDeviceEvents will be known.
                    TRACE(TF_SERVICEASPROCESS,
                        TEXT("%s: StartServiceCtrlDispatcher (1)"),
                        pszServiceName);

                    DWORD dwWait = WaitForSingleObject(g_phEvent[dwService],
                        INFINITE);

                    TRACE(TF_SERVICEASPROCESS,
                        TEXT("%s: StartServiceCtrlDispatcher (2)"),
                        pszServiceName);

                    if (WAIT_OBJECT_0 == dwWait)
                    {
                        if (g_ppse[dwService]->_fWantsDeviceEvents)
                        {
                            WNDCLASSEX wndclass;
                            HINSTANCE hinst = GetModuleHandle(NULL);

                            g_pseWantsDeviceEvents = g_ppse[dwService];

                            if (hinst)
                            {
                                wndclass.cbSize        = sizeof(wndclass);
                                wndclass.style         = NULL;
                                wndclass.lpfnWndProc   = _FakeWndProc;
                                wndclass.cbClsExtra    = 0;
                                wndclass.cbWndExtra    = 0;
                                wndclass.hInstance     = hinst;
                                wndclass.hIcon         = NULL;
                                wndclass.hCursor       = NULL;
                                wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
                                wndclass.lpszMenuName  = NULL;
                                wndclass.lpszClassName = TEXT("FakeWnd");
                                wndclass.hIconSm       = NULL;

                                if (RegisterClassEx(&wndclass))
                                {
                                    g_hwnd = CreateWindow(TEXT("FakeWnd"), TEXT("FakeWnd"),
                                        WS_POPUPWINDOW, 0, 0, 100, 200, NULL, NULL, hinst, NULL);

                                    if (g_hwnd)
                                    {
                                        g_pseWantsDeviceEvents->_ssh =
                                            (SERVICE_STATUS_HANDLE)g_hwnd;
                                    }
                                }
                            }
                        }

                        // We're done with the window creation, release the IService
                        // impl thread.
                        SetEvent(g_phEvent[dwService]);
                    }
                }
            }
            TRACE(TF_SERVICEASPROCESS,
                TEXT("%s: StartServiceCtrlDispatcher (3)"),
                pszServiceName);
        }

        while (SUCCEEDED(hres))
        {
            DWORD dw = MsgWaitForMultipleObjects(_cste * 5,
                phEvents, FALSE, INFINITE, QS_ALLINPUT);

            if (WAIT_FAILED != dw)
            {
                if ((_cste * 5) == (dw - WAIT_OBJECT_0))
                {
                    MSG msg;

                    if (GetMessage(&msg, NULL, 0, 0))
                    {
                        if (WM_DEVICECHANGE != msg.message)
                        {
                            DispatchMessage(&msg);
                        }
                        else
                        {
                            // To mimic the true service behavior, deliver
                            // these messages only if the "service" is
                            // running
                            if (SERVICE_RUNNING ==
                                g_pseWantsDeviceEvents->_servicestatus.dwCurrentState)
                            {
                                DispatchMessage(&msg);
                            }
                        }
                    }
                }
                else
                {
                    DWORD dwService2 = ((dw - WAIT_OBJECT_0 + 1) / 5);

                    if (NO_ERROR != _ServiceHandler(
                        rgdwControlCodes[(dw - WAIT_OBJECT_0) -
                        (dwService2 * 5)], 0, NULL, (PVOID)g_ppse[dwService2]))
                    {
                        hres = E_FAIL;
                    }
                }
            }
            else
            {
                hres = E_FAIL;
            }
        }
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }
    
    return hres;
}

#ifdef DEBUG
BOOL CGenericServiceManager::_SetServiceStatus(SERVICEENTRY* pse)
{
    WCHAR sz[256];

    lstrcpy(sz, pse->_szServiceName);

    switch (pse->_servicestatus.dwCurrentState)
    {
        case SERVICE_STOPPED:
            lstrcat(sz, TEXT(": SERVICE_STOPPED"));
            break;
        case SERVICE_START_PENDING:
            lstrcat(sz, TEXT(": SERVICE_START_PENDING"));
            break;
        case SERVICE_STOP_PENDING:
            lstrcat(sz, TEXT(": SERVICE_STOP_PENDING"));
            break;
        case SERVICE_RUNNING:
            lstrcat(sz, TEXT(": SERVICE_RUNNING"));
            break;
        case SERVICE_CONTINUE_PENDING:
            lstrcat(sz, TEXT(": SERVICE_CONTINUE_PENDING"));
            break;
        case SERVICE_PAUSE_PENDING:
            lstrcat(sz, TEXT(": SERVICE_PAUSE_PENDING"));
            break;
        case SERVICE_PAUSED:
            lstrcat(sz, TEXT(": SERVICE_PAUSED"));
            break;
        default:
            lstrcat(sz, TEXT(": Unknown state"));
            break;
    }

    TRACE(TF_SERVICE, sz);

    return TRUE;
}
#else
BOOL CGenericServiceManager::_SetServiceStatus(SERVICEENTRY*)
{
    return TRUE;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// Wnd stuff
LRESULT _FakeWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = 0;
    BOOL fProcessed = FALSE;

    switch (uMsg)
    {
        case WM_DEVICECHANGE:
        {
            fProcessed = TRUE;

            lRes = CGenericServiceManager::_ServiceHandler(
                SERVICE_CONTROL_DEVICEEVENT, (DWORD)wParam, (PVOID)lParam,
                (PVOID)g_pseWantsDeviceEvents);

            if ((NO_ERROR != lRes) && (TRUE != lRes))
            {
                ASSERT(FALSE);
            }

            break;
        }
        case WM_DESTROY:

            // Should cleanup here

            fProcessed = FALSE;

            break;

        default:

            fProcessed = FALSE;
            break;

    }

    if (!fProcessed)
    {
        lRes = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shsrvice\main.cpp ===
#include "shsrvice.h"

#include "dbg.h"
#include "tfids.h"

#pragma warning(push)
// FALSE positive below: gss
#pragma warning(disable : 4101)

// for now
static SECURITY_ATTRIBUTES     _sa = {0};
static ACL*                    _pacl = NULL;
static SID*                    _psidLocalUsers = NULL;
static SECURITY_DESCRIPTOR*    _psd = NULL;

HRESULT _InitSecurityDescriptor();
// for now

#ifdef UNICODE
extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
#else
int __cdecl main(int argc, char* argv[])
#endif
{
    TRACE(TF_SERVICE, TEXT("Entered main"));

    HRESULT hres = E_INVALIDARG;

#ifdef DEBUG
    CGenericServiceManager::_fRunAsService = FALSE;
#endif

    if (argc > 1)
    {
        hres = CGenericServiceManager::Init();

        if (!lstrcmpi(argv[1], TEXT("-i")) ||
            !lstrcmpi(argv[1], TEXT("/i")))
        {
            TRACE(TF_SERVICE, TEXT("Installing"));
            hres = CGenericServiceManager::Install();

            if (SUCCEEDED(hres))
            {
                TRACE(TF_SERVICE, TEXT("Install SUCCEEDED"));
            }
            else
            {
                TRACE(TF_SERVICE, TEXT("Install FAILED"));
            }
        }
        else
        {
            if (!lstrcmpi(argv[1], TEXT("-u")) ||
                !lstrcmpi(argv[1], TEXT("/u")))
            {
                TRACE(TF_SERVICE, TEXT("UnInstalling"));
                hres = CGenericServiceManager::UnInstall();

                if (SUCCEEDED(hres))
                {
                    TRACE(TF_SERVICE, TEXT("UnInstall SUCCEEDED"));
                }
                else
                {
                    TRACE(TF_SERVICE, TEXT("UnInstall FAILED"));
                }
            }
            else
            {
                hres = E_INVALIDARG;
            }
        }

        CGenericServiceManager::Cleanup();
    }
    else
    {
        hres = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

        if (SUCCEEDED(hres))
        {
//            hres = _InitSecurityDescriptor();

            if (SUCCEEDED(hres))
            {
                hres = CoInitializeSecurity(_psd, -1, NULL, NULL,
                    RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                    EOAC_NONE, NULL);

                if (SUCCEEDED(hres))
                {
                    // need to be here at most 2 seconds after being launched
                    hres = CGenericServiceManager::StartServiceCtrlDispatcher();
                }
                else
                {
                    TRACE(TF_SERVICE, TEXT("CoInitializeSecurity failed: 0x%08X"), hres);
                }
            }

            CoUninitialize();
        }
    }

    return hres;
}
#ifdef UNICODE
}
#endif
#pragma warning(pop)

HRESULT _InitSecurityDescriptor()
{
    HRESULT hres;

    if (_pacl)
    {
        hres = S_OK;
    }
    else
    {
        hres = E_FAIL;
//      This is for "Everyone":
//
//        SID_IDENTIFIER_AUTHORITY sidAuthNT = SECURITY_WORLD_SID_AUTHORITY;
//
//        if (AllocateAndInitializeSid(&sidAuthNT, 1, SECURITY_WORLD_RID,
//            0, 0, 0, 0, 0, 0, 0, (void**)&_psidLocalUsers))

        // This is for local entities only
        SID_IDENTIFIER_AUTHORITY sidAuthNT = SECURITY_NT_AUTHORITY;

        if (AllocateAndInitializeSid(&sidAuthNT, 1, SECURITY_INTERACTIVE_RID,
            0, 0, 0, 0, 0, 0, 0, (void**)&_psidLocalUsers))
        {
            DWORD cbacl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) -
                sizeof(DWORD/*ACCESS_ALLOWED_ACE.SidStart*/) +
                GetLengthSid(_psidLocalUsers);

            _pacl = (ACL*)LocalAlloc(LPTR, cbacl);

            if (_pacl)
            {
                if (InitializeAcl(_pacl, cbacl, ACL_REVISION))
                {
                    if (AddAccessAllowedAce(_pacl, ACL_REVISION, FILE_ALL_ACCESS,
                        _psidLocalUsers))
                    {
                        _psd = (SECURITY_DESCRIPTOR*)LocalAlloc(LPTR,
                            sizeof(SECURITY_DESCRIPTOR));

                        if (_psd)
                        {
                            if (InitializeSecurityDescriptor(_psd,
                                SECURITY_DESCRIPTOR_REVISION))
                            {
                                if (SetSecurityDescriptorDacl(_psd, TRUE,
                                    _pacl, FALSE))
                                {
                                    if (IsValidSecurityDescriptor(_psd))
                                    {
                                        _sa.nLength = sizeof(_sa);
                                        _sa.lpSecurityDescriptor = _psd;
                                        _sa.bInheritHandle = TRUE;

                                        hres = S_OK;
                                    }
                                }
                            }
                        }
                        else
                        {
                            hres = E_OUTOFMEMORY;
                        }
                    }
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }    

        if (FAILED(hres))
        {
            if (_psidLocalUsers)
            {
                FreeSid(_psidLocalUsers);
            }

            if (_pacl)
            {
                LocalFree((HLOCAL)_pacl);
            }

            if (_psd)
            {
                LocalFree((HLOCAL)_psd);
            }
        }
    }
  
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shsrvice\service.cpp ===
#include "shsrvice.h"

#include "mischlpr.h"

#include "dbg.h"
#include "tfids.h"

//static
HRESULT CGenericServiceManager::_RegisterServiceCtrlHandler(
    LPCWSTR pszServiceName, SERVICEENTRY* pse)
{
    ASSERT(pse);
    HRESULT hres = E_FAIL;
    TRACE(TF_SERVICE, TEXT("Entered _RegisterServiceCtrlHandler"));

    pse->_ssh = RegisterServiceCtrlHandlerExW(pszServiceName,
        _ServiceHandler, pse);

    if (pse->_ssh)
    {
#ifdef DEBUG
        lstrcpy(pse->_szServiceName, pszServiceName);
#endif        
        hres = S_OK;
    }
    else
    {
        // convert GetLastError to some HRESULT
    }

    return hres;
}

// static
HRESULT CGenericServiceManager::StartServiceCtrlDispatcher()
{
    HRESULT hres = E_FAIL;
    
    TRACE(TF_SERVICE, TEXT("Entered StartServiceCtrlDispatcher"));

    if (::StartServiceCtrlDispatcher(_rgste))
    {
        hres = S_OK;
    }
    
    return hres;
}

BOOL CGenericServiceManager::_SetServiceStatus(SERVICEENTRY* pse)
{
#ifdef DEBUG
    WCHAR sz[256];

    lstrcpy(sz, pse->_szServiceName);

    switch (pse->_servicestatus.dwCurrentState)
    {
        case SERVICE_STOPPED:
            lstrcat(sz, TEXT(": SERVICE_STOPPED"));
            break;
        case SERVICE_START_PENDING:
            lstrcat(sz, TEXT(": SERVICE_START_PENDING"));
            break;
        case SERVICE_STOP_PENDING:
            lstrcat(sz, TEXT(": SERVICE_STOP_PENDING"));
            break;
        case SERVICE_RUNNING:
            lstrcat(sz, TEXT(": SERVICE_RUNNING"));
            break;
        case SERVICE_CONTINUE_PENDING:
            lstrcat(sz, TEXT(": SERVICE_CONTINUE_PENDING"));
            break;
        case SERVICE_PAUSE_PENDING:
            lstrcat(sz, TEXT(": SERVICE_PAUSE_PENDING"));
            break;
        case SERVICE_PAUSED:
            lstrcat(sz, TEXT(": SERVICE_PAUSED"));
            break;
        default:
            lstrcat(sz, TEXT(": Unknown state"));
            break;
    }

    TRACE(TF_SERVICE, sz);
#endif

    BOOL b = SetServiceStatus(pse->_ssh, &(pse->_servicestatus));

#ifdef DEBUG
    if (!b)
    {
        TRACE(TF_SERVICE, TEXT("SetServiceStatus FAILED: GLE = 0x%08X"), GetLastError());
    }
#endif

    return b;
}

// static
HRESULT CGenericServiceManager::_HandleWantsDeviceEvents(
    LPCWSTR UNREF_PARAM(pszServiceName), BOOL fWantsDeviceEvents)
{
    if (fWantsDeviceEvents)
    {
        TRACE(TF_SERVICE, TEXT("Wants Device Events"));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\shsrvice\shtrig.cpp ===
#include <objbase.h>

#include "dbg.h"
#include <tchar.h>
#include <stdio.h>

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#ifdef UNICODE
extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
#else
int __cdecl main(int argc, char* argv[])
#endif
{
    if (argc > 1)
    {
        HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, argv[1]);

        if (hEvent)
        {
            PulseEvent(hEvent);

            CloseHandle(hEvent);
        }
        else
        {
            _tprintf(TEXT("FAILED"));
        }
    }

    return 0;
}
#ifdef UNICODE
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\cddiag\main.cpp ===
#include <objbase.h>

#include <stdio.h>
#include <shpriv.h>

#pragma warning(disable: 4201)
#include <winioctl.h>

#pragma warning(disable: 4200)
#include <ntddcdvd.h>

#include <ntddmmc.h>
#include <ntddcdrm.h>

#include "mischlpr.h"

#include "sfstr.h"

#include "unk.h"
#include "fact.h"

// {DD522ACC-F821-461a-A407-50B198B896DC}
/*extern const CLSID CLSID_HardwareDevices =
    {0xdd522acc, 0xf821, 0x461a,
    {0xa4, 0x7, 0x50, 0xb1, 0x98, 0xb8, 0x96, 0xdc}};

extern const IID IID_IHardwareDevices = 
{0x77CDD897, 0xF595, 0x4897,
{0xA9, 0x14, 0x6E, 0x91, 0x77, 0x1C, 0xC3, 0x30}};*/

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

struct CDDEVINFO
{
    BOOL fMMC2; // icon, label, say for sure what type
    DWORD dwDriveType;
    DWORD dwMediaType;
    BOOL fHasMedia;
    BOOL fMediaFormatted;
    BOOL fHasAudioTracks;
    BOOL fHasData;
    BOOL fHasAutorunINF;
    BOOL fHasDesktopINI;
    BOOL fHasDVDMovie; // autorun.inf takes precedence

    WCHAR szFileSystem[100];
    WCHAR szVolGUID[50];
    WCHAR szVolDeviceID[200];
};

static CDDEVINFO cddevinfo[100] = {0};
static DWORD ccddevinfo = 0;

struct _sFLAG_DESCR
{
    DWORD   dwFlag;
    LPTSTR  pszDescr;
    LPTSTR  pszComment;
};

#define FLAG_DESCR(a) { (DWORD)a, TEXT(#a), NULL }

int _PrintFlag(DWORD dwFlag, _sFLAG_DESCR rgflag[], DWORD cflag,
    DWORD /*cchIndent*/, BOOL fPrintValue, BOOL fHex, BOOL fComment, BOOL fORed)
{
    int i = 0;
    BOOL fAtLeastOne = FALSE;

    for (DWORD dw = 0; dw < cflag; ++dw)
    {
        BOOL fPrint = FALSE;

        if (fORed)
        {
            if (rgflag[dw].dwFlag & dwFlag)
            {
                fPrint = TRUE;
            }
        }
        else
        {
            if (rgflag[dw].dwFlag == dwFlag)
            {
                fPrint = TRUE;
            }
        }

        if (fPrint)
        {
            if (fAtLeastOne)
            {
                i += wprintf(TEXT("\n"));
            }

            if (fPrintValue)
            {
                if (fHex)
                {
                    i += wprintf(TEXT("0x%08X, "), rgflag[dw].dwFlag);
                }
                else
                {
                    i += wprintf(TEXT("%u, "), rgflag[dw].dwFlag);
                }
            }

            i += wprintf(TEXT("%s"), rgflag[dw].pszDescr);

            if (fComment)
            {
                i += wprintf(TEXT(", '%s'"), rgflag[dw].pszComment);
            }

            fAtLeastOne = TRUE;
        }
    }

    return i;
}

_sFLAG_DESCR _featurenumberFD[] =
{
    FLAG_DESCR(FeatureProfileList),
    FLAG_DESCR(FeatureCore),
    FLAG_DESCR(FeatureMorphing),
    FLAG_DESCR(FeatureRemovableMedium),
    FLAG_DESCR(FeatureRandomReadable),
    FLAG_DESCR(FeatureMultiRead),
    FLAG_DESCR(FeatureCdRead),
    FLAG_DESCR(FeatureDvdRead),
    FLAG_DESCR(FeatureRandomWritable),
    FLAG_DESCR(FeatureIncrementalStreamingWritable),
    FLAG_DESCR(FeatureSectorErasable),
    FLAG_DESCR(FeatureFormattable),
    FLAG_DESCR(FeatureDefectManagement),
    FLAG_DESCR(FeatureWriteOnce),
    FLAG_DESCR(FeatureRestrictedOverwrite),
    FLAG_DESCR(FeatureWriteProtect),
    FLAG_DESCR(FeatureCdrwCAVWrite),
    FLAG_DESCR(FeatureRigidRestrictedOverwrite),
    FLAG_DESCR(FeatureCdTrackAtOnce),
    FLAG_DESCR(FeatureCdMastering),
    FLAG_DESCR(FeatureDvdRecordableWrite),
    FLAG_DESCR(FeaturePowerManagement),
    FLAG_DESCR(FeatureSMART),
    FLAG_DESCR(FeatureEmbeddedChanger),
    FLAG_DESCR(FeatureCDAudioAnalogPlay),
    FLAG_DESCR(FeatureMicrocodeUpgrade),
    FLAG_DESCR(FeatureTimeout),
    FLAG_DESCR(FeatureDvdCSS),
    FLAG_DESCR(FeatureRealTimeStreaming),
    FLAG_DESCR(FeatureLogicalUnitSerialNumber),
    FLAG_DESCR(FeatureDiscControlBlocks),
    FLAG_DESCR(FeatureDvdCPRM),
};

HRESULT ProcessMMC2Features(CDDEVINFO* pcddevinfo)
{
    HANDLE hDevice = CreateFile(pcddevinfo->szVolDeviceID, GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

    if (INVALID_HANDLE_VALUE != hDevice)
    {
        DWORD cbReturned;

        GET_CONFIGURATION_IOCTL_INPUT input;
        DWORD cbHeader = sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_HEADER);
        GET_CONFIGURATION_HEADER* pheader = (GET_CONFIGURATION_HEADER*)LocalAlloc(LPTR, 
            cbHeader);

        if (pheader)
        {
            FEATURE_HEADER* pfh;

            input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;
            input.Reserved[0] = NULL;
            input.Reserved[1] = NULL;

            for (DWORD dw = 0; dw < ARRAYSIZE(_featurenumberFD); ++dw)
            {
                input.Feature = (FEATURE_NUMBER)(_featurenumberFD[dw].dwFlag);

                BOOL f = DeviceIoControl(hDevice,
                                     IOCTL_CDROM_GET_CONFIGURATION,
                                     &input,
                                     sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                                     pheader,
                                     cbHeader,             
                                     &cbReturned,
                                     NULL);


                pfh = (FEATURE_HEADER*)(pheader->Data);

                if (f)
                {
                    WORD w = (pfh->FeatureCode[0]) << 8 | (pfh->FeatureCode[1]);

                    if (w == (WORD)(_featurenumberFD[dw].dwFlag))
                    {
                        wprintf(TEXT("      "));

                        if (pfh->Current)
                        {
                            wprintf(TEXT("* "));
                        }
                        else
                        {
                            wprintf(TEXT("  "));
                        }

                        _PrintFlag(_featurenumberFD[dw].dwFlag, _featurenumberFD, ARRAYSIZE(_featurenumberFD),
                            0, FALSE, FALSE, FALSE, FALSE);

                        wprintf(TEXT("\n"));
                    }
                }
            }
        }

        CloseHandle(hDevice);
    }

    return S_OK;
}

HRESULT ProcessCDInfo(LPCWSTR pszMountPoint, CDDEVINFO* pcddevinfo, BOOL fMMC2Features)
{
    wprintf(TEXT("\n--------------------------------------------------------\n"));
    wprintf(TEXT("  %s\n\n"), pszMountPoint);

    if (pcddevinfo->fMMC2)
    {
        wprintf(TEXT("  (1) Drive is MMC2 compliant.  It should have an icon and label\n"));
        wprintf(TEXT("      that reflects its capabilites in My Computer when it\n"));
        wprintf(TEXT("      contains no media.\n"));

        wprintf(TEXT("    (1.1) Drive capabilities are:\n"));

        if (pcddevinfo->dwDriveType & HWDDC_CDROM)
        {
            wprintf(TEXT("          CD-ROM\n"));
        }

        if (pcddevinfo->dwDriveType & HWDDC_CDRECORDABLE)
        {
            wprintf(TEXT("          CD-R\n"));
        }

        if (pcddevinfo->dwDriveType & HWDDC_CDREWRITABLE)
        {
            wprintf(TEXT("          CD-RW\n"));
        }

        if (pcddevinfo->dwDriveType & HWDDC_DVDROM)
        {
            wprintf(TEXT("          DVD-ROM\n"));
        }

        if (pcddevinfo->dwDriveType & HWDDC_DVDRECORDABLE)
        {
            wprintf(TEXT("          DVD-R\n"));
        }

        if (pcddevinfo->dwDriveType & HWDDC_DVDREWRITABLE)
        {
            wprintf(TEXT("          DVD-RW\n"));
        }

        if (pcddevinfo->dwDriveType & HWDDC_DVDRAM)
        {
            wprintf(TEXT("          DVD-RAM\n"));
        }
    }
    else
    {
        wprintf(TEXT("  (1) Drive is *NOT* MMC2 compliant.  It cannot have an icon and label\n"));
        wprintf(TEXT("      that reflects its capabilites in My Computer when it contains no media.\n"));
        wprintf(TEXT("      It only has a CD icon and label.  We cannot say for sure what are its\n"));
        wprintf(TEXT("      capabilities either (CD-RW, DVD, ...).  MMC2 compliance is required\n"));
        wprintf(TEXT("      for the Windows Logo.\n"));
    }

    if (pcddevinfo->fHasMedia)
    {
        wprintf(TEXT("  (2) Drive contains a media.\n"));

        if (pcddevinfo->fMMC2)
        {
            wprintf(TEXT("    (2.1) Media capabilities are:\n"));

            if (pcddevinfo->dwMediaType & HWDMC_CDROM)
            {
                wprintf(TEXT("          CD-ROM\n"));
            }

            if (pcddevinfo->dwMediaType & HWDMC_CDRECORDABLE)
            {
                wprintf(TEXT("          CD-R\n"));
            }

            if (pcddevinfo->dwMediaType & HWDMC_CDREWRITABLE)
            {
                wprintf(TEXT("          CD-RW\n"));
            }

            if (pcddevinfo->dwMediaType & HWDMC_DVDROM)
            {
                wprintf(TEXT("          DVD-ROM\n"));
            }

            if (pcddevinfo->dwMediaType & HWDMC_DVDRECORDABLE)
            {
                wprintf(TEXT("          DVD-R\n"));
            }

            if (pcddevinfo->dwMediaType & HWDMC_DVDREWRITABLE)
            {
                wprintf(TEXT("          DVD-RW\n"));
            }

            if (pcddevinfo->dwMediaType & HWDMC_DVDRAM)
            {
                wprintf(TEXT("          DVD-RAM\n"));
            }
        }

        if (pcddevinfo->fMediaFormatted)
        {
            wprintf(TEXT("  (3) The media is formatted (non-blank).\n"));

            wprintf(TEXT("    (3.1) The file-system is: '%s'.\n"), pcddevinfo->szFileSystem);
        }
        else
        {
            wprintf(TEXT("  (3) The media is *NOT* formatted (blank).\n"));
        }
    }
    else
    {
        wprintf(TEXT("  (2) Drive does *NOT* contain media.\n"));
    }

    if (pcddevinfo->fHasAudioTracks)
    {
        wprintf(TEXT("  (4) The media has Audio Tracks (not same as MP3s).\n"));

        if (pcddevinfo->fHasAutorunINF)
        {
            wprintf(TEXT("    (4.1) But it also contains an Autorun.inf which\n"));
            wprintf(TEXT("          should take precedence when Autoplay'ing.\n"));
        }
    }

    if (pcddevinfo->fHasData)
    {
        wprintf(TEXT("  (5) The media contains data files/executables.\n"));
    }

    if (pcddevinfo->fHasAutorunINF)
    {
        wprintf(TEXT("  (6) The media contains an Autorun.inf file in its root.\n"));
    }
    else
    {
        if (pcddevinfo->fHasMedia)
        {
            wprintf(TEXT("  (6) The media does *NOT* contain an Autorun.inf file.\n"));
        }
    }

    if (pcddevinfo->fHasDesktopINI)
    {
        wprintf(TEXT("  (7) The media contains an Desktop.ini file in its root.\n"));
    }

    if (pcddevinfo->fHasDVDMovie)
    {
        wprintf(TEXT("  (8) The media contains a DVD Movie.\n"));

        if (pcddevinfo->fHasAutorunINF)
        {
            wprintf(TEXT("    (8.1) But it also contains an Autorun.inf which\n"));
            wprintf(TEXT("          should take precedence when Autoplay'ing.\n"));
        }
    }

    if (fMMC2Features)
    {
        if (pcddevinfo->fMMC2)
        {
            wprintf(TEXT("  (9) Drive is MMC2 compliant, supported features (* = current):\n"));
            ProcessMMC2Features(pcddevinfo);
        }
        else
        {
            wprintf(TEXT("  (9) Drive is not MMC2 compliant, ignored /f flag.\n"));
        }
    }

    return S_OK;
}

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    BOOL fDoIt = FALSE;
    BOOL fDoHelp = TRUE;
    BOOL fMMC2Features = FALSE;

    if (argc > 1)
    {
        if (!lstrcmpi(argv[1], TEXT("/?")) ||
            !lstrcmpi(argv[1], TEXT("-?")))
        {
        }
        else
        {
            if (!lstrcmpi(argv[1], TEXT("/f")) ||
                !lstrcmpi(argv[1], TEXT("-f")))
            {
                fDoIt = TRUE;
                fMMC2Features = TRUE;
                fDoHelp = FALSE;
            }
        }
    }
    else
    {
        fDoIt = TRUE;
    }

    if (fDoIt)
    {
        HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

        if (SUCCEEDED(hr))
        {
            IHardwareDevices* pihwdevs = NULL;

            hr = CoCreateInstance(CLSID_HardwareDevices, NULL,
                CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IHardwareDevices, &pihwdevs));

            if (SUCCEEDED(hr))
            {
                {
                    IHardwareDevicesVolumesEnum* penum;

                    hr = pihwdevs->EnumVolumes(HWDEV_GETCUSTOMPROPERTIES, &penum);

                    if (SUCCEEDED(hr))
                    {
                        VOLUMEINFO volinfo = {0};

                        while (SUCCEEDED(hr = penum->Next(&volinfo)) && (S_FALSE != hr))
                        {
                            if (HWDTS_CDROM == volinfo.dwDriveType)
                            {
                                cddevinfo[ccddevinfo].fMMC2 = (volinfo.dwDriveCapability & HWDDC_CAPABILITY_SUPPORTDETECTION);
                                cddevinfo[ccddevinfo].fHasMedia = (volinfo.dwMediaState & HWDMS_PRESENT);
                                cddevinfo[ccddevinfo].fMediaFormatted = (volinfo.dwMediaState & HWDMS_FORMATTED);
                                cddevinfo[ccddevinfo].fHasAudioTracks = (volinfo.dwMediaCap & HWDMC_HASAUDIOTRACKS);
                                cddevinfo[ccddevinfo].fHasData = (volinfo.dwMediaCap & HWDMC_HASDATATRACKS);
                                cddevinfo[ccddevinfo].fHasAutorunINF = (volinfo.dwMediaCap & HWDMC_HASAUTORUNINF);
                                cddevinfo[ccddevinfo].fHasDesktopINI = (volinfo.dwMediaCap & HWDMC_HASDESKTOPINI);
                                cddevinfo[ccddevinfo].fHasDVDMovie = (volinfo.dwMediaCap & HWDMC_HASDVDMOVIE);
                                cddevinfo[ccddevinfo].dwMediaType = (volinfo.dwMediaCap & HWDMC_CDTYPEMASK);
                                cddevinfo[ccddevinfo].dwDriveType = (volinfo.dwDriveCapability & HWDDC_CDTYPEMASK);

                                hr = SafeStrCpyN(cddevinfo[ccddevinfo].szFileSystem, volinfo.pszFileSystem, ARRAYSIZE(cddevinfo[ccddevinfo].szFileSystem));

                                if (FAILED(hr))
                                {
                                    SafeStrCpyN(cddevinfo[ccddevinfo].szFileSystem, TEXT("ERROR"), ARRAYSIZE(cddevinfo[ccddevinfo].szFileSystem));
                                }

                                hr = SafeStrCpyN(cddevinfo[ccddevinfo].szVolGUID, volinfo.pszVolumeGUID, ARRAYSIZE(cddevinfo[ccddevinfo].szVolGUID));

                                if (FAILED(hr))
                                {
                                    SafeStrCpyN(cddevinfo[ccddevinfo].szVolGUID, TEXT("ERROR"), ARRAYSIZE(cddevinfo[ccddevinfo].szVolGUID));
                                }

                                hr = SafeStrCpyN(cddevinfo[ccddevinfo].szVolDeviceID, volinfo.pszDeviceIDVolume, ARRAYSIZE(cddevinfo[ccddevinfo].szVolDeviceID));

                                if (FAILED(hr))
                                {
                                    SafeStrCpyN(cddevinfo[ccddevinfo].szVolDeviceID, TEXT("ERROR"), ARRAYSIZE(cddevinfo[ccddevinfo].szVolDeviceID));
                                }

                                ++ccddevinfo;
                            }
                        }

                        penum->Release();
                    }
                }

                if (ccddevinfo)
                {
                    if (1 == ccddevinfo)
                    {
                        wprintf(TEXT("\n  Found 1 CD Drive\n"));
                    }
                    else
                    {
                        wprintf(TEXT("\n  Found %d CD Drives\n"), ccddevinfo);
                    }
                }
                else
                {
                    wprintf(TEXT("\n  Did not find any CD Drive.  If there is a CD drive then\n"));
                    wprintf(TEXT("  you found a bug in the Shell Service.\n"));
                }

                {
                    IHardwareDevicesMountPointsEnum* penum;

                    hr = pihwdevs->EnumMountPoints(&penum);

                    if (SUCCEEDED(hr))
                    {
                        LPWSTR pszMountPoint;
                        LPWSTR pszDeviceIDVolume;

                        while (SUCCEEDED(hr = penum->Next(
                            &pszMountPoint, &pszDeviceIDVolume)) &&
                            (S_FALSE != hr))
                        {
                            for (DWORD dw = 0; dw < ccddevinfo; ++dw)
                            {
                                if (!lstrcmpi(pszDeviceIDVolume, cddevinfo[dw].szVolDeviceID))
                                {
                                    ProcessCDInfo(pszMountPoint, &cddevinfo[dw], fMMC2Features);
                                }
                            }
                        }

                        penum->Release();
                    }
                }
            }

            if (ccddevinfo)
            {
                wprintf(TEXT("\n  If any of the above is false, you found a bug in the Shell Service.\n"));

                if (fMMC2Features)
                {
                    wprintf(TEXT("  However, if the MMC2 feature information is false, there is\n"));
                    wprintf(TEXT("  probably a problem with the drive.\n"));
                }
            }

            CoUninitialize();
        }
    }
    else
    {
        if (fDoHelp)
        {
            wprintf(TEXT("\nBasic diagnostic of CD/DVD drives\n"));
            wprintf(TEXT("\nCDDIAG.EXE [/f]\n\n"));

            wprintf(TEXT("  /f         Displays the MMC2 feature supported by the drive.\n\n"));
        }
    }

    return 0;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_devenum\hwdevcbu.cpp ===
#include "hwdevcb.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY chwdevcbtestIME[] =
{
    _INTFMAPENTRY(CHWDevCBTest, IHardwareDeviceCallback),
};

const INTFMAPENTRY* CHWDevCBTest::_pintfmap = chwdevcbtestIME;
const DWORD CHWDevCBTest::_cintfmap =
    (sizeof(chwdevcbtestIME)/sizeof(chwdevcbtestIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CHWDevCBTest::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_devenum\hwdevcb.h ===
///////////////////////////////////////////////////////////////////////////////
// Test component to print event to command prompt
///////////////////////////////////////////////////////////////////////////////
#ifndef _HWDEVCB_H
#define _HWDEVCB_H

#include "unk.h"
#include "shpriv.h"

extern "C" const CLSID CLSID_HWDevCBTest;

class CHWDevCBTestImpl : public CCOMBase, public IHardwareDeviceCallback
{
public:
    // Interface IHardwareDeviceCallback
    STDMETHODIMP VolumeAddedOrUpdated(
        BOOL fAdded,
        VOLUMEINFO* pvolinfo);

    STDMETHODIMP VolumeRemoved(LPCWSTR pszVolume);

    STDMETHODIMP MountPointAdded(
        LPCWSTR pszMountPoint,     // eg: "c:\", or "d:\MountFolder\"
        LPCWSTR pszDeviceIDVolume);// eg: \\?\STORAGE#Volume#...{...GUID...}

    STDMETHODIMP MountPointRemoved(LPCWSTR pszMountPoint);

    STDMETHODIMP DeviceAdded(LPCWSTR pszDeviceID, GUID guidDeviceID);

    STDMETHODIMP DeviceUpdated(LPCWSTR pszDeviceID);

    // Both for devices and volumes
    STDMETHODIMP DeviceRemoved(LPCWSTR pszDeviceID);

#if 0
    // Interface IMoniker
    STDMETHODIMP BindToObject( 
        /* [unique][in] */ IBindCtx *pbc,
        /* [unique][in] */ IMoniker *pmkToLeft,
        /* [in] */ REFIID riidResult,
        /* [iid_is][out] */ void **ppvResult);
    
    STDMETHODIMP STDMETHODCALLTYPE BindToStorage( 
        /* [unique][in] */ IBindCtx *pbc,
        /* [unique][in] */ IMoniker *pmkToLeft,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObj);
    
    STDMETHODIMP Reduce( 
        /* [unique][in] */ IBindCtx *pbc,
        /* [in] */ DWORD dwReduceHowFar,
        /* [unique][out][in] */ IMoniker **ppmkToLeft,
        /* [out] */ IMoniker **ppmkReduced);
    
    STDMETHODIMP ComposeWith( 
        /* [unique][in] */ IMoniker *pmkRight,
        /* [in] */ BOOL fOnlyIfNotGeneric,
        /* [out] */ IMoniker **ppmkComposite);
    
    STDMETHODIMP Enum( 
        /* [in] */ BOOL fForward,
        /* [out] */ IEnumMoniker **ppenumMoniker);
    
    STDMETHODIMP IsEqual( 
        /* [unique][in] */ IMoniker *pmkOtherMoniker);
    
    STDMETHODIMP Hash( 
        /* [out] */ DWORD *pdwHash);
    
    STDMETHODIMP IsRunning( 
        /* [unique][in] */ IBindCtx *pbc,
        /* [unique][in] */ IMoniker *pmkToLeft,
        /* [unique][in] */ IMoniker *pmkNewlyRunning);
    
    STDMETHODIMP GetTimeOfLastChange( 
        /* [unique][in] */ IBindCtx *pbc,
        /* [unique][in] */ IMoniker *pmkToLeft,
        /* [out] */ FILETIME *pFileTime);
    
    STDMETHODIMP Inverse( 
        /* [out] */ IMoniker **ppmk);
    
    STDMETHODIMP CommonPrefixWith( 
        /* [unique][in] */ IMoniker *pmkOther,
        /* [out] */ IMoniker **ppmkPrefix);
    
    STDMETHODIMP RelativePathTo( 
        /* [unique][in] */ IMoniker *pmkOther,
        /* [out] */ IMoniker **ppmkRelPath);
    
    STDMETHODIMP GetDisplayName( 
        /* [unique][in] */ IBindCtx *pbc,
        /* [unique][in] */ IMoniker *pmkToLeft,
        /* [out] */ LPOLESTR *ppszDisplayName);
    
    STDMETHODIMP ParseDisplayName( 
        /* [unique][in] */ IBindCtx *pbc,
        /* [unique][in] */ IMoniker *pmkToLeft,
        /* [in] */ LPOLESTR pszDisplayName,
        /* [out] */ ULONG *pchEaten,
        /* [out] */ IMoniker **ppmkOut);
    
    STDMETHODIMP IsSystemMoniker( 
        /* [out] */ DWORD *pdwMksys);

#endif
};

typedef CUnkTmpl<CHWDevCBTestImpl> CHWDevCBTest;

#endif // _HWDEVCB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_apsettings\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <io.h>
#include <objbase.h>

#include "shpriv.h"

#ifndef UNICODE
#error This has to be UNICODE
#endif

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

int DoTest(int argc, wchar_t* argv[]);

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    return DoTest(argc, argv);
}
}

HRESULT _GetHWDevice(IHWDevice** ppihwdevice)
{
    // {AAC41048-53E3-4867-A0AA-5FBCEAE7E5F5}
    const CLSID CLSID_HWDevice =
        {0xaac41048, 0x53e3, 0x4867,
        {0xa0, 0xaa, 0x5f, 0xbc, 0xea, 0xe7, 0xe5, 0xf5}};

    const CLSID IID_IHWDevice =
        {0x00D7DA0C, 0xC968, 0x4331,
        {0x9F, 0x00, 0x62, 0x49, 0x17, 0x3D, 0x2E, 0x37}};

    return CoCreateInstance(CLSID_HWDevice, NULL,
            CLSCTX_LOCAL_SERVER, IID_IHWDevice, (void**)ppihwdevice);
}

int DoTest(int argc, wchar_t* argv[])
{
    HRESULT hres = E_FAIL;

    if (2 == argc)
    {
        hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	    if (SUCCEEDED(hres))
        {
            IHWDevice* phwd = NULL;

            hres = _GetHWDevice(&phwd);

            if (SUCCEEDED(hres))
            {
                LPWSTR pszBrandedName;

                hres = phwd->GetDeviceString(argv[1],
                    DEVSTR_STRICTBRANDEDNAME,
                    &pszBrandedName);

                if (SUCCEEDED(hres) && (S_FALSE != hres))
                {
                    wprintf(TEXT("Brand name for '%s': '%s'"), argv[1],
                        pszBrandedName);

                    CoTaskMemFree(pszBrandedName);
                }
                else
                {
                    wprintf(TEXT("GetDeviceString failed: 0x%08X"), hres);
                }

                phwd->Release();
            }
            else
            {
                wprintf(TEXT("_GetHWDevice failed: 0x%08X"), hres);
            }

	        CoUninitialize();
        }
        else
        {
            wprintf(TEXT("CoInitializeEx failed: 0x%08X"), hres);
        }
    }
    else
    {
        wprintf(TEXT("Wrong usage"));
    }

    return !SUCCEEDED(hres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_devenum\hwdevcb.cpp ===
#include "hwdevcb.h"

#include <stdio.h>

#include <shpriv.h> // for IStorageInfo

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// {AA2ED7B9-2D5F-43e7-A832-6C9151BB0E39}
extern "C" const CLSID CLSID_HWDevCBTest =
{0xaa2ed7b9, 0x2d5f, 0x43e7,
{0xa8, 0x32, 0x6c, 0x91, 0x51, 0xbb, 0xe, 0x39}};

#define NOT_USED(a) 

void PrintVolumeAddedOrUpdatedHelper(VOLUMEINFO* pvolinfo);

STDMETHODIMP CHWDevCBTestImpl::VolumeAddedOrUpdated(
        BOOL fAdded,
        VOLUMEINFO* pvolinfo)
{
    wprintf(L"\n----VolumeAddedOrUpdated------~0x%08X~\n", GetCurrentThreadId());
    if (fAdded)
    {
        wprintf(L"    ADDED'\n");    
    }
    else
    {
        wprintf(L"    UPDATED'\n");    
    }

    PrintVolumeAddedOrUpdatedHelper(pvolinfo);

    return S_OK;
}

STDMETHODIMP CHWDevCBTestImpl::VolumeRemoved(LPCWSTR pszVolume)
{
    wprintf(L"\n----VolumeRemoved------~0x%08X~\n", GetCurrentThreadId());
    wprintf(L"    MtPt: '%s'\n", pszVolume);

    return S_OK;
}

STDMETHODIMP CHWDevCBTestImpl::MountPointAdded(
    LPCWSTR pszMountPoint,     // eg: "c:\", or "d:\MountFolder\"
    LPCWSTR pszDeviceIDVolume)// eg: \\?\STORAGE#Volume#...{...GUID...}
{
    wprintf(L"\n----MountPointAdded------~0x%08X~\n", GetCurrentThreadId());
    wprintf(L"    MtPt: '%s' ->\n    Vol:  '%s'\n",
        pszMountPoint, pszDeviceIDVolume);

    return S_OK;
}

STDMETHODIMP CHWDevCBTestImpl::MountPointRemoved(LPCWSTR pszMountPoint)
{
    wprintf(L"\n----MountPointRemoved------~0x%08X~\n", GetCurrentThreadId());
    wprintf(L"    MtPt: '%s'\n", pszMountPoint);

    return S_OK;
}

STDMETHODIMP CHWDevCBTestImpl::DeviceAdded(LPCWSTR NOT_USED(pszDeviceID),
    GUID NOT_USED(guidDeviceID))
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::DeviceUpdated(LPCWSTR NOT_USED(pszDeviceID))
{
    return E_NOTIMPL;
}

// Both for devices and volumes
STDMETHODIMP CHWDevCBTestImpl::DeviceRemoved(LPCWSTR NOT_USED(pszDeviceID))
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#if 0
STDMETHODIMP CHWDevCBTestImpl::BindToObject( 
    /* [unique][in] */ IBindCtx /**pbc*/,
    /* [unique][in] */ IMoniker /**pmkToLeft*/,
    /* [in] */ REFIID /*riidResult*/,
    /* [iid_is][out] */ void /***ppvResult*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::STDMETHODCALLTYPE BindToStorage( 
    /* [unique][in] */ IBindCtx /**pbc*/,
    /* [unique][in] */ IMoniker /**pmkToLeft*/,
    /* [in] */ REFIID /*riid*/,
    /* [iid_is][out] */ void /***ppvObj*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::Reduce( 
    /* [unique][in] */ IBindCtx /**pbc*/,
    /* [in] */ DWORD /*dwReduceHowFar*/,
    /* [unique][out][in] */ /*IMoniker **ppmkToLeft*/,
    /* [out] */ IMoniker /***ppmkReduced*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::ComposeWith( 
    /* [unique][in] */ IMoniker /**pmkRight*/,
    /* [in] */ BOOL /*fOnlyIfNotGeneric*/,
    /* [out] */ IMoniker /***ppmkComposite*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::Enum( 
    /* [in] */ BOOL /*fForward*/,
    /* [out] */ IEnumMoniker **ppenumMoniker)
{
    *ppenumMoniker = NULL;

    return S_OK;
}

STDMETHODIMP CHWDevCBTestImpl::IsEqual( 
    /* [unique][in] */ IMoniker *pmkOtherMoniker)
{
    LPWSTR pszName;

    HRESULT hr = pmkOtherMoniker->GetDisplayName(NULL, NULL, pszName);

    if (!lstrcmpi(pszName, TEXT("Autoplay.TestEventHandler.td_devenum")))
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

STDMETHODIMP CHWDevCBTestImpl::Hash( 
    /* [out] */ DWORD *pdwHash)
{
    *pdwHash = 26;

    return S_OK;
}

STDMETHODIMP CHWDevCBTestImpl::IsRunning( 
    /* [unique][in] */ IBindCtx /**pbc*/,
    /* [unique][in] */ IMoniker /**pmkToLeft*/,
    /* [unique][in] */ IMoniker /**pmkNewlyRunning*/)
{
    return S_OK;
}

STDMETHODIMP CHWDevCBTestImpl::GetTimeOfLastChange( 
    /* [unique][in] */ IBindCtx /**pbc*/,
    /* [unique][in] */ IMoniker /**pmkToLeft*/,
    /* [out] */ FILETIME /**pFileTime*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::Inverse( 
    /* [out] */ IMoniker /***ppmk*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::CommonPrefixWith( 
    /* [unique][in] */ IMoniker /**pmkOther*/,
    /* [out] */ IMoniker /***ppmkPrefix*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::RelativePathTo( 
    /* [unique][in] */ IMoniker /**pmkOther*/,
    /* [out] */ IMoniker /***ppmkRelPath*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::GetDisplayName( 
    /* [unique][in] */ IBindCtx /**pbc*/,
    /* [unique][in] */ IMoniker /**pmkToLeft*/,
    /* [out] */ LPOLESTR *ppszDisplayName)
{
    *ppszDisplayName = CoTaskMemAlloc(sizeof(TEXT("Autoplay.TestEventHandler.td_devenum")) + 1 * sizeof(WCHAR));

    if (*ppszDisplayName)
    {
        lstrcpy(*ppszDisplayName, TEXT("Autoplay.TestEventHandler.td_devenum"));
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CHWDevCBTestImpl::ParseDisplayName( 
    /* [unique][in] */ IBindCtx /**pbc*/,
    /* [unique][in] */ IMoniker /**pmkToLeft*/,
    /* [in] */ LPOLESTR /*pszDisplayName*/,
    /* [out] */ ULONG /**pchEaten*/,
    /* [out] */ IMoniker /***ppmkOut*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHWDevCBTestImpl::IsSystemMoniker( 
    /* [out] */ DWORD *pdwMksys)
{
    return S_FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_devenum\main.cpp ===
#include <objbase.h>

#include <stdio.h>
#include <shpriv.h>

#include "mischlpr.h"

#include "unk.h"
#include "fact.h"

// {DD522ACC-F821-461a-A407-50B198B896DC}
extern const CLSID CLSID_HardwareDevices =
    {0xdd522acc, 0xf821, 0x461a,
    {0xa4, 0x7, 0x50, 0xb1, 0x98, 0xb8, 0x96, 0xdc}};

extern "C" const CLSID CLSID_HWDevCBTest;

extern const IID IID_IHardwareDevices = 
{0x99E69531, 0x1205, 0x4037,
{0x88, 0x27, 0xAD, 0x9B, 0x11, 0x36, 0x8B, 0x8E}};

extern const IID IID_IHardwareDeviceCallback =
{0x99B732C2, 0x9B7B, 0x4145,
{0x83, 0xA4, 0xC4, 0x5D, 0xF7, 0x91, 0xFD, 0x99}};

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

struct _sFLAG_DESCR
{
    DWORD   dwFlag;
    LPTSTR  pszDescr;
    LPTSTR  pszComment;
};

#define FLAG_DESCR(a) { (DWORD)a, TEXT(#a), NULL }

int _PrintIndent(DWORD cch)
{
    // for now, stupid simple
    for (DWORD dw = 0; dw < cch; ++dw)
    {
        wprintf(TEXT(" "));
    }

    return cch;
}

int _PrintFlag(DWORD dwFlag, _sFLAG_DESCR rgflag[], DWORD cflag,
    DWORD cchIndent, BOOL fPrintValue, BOOL fHex, BOOL fComment, BOOL fORed)
{
    int i = 0;
    BOOL fAtLeastOne = FALSE;

    for (DWORD dw = 0; dw < cflag; ++dw)
    {
        BOOL fPrint = FALSE;

        if (fORed)
        {
            if (rgflag[dw].dwFlag & dwFlag)
            {
                fPrint = TRUE;
            }
        }
        else
        {
            if (rgflag[dw].dwFlag == dwFlag)
            {
                fPrint = TRUE;
            }
        }

        if (fPrint)
        {
            if (fAtLeastOne)
            {
                i += wprintf(TEXT("\n"));
            }

            i += _PrintIndent(cchIndent);

            i += wprintf(TEXT("%s"), rgflag[dw].pszDescr);

            if (fPrintValue)
            {
                if (fHex)
                {
                    i += wprintf(TEXT(" (0x%08X)"), rgflag[dw].dwFlag);
                }
                else
                {
                    i += wprintf(TEXT(" (%u)"), rgflag[dw].dwFlag);
                }
            }

            if (fComment)
            {
                i += wprintf(TEXT(", '%s'"), rgflag[dw].pszComment);
            }

            fAtLeastOne = TRUE;
        }
    }

    return i;
}

// Media State
_sFLAG_DESCR _fdMediaState[] =
{
    FLAG_DESCR(HWDMS_PRESENT                        ),
    FLAG_DESCR(HWDMS_FORMATTED                      ),
};

_sFLAG_DESCR _fdMediaCap[] =
{
    FLAG_DESCR(HWDMC_WRITECAPABILITY_SUPPORTDETECTION ),
    FLAG_DESCR(HWDMC_CDROM		                      ),
    FLAG_DESCR(HWDMC_CDRECORDABLE                     ),
    FLAG_DESCR(HWDMC_CDREWRITABLE                     ),
    FLAG_DESCR(HWDMC_DVDROM                           ),
    FLAG_DESCR(HWDMC_DVDRECORDABLE                    ),
    FLAG_DESCR(HWDMC_DVDREWRITABLE                    ),
    FLAG_DESCR(HWDMC_DVDRAM                           ),
    FLAG_DESCR(HWDMC_ANALOGAUDIOOUT                   ),
    FLAG_DESCR(HWDMC_RANDOMWRITE                      ),
    FLAG_DESCR(HWDMC_HASAUTORUNINF                    ),

    FLAG_DESCR(HWDMC_HASDESKTOPINI                    ),
    FLAG_DESCR(HWDMC_HASDVDMOVIE                      ),
    FLAG_DESCR(HWDMC_HASAUDIOTRACKS                   ),
    FLAG_DESCR(HWDMC_HASDATATRACKS                    ),
    FLAG_DESCR(HWDMC_HASAUDIOTRACKS_UNDETERMINED      ),
    FLAG_DESCR(HWDMC_HASDATATRACKS_UNDETERMINED       ),
};

_sFLAG_DESCR _fdDriveCap[] =
{
    FLAG_DESCR(HWDDC_CAPABILITY_SUPPORTDETECTION ),
    FLAG_DESCR(HWDDC_CDROM		                 ),
    FLAG_DESCR(HWDDC_CDRECORDABLE                ),
    FLAG_DESCR(HWDDC_CDREWRITABLE                ),
    FLAG_DESCR(HWDDC_DVDROM                      ),
    FLAG_DESCR(HWDDC_DVDRECORDABLE               ),
    FLAG_DESCR(HWDDC_DVDREWRITABLE               ),
    FLAG_DESCR(HWDDC_DVDRAM                      ),
    FLAG_DESCR(HWDDC_ANALOGAUDIOOUT              ),
    FLAG_DESCR(HWDDC_RANDOMWRITE                 ),
    FLAG_DESCR(HWDDC_NOSOFTEJECT                 ),
};

_sFLAG_DESCR _fdVolumeFlags[] =
{
    FLAG_DESCR(HWDVF_STATE_SUPPORTNOTIFICATION),
};

_sFLAG_DESCR _fdDriveType[] =
{
    FLAG_DESCR(HWDTS_FLOPPY35			),
    FLAG_DESCR(HWDTS_FLOPPY525			),
    FLAG_DESCR(HWDTS_REMOVABLEDISK		),
    FLAG_DESCR(HWDTS_FIXEDDISK			),
    FLAG_DESCR(HWDTS_CDROM				),
};

_sFLAG_DESCR _fdFileSys[] =
{
    FLAG_DESCR(FS_CASE_IS_PRESERVED),
    FLAG_DESCR(FS_CASE_SENSITIVE),
    FLAG_DESCR(FS_UNICODE_STORED_ON_DISK),
    FLAG_DESCR(FS_PERSISTENT_ACLS),
    FLAG_DESCR(FS_FILE_COMPRESSION),
    FLAG_DESCR(FS_VOL_IS_COMPRESSED),
    FLAG_DESCR(FILE_NAMED_STREAMS),
    FLAG_DESCR(FILE_SUPPORTS_ENCRYPTION),
    FLAG_DESCR(FILE_SUPPORTS_OBJECT_IDS),
    FLAG_DESCR(FILE_SUPPORTS_REPARSE_POINTS),
    FLAG_DESCR(FILE_SUPPORTS_SPARSE_FILES),
    FLAG_DESCR(FILE_VOLUME_QUOTAS ),
};

_sFLAG_DESCR _fdFileAttrib[] =
{
    FLAG_DESCR(FILE_ATTRIBUTE_READONLY            ),
    FLAG_DESCR(FILE_ATTRIBUTE_HIDDEN              ),
    FLAG_DESCR(FILE_ATTRIBUTE_SYSTEM              ),
    FLAG_DESCR(FILE_ATTRIBUTE_DIRECTORY           ),
    FLAG_DESCR(FILE_ATTRIBUTE_ARCHIVE             ),
    FLAG_DESCR(FILE_ATTRIBUTE_DEVICE              ),
    FLAG_DESCR(FILE_ATTRIBUTE_NORMAL              ),
    FLAG_DESCR(FILE_ATTRIBUTE_TEMPORARY           ),
    FLAG_DESCR(FILE_ATTRIBUTE_SPARSE_FILE         ),
    FLAG_DESCR(FILE_ATTRIBUTE_REPARSE_POINT       ),
    FLAG_DESCR(FILE_ATTRIBUTE_COMPRESSED          ),
    FLAG_DESCR(FILE_ATTRIBUTE_OFFLINE             ),
    FLAG_DESCR(FILE_ATTRIBUTE_NOT_CONTENT_INDEXED ),
    FLAG_DESCR(FILE_ATTRIBUTE_ENCRYPTED           ),
};

void PrintVolumeAddedOrUpdatedHelper(VOLUMEINFO* pvolinfo)
{
    wprintf(L"    State:           '0x%08X'\n", pvolinfo->dwState);
    wprintf(L"    VolDevID:        '%s'\n", pvolinfo->pszDeviceIDVolume);
    wprintf(L"    VolGUID:         '%s'\n", pvolinfo->pszVolumeGUID);
    wprintf(L"    VolFlags:        '0x%08X'\n", pvolinfo->dwVolumeFlags);
    _PrintFlag(pvolinfo->dwVolumeFlags, _fdVolumeFlags, ARRAYSIZE(_fdVolumeFlags),
        8, TRUE, TRUE, FALSE, TRUE);
    wprintf(L"\n");

    wprintf(L"    DriveType:       '0x%08X'\n", pvolinfo->dwDriveType);
    _PrintFlag(pvolinfo->dwDriveType, _fdDriveType, ARRAYSIZE(_fdDriveType),
        8, TRUE, TRUE, FALSE, FALSE);
    wprintf(L"\n");

    wprintf(L"    DriveState:      '0x%08X'\n", pvolinfo->dwDriveState);
    wprintf(L"    DriveCap:        '0x%08X'\n", pvolinfo->dwDriveCapability);
    _PrintFlag(pvolinfo->dwDriveCapability, _fdDriveCap, ARRAYSIZE(_fdDriveCap),
        8, TRUE, TRUE, FALSE, TRUE);
    wprintf(L"\n");

    if (pvolinfo->dwMediaState & HWDMS_PRESENT)
    {
        if (pvolinfo->dwMediaState & HWDMS_FORMATTED)
        {
            wprintf(L"    Label:           '%s'\n", pvolinfo->pszLabel);
            wprintf(L"    FileSystem:      '%s'\n", pvolinfo->pszFileSystem);
            wprintf(L"    FileSystemFlags: '0x%08X'\n", pvolinfo->dwFileSystemFlags);
            _PrintFlag(pvolinfo->dwFileSystemFlags, _fdFileSys, ARRAYSIZE(_fdFileSys),
                8, TRUE, TRUE, FALSE, TRUE);
            wprintf(L"\n");

            wprintf(L"    MaxFileNameLen:  '0x%08X'\n", pvolinfo->dwMaxFileNameLen);
            wprintf(L"    RootAttributes:  '0x%08X'\n", pvolinfo->dwRootAttributes);
            _PrintFlag(pvolinfo->dwRootAttributes, _fdFileAttrib, ARRAYSIZE(_fdFileAttrib),
                8, TRUE, TRUE, FALSE, TRUE);
            wprintf(L"\n");

            wprintf(L"    SerialNumber:    '0x%08X'\n", pvolinfo->dwSerialNumber);
        }
        else
        {
            wprintf(L"    !!!! Not Formatted !!!!\n");
        }

        wprintf(L"    MediaState:      '0x%08X'\n", pvolinfo->dwMediaState);
        _PrintFlag(pvolinfo->dwMediaState, _fdMediaState, ARRAYSIZE(_fdMediaState),
            8, TRUE, TRUE, FALSE, TRUE);
        wprintf(L"\n");

        wprintf(L"    MediaCap:        '0x%08X'\n", pvolinfo->dwMediaCap);
        _PrintFlag(pvolinfo->dwMediaCap, _fdMediaCap, ARRAYSIZE(_fdMediaCap),
            8, TRUE, TRUE, FALSE, TRUE);
        wprintf(L"\n");
    }
    else
    {
        wprintf(L"    !!!! No Media !!!!\n");

        if (0x10000000 & pvolinfo->dwState)
        {
            wprintf(L"    GetVolumeInformation Failed!\n");
            wprintf(L"    GetLastError:    '0x%08X'\n", pvolinfo->dwSerialNumber);            
        }
    }
}

#define AUTOPLAY_MONIKER OLESTR("Shell.Autoplay:OnVideoArrival")

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        BOOL fRun;
        BOOL fEmbedded;

        if (CCOMBaseFactory::_ProcessConsoleCmdLineParams(argc, argv,
            &fRun, &fEmbedded))
        {
            if (fRun)
            {
                IHardwareDevices* pihwdevs = NULL;

                hr = CoCreateInstance(CLSID_HardwareDevices, NULL,
                    CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IHardwareDevices, &pihwdevs));
                
                if (SUCCEEDED(hr))
                {
                    {
                        IHardwareDevicesVolumesEnum* penum;

                        hr = pihwdevs->EnumVolumes(HWDEV_GETCUSTOMPROPERTIES, &penum);

                        if (SUCCEEDED(hr))
                        {
                            VOLUMEINFO volinfo;

                            wprintf(L"\n=====Begin Enumeration==============~0x%08X~\n",
                                GetCurrentThreadId());

                            while (SUCCEEDED(hr = penum->Next(&volinfo)) && (S_FALSE != hr))
                            {
                                wprintf(L"\n----Volume------~0x%08X~\n", GetCurrentThreadId());

                                PrintVolumeAddedOrUpdatedHelper(&volinfo);
                            }

                            penum->Release();
                        }
                    }

                    {
                        IHardwareDevicesMountPointsEnum* penum;

                        hr = pihwdevs->EnumMountPoints(&penum);

                        if (SUCCEEDED(hr))
                        {
                            LPWSTR pszMountPoint;
                            LPWSTR pszDeviceIDVolume;

                            while (SUCCEEDED(hr = penum->Next(
                                &pszMountPoint, &pszDeviceIDVolume)) &&
                                (S_FALSE != hr))
                            {
                                wprintf(L"\n----MountPoint------~0x%08X~\n", GetCurrentThreadId());
                                wprintf(L"    MountPoint:      '%s'\n", pszMountPoint);
                                wprintf(L"    VolDevID:        '%s'\n", pszDeviceIDVolume);
                            }

                            penum->Release();
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    if (argc > 1)
                    {
                        if (CCOMBaseFactory::_RegisterFactories(fEmbedded))
                        {
                            IHardwareDeviceCallback* pihdevcb;
                            DWORD dwToken = 0;

                            hr = CoCreateInstance(CLSID_HWDevCBTest, NULL,
                                CLSCTX_INPROC_SERVER, IID_PPV_ARG(IHardwareDeviceCallback,
                                &pihdevcb));

                            if (SUCCEEDED(hr))
                            {
                                wprintf(L"~0x%08X~Before Advise\n", GetCurrentThreadId());
                                hr = pihwdevs->Advise(pihdevcb, &dwToken);

                                wprintf(L"~0x%08X~After Advise\n", GetCurrentThreadId());
                                if (SUCCEEDED(hr))
                                {
                                    IMoniker* pmoniker;

                                    hr = CreateClassMoniker(CLSID_HWDevCBTest, &pmoniker);

                                    if (SUCCEEDED(hr))
                                    {
                                        IMoniker* pmoniker2;

                                        hr = CreateItemMoniker(TEXT("!"), TEXT("Test"), &pmoniker2);

                                        if (SUCCEEDED(hr))
                                        {
                                            IMoniker* pmonikerComp;
                                            hr = pmoniker->ComposeWith(pmoniker2, FALSE, &pmonikerComp);

                                            if (SUCCEEDED(hr))
                                            {
                                                IBindCtx* pBindCtx;

	                                            hr = CreateBindCtx(0, &pBindCtx);

	                                            if (SUCCEEDED(hr))
                                                {
			                                        IRunningObjectTable* prot;

			                                        hr = pBindCtx->GetRunningObjectTable(&prot);

			                                        if (SUCCEEDED(hr))
                                                    {
                                                        DWORD dwROTID;

				                                        hr = prot->Register(0, (IUnknown*)pihdevcb,
                                                            pmonikerComp, &dwROTID);

                                                        if (FAILED(hr))
                                                        {
                                                            wprintf(L"~0x%08X~prot->Register FAILED, 0x%08X\n", GetCurrentThreadId(), hr);
                                                        }
				                                        prot->Release ();
			                                        }
                                                    else
                                                    {
                                                        wprintf(L"~0x%08X~GetRunningObjectTable FAILED, 0x%08X\n", GetCurrentThreadId(), hr);
                                                    }

		                                            pBindCtx->Release ();
		                                        }
                                                else
                                                {
                                                    wprintf(L"~0x%08X~CreateClassMoniker FAILED, 0x%08X\n", GetCurrentThreadId(), hr);
                                                }
                                            }
                                            else
                                            {
                                                wprintf(L"~0x%08X~ComposeWith FAILED, 0x%08X\n", GetCurrentThreadId(), hr);
                                            }
                                        }
                                        else
                                        {
                                            wprintf(L"~0x%08X~CreateItemMoniker FAILED, 0x%08X\n", GetCurrentThreadId(), hr);
                                        }
                                    }
                                    else
                                    {
                                        wprintf(L"~0x%08X~CreateBindCtx FAILED, 0x%08X\n", GetCurrentThreadId(), hr);
                                    }

                                    Sleep(0xFFFFFFFF);
                                    wprintf(L"~0x%08X~Before Unadvise\n", GetCurrentThreadId());
                                    hr = pihwdevs->Unadvise(dwToken);
                                }
                                else
                                {
                                    wprintf(L"~0x%08X~Advise FAILED, 0x%08X\n", GetCurrentThreadId(), hr);
                                }

                                pihdevcb->Release();
                            }

                            if (!fEmbedded)
                            {
                                IClassFactory* pcf;
                                hr = CoGetClassObject(CLSID_HWDevCBTest, CLSCTX_INPROC_SERVER,
                                    NULL, IID_PPV_ARG(IClassFactory, &pcf));

                                if (SUCCEEDED(hr))
                                {
                                    pcf->LockServer(FALSE);

                                    pcf->Release();
                                }
                            }

                            wprintf(L"~0x%08X~Before _WaitForAllClientsToGo\n", GetCurrentThreadId());
                            CCOMBaseFactory::_WaitForAllClientsToGo();

                            CCOMBaseFactory::_UnregisterFactories(fEmbedded);
                        }
                    }
                }

                if (pihwdevs)
                {
                    pihwdevs->Release();
                }

                CoUninitialize();
            }
        }
    }

    return 0;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_devenum\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "hwdevcb.h"

CFactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_HWDevCBTest,
        CHWDevCBTest::UnkCreateInstance,
		L"HWDevicesCallBack",           // Friendly name
		L"HWDevicesCallBack.1",         // ProgID
		L"HWDevicesCallBack",           // Version-independent
        THREADINGMODEL_FREE,          // ThreadingModel == Both
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        NULL,
    },
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_devxprop\main.cpp ===
#include <objbase.h>

#include <stdio.h>
#include <shpriv.h>

#include "mischlpr.h"

#include "unk.h"
#include "fact.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        BOOL fShowUsage = FALSE;

        if ((argc >= 4) && (argc <= 5))
        {
            IHWDeviceCustomProperties* pihwdevcp;

            LPCWSTR pszDeviceID = argv[1];
            LPCWSTR pszPropName = argv[2];
            LPCWSTR pszType = argv[3];
            DWORD dwFlags = 0;

            if (argc == 5)
            {
                dwFlags = _wtoi(argv[4]);
            }

            hr = CoCreateInstance(CLSID_HWDeviceCustomProperties, NULL,
                    CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IHWDeviceCustomProperties,
                    &pihwdevcp));

            if (SUCCEEDED(hr))
            {
                if (dwFlags & 2)
                {
                    hr = pihwdevcp->InitFromDevNode(pszDeviceID, dwFlags & ~2);
                }
                else
                {
                    hr = pihwdevcp->Initialize(pszDeviceID, dwFlags);
                }

                if (SUCCEEDED(hr))
                {
                    if (!lstrcmpi(pszType, TEXT("/REG_SZ")))
                    {
                        LPWSTR pszProp;

                        hr = pihwdevcp->GetStringProperty(pszPropName,
                            &pszProp);

                        if (SUCCEEDED(hr))
                        {
                            wprintf(TEXT("\n    %s, %s: '%s'\n"), pszPropName,
                                pszType, pszProp);

                            CoTaskMemFree(pszProp);
                        }
                        else
                        {
                            wprintf(TEXT("\n    Could not get property %s, HRESULT = 0x%08X\n"),
                                pszPropName, hr);
                        }
                    }
                    else if (!lstrcmpi(pszType, TEXT("/REG_DWORD")))
                    {
                        DWORD dwProp;

                        hr = pihwdevcp->GetDWORDProperty(pszPropName,
                            &dwProp);

                        if (SUCCEEDED(hr))
                        {
                            wprintf(TEXT("\n    %s, %s: '0x%08X'\n"), pszPropName,
                                pszType, dwProp);
                        }
                        else
                        {
                            wprintf(TEXT("\n    Could not get property %s, HRESULT = 0x%08X'\n"),
                                pszPropName, hr);
                        }
                    }
                    else if (!lstrcmpi(pszType, TEXT("/REG_BINARY")))
                    {
                        //see sdk\inc\wtypes.h for BYTE_BLOB
                        BYTE_BLOB* pblob ;

                        hr = pihwdevcp->GetBlobProperty(pszPropName,
                            &pblob);

                        if (SUCCEEDED(hr))
                        {
                            BOOL fFirst = TRUE;
                            DWORD cPerLine = 0;
                            DWORD dwLeft;

                            for (unsigned long ul = 0; ul < pblob->clSize; ++ul)
                            {
                                if (fFirst)
                                {
                                    wprintf(TEXT("\n    %s, %s:\n            %02X"), pszPropName,
                                        pszType, pblob->abData[ul]);

                                    fFirst = FALSE;
                                }
                                else
                                {
                                    wprintf(TEXT(" %02X"), pblob->abData[ul]);
                                }

                                ++cPerLine;

                                if (8 == cPerLine)
                                {
                                    wprintf(TEXT("  "));

                                    for (int i = 8; i >= 0; --i)
                                    {
                                        if (iswalnum(pblob->abData[ul - i]) ||
                                            iswpunct(pblob->abData[ul - i]))
                                        {
                                            wprintf(TEXT("%c"), pblob->abData[ul - i]);
                                        }
                                        else
                                        {
                                            wprintf(TEXT("."));
                                        }
                                    }

                                    wprintf(TEXT("\n           "));
                                }
                            }

                            dwLeft = (pblob->clSize % 8) - 1;

                            for (DWORD j = 0; j < (8 - (pblob->clSize % 8)) * 3; ++j)
                            {
                                wprintf(TEXT(" "));
                            }

                            wprintf(TEXT("  "));

                            for (int i = dwLeft; i >= 0; --i)
                            {
                                if (iswalnum(pblob->abData[pblob->clSize - 1 - i]) ||
                                    iswpunct(pblob->abData[pblob->clSize - 1 - i]))
                                {
                                    wprintf(TEXT("%c"), pblob->abData[pblob->clSize - 1 - i]);
                                }
                                else
                                {
                                    wprintf(TEXT("."));
                                }
                            }

                            wprintf(TEXT("\n"));

                            CoTaskMemFree(pblob);
                        }
                        else
                        {
                            wprintf(TEXT("\n    Could not get property %s, HRESULT = 0x%08X'\n"),
                                pszPropName, hr);
                        }
                    }
                    else if (!lstrcmpi(pszType, TEXT("/REG_MULTI_SZ")))
                    {
                        WORD_BLOB* pblob;

                        hr = pihwdevcp->GetMultiStringProperty(pszPropName,
                            TRUE, &pblob);

                        if (SUCCEEDED(hr))
                        {
                            BOOL fFirst = TRUE;
                            LPWSTR pszProp = pblob->asData;

                            for (LPWSTR psz = pszProp; *psz; psz += lstrlen(psz) + 1)
                            {
                                if (fFirst)
                                {
                                    wprintf(TEXT("\n    %s, %s:\n            '%s'\n"), pszPropName,
                                        pszType, psz);

                                    fFirst = FALSE;
                                }
                                else
                                {
                                    wprintf(TEXT("            '%s'\n"), psz);
                                }
                            }

                            wprintf(TEXT("\n"));

                            CoTaskMemFree(pblob);
                        }
                        else
                        {
                            wprintf(TEXT("\n    Could not get property %s, HRESULT = 0x%08X'\n"),
                                pszPropName, hr);
                        }
                    }
                    else
                    {
                        fShowUsage = TRUE;
                    }
                }
                else
                {
                    wprintf(TEXT("\n    ERROR! IHWDeviceCustomProperties::Initialize failed, HRESULT = 0x%08X\n"), hr);
                }

                pihwdevcp->Release();
            }
            else
            {
                wprintf(TEXT("\n    ERROR! CoCreateInstance failed, HRESULT = 0x%08X\n"), hr);
            }
        }
        else
        {
            fShowUsage = TRUE;
        }

        if (fShowUsage)
        {
            wprintf(TEXT("\nTD_DEVXPROP device_id property_name type_of_query [flags]\n\n"));

            wprintf(TEXT("device_id          PnP Device ID (e.g. \\\\?\\STORAGE#RemovableMedia#7&d4fb61...), or;\n"));
            wprintf(TEXT("                   Volume drive mountpoint (e.g. E:\\).\n\n"));

            wprintf(TEXT("property_name      Property name (e.g. Devicegroup)\n"));
            
            wprintf(TEXT("type_of_query      One of:\n"));
            wprintf(TEXT("                       /REG_SZ, querys a REG_SZ property\n"));
            wprintf(TEXT("                       /REG_DWORD, querys a REG_DWORD property\n"));
            wprintf(TEXT("                       /REG_MULTI_SZ, querys a REG_MULTI_SZ property\n"));
            wprintf(TEXT("                       /REG_BINARY, querys a REG_BINARY property\n\n"));

            wprintf(TEXT("[flags]            Flags that modifies the behavior of the query.  One of:\n"));
            wprintf(TEXT("                       1, uses special volume processing to query the device\n"));
            wprintf(TEXT("                          properties from the volume interface.\n"));
            wprintf(TEXT("                       2, device_id is  a dev node\n"));

            wprintf(TEXT("\n"));
        }

        CoUninitialize();
    }
    else
    {
        wprintf(TEXT("\n    ERROR! CoInitializeEx failed, HRESULT = 0x%08X\n"), hr);
    }

    return 0;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_sfstr\td_main.cpp ===
#include <objbase.h>

#include "sfstr.h"

#include "dbg.h"

#ifndef UNICODE
#error This has to be UNICODE
#endif

// from td_sfstr.cpp
int DoTest(int argc, wchar_t* argv[]);

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    return !DoTest(argc, argv);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_heh\main.cpp ===
#include <objbase.h>

#include <stdio.h>

#include "unk.h"
#include "fact.h"

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    HRESULT hres = CoInitialize(NULL);

    if (SUCCEEDED(hres))
    {
        BOOL fRun;
        BOOL fEmbedded;

        if (CCOMBaseFactory::_ProcessConsoleCmdLineParams(argc, argv, &fRun,
            &fEmbedded))
        {
            if (fRun)
            {
                if (CCOMBaseFactory::_RegisterFactories(fEmbedded))
                {
                    CCOMBaseFactory::_WaitForAllClientsToGo();

                    CCOMBaseFactory::_UnregisterFactories(fEmbedded);
                }

/*                wprintf(L"Closing in 10 secs ");

                for (DWORD dw = 0; dw < 10; ++dw)
                {
                    wprintf(L".");
                    Sleep(1000);
                }*/
            }
        }

        CoUninitialize();
    }

    return 0;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_heh\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "cprt.h"

// {AAA93D49-75E1-4444-A26C-DB3575914246}
const CLSID APPID_td_heh = {
    0xaaa93d49,
    0x75e1,
    0x4444,
    {0xa2, 0x6c, 0xdb, 0x35, 0x75, 0x91, 0x42, 0x46}
};

CFactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_CPrt,
        CPrt::UnkCreateInstance,
		L"Sample HW Event Handler",           // Friendly name
		L"Sample HW Event Handler.1",         // ProgID
		L"Sample HW Event Handler",           // Version-independent
        THREADINGMODEL_BOTH,          // ThreadingModel == Both
        CLSCTX_LOCAL_SERVER,
        REGCLS_MULTIPLEUSE,
        NULL,
        NULL,
    },
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_heh\cprt.cpp ===
#include "cprt.h"

#include <stdio.h>

#include <shlobj.h> // for DROPFILES
#include <shpriv.h> // for IStorageInfo

#include "sfstr.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// {8BA650B6-5F49-4894-BE7C-8253D75DACE7}
extern "C" const CLSID CLSID_CPrt =
    {0x8ba650b6, 0x5f49, 0x4894,
    {0xbe, 0x7c, 0x82, 0x53, 0xd7, 0x5d, 0xac, 0xe7}};

// {C1FB73D0-EC3A-4ba2-B512-8CDB9187B6D1}
extern "C" const CLSID IID_IHWEventHandler =
    {0xC1FB73D0, 0xEC3A, 0x4ba2,
    {0xB5, 0x12, 0x8C, 0xDB, 0x91, 0x87, 0xB6, 0xD1}};

STDMETHODIMP CPrtImpl::Initialize(LPCWSTR pszParams)
{
/*    HRESULT hr = S_OK;

    wprintf(L"=======================================================\n");

    if (pszParams)
    {
        wprintf(L"Initilization: %s\n", pszParams);
    }
    else
    {
        wprintf(L"Initilization: <no params>\n");
    }

    return hr;*/

    SafeStrCpyN(_szParams, pszParams, ARRAYSIZE(_szParams));

    return S_OK;
}

STDMETHODIMP CPrtImpl::HandleEvent(LPCWSTR /*pszDeviceID*/, LPCWSTR /*pszDeviceIDAlt*/,
    LPCWSTR /*pszEventType*/)
{
/*    HRESULT hr = E_INVALIDARG;

    if (pszDeviceID && pszEventType && *pszDeviceID && *pszEventType)
    {
        wprintf(L"-------------------------------------------------------\n");
        wprintf(L"Device ID:       %s\n", pszDeviceID);
        if (pszDeviceIDAlt)
        {
            wprintf(L"Device ID Alt:   %s\n", pszDeviceIDAlt);
        }
        else
        {
            wprintf(L"Device ID Alt:   <NULL>\n");
        }
        wprintf(L"Event type:      %s\n", pszEventType);

        hr = S_OK;
    }

    return hr;*/

    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    WCHAR sz[4096];

    si.cb = sizeof(si);

    ExpandEnvironmentStrings(_szParams, sz, ARRAYSIZE(sz));

    CreateProcess(sz, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

    return S_OK;
}

STDMETHODIMP CPrtImpl::HandleEventWithContent(LPCWSTR /*pszDeviceID*/,
    LPCWSTR /*pszDeviceIDAlt*/, LPCWSTR /*pszEventType*/,
    LPCWSTR /*pszContentTypeHandler*/, IDataObject* /*pdataobject*/)
{
/*    HRESULT hr = E_INVALIDARG;

    if (pszDeviceID && pszEventType && pszContentTypeHandler && *pszDeviceID &&
        *pszEventType && *pszContentTypeHandler)
    {
        wprintf(L"-------------------------------------------------------\n");
        wprintf(L"Device ID:            %s\n", pszDeviceID);
        if (pszDeviceIDAlt)
        {
            wprintf(L"Device ID Alt:        %s\n", pszDeviceIDAlt);
        }
        else
        {
            wprintf(L"Device ID Alt:        <NULL>\n");
        }
        wprintf(L"Event type:           %s\n", pszEventType);
        wprintf(L"Content Type Handler: %s\n", pszContentTypeHandler);

        hr = S_OK;
    }

    STGMEDIUM medium = {0};
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (SUCCEEDED(pdataobject->QueryGetData(&fmte)))
    {
        if (SUCCEEDED(pdataobject->GetData(&fmte, &medium)))
        {
            DROPFILES* pdf = (DROPFILES*)GlobalLock(medium.hGlobal);

            if (pdf)
            {
                LPWSTR pszFile = (LPWSTR)(pdf + 1);

                if (pszFile)
                {
                    while (*pszFile)
                    {
                        wprintf(L"    %s\n", pszFile);

                        pszFile += lstrlen(pszFile) + 1;
                    }
                }

                GlobalUnlock(medium.hGlobal);
            }

            ReleaseStgMedium(&medium);
        }
    }

    return hr;*/

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_heh\cprtu.cpp ===
#include "cprt.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY cprtIME[] =
{
    _INTFMAPENTRY(CPrt, IHWEventHandler),
};

const INTFMAPENTRY* CPrt::_pintfmap = cprtIME;
const DWORD CPrt::_cintfmap =
    (sizeof(cprtIME)/sizeof(cprtIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

COMFACTORYCB CPrt::_cfcb = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_sfstr\shdrt.cpp ===
#include <objbase.h>

#include "dbg.h"

static const CHAR szTestName[] = "Safe String Test";

// from td_sfstr.cpp
int DoTest(int argc, wchar_t* argv[]);

typedef BOOL (CALLBACK * SHTESTPROC)();

BOOL CALLBACK SHTestProc()
{
    return DoTest(0, NULL);
}

// for now
struct SHTESTDESCRIPTOR
{
    DWORD        _cbSize;
    LPCSTR       _pszTestName;
    SHTESTPROC   _pfnTestProc;
    DWORD        _dwAttribs;
};

// SHTESTLISTPROC
//
// Each test dll exports this function, which describes the tests
// it contains (or returns just a count if the arg passed to is is null

DWORD CALLBACK ListTestProcs(SHTESTDESCRIPTOR* prgpshtd)
{
    if (prgpshtd)
    {
        prgpshtd->_pszTestName = szTestName;
        prgpshtd->_pfnTestProc = SHTestProc;

        // ????
        prgpshtd->_dwAttribs = 0;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_heh\cprt.h ===
///////////////////////////////////////////////////////////////////////////////
// Test component to print event to command prompt
///////////////////////////////////////////////////////////////////////////////
#ifndef _CPRT_H
#define _CPRT_H

#include "unk.h"
#include "shobjidl.h"

extern "C" const CLSID CLSID_CPrt;

class CPrtImpl : public CCOMBase, public IHWEventHandler
{
public:
    // Interface IHWEventHandler
	STDMETHODIMP Initialize(LPCWSTR pszParams);

	STDMETHODIMP HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszDeviceIDAlt,
        LPCWSTR pszEventType);

    STDMETHODIMP HandleEventWithContent(LPCWSTR pszDeviceID,
        LPCWSTR pszDeviceIDAlt, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdataobject);

private:
    WCHAR   _szParams[4096];
};

typedef CUnkTmpl<CPrtImpl> CPrt;

#endif // _CPRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_sfstr\td_sfstr.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <io.h>
#include <objbase.h>

#include "sfstr.h"

#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

const WCHAR szOne[] = TEXT("0");
const WCHAR szTwo[] = TEXT("01");
const WCHAR szThree[] = TEXT("012");
const WCHAR szFour[] = TEXT("0123");
const WCHAR szFive[] = TEXT("01234");

int DoTest(int , wchar_t* [])
{
    HRESULT hresTest = S_OK;

    // For all fcts call
    HRESULT hres;

    WCHAR szDestTwo[2];
    WCHAR szDestThree[3];
    WCHAR szDestFour[4];
    WCHAR szDestFive[5];
    WCHAR szDestSix[6];

///////////////////////////////////////////////////////////////////////////////
//
// SafeStrCxxN
    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestFour, szThree, ARRAYSIZE(szDestFour));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestThree, szThree, ARRAYSIZE(szDestThree));

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestFive, szThree, ARRAYSIZE(szDestFive));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatN(szDestSix, szTwo, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szTwo, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatN(szDestSix, szTwo, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

///////////////////////////////////////////////////////////////////////////////
//
// SafeStrCxxNEx
    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    LPWSTR pszNext = 0;
    DWORD cchLeft = 0;

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestFour, szThree, ARRAYSIZE(szDestFour), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (1 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestThree, szThree, ARRAYSIZE(szDestThree),
            &pszNext, &cchLeft);

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestFive, szThree, ARRAYSIZE(szDestFive), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (2 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestSix, szThree, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (3 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(pszNext, szTwo, cchLeft);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestSix, szThree, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (3 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(pszNext, szThree, cchLeft);

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestSix, szTwo, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (4 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(pszNext, szTwo, cchLeft);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatNEx(szDestSix, szTwo, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (1 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatNEx(szDestSix, szThree, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szTwo, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatNEx(szDestSix, szTwo, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (2 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

///////////////////////////////////////////////////////////////////////////////
//
// SafeStrCpyNExact
    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 1);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 2);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 3);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 4);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 5);

        if (SUCCEEDED(hres) || (E_SOURCEBUFFERTOOSMALL != hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestTwo, szThree, ARRAYSIZE(szDestTwo), 5);

        if (SUCCEEDED(hres) || (E_BUFFERTOOSMALL != hres))
        {
            hresTest = E_FAIL;
        }
    }

///////////////////////////////////////////////////////////////////////////////
//
// SafeStrCpyNExactEx
    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 1, 
            &pszNext, &cchLeft);

        if (FAILED(hres) || (4 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 2, 
            &pszNext, &cchLeft);

        if (FAILED(hres) || (3 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 3, 
            &pszNext, &cchLeft);

        if (FAILED(hres) || (2 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 4, 
            &pszNext, &cchLeft);

        if (FAILED(hres) || (1 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 5, 
            &pszNext, &cchLeft);

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    return SUCCEEDED(hresTest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\hdsrv\tstdrv\td_sniff\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <io.h>
#include <objbase.h>

#include "sniff.h"

#ifndef UNICODE
#error This has to be UNICODE
#endif

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

int DoTest(int argc, wchar_t* argv[]);

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    return DoTest(argc, argv);
}
}

HRESULT _ProcessContentTypeHandlerCB(LPCWSTR pszContentTypeHandler,
    LPCWSTR pszFilePattern, DWORD cFiles, void*)
{
    wprintf(TEXT("%s: %s [%d]\n"), pszContentTypeHandler, pszFilePattern, cFiles);

    return S_OK;
}

int DoTest(int argc, wchar_t* argv[])
{
    HRESULT hr = E_FAIL;

    if (3 == argc)
    {
        hr = _SniffVolumeContentType(argv[1],
            argv[2], _ProcessContentTypeHandlerCB, NULL);
    }
    else
    {
        wprintf(TEXT("Wrong usage"));
    }

    return !SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\apiconnection.h ===
//  --------------------------------------------------------------------------
//  Module Name: APIConnectionThread.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that listens to an LPC connection port waiting for requests from
//  a client to connect to the port or a request which references a previously
//  established connection.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _APIConnectionThread_
#define     _APIConnectionThread_

#include "DynamicArray.h"
#include "PortMessage.h"
#include "ServerAPI.h"

//  --------------------------------------------------------------------------
//  CAPIConnection
//
//  Purpose:    This class listens to the server connection port for an LPC
//              connection request, an LPC request or an LPC connect closed
//              message. It correctly handles each request. LPC requests are
//              queued to the managing CAPIDispatcher.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-11-28  vtan        removed thread functionality
//  --------------------------------------------------------------------------

class   CAPIConnection : public CCountedObject
{
    private:
                                            CAPIConnection (void);
    public:
                                            CAPIConnection (CServerAPI* pServerAPI);
                                            ~CAPIConnection (void);

                NTSTATUS                    ConstructorStatusCode (void)    const;
                NTSTATUS                    Listen (void);

                NTSTATUS                    AddAccess (PSID pSID, DWORD dwMask);
                NTSTATUS                    RemoveAccess (PSID pSID);
    private:
                NTSTATUS                    ListenToServerConnectionPort (void);

                NTSTATUS                    HandleServerRequest (const CPortMessage& portMessage, CAPIDispatcher *pAPIDispatcher);
                NTSTATUS                    HandleServerConnectionRequest (const CPortMessage& portMessage);
                NTSTATUS                    HandleServerConnectionClosed (const CPortMessage& portMessage, CAPIDispatcher *pAPIDispatcher);

                int                         FindIndexDispatcher (CAPIDispatcher *pAPIDispatcher);
    private:
                NTSTATUS                    _status;
                bool                        _fStopListening;
                CServerAPI*                 _pServerAPI;
                HANDLE                      _hPort;
                CDynamicCountedObjectArray  _dispatchers;
};

#endif  /*  _APIConnectionThread_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\apirequest.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: APIRequest.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that uses multiple inheritence to allow a CPortMessage to be
//  included in a queue as a CQueueElement.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "APIRequest.h"
#include "StatusCode.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//  --------------------------------------------------------------------------
//  CAPIRequest::CAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher object to handle
//                                      this request.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CAPIRequest. Store a reference to the
//              CAPIDispatcher and add a reference to the object.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIRequest::CAPIRequest (CAPIDispatcher* pAPIDispatcher) :
    CQueueElement(),
    CPortMessage(),
    _pAPIDispatcher(pAPIDispatcher)

{
    pAPIDispatcher->AddRef();
}

//  --------------------------------------------------------------------------
//  CAPIRequest::CAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher object to handle
//                                      this request.
//              portMessage         =   CPortMessage to copy construct.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CAPIRequest. Store a reference to the
//              CAPIDispatcher and add a reference to the object.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIRequest::CAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage) :
    CQueueElement(),
    CPortMessage(portMessage),
    _pAPIDispatcher(pAPIDispatcher)

{
    pAPIDispatcher->AddRef();
}

//  --------------------------------------------------------------------------
//  CAPIRequest::~CAPIRequest
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CAPIRequest. Release the reference to the
//              CAPIDispatcher object.
//
//  History:    99-11-07    vtan        created
//  --------------------------------------------------------------------------

CAPIRequest::~CAPIRequest (void)

{
    _pAPIDispatcher->Release();
    _pAPIDispatcher = NULL;
}


//  --------------------------------------------------------------------------
//  _ValidateMappedClientString
//
//  Arguments:  pszMapped = String successfully mapped from the client memory space
//                          using _AllocAndMapClientString().
//              cchIn     = client's count of characters, including NULL.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Ensures that the length of the string is what the client said it was.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------

NTSTATUS _ValidateMappedClientString( 
    IN LPCWSTR pszMapped,
    IN ULONG   cchIn )
{
    size_t   cch;
    
    //  note: cchIn includes the NULL terminus.
    return (SUCCEEDED(StringCchLengthW((LPWSTR)pszMapped, cchIn, &cch)) &&
            cchIn == (cch + 1)) ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
}

//  --------------------------------------------------------------------------
//  _FreeMappedClientString
//
//  Arguments:  pszMapped = String successfully mapped from the client memory space
//                          using _AllocAndMapClientString().
//
//  Returns:    NTSTATUS
//
//  Purpose:    Release memory for mapped client string.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------

void _FreeMappedClientString(IN LPWSTR pszMapped)
{
    delete [] pszMapped;
}

//  --------------------------------------------------------------------------
//  _AllocAndMapClientString
//
//  Arguments:  hProcessClient = client process handle
//              pszIn  = client's address of string
//              cchIn  = client's count of characters, including NULL.
//              cchMax = maximum allowed characters
//              ppszMapped = outbound mapped string.   Should be freed with _FreeClientString()
//
//  Returns:    NTSTATUS
//
//  Purpose:    Ensures that the length of the string is what the client said it was.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------

NTSTATUS _AllocAndMapClientString( 
    IN HANDLE   hProcessClient,
    IN LPCWSTR  pszIn,
    IN UINT     cchIn,
    IN UINT     cchMax,
    OUT LPWSTR*  ppszMapped )
{
    NTSTATUS status;

    ASSERTMSG(ppszMapped != NULL, "_AllocAndMapClientString: NULL outbound parameter, LPWSTR*.");
    ASSERTMSG(hProcessClient != NULL, "_AllocAndMapClientString: NULL process handle.");

    *ppszMapped = NULL;

    if( pszIn && cchIn > 0 && cchIn <= cchMax )
    {
        LPWSTR pszMapped = new WCHAR[cchIn];
        if( pszMapped )
        {
            SIZE_T dwNumberOfBytesRead;
            if( ReadProcessMemory(hProcessClient, pszIn, pszMapped, cchIn * sizeof(WCHAR),
                                  &dwNumberOfBytesRead) )
            {
                status = _ValidateMappedClientString(pszMapped, cchIn);

                if( NT_SUCCESS(status) )
                {
                    *ppszMapped = pszMapped;
                }
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }

            if( !NT_SUCCESS(status) )
            {
                _FreeMappedClientString(pszMapped);
            }
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\apiconnection.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: APIConnectionThread.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that listens to an LPC connection port waiting for requests from
//  a client to connect to the port or a request which references a previously
//  established connection.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "APIConnection.h"

#include <lpcgeneric.h>

#include "Access.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CAPIConnection::CAPIConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CAPIConnectionThread. Store the CServerAPI
//              function table. This describes how to react to LPC messages.
//              This function also creates the server connection port.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-09-01  vtan        use explicit security descriptor
//  --------------------------------------------------------------------------

CAPIConnection::CAPIConnection (CServerAPI* pServerAPI) :
    _status(STATUS_NO_MEMORY),
    _fStopListening(false),
    _pServerAPI(pServerAPI),
    _hPort(NULL)

{
    OBJECT_ATTRIBUTES       objectAttributes;
    UNICODE_STRING          portName;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;

    //  Increment the reference on the interface.

    pServerAPI->AddRef();

    //  Get the name from the interface.

    RtlInitUnicodeString(&portName, pServerAPI->GetPortName());

    //  Build a security descriptor for the port that allows:
    //      S-1-5-18        NT AUTHORITY\SYSTEM     PORT_ALL_ACCESS
    //      S-1-5-32-544    <local administrators>  READ_CONTROL | PORT_CONNECT

    static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority       =   SECURITY_NT_AUTHORITY;

    static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
    {
        {
            &s_SecurityNTAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            PORT_ALL_ACCESS
        },
        {
            &s_SecurityNTAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            READ_CONTROL | PORT_CONNECT
        }
    };

    //  Build a security descriptor that allows the described access above.

    pSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);

    //  Initialize the object attributes.

    InitializeObjectAttributes(&objectAttributes,
                               &portName,
                               0,
                               NULL,
                               pSecurityDescriptor);

    //  Create the port.

    _status = NtCreatePort(&_hPort,
                           &objectAttributes,
                           0,
                           PORT_MAXIMUM_MESSAGE_LENGTH,
                           16 * PORT_MAXIMUM_MESSAGE_LENGTH);

    //  Release the security descriptor memory.

    ReleaseMemory(pSecurityDescriptor);

    if (!NT_SUCCESS(_status))
    {
        pServerAPI->Release();
    }
}

//  --------------------------------------------------------------------------
//  CAPIConnection::~CAPIConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CAPIConnectionThread. Close the port. Release
//              the interface referrence.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIConnection::~CAPIConnection (void)

{
    ReleaseHandle(_hPort);
    _pServerAPI->Release();
    _pServerAPI = NULL;
}

//  --------------------------------------------------------------------------
//  CAPIConnection::ConstructorStatusCode
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Returns the constructor status code back to the caller.
//
//  History:    2000-10-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::ConstructorStatusCode (void)    const

{
    return(_status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::Listen
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Listens for server API connections and requests.
//
//  History:    2000-11-28  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::Listen (void)

{
    NTSTATUS    status;

    //  If a connection port was created then start listening.

    if (_hPort != NULL)
    {
        do
        {
            (NTSTATUS)ListenToServerConnectionPort();
        } while (!_fStopListening);
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::AddAccess
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds access allowed to the ACL of the port.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::AddAccess (PSID pSID, DWORD dwMask)

{
    CSecuredObject  object(_hPort, SE_KERNEL_OBJECT);

    return(object.Allow(pSID, dwMask, 0));
}

//  --------------------------------------------------------------------------
//  CAPIConnection::RemoveAccess
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Removes access allowed from the ACL of the port.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::RemoveAccess (PSID pSID)

{
    CSecuredObject  object(_hPort, SE_KERNEL_OBJECT);

    return(object.Remove(pSID));
}

//  --------------------------------------------------------------------------
//  CAPIConnection::ListenToServerConnectionPort
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Calls ntdll!NtReplyWaitReceivePort to listen to the LPC port
//              for a message. Respond to the message. Messages understood are
//              LPC_REQUEST / LPC_CONNECTION_REQUEST / LPC_PORT_CLOSED.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::ListenToServerConnectionPort (void)

{
    NTSTATUS        status;
    CAPIDispatcher  *pAPIDispatcher;
    CPortMessage    portMessage;

    status = NtReplyWaitReceivePort(_hPort,
                                    reinterpret_cast<void**>(&pAPIDispatcher),
                                    NULL,
                                    portMessage.GetPortMessage());
    if (NT_SUCCESS(status))
    {
        switch (portMessage.GetType())
        {
            case LPC_REQUEST:
                status = HandleServerRequest(portMessage, pAPIDispatcher);
                break;
            case LPC_CONNECTION_REQUEST:
                (NTSTATUS)HandleServerConnectionRequest(portMessage);
                break;
            case LPC_PORT_CLOSED:
                status = HandleServerConnectionClosed(portMessage, pAPIDispatcher);
                break;
            default:
                break;
        }
        TSTATUS(status);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::HandleServerRequest
//
//  Arguments:  portMessage     =   CPortMessage containing the message.
//              pAPIDispatcher  =   CAPIDispatcher to handle request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Queue the PORT_MESSAGE request to the handling dispatcher and
//              wait for the next message. The queue operation will queue the
//              request and either queue a work item if no work item is
//              currently executing or just add it to the currently executing
//              work item.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::HandleServerRequest (const CPortMessage& portMessage, CAPIDispatcher *pAPIDispatcher)

{
    NTSTATUS            status;
    unsigned long       ulAPINumber;
    const API_GENERIC   *pAPI;

    pAPI = reinterpret_cast<const API_GENERIC*>(portMessage.GetData());
    ulAPINumber = pAPI->ulAPINumber;
    if ((ulAPINumber & API_GENERIC_SPECIAL_MASK) != 0)
    {
        switch (pAPI->ulAPINumber & API_GENERIC_SPECIAL_MASK)
        {
            case API_GENERIC_STOPSERVER:
            {
                int     i, iLimit;

                if (HandleToULong(portMessage.GetUniqueProcess()) == GetCurrentProcessId())
                {
                    status = STATUS_SUCCESS;
                    _fStopListening = true;
                }
                else
                {
                    status = STATUS_ACCESS_DENIED;
                }

                //  Send the message back to the client. Even though this is
                //  RejectRequest it will send back the message and unblock
                //  the caller.

                TSTATUS(pAPIDispatcher->RejectRequest(portMessage, status));

                //  Now iterate all the CAPIDispatchers we know of and close them
                //  this will reject any further requests and not have clients
                //  block in NtRequestWaitReplyPort.

                iLimit = _dispatchers.GetCount();
                for (i = iLimit - 1; i >= 0; --i)
                {
                    CAPIDispatcher  *pAPIDispatcher;

                    pAPIDispatcher = static_cast<CAPIDispatcher*>(_dispatchers.Get(i));
                    if (pAPIDispatcher != NULL)
                    {
                        pAPIDispatcher->CloseConnection();
                        pAPIDispatcher->Release();
                    }
                    _dispatchers.Remove(i);
                }

                break;
            }
            default:
                status = STATUS_NOT_IMPLEMENTED;
                DISPLAYMSG("Invalid API number special code passed to CAPIConnection::HandleServerRequest");
                break;
        }
    }
    else if ((pAPI->ulAPINumber & API_GENERIC_OPTIONS_MASK) != 0)
    {
        switch (pAPI->ulAPINumber & API_GENERIC_OPTIONS_MASK)
        {
            case API_GENERIC_EXECUTE_IMMEDIATELY:
                status = pAPIDispatcher->ExecuteRequest(portMessage);
                break;
            default:
                status = STATUS_NOT_IMPLEMENTED;
                DISPLAYMSG("Invalid API number option passed to CAPIConnection::HandleServerRequest");
                break;
        }
    }
    else
    {
        status = pAPIDispatcher->QueueRequest(portMessage);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::HandleServerConnectionRequest
//
//  Arguments:  portMessage     =   CPortMessage containing the message.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Ask the interface whether this connection should be accepted.
//              If the connection is accepted then create the dispatcher that
//              handles requests from this particular client. Either way
//              inform the kernel that the request is either rejected or
//              accepted. If the connection is accepted then complete the
//              connection and give the dispatcher that will handle the
//              requests the port to reply to.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::HandleServerConnectionRequest (const CPortMessage& portMessage)

{
    NTSTATUS        status;
    bool            fConnectionAccepted;
    HANDLE          hPort;
    CAPIDispatcher  *pAPIDispatcher;

    //  Should the connection be accepted?

    fConnectionAccepted = _pServerAPI->ConnectionAccepted(portMessage);
    if (fConnectionAccepted)
    {

        //  If so then create the dispatcher to handle this client.

        pAPIDispatcher = _pServerAPI->CreateDispatcher(portMessage);
        if (pAPIDispatcher != NULL)
        {

            //  First try to add the CAPIDispatcher object to the static array.
            //  If this fails then reject the connection and release the memory.

            if (!NT_SUCCESS(_dispatchers.Add(pAPIDispatcher)))
            {
                pAPIDispatcher->Release();
                pAPIDispatcher = NULL;
            }
        }
    }
    else
    {
        pAPIDispatcher = NULL;
    }

    //  Without a CAPIDispatcher object reject the connection.

    if (pAPIDispatcher == NULL)
    {
        fConnectionAccepted = false;
    }

    //  Tell the kernel what the result is.

    status = NtAcceptConnectPort(&hPort,
                                 pAPIDispatcher,
                                 const_cast<PORT_MESSAGE*>(portMessage.GetPortMessage()),
                                 fConnectionAccepted,
                                 NULL,
                                 NULL);
    if (fConnectionAccepted)
    {

        //  If we tried to accept the connection but NtAcceptConnectPort
        //  couldn't allocate the port objects or something then we need
        //  to clean up the _dispatchers array CAPIDispatcher entry added.

        if (NT_SUCCESS(status))
        {
            pAPIDispatcher->SetPort(hPort);

            //  If the connection is accepted then complete the connection and set
            //  the reply port to the CAPIDispatcher that will process requests.

            TSTATUS(NtCompleteConnectPort(hPort));
        }
        else
        {
            int     iIndex;

            //  Otherwise find the CAPIDispatcher that was added and remove it
            //  from the array. There's no need to wake the client up because
            //  NtAcceptConnectPort wakes it up in cases of failure.

            iIndex = FindIndexDispatcher(pAPIDispatcher);
            if (iIndex >= 0)
            {
                TSTATUS(_dispatchers.Remove(iIndex));
            }
            TSTATUS(pAPIDispatcher->CloseConnection());
            pAPIDispatcher->Release();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::HandleServerConnectionClosed
//
//  Arguments:  portMessage     =   CPortMessage containing the message.
//              pAPIDispatcher  =   CAPIDispatcher to handle request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    The port associated with the CAPIDispatcher client was
//              closed. This is probably because the client process went away.
//              Let the dispatcher clean itself up.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIConnection::HandleServerConnectionClosed (const CPortMessage& portMessage, CAPIDispatcher *pAPIDispatcher)

{
    UNREFERENCED_PARAMETER(portMessage);

    NTSTATUS    status;

    if (pAPIDispatcher != NULL)
    {
        int     iIndex;

        status = pAPIDispatcher->CloseConnection();
        pAPIDispatcher->Release();
        iIndex = FindIndexDispatcher(pAPIDispatcher);
        if (iIndex >= 0)
        {
            _dispatchers.Remove(iIndex);
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIConnection::FindIndexDispatcher
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher to find.
//
//  Returns:    int
//
//  Purpose:    Finds the index in the dynamic counted object array of the
//              dispatcher.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

int     CAPIConnection::FindIndexDispatcher (CAPIDispatcher *pAPIDispatcher)

{
    int     i, iLimit, iResult;

    iResult = -1;
    iLimit = _dispatchers.GetCount();
    for (i = 0; (iResult < 0) && (i < iLimit); ++i)
    {
        if (pAPIDispatcher == static_cast<CAPIDispatcher*>(_dispatchers.Get(i)))
        {
            iResult = i;
        }
    }
    return(iResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\apirequest.h ===
//  --------------------------------------------------------------------------
//  Module Name: APIRequest.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that uses multiple inheritence to allow a CPortMessage to be
//  included in a queue as a CQueueElement.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _APIRequest_
#define     _APIRequest_

#include "APIDispatcher.h"
#include "PortMessage.h"
#include "Queue.h"

//  --------------------------------------------------------------------------
//  CAPIRequest
//
//  Purpose:    This class combines CPortMessage and CQueueElement to allow
//              the PORT_MESSAGE struct in CPortMessage to be used in a queue.
//              This allows the server to queue requests to the thread that
//              is handling the client.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CAPIRequest : public CQueueElement, public CPortMessage
{
    private:
                                    CAPIRequest (void);
    public:
                                    CAPIRequest (CAPIDispatcher* pAPIDispatcher);
                                    CAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage);
        virtual                     ~CAPIRequest (void);

        virtual NTSTATUS            Execute (void) = 0;
    protected:
                CAPIDispatcher*     _pAPIDispatcher;
};

//  --------------------------------------------------------------------------
//  _AllocAndMapClientString
//
//  Arguments:  hProcessClient = client process handle
//              pszIn  = client's address of string
//              cchIn  = client's count of characters, including NULL.
//              cchMax = maximum allowed characters
//              ppszMapped = outbound mapped string.   Should be freed with _FreeClientString()
//
//  Returns:    NTSTATUS
//
//  Purpose:    Ensures that the length of the string is what the client said it was.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------
NTSTATUS _AllocAndMapClientString( 
    IN HANDLE   hProcessClient,
    IN LPCWSTR  pszIn,
    IN UINT     cchIn,
    IN UINT     cchMax,
    OUT LPWSTR*  ppszMapped );

//  --------------------------------------------------------------------------
//  _FreeMappedClientString
//
//  Arguments:  pszMapped = String successfully mapped from the client memory space
//                          using _AllocAndMapClientString().
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases memory for mapped client string.
//
//  History:    2002-02-26  scotthan    created
//  --------------------------------------------------------------------------
void _FreeMappedClientString(IN LPWSTR pszMapped);


#endif  /*  _APIRequest_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\apidispatcher.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: APIDispatcher.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that handles API requests in the server on a separate thread. Each
//  thread is dedicated to respond to a single client. This is acceptable for
//  a lightweight server.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "APIDispatcher.h"

#include "APIRequest.h"
#include "SingleThreadedExecution.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CAPIDispatcher::CAPIDispatcher
//
//  Arguments:  hClientProcess  =   HANDLE to the client process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CAPIDispatcher. The handle to the client
//              process is transferred to this object.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIDispatcher::CAPIDispatcher (HANDLE hClientProcess) :
    _hSection(NULL),
    _pSection(NULL),
    _hProcessClient(hClientProcess),
    _hPort(NULL),
    _fRequestsPending(false),
    _fConnectionClosed(false)

{
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::~CAPIDispatcher
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CAPIDispatcher. Release the port handle if
//              present. Release the process handle.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CAPIDispatcher::~CAPIDispatcher (void)

{
    ASSERTMSG(_fConnectionClosed, "Destructor invoked without connection being closed in CAPIDispatcher::~CAPIDispatcher");
    if (_pSection != NULL)
    {
        TBOOL(UnmapViewOfFile(_pSection));
        _pSection = NULL;
    }
    ReleaseHandle(_hSection);
    ReleaseHandle(_hPort);
    ReleaseHandle(_hProcessClient);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::GetClientProcess
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the handle to the client process. This is not
//              duplicated. DO NOT CLOSE THIS HANDLE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

HANDLE  CAPIDispatcher::GetClientProcess (void)     const

{
    return(_hProcessClient);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::GetClientSessionID
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Returns the client session ID.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

DWORD   CAPIDispatcher::GetClientSessionID (void)   const

{
    DWORD                           dwSessionID;
    ULONG                           ulReturnLength;
    PROCESS_SESSION_INFORMATION     processSessionInformation;

    if (NT_SUCCESS(NtQueryInformationProcess(_hProcessClient,
                                             ProcessSessionInformation,
                                             &processSessionInformation,
                                             sizeof(processSessionInformation),
                                             &ulReturnLength)))
    {
        dwSessionID = processSessionInformation.SessionId;
    }
    else
    {
        dwSessionID = 0;
    }
    return(dwSessionID);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::SetPort
//
//  Arguments:  hPort   =   Reply port received from
//                          ntdll!NtAcceptConnectionPort.
//
//  Returns:    <none>
//
//  Purpose:    Sets the given port handle into this object. The handle
//              ownership is transferred. Wait until the thread processing
//              requests is ready before returning.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CAPIDispatcher::SetPort (HANDLE hPort)

{
    _hPort = hPort;
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::GetSection
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns a handle to a section used to communicate large
//              quantities of data from client to server. If the section has
//              not been created then create it.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CAPIDispatcher::GetSection (void)

{
    if (_hSection == NULL)
    {
        TSTATUS(CreateSection());
    }
    return(_hSection);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::GetSectionAddress
//
//  Arguments:  <none>
//
//  Returns:    void*
//
//  Purpose:    Returns the mapped address of the section.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

void*   CAPIDispatcher::GetSectionAddress (void)    const

{
    return(_pSection);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::CloseConnection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sets the member variable indicating the dispatcher's port has
//              been closed and that any pending requests are now invalid.
//              The object is reference counted so if there are any pending
//              requests they will release their reference when they're done.
//              The caller of this function releases its reference.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-11-08  vtan        reference counted object
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::CloseConnection (void)

{
    CSingleThreadedExecution    requestsPendingLock(_lock);

    _fConnectionClosed = true;
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::QueueRequest
//
//  Arguments:  portMessage     =   CPortMessage of request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Checks if the connection has been closed. If closed then it
//              rejects the request. Otherwise it queues it.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::QueueRequest (const CPortMessage& portMessage)

{
    NTSTATUS    status;

    if (_fConnectionClosed)
    {
        status = RejectRequest(portMessage, STATUS_PORT_DISCONNECTED);
    }
    else
    {
        status = CreateAndQueueRequest(portMessage);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::ExecuteRequest
//
//  Arguments:  portMessage     =   CPortMessage of request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Checks if the connection has been closed. If closed then it
//              rejects the request. Otherwise it executes it.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::ExecuteRequest (const CPortMessage& portMessage)

{
    NTSTATUS    status;

    if (_fConnectionClosed)
    {
        status = RejectRequest(portMessage, STATUS_PORT_DISCONNECTED);
    }
    else
    {
        status = CreateAndExecuteRequest(portMessage);
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::RejectRequest
//
//  Arguments:  portMessage     =   CPortMessage of request.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sends back a reply to the caller STATUS_PORT_DISCONNECTED to
//              reject the request.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::RejectRequest (const CPortMessage& portMessage, NTSTATUS status)    const

{
    CPortMessage    portMessageOut(portMessage);

    //  Send the message back to the client.

    portMessageOut.SetDataLength(sizeof(NTSTATUS));
    portMessageOut.SetReturnCode(status);
    return(SendReply(portMessageOut));
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::Entry
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Main entry point for processing LPC requests. If there are
//              pending requests in the queue pick them off and process them.
//              While processing them more items can get queued. Keep
//              processing until there are no more queued items. There is a
//              possible overlap where a newly queued item can be missed. In
//              that case a new work item is queued to execute those requests.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CAPIDispatcher::Entry (void)

{
    CAPIRequest     *pAPIRequest;

    //  Acquire the requests pending lock before fetching the first
    //  request. This will ensure an accurate result.

    _lock.Acquire();
    pAPIRequest = static_cast<CAPIRequest*>(_queue.Get());

    //  If there are more requests in the queue keep looping.

    while (pAPIRequest != NULL)
    {

        //  Release the requests pending lock to allow more requests to
        //  get queued to this dispatcher while the dispatch is executing.

        if (!_fConnectionClosed)
        {
            NTSTATUS    status;

            //  Before executing the API request release the lock to allow
            //  more requests to get queued while executing this one.

            _lock.Release();

            //  Execute the request.

            status = Execute(pAPIRequest);

            //  Acquire the requests pending lock again before getting
            //  the next available request. If the loop continues the
            //  lock will be released at the top of the loop. If the loop
            //  exits then the lock must be released outside.

            _lock.Acquire();

            //  On debug builds ignore STATUS_REPLY_MESSAGE_MISMATCH.
            //  This typically happens on stress machines where timing
            //  causes the thread waiting on the reply to go away before
            //  the service has a chance to reply to the LPC request.

#ifdef      DEBUG
            if (!_fConnectionClosed && !ExcludedStatusCodeForDebug(status))
            {
                TSTATUS(status);
            }
#endif  /*  DEBUG   */

        }

        //  Remove this processed request.

        _queue.Remove();

        //  Get the next request. A request may have been queued while
        //  processing the request just processed. So keep looping until
        //  there really are no requests left.

        pAPIRequest = static_cast<CAPIRequest*>(_queue.Get());
    }

    //  Set the state to no longer processing requests so that any
    //  further queued requests will cause the dispatcher to be
    //  re-invoked in a new worker thread. Release the lock.

    _fRequestsPending = false;
    _lock.Release();
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::Execute
//
//  Arguments:  pAPIRequest     =   API request to execute.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute the API request. This can be done from a queued work
//              item executing on a different thread or execute in the server
//              port listen thread.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::Execute (CAPIRequest *pAPIRequest)  const

{
    NTSTATUS    status;

    //  Set the return data size to NTSTATUS by default. Execute the
    //  request. Store the result. If the executed function has more
    //  data to return it will set the size itself.

    pAPIRequest->SetDataLength(sizeof(NTSTATUS));

    //  Protect the execution with an exception block. If the code
    //  throws an exception it would normally just kill the worker
    //  thread. However, the CAPIDispatcher would be left in a state
    //  where it was marked as still executing requests even though
    //  the thread died. If an exception is thrown the function is
    //  considered unsuccessful.

    __try
    {
        status = pAPIRequest->Execute();
    }
    __except (DispatcherExceptionFilter(GetExceptionInformation()))
    {
        status = STATUS_UNSUCCESSFUL;
    }

    pAPIRequest->SetReturnCode(status);

    //  Reply to the client with the result.

    return(SendReply(*pAPIRequest));
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::CreateSection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Overridable function that creates a section object. Because
//              size is not determinable it can be inheritable.
//
//              The default implementation does nothing.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::CreateSection (void)

{
    return(STATUS_NOT_IMPLEMENTED);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::SignalRequestPending
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signals the event to wake up the thread processing requests.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::SignalRequestPending (void)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    requestsPendingLock(_lock);

    //  Only check the validity of _fRequestsPending after acquiring the
    //  lock. This will guarantee that the value of this variable is
    //  100% correct in a multi worker threaded environment.

    if (!_fRequestsPending)
    {
        _fRequestsPending = true;
        status = Queue();
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAPIDispatcher::SendReply
//
//  Arguments:  portMessage     =   CPortMessage to send in the reply.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sends a reply to the LPC port so the caller can be unblocked.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAPIDispatcher::SendReply (const CPortMessage& portMessage)     const

{
    return(NtReplyPort(_hPort, const_cast<PORT_MESSAGE*>(portMessage.GetPortMessage())));
}

#ifdef      DEBUG

//  --------------------------------------------------------------------------
//  CAPIDispatcher::ExcludedStatusCodeForDebug
//
//  Arguments:  status  =   NTSTATUS code to check.
//
//  Returns:    bool
//
//  Purpose:    Returns whether this status code should be ignored on asserts.
//
//  History:    2001-03-30  vtan        created
//  --------------------------------------------------------------------------

bool    CAPIDispatcher::ExcludedStatusCodeForDebug (NTSTATUS status)

{
    return((status == STATUS_REPLY_MESSAGE_MISMATCH) ||
           (status == STATUS_INVALID_CID));
}

#endif  /*  DEBUG   */

//  --------------------------------------------------------------------------
//  CAPIDispatcher::DispatcherExceptionFilter
//
//  Arguments:  <none>
//
//  Returns:    LONG
//
//  Purpose:    Filters exceptions that occur when dispatching API requests.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

LONG    WINAPI  CAPIDispatcher::DispatcherExceptionFilter (struct _EXCEPTION_POINTERS *pExceptionInfo)

{
    (LONG)RtlUnhandledExceptionFilter(pExceptionInfo);
    return(EXCEPTION_EXECUTE_HANDLER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\portmessage.h ===
//  --------------------------------------------------------------------------
//  Module Name: PortMessage.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class to wrap a PORT_MESSAGE struct within an object. It contains space
//  for PORT_MAXIMUM_MESSAGE_LENGTH bytes of data. Subclass this class to
//  write typed functions that access this data. Otherwise use
//  CPortMessage::GetData and type case the pointer returned.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _PortMessage_
#define     _PortMessage_

//  --------------------------------------------------------------------------
//  CPortMessage
//
//  Purpose:    This class wraps a PORT_MESSAGE structure. Subclass it to
//              write functions that access the internal data.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CPortMessage
{
    public:
                                CPortMessage (void);
                                CPortMessage (const CPortMessage& portMessage);
        virtual                 ~CPortMessage (void);
    public:
        const PORT_MESSAGE*     GetPortMessage (void)               const;
        PORT_MESSAGE*           GetPortMessage (void);
        const char*             GetData (void)                      const;
        char*                   GetData (void);

        CSHORT                  GetDataLength (void)                const;
        CSHORT                  GetType (void)                      const;
        HANDLE                  GetUniqueProcess (void)             const;
        HANDLE                  GetUniqueThread (void)              const;

        void                    SetReturnCode (NTSTATUS status);
        void                    SetData (const void *pData, CSHORT sDataSize);
        void                    SetDataLength (CSHORT sDataSize);

        NTSTATUS                OpenClientToken (HANDLE& hToken)    const;
    protected:
        PORT_MESSAGE            _portMessage;
        char                    _data[PORT_MAXIMUM_MESSAGE_LENGTH];
};

#endif  /*  _PortMessage_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\apidispatcher.h ===
//  --------------------------------------------------------------------------
//  Module Name: APIDispatcher.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class that handles API requests in the server on a separate thread. Each
//  thread is dedicated to respond to a single client. This is acceptable for
//  a lightweight server.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _APIDispatcher_
#define     _APIDispatcher_

#include "KernelResources.h"
#include "PortMessage.h"
#include "Queue.h"
#include "WorkItem.h"

class   CAPIRequest;                //  This would be circular otherwise

//  --------------------------------------------------------------------------
//  CAPIDispatcher
//
//  Purpose:    This class processes requests from a client when signaled to.
//              CAPIDispatcher::QueueRequest is called by a thread which
//              monitors an LPC port. Once the request is queued an event is
//              signaled to wake the thread which processes client requests.
//              The thread processes all queued requests and wait for the
//              event to be signaled again.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CAPIDispatcher : public CWorkItem
{
    private:
        friend  class   CCatchCorruptor;

                                    CAPIDispatcher (void);
    public:
                                    CAPIDispatcher (HANDLE hClientProcess);
        virtual                     ~CAPIDispatcher (void);

                HANDLE              GetClientProcess (void)     const;
                DWORD               GetClientSessionID (void)   const;
                void                SetPort (HANDLE hPort);
                HANDLE              GetSection (void);
                void*               GetSectionAddress (void)    const;
                NTSTATUS            CloseConnection (void);
                NTSTATUS            QueueRequest (const CPortMessage& portMessage);
                NTSTATUS            ExecuteRequest (const CPortMessage& portMessage);
                NTSTATUS            RejectRequest (const CPortMessage& portMessage, NTSTATUS status)    const;
        virtual NTSTATUS            CreateAndQueueRequest (const CPortMessage& portMessage) = 0;
        virtual NTSTATUS            CreateAndExecuteRequest (const CPortMessage& portMessage) = 0;
    protected:
        virtual void                Entry (void);
                NTSTATUS            Execute (CAPIRequest *pAPIRequest)  const;
        virtual NTSTATUS            CreateSection (void);

                NTSTATUS            SignalRequestPending (void);
    private:
                NTSTATUS            SendReply (const CPortMessage& portMessage)     const;
#ifdef      DEBUG
        static  bool                ExcludedStatusCodeForDebug (NTSTATUS status);
#endif  /*  DEBUG   */
        static  LONG        WINAPI  DispatcherExceptionFilter (struct _EXCEPTION_POINTERS *pExceptionInfo);
    protected:
                HANDLE              _hSection;
                void*               _pSection;
                CQueue              _queue;
    private:
                HANDLE              _hProcessClient;
                HANDLE              _hPort;
                bool                _fRequestsPending,
                                    _fConnectionClosed;
                CCriticalSection    _lock;
};

#endif  /*  _APIDispatcher_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\queue.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Queue.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains a class to handle a queue element and a class to handle
//  a queue of queue elements.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Queue.h"

#include "SingleThreadedExecution.h"

//  --------------------------------------------------------------------------
//  CQueueElement::CQueueElement
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CQueueElement.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueueElement::CQueueElement (void) :
    _pNextElement(NULL)

{
}

//  --------------------------------------------------------------------------
//  CQueueElement::~CQueueElement
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CQueueElement.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueueElement::~CQueueElement (void)

{
}

//  --------------------------------------------------------------------------
//  CQueue::CQueue
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CQueue.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueue::CQueue (void) :
    _pQueue(NULL)

{
}

//  --------------------------------------------------------------------------
//  CQueue::~CQueue
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CQueue.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueue::~CQueue (void)

{
    while (_pQueue != NULL)
    {
        CQueueElement   *pNextElement;

        pNextElement = _pQueue->_pNextElement;
        delete _pQueue;
        _pQueue = pNextElement;
    }
}

//  --------------------------------------------------------------------------
//  CQueue::Add
//
//  Arguments:  pQueueElement   =   CQueueElement to add to the queue.
//
//  Returns:    <none>
//
//  Purpose:    Adds the CQueueElement to the queue. Queue manipulation is
//              guarded by a critical section because one thread may be
//              queuing elements while another thread is processesing them.
//
//              You must provide a dynamically created CQueueElement object.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CQueue::Add (CQueueElement *pQueueElement)

{
    if (pQueueElement != NULL)
    {
        CQueueElement               *pCurrentElement, *pLastElement;
        CSingleThreadedExecution    queueLock(_lock);

        pLastElement = pCurrentElement = _pQueue;
        while (pCurrentElement != NULL)
        {
            pLastElement = pCurrentElement;
            pCurrentElement = pCurrentElement->_pNextElement;
        }
        if (pLastElement != NULL)
        {
            pLastElement->_pNextElement = pQueueElement;
        }
        else
        {
            _pQueue = pQueueElement;
        }
    }
}

//  --------------------------------------------------------------------------
//  CQueue::Remove
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Removes the first element from the queue. The queue is a
//              standard FIFO structure. The CQueueElement is deleted. There
//              is no reference counting because these are internal items.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CQueue::Remove (void)

{
    CSingleThreadedExecution    queueLock(_lock);

    if (_pQueue != NULL)
    {
        CQueueElement   *pNextElement;

        pNextElement = _pQueue->_pNextElement;
        delete _pQueue;
        _pQueue = pNextElement;
    }
}

//  --------------------------------------------------------------------------
//  CQueue::Get
//
//  Arguments:  <none>
//
//  Returns:    CQueueElement*
//
//  Purpose:    Returns the first CQueueElement in the queue.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CQueueElement*  CQueue::Get (void)  const

{
    return(_pQueue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\queue.h ===
//  --------------------------------------------------------------------------
//  Module Name: Queue.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains a class to handle a queue element and a class to handle
//  a queue of queue elements.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _Queue_
#define     _Queue_

#include "DynamicObject.h"
#include "KernelResources.h"

//  --------------------------------------------------------------------------
//  CQueueElement
//
//  Purpose:    This is the queue element base class. It contains a field
//              which the queue manages.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CQueueElement : public CDynamicObject
{
    private:
        friend  class   CQueue;
    public:
                                    CQueueElement (void);
        virtual                     ~CQueueElement (void);
    private:
                CQueueElement*      _pNextElement;
};

//  --------------------------------------------------------------------------
//  CQueue
//
//  Purpose:    This is the queue manager class. It manages queue elements.
//              Because the queue may be called from two threads that act on
//              the same object (one thread reads the queue to process
//              requests and the other adds to the queue to queue requests)
//              a critical section is required to process queue manipulation.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CQueue
{
    public:
                                    CQueue (void);
                                    ~CQueue (void);

                void                Add (CQueueElement *pQueueElement);
                void                Remove (void);
                CQueueElement*      Get (void)  const;
    private:
                CQueueElement*      _pQueue;
                CCriticalSection    _lock;
};

#endif  /*  _Queue_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\portmessage.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: PortMessage.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  A class to wrap a PORT_MESSAGE struct within an object. It contains space
//  for PORT_MAXIMUM_MESSAGE_LENGTH bytes of data. Subclass this class to
//  write typed functions that access this data. Otherwise use
//  CPortMessage::GetData and type case the pointer returned.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "PortMessage.h"

#include "LPCGeneric.h"

//  --------------------------------------------------------------------------
//  CPortMessage::CPortMessage
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CPortMessage. Zero the memory.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CPortMessage::CPortMessage (void)

{
    ZeroMemory(&_portMessage, sizeof(_portMessage));
    ZeroMemory(_data, sizeof(_data));
}

//  --------------------------------------------------------------------------
//  CPortMessage::CPortMessage
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Copy constructor for CPortMessage. Copies the given
//              CPortMessage and all the data in it to the member variable.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CPortMessage::CPortMessage (const CPortMessage& portMessage) :
    _portMessage(*portMessage.GetPortMessage())

{
    ASSERTMSG(portMessage.GetDataLength() < PORT_MAXIMUM_MESSAGE_LENGTH, "Impending heap corruption (illegal PORT_MESSAGE) in CPortMessage::CPortMessage");
    CopyMemory(_data, portMessage.GetPortMessage() + 1, portMessage.GetDataLength());
}

//  --------------------------------------------------------------------------
//  CPortMessage::~CPortMessage
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CPortMessage.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CPortMessage::~CPortMessage (void)

{
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetPortMessage
//
//  Arguments:  <none>
//
//  Returns:    const PORT_MESSAGE*
//
//  Purpose:    Returns a pointer to the PORT_MESSAGE struct for const
//              objects.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

const PORT_MESSAGE*     CPortMessage::GetPortMessage (void)               const

{
    return(&_portMessage);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetPortMessage
//
//  Arguments:  <none>
//
//  Returns:    const PORT_MESSAGE*
//
//  Purpose:    Returns a pointer to the PORT_MESSAGE struct for non-const
//              objects.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

PORT_MESSAGE*   CPortMessage::GetPortMessage (void)

{
    return(&_portMessage);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetData
//
//  Arguments:  <none>
//
//  Returns:    const char*
//
//  Purpose:    Returns a pointer to the data area for const objects.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

const char*     CPortMessage::GetData (void)                      const

{
    return(_data);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetData
//
//  Arguments:  <none>
//
//  Returns:    char*
//
//  Purpose:    Returns a pointer to the data area for non-const objects.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

char*     CPortMessage::GetData (void)

{
    return(_data);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetDataLength
//
//  Arguments:  <none>
//
//  Returns:    CSHORT
//
//  Purpose:    Returns the length of the data sent in the PORT_MESSAGE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CSHORT  CPortMessage::GetDataLength (void)                const

{
    return(_portMessage.u1.s1.DataLength);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetType
//
//  Arguments:  <none>
//
//  Returns:    CSHORT
//
//  Purpose:    Returns the type of message sent in the PORT_MESSAGE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CSHORT  CPortMessage::GetType (void)                      const

{
    #pragma warning (disable:4310)
    return(static_cast<CSHORT>(_portMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE));
    #pragma warning (default:4310)
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetUniqueProcess
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the process ID of the client process sent in the
//              PORT_MESSAGE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

HANDLE  CPortMessage::GetUniqueProcess (void)             const

{
    return(_portMessage.ClientId.UniqueProcess);
}

//  --------------------------------------------------------------------------
//  CPortMessage::GetUniqueThread
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the thread ID of the client process sent in the
//              PORT_MESSAGE.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

HANDLE  CPortMessage::GetUniqueThread (void)              const

{
    return(_portMessage.ClientId.UniqueThread);
}

//  --------------------------------------------------------------------------
//  CPortMessage::SetReturnCode
//
//  Arguments:  status  =   NTSTATUS to send back to client.
//
//  Returns:    <none>
//
//  Purpose:    Sets the return NTSTATUS code in the PORT_MESSAGE to send
//              back to the client.
//
//  History:    1999-11-12  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CPortMessage::SetReturnCode (NTSTATUS status)

{
    reinterpret_cast<API_GENERIC*>(&_data)->status = status;
}

//  --------------------------------------------------------------------------
//  CPortMessage::SetData
//
//  Arguments:  pData       =   Pointer to data passed in.
//              ulDataSize  =   Size of data passed in.
//
//  Returns:    <none>
//
//  Purpose:    Copies the given data to the port message buffer that follows
//              the PORT_MESSAGE struct and set the PORT_MESSAGE sizes to
//              match the data size.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CPortMessage::SetData (const void *pData, CSHORT sDataSize)

{
    ASSERTMSG(sDataSize < (sizeof(PORT_MAXIMUM_MESSAGE_LENGTH) - sizeof(PORT_MESSAGE)), "Too much data passed to CPortMessage::SetData");
    CopyMemory(_data, pData, sDataSize);
    _portMessage.u1.s1.DataLength = sDataSize;
    _portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(PORT_MESSAGE) + sDataSize);
}

//  --------------------------------------------------------------------------
//  CPortMessage::SetDataLength
//
//  Arguments:  ulDataSize  =   Size of data.
//
//  Returns:    <none>
//
//  Purpose:    Set the PORT_MESSAGE sizes to match the data size.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

void    CPortMessage::SetDataLength (CSHORT sDataSize)

{
    ASSERTMSG(sDataSize < (sizeof(PORT_MAXIMUM_MESSAGE_LENGTH) - sizeof(PORT_MESSAGE)), "Length too large in CPortMessage::SetDataLength");
    _portMessage.u1.s1.DataLength = sDataSize;
    _portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(PORT_MESSAGE) + sDataSize);
}

//  --------------------------------------------------------------------------
//  CPortMessage::OpenClientToken
//
//  Arguments:  hToken  =   HANDLE to the token of the client.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Gets the token of the client. This can be the thread
//              impersonation token, the process primary token or failure.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CPortMessage::OpenClientToken (HANDLE& hToken)    const

{
    NTSTATUS            status;
    HANDLE              hThread;
    OBJECT_ATTRIBUTES   objectAttributes;
    CLIENT_ID           clientID;

    hToken = NULL;
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);
    clientID.UniqueProcess = NULL;
    clientID.UniqueThread = GetUniqueThread();
    status = NtOpenThread(&hThread, THREAD_QUERY_INFORMATION, &objectAttributes, &clientID);
    if (NT_SUCCESS(status))
    {
        (NTSTATUS)NtOpenThreadToken(hThread, TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY, FALSE, &hToken);
        TSTATUS(NtClose(hThread));
    }
    if (hToken == NULL)
    {
        HANDLE  hProcess;

        clientID.UniqueProcess = GetUniqueProcess();
        clientID.UniqueThread = NULL;
        status = NtOpenProcess(&hProcess, PROCESS_QUERY_INFORMATION, &objectAttributes, &clientID);
        if (NT_SUCCESS(status))
        {
            (NTSTATUS)NtOpenProcessToken(hProcess, TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY, &hToken);
        }
        TSTATUS(NtClose(hProcess));
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\serverapi.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ServerAPI.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  An abstract base class containing virtual functions that allow the basic
//  port functionality code to be reused to create another server. These
//  virtual functions create other objects with pure virtual functions which
//  the basic port functionality code invokes thru the v-table.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ServerAPI.h"

#include <lpcgeneric.h>

#include "APIConnection.h"
#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CServerAPI::CServerAPI
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the abstract base class.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CServerAPI::CServerAPI (void)

{
}

//  --------------------------------------------------------------------------
//  CServerAPI::~CServerAPI
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the abstract base class.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CServerAPI::~CServerAPI (void)

{
}

//  --------------------------------------------------------------------------
//  CServerAPI::Start
//
//  Arguments:  
//
//  Returns:    NTSTATUS
//
//  Purpose:    Uses the service control manager to start the service.
//
//  History:    2000-10-13  vtan        created
//              2000-11-28  vtan        rewrote for Win32 services
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::Start (void)

{
    NTSTATUS    status;
    SC_HANDLE   hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, GetServiceName(), SERVICE_START);
        if (hSCService != NULL)
        {
            if (StartService(hSCService, 0, NULL) != FALSE)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CServerAPI::Stop
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Use the service control manager to stop the service.
//
//  History:    2000-10-17  vtan        created
//              2000-11-28  vtan        rewrote for Win32 services
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::Stop (void)

{
    NTSTATUS    status;
    HANDLE      hPort;

    //  First try connecting to the server and asking it to stop. This is
    //  cleanest method.

    status = Connect(&hPort);
    if (NT_SUCCESS(status))
    {
        NTSTATUS        status;
        API_GENERIC     apiRequest;
        CPortMessage    portMessageIn, portMessageOut;

        apiRequest.ulAPINumber = API_GENERIC_STOPSERVER;
        portMessageIn.SetData(&apiRequest, sizeof(apiRequest));
        status = NtRequestWaitReplyPort(hPort,
                                        portMessageIn.GetPortMessage(),
                                        portMessageOut.GetPortMessage());
        if (NT_SUCCESS(status))
        {
            status = reinterpret_cast<const API_GENERIC*>(portMessageOut.GetData())->status;
        }
        TBOOL(CloseHandle(hPort));
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CServerAPI::IsRunning
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Use the service control manager to query whether the service
//              is running.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

bool    CServerAPI::IsRunning (void)

{
    bool        fRunning;
    SC_HANDLE   hSCManager;

    fRunning = false;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, GetServiceName(), SERVICE_QUERY_STATUS);
        if (hSCService != NULL)
        {
            SERVICE_STATUS  serviceStatus;

            if (QueryServiceStatus(hSCService, &serviceStatus) != FALSE)
            {
                fRunning = (serviceStatus.dwCurrentState == SERVICE_RUNNING);
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    return(fRunning);
}

//  --------------------------------------------------------------------------
//  CServerAPI::IsAutoStart
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Use the service contorl manager to find out if the service
//              is configured to be an automatically started service.
//
//  History:    2000-11-30  vtan        created
//  --------------------------------------------------------------------------

bool    CServerAPI::IsAutoStart (void)

{
    bool        fAutoStart;
    SC_HANDLE   hSCManager;

    fAutoStart = false;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, GetServiceName(), SERVICE_QUERY_CONFIG);
        if (hSCService != NULL)
        {
            DWORD                   dwBytesNeeded;
            QUERY_SERVICE_CONFIG    *pServiceConfig;

            (BOOL)QueryServiceConfig(hSCService, NULL, 0, &dwBytesNeeded);
            pServiceConfig = static_cast<QUERY_SERVICE_CONFIG*>(LocalAlloc(LMEM_FIXED, dwBytesNeeded));
            if (pServiceConfig != NULL)
            {
                if (QueryServiceConfig(hSCService, pServiceConfig, dwBytesNeeded, &dwBytesNeeded) != FALSE)
                {
                    fAutoStart = (pServiceConfig->dwStartType == SERVICE_AUTO_START);
                }
                (HLOCAL)LocalFree(pServiceConfig);
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    return(fAutoStart);
}

//  --------------------------------------------------------------------------
//  CServerAPI::Wait
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Waits for the service control manager to return the state that
//              the service is running. This does not check that the service
//              is auto start or not. You can only call this function if the
//              service is auto start or you demand started the service.
//              Otherwise the function will timeout.
//
//  History:    2000-11-28  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::Wait (DWORD dwTimeout)

{
    NTSTATUS    status;
    SC_HANDLE   hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, GetServiceName(), SERVICE_QUERY_STATUS);
        if (hSCService != NULL)
        {
            SERVICE_STATUS  serviceStatus;

            if (QueryServiceStatus(hSCService, &serviceStatus) != FALSE)
            {
                status = STATUS_SUCCESS;
                if (serviceStatus.dwCurrentState != SERVICE_RUNNING)
                {
                    bool    fTimedOut;
                    DWORD   dwTickStart;

                    dwTickStart = GetTickCount();
                    fTimedOut = ((GetTickCount() - dwTickStart) >= dwTimeout);
                    while (NT_SUCCESS(status) &&
                           !fTimedOut &&
                           (serviceStatus.dwCurrentState != SERVICE_RUNNING) &&
                           (serviceStatus.dwCurrentState != SERVICE_STOP_PENDING))
                    {
                        Sleep(50);
                        if (QueryServiceStatus(hSCService, &serviceStatus) != FALSE)
                        {
                            fTimedOut = ((GetTickCount() - dwTickStart) >= dwTimeout);
                        }
                        else
                        {
                            status = CStatusCode::StatusCodeOfLastError();
                        }
                    }
                    if (serviceStatus.dwCurrentState == SERVICE_RUNNING)
                    {
                        status = STATUS_SUCCESS;
                    }
                    else if (fTimedOut)
                    {
                        status = STATUS_TIMEOUT;
                    }
                    else
                    {
                        status = STATUS_UNSUCCESSFUL;
                    }
#ifdef      DBG
                    char    sz[256];

                    wsprintfA(sz, "Waited %d ticks for theme service", GetTickCount() - dwTickStart);
                    INFORMATIONMSG(sz);
#endif  /*  DBG     */
                }
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CServerAPI::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes static member variables for this class. Must be
//              called by subclasses of this class.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::StaticInitialize (void)

{
#ifdef  DBG
    TSTATUS(CDebug::StaticInitialize());
#endif
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CServerAPI::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases static resources used by this class.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CServerAPI::StaticTerminate (void)

{
#ifdef  DBG
    TSTATUS(CDebug::StaticTerminate());
#endif
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CServerAPI::IsClientTheSystem
//
//  Arguments:  portMessage     =   CPortMessage from the client.
//
//  Returns:    bool
//
//  Purpose:    Determines whether the client in the port message is the local
//              system account.
//
//  History:    1999-12-13  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

bool    CServerAPI::IsClientTheSystem (const CPortMessage& portMessage)

{
    bool    fResult;
    HANDLE  hToken;

    if (NT_SUCCESS(portMessage.OpenClientToken(hToken)))
    {
        CTokenInformation   tokenInformation(hToken);

        fResult = tokenInformation.IsUserTheSystem();
        ReleaseHandle(hToken);
    }
    else
    {
        fResult = false;
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CServerAPI::IsClientAnAdministrator
//
//  Arguments:  portMessage     =   CPortMessage from the client.
//
//  Returns:    bool
//
//  Purpose:    Determines whether the client in the port message is an
//              administrator.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

bool    CServerAPI::IsClientAnAdministrator (const CPortMessage& portMessage)

{
    bool    fResult;
    HANDLE  hToken;

    if (NT_SUCCESS(portMessage.OpenClientToken(hToken)))
    {
        CTokenInformation   tokenInformation(hToken);

        fResult = tokenInformation.IsUserAnAdministrator();
        ReleaseHandle(hToken);
    }
    else
    {
        fResult = false;
    }
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\workitem.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: WorkItem.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements the handling of queuing a work item and calling the
//  entry point of the work item function when entered in a worker thread.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "WorkItem.h"

#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CWorkItem::CWorkItem
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CWorkItem.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CWorkItem::CWorkItem (void)

{
}

//  --------------------------------------------------------------------------
//  CWorkItem::~CWorkItem
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CWorkItem.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CWorkItem::~CWorkItem (void)

{
}

//  --------------------------------------------------------------------------
//  CWorkItem::Queue
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Queues the work item entry function to be executed.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

NTSTATUS    CWorkItem::Queue (void)

{
    NTSTATUS    status;

    //  Initially add a reference to this work item. If the queue succeeds
    //  then leave the reference for WorkItemEntryProc to release. Otherwise
    //  on failure release the reference.

    AddRef();
    if (QueueUserWorkItem(WorkItemEntryProc, this, WT_EXECUTEDEFAULT) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        Release();
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CWorkItem::WorkItemEntryProc
//
//  Arguments:  pParameter  =   Context pointer passed in when queued.
//
//  Returns:    DWORD
//
//  Purpose:    Callback entry point for queued work item. Takes the context
//              pointer and calls the virtual function that implements the
//              actual work.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

DWORD   WINAPI  CWorkItem::WorkItemEntryProc (void *pParameter)

{
    CWorkItem   *pWorkItem;

    pWorkItem = reinterpret_cast<CWorkItem*>(pParameter);
    pWorkItem->Entry();
    pWorkItem->Release();
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\serverapi.h ===
//  --------------------------------------------------------------------------
//  Module Name: ServerAPI.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  An abstract base class containing virtual functions that allow the basic
//  port functionality code to be reused to create another server. These
//  virtual functions create other objects with pure virtual functions which
//  the basic port functionality code invokes thru the v-table.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _ServerAPI_
#define     _ServerAPI_

#include "APIDispatcher.h"
#include "CountedObject.h"
#include "PortMessage.h"

class   CAPIConnection;         //  This would be circular otherwise

//  --------------------------------------------------------------------------
//  CServerAPI
//
//  Purpose:    The abstract base class which the server connection monitor
//              thread uses to determine whether server connection should be
//              accepted or rejected as well as creating threads to process
//              client requests.
//
//  History:    1999-11-07  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CServerAPI : public CCountedObject
{
    protected:
                                    CServerAPI (void);
        virtual                     ~CServerAPI (void);
    public:
        virtual const WCHAR*        GetPortName (void) = 0;
        virtual const TCHAR*        GetServiceName (void) = 0;
        virtual bool                ConnectionAccepted (const CPortMessage& portMessage) = 0;
        virtual CAPIDispatcher*     CreateDispatcher (const CPortMessage& portMessage) = 0;
        virtual NTSTATUS            Connect (HANDLE* phPort) = 0;

                NTSTATUS            Start (void);
                NTSTATUS            Stop (void);
                bool                IsRunning (void);
                bool                IsAutoStart (void);
                NTSTATUS            Wait (DWORD dwTimeout);

        static  NTSTATUS            StaticInitialize (void);
        static  NTSTATUS            StaticTerminate (void);
    protected:
        static  bool                IsClientTheSystem (const CPortMessage& portMessage);
        static  bool                IsClientAnAdministrator (const CPortMessage& portMessage);
};

#endif  /*  _ServerAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\service.h ===
//  --------------------------------------------------------------------------
//  Module Name: Service.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements generic portions of a Win32
//  serivce.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _Service_
#define     _Service_

#include "APIConnection.h"

//  --------------------------------------------------------------------------
//  CService
//
//  Purpose:    Base class implementation of a service for the service control
//              manager.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

class   CService : public CCountedObject
{
    private:
        friend  class   CServiceWorkItem;

                                        CService (void);
    protected:
                                        CService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI, const TCHAR *pszServiceName);
        virtual                         ~CService (void);
    public:
                void                    Start (void);

        static  NTSTATUS                Install (const TCHAR *pszName,
                                                 const TCHAR *pszImage,
                                                 const TCHAR *pszGroup,
                                                 const TCHAR *pszAccount,
                                                 const TCHAR *pszDllName,
                                                 const TCHAR *pszDependencies,
                                                 const TCHAR *pszSvchostGroup,
                                                 const TCHAR *pszServiceMainName,
                                                 DWORD dwStartType,
                                                 HINSTANCE hInstance,
                                                 UINT uiDisplayNameID,
                                                 UINT uiDescriptionID,
                                                 SERVICE_FAILURE_ACTIONS *psfa = NULL);
        static  NTSTATUS                Remove (const TCHAR *pszName);

    protected:
        virtual NTSTATUS                Signal (void);
        virtual DWORD                   HandlerEx (DWORD dwControl);
    private:
        static  DWORD   WINAPI          CB_HandlerEx (DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);

        static  NTSTATUS                AddService (const TCHAR *pszName,
                                                    const TCHAR *pszImage,
                                                    const TCHAR *pszGroup,
                                                    const TCHAR *pszAccount,
                                                    const TCHAR *pszDependencies,
                                                    DWORD dwStartType,
                                                    HINSTANCE hInstance,
                                                    UINT uiDisplayNameID,
                                                    SERVICE_FAILURE_ACTIONS *psfa = NULL);
        static  NTSTATUS                AddServiceDescription (const TCHAR *pszName, HINSTANCE hInstance, UINT uiDescriptionID);
        static  NTSTATUS                AddServiceParameters (const TCHAR *pszName, const TCHAR *pszDllName, const TCHAR *pszServiceMainName);
        static  NTSTATUS                AddServiceToGroup (const TCHAR *pszName, const TCHAR *pszSvchostGroup);
        static  bool                    StringInMulitpleStringList (const TCHAR *pszStringList, const TCHAR *pszString);
        static  void                    StringInsertInMultipleStringList (TCHAR *pszStringList, const TCHAR *pszString, DWORD dwStringListSize);
    protected:
                SERVICE_STATUS_HANDLE   _hService;
                SERVICE_STATUS          _serviceStatus;
                const TCHAR*            _pszServiceName;
                CAPIConnection*         _pAPIConnection;
                CServerAPI*             _pServerAPI;
};

//  --------------------------------------------------------------------------
//  CServiceWorkItem
//
//  Purpose:    Work item class to stop the server using the CServerAPI class.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

class   CServiceWorkItem : public CWorkItem
{
    private:
                                        CServiceWorkItem (void);
    public:
                                        CServiceWorkItem (CServerAPI *pServerAPI);
        virtual                         ~CServiceWorkItem (void);
    protected:
        virtual void                    Entry (void);
    private:
                CServerAPI*             _pServerAPI;
};

#endif  /*  _Service_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\service.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Service.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements generic portions of a Win32
//  serivce.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Service.h"

#include "RegistryResources.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CService::CService
//
//  Arguments:  pAPIConnection  =   CAPIConnection used to implement service.
//              pServerAPI      =   CServerAPI used to stop service.
//              pszServiceName  =   Name of service.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CService.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CService::CService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI, const TCHAR *pszServiceName) :
    _hService(NULL),
    _pszServiceName(pszServiceName),
    _pAPIConnection(pAPIConnection),
    _pServerAPI(pServerAPI)

{
    ZeroMemory(&_serviceStatus, sizeof(_serviceStatus));
    pAPIConnection->AddRef();
    pServerAPI->AddRef();
}

//  --------------------------------------------------------------------------
//  CService::~CService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CService. Release used resources.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CService::~CService (void)

{
    _pServerAPI->Release();
    _pServerAPI = NULL;
    _pAPIConnection->Release();
    _pAPIConnection = NULL;
    ASSERTMSG(_hService == NULL, "_hService should be released in CService::~CService");
}

//  --------------------------------------------------------------------------
//  CService::Start
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Called from ServiceMain of the service. This registers the
//              handler and starts the service (listens to the API port).
//              When the listen call returns it sets the status of the service
//              as stopped and exits.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

void    CService::Start (void)

{

    //  Add a reference for the HandlerEx callback. When the handler receives
    //  a stop code it will release its reference.

    AddRef();
    _hService = RegisterServiceCtrlHandlerEx(_pszServiceName, CB_HandlerEx, this);
    if (_hService != NULL)
    {
        NTSTATUS    status;

        _serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
        _serviceStatus.dwCurrentState = SERVICE_RUNNING;
        _serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
        _serviceStatus.dwWin32ExitCode = NO_ERROR;
        _serviceStatus.dwCheckPoint = 0;
        _serviceStatus.dwWaitHint = 0;
        TBOOL(SetServiceStatus(_hService, &_serviceStatus));
        TSTATUS(Signal());
        status = _pAPIConnection->Listen();
        _serviceStatus.dwCurrentState = SERVICE_STOPPED;
        _serviceStatus.dwWin32ExitCode = CStatusCode::ErrorCodeOfStatusCode(status);
        _serviceStatus.dwCheckPoint = 0;
        _serviceStatus.dwWaitHint = 0;
        TBOOL(SetServiceStatus(_hService, &_serviceStatus));
        _hService = NULL;
    }
    else
    {
        Release();
    }
}

//  --------------------------------------------------------------------------
//  CService::Install
//
//  Arguments:  pszName             =   Name of the service.
//              pszImage            =   Executable image of the service.
//              pszGroup            =   Group to which the service belongs.
//              pszAccount          =   Account under which the service runs.
//              pszDllName          =   Name of the hosting dll.
//              pszDependencies     =   Any dependencies the service has.
//              pszSvchostGroup     =   The svchost group.
//              dwStartType         =   Start type of the service.
//              hInstance           =   HINSTANCE for resources.
//              uiDisplayNameID     =   Resource ID of the display name.
//              uiDescriptionID     =   Resource ID of the description.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Use the service control manager to create the service. Add
//              additional information that CreateService does not allow us to
//              directly specify and add additional information that is
//              required to run in svchost.exe as a shared service process.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::Install (const TCHAR *pszName,
                               const TCHAR *pszImage,
                               const TCHAR *pszGroup,
                               const TCHAR *pszAccount,
                               const TCHAR *pszDllName,
                               const TCHAR *pszDependencies,
                               const TCHAR *pszSvchostGroup,
                               const TCHAR *pszServiceMainName,
                               DWORD dwStartType,
                               HINSTANCE hInstance,
                               UINT uiDisplayNameID,
                               UINT uiDescriptionID,
                               SERVICE_FAILURE_ACTIONS *psfa)

{
    NTSTATUS    status;

    status = AddService(pszName, pszImage, pszGroup, pszAccount, pszDependencies, dwStartType, hInstance, uiDisplayNameID, psfa);
    if (NT_SUCCESS(status))
    {
        status = AddServiceDescription(pszName, hInstance, uiDescriptionID);
        if (NT_SUCCESS(status))
        {
            status = AddServiceParameters(pszName, pszDllName, pszServiceMainName);
            if (NT_SUCCESS(status))
            {
                status = AddServiceToGroup(pszName, pszSvchostGroup);
            }
        }
    }
    if (!NT_SUCCESS(status))
    {
        TSTATUS(Remove(pszName));
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CService::Remove
//
//  Arguments:  pszName     =   Name of service to remove.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Use the service control manager to delete the service. This
//              doesn't clean up the turds left for svchost usage.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::Remove (const TCHAR *pszName)

{
    NTSTATUS    status;
    SC_HANDLE   hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCService;

        hSCService = OpenService(hSCManager, pszName, DELETE);
        if (hSCService != NULL)
        {
            if (DeleteService(hSCService) != FALSE)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }
            TBOOL(CloseServiceHandle(hSCService));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CService::Signal
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Base class implementation of signal service started function.
//              This does nothing.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::Signal (void)

{
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CService::HandlerEx
//
//  Arguments:  dwControl   =   Control code from service control manager.
//
//  Returns:    DWORD
//
//  Purpose:    HandlerEx function for the service. The base class implements
//              most of the useful things that the service will want to do.
//              It's declared virtual in case overriding is required.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

DWORD   CService::HandlerEx (DWORD dwControl)

{
    DWORD                   dwErrorCode;
    SERVICE_STATUS_HANDLE   hService;

    hService = _hService;
    switch (dwControl)
    {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
        {
            NTSTATUS            status;
            CServiceWorkItem    *pServiceWorkItem;

            //  In the stop/shutdown case respond to the message by setting
            //  the status to SERVICE_STOP_PENDING. Create a workitem to end
            //  the main service thread by sending an LPC request down the
            //  port telling it to quit. This call can only succeed if it
            //  comes from within the process. If the queue fails the stop
            //  the server inline on the shared dispatcher thread.

            _serviceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            TBOOL(SetServiceStatus(hService, &_serviceStatus));
            pServiceWorkItem = new CServiceWorkItem(_pServerAPI);
            if (pServiceWorkItem != NULL)
            {
                status = pServiceWorkItem->Queue();
                pServiceWorkItem->Release();
            }
            else
            {
                status = STATUS_NO_MEMORY;
            }
            if (!NT_SUCCESS(status))
            {
                TSTATUS(_pServerAPI->Stop());
            }
            hService = NULL;
            dwErrorCode = CStatusCode::ErrorCodeOfStatusCode(status);
            break;
        }
        case SERVICE_CONTROL_PAUSE:
            dwErrorCode = ERROR_CALL_NOT_IMPLEMENTED;
            break;
        case SERVICE_CONTROL_CONTINUE:
            dwErrorCode = ERROR_CALL_NOT_IMPLEMENTED;
            break;
        case SERVICE_CONTROL_INTERROGATE:
            dwErrorCode = NO_ERROR;
            break;
        case SERVICE_CONTROL_PARAMCHANGE:
        case SERVICE_CONTROL_NETBINDADD:
        case SERVICE_CONTROL_NETBINDREMOVE:
        case SERVICE_CONTROL_NETBINDENABLE:
        case SERVICE_CONTROL_NETBINDDISABLE:
        case SERVICE_CONTROL_DEVICEEVENT:
        case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
        case SERVICE_CONTROL_POWEREVENT:
            dwErrorCode = ERROR_CALL_NOT_IMPLEMENTED;
            break;
        default:
            DISPLAYMSG("Unknown service control code passed to CService::HandlerEx");
            dwErrorCode = ERROR_CALL_NOT_IMPLEMENTED;
            break;
    }

    //  If the SERVICE_STATUS_HANDLE is still valid then set the service
    //  status code. Otherwise the service thread has been terminated by
    //  a SERVICE_CONTROL_STOP or SERVICE_CONTROL_SHUTDOWN code.

    if (hService != NULL)
    {
        TBOOL(SetServiceStatus(hService, &_serviceStatus));
    }
    else
    {

        //  In the stop case release the reference so the object is destroyed.

        Release();
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CService::CB_HandlerEx
//
//  Arguments:  See the platform SDK under HandlerEx.
//
//  Returns:    DWORD
//
//  Purpose:    Static function stub to call into the class.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CService::CB_HandlerEx (DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)

{
    UNREFERENCED_PARAMETER(dwEventType);
    UNREFERENCED_PARAMETER(lpEventData);

    return(reinterpret_cast<CService*>(lpContext)->HandlerEx(dwControl));
}

//  --------------------------------------------------------------------------
//  CService:AddService
//
//  Arguments:  pszName             =   Name of the service.
//              pszImage            =   Executable image of the service.
//              pszGroup            =   Group to which the service belongs.
//              pszAccount          =   Account under which the service runs.
//              pszDependencies     =   Any dependencies the service has.
//              dwStartType         =   Start type of the service.
//              hInstance           =   HINSTANCE for resources.
//              uiDisplayNameID     =   Resource ID of the display name.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Uses the service control manager to create the service and add
//              it into the database.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::AddService (const TCHAR *pszName,
                                  const TCHAR *pszImage,
                                  const TCHAR *pszGroup,
                                  const TCHAR *pszAccount,
                                  const TCHAR *pszDependencies,
                                  DWORD dwStartType,
                                  HINSTANCE hInstance,
                                  UINT uiDisplayNameID,
                                  SERVICE_FAILURE_ACTIONS *psfa)

{
    DWORD       dwErrorCode;
    SC_HANDLE   hSCManager;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (hSCManager != NULL)
    {
        TCHAR   sz[256];

        if (LoadString(hInstance, uiDisplayNameID, sz, ARRAYSIZE(sz)) != 0)
        {
            SC_HANDLE   hSCService;

            hSCService = CreateService(hSCManager,
                                       pszName,
                                       sz,
                                       SERVICE_ALL_ACCESS,
                                       SERVICE_WIN32_SHARE_PROCESS,
                                       dwStartType,
                                       SERVICE_ERROR_NORMAL,
                                       pszImage,
                                       pszGroup,
                                       NULL,
                                       pszDependencies,
                                       pszAccount,
                                       NULL);
            if (hSCService != NULL)
            {
                // Apply the failure action configuration, if any
                if (psfa != NULL)
                {
                    // If CreateService succeeded, why would this fail?
                    TBOOL(ChangeServiceConfig2(hSCService, SERVICE_CONFIG_FAILURE_ACTIONS, psfa));
                }

                TBOOL(CloseServiceHandle(hSCService));
                dwErrorCode = ERROR_SUCCESS;
            }
            else
            {

                //  Blow off ERROR_SERVICE_EXISTS. If in the future the need
                //  to change the configuration arises add the code here.

                dwErrorCode = GetLastError();
                if (dwErrorCode == ERROR_SERVICE_EXISTS)
                {
                    dwErrorCode = ERROR_SUCCESS;

                    // Apply the failure action configuration, if any
                    if (psfa != NULL)
                    {
                        hSCService = OpenService(hSCManager, pszName, SERVICE_ALL_ACCESS);
                        if (hSCService != NULL)
                        {
                            TBOOL(ChangeServiceConfig2(hSCService, SERVICE_CONFIG_FAILURE_ACTIONS, psfa));
                            TBOOL(CloseServiceHandle(hSCService));
                        }
                    }
                }
            }
            TBOOL(CloseServiceHandle(hSCManager));
        }
        else
        {
            dwErrorCode = GetLastError();
        }
    }
    else
    {
        dwErrorCode = GetLastError();
    }
    return(CStatusCode::StatusCodeOfErrorCode(dwErrorCode));
}

//  --------------------------------------------------------------------------
//  CService:AddServiceDescription
//
//  Arguments:  pszName             =   Name of service.
//              hInstance           =   HINSTANCE of module.
//              uiDescriptionID     =   Resource ID of description.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reads the string resource from the given location and writes
//              it as the description of the given service in the registry.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::AddServiceDescription (const TCHAR *pszName, HINSTANCE hInstance, UINT uiDescriptionID)

{
    LONG        lErrorCode;
    TCHAR       szKeyName[256];
    CRegKey     regKeyService;

    (TCHAR*)lstrcpy(szKeyName, TEXT("SYSTEM\\CurrentControlSet\\Services\\"));
    (TCHAR*)lstrcat(szKeyName, pszName);
    lErrorCode = regKeyService.Open(HKEY_LOCAL_MACHINE,
                                    szKeyName,
                                    KEY_SET_VALUE);
    if (ERROR_SUCCESS == lErrorCode)
    {
        TCHAR   sz[256];

        if (LoadString(hInstance, uiDescriptionID, sz, ARRAYSIZE(sz)) != 0)
        {
            lErrorCode = regKeyService.SetString(TEXT("Description"), sz);
        }
        else
        {
            lErrorCode = GetLastError();
        }
    }
    return(CStatusCode::StatusCodeOfErrorCode(lErrorCode));
}

//  --------------------------------------------------------------------------
//  CService:AddServiceParameters
//
//  Arguments:  pszName     =   Name of service.
//              pszDllName  =   Name of DLL hosting service.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds parameters required for svchost to host this service.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::AddServiceParameters (const TCHAR *pszName, const TCHAR *pszDllName, const TCHAR *pszServiceMainName)

{
    LONG        lErrorCode;
    TCHAR       szKeyName[256];
    CRegKey     regKey;

    (TCHAR*)lstrcpy(szKeyName, TEXT("SYSTEM\\CurrentControlSet\\Services\\"));
    (TCHAR*)lstrcat(szKeyName, pszName);
    (TCHAR*)lstrcat(szKeyName, TEXT("\\Parameters"));
    lErrorCode = regKey.Create(HKEY_LOCAL_MACHINE,
                               szKeyName,
                               REG_OPTION_NON_VOLATILE,
                               KEY_SET_VALUE,
                               NULL);
    if (ERROR_SUCCESS == lErrorCode)
    {
        TCHAR   sz[256];

        (TCHAR*)lstrcpy(sz, TEXT("%SystemRoot%\\System32\\"));
        (TCHAR*)lstrcat(sz, pszDllName);
        lErrorCode = regKey.SetPath(TEXT("ServiceDll"), sz);
        if (ERROR_SUCCESS == lErrorCode)
        {
            if (pszServiceMainName == NULL)
            {
                (TCHAR*)lstrcpy(sz, TEXT("ServiceMain"));
                pszServiceMainName = sz;
            }
            lErrorCode = regKey.SetString(TEXT("ServiceMain"), pszServiceMainName);
        }
    }
    return(CStatusCode::StatusCodeOfErrorCode(lErrorCode));
}

//  --------------------------------------------------------------------------
//  CService:AddServiceToGroup
//
//  Arguments:  pszName             =   Name of service.
//              pszSvchostGroup     =   Group to which the service belongs.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the service as part of the group of services hosted in
//              a single instance of svchost.exe.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CService::AddServiceToGroup (const TCHAR *pszName, const TCHAR *pszSvchostGroup)

{
    LONG        lErrorCode;
    CRegKey     regKey;

    lErrorCode = regKey.Open(HKEY_LOCAL_MACHINE,
                             TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"),
                             KEY_QUERY_VALUE | KEY_SET_VALUE);
    if (ERROR_SUCCESS == lErrorCode)
    {
        DWORD   dwType, dwBaseDataSize, dwDataSize;

        dwType = dwBaseDataSize = dwDataSize = 0;
        lErrorCode = regKey.QueryValue(pszSvchostGroup,
                                       &dwType,
                                       NULL,
                                       &dwBaseDataSize);
        if ((REG_MULTI_SZ == dwType) && (dwBaseDataSize != 0))
        {
            TCHAR   *pszData;

            dwDataSize = dwBaseDataSize + ((lstrlen(pszName) + sizeof('\0')) * sizeof(TCHAR));
            pszData = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, dwDataSize));
            if (pszData != NULL)
            {
                lErrorCode = regKey.QueryValue(pszSvchostGroup,
                                               NULL,
                                               pszData,
                                               &dwBaseDataSize);
                if (ERROR_SUCCESS == lErrorCode)
                {
                    if (!StringInMulitpleStringList(pszData, pszName))
                    {
                        StringInsertInMultipleStringList(pszData, pszName, dwDataSize);
                        lErrorCode = regKey.SetValue(pszSvchostGroup,
                                                     dwType,
                                                     pszData,
                                                     dwDataSize);
                    }
                    else
                    {
                        lErrorCode = ERROR_SUCCESS;
                    }
                }
                (HLOCAL)LocalFree(pszData);
            }
            else
            {
                lErrorCode = ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            lErrorCode = ERROR_INVALID_DATA;
        }
    }
    return(CStatusCode::StatusCodeOfErrorCode(lErrorCode));
}

//  --------------------------------------------------------------------------
//  CService:StringInMulitpleStringList
//
//  Arguments:  pszStringList   =   String list to search.
//              pszString       =   String to search for.
//
//  Returns:    bool
//
//  Purpose:    Searches the REG_MULTI_SZ string list looking for matches.
//
//  History:    2000-12-01  vtan        created
//  --------------------------------------------------------------------------

bool    CService::StringInMulitpleStringList (const TCHAR *pszStringList, const TCHAR *pszString)

{
    bool    fFound;

    fFound = false;
    while (!fFound && (pszStringList[0] != TEXT('\0')))
    {
        fFound = (lstrcmpi(pszStringList, pszString) == 0);
        if (!fFound)
        {
            pszStringList += (lstrlen(pszStringList) + sizeof('\0'));
        }
    }
    return(fFound);
}

//  --------------------------------------------------------------------------
//  CService:StringInsertInMultipleStringList
//
//  Arguments:  pszStringList       =   String list to insert string in.
//              pszString           =   String to insert.
//              dwStringListSize    =   Byte count of string list.
//
//  Returns:    bool
//
//  Purpose:    Inserts the given string into the multiple string list in
//              the first alphabetical position encountered. If the list is
//              kept alphabetical then this preserves it.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

void    CService::StringInsertInMultipleStringList (TCHAR *pszStringList, const TCHAR *pszString, DWORD dwStringListSize)

{
    int     iResult, iSize;
    TCHAR   *pszFirstString, *pszLastString;

    pszFirstString = pszLastString = pszStringList;
    iSize = lstrlen(pszString) + sizeof('\0');
    iResult = -1;
    while ((iResult < 0) && (pszStringList[0] != TEXT('\0')))
    {
        pszLastString = pszStringList;
        iResult = lstrcmpi(pszStringList, pszString);
        ASSERTMSG(iResult != 0, "Found exact match in StringInsertInMultipleStringList");
        pszStringList += (lstrlen(pszStringList) + sizeof('\0'));
    }
    if (iResult < 0)
    {
        pszLastString = pszStringList;
    }
    MoveMemory(pszLastString + iSize, pszLastString, dwStringListSize - ((pszLastString - pszFirstString) * sizeof(TCHAR)) - (iSize * sizeof(TCHAR)));
    (TCHAR*)lstrcpy(pszLastString, pszString);
}

//  --------------------------------------------------------------------------
//  CServiceWorkItem::CServiceWorkItem
//
//  Arguments:  pServerAPI  =   CServerAPI to use.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CServiceWorkItem.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CServiceWorkItem::CServiceWorkItem (CServerAPI *pServerAPI) :
    _pServerAPI(pServerAPI)

{
    pServerAPI->AddRef();
}

//  --------------------------------------------------------------------------
//  CServiceWorkItem::~CServiceWorkItem
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CServiceWorkItem. Release resources used.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CServiceWorkItem::~CServiceWorkItem (void)

{
    _pServerAPI->Release();
    _pServerAPI = NULL;
}

//  --------------------------------------------------------------------------
//  CServiceWorkItem::Entry
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Executes work item request (stop the server).
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

void    CServiceWorkItem::Entry (void)

{
    TSTATUS(_pServerAPI->Stop());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\lpc\workitem.h ===
//  --------------------------------------------------------------------------
//  Module Name: WorkItem.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements the handling of queuing a work item and calling the
//  entry point of the work item function when entered in a worker thread.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _WorkItem_
#define     _WorkItem_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CWorkItem
//
//  Purpose:    A class to hide the work of queuing a work item to a worker
//              thread for execution.
//
//  History:    1999-11-26  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CWorkItem : public CCountedObject
{
    public:
                                CWorkItem (void);
        virtual                 ~CWorkItem (void);

                NTSTATUS        Queue (void);
    protected:
        virtual void            Entry (void) = 0;
    private:
        static  DWORD   WINAPI  WorkItemEntryProc (void *pParameter);
};

#endif  /*  _WorkItem_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagerapirequest.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerAPIRequest.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the work for the theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerAPIRequest_
#define     _ThemeManagerAPIRequest_

#include "APIRequest.h"
#include "DynamicArray.h"
#include "ThemeManagerSessionData.h"

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest
//
//  Purpose:    This is an intermediate class that contains a common method
//              that can be used by sub-classes.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

class   CThemeManagerAPIRequest : public CAPIRequest
{
    private:
                                                CThemeManagerAPIRequest (void);
    public:
                                                CThemeManagerAPIRequest (CAPIDispatcher* pAPIDispatcher);
                                                CThemeManagerAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage);
        virtual                                 ~CThemeManagerAPIRequest (void);

        virtual NTSTATUS                        Execute (void);

        static  NTSTATUS                        SessionDestroy (DWORD dwSessionID);

        static  NTSTATUS                        InitializeServerChangeNumber (void);

        static  NTSTATUS                        StaticInitialize (void);
        static  NTSTATUS                        StaticTerminate (void);
        static  NTSTATUS                        ArrayInitialize (void);
        static  NTSTATUS                        ArrayTerminate (void);
    private:
                NTSTATUS                        ImpersonateClientIfRequired (void);
                NTSTATUS                        ClientHasTcbPrivilege (void);
        static  int                             FindIndexSessionData (DWORD dwSessionID);
                NTSTATUS                        GetClientSessionData (void);

                NTSTATUS                        Execute_ThemeHooksOn (void);
                NTSTATUS                        Execute_ThemeHooksOff (void);
                NTSTATUS                        Execute_GetStatusFlags (void);
                NTSTATUS                        Execute_GetCurrentChangeNumber (void);
                NTSTATUS                        Execute_GetNewChangeNumber (void);
                NTSTATUS                        Execute_SetGlobalTheme (void);
                NTSTATUS                        Execute_MarkSection (void);
                NTSTATUS                        Execute_GetGlobalTheme (void);
                NTSTATUS                        Execute_CheckThemeSignature (void);
                NTSTATUS                        Execute_LoadTheme (void);

    //  These are internal and typically require SE_TCB_PRIVILEGE to execute.

                NTSTATUS                        Execute_UserLogon (void);
                NTSTATUS                        Execute_UserLogoff (void);
                NTSTATUS                        Execute_SessionCreate (void);
                NTSTATUS                        Execute_SessionDestroy (void);
                NTSTATUS                        Execute_Ping (void);
    private:
                HANDLE                          _hToken;
                CThemeManagerSessionData*       _pSessionData;

        static  CDynamicCountedObjectArray*     s_pSessionData;
        static  CCriticalSection*               s_pLock;
        static  DWORD                           s_dwServerChangeNumber;

        static  const TCHAR                     s_szServerChangeNumberValue[];
};

#endif  /*  _ThemeManagerAPIRequest_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagerapiserver.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerAPIServer.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains several classes that implemention virtual functions
//  for complete LPC functionality.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeManagerAPIServer.h"

#include <lpcthemes.h>

#include "ThemeManagerDispatcher.h"
#include "ThemeManagerService.h"

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::CThemeManagerAPIServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CThemeManagerAPIServer class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIServer::CThemeManagerAPIServer (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::~CThemeManagerAPIServer
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CThemeManagerAPIServer class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIServer::~CThemeManagerAPIServer (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::ConnectToServer
//
//  Arguments:  phPort  =   Handle to the port received on connection.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Connects to the server.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIServer::ConnectToServer (HANDLE *phPort)

{
    ULONG                           ulConnectionInfoLength;
    UNICODE_STRING                  portName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[64];

    RtlInitUnicodeString(&portName, GetPortName());
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    lstrcpyW(szConnectionInfo, THEMES_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    return(NtConnectPort(phPort,
                         &portName,
                         &sqos,
                         NULL,
                         NULL,
                         NULL,
                         szConnectionInfo,
                         &ulConnectionInfoLength));
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::GetPortName
//
//  Arguments:  <none>
//
//  Returns:    const WCHAR*
//
//  Purpose:    Uses a common routine to get the theme API port name.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

const WCHAR*    CThemeManagerAPIServer::GetPortName (void)

{
    return(THEMES_PORT_NAME);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::GetPortName
//
//  Arguments:  <none>
//
//  Returns:    const TCHAR*
//
//  Purpose:    Uses a common routine to get the theme service name.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

const TCHAR*    CThemeManagerAPIServer::GetServiceName (void)

{
    return(CThemeManagerService::GetName());
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::ConnectionAccepted
//
//  Arguments:  portMessage     =   PORT_MESSAGE from client.
//
//  Returns:    bool
//
//  Purpose:    Accepts or rejects a port connection request. Accepts all
//              connections currently.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeManagerAPIServer::ConnectionAccepted (const CPortMessage& portMessage)

{
    return(lstrcmpW(reinterpret_cast<const WCHAR*>(portMessage.GetData()), THEMES_CONNECTION_REQUEST) == 0);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::CreateDispatcher
//
//  Arguments:  portMessage     =   PORT_MESSAGE from client.
//
//  Returns:    CAPIDispatcher*
//
//  Purpose:    Called by the LPC connection request handler to create a new
//              thread to handle client requests.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CAPIDispatcher*     CThemeManagerAPIServer::CreateDispatcher (const CPortMessage& portMessage)

{
    HANDLE              hClientProcess;
    OBJECT_ATTRIBUTES   objectAttributes;
    CLIENT_ID           clientID;
    CAPIDispatcher      *pAPIDispatcher;

    pAPIDispatcher = NULL;
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);
    clientID.UniqueProcess = portMessage.GetUniqueProcess();
    clientID.UniqueThread = NULL;

    //  Open a handle to the client process. The handle must have PROCESS_DUP_HANDLE
    //  for the server to be able to deliver handles to the client. It also needs
    //  PROCESS_VM_READ | PROCESS_VM_WRITE if it's to read and write the client
    //  address space to store data that's too big for the LPC port.

    //  That handle is stored by the thread handler. It's not closed here.

    if (NT_SUCCESS(NtOpenProcess(&hClientProcess,
                                 PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
                                 &objectAttributes,
                                 &clientID)))
    {
        pAPIDispatcher = new CThemeManagerDispatcher(hClientProcess);
    }
    return(pAPIDispatcher);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer::Connect
//
//  Arguments:  phPort  =   Connection port returned.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Connects to the server.
//
//  History:    2000-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIServer::Connect (HANDLE* phPort)

{
    return(ConnectToServer(phPort));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagerapirequest.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerAPIRequest.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the work for the theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeManagerAPIRequest.h"

#include <LPCThemes.h>
#include <uxthemep.h>
#include <UxThemeServer.h>

#include "RegistryResources.h"
#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::s_pSessionData
//
//  Purpose:    Static member variables.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

CDynamicCountedObjectArray*     CThemeManagerAPIRequest::s_pSessionData                 =   NULL;
CCriticalSection*               CThemeManagerAPIRequest::s_pLock                        =   NULL;
DWORD                           CThemeManagerAPIRequest::s_dwServerChangeNumber         =   0;
const TCHAR                     CThemeManagerAPIRequest::s_szServerChangeNumberValue[]  =   TEXT("ServerChangeNumber");

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::CThemeManagerAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher that calls this object.
//              pAPIConnection  =   CAPIConnection for access change.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CThemeManagerAPIRequest class. It just passes the
//              control to the super class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIRequest::CThemeManagerAPIRequest (CAPIDispatcher* pAPIDispatcher) :
    CAPIRequest(pAPIDispatcher),
    _hToken(NULL),
    _pSessionData(NULL)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::CThemeManagerAPIRequest
//
//  Arguments:  pAPIDispatcher  =   CAPIDispatcher that calls this object.
//              pAPIConnection  =   CAPIConnection for access change.
//              portMessage     =   CPortMessage to copy construct.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CThemeManagerAPIRequest class. It just
//              passes the control to the super class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIRequest::CThemeManagerAPIRequest (CAPIDispatcher* pAPIDispatcher, const CPortMessage& portMessage) :
    CAPIRequest(pAPIDispatcher, portMessage),
    _hToken(NULL),
    _pSessionData(NULL)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::~CThemeManagerAPIRequest
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CThemeManagerAPIRequest class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIRequest::~CThemeManagerAPIRequest (void)

{
    ASSERTMSG(_hToken == NULL, "Impersonation token not released in CThemeManagerAPIRequest::~CThemeManagerAPIRequest");
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute implementation for theme manager API requests. This
//              function dispatches requests based on the API request number.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute (void)

{
    NTSTATUS        status;
    unsigned long   ulAPINumber;

    ulAPINumber = reinterpret_cast<API_THEMES*>(&_data)->apiGeneric.ulAPINumber & API_GENERIC_NUMBER_MASK;

    //  First try and get the client session data. If this fails then
    //  there's no object to execute the request on. Fail it.
    //  Exception to this is API_THEMES_SESSIONCREATE which creates one.

    //  Note: GetClientSessionData will store the session data in the
    //  _pSessionData member variable. While doing so it will increase
    //  reference count on this so that it doesn't get pulled from the
    //  array while the API request is being executed. The reference is
    //  released at the end of this function.

    status = GetClientSessionData();
    if (NT_SUCCESS(status) || (ulAPINumber == API_THEMES_SESSIONCREATE))
    {
        switch (ulAPINumber)
        {
            case API_THEMES_THEMEHOOKSON:
                status = Execute_ThemeHooksOn();
                break;
            case API_THEMES_THEMEHOOKSOFF:
                status = Execute_ThemeHooksOff();
                break;
            case API_THEMES_GETSTATUSFLAGS:
                status = Execute_GetStatusFlags();
                break;
            case API_THEMES_GETCURRENTCHANGENUMBER:
                status = Execute_GetCurrentChangeNumber();
                break;
            case API_THEMES_GETNEWCHANGENUMBER:
                status = Execute_GetNewChangeNumber();
                break;
            case API_THEMES_SETGLOBALTHEME:
                status = Execute_SetGlobalTheme();
                break;
            case API_THEMES_MARKSECTION:
                status = Execute_MarkSection();
                break;
            case API_THEMES_GETGLOBALTHEME:
                status = Execute_GetGlobalTheme();
                break;
            case API_THEMES_CHECKTHEMESIGNATURE:
                status = Execute_CheckThemeSignature();
                break;
            case API_THEMES_LOADTHEME:
                status = Execute_LoadTheme();
                break;
            case API_THEMES_USERLOGON:
                status = Execute_UserLogon();
                break;
            case API_THEMES_USERLOGOFF:
                status = Execute_UserLogoff();
                break;
            case API_THEMES_SESSIONCREATE:
                status = Execute_SessionCreate();
                break;
            case API_THEMES_SESSIONDESTROY:
                status = Execute_SessionDestroy();
                break;
            case API_THEMES_PING:
                status = Execute_Ping();
                break;
            default:
                DISPLAYMSG("Unknown API request in CThemeManagerAPIRequest::Execute");
                status = STATUS_NOT_IMPLEMENTED;
                break;
        }
    }

    //  If the execution function needed to impersonate the client then
    //  revert here and release the token used.

    if (_hToken != NULL)
    {
        TBOOL(RevertToSelf());
        ReleaseHandle(_hToken);
    }

    //  Release the _pSessionData object now. NULL it out to prevent
    //  accidentally using it after being released.

    if (_pSessionData != NULL)
    {
        _pSessionData->Release();
        _pSessionData = NULL;
    }

    //  Return to caller.

    TSTATUS(status);
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::SessionDestroy
//
//  Arguments:  dwSessionID     =   Session ID to destroy.
//
//  Returns:    NTSTATUS
//
//  Purpose:    External entry point for session client (winlogon) watcher.
//              When winlogon dies we clean up the session information for
//              that session and release resources.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::SessionDestroy (DWORD dwSessionID)

{
    NTSTATUS                    status;
    int                         iIndex;
    CSingleThreadedExecution    lock(*s_pLock);

    iIndex = FindIndexSessionData(dwSessionID);
    if (iIndex >= 0)
    {
        status = s_pSessionData->Remove(iIndex);
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::InitializeServerChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes the static server change number. Every time the
//              service starts up this number is incremented. If the number
//              isn't present then 0 is used.
//
//  History:    2000-12-09  vtan        created
//              2000-12-09  vtan        split from StaticInitialize
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::InitializeServerChangeNumber (void)

{
    LONG        lErrorCodeOpen, lErrorCodeRead;
    DWORD       dwServerChangeNumber;
    CRegKey     regKey;

    dwServerChangeNumber = s_dwServerChangeNumber;

    //  Initialize the static member variable now in case of failure.
    //  We ignore failures because at GUI setup the key does NOT exist
    //  because the server dll hasn't been regsvr'd yet. After GUI setup
    //  this gets regsvr'd and the key exists and we are happy campers.

    lErrorCodeOpen = regKey.Open(HKEY_LOCAL_MACHINE,
                                 TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"),
                                 KEY_QUERY_VALUE | KEY_SET_VALUE);
    if (ERROR_SUCCESS == lErrorCodeOpen)
    {
        lErrorCodeRead = regKey.GetDWORD(s_szServerChangeNumberValue, dwServerChangeNumber);
    }
    else
    {
        lErrorCodeRead = ERROR_FILE_NOT_FOUND;
    }
    dwServerChangeNumber = static_cast<WORD>(dwServerChangeNumber + 1);
    if ((ERROR_SUCCESS == lErrorCodeOpen) && (ERROR_SUCCESS == lErrorCodeRead))
    {
        TW32(regKey.SetDWORD(s_szServerChangeNumberValue, dwServerChangeNumber));
    }
    s_dwServerChangeNumber = dwServerChangeNumber;
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Static initializer for the class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::StaticInitialize (void)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (s_pLock == NULL)
    {
        s_pLock = new CCriticalSection;
        if (s_pLock != NULL)
        {
            status = s_pLock->Status();
            if (!NT_SUCCESS(status))
            {
                delete s_pLock;
                s_pLock = NULL;
            }
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Static destructor for the class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::StaticTerminate (void)

{
    if (s_pLock != NULL)
    {
        delete s_pLock;
        s_pLock = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::ArrayInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes (allocates) the session array.
//
//  History:    2001-01-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::ArrayInitialize (void)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    lock(*s_pLock);

    status = STATUS_SUCCESS;
    if (s_pSessionData == NULL)
    {
        s_pSessionData = new CDynamicCountedObjectArray;
        if (s_pSessionData == NULL)
        {
            status = STATUS_NO_MEMORY;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::ArrayTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases all objects in the session array (removes the waits)
//              and releases the session array object.
//
//  History:    2001-01-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::ArrayTerminate (void)

{
    CSingleThreadedExecution    lock(*s_pLock);

    if (s_pSessionData != NULL)
    {
        int     i, iLimit;

        iLimit = s_pSessionData->GetCount();
        for (i = iLimit - 1; i >= 0; --i)
        {
            TSTATUS(static_cast<CThemeManagerSessionData*>(s_pSessionData->Get(i))->Cleanup());
            TSTATUS(s_pSessionData->Remove(i));
        }
        delete s_pSessionData;
        s_pSessionData = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::ImpersonateClientIfRequired
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Impersonates the client if the client is NOT the SYSTEM.
//              There's usually no point impersonating the system unless the
//              token is actually a filtered token.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::ImpersonateClientIfRequired (void)

{
    NTSTATUS    status;

    status = OpenClientToken(_hToken);
    if (NT_SUCCESS(status))
    {
        CTokenInformation   tokenInformation(_hToken);

        if (tokenInformation.IsUserTheSystem())
        {
            ReleaseHandle(_hToken);
            status = STATUS_SUCCESS;
        }
        else if (ImpersonateLoggedOnUser(_hToken) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::ClientHasTcbPrivilege
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Returns whether the client has the SE_TCB_PRIVILEGE as a
//              status code.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::ClientHasTcbPrivilege (void)

{
    NTSTATUS    status;
    HANDLE      hTokenClient;

    if (OpenProcessToken(_pAPIDispatcher->GetClientProcess(),
                         TOKEN_QUERY,
                         &hTokenClient) != FALSE)
    {
        CTokenInformation   tokenInformation(hTokenClient);

        if (tokenInformation.UserHasPrivilege(SE_TCB_PRIVILEGE))
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_ACCESS_DENIED;
        }
        TBOOL(CloseHandle(hTokenClient));
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::FindIndexSessionData
//
//  Arguments:  dwSessionID     =   Session ID to find.
//
//  Returns:    int
//
//  Purpose:    Iterates the session data array looking for the sessions that
//              matches the given session.
//
//  History:    2000-11-30  vtan        created
//  --------------------------------------------------------------------------

int     CThemeManagerAPIRequest::FindIndexSessionData (DWORD dwSessionID)

{
    int     iIndex;

    iIndex = -1;
    if ((s_pLock != NULL) && (s_pSessionData != NULL))
    {
        int     i, iLimit;

        ASSERTMSG(s_pLock->IsOwned(), "s_pLock must be acquired in CThemeManagerAPIRequest::FindIndexSessionData");
        iLimit = s_pSessionData->GetCount();
        for (i = 0; (iIndex < 0) && (i < iLimit); ++i)
        {
            CThemeManagerSessionData    *pSessionData;

            pSessionData = static_cast<CThemeManagerSessionData*>(s_pSessionData->Get(i));
            if ((pSessionData != NULL) && (pSessionData->EqualSessionID(dwSessionID)))
            {
                iIndex = i;
            }
        }
    }
    return(iIndex);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::GetClientSessionData
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Retrieves the session data associated with the client's
//              session ID. This abstracts the information from uxtheme's
//              loader code and just passes it an object it knows how to deal
//              with.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::GetClientSessionData (void)

{
    NTSTATUS                    status;
    int                         iIndex;
    CSingleThreadedExecution    lock(*s_pLock);

    status = STATUS_UNSUCCESSFUL;
    iIndex = FindIndexSessionData(_pAPIDispatcher->GetClientSessionID());
    if (iIndex >= 0)
    {
        _pSessionData = static_cast<CThemeManagerSessionData*>(s_pSessionData->Get(iIndex));
        if (_pSessionData != NULL)
        {
            _pSessionData->AddRef();
            status = STATUS_SUCCESS;
        }
    }
    else
    {
        _pSessionData = NULL;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_ThemeHooksOn
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_THEMEHOOKSON.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_ThemeHooksOn (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_THEMEHOOKSON_OUT     *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiThemeHooksOn.out;
        pAPIOut->hr = ThemeHooksOn(_pSessionData->GetData());
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_ThemeHooksOff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_THEMEHOOKSOFF.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_ThemeHooksOff (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_THEMEHOOKSOFF_OUT    *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiThemeHooksOff.out;
        pAPIOut->hr = ThemeHooksOff(_pSessionData->GetData());
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_GetStatusFlags
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_GETSTATUSFLAGS.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_GetStatusFlags (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        DWORD                           dwFlags;
        API_THEMES_GETSTATUSFLAGS_OUT   *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiGetStatusFlags.out;
        dwFlags = QTS_AVAILABLE;
        if (AreThemeHooksActive(_pSessionData->GetData()))
        {
            dwFlags |= QTS_RUNNING;
        }
        pAPIOut->dwFlags = dwFlags;
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_GetCurrentChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_GETCURRENTCHANGENUMBER.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_GetCurrentChangeNumber (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_GETCURRENTCHANGENUMBER_OUT   *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiGetCurrentChangeNumber.out;
        pAPIOut->iChangeNumber = GetCurrentChangeNumber(_pSessionData->GetData());
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_GetNewChangeNumber
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_GETNEWCHANGENUMBER.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_GetNewChangeNumber (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_GETNEWCHANGENUMBER_OUT   *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiGetNewChangeNumber.out;
        pAPIOut->iChangeNumber = GetNewChangeNumber(_pSessionData->GetData());
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_SetGlobalTheme
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_SETGLOBALTHEME.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_SetGlobalTheme (void)

{
    NTSTATUS    status;

    // Note: we must not impersonate the user here, since we need write access to the section

    HANDLE                          hSection;
    API_THEMES_SETGLOBALTHEME_IN    *pAPIIn;
    API_THEMES_SETGLOBALTHEME_OUT   *pAPIOut;

    pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiSetGlobalTheme.in;
    pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiSetGlobalTheme.out;
    if (pAPIIn->hSection != NULL)
    {
        if (DuplicateHandle(_pAPIDispatcher->GetClientProcess(),
                            pAPIIn->hSection,
                            GetCurrentProcess(),
                            &hSection,
                            FILE_MAP_ALL_ACCESS,
                            FALSE,
                            0) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        hSection = NULL;
        status = STATUS_SUCCESS;
    }
    if (NT_SUCCESS(status))
    {
        pAPIOut->hr = SetGlobalTheme(_pSessionData->GetData(), hSection);
        if (hSection != NULL)
        {
            TBOOL(CloseHandle(hSection));
        }
    }
    else
    {
        pAPIOut->hr = HRESULT_FROM_NT(status);
    }

    SetDataLength(sizeof(API_THEMES));
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_MarkSection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_MARKSECTION.
//
//  History:    2001-05-08  lmouton     created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_MarkSection (void)

{
    NTSTATUS    status;

    // Note: we must not impersonate the user here, since we need write access to the section

    HANDLE                          hSection;
    DWORD                           dwAdd;
    DWORD                           dwRemove;
    API_THEMES_MARKSECTION_IN       *pAPIIn;
    API_THEMES_MARKSECTION_OUT      *pAPIOut;

    pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiMarkSection.in;
    pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiMarkSection.out;
    dwAdd = pAPIIn->dwAdd;
    dwRemove = pAPIIn->dwRemove;

    if (pAPIIn->hSection != NULL)
    {
        if (DuplicateHandle(_pAPIDispatcher->GetClientProcess(),
                            pAPIIn->hSection,
                            GetCurrentProcess(),
                            &hSection,
                            FILE_MAP_ALL_ACCESS,
                            FALSE,
                            0) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
            DISPLAYMSG("Execute_MarkSection: Can't get a write handle");
        }
    }
    else
    {
        hSection = NULL;
        status = STATUS_SUCCESS;
    }
    if (NT_SUCCESS(status))
    {
        if (hSection != NULL)
        {
            MarkSection(hSection, dwAdd, dwRemove);
            TBOOL(CloseHandle(hSection));
        }
    }

    SetDataLength(sizeof(API_THEMES));
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_GetGlobalTheme
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_GETGLOBALTHEME.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_GetGlobalTheme (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        HRESULT                         hr;
        HANDLE                          hSection;
        API_THEMES_GETGLOBALTHEME_OUT   *pAPIOut;

        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiGetGlobalTheme.out;
        hr = GetGlobalTheme(_pSessionData->GetData(), &hSection);
        if (SUCCEEDED(hr) && (hSection != NULL))
        {
            if (DuplicateHandle(GetCurrentProcess(),
                                hSection,
                                _pAPIDispatcher->GetClientProcess(),
                                &pAPIOut->hSection,
                                FILE_MAP_READ,
                                FALSE,
                                0) != FALSE)
            {
                hr = S_OK;
            }
            else
            {
                DWORD   dwErrorCode;

                dwErrorCode = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErrorCode);
            }
            TBOOL(CloseHandle(hSection));
        }
        pAPIOut->hr = hr;
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  LOADTHEME_STRINGS + supporting functions
//
//  Purpose:    Manages and validates LoadTheme string parameters
//
//  History:    2002-02-26  scotthan        created
//  --------------------------------------------------------------------------
typedef struct 
{
    LPWSTR pszFilename;
    LPWSTR pszColor;
    LPWSTR pszSize;

} LOADTHEME_STRINGS;

#define MAX_THEME_STRING    MAX_PATH

//  --------------------------------------------------------------------------
void _FreeThemeStrings( IN LOADTHEME_STRINGS* plts )
{
    if( plts )
    {
        _FreeMappedClientString(plts->pszFilename);
        _FreeMappedClientString(plts->pszColor);
        _FreeMappedClientString(plts->pszSize);
        delete plts;
    }
}

//  --------------------------------------------------------------------------
NTSTATUS _AllocAndMapThemeStrings( 
    IN HANDLE   hProcessClient,
    IN LPCWSTR  pszFilenameIn,
    IN UINT     cchFilenameIn,
    IN LPCWSTR  pszColorIn,
    IN UINT     cchColorIn,
    IN LPCWSTR  pszSizeIn,
    IN UINT     cchSizeIn,
    OUT LOADTHEME_STRINGS** pplts )
{
    NTSTATUS status;

    ASSERTMSG(pplts != NULL, "_AllocAndMapThemeStrings: NULL outbound parameter, LOADTHEME_STRINGS**.");
    ASSERTMSG(hProcessClient != NULL, "_AllocAndMapThemeStrings: NULL process handle.");

    //  note: cchFileNameIn, cchColorIn, cchSizeIn are char counts that include the NULL terminus.
    if( pszFilenameIn && pszColorIn && pszSizeIn &&
        cchFilenameIn > 0 && cchColorIn > 0 && cchSizeIn > 0 &&
        cchFilenameIn <= MAX_THEME_STRING && cchColorIn <= MAX_THEME_STRING && cchSizeIn <= MAX_THEME_STRING )
    {
        *pplts = NULL;

        LOADTHEME_STRINGS *plts = new LOADTHEME_STRINGS;

        if( plts != NULL )
        {
            ZeroMemory(plts, sizeof(*plts));

            status = _AllocAndMapClientString(hProcessClient, pszFilenameIn, cchFilenameIn, MAX_THEME_STRING, &plts->pszFilename);
            if( NT_SUCCESS(status) )
            {
                status = _AllocAndMapClientString(hProcessClient, pszColorIn, cchColorIn, MAX_THEME_STRING, &plts->pszColor);
                if( NT_SUCCESS(status) )
                {
                    status = _AllocAndMapClientString(hProcessClient, pszSizeIn, cchSizeIn, MAX_THEME_STRING, &plts->pszSize);
                    if( NT_SUCCESS(status) )
                    {
                        *pplts = plts;
                    }
                }
            }

            if( !NT_SUCCESS(status) )
            {
                _FreeThemeStrings(plts);
            }
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;       
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_CheckThemeSignature
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_CHECKTHEMESIGNATURE.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_CheckThemeSignature (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();
    if (NT_SUCCESS(status))
    {
        API_THEMES_CHECKTHEMESIGNATURE_IN   *pAPIIn;
        API_THEMES_CHECKTHEMESIGNATURE_OUT  *pAPIOut;
        LPWSTR                              pszThemeFileName;

        pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiCheckThemeSignature.in;
        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiCheckThemeSignature.out;

        status = _AllocAndMapClientString(_pAPIDispatcher->GetClientProcess(), 
                                          pAPIIn->pszName, 
                                          pAPIIn->cchName, 
                                          MAX_PATH, 
                                          &pszThemeFileName);
        if( NT_SUCCESS(status) )
        {
            pAPIOut->hr = CheckThemeSignature(pszThemeFileName);
            status = STATUS_SUCCESS;

            _FreeMappedClientString(pszThemeFileName);
        }
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_LoadTheme
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_LOADTHEME.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_LoadTheme (void)

{
    NTSTATUS    status;

    status = ImpersonateClientIfRequired();

    if (NT_SUCCESS(status))
    {
        HANDLE                      hProcessClient;
        API_THEMES_LOADTHEME_IN     *pAPIIn;
        API_THEMES_LOADTHEME_OUT    *pAPIOut;
        LOADTHEME_STRINGS*          plts;

        hProcessClient = _pAPIDispatcher->GetClientProcess();
        pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiLoadTheme.in;
        pAPIOut = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiLoadTheme.out;

        status = _AllocAndMapThemeStrings( hProcessClient, pAPIIn->pszName, pAPIIn->cchName,
                                           pAPIIn->pszColor, pAPIIn->cchColor,
                                           pAPIIn->pszSize, pAPIIn->cchSize,
                                           &plts );
        if( NT_SUCCESS(status) )
        {
            HANDLE  hSectionIn, hSectionOut;

            if (DuplicateHandle(hProcessClient,
                                pAPIIn->hSection,
                                GetCurrentProcess(),
                                &hSectionIn,
                                FILE_MAP_ALL_ACCESS,
                                FALSE,
                                0) != FALSE)
            {
                status = STATUS_SUCCESS;
                
                // Warning: this function will revert to self in order to create the section in system context.
                // Impersonate the user again after it if needed
                pAPIOut->hr = LoadTheme(_pSessionData->GetData(), hSectionIn, &hSectionOut, 
                                        plts->pszFilename, plts->pszColor, plts->pszSize);

                if (SUCCEEDED(pAPIOut->hr))
                {
                    // Still running in the system context here
                    if (DuplicateHandle(GetCurrentProcess(),
                                        hSectionOut,
                                        hProcessClient,
                                        &pAPIOut->hSection,
                                        FILE_MAP_READ,
                                        FALSE,
                                        0) == FALSE)
                    {
                        status = CStatusCode::StatusCodeOfLastError();
                    }
                    TBOOL(CloseHandle(hSectionOut));
                }
                TBOOL(CloseHandle(hSectionIn));
            }
            else
            {
                status = CStatusCode::StatusCodeOfLastError();
            }

            _FreeThemeStrings(plts);
        }
    }

    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_UserLogon
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_USERLOGON. To call this API you must have
//              the SE_TCB_PRIVILEGE in your token.
//
//  History:    2000-10-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_UserLogon (void)

{
    NTSTATUS    status;

    status = ClientHasTcbPrivilege();
    if (NT_SUCCESS(status))
    {
        HANDLE                      hToken;
        API_THEMES_USERLOGON_IN     *pAPIIn;

        pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiUserLogon.in;
        if (DuplicateHandle(_pAPIDispatcher->GetClientProcess(),
                            pAPIIn->hToken,
                            GetCurrentProcess(),
                            &hToken,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS) != FALSE)
        {
            status = _pSessionData->UserLogon(hToken);
            TBOOL(CloseHandle(hToken));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_UserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_USERLOGOFF. To call this API you must have
//              the SE_TCB_PRIVILEGE in your token.
//
//  History:    2000-10-12  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_UserLogoff (void)

{
    NTSTATUS    status;

    status = ClientHasTcbPrivilege();
    if (NT_SUCCESS(status))
    {
        status = _pSessionData->UserLogoff();
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_SessionCreate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_SESSIONCREATE. To call this API you must
//              have the SE_TCB_PRIVILEGE in your token.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_SessionCreate (void)

{
    NTSTATUS    status;

    status = ClientHasTcbPrivilege();
    if (NT_SUCCESS(status))
    {
        HANDLE                      hProcessClient;
        CThemeManagerSessionData    *pSessionData;

        ASSERTMSG(_pSessionData == NULL, "Session data already exists in CThemeManagerAPIRequest::Execute_SessionCreate");
        if (DuplicateHandle(GetCurrentProcess(),
                            _pAPIDispatcher->GetClientProcess(),
                            GetCurrentProcess(),
                            &hProcessClient,
                            PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE,
                            FALSE,
                            0) != FALSE)
        {
            DWORD   dwSessionID;

            dwSessionID = _pAPIDispatcher->GetClientSessionID();
            pSessionData = new CThemeManagerSessionData(dwSessionID);
            if (pSessionData != NULL)
            {
                API_THEMES_SESSIONCREATE_IN     *pAPIIn;

                pAPIIn = &reinterpret_cast<API_THEMES*>(&_data)->apiSpecific.apiSessionCreate.in;
                status = pSessionData->Allocate(hProcessClient,
                                                s_dwServerChangeNumber,
                                                pAPIIn->pfnRegister,
                                                pAPIIn->pfnUnregister,
                                                pAPIIn->pfnClearStockObjects,
                                                pAPIIn->dwStackSizeReserve,
                                                pAPIIn->dwStackSizeCommit);
                if (NT_SUCCESS(status))
                {
                    int                         iIndex;
                    CSingleThreadedExecution    lock(*s_pLock);

                    //  Find the session data in the static array. If found
                    //  then remove the entry (don't allow duplicates).

                    iIndex = FindIndexSessionData(dwSessionID);
                    if (iIndex >= 0)
                    {
                        status = s_pSessionData->Remove(iIndex);
                    }

                    //  If the static array has been destroyed (the service has been
                    //  stopped) then don't do anything - this is not an error.

                    if (NT_SUCCESS(status) && (s_pSessionData != NULL))
                    {
                        status = s_pSessionData->Add(pSessionData);
                    }
                }
                pSessionData->Release();
            }
            else
            {
                status = STATUS_NO_MEMORY;
            }
            TBOOL(CloseHandle(hProcessClient));
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_SessionDestroy
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_SESSIONDESTROY. To call this API you must
//              have the SE_TCB_PRIVILEGE in your token.
//
//  History:    2000-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_SessionDestroy (void)

{
    NTSTATUS    status;

    status = ClientHasTcbPrivilege();
    if (NT_SUCCESS(status))
    {
        int                         iIndex;
        CSingleThreadedExecution    lock(*s_pLock);

        iIndex = FindIndexSessionData(_pAPIDispatcher->GetClientSessionID());
        if (iIndex >= 0)
        {
            status = s_pSessionData->Remove(iIndex);
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }
    SetDataLength(sizeof(API_THEMES));
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerAPIRequest::Execute_Ping
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Handles API_THEMES_PING. Tell the client we're alive.
//
//  History:    2000-11-30  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerAPIRequest::Execute_Ping (void)

{
    SetDataLength(sizeof(API_THEMES));
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagerdispatcher.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerDispatcher.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements dispatching work for the
//  theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeManagerDispatcher.h"

#include "ThemeManagerAPIRequest.h"

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher::CThemeManagerDispatcher
//
//  Arguments:  hClientProcess  =   HANDLE to the client process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CThemeManagerDispatcher class. This
//              stores the client handle. It does not duplicate it.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerDispatcher::CThemeManagerDispatcher (HANDLE hClientProcess) :
    CAPIDispatcher(hClientProcess)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher::~CThemeManagerDispatcher
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for the CThemeManagerDispatcher class.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerDispatcher::~CThemeManagerDispatcher (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher::CreateAndQueueRequest
//
//  Arguments:  portMessage     =   PORT_MESSAGE request to queue to handler.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Queues the client request to the dispatcher. Tells the
//              handler thread that there is input waiting. This function
//              knows what kind of CAPIRequest to create so that
//              CAPIRequest::Execute will work correctly.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerDispatcher::CreateAndQueueRequest (const CPortMessage& portMessage)

{
    NTSTATUS        status;
    CQueueElement   *pQueueElement;

    pQueueElement = new CThemeManagerAPIRequest(this, portMessage);
    if (pQueueElement != NULL)
    {
        _queue.Add(pQueueElement);
        status = SignalRequestPending();
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher::CreateAndExecuteRequest
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Executes the given request immediately and returns the result
//              back to the caller. The API request is done on the server
//              listen thread.
//
//  History:    2000-10-19  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerDispatcher::CreateAndExecuteRequest (const CPortMessage& portMessage)

{
    NTSTATUS        status;
    CAPIRequest     *pAPIRequest;

    pAPIRequest = new CThemeManagerAPIRequest(this, portMessage);
    if (pAPIRequest != NULL)
    {
        status = Execute(pAPIRequest);
        delete pAPIRequest;
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagerdispatcher.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerDispatcher.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements dispatching work for the
//  theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerDispatcher_
#define     _ThemeManagerDispatcher_

#include "APIDispatcher.h"
#include "PortMessage.h"
#include "ServerAPI.h"

//  --------------------------------------------------------------------------
//  CThemeManagerDispatcher
//
//  Purpose:    This sub-class implements CAPIDispatcher::QueueRequest to
//              create a CThemeManagerRequest which knows how to handle
//              API requests for the theme manager.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

class   CThemeManagerDispatcher : public CAPIDispatcher
{
    private:
                                    CThemeManagerDispatcher (void);
    public:
                                    CThemeManagerDispatcher (HANDLE hClientProcess);
        virtual                     ~CThemeManagerDispatcher (void);

        virtual NTSTATUS            CreateAndQueueRequest (const CPortMessage& portMessage);
        virtual NTSTATUS            CreateAndExecuteRequest (const CPortMessage& portMessage);
};

#endif  /*  _ThemeManagerDispatcher_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagerapiserver.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerAPIServer.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains several classes that implemention virtual functions
//  for complete LPC functionality.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerAPIServer_
#define     _ThemeManagerAPIServer_

#include "ServerAPI.h"

//  --------------------------------------------------------------------------
//  CThemeManagerAPIServer
//
//  Purpose:    This class implements the interface that the
//              CAPIConnectionThread uses to create create the LPC port,
//              accept or reject connections to the LPC port and create the
//              LPC request handling thread.
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

class   CThemeManagerAPIServer : public CServerAPI
{
    public:
                                    CThemeManagerAPIServer (void);
        virtual                     ~CThemeManagerAPIServer (void);

                NTSTATUS            ConnectToServer (HANDLE *phPort);
    protected:
        virtual const WCHAR*        GetPortName (void);
        virtual const TCHAR*        GetServiceName (void);
        virtual bool                ConnectionAccepted (const CPortMessage& portMessage);
        virtual CAPIDispatcher*     CreateDispatcher (const CPortMessage& portMessage);
        virtual NTSTATUS            Connect (HANDLE* phPort);
};

#endif  /*  _ThemeManagerAPIServer_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagerservice.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerService.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the theme server service
//  specifics.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerService_
#define     _ThemeManagerService_

#include "Service.h"

//  --------------------------------------------------------------------------
//  CThemeManagerService
//
//  Purpose:    Implements theme manager server specific functionality to the
//              CService class.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

class   CThemeManagerService : public CService
{
    private:
                                CThemeManagerService (void);
    public:
                                CThemeManagerService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI);
        virtual                 ~CThemeManagerService (void);
    protected:
        virtual NTSTATUS        Signal (void);
    public:
        static  const TCHAR*    GetName (void);
        static  HANDLE          OpenStartEvent (DWORD dwSessionID, DWORD dwDesiredAccess);
        static  DWORD   WINAPI  SignalSessionEvents (void *pParameter);
    private:
        static  const TCHAR     s_szName[];
};

#endif  /*  _ThemeManagerService_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagerservice.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerService.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the theme server service
//  specifics.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeManagerService.h"

#include <lpcthemes.h>
#include <winsta.h>

#include "Access.h"
#include "StatusCode.h"

const TCHAR     CThemeManagerService::s_szName[]    =   TEXT("Themes");

//  --------------------------------------------------------------------------
//  CThemeManagerService::CThemeManagerService
//
//  Arguments:  pAPIConnection  =   CAPIConnection passed to base class.
//              pServerAPI      =   CServerAPI passed to base class.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeManagerService.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerService::CThemeManagerService (CAPIConnection *pAPIConnection, CServerAPI *pServerAPI) :
    CService(pAPIConnection, pServerAPI, GetName())

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::~CThemeManagerService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeManagerService.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerService::~CThemeManagerService (void)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::Signal
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Used to signal that the service is coming up. Winlogon (via
//              msgina) is listening for this event in its own session. This
//              function queues a request to execute the real work done on a
//              worker thread to prevent blocking the main service thread. If
//              this is not possible then execute the signal inline.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerService::Signal (void)

{
    if (QueueUserWorkItem(SignalSessionEvents, NULL, WT_EXECUTEDEFAULT) == FALSE)
    {
        (DWORD)SignalSessionEvents(NULL);
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::GetName
//
//  Arguments:  <none>
//
//  Returns:    const TCHAR*
//
//  Purpose:    Returns the name of the service (ThemeService).
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

const TCHAR*    CThemeManagerService::GetName (void)

{
    return(s_szName);
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::OpenStartEvent
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Opens or creates the theme service recovery event. This allows
//              a process that has registered for the event to be signaled
//              when the theme server is demand started. Currently only
//              winlogon listens for this event and is required so that it can
//              reestablish a server connection and re-create the session data
//              which holds the hooks for theming.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CThemeManagerService::OpenStartEvent (DWORD dwSessionID, DWORD dwDesiredAccess)

{
    HANDLE              hEvent;
    NTSTATUS            status;
    UNICODE_STRING      eventName;
    OBJECT_ATTRIBUTES   objectAttributes;
    WCHAR               szEventName[64];

    if (dwSessionID == 0)
    {
        wsprintfW(szEventName, L"\\BaseNamedObjects\\%s", THEMES_START_EVENT_NAME);
    }
    else
    {
        wsprintfW(szEventName, L"\\Sessions\\%d\\BaseNamedObjects\\%s", dwSessionID, THEMES_START_EVENT_NAME);
    }
    RtlInitUnicodeString(&eventName, szEventName);
    InitializeObjectAttributes(&objectAttributes,
                               &eventName,
                               0,
                               NULL,
                               NULL);
    status = NtOpenEvent(&hEvent, dwDesiredAccess, &objectAttributes);
    if (!NT_SUCCESS(status))
    {

        //  Build a security descriptor for the event that allows:
        //      S-1-5-18            NT AUTHORITY\SYSTEM     EVENT_ALL_ACCESS
        //      S-1-5-32-544        <local administrators>  SYNCHRONIZE | READ_CONTROL
        //      S-1-1-0             <everyone>              SYNCHRONIZE

        static  SID_IDENTIFIER_AUTHORITY    s_SecurityNTAuthority       =   SECURITY_NT_AUTHORITY;
        static  SID_IDENTIFIER_AUTHORITY    s_SecurityWorldAuthority    =   SECURITY_WORLD_SID_AUTHORITY;

        static  const CSecurityDescriptor::ACCESS_CONTROL   s_AccessControl[]   =
        {
            {
                &s_SecurityNTAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                EVENT_ALL_ACCESS
            },
            {
                &s_SecurityNTAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                SYNCHRONIZE | READ_CONTROL
            },
            {
                &s_SecurityWorldAuthority,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                SYNCHRONIZE
            },
        };

        PSECURITY_DESCRIPTOR    pSecurityDescriptor;

        //  Build a security descriptor that allows the described access above.

        pSecurityDescriptor = CSecurityDescriptor::Create(ARRAYSIZE(s_AccessControl), s_AccessControl);

        InitializeObjectAttributes(&objectAttributes,
                                   &eventName,
                                   0,
                                   NULL,
                                   pSecurityDescriptor);
        status = NtCreateEvent(&hEvent,
                               EVENT_ALL_ACCESS,
                               &objectAttributes,
                               NotificationEvent,
                               FALSE);
        ReleaseMemory(pSecurityDescriptor);
        if (!NT_SUCCESS(status))
        {
            hEvent = NULL;
            SetLastError(CStatusCode::ErrorCodeOfStatusCode(status));
        }
    }
    return(hEvent);
}

//  --------------------------------------------------------------------------
//  CThemeManagerService::SignalSessionEvents
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Opens or creates the theme service recovery event. This allows
//              a process that has registered for the event to be signaled
//              when the theme server is demand started.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CThemeManagerService::SignalSessionEvents (void *pParameter)

{
    UNREFERENCED_PARAMETER(pParameter);

    HANDLE      hEvent;
    HANDLE      hServer;

    //  First try and use terminal server to enumerate the sessions available.

    hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
    if (hServer != NULL)
    {
        ULONG       ulEntries;
        PLOGONID    pLogonIDs;

        if (WinStationEnumerate(hServer, &pLogonIDs, &ulEntries))
        {
            ULONG       ul;
            PLOGONID    pLogonID;

            for (ul = 0, pLogonID = pLogonIDs; ul < ulEntries; ++ul, ++pLogonID)
            {
                if ((pLogonID->State == State_Active) || (pLogonID->State == State_Connected) || (pLogonID->State == State_Disconnected))
                {
                    hEvent = OpenStartEvent(pLogonID->SessionId, EVENT_MODIFY_STATE);
                    if (hEvent != NULL)
                    {
                        TBOOL(SetEvent(hEvent));
                        TBOOL(CloseHandle(hEvent));
                    }
                }
            }
            (BOOLEAN)WinStationFreeMemory(pLogonIDs);
        }
        (BOOLEAN)WinStationCloseServer(hServer);
    }
    else
    {

        //  If terminal services is not available then assume session 0 only.

        hEvent = OpenStartEvent(0, EVENT_MODIFY_STATE);
        if (hEvent != NULL)
        {
            TBOOL(SetEvent(hEvent));
            TBOOL(CloseHandle(hEvent));
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagersessiondata.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerSessionData.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements information the encapsulates a
//  client TS session for the theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeManagerSessionData.h"

#include <uxthemep.h>
#include <UxThemeServer.h>

#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "ThemeManagerAPIRequest.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::s_pAPIConnection
//
//  Purpose:    Static member variables.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

CAPIConnection*     CThemeManagerSessionData::s_pAPIConnection  =   NULL;

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::CThemeManagerSessionData
//
//  Arguments:  pAPIConnection  =   CAPIConnection for port access control.
//              dwSessionID     =   Session ID.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CThemeManagerSessionData.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerSessionData::CThemeManagerSessionData (DWORD dwSessionID) :
    _dwSessionID(dwSessionID),
    _pvThemeLoaderData(NULL),
    _hToken(NULL),
    _hProcessClient(NULL),
    _hWait(NULL)

{
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::~CThemeManagerSessionData
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CThemeManagerSessionData.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerSessionData::~CThemeManagerSessionData (void)

{
    ASSERTMSG(_hWait == NULL, "Wait not executed or removed in CThemeManagerSessionData::~CThemeManagerSessionData");
    ASSERTMSG(_hProcessClient == NULL, "_hProcessClient not closed in CThemeManagerSessionData::~CThemeManagerSessionData");
    TSTATUS(UserLogoff());
    if (_pvThemeLoaderData != NULL)
    {
        SessionFree(_pvThemeLoaderData);
        _pvThemeLoaderData = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::GetData
//
//  Arguments:  <none>
//
//  Returns:    void*
//
//  Purpose:    Returns the internal data blob allocated by SessionCreate.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

void*   CThemeManagerSessionData::GetData (void)  const

{
    return(_pvThemeLoaderData);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::EqualSessionID
//
//  Arguments:  dwSessionID
//
//  Returns:    bool
//
//  Purpose:    Returns whether the given session ID matches this session
//              data.
//
//  History:    2000-11-30  vtan        created
//  --------------------------------------------------------------------------

bool    CThemeManagerSessionData::EqualSessionID (DWORD dwSessionID)  const

{
    return(dwSessionID == _dwSessionID);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::Allocate
//
//  Arguments:  hProcessClient  =   Handle to the client process.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Allocates a data blob via SessionCreate which also keeps a
//              handle to the client process that initiated the session. This
//              is always winlogon in the client session ID.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerSessionData::Allocate (HANDLE hProcessClient, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit)

{
    NTSTATUS    status;

    if (DuplicateHandle(GetCurrentProcess(),
                        hProcessClient,
                        GetCurrentProcess(),
                        &_hProcessClient,
                        SYNCHRONIZE,
                        FALSE,
                        0) != FALSE)
    {
        ASSERTMSG(_hWait == NULL, "_hWait already exists in CThemeManagerSessionData::Allocate");
        AddRef();
        if (RegisterWaitForSingleObject(&_hWait,
                                        _hProcessClient,
                                        CB_SessionTermination,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE) != FALSE)
        {
            _pvThemeLoaderData = SessionAllocate(hProcessClient, dwServerChangeNumber, pfnRegister, pfnUnregister, pfnClearStockObjects, dwStackSizeReserve, dwStackSizeCommit);
            if (_pvThemeLoaderData != NULL)
            {
                status = STATUS_SUCCESS;
            }
            else
            {
                status = STATUS_NO_MEMORY;
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
        if (!NT_SUCCESS(status))
        {
            HANDLE  hWait;

            //  In the case of failure grab the _hWait and try to unregister it.
            //  If the unregister fails then the callback is already executing
            //  and there's little we can to stop it. This means that the winlogon
            //  for the client session died between the time we entered this function
            //  and registered the wait and now. If the unregister worked then then
            //  callback hasn't executed so just release the resources.

            hWait = InterlockedExchangePointer(&_hWait, NULL);
            if (hWait != NULL)
            {
                if (UnregisterWait(hWait) != FALSE)
                {
                    Release();
                }
                ReleaseHandle(_hProcessClient);
                if (_pvThemeLoaderData != NULL)
                {
                    SessionFree(_pvThemeLoaderData);
                    _pvThemeLoaderData = NULL;
                }
            }
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::Cleanup
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Used to unregister the wait on the client process. This is
//              necessary to prevent the callback from occurring after the
//              service has been shut down which will cause access to a static
//              member variable that is NULL'd out.
//
//  History:    2001-01-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerSessionData::Cleanup (void)

{
    HANDLE  hWait;

    hWait = InterlockedExchangePointer(&_hWait, NULL);
    if (hWait != NULL)
    {
        if (UnregisterWait(hWait) != FALSE)
        {
            Release();
        }
        ReleaseHandle(_hProcessClient);
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::UserLogon
//
//  Arguments:  hToken  =   Handle to the token of the user logging on.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Saves a copy of the token for use at log off. Allows access
//              to the theme port to the logon SID of the token.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerSessionData::UserLogon (HANDLE hToken)

{
    NTSTATUS    status;

    if (_hToken == NULL)
    {
        if (DuplicateHandle(GetCurrentProcess(),
                            hToken,
                            GetCurrentProcess(),
                            &_hToken,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS) != FALSE)
        {
            PSID                pSIDLogon;
            CTokenInformation   token(hToken);

            pSIDLogon = token.GetLogonSID();
            if (pSIDLogon != NULL)
            {
                if (s_pAPIConnection != NULL)
                {
                    status = s_pAPIConnection->AddAccess(pSIDLogon, PORT_CONNECT);
                }
                else
                {
                    status = STATUS_SUCCESS;
                }
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::UserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Remove access to the theme port for the user being logged off.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeManagerSessionData::UserLogoff (void)

{
    NTSTATUS    status;

    if (_hToken != NULL)
    {
        PSID                pSIDLogon;
        CTokenInformation   token(_hToken);

        pSIDLogon = token.GetLogonSID();
        if (pSIDLogon != NULL)
        {
            if (s_pAPIConnection != NULL)
            {
                status = s_pAPIConnection->RemoveAccess(pSIDLogon);
            }
            else
            {
                status = STATUS_SUCCESS;
            }
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
        ReleaseHandle(_hToken);
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::SetAPIConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Sets the static CAPIConnection for port access changes.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

void    CThemeManagerSessionData::SetAPIConnection (CAPIConnection *pAPIConnection)

{
    pAPIConnection->AddRef();
    s_pAPIConnection = pAPIConnection;
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::ReleaseAPIConnection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the static CAPIConnection for port access changes.
//
//  History:    2000-12-02  vtan        created
//  --------------------------------------------------------------------------

void    CThemeManagerSessionData::ReleaseAPIConnection (void)

{
    s_pAPIConnection->Release();
    s_pAPIConnection = NULL;
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::SessionTermination
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Callback on winlogon process termination for a given session.
//              We clean up the session specific data blob when this happens.
//              This allows the process handles on winlogon to be released.
//              If this isn't done then a zombie lives and the session is
//              never reclaimed.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

void    CThemeManagerSessionData::SessionTermination (void)

{
    HANDLE  hWait;

    hWait = InterlockedExchangePointer(&_hWait, NULL);
    if (hWait != NULL)
    {
        (BOOL)UnregisterWait(hWait);
        ReleaseHandle(_hProcessClient);
    }
    CThemeManagerAPIRequest::SessionDestroy(_dwSessionID);
    Release();
}

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData::CB_SessionTermination
//
//  Arguments:  pParameter          =   This object.
//              TimerOrWaitFired    =   Not used.
//
//  Returns:    <none>
//
//  Purpose:    Callback stub to member function.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CThemeManagerSessionData::CB_SessionTermination (void *pParameter, BOOLEAN TimerOrWaitFired)

{
    UNREFERENCED_PARAMETER(TimerOrWaitFired);

    static_cast<CThemeManagerSessionData*>(pParameter)->SessionTermination();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\thememanagersessiondata.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeManagerSessionData.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements information the encapsulates a
//  client TS session for the theme server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

#ifndef     _ThemeManagerSessionData_
#define     _ThemeManagerSessionData_

#include "APIConnection.h"

//  --------------------------------------------------------------------------
//  CThemeManagerSessionData
//
//  Purpose:    This class encapsulates all the information that the theme
//              manager needs to maintain a client session.
//
//  History:    2000-11-17  vtan        created
//              2000-11-29  vtan        moved to separate file
//  --------------------------------------------------------------------------

class   CThemeManagerSessionData : public CCountedObject
{
    private:
                                    CThemeManagerSessionData (void);
    public:
                                    CThemeManagerSessionData (DWORD dwSessionID);
                                    ~CThemeManagerSessionData (void);

                void*               GetData (void)  const;
                bool                EqualSessionID (DWORD dwSessionID)  const;

                NTSTATUS            Allocate (HANDLE hProcessClient, DWORD dwServerChangeNumber, void *pfnRegister, void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit);
                NTSTATUS            Cleanup (void);
                NTSTATUS            UserLogon (HANDLE hToken);
                NTSTATUS            UserLogoff (void);

        static  void                SetAPIConnection (CAPIConnection *pAPIConnection);
        static  void                ReleaseAPIConnection (void);
    private:
                void                SessionTermination (void);
        static  void    CALLBACK    CB_SessionTermination (void *pParameter, BOOLEAN TimerOrWaitFired);
        static  DWORD   WINAPI      CB_UnregisterWait (void *pParameter);
    private:
                DWORD               _dwSessionID;
                void*               _pvThemeLoaderData;
                HANDLE              _hToken;
                HANDLE              _hProcessClient;
                HANDLE              _hWait;
        static  CAPIConnection*     s_pAPIConnection;
};

#endif  /*  _ThemeManagerSessionData_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\themeservice.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeService.h
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that are called from the shell services DLL
//  to interact with the theme service.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeService_
#define     _ThemeService_

//  --------------------------------------------------------------------------
//  CThemeService
//
//  Purpose:    Class that implements entry points for the common shell
//              service to invoke theme service functionality.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

class   CThemeService
{
    public:
        static  NTSTATUS        Main (DWORD dwReason);
        static  NTSTATUS        RegisterServer (void);
        static  NTSTATUS        UnregisterServer (void);
};

#endif  /*  _ThemeService_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\themeserverclient.h ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServerClient.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the theme server functions that
//  are executed in a client context (winlogon context).
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ThemeServerClient_
#define     _ThemeServerClient_

#include "KernelResources.h"
#include "ThemeManagerAPIServer.h"

//  --------------------------------------------------------------------------
//  CThemeServerClient
//
//  Purpose:    This class implements external entry points for the theme
//              server (typically used by winlogon).
//
//  History:    2000-10-10  vtan        created
//  --------------------------------------------------------------------------

class   CThemeServerClient
{
    private:
                                            CThemeServerClient (void);
                                            ~CThemeServerClient (void);
    public:
        static  DWORD                       WaitForServiceReady (DWORD dwTimeout);
        static  NTSTATUS                    WatchForStart (void);
        static  NTSTATUS                    UserLogon (HANDLE hToken);
        static  NTSTATUS                    UserLogoff (void);
        static  NTSTATUS                    UserInitTheme (BOOL fPolicyCheckOnly);

        static  NTSTATUS                    StaticInitialize (void);
        static  NTSTATUS                    StaticTerminate (void);
    private:
        static  NTSTATUS                    NotifyUserLogon (HANDLE hToken);
        static  NTSTATUS                    NotifyUserLogoff (void);
        static  NTSTATUS                    InformServerUserLogon (HANDLE hToken);
        static  NTSTATUS                    InformServerUserLogoff (void);
        static  NTSTATUS                    SessionCreate (void);
        static  NTSTATUS                    SessionDestroy (void);
        static  NTSTATUS                    ReestablishConnection (void);

        static  void    CALLBACK            CB_ServiceStart (void *pParameter, BOOLEAN TimerOrWaitFired);
    private:
        static  CThemeManagerAPIServer*     s_pThemeManagerAPIServer;
        static  HANDLE                      s_hPort;
        static  HANDLE                      s_hToken;
        static  HANDLE                      s_hEvent;
        static  HANDLE                      s_hWaitObject;
        static  HMODULE                     s_hModuleUxTheme;
        static  CCriticalSection*           s_pLock;
};

#endif  /*  _ThemeServerClient_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\themeserverexports.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServerExports.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains functions that exported from the theme services module.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include "StatusCode.h"
#include "ThemeServerClient.h"
#include <uxthemep.h>

//  --------------------------------------------------------------------------
//  ::ThemeWaitForServiceReady
//
//  Arguments:  dwTimeout   =   Number of ticks to wait.
//
//  Returns:    DWORD
//
//  Purpose:    External C entry point to DLL to wait for the service to
//              enter the running state.
//
//  History:    2000-10-13  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI      ThemeWaitForServiceReady (DWORD dwTimeout)

{
    return(CThemeServerClient::WaitForServiceReady(dwTimeout));
}

//  --------------------------------------------------------------------------
//  ::ThemeWatchForStart
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to DLL to watch for the service
//              recovering or demand starting.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI      ThemeWatchForStart (void)

{
    bool        fResult;
    NTSTATUS    status;

    status = CThemeServerClient::WatchForStart();
    fResult = NT_SUCCESS(status);
    if (!fResult)
    {
        SetLastError(CStatusCode::ErrorCodeOfStatusCode(status));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::ThemeUserLogon
//
//  Arguments:  hToken  =   Token of user that logged on.
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to DLL to signal a user logon.
//
//  History:    2000-10-12  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ThemeUserLogon (HANDLE hToken)

{
    bool        fResult;
    NTSTATUS    status;

    status = CThemeServerClient::UserLogon(hToken);
    fResult = NT_SUCCESS(status);
    if (!fResult)
    {
        SetLastError(CStatusCode::ErrorCodeOfStatusCode(status));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::ThemeUserLogoff
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to DLL to signal a user logoff.
//
//  History:    2000-10-12  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ThemeUserLogoff (void)

{
    bool        fResult;
    NTSTATUS    status;

    status = CThemeServerClient::UserLogoff();
    fResult = NT_SUCCESS(status);
    if (!fResult)
    {
        SetLastError(CStatusCode::ErrorCodeOfStatusCode(status));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::ThemeUserTSReconnect
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    External C entry point to DLL to signal terminal server
//              "reconnect" (remote connect to a session or reestablish
//              local connect to a session).
//
//  History:    2001-01-18  rfernand    created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ThemeUserTSReconnect (void)

{
    //---- this may turn theme on/off based on local/remote conditions ----
    CThemeServerClient::UserInitTheme(FALSE);

    return(true);       // always succeeds
}

//  --------------------------------------------------------------------------
//  ::ThemeUserStartShell
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Load the theme for this user
//
//  History:    2001-03-29  lmouton     created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ThemeUserStartShell (void)

{
    //---- this may turn theme on/off based on local/remote conditions ----
    CThemeServerClient::UserInitTheme(TRUE);

    return(true);       // always succeeds
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\about.cpp ===
#include "priv.h"

#include <mluisupp.h>

//
//  The about box is now an HTML dialog. It is sent a ~ (tilde) 
//  delimited BSTR that has, in this order, version number, 
//  person software is licensed to, company software is licensed to, and 
//  whether 40, 56, or 128 bit ie is installed.
//

STDAPI_(void) IEAboutBox( HWND hWnd )
{
    TCHAR szInfo[512 + INTERNET_MAX_URL_LENGTH];  // potential for IEAK specific URL from 
                                                  // SHAboutInfo
    szInfo[0] = 0;

    SHAboutInfo(szInfo, ARRAYSIZE(szInfo));     // from shlwapi

    BSTR bstrVal = SysAllocStringT(szInfo);
    if (bstrVal)
    {
        TCHAR   szResURL[MAX_URL_STRING];
        HRESULT hr;

        hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                               HINST_THISDLL,
                               ML_CROSSCODEPAGE,
                               TEXT("about.dlg"),
                               szResURL,
                               ARRAYSIZE(szResURL),
                               TEXT("shdocvw.dll"));
        if (SUCCEEDED(hr))
        {
            VARIANT var = {0};      // variant containing version and user info
            var.vt = VT_BSTR;
            var.bstrVal = bstrVal;

            IMoniker *pmk;
            if (SUCCEEDED(CreateURLMoniker(NULL, szResURL, &pmk)))
            {
                ShowHTMLDialog(hWnd, pmk, &var, L"help: no", NULL);
                pmk->Release();
            }
            SysFreeString(bstrVal);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\themeservice.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeService.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  This file contains functions that are called from the shell services DLL
//  to interact with the theme service.
//
//  History:    2001-01-02  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeService.h"
#include <shlwapi.h>
#include <shlwapip.h>

#include "Resource.h"
#include "ThemeManagerAPIRequest.h"
#include "ThemeManagerService.h"
#include "ThemeServerClient.h"

extern  HINSTANCE   g_hInstance;

//  --------------------------------------------------------------------------
//  CThemeService::Main
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    See the platform SDK under DllMain.
//
//  Purpose:    Performs initialization and clean up on process attach and
//              detach. Not interested in anything else.
//
//  History:    2000-10-12  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CThemeService::Main (DWORD dwReason)

{
    NTSTATUS    status;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            status = CThemeManagerAPIRequest::StaticInitialize();
            if (NT_SUCCESS(status))
            {
                status = CThemeServerClient::StaticInitialize();
            }
            break;
        case DLL_PROCESS_DETACH:
            TSTATUS(CThemeServerClient::StaticTerminate());
            TSTATUS(CThemeManagerAPIRequest::StaticTerminate());
            status = STATUS_SUCCESS;
            break;
        default:
            status = STATUS_SUCCESS;
            break;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeService::DllRegisterServer
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Register entry point to allow the theme server to install
//              itself into the registry.
//
//  History:    2000-11-28  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CThemeService::RegisterServer (void)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;

    //  In upgrade cases, remove our old name service from both 32 & 64 bit systems

    (NTSTATUS)CService::Remove(TEXT("ThemeService"));

#ifdef _WIN64

    //  In upgrade cases for 64-bit, remove our current name service

    (NTSTATUS)CService::Remove(CThemeManagerService::GetName());

#else
    
    //  This is 32-bit only. Check if this is REALLY 32-bit and not 32-bit on 64-bit.

    if (!IsOS(OS_WOW6432))
    {
        // Prepare the failure actions, in order to get the service to restart automatically

        SC_ACTION ac[3];
        ac[0].Type = SC_ACTION_RESTART;
        ac[0].Delay = 60000;
        ac[1].Type = SC_ACTION_RESTART;
        ac[1].Delay = 60000;
        ac[2].Type = SC_ACTION_NONE;
        ac[2].Delay = 0;
        
        SERVICE_FAILURE_ACTIONS sf;
        sf.dwResetPeriod = 86400;
        sf.lpRebootMsg = NULL;
        sf.lpCommand = NULL;
        sf.cActions = 3;
        sf.lpsaActions = ac;

        //  Now install the new service by name.

        status = CService::Install(CThemeManagerService::GetName(),
                                 TEXT("%SystemRoot%\\System32\\svchost.exe -k netsvcs"),
                                 TEXT("UIGroup"),
                                 NULL,
                                 TEXT("shsvcs.dll"),
                                 NULL,
                                 TEXT("netsvcs"),
                                 TEXT("ThemeServiceMain"),
                                 SERVICE_AUTO_START,
                                 g_hInstance,
                                 IDS_THEMESERVER_DISPLAYNAME,
                                 IDS_THEMESERVER_DESCRIPTION,
                                 &sf);

    }

#endif

    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeService::DllUnregisterServer
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Unregister entry point to allow the theme server to uninstall
//              itself from the registry.
//
//  History:    2000-11-28  vtan        created
//              2001-01-02  vtan        scoped to a C++ class
//  --------------------------------------------------------------------------

NTSTATUS    CThemeService::UnregisterServer (void)

{

    //  Ignore any "not found", etc errors.

    (NTSTATUS)CService::Remove(CThemeManagerService::GetName());
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  ::ThemeServiceMain
//
//  Arguments:  dwArgc      =   Number of arguments.
//              lpszArgv    =   Argument array.
//
//  Returns:    <none>
//
//  Purpose:    ServiceMain entry point for theme server.
//
//  History:    2000-11-28  vtan        created
//              2001-01-02  vtan        scoped to the theme service
//  --------------------------------------------------------------------------

void    WINAPI  ThemeServiceMain (DWORD dwArgc, LPWSTR *lpszArgv)

{
    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpszArgv);

    NTSTATUS    status;

    status = CThemeManagerAPIRequest::InitializeServerChangeNumber();
    if (NT_SUCCESS(status))
    {
        CThemeManagerAPIServer  *pThemeManagerAPIServer;

        //  Bring in shell32.dll NOW so that when CheckThemeSignature is called
        //  and it tries to use SHGetFolderPath it won't cause shell32.dll to be
        //  brought in while impersonating a user. This will cause advapi32.dll
        //  to leak a key to the user's hive that won't get cleaned up at logoff.

        CModule     hModule(TEXT("shell32.dll"));

        pThemeManagerAPIServer = new CThemeManagerAPIServer;
        if (pThemeManagerAPIServer != NULL)
        {
            CAPIConnection  *pAPIConnection;

            pAPIConnection = new CAPIConnection(pThemeManagerAPIServer);
            if (pAPIConnection != NULL)
            {
                CThemeManagerService    *pThemeManagerService;

                pThemeManagerService = new CThemeManagerService(pAPIConnection, pThemeManagerAPIServer);
                if (pThemeManagerService != NULL)
                {
                    CThemeManagerSessionData::SetAPIConnection(pAPIConnection);
                    TSTATUS(CThemeManagerAPIRequest::ArrayInitialize());
                    pThemeManagerService->Start();
                    pThemeManagerService->Release();
                    TSTATUS(CThemeManagerAPIRequest::ArrayTerminate());
                    CThemeManagerSessionData::ReleaseAPIConnection();
                }
                pAPIConnection->Release();
            }
            pThemeManagerAPIServer->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\services\themesrv\themeserverclient.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ThemeServerClient.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  This file contains a class that implements the theme server functions that
//  are executed in a client context (winlogon context).
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "ThemeServerClient.h"

#include <lpcthemes.h>
#include <uxthemep.h>
#include <UxThemeServer.h>

#include "SingleThreadedExecution.h"
#include "StatusCode.h"
#include "ThemeManagerService.h"
#include <Impersonation.h>

//  --------------------------------------------------------------------------
//  CThemeManagerAPI::s_pThemeManagerAPIServer
//  CThemeManagerAPI::s_hPort
//  CThemeManagerAPI::s_hToken
//  CThemeManagerAPI::s_hEvent
//  CThemeManagerAPI::s_hWaitObject
//  CThemeManagerAPI::s_pLock
//
//  Purpose:    Static member variables.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

CThemeManagerAPIServer*     CThemeServerClient::s_pThemeManagerAPIServer    =   NULL;
HANDLE                      CThemeServerClient::s_hPort                     =   NULL;
HANDLE                      CThemeServerClient::s_hToken                    =   NULL;
HANDLE                      CThemeServerClient::s_hEvent                    =   NULL;
HANDLE                      CThemeServerClient::s_hWaitObject               =   NULL;
HMODULE                     CThemeServerClient::s_hModuleUxTheme            =   NULL;
CCriticalSection*           CThemeServerClient::s_pLock                     =   NULL;

//  --------------------------------------------------------------------------
//  CThemeServerClient::WaitForServiceReady
//
//  Arguments:  dwTimeout   =   Number of ticks to wait.
//
//  Returns:    DWORD
//
//  Purpose:    Check if the service is autostart. If so then wait the
//              designated amount of time for the service. If the service
//              is then running or was running but isn't autostart then
//              re-establish the connection to the server.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

DWORD   CThemeServerClient::WaitForServiceReady (DWORD dwTimeout)

{
    DWORD       dwWaitResult;
    NTSTATUS    status;

    dwWaitResult = WAIT_TIMEOUT;
    if (s_pThemeManagerAPIServer->IsAutoStart())
    {
        status = s_pThemeManagerAPIServer->Wait(dwTimeout);
#ifdef      DBG
        if (STATUS_TIMEOUT == status)
        {
            INFORMATIONMSG("Wait on auto start theme service timed out.");
        }
#endif  /*  DBG     */
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    if (NT_SUCCESS(status) && s_pThemeManagerAPIServer->IsRunning())
    {
        status = ReestablishConnection();
        if (NT_SUCCESS(status))
        {
            THR(InitUserRegistry());
            THR(InitUserTheme(FALSE));
            dwWaitResult = WAIT_OBJECT_0;
        }
    }
    return(dwWaitResult);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::WatchForStart
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens or creates the theme server announce event. This is a
//              manual reset event which the theme server pulses when it
//              starts up. This allows winlogon to initiate new connections
//              to the theme server without having to wait for logon or
//              logoff events to happen.
//
//              This event is intentionally leaked and cleaned up when the
//              winlogon process for the session goes away.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::WatchForStart (void)

{
    NTSTATUS    status;

    s_hEvent = CThemeManagerService::OpenStartEvent(NtCurrentPeb()->SessionId, SYNCHRONIZE);
    if (s_hEvent != NULL)
    {
        if (RegisterWaitForSingleObject(&s_hWaitObject,
                                        s_hEvent,
                                        CB_ServiceStart,
                                        NULL,
                                        INFINITE,
                                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::UserLogon
//
//  Arguments:  hToken  =   Token of user logging on.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signals the server that a user is logging on and gives the
//              server the handle to the token. The server will grant access
//              to the port based on the user's logon SID. Then perform work
//              to initialize the environment for the user logging on.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::UserLogon (HANDLE hToken)

{
    NTSTATUS    status;

    status = NotifyUserLogon(hToken);
    if (STATUS_PORT_DISCONNECTED == status)
    {
        status = ReestablishConnection();
        if (NT_SUCCESS(status))
        {
            status = NotifyUserLogon(hToken);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::UserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signals the server that the current user for this session is
//              logging off. The server will remove the access that was
//              granted at logon and reinitialize the theme settings to the
//              ".Default" settings.
//
//  History:    2000-10-10  vtan        created
//              2000-11-29  vtan        converted to a Win32 service
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::UserLogoff (void)

{
    NTSTATUS    status;

    status = NotifyUserLogoff();
    if (STATUS_PORT_DISCONNECTED == status)
    {
        status = ReestablishConnection();
        if (NT_SUCCESS(status))
        {
            status = NotifyUserLogoff();
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::UserInitTheme
//
//  Arguments:  BOOL
//
//  Returns:    NTSTATUS
//
//  Purpose:    Called at logon, or when Terminal Server connects a user to a 
//              remote session or reconnects to a local session.  Needs to 
//              evaluate the environment and decide if themes need to be loaded
//              or unloaded.
//
//  History:    2000-01-18  rfernand        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::UserInitTheme (BOOL fPolicyCheckOnly)

{
    bool    fSuccessfulImpersonation;

    //  If there's a token impersonate the user. Otherwise use the system context.

    if (s_hToken != NULL)
    {
        fSuccessfulImpersonation = NT_SUCCESS(CImpersonation::ImpersonateUser(GetCurrentThread(), s_hToken));
    }
    else
    {
        fSuccessfulImpersonation = true;
    }
    if (fSuccessfulImpersonation)
    {
        (HRESULT)InitUserTheme(fPolicyCheckOnly);
    }
    if (fSuccessfulImpersonation && (s_hToken != NULL))
    {
        TBOOL(RevertToSelf());
    } 
    return STATUS_SUCCESS;
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes static member variables. Allocate a
//              CThemeManagerAPIServer and a lock for this object.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::StaticInitialize (void)

{
    NTSTATUS    status;

    if (s_pThemeManagerAPIServer == NULL)
    {
        status = STATUS_NO_MEMORY;
        s_pThemeManagerAPIServer = new CThemeManagerAPIServer;
        if (s_pThemeManagerAPIServer != NULL)
        {
            s_pLock = new CCriticalSection;
            if (s_pLock != NULL)
            {
                status = STATUS_SUCCESS;
            }
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Release static member variables initialized.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::StaticTerminate (void)

{
    if (s_pLock != NULL)
    {
        delete s_pLock;
        s_pLock = NULL;
    }
    if (s_pThemeManagerAPIServer != NULL)
    {
        s_pThemeManagerAPIServer->Release();
        s_pThemeManagerAPIServer = NULL;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::NotifyUserLogon
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Execute the send message to the server and tell it that the
//              given user is now logged on. This will instruct the server
//              to grant access to the ThemeApiPort.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::NotifyUserLogon (HANDLE hToken)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    lock(*s_pLock);

    if (s_hPort != NULL)
    {
        status = InformServerUserLogon(hToken);
    }
    else
    {
        status = STATUS_PORT_DISCONNECTED;
    }

    //  Keep a copy of the token as well in case of demand start of
    //  the theme server so we can impersonate the user when we load
    //  their theme using InitUserTheme. Don't copy it if it already
    //  exists.

    if (s_hToken == NULL)
    {
        TBOOL(DuplicateHandle(GetCurrentProcess(),
                              hToken,
                              GetCurrentProcess(),
                              &s_hToken,
                              0,
                              FALSE,
                              DUPLICATE_SAME_ACCESS));
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::NotifyUserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Tell the server that the logged on user is logged off. This
//              will remove access to ThemeApiPort.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::NotifyUserLogoff (void)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    lock(*s_pLock);

    if (s_hToken != NULL)
    {
        ReleaseHandle(s_hToken);
        if (s_hPort != NULL)
        {
            status = InformServerUserLogoff();
        }
        else
        {
            status = STATUS_PORT_DISCONNECTED;
        }
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::InformServerUserLogon
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Tell the server that the logged on user is logged off. This
//              will remove access to ThemeApiPort.
//
//  History:    2000-12-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::InformServerUserLogon (HANDLE hToken)

{
    NTSTATUS                status;
    THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

    ZeroMemory(&portMessageIn, sizeof(portMessageIn));
    ZeroMemory(&portMessageOut, sizeof(portMessageOut));
    portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_USERLOGON;
    portMessageIn.apiThemes.apiSpecific.apiUserLogon.in.hToken = hToken;
    portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
    portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
    status = NtRequestWaitReplyPort(s_hPort,
                                    &portMessageIn.portMessage,
                                    &portMessageOut.portMessage);
    if (NT_SUCCESS(status))
    {
        status = portMessageOut.apiThemes.apiGeneric.status;
        if (NT_SUCCESS(status))
        {
            THR(InitUserTheme(FALSE));
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::InformServerUserLogoff
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Tell the server that the logged on user is logged off. This
//              will remove access to ThemeApiPort.
//
//  History:    2000-12-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::InformServerUserLogoff (void)

{
    NTSTATUS                status;
    THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

    ZeroMemory(&portMessageIn, sizeof(portMessageIn));
    ZeroMemory(&portMessageOut, sizeof(portMessageOut));
    portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_USERLOGOFF;
    portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
    portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
    status = NtRequestWaitReplyPort(s_hPort,
                                    &portMessageIn.portMessage,
                                    &portMessageOut.portMessage);
    if (NT_SUCCESS(status))
    {
        status = portMessageOut.apiThemes.apiGeneric.status;
        if (NT_SUCCESS(status))
        {
            THR(InitUserRegistry());
            THR(InitUserTheme(FALSE));
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::SessionCreate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signal the server that a new session is being created. This
//              allows the server to allocate a data blob for this session.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::SessionCreate (void)

{
    NTSTATUS                    status;
    CSingleThreadedExecution    lock(*s_pLock);

    if (s_hModuleUxTheme == NULL)
    {
        s_hModuleUxTheme = LoadLibrary(TEXT("uxtheme.dll"));
    }
    if (s_hModuleUxTheme != NULL)
    {
        void    *pfnRegister, *pfnUnregister, *pfnClearStockObjects;

        //  Get the uxtheme function addresses in this process address space.
        //      34  =   ThemeHooksInstall
        //      35  =   ThemeHooksRemove
        //      62  =   ServerClearStockObjects

        pfnRegister = GetProcAddress(s_hModuleUxTheme, MAKEINTRESOURCEA(34));
        pfnUnregister = GetProcAddress(s_hModuleUxTheme, MAKEINTRESOURCEA(35));
        pfnClearStockObjects = GetProcAddress(s_hModuleUxTheme, MAKEINTRESOURCEA(62));

        if ((pfnRegister != NULL) && (pfnUnregister != NULL) && (pfnClearStockObjects != NULL))
        {
            DWORD                       dwStackSizeReserve, dwStackSizeCommit;
            ULONG                       ulReturnLength;
            IMAGE_NT_HEADERS            *pNTHeaders;
            SYSTEM_BASIC_INFORMATION    systemBasicInformation;
            THEMESAPI_PORT_MESSAGE      portMessageIn, portMessageOut;

            //  Get system basic information for stack size defaults.

            status = NtQuerySystemInformation(SystemBasicInformation,
                                              &systemBasicInformation,
                                              sizeof(systemBasicInformation),
                                              &ulReturnLength);
            if (NT_SUCCESS(status))
            {
                dwStackSizeReserve = systemBasicInformation.AllocationGranularity;
                dwStackSizeCommit = systemBasicInformation.PageSize;
            }
            else
            {
                dwStackSizeReserve = dwStackSizeCommit = 0;
            }

            //  Go to the image header for this process and get the stack size
            //  defaults if they are specified. Otherwise use system defaults (above).

            pNTHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);
            if (pNTHeaders != NULL)
            {
                dwStackSizeReserve = static_cast<DWORD>(pNTHeaders->OptionalHeader.SizeOfStackReserve);
                dwStackSizeCommit = static_cast<DWORD>(pNTHeaders->OptionalHeader.SizeOfStackCommit);
            }

            //  Make the call.

            ZeroMemory(&portMessageIn, sizeof(portMessageIn));
            ZeroMemory(&portMessageOut, sizeof(portMessageOut));
            portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_SESSIONCREATE;
            portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.pfnRegister = pfnRegister;
            portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.pfnUnregister = pfnUnregister;
            portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.pfnClearStockObjects = pfnClearStockObjects;
            portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.dwStackSizeReserve = dwStackSizeReserve;
            portMessageIn.apiThemes.apiSpecific.apiSessionCreate.in.dwStackSizeCommit = dwStackSizeCommit;
            portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
            portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
            status = NtRequestWaitReplyPort(s_hPort,
                                            &portMessageIn.portMessage,
                                            &portMessageOut.portMessage);
            if (NT_SUCCESS(status))
            {
                status = portMessageOut.apiThemes.apiGeneric.status;
            }
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::SessionDestroy
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Signal the server that the current session is about to be
//              destroyed. This allows the server to release the data blob
//              allocated.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::SessionDestroy (void)

{
    NTSTATUS                    status;
    THEMESAPI_PORT_MESSAGE      portMessageIn, portMessageOut;
    CSingleThreadedExecution    lock(*s_pLock);

    ZeroMemory(&portMessageIn, sizeof(portMessageIn));
    ZeroMemory(&portMessageOut, sizeof(portMessageOut));
    portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_SESSIONDESTROY;
    portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
    portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
    status = NtRequestWaitReplyPort(s_hPort,
                                    &portMessageIn.portMessage,
                                    &portMessageOut.portMessage);
    if (NT_SUCCESS(status))
    {
        status = portMessageOut.apiThemes.apiGeneric.status;
    }
    if (s_hModuleUxTheme != NULL)
    {
        TBOOL(FreeLibrary(s_hModuleUxTheme));
        s_hModuleUxTheme = NULL;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::ReestablishConnection
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Reconnects to theme server. If the reconnection is established
//              the re-create the session data. This will not correct any
//              disconnected ports that some clients may have but because this
//              is called in winlogon it re-establish this correctly for
//              session 0 in all cases.
//
//              UnregisterUserApiHook must be called to clear any left over
//              registrations from a server that died. Then go ahead and
//              re-initialize the environment anyway.
//
//  History:    2000-11-17  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThemeServerClient::ReestablishConnection (void)

{
    NTSTATUS    status;

    ReleaseHandle(s_hPort);
    status = s_pThemeManagerAPIServer->ConnectToServer(&s_hPort);
    if (NT_SUCCESS(status))
    {
        status = SessionCreate();
        if (NT_SUCCESS(status))
        {
            (BOOL)UnregisterUserApiHook();
            THR(ReestablishServerConnection());
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThemeServerClient::CB_ServiceStart
//
//  Arguments:  pParameter          =   User parameter.
//              TimerOrWaitFired    =   Timer or wait fired.
//
//  Returns:    <none>
//
//  Purpose:    Callback called when the theme server ready event is signaled.
//              This indicates that the service was demand started or
//              restarted in the event of failure.
//
//  History:    2000-11-29  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CThemeServerClient::CB_ServiceStart (void *pParameter, BOOLEAN TimerOrWaitFired)

{
    UNREFERENCED_PARAMETER(pParameter);
    UNREFERENCED_PARAMETER(TimerOrWaitFired);

    NTSTATUS                    status;
    CSingleThreadedExecution    lock(*s_pLock);

    //  If there is a connection ping it.

    if (s_hPort != NULL)
    {
        THEMESAPI_PORT_MESSAGE  portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiThemes.apiGeneric.ulAPINumber = API_THEMES_PING;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_THEMES);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(THEMESAPI_PORT_MESSAGE));
        status = NtRequestWaitReplyPort(s_hPort,
                                        &portMessageIn.portMessage,
                                        &portMessageOut.portMessage);
        if (NT_SUCCESS(status))
        {
            status = portMessageOut.apiThemes.apiGeneric.status;
        }
    }
    else
    {
        status = STATUS_PORT_DISCONNECTED;
    }
    if (STATUS_PORT_DISCONNECTED == status)
    {
        HDESK   hDeskCurrent, hDeskInput;

        //  Set this thread's desktop to the input desktop so
        //  that the theme change can be broadcast to the input
        //  desktop. This is Default in most cases where a logged
        //  on user is active but in the non-logged on user case
        //  this will be Winlogon. Restore the thread's desktop
        //  when done.

        TSTATUS(ReestablishConnection());
        hDeskCurrent = hDeskInput = NULL;
        if (s_hToken != NULL)
        {
            hDeskCurrent = GetThreadDesktop(GetCurrentThreadId());
            hDeskInput = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
            if ((hDeskCurrent != NULL) && (hDeskInput != NULL))
            {
                TBOOL(SetThreadDesktop(hDeskInput));
            }
            if (NT_SUCCESS(CImpersonation::ImpersonateUser(GetCurrentThread(), s_hToken)))
            {
                TSTATUS(InformServerUserLogon(s_hToken));
            }
            if ((hDeskCurrent != NULL) && (hDeskInput != NULL))
            {
                SetThreadDesktop(hDeskCurrent);
                (BOOL)CloseDesktop(hDeskInput);
            }
            TBOOL(RevertToSelf());
        }
        else
        {
            THR(InitUserRegistry());
            THR(InitUserTheme(FALSE));
        }
    }

    //  Reset the event here and now.

    TBOOL(ResetEvent(s_hEvent));

    //  Unregister the original wait (it only executes once anyway). This
    //  call will return a failure code with the callback in progress.
    //  Ignore this error. The thread pool will clean up the wait.

    (BOOL)UnregisterWait(s_hWaitObject);

    //  Reregister the wait as execute once only again waiting for
    //  the next time the event is signaled.

    TBOOL(RegisterWaitForSingleObject(&s_hWaitObject,
                                      s_hEvent,
                                      CB_ServiceStart,
                                      NULL,
                                      INFINITE,
                                      WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\advanced.h ===
#ifndef _ADVANCED_H_
#define _ADVANCED_H_

#error DELETEMECHEE
// nobody seems to use this header file, which is good
// because for months it had a build-breaking typo. -raymondc
BOOL CALLBACK AdvancedOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\admovr2.h ===
/***************************************************************************/
/* WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! */
/***************************************************************************/
/* As part of the shdocvw/browseui split, this file is moving to           */
/* shell32\unicpp\admovr2.h.  Make sure you make your delta to the         */
/* shell32 version if you don't want your changes to be lost!              */
/***************************************************************************/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Apr 03 11:59:43 1997
 */
/* Compiler settings for ADMover.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ADMover_h__
#define __ADMover_h__

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __ADMOVERLib_LIBRARY_DEFINED__
#define __ADMOVERLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ADMOVERLib
 * at Thu Apr 03 11:59:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 

#ifdef __cplusplus
class DECLSPEC_UUID("72267F6A-A6F9-11D0-BC94-00C04FB67863")
DeskMovr;
#endif


#endif /* __ADMOVERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

#ifndef __ADMOVR2__
#define __ADMOVR2__

#include "mshtml.h"
#include "mshtmdid.h"

//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#ifdef __cplusplus

#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    ATOMICRELEASE(ptr)
#define QUICK_RELEASE(ptr)     ATOMICRELEASE(ptr)
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()

#define NEW_HIT_TEST

    
    interface DECLSPEC_UUID("72267F69-A6F9-11D0-BC94-00C04FB67863")
    IDeskMovr : public IUnknown
    {
    public:        
        virtual HRESULT STDMETHODCALLTYPE Duck( 
            BOOL fDuck) = 0;
 
       virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Engaged( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
    };


    interface DECLSPEC_UUID("72267F6C-A6F9-11D0-BC94-00C04FB67863")
    IDeskSizr : public IUnknown
    {
    public:
         
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Target( 
            /* [in] */ LPDISPATCH newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Engaged( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Duck( 
            BOOL fDuck) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TrackTarget( void) = 0;
        
    };

#endif

#define OLEMISMOVR (OLEMISC_ALWAYSRUN|OLEMISC_NOUIACTIVATE|OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT)
EXTERN_C void PersistTargetPosition( IHTMLElement *pielem,
                            int left,
                            int top,
                            int width,
                            int height,
                            int zIndex,
                            BOOL fSaveRestore,
                            DWORD dwNewState);

EXTERN_C BOOL WINAPI DeskMovr_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

#endif // __ADMOVR2__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\assocurl.h ===
#ifndef _ASSOC_H_
#define _ASSOC_H_

// STDAPI AssociateMIMEA(HWND hwndParent, DWORD dwInFlags, LPCSTR pcszFile, LPCSTR pcszMIMEContentType, LPSTR pszAppBuf, UINT cchAppBuf);
// STDAPI AssociateMIMEW(HWND hwndParent, DWORD dwInFlags, LPCWSTR pcszFile, LPCWSTR pcszMIMEContentType, LPWSTR pszAppBuf, UINT cchAppBuf);

STDAPI AssociateURLA(HWND hwndParent, DWORD dwInFlags, LPCSTR pcszFile, LPCSTR pcszURL, LPSTR pszAppBuf, UINT cchAppBuf);
STDAPI AssociateURLW(HWND hwndParent, DWORD dwInFlags, LPCWSTR pcszFile, LPCWSTR pcszURL, LPWSTR pszAppBuf, UINT cchAppBuf);

#ifdef UNICODE
// #define AssociateMIME     AssociateMIMEW
#define AssociateURL      AssociateURLW
#else
// #define AssociateMIME     AssociateMIMEA
#define AssociateURL      AssociateURLA
#endif

#endif // _ASSOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_

#if (WINVER >= 0x0500)
#else
#define TVS_EX_NOSINGLECOLLAPSE    0x00000001 // for now make this internal
#endif


STDAPI_(DWORD) NT5_GetSaveFileNameW(LPOPENFILENAMEW pofn);
STDAPI_(PROPSHEETPAGE*) Whistler_AllocatePropertySheetPage(int numPages, DWORD* pc);
STDAPI_(HPROPSHEETPAGE) Whistler_CreatePropertySheetPageW(LPCPROPSHEETPAGEW a);


#undef GetSaveFileNameW
#define GetSaveFileNameW NT5_GetSaveFileNameW

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\asyncrat.h ===
class CDocObjectHost;

struct PicsQuery {
	DWORD dwSerial;
	HWND hwnd;
	LPVOID lpvRatingDetails;
};

extern DWORD _AddPicsQuery(HWND hwnd);
extern void _RemovePicsQuery(DWORD dwSerial);
extern BOOL _GetPicsQuery(DWORD dwSerial, PicsQuery *pOut);
extern void _RefPicsQueries(void);
extern void _ReleasePicsQueries(void);
extern BOOL _PostPicsMessage(DWORD dwSerial, HRESULT hr, LPVOID lpvRatingDetails);

#define WM_PICS_ASYNCCOMPLETE           (WM_USER + 0x0501)
#define WM_PICS_ROOTDOWNLOADCOMPLETE    (WM_USER + 0x0502)
#define WM_PICS_ALLCHECKSCOMPLETE       (WM_USER + 0x0503)
#define WM_PICS_DOBLOCKINGUI            (WM_USER + 0x0504)
#define WM_PICS_RESULTTOPRIVWIN         (WM_USER + 0x0505)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\autoscrl.h ===
// stuff for doing auto scrolling
#define NUM_POINTS	3
typedef struct {	// asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0
BOOL DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\airesize.h ===
#ifndef __IEAIRESIZE_H_
#define __IEAIRESIZE_H_

#define AIR_SCREEN_CONSTANTY 34          // in pixels (this is a magic number)
#define AIR_SCREEN_CONSTANTX 40          // in pixels (this is a magic number)
#define AIR_TIMER            1400        // time in milliseconds to delay on mouseover/out events
#define AIR_MIN_CX           39          // minimum x size of the button
#define AIR_MIN_CY           38          // minimum y size of the button
#define AIR_NUM_TBBITMAPS    1           // number of bitmaps (only 1 button)
#define AIR_BMP_CX           32          // bitmap size
#define AIR_BMP_CY           32
#define AIR_MIN_BROWSER_SIZE 150         // min size in pixels the browser has to be to display the button

#define AIR_SCROLLBAR_SIZE_V GetSystemMetrics(SM_CXVSCROLL)
#define AIR_SCROLLBAR_SIZE_H GetSystemMetrics(SM_CYHSCROLL)

// used for sinking scroll events:
void  Win3FromDoc2(IHTMLDocument2 *pDoc2, IHTMLWindow3 **ppWin3);
DWORD MP_GetOffsetInfoFromRegistry();


// EventSink Callback Class...
class CAutoImageResizeEventSinkCallback
{
public:
    typedef enum
    {
        EVENT_BOGUS     = 100,
        EVENT_MOUSEOVER = 0,
        EVENT_MOUSEOUT,
        EVENT_SCROLL,
        EVENT_RESIZE,
        EVENT_BEFOREPRINT,
        EVENT_AFTERPRINT
    }
    EVENTS;

    typedef struct
    {
        EVENTS  Event;
        LPCWSTR pwszEventSubscribe;
        LPCWSTR pwszEventName;
    }
    EventSinkEntry;

    virtual HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) = 0;

    static  EventSinkEntry EventsToSink[];
};

class CAutoImageResize : public CAutoImageResizeEventSinkCallback
{
    long   m_cRef;

public:
    class CEventSink;
    
    CAutoImageResize();
   ~CAutoImageResize();

    // IUnknown...
    virtual STDMETHODIMP QueryInterface(REFIID, void **);
    virtual ULONG __stdcall AddRef();
    virtual ULONG __stdcall Release();

    // CAutoImageResizeEventSinkCallback...
    HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj);
    
    // Init and UnInit (called from basesb.cpp)
    HRESULT Init(IHTMLDocument2 *pDoc2);
    HRESULT UnInit();

protected:

    // AutoImageResize Stuff
    HRESULT DoAutoImageResize();
    
    // Event Handlers
    HRESULT HandleMouseover();
    HRESULT HandleMouseout();
    HRESULT HandleScroll();
    HRESULT HandleResize();
    HRESULT HandleBeforePrint();
    HRESULT HandleAfterPrint();

    // Button Functions
    HRESULT CreateButton();
    HRESULT ShowButton();
    HRESULT HideButton();
    HRESULT DestroyButton();

    // Timer callback function
    static  VOID CALLBACK s_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    // Button callback function
    static  LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    // CAutoImageResize member variables
    CEventSink     *m_pSink;                 // Event Sink

    HWND            m_hWndButton;            // Button hWnd
    HWND            m_hWndButtonCont;
    WNDPROC         m_wndProcOld;            // Old wind proc for button
    HIMAGELIST      m_himlButtonShrink;      // Shrink image
    HIMAGELIST      m_himlButtonExpand;		 // Expand image    
            
    UINT            m_airState;              // Current state of the AutoImageResize feature (image state)
    UINT            m_airButtonState;        // Current state of the AIR Button
    UINT            m_airUsersLastChoice;    // The last state the user put us into by clicking the button
    UINT            m_airBeforePrintState;   // OnAfterPrint uses this to restore state if necessary

    POINT           m_airOrigSize;           // Original x,y dimensions of an image thats been AIR'ed

    BOOL            m_bWindowResizing;       // True when a onresize event for the win3 object fired, but hasn't been processed yet.
                                             
    // Useful stuff for the attached document
    HWND            m_hWnd;                  // Browser hWnd
    IHTMLDocument2 *m_pDoc2;                 // Document pointer
    IHTMLElement2  *m_pEle2;                 // Pointer to the image
    IHTMLWindow3   *m_pWin3;                 // For unsinking scroll event
    EVENTS          m_eventsCurr;            // Event currently being processed

public:

    // Sinks regular Trident events. Calls back via CAutoImageResizeEventSinkCallback...
    class CEventSink : public IDispatch
    {
        ULONG   m_cRef;

    public:

        CEventSink(CAutoImageResizeEventSinkCallback *pParent);
       ~CEventSink();

        HRESULT SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);

        void SetParent(CAutoImageResizeEventSinkCallback *pParent) { m_pParent = pParent; }

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
        STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
            LCID lcid, DISPID *rgDispId);
        STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
            EXCEPINFO *pExcepInfo, UINT *puArgErr);

    private:
        CAutoImageResizeEventSinkCallback *m_pParent;
    };
};

#endif //__IEAIRESIZE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//
#define UNICODE 1

#include <shlwapi.h>
#include <shlwapip.h>
#include <resource.h>
#include <shfusion.h>

BOOL NT5_GetSaveFileNameW(LPOPENFILENAMEW pofn)
{
    BOOL fRC = FALSE;
    
    if (GetUIVersion() >= 5)
    {
        // we're on Win2k or Millennium
        ULONG_PTR uCookie = 0;
        OPENFILENAMEW ofn_nt5;

        memset(&ofn_nt5, 0, sizeof(OPENFILENAMEW));

        CopyMemory(&ofn_nt5, pofn, pofn->lStructSize);
        
        ofn_nt5.lStructSize = sizeof(OPENFILENAMEW);    // New OPENFILENAME struct size

        // If we start adding more of these, make a table.
        if(pofn->lpTemplateName == MAKEINTRESOURCE(IDD_ADDTOSAVE_DIALOG))
            ofn_nt5.lpTemplateName = MAKEINTRESOURCE(IDD_ADDTOSAVE_NT5_DIALOG);

        if (SHActivateContext(&uCookie))
        {
            fRC = GetSaveFileNameWrapW(&ofn_nt5);
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
        }
        
        if(fRC)
        {
            ofn_nt5.lStructSize = pofn->lStructSize;    // restore old values
            ofn_nt5.lpTemplateName = pofn->lpTemplateName;
            CopyMemory(pofn, &ofn_nt5, pofn->lStructSize);  // copy to passed in struct
        }
    }
    else
    {
        fRC = GetSaveFileNameWrapW(pofn);
    }

    return fRC;
}

PROPSHEETPAGE* Whistler_AllocatePropertySheetPage(int numPages, DWORD* pc)
{
    PROPSHEETPAGE* pspArray = (PROPSHEETPAGE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PROPSHEETPAGE)*numPages);
    if (pspArray)
    {
        int i;
        for (i=0; i<numPages; i++)
        {
            pspArray[i].dwSize = sizeof(PROPSHEETPAGE);
            pspArray[i].dwFlags = PSP_USEFUSIONCONTEXT;
            pspArray[i].hActCtx = g_hActCtx;
        }
        *pc = sizeof(PROPSHEETPAGE);
    }
    return pspArray;
}

HPROPSHEETPAGE Whistler_CreatePropertySheetPageW(LPCPROPSHEETPAGEW a)
{
    LPCPROPSHEETPAGEW ppsp = (LPCPROPSHEETPAGEW)a;
    PROPSHEETPAGEW psp;

    if (g_hActCtx && (a->dwSize<=PROPSHEETPAGE_V2_SIZE))
    {
        memset(&psp, 0, sizeof(psp));
        CopyMemory(&psp, a, a->dwSize);
        psp.dwSize = sizeof(psp);
        ppsp = &psp;
    }
    return CreatePropertySheetPageW(ppsp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\atl.h ===
STDAPI_(void) AtlInit(HINSTANCE hinst);
STDAPI_(void) AtlTerm();

STDAPI        AtlGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
STDAPI_(LONG) AtlGetLockCount();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\atl.cpp ===
#include "priv.h"
#include "atl.h"
#include "nsc.h"
#include "srchasst.h"

//ATL support
CComModule _Module;         // ATL module object

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ShellNameSpace, CNscTree)
    OBJECT_ENTRY(CLSID_SearchAssistantOC, CSearchAssistantOC)
END_OBJECT_MAP()

STDAPI_(void) AtlInit(HINSTANCE hinst)
{
    _Module.Init(ObjectMap, hinst);
}

STDAPI_(void) AtlTerm()
{
    _Module.Term();
}

STDAPI AtlGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = _Module.GetClassObject(rclsid, riid, ppv);

#ifdef DEBUG
    //this object gets freed on DLL_PROCESS_DETACH, which happens AFTER the
    // mem leak check happens on exit.
    if (SUCCEEDED(hr))
    {
        _ASSERTE(_Module.m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;

        while (pEntry->pclsid != NULL)
        {
            if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
            {
                ASSERT(pEntry->pCF);
                break;
            }
            pEntry++;
        }
    }
#endif

    return hr;
}

STDAPI_(LONG) AtlGetLockCount()
{
    return _Module.GetLockCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\airesize.cpp ===
#include "priv.h"
#include <iehelpid.h>
#include <pstore.h>
#include "hlframe.h"
#include "shldisp.h"
#include "opsprof.h"
#include "resource.h"
#include <mluisupp.h>
#include "htmlstr.h"
#include "airesize.h"
#include "mshtmcid.h"
#include "util.h"
#include "winuser.h"

//////////////////////////////////////////////////////////////////////////////////
//
// filename:    airesize.cpp
//
// description: implements the autoimageresize feature
//
// notes:       
//
// history:     03.07.2001 by jeffdav
//
//////////////////////////////////////////////////////////////////////////////////

extern HINSTANCE g_hinst;

#define TF_AIRESIZE TF_CUSTOM2

CAutoImageResizeEventSinkCallback::EventSinkEntry CAutoImageResizeEventSinkCallback::EventsToSink[] =
{
    { EVENT_MOUSEOVER,   L"onmouseover",   L"mouseover"  }, 
    { EVENT_MOUSEOUT,    L"onmouseout",    L"mouseout"   }, 
    { EVENT_SCROLL,      L"onscroll",      L"scroll"     }, 
    { EVENT_RESIZE,      L"onresize",      L"resize"     },
    { EVENT_BEFOREPRINT, L"onbeforeprint", L"beforeprint"},
    { EVENT_AFTERPRINT,  L"onafterprint",  L"afterprint" }
};

// autoimage resize states
enum
{
    AIRSTATE_BOGUS = 0,
    AIRSTATE_INIT,
    AIRSTATE_NORMAL,
    AIRSTATE_RESIZED,
    AIRSTATE_WAITINGTORESIZE
};

// button states
enum
{
    AIRBUTTONSTATE_BOGUS = 0,
    AIRBUTTONSTATE_HIDDEN,
    AIRBUTTONSTATE_VISIBLE,
    AIRBUTTONSTATE_WAITINGTOSHOW,
    AIRBUTTONSTATE_NOBUTTON
};

////////////////////////////////////////////////////////////////////////////
// QI, AddRef, Release:

STDMETHODIMP CAutoImageResize::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IPropertyNotifySink == riid) || (IID_IUnknown == riid)) 
    {
        *ppv = (IPropertyNotifySink *)this;
    }

    if (*ppv) 
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAutoImageResize::AddRef(void) 
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CAutoImageResize::Release(void) 
{
    if (--m_cRef == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////////////
// Constructor, Destructor, Init, UnInit:

// constructor
CAutoImageResize::CAutoImageResize()
{
    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::CAutoImageResize");

    m_airState          = AIRSTATE_INIT;
    m_airUsersLastChoice= AIRSTATE_BOGUS; // we don't care until the user clicks the button
    m_hWndButton        = NULL;
    m_hWnd              = NULL;
    m_wndProcOld        = NULL;
    m_pDoc2             = NULL;
    m_pEle2             = NULL;
    m_pWin3             = NULL;
    m_bWindowResizing   = FALSE;
    m_himlButtonShrink  = NULL;
    m_himlButtonExpand  = NULL;
    
    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::CAutoImageResize");
}

// destructor
CAutoImageResize::~CAutoImageResize()
{
    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::~CAutoImageResize");

    DestroyButton();

    ATOMICRELEASE(m_pEle2);
    ATOMICRELEASE(m_pDoc2);

    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::~CAutoImageResize");
}

HRESULT CAutoImageResize::Init(IHTMLDocument2 *pDoc2)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::Init");

    ASSERT(pDoc2);

    //sink things
    IHTMLElement2           *pEle2       = NULL;
    IHTMLElementCollection  *pCollect    = NULL;
    IHTMLElementCollection  *pSubCollect = NULL;
    IDispatch               *pDisp       = NULL;
    VARIANT                  TagName;
    ULONG                    ulCount     = 0;
    VARIANTARG               va1;
    VARIANTARG               va2;
    IHTMLWindow3            *pWin3       = NULL;
    IOleWindow              *pOleWin     = NULL;
    
    // ...remember this...
    m_pDoc2 = pDoc2;
    pDoc2->AddRef();

    // ...remember the hwnd also...
    hr = m_pDoc2->QueryInterface(IID_IOleWindow,(void **)&pOleWin);
    if (FAILED(hr))
        goto Cleanup;
    pOleWin->GetWindow(&m_hWnd);
    
    // setup variant for finding all the IMG tags...
    TagName.vt      = VT_BSTR;
    TagName.bstrVal = (BSTR)c_bstr_IMG;
    
    //get all tags
    hr = pDoc2->get_all(&pCollect);                   
    if (FAILED(hr))
        goto Cleanup;

    //get all IMG tags
    hr = pCollect->tags(TagName, &pDisp);
    if (FAILED(hr))
        goto Cleanup;
        
    if (pDisp) 
    {
        hr = pDisp->QueryInterface(IID_IHTMLElementCollection,(void **)&pSubCollect);
        ATOMICRELEASE(pDisp);
    }
    if (FAILED(hr))
        goto Cleanup;

    //get IMG tag count
    hr = pSubCollect->get_length((LONG *)&ulCount);
    if (FAILED(hr))
        goto Cleanup;

    // highlander theorem: there can be only one!
    // bt's corollary: there must be exactally one.
    if (1 != ulCount)
        goto Cleanup;

    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
        
    pDisp    = NULL;                                
    va1.lVal = (LONG)0;
    pSubCollect->item(va1, va2, &pDisp);

    // create event sink for the image
    if (!m_pSink && pDisp)
        m_pSink = new CEventSink(this);

    if (pDisp) 
    {
        hr = pDisp->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
        if (FAILED(hr))
            goto Cleanup;

        ASSERT(m_pSink);

        if (m_pSink && pEle2) 
        {
            EVENTS events[] = { EVENT_MOUSEOVER, EVENT_MOUSEOUT };
            m_pSink->SinkEvents(pEle2, ARRAYSIZE(events), events);
            m_pEle2=pEle2;
            pEle2->AddRef();
        }
        ATOMICRELEASE(pEle2);
        ATOMICRELEASE(pDisp);
    }

    // sink scroll event from the window, because it doesn't come from elements.
    if (m_pSink) 
    {
        Win3FromDoc2(m_pDoc2, &pWin3);

        if (pWin3) 
        {
            m_pWin3 = pWin3;
            m_pWin3->AddRef();

            EVENTS events[] = { EVENT_SCROLL, EVENT_RESIZE, EVENT_BEFOREPRINT, EVENT_AFTERPRINT };
            m_pSink->SinkEvents(pWin3, ARRAYSIZE(events), events);
        }
    }
    
    // end sinking things

    // Init() gets called when onload fires, so the image *should* be ready
    // to get adjusted, if need be...
    DoAutoImageResize();

Cleanup:

    ATOMICRELEASE(pCollect);
    ATOMICRELEASE(pSubCollect);
    ATOMICRELEASE(pWin3);
    ATOMICRELEASE(pDisp);
    ATOMICRELEASE(pEle2);
    ATOMICRELEASE(pOleWin);

    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::Init");

    return hr;
}

HRESULT CAutoImageResize::UnInit()
{
    // Unhook regular event sink

    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::UnInit");

    DestroyButton();

    if (m_pSink) 
    {
        if (m_pWin3) 
        {
            EVENTS events[] = { EVENT_SCROLL, EVENT_RESIZE, EVENT_BEFOREPRINT, EVENT_AFTERPRINT };
            m_pSink->UnSinkEvents(m_pWin3, ARRAYSIZE(events), events);
            SAFERELEASE(m_pWin3);
        }
        m_pSink->SetParent(NULL);
        ATOMICRELEASE(m_pSink);
    }

    SAFERELEASE(m_pEle2);
    SAFERELEASE(m_pDoc2);
    
    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::UnInit");

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// AutoImageResize Functions:

HRESULT CAutoImageResize::DoAutoImageResize()
{
    HRESULT          hr         = S_OK;
    IHTMLImgElement *pImgEle    = NULL;
    LONG             lHeight    = 0;
    LONG             lWidth     = 0;
    LONG             lNewHeight = 0;
    LONG             lNewWidth  = 0;
    LONG             lScrHt     = 0;
    LONG             lScrWd     = 0;
    RECT rcBrowserWnd;
    
    ASSERT(m_pEle2);

    // get an IHTMLImgElement from the IHTMLElement cached...
    hr = m_pEle2->QueryInterface(IID_IHTMLImgElement, (void **)&pImgEle);
    if (FAILED(hr) || !pImgEle)
        goto Cleanup;

    // get the current dimensions
    if (FAILED(pImgEle->get_height(&lHeight)) || FAILED(pImgEle->get_width(&lWidth)))
        goto Cleanup;

    // if this is the first time through, we need to take care of some init stuff
    if (AIRSTATE_INIT == m_airState)
    {
        // cache orig dimensions
        m_airOrigSize.x = lWidth;
        m_airOrigSize.y = lHeight;

        // INIT done, promote to NORMAL
        m_airState = AIRSTATE_NORMAL;
    }

    // check to see if we are being called because the user is resizing the window
    // and then massage the state as necessary.
    if (m_bWindowResizing)
    {
        m_airState = AIRSTATE_NORMAL;
    }

    switch (m_airState)
    {
        case AIRSTATE_NORMAL:

        // how big is the window?
        if (GetClientRect(m_hWnd, &rcBrowserWnd)) 
        {

            lScrHt = rcBrowserWnd.bottom - rcBrowserWnd.top;
            lScrWd = rcBrowserWnd.right - rcBrowserWnd.left;
        
            // is the image bigger then the window?
            if (lScrWd < lWidth)
                m_airState=AIRSTATE_WAITINGTORESIZE;

            if (lScrHt < lHeight)
                m_airState=AIRSTATE_WAITINGTORESIZE;
        }
        else
            goto Cleanup;

        // if the window is resizing, we may need to expand the image, so massage the state again...
        // (there is a check later on to make sure we don't expand too far...)
        if (m_bWindowResizing)
        {
            m_airState = AIRSTATE_WAITINGTORESIZE;
        }

        // image didn't fit, so we must resize now
        if (AIRSTATE_WAITINGTORESIZE == m_airState)
        {
            // calculate new size:
            if (MulDiv(lWidth,1000,lScrWd) < MulDiv(lHeight,1000,lScrHt))
            {
                lNewHeight = lScrHt-AIR_SCREEN_CONSTANTY;
                lNewWidth = MulDiv(lNewHeight,m_airOrigSize.x,m_airOrigSize.y);
            }
            else
            {
                lNewWidth  = lScrWd-AIR_SCREEN_CONSTANTX;
                lNewHeight = MulDiv(lNewWidth, m_airOrigSize.y, m_airOrigSize.x);
            }

            // we don't ever want to resize to be LARGER then the original... 
            if ((lNewHeight > m_airOrigSize.y) || (lNewWidth > m_airOrigSize.x))
            {
                if (m_bWindowResizing)
                {
                    // restore orig size cause it should fit and turn off the button
                    lNewHeight = m_airOrigSize.y;
                    lNewWidth  = m_airOrigSize.x;
                    m_airButtonState = AIRBUTTONSTATE_NOBUTTON;
                }
                else
                    goto Cleanup;
            }
            
            if (FAILED(pImgEle->put_height(lNewHeight)) || FAILED(pImgEle->put_width(lNewWidth)))
            {
                goto Cleanup;
            }
            else
            {
                m_airState=AIRSTATE_RESIZED;
                if (AIRBUTTONSTATE_VISIBLE == m_airButtonState)
                {
                    // reposition button
                    HideButton();
                    ShowButton();
                }
            }
        }
        else
        {
            // It fit in the browser window so we don't need to do any work yet...
            // If they resize the window or something we need to check again...
            m_airButtonState=AIRBUTTONSTATE_NOBUTTON;
        }

        break;

        case AIRSTATE_RESIZED:

        // restore the image to its normal size
        if (FAILED(pImgEle->put_height(m_airOrigSize.y)) ||
            FAILED(pImgEle->put_width (m_airOrigSize.x)))
        {
            goto Cleanup;
        }
        else
        {
            m_airState=AIRSTATE_NORMAL;
            if (AIRBUTTONSTATE_VISIBLE == m_airButtonState)
            {
                // reposition button
                HideButton();
                ShowButton();
            }
        }

        break;

        case AIRSTATE_WAITINGTORESIZE:

            // we should never be in this state at this time!
            ASSERT(m_airState!=AIRSTATE_WAITINGTORESIZE);
            
            break;

        default:
            break;
    }
    
Cleanup:

    ATOMICRELEASE(pImgEle);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Timer Proc:

LRESULT CALLBACK CAutoImageResize::s_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAutoImageResize* pThis = (CAutoImageResize*)GetWindowPtr(hWnd, GWLP_USERDATA);    

    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::s_WndProc  hWnd=%x, pThis=%p", hWnd, pThis);

    HRESULT             hr                = S_OK;
    IOleCommandTarget  *pOleCommandTarget = NULL;   
    UINT                iToolTip          = NULL;

    switch (uMsg) 
    {
        case WM_SIZE:

            if (!pThis)
                break;

            SetWindowPos(pThis->m_hWndButton, NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER | SWP_NOACTIVATE);
            break;

        case WM_ERASEBKGND:
            
            if (!pThis)
                break;

            {
                RECT rc;
                HBRUSH hb = GetSysColorBrush(COLOR_3DFACE);

                GetClientRect(pThis->m_hWndButton, &rc);
                FillRect((HDC)wParam, &rc, hb);
                return TRUE;
            }

        case WM_COMMAND:

            if (!pThis)
                break;

            switch(LOWORD(wParam))
            {
                case IDM_AIR_BUTTON:

                    if (AIRSTATE_NORMAL  == pThis->m_airState)
                    {
                        pThis->m_airUsersLastChoice = AIRSTATE_RESIZED;
                    }
                    else if (AIRSTATE_RESIZED == pThis->m_airState)
                    {
                        pThis->m_airUsersLastChoice = AIRSTATE_NORMAL;
                    }

                    pThis->DoAutoImageResize();
                    break;
            }
            break;

        case WM_NOTIFY:  // tooltips...

            if (!pThis)
                break;

            switch (((LPNMHDR)lParam)->code) 
            {
                case TTN_NEEDTEXT:
                {
                    if (AIRSTATE_NORMAL == pThis->m_airState)
                    {
                        iToolTip = IDS_AIR_SHRINK;
                    }
                    else if (AIRSTATE_RESIZED == pThis->m_airState)
                    {
                        iToolTip = IDS_AIR_EXPAND;
                    }

                    LPTOOLTIPTEXT lpToolTipText;
                    TCHAR szBuf[MAX_PATH];
                    lpToolTipText = (LPTOOLTIPTEXT)lParam;
                    hr = MLLoadString(iToolTip,   
                                      szBuf,
                                      ARRAYSIZE(szBuf));
                    lpToolTipText->lpszText = szBuf;
                    break;
                }
            }
            break;

        case WM_SETTINGCHANGE:
            {
                pThis->DestroyButton(); // to stop wierd window distortion
                break;
            }

        case WM_CONTEXTMENU:
            {
                // should we be consistant and have a turn-me-off/help context menu?
            }
            break;

        default:
            return(DefWindowProc(hWnd, uMsg, wParam, lParam));
    }


    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::s_WndProc  hWnd=%x, pThis=%p", hWnd, pThis);

    return (hr);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Timer Proc:

VOID CALLBACK CAutoImageResize::s_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) 
{
    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::TimerProc");

    CAutoImageResize* pThis = (CAutoImageResize*)GetWindowPtr(hwnd, GWLP_USERDATA);

    switch (uMsg) 
    {
        case WM_TIMER:
            KillTimer(hwnd, IDT_AIR_TIMER);  
            if (pThis && (AIRBUTTONSTATE_WAITINGTOSHOW == pThis->m_airButtonState))
            {
                // Our hover bar is waiting to be shown.
                if (pThis->m_pEle2)
                {
                    // We still have an element.  Show it.
                    pThis->m_airButtonState = AIRBUTTONSTATE_VISIBLE;

                    pThis->ShowButton();
                } 
                else
                {
                    // Our timer popped, but we don't have an element.
                    pThis->HideButton();
                }
            }
            break;
        
        default:
            break;
    }
    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::TimerProc");
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Button Functions:

HRESULT CAutoImageResize::CreateButton()
{
    HRESULT hr         = S_OK;
    SIZE    size       = {0,0};

    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::CreateHover, this=%p, m_airButtonState=%d", this, m_airButtonState);

    InitCommonControls();

    WNDCLASS wc = {0};
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = TEXT("AutoImageResizeHost");
    wc.lpfnWndProc = s_WndProc;
    wc.hInstance = g_hinst;
    wc.hbrBackground = HBRUSH(COLOR_BTNFACE);
    RegisterClass(&wc);

    if (!m_hWndButtonCont)
    {

        m_hWndButtonCont = CreateWindow(TEXT("AutoImageResizeHost"), TEXT(""), WS_DLGFRAME | WS_VISIBLE | WS_CHILD /*| WS_POPUP*/, 
                                        0, 0, 0, 0, m_hWnd, NULL, g_hinst, NULL);

        if (!m_hWndButtonCont)
        {
            TraceMsg(TF_AIRESIZE | TF_WARNING, "CAutoImageResize::CreateButton, unable to create m_hWndButtonCont");
            hr = E_FAIL;
            goto Cleanup;
        }

        // setup the window callback stuff...
        ASSERT(m_wndProcOld == NULL);
        m_wndProcOld = (WNDPROC)SetWindowLongPtr(m_hWndButtonCont, GWLP_WNDPROC, (LONG_PTR)s_WndProc);

        // pass in the this pointer so the button can call member functions
        ASSERT(GetWindowPtr(m_hWndButtonCont, GWLP_USERDATA) == NULL);
        SetWindowPtr(m_hWndButtonCont, GWLP_USERDATA, this);
    }

    // create the button
    if (!m_hWndButton)
    {

        m_hWndButton = CreateWindow(TOOLBARCLASSNAME, TEXT(""), TBSTYLE_TOOLTIPS | CCS_NODIVIDER | TBSTYLE_FLAT | WS_VISIBLE | WS_CHILD,
                                    0,0,0,0, m_hWndButtonCont, NULL, g_hinst, NULL);

        if (!m_hWndButton)
        {
            TraceMsg(TF_AIRESIZE | TF_WARNING, "CAutoImageResize::CreateButton, unable to create m_hWndButton");
            hr = E_FAIL;
            goto Cleanup;
        }
        

        ASSERT(GetWindowPtr(m_hWndButton, GWLP_USERDATA) == NULL);
        SetWindowPtr(m_hWndButton, GWLP_USERDATA, this);

        // set cc version for this too, and the sizeof tbbutton struct...
        SendMessage(m_hWndButton, CCM_SETVERSION,      COMCTL32_VERSION, 0);
        SendMessage(m_hWndButton, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
    }

    if (!m_himlButtonExpand)
    {
        m_himlButtonExpand = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_AIR_EXPAND), 32, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (!m_himlButtonExpand)
        {
            TraceMsg(TF_AIRESIZE | TF_WARNING, "CAutoImageResize::CreateButton, unable to create m_himlButtonExpand");
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    if (!m_himlButtonShrink)
    {
        m_himlButtonShrink = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_AIR_SHRINK), 32, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (!m_himlButtonShrink)
        {
            TraceMsg(TF_AIRESIZE | TF_WARNING, "CAutoImageResize::CreateButton, unable to create m_himlButtonShrink");
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // set image list and hot image list
    SendMessage(m_hWndButton, TB_SETIMAGELIST,    0, (LPARAM)m_himlButtonExpand);
    SendMessage(m_hWndButton, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlButtonExpand);

    // add the buttons

    TBBUTTON tbAirButton;
    
    tbAirButton.iBitmap   = 0;
    tbAirButton.idCommand = IDM_AIR_BUTTON;
    tbAirButton.fsState   = TBSTATE_ENABLED;
    tbAirButton.fsStyle   = TBSTYLE_BUTTON;
    tbAirButton.dwData    = 0;
    tbAirButton.iString   = 0;

    SendMessage(m_hWndButton, TB_INSERTBUTTON, 0, (LPARAM)&tbAirButton);

Cleanup:

    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::CreateButton, this=%p, m_airButtonState=%d", this, m_airButtonState);

    return hr;
}

HRESULT CAutoImageResize::ShowButton()
{
    HRESULT    hr       = E_FAIL;
    IHTMLRect *pRect    = NULL;
    LONG       lLeft    = 0;              // these are the screen coords
    LONG       lRight   = 0;              // we get right and bottom to det size of image
    LONG       lTop     = 0;
    LONG       lBottom  = 0;
    DWORD      dwOffset = MP_GetOffsetInfoFromRegistry();
    RECT       rcBrowserWnd;
    WORD       wImage   = NULL;

    DWORD dw;
    SIZE  sz;
    RECT  rc;   
    
    TraceMsg(TF_AIRESIZE, "+CAutoImageResize::ShowButton, this=%p, m_airButtonState=%d", this, m_airButtonState);

    ASSERT(m_pEle2);

    // get the coords of the image...
    if (SUCCEEDED(m_pEle2->getBoundingClientRect(&pRect)) && pRect)
    {
        pRect->get_left(&lLeft);
        pRect->get_right(&lRight);
        pRect->get_top(&lTop);
        pRect->get_bottom(&lBottom);
    }
    else
        goto Cleanup;

    // make sure we are inside the browser window...
    if (GetClientRect(m_hWnd, &rcBrowserWnd)) 
    {
        // if the browser window is less then a certain min size, we
        // don't display the button...
        if ((rcBrowserWnd.right  - rcBrowserWnd.left < AIR_MIN_BROWSER_SIZE) ||
            (rcBrowserWnd.bottom - rcBrowserWnd.top  < AIR_MIN_BROWSER_SIZE))
            goto Cleanup;

        // if the browser window is larger then the image, we don't display
        // the button...
        if ((AIRSTATE_NORMAL == m_airState) &&
            (rcBrowserWnd.left   < lLeft  ) &&
            (rcBrowserWnd.right  > lRight ) &&
            (rcBrowserWnd.top    < lTop   ) &&
            (rcBrowserWnd.bottom > lBottom))
            goto Cleanup;
        

        // adjust for scrollbars
        if (lRight > rcBrowserWnd.right - AIR_SCROLLBAR_SIZE_V)
        {
            lRight = rcBrowserWnd.right - AIR_SCROLLBAR_SIZE_V;
        }

        if (lBottom > rcBrowserWnd.bottom - AIR_SCROLLBAR_SIZE_H)
        {
            lBottom = rcBrowserWnd.bottom - AIR_SCROLLBAR_SIZE_H;
        }
    }
    else
        goto Cleanup;

    // someone tried to show the button, but it doesn't exist.
    // this is ok, if we actually have an element, so fix it for them.
    if (!m_hWndButtonCont && m_pEle2)
        CreateButton();

    // make sure the image list exists
    if (!m_himlButtonShrink || !m_himlButtonExpand)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (AIRSTATE_NORMAL == m_airState)
    {
        SendMessage(m_hWndButton, TB_SETIMAGELIST,    0, (LPARAM)m_himlButtonShrink);
        SendMessage(m_hWndButton, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlButtonShrink);
    }
    else if (AIRSTATE_RESIZED == m_airState)
    {
        SendMessage(m_hWndButton, TB_SETIMAGELIST,    0, (LPARAM)m_himlButtonExpand);
        SendMessage(m_hWndButton, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlButtonExpand);
    }		
    else if (AIRSTATE_INIT == m_airState || AIRSTATE_WAITINGTORESIZE == m_airState)
    {
        goto Cleanup;
    }

    // do some calc to get window size and position...
    dw        = (DWORD)SendMessage(m_hWndButton, TB_GETBUTTONSIZE, 0, 0);
    sz.cx     = LOWORD(dw); 
    sz.cy     = HIWORD(dw);
    rc.left   = rc.top = 0; 
    rc.right  = sz.cx; 
    rc.bottom = sz.cy;

    AdjustWindowRectEx(&rc, GetWindowLong(m_hWndButtonCont, GWL_STYLE), FALSE, GetWindowLong(m_hWndButtonCont, GWL_EXSTYLE));

    // that should be all...
    SetWindowPos(m_hWndButtonCont, NULL,
                 lRight -(rc.right-rc.left)-dwOffset,       // left
                 lBottom-(rc.bottom-rc.top)-dwOffset,       // right
                 rc.right -rc.left,                         // width
                 rc.bottom-rc.top,                          // height
                 SWP_NOZORDER | SWP_SHOWWINDOW);            // show it

    m_airButtonState = AIRBUTTONSTATE_VISIBLE;

    hr = S_OK;

Cleanup:

    ATOMICRELEASE(pRect);

    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::ShowButton, this=%p, m_airButtonState=%d", this, m_airButtonState);

    return hr;
}

HRESULT CAutoImageResize::HideButton()
{
    HRESULT hr = S_OK;

    if (m_hWndButton)
    {
        ShowWindow(m_hWndButtonCont, SW_HIDE);
        m_airButtonState=AIRBUTTONSTATE_HIDDEN;
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CAutoImageResize::DestroyButton()
{
    HRESULT hr = S_OK;

        TraceMsg(TF_AIRESIZE, "+CAutoImageResize::DestroyHover, this=%p, m_airButtonState=%d", this, m_airButtonState);

    if (m_hWndButton)
    {
        // first destroy the toolbar
        if (!DestroyWindow(m_hWndButton))
        {
            TraceMsg(TF_AIRESIZE, "In CAutoImageResize::DestroyHover, DestroyWindow(m_hWndButton) failed");
            hr = E_FAIL;
        }
        m_hWndButton=NULL;
    }

    // If we have a container window...
    if (m_hWndButtonCont)
    {
        if (m_wndProcOld)
        {
            // Unsubclass the window
            SetWindowLongPtr(m_hWndButtonCont, GWLP_WNDPROC, (LONG_PTR)m_wndProcOld);
            m_wndProcOld = NULL;
        }

        // Clear the window word
        SetWindowPtr(m_hWndButtonCont, GWLP_USERDATA, NULL);

        // then destroy the rebar
        if (!DestroyWindow(m_hWndButtonCont))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        m_hWndButtonCont = NULL;
    }

    // and destroy the image lists...
    if (m_himlButtonShrink)
    {
        ImageList_Destroy(m_himlButtonShrink);
        m_himlButtonShrink = NULL;
    }

    if (m_himlButtonExpand)
    {
        ImageList_Destroy(m_himlButtonExpand);
        m_himlButtonExpand = NULL;
    }


Cleanup:
    TraceMsg(TF_AIRESIZE, "-CAutoImageResize::DestroyHover, this=%p, hr=%x", this, hr);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Event Handlers:

HRESULT CAutoImageResize::HandleMouseover()
{
    HRESULT hr = S_OK;

    if (AIRBUTTONSTATE_NOBUTTON == m_airButtonState)
    {
        return S_OK;
    }

    if (!m_hWndButton)
    {
        hr = CreateButton();
    }

    if (m_hWndButton)
    {
        m_airButtonState = AIRBUTTONSTATE_WAITINGTOSHOW;
        SetTimer(m_hWndButton, IDT_AIR_TIMER, AIR_TIMER, s_TimerProc);
    }

    return hr;
}

HRESULT CAutoImageResize::HandleMouseout()
{

    switch(m_airButtonState)
    {
        case AIRBUTTONSTATE_HIDDEN:
            break;
     
        case AIRBUTTONSTATE_VISIBLE:
            HideButton();
            break;
        
        case AIRBUTTONSTATE_WAITINGTOSHOW:
            m_airButtonState=AIRBUTTONSTATE_HIDDEN;
            KillTimer(m_hWndButton, IDT_AIR_TIMER);
            break;
    }

    return S_OK;
}

HRESULT CAutoImageResize::HandleScroll()
{
    RECT rect;

    if (AIRBUTTONSTATE_VISIBLE == m_airButtonState)
    {
        ASSERT(m_hWndButtonCont);
        ASSERT(m_pEle2);

        GetWindowRect(m_hWndButtonCont, &rect);

        HideButton();
        ShowButton();

        rect.top    -= 3*AIR_MIN_CY;
        rect.bottom += 2*AIR_MIN_CY;
        rect.left   -= 3*AIR_MIN_CX;
        rect.right  += 2*AIR_MIN_CX;

        // redraw the button
        RedrawWindow(m_hWnd, &rect, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
    }

    return S_OK;
}

HRESULT CAutoImageResize::HandleResize()
{

    // if the image previously fit in the window, but the user resized the window and now
    // we have resized the image, we should reset the button state so the user actually gets
    // a button...
    if (AIRBUTTONSTATE_NOBUTTON == m_airButtonState)
    {
        m_airButtonState = AIRBUTTONSTATE_HIDDEN;
    }

    // if the users has decided they want the image expanded by clicking the button to expand it,
    // we should honor that and not resize the image simply because the window changes size
    if (AIRSTATE_NORMAL == m_airUsersLastChoice)
    {
        return S_OK;
    }

    m_bWindowResizing = TRUE;

    DoAutoImageResize();
    
    m_bWindowResizing = FALSE;

    return S_OK;
}

HRESULT CAutoImageResize::HandleBeforePrint()
{

    m_airBeforePrintState = m_airState;

    if (AIRSTATE_RESIZED == m_airState)
    {
        DoAutoImageResize();
    }

    return S_OK;
}

HRESULT CAutoImageResize::HandleAfterPrint()
{
    if (AIRSTATE_RESIZED == m_airBeforePrintState &&
        AIRSTATE_NORMAL  == m_airState)
    {
        DoAutoImageResize();
    }

    return S_OK;
}

HRESULT CAutoImageResize::HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) 
{
    TraceMsg(TF_AIRESIZE, "CAutoImageResize::HandleEvent Event=%ws", EventsToSink[Event].pwszEventName);

    HRESULT hr          = S_OK;

    m_eventsCurr = Event;

    switch(Event) 
    {
        case EVENT_SCROLL:
            HandleScroll();
            break;

        case EVENT_MOUSEOVER:
            hr = HandleMouseover();
            break;

        case EVENT_MOUSEOUT:
            hr = HandleMouseout();
            break;

        case EVENT_RESIZE:
            hr = HandleResize();
            break;

        case EVENT_BEFOREPRINT:
            hr = HandleBeforePrint();
            break;

        case EVENT_AFTERPRINT:
            hr = HandleAfterPrint();
            break;

        default:
            //do nothing?
            break;
    }

    return (hr);
}


////////////////////////////////////////////////////////////////////////////////////////////////

// this is stolen from iforms.cpp:

//=========================================================================
//
// Event sinking class
//
//  We simply implement IDispatch and make a call into our parent when
//   we receive a sinked event.
//
//=========================================================================

CAutoImageResize::CEventSink::CEventSink(CAutoImageResizeEventSinkCallback *pParent)
{
    TraceMsg(TF_AIRESIZE, "CAutoImageResize::CEventSink::CEventSink");
    DllAddRef();
    m_cRef = 1;
    m_pParent = pParent;
}

CAutoImageResize::CEventSink::~CEventSink()
{
    TraceMsg(TF_AIRESIZE, "CAutoImageResize::CEventSink::~CEventSink");
    ASSERT( m_cRef == 0 );
    DllRelease();
}

STDMETHODIMP CAutoImageResize::CEventSink::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IDispatch == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IDispatch *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CAutoImageResize::CEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CAutoImageResize::CEventSink::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CAutoImageResize::CEventSink::SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CAutoImageResizeEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}

HRESULT CAutoImageResize::CEventSink::SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CAutoImageResizeEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}


HRESULT CAutoImageResize::CEventSink::UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CAutoImageResizeEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

HRESULT CAutoImageResize::CEventSink::UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CAutoImageResizeEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

// IDispatch
STDMETHODIMP CAutoImageResize::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAutoImageResize::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAutoImageResize::CEventSink::GetIDsOfNames(
                REFIID          riid,
                OLECHAR**       rgszNames,
                UINT            cNames,
                LCID            lcid,
                DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAutoImageResize::CEventSink::Invoke(
            DISPID dispIdMember,
            REFIID, LCID,
            WORD wFlags,
            DISPPARAMS* pDispParams,
            VARIANT* pVarResult,
            EXCEPINFO*,
            UINT* puArgErr)
{
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) && pObj))
            {
                EVENTS Event=EVENT_BOGUS;
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                if (bstrEvent)
                {
                    for (int i=0; i<ARRAYSIZE(CAutoImageResizeEventSinkCallback::EventsToSink); i++)
                    {
                        if (!StrCmpCW(bstrEvent, CAutoImageResizeEventSinkCallback::EventsToSink[i].pwszEventName))
                        {
                            Event = (EVENTS) i;
                            break;
                        }
                    }

                    SysFreeString(bstrEvent);
                }

                if (Event != EVENT_BOGUS)
                {
                    IHTMLElement *pEle=NULL;

                    pObj->get_srcElement(&pEle);

                    // EVENT_SCROLL comes from our window so we won't have an
                    //  element for it
                    if (pEle || (Event == EVENT_SCROLL) || (Event == EVENT_RESIZE) || (Event == EVENT_BEFOREPRINT) || (Event == EVENT_AFTERPRINT))
                    {
                        // Call the event handler here
                        m_pParent->HandleEvent(pEle, Event, pObj);

                        if (pEle)
                        {
                            pEle->Release();
                        }
                    }
                }

                pObj->Release();
            }
        }
    }

    return S_OK;
}
#undef TF_AIRESIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\bands.cpp ===
#include "priv.h"
#include "util.h"
#include "resource.h"

#include "..\inc\bands.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\bcwx.cpp ===
#include "priv.h"

#define ASSERTDATA

/* Macro to compute a back pointer to a containing class given a
   pointer to a member, the member name, and the containing class type.
   This generates no code because it results in a constant offset.
   Note: this is taken from mso96 dll code. */
#define BACK_POINTER(p, m, c) \
	((c *) (void *) (((char *) (void *) (p)) - (char *) (&((c *) 0)->m)))

#ifdef DEBUG
	#define Debug(e) e
	#define DebugElse(s, t)	s
#else
	#define Debug(e)
	#define DebugElse(s, t) t
#endif

#include "bcw.cpp"

IBindCtx * BCW_Create(IBindCtx* pibc)
{
    return BCW::Create(pibc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\basesb.h ===
#ifndef _BASESB2_H
#define _BASESB2_H

#include "iface.h"
#include "track.h"
#include "fldset.h"
#include <vervec.h>
#include <iethread.h>
#include <profsvc.h>
#include "browsext.h"
#include "airesize.h"

//  this is used to identify the top frame browsers dwBrowserIndex
#define BID_TOPFRAMEBROWSER   ((DWORD)-1)

void IECleanUpAutomationObject(void);

#define CBASEBROWSER CBaseBrowser2
class CBaseBrowser2 : public CAggregatedUnknown 
                   , public IShellBrowser
                   , public IBrowserService3
                   , public IServiceProvider
                   , public IOleCommandTarget
                   , public IOleContainer
                   , public IOleInPlaceUIWindow
                   , public IAdviseSink
                   , public IDropTarget
                   , public IInputObjectSite
                   , public IDocNavigate
                   , public IPersistHistory
                   , public IInternetSecurityMgrSite
                   , public IVersionHost
                   , public IProfferServiceImpl
                   , public ITravelLogClient
                   , public ITravelLogClient2
                   , public ITridentService2
                   , public IShellBrowserService
                   , public IInitViewLinkedWebOC
                   , public INotifyAppStart
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj) {return CAggregatedUnknown::QueryInterface(riid, ppvObj);};
    STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
                                                                        
    // IShellBrowser (same as IOleInPlaceFrame)
    STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd);
    STDMETHODIMP RemoveMenusSB(HMENU hmenuShared);
    STDMETHODIMP SetStatusTextSB(LPCOLESTR lpszStatusText);
    STDMETHODIMP EnableModelessSB(BOOL fEnable);
    STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);
    STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHODIMP GetViewStateStream(DWORD grfMode, LPSTREAM  *ppStrm) {return E_NOTIMPL; };
    STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd);
    STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHODIMP QueryActiveShellView(struct IShellView ** ppshv);
    STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv);
    STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // IOleInPlaceUIWindow (also IOleWindow)
    STDMETHODIMP GetBorder(LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IOleContainer
    STDMETHODIMP ParseDisplayName(IBindCtx  *pbc, LPOLESTR pszDisplayName, ULONG  *pchEaten, IMoniker  **ppmkOut);
    STDMETHODIMP EnumObjects(DWORD grfFlags, IEnumUnknown **ppenum);
    STDMETHODIMP LockContainer( BOOL fLock);

    // IBrowserService
    STDMETHODIMP GetParentSite(struct IOleInPlaceSite** ppipsite);
    STDMETHODIMP SetTitle(IShellView *psv, LPCWSTR pszName);
    STDMETHODIMP GetTitle(IShellView *psv, LPWSTR pszName, DWORD cchName);
    STDMETHODIMP GetOleObject(struct IOleObject** ppobjv);

    STDMETHODIMP GetTravelLog(ITravelLog **pptl);
    STDMETHODIMP ShowControlWindow(UINT id, BOOL fShow);
    STDMETHODIMP IsControlWindowShown(UINT id, BOOL *pfShown);
    STDMETHODIMP IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags);
    STDMETHODIMP IEParseDisplayName(UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut);
    STDMETHODIMP DisplayParseError(HRESULT hres, LPCWSTR pwszPath);
    STDMETHODIMP NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF);
    STDMETHODIMP SetNavigateState(BNSTATE bnstate);
    STDMETHODIMP GetNavigateState(BNSTATE *pbnstate);
    STDMETHODIMP UpdateWindowList(void);
    STDMETHODIMP UpdateBackForwardState(void);
    STDMETHODIMP NotifyRedirect(IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse);
    STDMETHODIMP SetFlags(DWORD dwFlags, DWORD dwFlagMask);
    STDMETHODIMP GetFlags(DWORD *pdwFlags);
    STDMETHODIMP CanNavigateNow(void);
    STDMETHODIMP GetPidl(LPITEMIDLIST *ppidl);
    STDMETHODIMP SetReferrer(LPITEMIDLIST pidl);
    STDMETHODIMP_(DWORD) GetBrowserIndex(void);
    STDMETHODIMP GetBrowserByIndex(DWORD dwID, IUnknown **ppunk);
    STDMETHODIMP GetHistoryObject(IOleObject **ppole, IStream **ppstm, IBindCtx **ppbc);
    STDMETHODIMP SetHistoryObject(IOleObject *pole, BOOL fIsLocalAnchor);
    STDMETHODIMP CacheOLEServer(IOleObject *pole);
    STDMETHODIMP GetSetCodePage(VARIANT* pvarIn, VARIANT* pvarOut);
    STDMETHODIMP OnHttpEquiv(IShellView* psv, BOOL fDone, VARIANT *pvarargIn, VARIANT *pvarargOut);
    STDMETHODIMP GetPalette( HPALETTE * hpal );
    STDMETHODIMP RegisterWindow(BOOL fUnregister, int swc) {return E_NOTIMPL;}
    STDMETHODIMP_(LRESULT) WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP OnSize(WPARAM wParam);
    STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    STDMETHODIMP_(LRESULT) OnCommand(WPARAM wParam, LPARAM lParam);
    STDMETHODIMP OnDestroy();
    STDMETHODIMP ReleaseShellView();
    STDMETHODIMP ActivatePendingView();
    STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    STDMETHODIMP OnSetFocus();
    STDMETHODIMP OnFrameWindowActivateBS(BOOL fActive);
    STDMETHODIMP SetTopBrowser();
    STDMETHODIMP UpdateSecureLockIcon(int eSecureLock);
    STDMETHODIMP Offline(int iCmd);
    STDMETHODIMP SetActivateState(UINT uActivate) { _bbd._uActivateState = uActivate; return S_OK;};
    STDMETHODIMP AllowViewResize(BOOL f) { HRESULT hres = _fDontResizeView ? S_FALSE : S_OK; _fDontResizeView = !BOOLIFY(f); return hres;};
    STDMETHODIMP InitializeDownloadManager();
    STDMETHODIMP InitializeTransitionSite();
    STDMETHODIMP CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd);
    STDMETHODIMP GetFolderSetData(struct tagFolderSetData*) { ASSERT(0); return E_NOTIMPL;};
    STDMETHODIMP CreateBrowserPropSheetExt(REFIID, void **) { ASSERT(0); return E_NOTIMPL;};
    STDMETHODIMP GetBaseBrowserData( LPCBASEBROWSERDATA* ppbd ) { *ppbd = &_bbd; return S_OK; };
    STDMETHODIMP_(LPBASEBROWSERDATA) PutBaseBrowserData() { return &_bbd; };

    STDMETHODIMP SetAsDefFolderSettings() { TraceMsg(TF_ERROR, "CBaseBrowser2::SetAsDefFolderSettings called, returned E_NOTIMPL"); return E_NOTIMPL;};
    STDMETHODIMP GetViewRect(RECT* prc);
    STDMETHODIMP GetViewWindow(HWND * phwndView);
    STDMETHODIMP InitializeTravelLog(ITravelLog* ptl, DWORD dw);
    STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);

    // ITravelLogClient
    STDMETHODIMP FindWindowByIndex(DWORD dwID, IUnknown ** ppunk);
    STDMETHODIMP GetWindowData(LPWINDOWDATA pWinData);
    STDMETHODIMP LoadHistoryPosition(LPOLESTR pszUrlLocation, DWORD dwCookie);

    // ITridentService
    STDMETHODIMP FireBeforeNavigate2(IDispatch * pDispatch,
                                     LPCTSTR     lpszUrl,
                                     DWORD       dwFlags,
                                     LPCTSTR     lpszFrameName,
                                     LPBYTE      pPostData,
                                     DWORD       cbPostData,
                                     LPCTSTR     lpszHeaders,
                                     BOOL        fPlayNavSound,
                                     BOOL      * pfCancel);
    STDMETHODIMP FireNavigateComplete2(IHTMLWindow2 * pHTMLWindow2,
                                       DWORD          dwFlags);
        
    STDMETHODIMP FireDownloadBegin();
    STDMETHODIMP FireDownloadComplete();
    STDMETHODIMP FireDocumentComplete(IHTMLWindow2 * pHTMLWindow2,
                                      DWORD          dwFlags);

    STDMETHODIMP UpdateDesktopComponent(IHTMLWindow2 * pHTMLWindow);
    STDMETHODIMP GetPendingUrl(BSTR * pbstrPendingUrl);
    STDMETHODIMP ActiveElementChanged(IHTMLElement * pHTMLElement);
    STDMETHODIMP GetUrlSearchComponent(BSTR * pbstrSearch);
    STDMETHODIMP IsErrorUrl(LPCTSTR lpszUrl, BOOL *pfIsError);

    STDMETHOD(FireNavigateError)(IHTMLWindow2 * pHTMLWindow2,
                                 DWORD  dwStatusCode,
                                 BOOL * pfCancel)
    {
        ASSERT(0);
        return E_NOTIMPL;
    }

    // ITridentService2
    //
    STDMETHODIMP AttachMyPics(void *pDoc2, void **ppMyPics);
    STDMETHODIMP_(BOOL) ReleaseMyPics(void *pMyPics);
    STDMETHODIMP InitAutoImageResize();
    STDMETHODIMP UnInitAutoImageResize();
    STDMETHODIMP IsGalleryMeta(BOOL bFlag, void *pMyPics);
    STDMETHODIMP EmailPicture(BSTR bstrURL);

    STDMETHODIMP FireNavigateError(IHTMLWindow2 * pHTMLWindow2, 
                                   BSTR           bstrURL,
                                   BSTR           bstrTargetFrameName,
                                   DWORD          dwStatusCode,
                                   BOOL         * pfCancel);

    STDMETHODIMP FirePrintTemplateEvent(IHTMLWindow2 * pHTMLWindow2, DISPID dispidPrintEvent);
    STDMETHODIMP FireUpdatePageStatus(IHTMLWindow2 * pHTMLWindow2, DWORD nPage, BOOL fDone);
    STDMETHODIMP FirePrivacyImpactedStateChange(BOOL bPrivacyImpacted);

    STDMETHODIMP_(UINT) _get_itbLastFocus() { ASSERT(0); return ITB_VIEW; };
    STDMETHODIMP _put_itbLastFocus(UINT itbLastFocus) { return E_NOTIMPL; };

    // IShellBrowserService
    //
    STDMETHODIMP GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv) {ASSERT(0); return E_NOTIMPL;}
    // see _UIActivateView, below
    
    // BEGIN REVIEW:  review names and need of each.  
    // 
    // this first set could be basebrowser only members.  no one overrides
    STDMETHODIMP _CancelPendingNavigationAsync() ;
    STDMETHODIMP _CancelPendingView() ;
    STDMETHODIMP _MaySaveChanges() ; 
    STDMETHODIMP _PauseOrResumeView( BOOL fPaused) ;
    STDMETHODIMP _DisableModeless() ;
    
    // rethink these... are all of these necessary?
    STDMETHODIMP _NavigateToPidl( LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags);
    STDMETHODIMP _TryShell2Rename( IShellView* psv, LPCITEMIDLIST pidlNew);
    STDMETHODIMP _SwitchActivationNow( );

    
    // this belongs with the toolbar set.
    STDMETHODIMP _ExecChildren(IUnknown *punkBar, BOOL fBroadcast,
                              const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                              VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    STDMETHODIMP _SendChildren(HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam);

    STDMETHODIMP _GetViewBorderRect(RECT* prc);
    STDMETHODIMP _UpdateViewRectSize();
    STDMETHODIMP _ResizeNextBorder(UINT itb);
    STDMETHODIMP _ResizeView();

    // Notes: Only CDesktopBrowser may sublcass this.
    STDMETHODIMP _GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon);

    //END REVIEW:

    // CDesktopBrowser accesses CCommonBrowser implementations of these:
    STDMETHODIMP_(IStream*) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName) { ASSERT(FALSE); return NULL; }
    STDMETHODIMP_(LRESULT) ForwardViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam) { ASSERT(FALSE); return 0; }
    STDMETHODIMP SetAcceleratorMenu(HACCEL hacc) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP_(int) _GetToolbarCount(THIS) { ASSERT(FALSE); return 0; }
    STDMETHODIMP_(LPTOOLBARITEM) _GetToolbarItem(THIS_ int itb) { ASSERT(FALSE); return NULL; }
    STDMETHODIMP _SaveToolbars(IStream* pstm) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP _LoadToolbars(IStream* pstm) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP _CloseAndReleaseToolbars(BOOL fClose) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP v_MayGetNextToolbarFocus(LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd) { ASSERT(FALSE); return E_NOTIMPL; };
    STDMETHODIMP _ResizeNextBorderHelper(UINT itb, BOOL bUseHmonitor) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP_(UINT) _FindTBar(IUnknown* punkSrc) { ASSERT(FALSE); return (UINT)-1; };
    STDMETHODIMP _SetFocus(LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP v_MayTranslateAccelerator(MSG* pmsg) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP _GetBorderDWHelper(IUnknown* punkSrc, LPRECT lprectBorder, BOOL bUseHmonitor) { ASSERT(FALSE); return E_NOTIMPL; }

    // CShellBrowser overrides this.
    STDMETHODIMP v_CheckZoneCrossing(LPCITEMIDLIST pidl) {return S_OK;};

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);

    // IAdviseSink
    STDMETHODIMP_(void) OnDataChange(FORMATETC *, STGMEDIUM *);
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename(IMoniker *);
    STDMETHODIMP_(void) OnSave();
    STDMETHODIMP_(void) OnClose();

    // IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IInputObjectSite
    STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    // IDocNavigate
    STDMETHODIMP OnReadyStateChange(IShellView* psvSource, DWORD dwReadyState);
    STDMETHODIMP get_ReadyState(DWORD * pdwReadyState);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid);

    // IPersistHistory
    STDMETHODIMP LoadHistory(IStream *pStream, IBindCtx *pbc);
    STDMETHODIMP SaveHistory(IStream *pStream);
    STDMETHODIMP SetPositionCookie(DWORD dwPositionCookie);
    STDMETHODIMP GetPositionCookie(DWORD *pdwPositioncookie);

    // IInternetSecurityMgrSite
    // STDMETHODIMP GetWindow(HWND * lphwnd) { return IOleWindow::GetWindow(lphwnd); }
    STDMETHODIMP EnableModeless(BOOL fEnable) { return EnableModelessSB(fEnable); }

    // IVersionHost
    STDMETHODIMP QueryUseLocalVersionVector( BOOL *fUseLocal);
    STDMETHODIMP QueryVersionVector( IVersionVector *pVersion);

    // ITravelLogClient2
    STDMETHODIMP GetDummyWindowData(LPWSTR pszUrl, LPWSTR pszTitle, LPWINDOWDATA pWinData);

    // This is the QueryInterface the aggregator implements
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void ** ppvObj);

    // IInitViewLinkedWebOC methods

    STDMETHODIMP SetViewLinkedWebOC(BOOL bValue) 
    {
        _fIsViewLinkedWebOC = bValue;
        return S_OK;
    };

    STDMETHODIMP IsViewLinkedWebOC(BOOL* pbValue) 
    {
        ASSERT(pbValue);

        *pbValue = _fIsViewLinkedWebOC;
        return S_OK;
    };

    STDMETHODIMP SetViewLinkedWebOCFrame(IDispatch * pDisp)
    {
        HRESULT hr = E_FAIL;

        ASSERT(pDisp);

        ATOMICRELEASE(_pDispViewLinkedWebOCFrame);

        hr = IUnknown_QueryService(pDisp,
                                   SID_SWebBrowserApp,
                                   IID_PPV_ARG(IWebBrowser2, &_pDispViewLinkedWebOCFrame));

        if (FAILED(hr))
        {
            _fIsViewLinkedWebOC = FALSE;   
        }

        return hr;
    };

    STDMETHODIMP GetViewLinkedWebOCFrame(IDispatch** ppDisp)
    {
        ASSERT(_fIsViewLinkedWebOC);
        ASSERT(_pDispViewLinkedWebOCFrame);
        ASSERT(ppDisp);

        *ppDisp = _pDispViewLinkedWebOCFrame;
        _pDispViewLinkedWebOCFrame->AddRef();

        return S_OK;
    };

    STDMETHODIMP SetFrameName(BSTR bstrFrameName);

    // INotifyAppStart

    STDMETHODIMP AppStarting(void);
    STDMETHODIMP AppStarted(void);

    static BSTR GetHTMLWindowUrl(IHTMLWindow2 * pHTMLWindow);
    static LPITEMIDLIST PidlFromUrl(BSTR bstrUrl);
    
protected:

    // "protected" so derived classes can construct/destruct us too
    CBaseBrowser2(IUnknown* punkAgg);   
    virtual ~CBaseBrowser2();
    
    friend HRESULT CBaseBrowser2_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend HRESULT CBaseBrowser2_Validate(HWND hwnd, void ** ppsb);

    // topmost CBaseBrowser2 in a frameset (IE3/AOL/CIS/VB)
    virtual void        _OnNavigateComplete(LPCITEMIDLIST pidl, DWORD grfHLNF);
    virtual HRESULT     _CheckZoneCrossing(LPCITEMIDLIST pidl);
    virtual STDMETHODIMP _PositionViewWindow(HWND hwnd, LPRECT prc);
    void                _PositionViewWindowHelper(HWND hwnd, LPRECT prc);
    virtual LRESULT     _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void        _ViewChange(DWORD dwAspect, LONG lindex);
    virtual void        _UpdateBackForwardState();
    virtual BOOL        v_OnSetCursor(LPARAM lParam);
    virtual STDMETHODIMP v_ShowHideChildWindows(BOOL fChildOnly);
    virtual void        v_PropagateMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend);
    virtual HRESULT     _ShowBlankPage(LPCTSTR pszAboutUrl, LPCITEMIDLIST pidlIntended);
    
    // ViewStateStream related
    
    HRESULT     _CheckInCacheIfOffline(LPCITEMIDLIST pidl, BOOL fIsAPost);
    void        _CreateShortcutOnDesktop(IUnknown *pUnk, BOOL fUI);
    void        _AddToFavorites(LPCITEMIDLIST pidl, LPCTSTR pszTitle, BOOL fDisplayUI);

    // to avoid having to pass hwnd on every message to WndProc, set it once
    void        _SetWindow(HWND hwnd) { _bbd._hwnd = hwnd; }
    void        _DoOptions(VARIANT* pvar);
    LRESULT     _OnGoto(void);
    void        _NavigateToPidlAsync(LPITEMIDLIST pidl, DWORD dwSBSP, BOOL fDontCallCancel = FALSE);
    BOOL        _CanNavigate(void);

    // inline so that lego will get the right opt.
    void        _PreActivatePendingViewAsync(void) 
    {
        _StopAsyncOperation();
    };

    BOOL        _ActivatePendingViewAsync(void);
    void        _FreeQueuedPidl(LPITEMIDLIST* ppidl);
    void        _StopAsyncOperation(void);
    void        _MayUnblockAsyncOperation();
    BOOL        _PostAsyncOperation(UINT uAction);
    LRESULT     _SendAsyncOperation(UINT uAction);
    void        _SendAsyncNavigationMsg(VARIANTARG *pvarargIn);
    HRESULT     _OnCoCreateDocument(VARIANTARG *pvarargOut);
    void        _NotifyCommandStateChange();

    BOOL        _IsViewMSHTML(IShellView * psv);

    BOOL        _ActivateView(BSTR         bstrUrl,
                              LPITEMIDLIST pidl,
                              DWORD        dwFlags,
                              BOOL         fIsErrorUrl);

    HRESULT     _GetWebBrowserForEvt(IDispatch     * pDispatch,
                                     IWebBrowser2 ** ppWebBrowser);

    void        _Exec_psbMixedZone();

#ifdef TEST_AMBIENTS
    BOOL        _LocalOffline(int iCmd);
    BOOL        _LocalSilent(int iCmd);
#endif // TEST_AMBIENTS
    
    #define NAVTYPE_ShellNavigate   0x01
    #define NAVTYPE_PageIsChanging  0x02
    #define NAVTYPE_SiteIsChanging  0x04

    void         _EnableStop(BOOL fEnable);
    LRESULT      _OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu);
    HRESULT      _updateNavigationUI();
    HRESULT      _setDescendentNavigate(VARIANTARG *pvarargIn);
    void         _UpdateBrowserState(LPCITEMIDLIST pidl);
    void         _UpdateDocHostState(LPITEMIDLIST pidl, BOOL fIsErrorUrl) const;
    HRESULT      _FireBeforeNavigateEvent(LPCITEMIDLIST pidl, BOOL* pfUseCache);
    LPITEMIDLIST _GetPidlForDisplay(BSTR bstrUrl, BOOL * pfIsErrorUrl = NULL);

    HRESULT      _OpenNewFrame(LPITEMIDLIST pidlNew, UINT wFlags);
    STDMETHODIMP _UIActivateView(UINT uState);
    HRESULT      _CancelPendingNavigation(BOOL fDontReleaseState = FALSE);
    void         _StopCurrentView(void);

    void         _MayTrackClickStream(LPITEMIDLIST pidlThis);        // (peihwal)

    STDMETHODIMP _OnFocusChange(UINT itb);

    void         _RegisterAsDropTarget();
    void         _UnregisterAsDropTarget();

    HRESULT     _InitDocHost(IWebBrowser2 * pWebBrowser);

    enum BrowserPaletteType
    {
        BPT_DeferPaletteSupport = 0,    // we don't think we own the palette
        BPT_UnknownDisplay,             // need to decide if we need a palette
        BPT_DisplayViewChanged,         // BPT_UnknownDisplay handling notify
        BPT_UnknownPalette,             // need to decide what palette to use
        BPT_PaletteViewChanged,         // BPT_UnknownPalette handling notify
        BPT_Normal,                     // handle WM_QUERYNEWPALETTE ourselves
        BPT_ShellView,                  // forward WM_QUERYNEWPALETTE to view
        BPT_NotPalettized               // not a palettized display, do nothing
    };
    
    void            _ColorsDirty(BrowserPaletteType bptNew);
    void            _DisplayChanged(WPARAM wParam, LPARAM lParam);
    HRESULT         _UpdateBrowserPaletteInPlace(LOGPALETTE *plp);
    void            _RealizeBrowserPalette(BOOL fBackground);
    virtual void    _PaletteChanged(WPARAM wParam, LPARAM lParam);
    BOOL            _QueryNewPalette();

    /// BEGIN-CHC- Security fix for viewing non shdocvw ishellviews
    void    _CheckDisableViewWindow();
    BOOL    _SubclassDefview();
    static LRESULT DefViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    WNDPROC _pfnDefView;
    /// END-CHC- Security fix for viewing non shdocvw ishellviews
    
    void            _DLMDestroy(void);
    void            _DLMUpdate(MSOCMD* prgCmd);
    void            _DLMRegister(IUnknown* punk);

    void            CreateNewSyncShellView( void );

    void            _UpdateTravelLog(BOOL fForceUpdate = FALSE);

    virtual BOOL    _HeyMoe_IsWiseGuy(void) {return FALSE;}

    IBrowserService2*    _pbsOuter;
    IBrowserService3*    _pbsOuter3;
    IShellBrowser*       _psbOuter;
    IServiceProvider*    _pspOuter;
    IDockingWindowSite*  _pdwsOuter;
    // The following are intercepted by CCommonBrowser, but we don't call 'em
    //IOleCommandTarget* _pctOuter;
    //IInputObjectSite*  _piosOuter;

    BASEBROWSERDATA _bbd;
    IUnknown *_pauto;

    BrowserPaletteType  _bptBrowser;
    HPALETTE            _hpalBrowser;

    IViewObject *_pvo;  // view object implementation on the shell view
    UINT  _cRefUIActivateSV;

    DWORD  _dwBrowserIndex;
    DWORD       _dwReadyState;

    DWORD       _dwReadyStateCur;
    LPWSTR      _pszTitleCur;
    
    IDropTarget * _pdtView; // Pointer to _bbd._psv's IDropTarget interface
    

    IOleObject * _poleHistory;
    IStream    * _pstmHistory;
    IBindCtx   * _pbcHistory;
    
    IHTMLDocument2  * _pHTMLDocument;
    IPersistHistory * _pphHistory;

    IOleInPlaceActiveObject *_pact;     // for UIWindow

    IClassFactory* _pcfHTML;            // cached/locked class factory

    
    DWORD       _dwReadyStatePending;
    LPWSTR      _pszTitlePending;
    DWORD       _grfHLNFPending;
    HDPA        _hdpaDLM;           // downloading object (for DLM)
    BOOL        _cp;                // current codepage

    //
    // NOTES: Currently, we support only one pending navigation.
    //  If we want to support queued navigation, we need to turn
    //  following two variables into a queue. (SatoNa)
    //
    DWORD       _uActionQueued;       // queued action
    LPITEMIDLIST _pidlQueued;         // pidl to go asynchronously
    DWORD       _dwSBSPQueued;        // grfHLNF to go asynchronously

    UINT        _cRefCannotNavigate;  // Increment when we can navigate

    RECT _rcBorderDoc;                  // for UIWindow
    DWORD _dwStartingAppTick;

    BITBOOL     _fDontResizeView : 1; // Don't resize _hwndView
    BITBOOL     _fNavigate:1;       // are we navigating?
    BITBOOL     _fDescendentNavigate:1; // are our descendents navigating?
    BITBOOL     _fDownloadSet:1;        // did we invoke download animation ?
    BITBOOL     _fNoDragDrop:1;          // TRUE iff we want to register for drops
    BITBOOL     _fRegisteredDragDrop:1;  // TRUE iff we have registered for drops
    BITBOOL     _fNavigatedToBlank: 1;  // Has called _ShowBlankPage once.
    BITBOOL     _fAsyncNavigate:1; // Ignore sync-hack-bug-fix
    BITBOOL     _fPausedByParent :1;    // Interaction paused by parent
    BITBOOL     _fDontAddTravelEntry:1;
    BITBOOL     _fIsLocalAnchor:1;
    BITBOOL     _fGeneratedPage:1;      //  trident told us that the page is generated.
    BITBOOL     _fOwnsPalette:1;        // does the browser own the palette ? (did we get QueryNewPalette ..)
    BITBOOL     _fUsesPaletteCommands : 1; // if we are using a separate communication with trident for palette commands
    BITBOOL     _fCreateViewWindowPending:1;
    BITBOOL     _fReleasingShellView:1; 
    BITBOOL     _fDeferredUIDeactivate:1;
    BITBOOL     _fDeferredSelfDestruction:1;
    BITBOOL     _fActive:1;  // remember if the frame is active or not (WM_ACTIVATE)
    BITBOOL     _fUIActivateOnActive:1; // TRUE iff we have a bending uiactivate
    BITBOOL     _fInQueryStatus:1;
    BITBOOL     _fCheckedDesktopComponentName:1;
    BITBOOL     _fInDestroy:1;            // being destroyed
    BITBOOL     _fDontUpdateTravelLog:1;
    BITBOOL     _fHtmlNavCanceled:1;
    BITBOOL     _fDontShowNavCancelPage:1;

    BITBOOL     _fHadBeforeNavigate   :1;
    BITBOOL     _fHadNavigateComplete :1;

    enum DOCFLAGS
    {
        DOCFLAG_DOCCANNAVIGATE         = 0x00000001,  // The document knows how to navigate
        DOCFLAG_NAVIGATEFROMDOC        = 0x00000002,  // Document called Navigate
        DOCFLAG_SETNAVIGATABLECODEPAGE = 0x00000004,  // GetBindInfo should call NavigatableCodepage
    };

    DWORD _dwDocFlags;
    
    // for IDropTarget
    
    DWORD _dwDropEffect;

#ifdef DEBUG
    BOOL        _fProcessed_WM_CLOSE; // TRUE iff WM_CLOSE processed
    BOOL        _fMightBeShuttingDown; // TRUE if we might be shutting down (recieved a WM_QUERYENDSESSION || (WM_ENDSESSION w/ wParam == TRUE))
#endif

    // friend   CIEFrameAuto;
    interface IShellHTMLWindowSupport   *_phtmlWS;  
    
    IUrlHistoryStg *_pIUrlHistoryStg;   // pointer to url history storage object
    
    ITravelLogStg *_pITravelLogStg;     // exposed travel log object

    ITargetFrame2 *_ptfrm;
    
    //  Cached History IShellFolder
    IUnknown *_punkSFHistory;

    //  what SSL icon to show
    int     _eSecureLockIconPending;
    
    // Support for OLECMDID_HTTPEQUIV (Client Pull, PICS, etc)

#ifdef NEVER
    HRESULT _HandleHttpEquiv (VARIANT *pvarargIn, VARIANT *pvarargOut, BOOL fDone);
    HRESULT _KillRefreshTimer( void );
    VOID    _OnRefreshTimer(void);
    void    _StartRefreshTimer(void);

    // equiv handlers we know about
    friend HRESULT _HandleRefresh (HWND hwnd, WCHAR *pwz, WCHAR *pwzColon, CBaseBrowser2 *pbb, BOOL fDone, LPARAM lParam);
#endif

    friend HRESULT _HandlePICS (HWND hwnd, WCHAR *pwz, WCHAR *pwzColon, CBaseBrowser2 *pbb, BOOL fDone, LPARAM lParam);

#ifdef NEVER
    friend VOID CALLBACK _RefreshTimerProc (HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    // Client Pull values
    WCHAR *_pwzRefreshURL;
    int    _iRefreshTimeout;
    BOOL   _iRefreshTimeoutSet:1;
    INT_PTR _iRefreshTimerID;
#endif

#ifdef MESSAGEFILTER
    // COM Message filter used to help dispatch TIMER messages during OLE operations.
    LPMESSAGEFILTER _lpMF;
#endif

    CUrlTrackingStg * _ptracking;

    CAutoImageResize *_pAIResize;

    // _fTopBrowser vs. _fNoTopLevelBrowser:
    // _fTopBrowser: True means we are the top most browser, or a top most browser does not exist and we are acting like the top most browser.
    //               In the latter case, the immediate childern of our host will also act like top most browsers.
    // _fNoTopLevelBrowser: This means that the top most item isn't one of our shell browsers, so it's immediate browser child
    //               will act like a top most browser.
    //
    //     In normal cases, a shell browser (CShellBrowser, CDesktopBrowser, ...) is a top most browser
    //   with TRUE==_fTopBrowser and FALSE==_fNoTopLevelBrowser.  It can have subframes that will have
    //   FALSE==_fTopBrowser and FALSE==_fNoTopLevelBrowser.
    //
    //   The only time _fNoTopLevelBrowser is TRUE is if some other object (like Athena) hosts MSHTML directly
    //   which will prevent some shell browser from being top most.  Since the HTML can have several frames,
    //   each will have TRUE==_fTopBrowser, so _fNoTopLevelBrowser will be set to TRUE to distinguish this case.
    BOOL        _fTopBrowser :1;    // Should only be set via the _SetTopBrowser method
    BOOL        _fNoTopLevelBrowser :1;         // TRUE iff the toplevel is a non-shell browser (Athena).  Shell browsers include CDesktopBrowser, CShellBrowser, ...
    BOOL        _fHaveOldStatusText :1;
    
    WCHAR       _szwOldStatusText[MAX_PATH];

    FOLDERSETDATABASE _fldBase; // cache viewset results in here (used when navigating)

    // Manages extended toolbar buttons and tools menu extensions for IE
    IToolbarExt* _pToolbarExt;

    LPITEMIDLIST _pidlBeforeNavigateEvent;         // pidl refered to in BeforeNavigate2 event

    // ViewLinkedWebOC variables

    BOOL           _fIsViewLinkedWebOC;                // TRUE if an instance of the WebOC is a ViewLinked
    IWebBrowser2*  _pDispViewLinkedWebOCFrame;         // The pDisp of the Frame of a ViewLinkedWebOC.
    BOOL           _fHadFirstBeforeNavigate;           // TRUE if we have already skipped over the first ViewLinkedWebOC's 
                                                       // BeforeNavigateEvent.

    TCHAR _szViewLinkedWebOCFrameName[INTERNET_MAX_URL_LENGTH+1];

public:

    // handling for plugUI shutdown
    // need the hwnd for the lang change modal property sheet
    static HDPA         s_hdpaOptionsHwnd;

    static void         _SyncDPA();
    static int CALLBACK _OptionsPropSheetCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam);

private:
    HRESULT _AddFolderOptionsSheets(DWORD dwReserved, LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPPROPSHEETHEADER ppsh);
    HRESULT _AddInternetOptionsSheets(DWORD dwReserved, LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPPROPSHEETHEADER ppsh);
    HRESULT _ReplaceWithGoHome(LPCITEMIDLIST * ppidl, LPITEMIDLIST * ppidlFree);

    // this is private!  it should only be called by _NavigateToPidl

    HRESULT     _CreateNewShellViewPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD fSBSP);
    HRESULT     _CreateNewShellView(IShellFolder* psf, LPCITEMIDLIST pidl, DWORD grfHLNF);
    HRESULT     _DismissFindDialog();

    // Privacy state
    HRESULT     _UpdatePrivacyIcon(BOOL fSetNewState, BOOL fNewState);
};

HRESULT _DisplayParseError(HWND hwnd, HRESULT hres, LPCWSTR pwszPath);

#endif // _BASESB2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\bcw.h ===
/****************************************************************************
bcw.h

  Owner: Srinik
  Copyright (c) 1995 Microsoft Corporation
  
    This header file for BCW class which implements wrappers for IBindCtx 
    and IRunningObjectTable. We use this object to trick the moniker binding
    code to create a new instance of the object (that the moniker is 
    referring to) instead connecting to already running instance. 
****************************************************************************/

#ifndef BCW_H
#define BCW_H

/****************************************************************************
BCW_ROT is the IRunningObjectTable imlementation of BCW_ROT.
****************************************************************************/

class BCW_ROT: public IRunningObjectTable
{ 
    friend class BCW;
public:
    BCW_ROT(); 
    ~BCW_ROT();
    
private:
    BOOL_PTR FInitROTPointer(void);
    
private:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IRunningObjectTable methods ***
    STDMETHODIMP Register(DWORD grfFlags, IUnknown *punkObject,
        IMoniker *pmkObjectName, DWORD *pdwRegister)
    {
        if (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->Register(grfFlags, punkObject, pmkObjectName, pdwRegister);
    }
    
    STDMETHODIMP Revoke(DWORD dwRegister)
    {
        if (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->Revoke(dwRegister);
    }
    
    STDMETHODIMP IsRunning(IMoniker *pmkObjectName)
    {
        // Trick the moniker binding code into thinking that the object is not 
        // running. This way it will try to create a new instance of the object.
        // REVIEW: we may want to check the pmkObjectName, and if is not the one
        // that we are concerned with,then we may want to delegate the call.
        return S_FALSE;
    }
    
    STDMETHODIMP GetObject(IMoniker *pmkObjectName,IUnknown **ppunkObject)
    {
        // Trick the moniker binding code into thinking that the object is not 
        // running. This way it will try to create a new instance of the object.
        // REVIEW: we may want to check the pmkObjectName, and if is not the one
        // that we are concerned with,then we may want to delegate the call.
        return MK_E_UNAVAILABLE;
    }
    
    STDMETHODIMP NoteChangeTime(DWORD dwRegister, FILETIME *pfiletime)
    {
        if  (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->NoteChangeTime(dwRegister, pfiletime);
    }
    
    STDMETHODIMP GetTimeOfLastChange(IMoniker *pmkObjectName,  FILETIME *pfiletime)
    {
        if (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->GetTimeOfLastChange(pmkObjectName, pfiletime);
    }
    
    STDMETHODIMP EnumRunning(IEnumMoniker **ppenumMoniker)
    {
        if (m_piROT == NULL)
            return E_FAIL;
        
        return m_piROT->EnumRunning(ppenumMoniker);
    }
    
private:
    /* Return back pointer to containing BCW object. */
    inline BCW* PBCW();
    IRunningObjectTable * m_piROT;
#ifdef DEBUG
    Debug(ULONG m_cRef); 
#endif
};


/****************************************************************************
Declaration of BCW. This class implements IBindCtx and IRunningObjectTable
This is class is used to manipulate the binding process, such that the 
moniker binding code will create a new instance of the object instead of 
binding to the existing instance
****************************************************************************/

class BCW: public IBindCtx
{ 
    friend class BCW_ROT;
    
public:
    BCW(IBindCtx * pibc); 
    ~BCW();
    
    static IBindCtx * Create(IBindCtx * pibc);
    
private:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IBindCtx methods ***
    STDMETHODIMP RegisterObjectBound(IUnknown *punk)
    {   return m_pibc->RegisterObjectBound(punk); }
    
    STDMETHODIMP RevokeObjectBound(IUnknown *punk)
    {   return m_pibc->RevokeObjectBound(punk); }
    
    STDMETHODIMP ReleaseBoundObjects(void)
    {   return m_pibc->ReleaseBoundObjects(); }
    
    STDMETHODIMP SetBindOptions(BIND_OPTS *pbindopts)
    {   return m_pibc->SetBindOptions(pbindopts); }
    
    STDMETHODIMP GetBindOptions(BIND_OPTS *pbindopts)
    {   return m_pibc->GetBindOptions(pbindopts); }
    
    STDMETHODIMP GetRunningObjectTable(IRunningObjectTable **pprot)
    {   
        if (pprot == NULL)
            return E_INVALIDARG;
        
        *pprot = (IRunningObjectTable *) &m_ROT;
        ((IUnknown *) *pprot)->AddRef();
        return NOERROR;
    }
    
    STDMETHODIMP RegisterObjectParam(LPOLESTR pszKey, IUnknown *punk)
    {   return m_pibc->RegisterObjectParam(pszKey, punk); }
    
    STDMETHODIMP GetObjectParam(LPOLESTR pszKey, IUnknown **ppunk)
    {   return m_pibc->GetObjectParam(pszKey, ppunk); }
    
    STDMETHODIMP EnumObjectParam(IEnumString **ppenum)
    {   return m_pibc->EnumObjectParam(ppenum); }
    
    STDMETHODIMP RevokeObjectParam(LPOLESTR pszKey)
    {   return m_pibc->RevokeObjectParam(pszKey); }
    
private:
    BCW_ROT     m_ROT;      // IRunningObjectTable implementation
    DWORD       m_cObjRef;
    IBindCtx *  m_pibc;
};

#endif  // BCW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\bindcb.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

// the CStubBindStatusCallback implements IBindStatusCallback,
// IHttpNegotiate.  We use it to make a "fake" bind status callback
// object when we have headers and post data we would like to apply
// to a navigation.  We supply this IBindStatusCallback object, and
// the URL moniker asks us for headers and post data and use those in
// the transaction.

#include "priv.h"
#include "sccls.h"
#include "bindcb.h"  

CStubBindStatusCallback::CStubBindStatusCallback(LPCWSTR pwzHeaders,LPCBYTE pPostData,
    DWORD cbPostData, VARIANT_BOOL bOfflineProperty, VARIANT_BOOL bSilentProperty, BOOL bHyperlink,
    DWORD grBindFlags) : _cRef(1)
    // _pszHeaders(NULL), _hszPostData(NULL), _cbPostData(0)  (don't need to zero-init)
{
    // this is a standalone COM object; need to maintain ref count on our
    // DLL to ensure it doesn't unload
    DllAddRef();

    if (pwzHeaders) {
        _pszHeaders = StrDup(pwzHeaders);    // allocate for a permanent copy
    }

    if (pPostData && cbPostData) {
        // make a copy of post data and store it
        _hszPostData = GlobalAlloc(GPTR,cbPostData);
        if (_hszPostData) {
            memcpy((LPVOID) _hszPostData,pPostData,cbPostData);
            _cbPostData = cbPostData;
        }
    }

    _bFrameIsOffline = bOfflineProperty ? TRUE : FALSE;
    _bFrameIsSilent = bSilentProperty ? TRUE : FALSE;
    _bHyperlink = bHyperlink ? TRUE : FALSE;
    _grBindFlags = grBindFlags;
    TraceMsg(TF_SHDLIFE, "ctor CStubBindStatusCallback %x", this);
}

HRESULT CStubBSC_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CStubBindStatusCallback * pbsc = new CStubBindStatusCallback(NULL, NULL, 0, FALSE, FALSE, TRUE, 0);
    if (pbsc) {
    *ppunk = (IBindStatusCallback *)pbsc;
    return S_OK;
    }

    return E_OUTOFMEMORY;
}


CStubBindStatusCallback::~CStubBindStatusCallback()
{
    TraceMsg(TF_SHDLIFE, "dtor CBindStatusCallback %x", this);

    _FreeHeadersAndPostData();  // free any data we still have in this object

    // release ref count on DLL
    DllRelease();
}

STDMETHODIMP CStubBindStatusCallback::QueryInterface(REFIID riid,
    LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IBindStatusCallback)) {
        *ppvObj = SAFECAST(this, IBindStatusCallback*);
    } else if (IsEqualIID(riid, IID_IHttpNegotiate)) {
        *ppvObj = SAFECAST(this, IHttpNegotiate*);
    } else if (IsEqualIID(riid, IID_IMarshal)) {
        *ppvObj = SAFECAST(this, IMarshal*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();  // handing out an interface on ourselves; bump up ref count

    return S_OK;
}

STDMETHODIMP_(ULONG) CStubBindStatusCallback::AddRef(void)
{
    _cRef++;
    TraceMsg(TF_SHDREF, "CStubBindStatusCallback(%x)::AddRef called, new _cRef=%d", this, _cRef);

    return _cRef;
}

STDMETHODIMP_(ULONG) CStubBindStatusCallback::Release(void)
{
    _cRef--;
    TraceMsg(TF_SHDREF, "CStubBindStatusCallback(%x)::Release called, new _cRef=%d", this, _cRef);

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

//
//  Implementation of IBindStatusCallback begins here
//

// implements IBindStatusCallback::OnStartBinding
STDMETHODIMP CStubBindStatusCallback::OnStartBinding(DWORD grfBSCOption,IBinding *pib)
{
    return S_OK;  // we don't care
}

// implements IBindStatusCallback::GetPriority
STDMETHODIMP CStubBindStatusCallback::GetPriority(LONG *pnPriority)
{
    *pnPriority = NORMAL_PRIORITY_CLASS;

    return S_OK;
}

// implements IBindStatusCallback::OnLowResource
STDMETHODIMP CStubBindStatusCallback::OnLowResource(DWORD reserved)
{
    return S_OK;  // we don't care
}

// implements IBindStatusCallback::OnProgress
STDMETHODIMP CStubBindStatusCallback::OnProgress(ULONG ulProgress,ULONG ulProgressMax,
        ULONG ulStatusCode,LPCWSTR szStatusText)
{
    return S_OK;  // we don't care
}

// implements IBindStatusCallback::OnStopBinding
STDMETHODIMP CStubBindStatusCallback::OnStopBinding(HRESULT hresult,LPCWSTR szError)
{
    return S_OK;  // we don't care
}

// implements IBindStatusCallback::GetBindInfo
STDMETHODIMP CStubBindStatusCallback::GetBindInfo(DWORD *grfBINDF,BINDINFO *pbindinfo)
{
    HRESULT hr;

    if ( !grfBINDF || !pbindinfo || !pbindinfo->cbSize )
        return E_INVALIDARG;

    // call helper function to do fill in BINDINFO struct with appropriate
    // binding data
    *grfBINDF = _grBindFlags;
    hr = BuildBindInfo(grfBINDF,pbindinfo,_hszPostData,_cbPostData, _bFrameIsOffline, _bFrameIsSilent, _bHyperlink,
        (IBindStatusCallback *) this);

    return hr;
}

// implements IBindStatusCallback::OnDataAvailable
STDMETHODIMP CStubBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
    FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    ASSERT(FALSE);  // should never get called here!

    return S_OK;
}

STDMETHODIMP CStubBindStatusCallback::OnObjectAvailable(REFIID riid,IUnknown *punk)
{
    return S_OK;
}

//
//  Implementation of IHttpNegotiate begins here
//

// implements IHttpNegotiate::BeginningTransaction
STDMETHODIMP CStubBindStatusCallback::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
    DWORD dwReserved, LPWSTR *ppwzAdditionalHeaders)
{
    // call helper function
    return BuildAdditionalHeaders(_pszHeaders,(LPCWSTR *) ppwzAdditionalHeaders);
}

// implements IHttpNegotiate::OnResponse
STDMETHODIMP CStubBindStatusCallback::OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
    LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders)
{

    return S_OK;
}

//
//  Additional methods on our class begin here
//

STDMETHODIMP CStubBindStatusCallback::_FreeHeadersAndPostData()
{
    if (_pszHeaders) {
        LocalFree((HGLOBAL) _pszHeaders);
        _pszHeaders = NULL;
    }

    if (_hszPostData) {
        GlobalFree(_hszPostData);
        _hszPostData = NULL;
        _cbPostData = 0;
    }
    
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::_CanMarshalIID
//
//  Synopsis:   Checks whether this object supports marshalling this IID.
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL CStubBindStatusCallback::_CanMarshalIID(REFIID riid)
{
    // keep this in sync with the QueryInterface
    return (BOOL) (IsEqualIID(riid,IID_IBindStatusCallback) || 
                   IsEqualIID(riid,IID_IUnknown) ||
                   IsEqualIID(riid, IID_IHttpNegotiate));
}

//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::_ValidateMarshalParams
//
//  Synopsis:   Validates the standard set parameters that are passed into most
//              of the IMarshal methods
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CStubBindStatusCallback::_ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags)
{

    HRESULT hr = NOERROR;
 
    if (_CanMarshalIID(riid))
    {
        // 10/02/96 chrisfra: ask johannp, should we be supporting future contexts
        // via CoGetStandardMarshal?

        ASSERT((dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_LOCAL || dwDestContext == MSHCTX_NOSHAREDMEM));
        ASSERT((mshlflags == MSHLFLAGS_NORMAL || mshlflags == MSHLFLAGS_TABLESTRONG));

        if (   (dwDestContext != MSHCTX_INPROC && dwDestContext != MSHCTX_LOCAL && dwDestContext != MSHCTX_NOSHAREDMEM)
            || (mshlflags != MSHLFLAGS_NORMAL && mshlflags != MSHLFLAGS_TABLESTRONG))
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// IMarshal methods
//
//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::GetUnmarshalClass
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pCid] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CStubBindStatusCallback::GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid)
{
    HRESULT hr;

    hr = _ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        *pCid = (CLSID) CLSID_CStubBindStatusCallback;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::GetMarshalSizeMax
//
//  Synopsis:
//
//  Arguments:  [void] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pSize] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CStubBindStatusCallback::GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize)
{
    HRESULT hr;

    if (pSize == NULL)
    {
        hr = E_INVALIDARG;

    }
    else
    {

        hr = _ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
        if (hr == NOERROR)
        {

            // size of fBSCBFlags, grBindFlags, postdata, headers.
            *pSize = (sizeof(DWORD) + 3 * sizeof(DWORD)) + _cbPostData ;
            if (_pszHeaders)
                *pSize += lstrlen(_pszHeaders) + 1;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::MarshalInterface
//
//  Synopsis:
//
//  Arguments:  [REFIID] --
//              [riid] --
//              [DWORD] --
//              [void] --
//              [DWORD] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CStubBindStatusCallback::MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags)
{
    HRESULT hr;
    DWORD cbLen;
    DWORD fBSCBFlags;

    hr = _ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr != NOERROR) goto exitPoint;

    //  Write _grBindFlags
    hr = pistm->Write(&_grBindFlags, sizeof(DWORD), NULL);
    if (hr != NOERROR) goto exitPoint;

    //  Write fBSCBFlags

    fBSCBFlags = (_bFrameIsOffline ? 1 : 0) + (_bFrameIsSilent ? 2 : 0) ;

    hr = pistm->Write(&fBSCBFlags, sizeof(DWORD), NULL);
    if (hr != NOERROR) goto exitPoint;

    //  Write headers

    cbLen = (_pszHeaders ? (lstrlen(_pszHeaders) + 1) * sizeof(TCHAR) : 0);
    hr = pistm->Write(&cbLen, sizeof(DWORD), NULL);
    if (hr != NOERROR) goto exitPoint;
    if (cbLen != 0)
    {
        hr = pistm->Write(_pszHeaders, cbLen, NULL);
        if (hr != NOERROR) goto exitPoint;
    }

    //  Write PostData

    hr = pistm->Write(&_cbPostData, sizeof(DWORD), NULL);
    if (hr != NOERROR) goto exitPoint;
    if (_cbPostData != 0)
    {
        hr = pistm->Write(_hszPostData, _cbPostData, NULL);
        if (hr != NOERROR) goto exitPoint;
    }

exitPoint:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CStubBindStatusCallback::UnmarshalInterface
//
//  Synopsis:   Unmarshals an Urlmon interface out of a stream
//
//  Arguments:  [REFIID] --
//              [void] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CStubBindStatusCallback::UnmarshalInterface(IStream *pistm, REFIID riid, void ** ppvObj)
{
    HRESULT hr = NOERROR;
    DWORD fBSCBFlags;

    if (ppvObj == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (! _CanMarshalIID(riid))
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        *ppvObj = NULL;
        DWORD cbLen;

        //  Free old values, if any

        _FreeHeadersAndPostData();

        //  Read _grBindFlags

        hr = pistm->Read(&fBSCBFlags, sizeof(DWORD), NULL);
        if (hr != NOERROR) goto exitPoint;
        _grBindFlags = fBSCBFlags;

        //  Read m_fBSCBFlags

        hr = pistm->Read(&fBSCBFlags, sizeof(DWORD), NULL);
        if (hr != NOERROR) goto exitPoint;
        _bFrameIsOffline = fBSCBFlags & 1 ? 1:0;
        _bFrameIsSilent = fBSCBFlags & 2 ? 1:0;

        //  Read headers

        hr = pistm->Read(&cbLen, sizeof(DWORD), NULL);
        if (hr != NOERROR) goto exitPoint;
        if (cbLen != 0)
        {
            LPTSTR pszData;

            pszData = (LPTSTR) LocalAlloc(LPTR, cbLen);
            if (pszData == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exitPoint;
            }
            hr = pistm->Read(pszData, cbLen, 0);
            if (hr != NOERROR)
            {
                LocalFree(pszData);
                pszData = NULL;
                goto exitPoint;
            }
            _pszHeaders = pszData;
        }

        //  Read PostData

        hr = pistm->Read(&cbLen, sizeof(DWORD), NULL);
        if (hr != NOERROR) goto exitPoint;
        if (cbLen != 0)
        {
            HGLOBAL hszData;

            // POST data must be HGLOBAL because the StgMedium requires it
            // see bindcb.cpp ::GetBindInfo()
            // This will be freed by the Moniker when it's done with it.


            hszData = GlobalAlloc(GPTR,cbLen);
            if (hszData == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exitPoint;
            }
            hr = pistm->Read(hszData, cbLen, 0);
            if (hr != NOERROR)
            {
                GlobalFree(hszData);
                hszData = NULL;
                goto exitPoint;
            }
            _hszPostData = hszData;
            _cbPostData = cbLen;
        }


        // call QI to get the requested interface
        hr = QueryInterface(riid, ppvObj);
    }
exitPoint:
    return hr;
}

STDMETHODIMP CStubBindStatusCallback::ReleaseMarshalData(IStream *pStm)
{
    //  10/02/96 chrisfra: ask Johannp if this should be seeking past EOD
    return NOERROR;
}

STDMETHODIMP CStubBindStatusCallback::DisconnectObject(DWORD dwReserved)
{
    return NOERROR;
}


//
//  Global helper functions
//

/*******************************************************************

    NAME:       fOnProxy

    SYNOPSIS:   returns TRUE if we are have proxy enabled


********************************************************************/
BOOL fOnProxy()
{
    // are we on a proxy?
    BOOL fRetOnProxy = FALSE;
    DWORD dwValue;
    DWORD dwSize = SIZEOF(dwValue);
    BOOL  fDefault = FALSE;

    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
        TEXT("ProxyEnable"), NULL, (LPBYTE)&dwValue, &dwSize, FALSE, (LPVOID) &fDefault, SIZEOF(fDefault));
    fRetOnProxy = dwValue;

    return fRetOnProxy;
}

/*******************************************************************

    NAME:       SetBindfFlagsBasedOnAmbient

    SYNOPSIS:   sets BINDF_OFFLINE if ambient offline and
                not-connected and sets BINDF_GETFROMCACHE_IF_NET_FAIL
                if ambient offline and connected


********************************************************************/
void SetBindfFlagsBasedOnAmbient(BOOL fAmbientOffline, DWORD *grfBINDF)
{
    if(fAmbientOffline)
    {
        DWORD dwConnectedStateFlags;
        
        // We want to set the offline bindf flag if the ambient flag is set
        // and we're currently not connected.
        //
        // If either of these conditions is not true, clear the offline flag
        // as mshtml may have previously set it.
        if(FALSE == InternetGetConnectedState(&dwConnectedStateFlags, 0))
        {
            *grfBINDF |= BINDF_OFFLINEOPERATION;
            *grfBINDF &= ~BINDF_GETFROMCACHE_IF_NET_FAIL;
        }
        else
        {
            *grfBINDF |= BINDF_GETFROMCACHE_IF_NET_FAIL;
            *grfBINDF &= ~BINDF_OFFLINEOPERATION;   
        }
    }
    else
    {
        *grfBINDF &= ~BINDF_OFFLINEOPERATION;
    }
}


/*******************************************************************

    NAME:       BuildBindInfo

    SYNOPSIS:   Fills out a BINDINFO structure for a URL moniker

    NOTES:      The point of having this in a global helper function is
                so we don't have to duplicate this code in multiple
                implementations of IBindStatusCallback.

                The caller must pass in an IUnknown to be used as the
                pUnkForRelease in the STGMEDIUM for post data.  If there
                is post data, this function will AddRef the passed-in
                IUnknown and return it in the STGMEDIUM structure.  The
                caller (or someone else, if the caller hands it off) must
                ultimately call Release on pbindinfo->stgmediumData.pUnkForRelease.

********************************************************************/
HRESULT BuildBindInfo(DWORD *grfBINDF,BINDINFO *pbindinfo,HGLOBAL hszPostData,
    DWORD cbPostData, BOOL bFrameIsOffline, BOOL bFrameIsSilent, BOOL bHyperlink, LPUNKNOWN pUnkForRelease)
{
    DWORD dwConnectedStateFlags = 0;
    ASSERT(grfBINDF);
    ASSERT(pbindinfo);
    ASSERT(pUnkForRelease);

    HRESULT hres=S_OK;

    if ( !grfBINDF || !pbindinfo || !pbindinfo->cbSize )
        return E_INVALIDARG;

    // clear BINDINFO except cbSize
    ASSERT(sizeof(*pbindinfo) == pbindinfo->cbSize);
    DWORD cbSize = pbindinfo->cbSize;
    ZeroMemory( pbindinfo, cbSize );
    pbindinfo->cbSize = cbSize;

    *grfBINDF |= BINDF_ASYNCHRONOUS;

    if (bHyperlink)
        *grfBINDF |= BINDF_HYPERLINK;

   
    SetBindfFlagsBasedOnAmbient(bFrameIsOffline, grfBINDF);
    
    if(bFrameIsSilent)
        *grfBINDF |= BINDF_NO_UI;   

    // default method is GET.  Valid ones are _GET, _PUT, _POST, _CUSTOM
    pbindinfo->dwBindVerb = BINDVERB_GET;

    // get IE-wide UTF-8 policy by calling urlmon
    DWORD dwIE = URL_ENCODING_NONE;
    DWORD dwOutLen = sizeof(DWORD);
    if( S_OK == UrlMkGetSessionOption(
        URLMON_OPTION_URL_ENCODING,
        &dwIE, 
        sizeof(DWORD),
        &dwOutLen,
        NULL )  )
    {
        if( dwIE == URL_ENCODING_ENABLE_UTF8 )
        {
            pbindinfo->dwOptions |= BINDINFO_OPTIONS_ENABLE_UTF8;
        }
        else 
        if( dwIE == URL_ENCODING_DISABLE_UTF8 )
        {
            pbindinfo->dwOptions |= BINDINFO_OPTIONS_DISABLE_UTF8;
        }
    }

    // if we have postdata set, then we assume this is a POST verb

    if (hszPostData)
    {
        pbindinfo->dwBindVerb = BINDVERB_POST;
        pbindinfo->stgmedData.tymed = TYMED_HGLOBAL;
        pbindinfo->stgmedData.hGlobal = hszPostData;
        //  this count should *NOT* include the terminating NULL
        pbindinfo->cbstgmedData = cbPostData;
        pbindinfo->stgmedData.pUnkForRelease = pUnkForRelease;
        // addref on the IUnknown that's holding onto this data so
        // it knows to stick around; caller must call Release
        // on the pUnkForRelease when done.
        pUnkForRelease->AddRef(); 

        // We will still cache the response, but we do not want to
        // read from cache for a POST transaction.  This will keep us
        // from reading from the cache.
        *grfBINDF |= BINDF_GETNEWESTVERSION | BINDF_CONTAINER_NOWRITECACHE;
    } else {
        ASSERT(pbindinfo->stgmedData.tymed == TYMED_NULL);
        ASSERT(pbindinfo->stgmedData.hGlobal == NULL);
        ASSERT(pbindinfo->stgmedData.pUnkForRelease == NULL);
    }

    return hres;
}

#define HDR_LANGUAGE     TEXT("Accept-Language:")
#define CRLF             TEXT("\x0D\x0A")
#define HDR_LANGUAGE_CRLF     TEXT("Accept-Language: %s\x0D\x0A")

/*******************************************************************

    NAME:       BuildAdditionalHeaders

    SYNOPSIS:   Builds HTTP headers to be given to URL moniker

    ENTRY:      pszOurExtraHeaders - headers that we explicitly want to add
                *ppwzCombinedHeadersOut - on exit, filled in with
                   buffer of default headers plus pszOurExtraHeaders.

    NOTES:      The point of having this in a global helper function is
                so we don't have to duplicate this code in multiple
                implementations of IBindStatusCallback.

                The caller must free *ppwzCombinedHeaders by passing
                to URLMON, or calling OleFree

********************************************************************/
HRESULT BuildAdditionalHeaders(LPCTSTR pszOurExtraHeaders,LPCWSTR * ppwzCombinedHeadersOut)
{

    TCHAR   szLanguage[80];   // what limit on language?
    DWORD   dwLanguage = ARRAYSIZE(szLanguage);
    static const TCHAR hdr_language[] = HDR_LANGUAGE_CRLF;
    TCHAR szHeader[ARRAYSIZE(hdr_language) + ARRAYSIZE(szLanguage)]; // NOTE format string length > wnsprintf length
    int cchHeaders = 0;
    int cchAddedHeaders = 1;  // implied '\0'
    HRESULT hres = NOERROR;

    if (!ppwzCombinedHeadersOut)
        return E_FAIL;

    *ppwzCombinedHeadersOut = NULL;

    // If there is no language in the registry, *WE DO NOT SEND THIS HEADER*

    // S_OK means szLanguage filled in and returned
    // S_FALSE means call succeeded, but there was no language set
    // E_* is an error
    // We treat S_FALSE and E_* the same, no language header sent.
    if (GetAcceptLanguages(szLanguage, &dwLanguage) == S_OK)
    {
        wnsprintf(szHeader, ARRAYSIZE(szHeader), hdr_language, szLanguage);
        cchHeaders = lstrlen(szHeader) + 1;
    }

    if (pszOurExtraHeaders)
    {
        cchAddedHeaders = lstrlen(pszOurExtraHeaders) + 1;
    }

    // If we have headers we added or were sent in, we need to Wide 'em and
    // give 'em back
    if (cchAddedHeaders > 1 || cchHeaders > 0)
    {
        WCHAR *pwzHeadersForUrlmon = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR) * (cchHeaders  + cchAddedHeaders - 1));
        if (pwzHeadersForUrlmon)
        {
            if (cchHeaders)
            {
                StrCpyN(pwzHeadersForUrlmon, szHeader, cchHeaders);
            }
            if (pszOurExtraHeaders)
            {
                if (cchHeaders)
                {
                    StrCpyN(pwzHeadersForUrlmon + cchHeaders - 1,
                            pszOurExtraHeaders, cchAddedHeaders);
                }
                else
                {
                    StrCpyN(pwzHeadersForUrlmon, pszOurExtraHeaders, cchAddedHeaders - 1);
                }
            }
            if (cchHeaders || pszOurExtraHeaders)
                *ppwzCombinedHeadersOut = pwzHeadersForUrlmon;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    else
        hres = pszOurExtraHeaders == NULL ? S_OK : E_FAIL;

    return hres;
}

/*******************************************************************

    NAME:       GetHeadersAndPostData

    SYNOPSIS:   Gets HTTP headers and post data from an IBindStatusCallback

    ENTRY:      IBindStatusCallback - object to ask for headers and post data
                ppszHeaders - on exit, filled in with pointer to headers,
                    or NULL if none
                pstgPostData - pointer to a STGMEDIUM to be filled in with post
                    data, if any.


    NOTES:      The caller is responsible for:
                    - calling LocalFree on *ppszHeaders when done with them
                    - calling ReleaseStgMedium on pstgPostData when done
                      with it

********************************************************************/
HRESULT GetHeadersAndPostData(IBindStatusCallback * pBindStatusCallback,
    LPTSTR * ppszHeaders, STGMEDIUM * pstgPostData, DWORD * pdwPostData, BOOL* pfIsPost)
{
    HRESULT hr = S_OK;

    ASSERT(pBindStatusCallback);
    ASSERT(ppszHeaders);
    ASSERT(pstgPostData);
    ASSERT(pdwPostData);

    // clear the out parameters
    *ppszHeaders = NULL;

    DWORD grfBINDF;
    IHttpNegotiate *pinegotiate;
    BINDINFO binfo;
    binfo.cbSize = sizeof(binfo);
    ZeroMemory(pstgPostData,sizeof(*pstgPostData));
    *pdwPostData = 0;

    hr=pBindStatusCallback->GetBindInfo(&grfBINDF, &binfo);

    if (SUCCEEDED(hr)) {
        // copy STGMEDIUM with post data to caller
        *pstgPostData = binfo.stgmedData;
        *pdwPostData = binfo.cbstgmedData;

        // clear these so ReleaseBindInfo won't wack it since we are giving it to the caller
        ZeroMemory(&binfo.stgmedData, sizeof(STGMEDIUM));
        binfo.cbstgmedData = 0;

        if (pfIsPost)
        {
            if(*pdwPostData)
                *pfIsPost = TRUE;
            else
                *pfIsPost = FALSE;
        }
 
        hr = pBindStatusCallback->QueryInterface(IID_IHttpNegotiate, (LPVOID *)&pinegotiate);
        if (SUCCEEDED(hr))
        {
            WCHAR *pwzAdditionalHeaders = NULL;
            WCHAR wzNull[1];

            wzNull[0] = 0;
            hr=pinegotiate->BeginningTransaction(wzNull, wzNull, 0, &pwzAdditionalHeaders);
            if (SUCCEEDED(hr) && pwzAdditionalHeaders)
            {
                DWORD cchHeaders;

                cchHeaders = lstrlen(pwzAdditionalHeaders) + 1;

                //  they should *NEVER* be specifying more than a few hundred
                //  bytes or they're going to fail with a number of HTTP servers!

                LPTSTR pszHeaders = (TCHAR *)LocalAlloc(LPTR, cchHeaders*sizeof(TCHAR));
                if (pszHeaders)
                {
                    LPTSTR pszNext;
                    LPTSTR pszLine;
                    LPTSTR pszLast;

                    StrCpyN(pszHeaders, pwzAdditionalHeaders, cchHeaders);
                    pszLine = pszHeaders;
                    pszLast = pszHeaders + lstrlen(pszHeaders);
                    while (pszLine < pszLast)
                    {
                        pszNext = StrStrI(pszLine, CRLF);
                        if (pszNext == NULL)
                        {
                            // All Headers must be terminated in CRLF!
                            pszLine[0] = '\0';
                            break;
                        }
                        pszNext += 2;
                        if (!StrCmpNI(pszLine,HDR_LANGUAGE,16))
                        {
                            MoveMemory(pszLine, pszNext, ((pszLast - pszNext) + 1)*sizeof(TCHAR));
                            break;
                        }
                        pszLine = pszNext;
                    }
                    // Don't include empty headers
                    if (pszHeaders[0] == '\0')
                    {
                        LocalFree(pszHeaders);
                        pszHeaders = NULL;
                    }
                }
                OleFree(pwzAdditionalHeaders);
                *ppszHeaders = pszHeaders;
            }
            pinegotiate->Release();
        }

        ReleaseBindInfo(&binfo);
    }

    return hr;
}

/*******************************************************************

    NAME:       GetTopLevelBindStatusCallback

    ENTRY:      psp - IServiceProvider of ShellBrowser container to query
                ppBindStatusCallback - if successful, filled in with
                   an IBindStatusCallback on exit

    SYNOPSIS:   Gets the IBindStatusCallback associated with this top
                level browser.  This works from within nested frames.

********************************************************************/
HRESULT GetTopLevelBindStatusCallback(IServiceProvider * psp,
    IBindStatusCallback ** ppBindStatusCallback)
{
    IHlinkFrame *phf;
    HRESULT hr = psp->QueryService(SID_SHlinkFrame, IID_PPV_ARG(IHlinkFrame, &phf));
    if (SUCCEEDED(hr)) 
    {
        hr = IUnknown_QueryService(phf, IID_IHlinkFrame, IID_PPV_ARG(IBindStatusCallback, ppBindStatusCallback));
        phf->Release();
    }

    return hr;
}

/*******************************************************************

    NAME:       GetTopLevelPendingBindStatusCallback

    ENTRY:      psp - IServiceProvider of ShellBrowser container to query
                ppBindStatusCallback - if successful, filled in with
                   an IBindStatusCallback on exit

    SYNOPSIS:   Gets the IBindStatusCallback associated with this top
                level browser.  This works from within nested frames.

********************************************************************/
HRESULT GetTopLevelPendingBindStatusCallback(IServiceProvider * psp,
    IBindStatusCallback ** ppBindStatusCallback)
{
    IHlinkFrame *phf;
    HRESULT hr = psp->QueryService(SID_SHlinkFrame, IID_PPV_ARG(IHlinkFrame, &phf));
    if (SUCCEEDED(hr)) 
    {
        hr = IUnknown_QueryService(phf, SID_PendingBindStatusCallback, IID_PPV_ARG(IBindStatusCallback, ppBindStatusCallback));
        phf->Release();
    }

    return hr;
}

// Global helper function to create a CStubBindStatusCallback
HRESULT CStubBindStatusCallback_Create(LPCWSTR pwzHeaders, LPCBYTE pPostData,
    DWORD cbPostData, VARIANT_BOOL bFrameIsOffline, VARIANT_BOOL bFrameIsSilent, BOOL bHyperlink, 
    DWORD grBindFlags,
    CStubBindStatusCallback ** ppBindStatusCallback)
{
    ASSERT(ppBindStatusCallback);

    *ppBindStatusCallback = new CStubBindStatusCallback(pwzHeaders,pPostData,
        cbPostData, bFrameIsOffline, bFrameIsSilent, bHyperlink, grBindFlags);

    return (*ppBindStatusCallback ? S_OK : E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\bindcb.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _BINDCB_H_

// the CStubBindStatusCallback implements IBindStatusCallback and
// IHttpNegotiate.  We use it to make a "fake" bind status callback
// object when we have headers and post data we would like to apply
// to a navigation.  We supply this IBindStatusCallback object, and
// the URL moniker asks us for headers and post data and use those in
// the transaction.

class CStubBindStatusCallback : public IBindStatusCallback,
                                       IHttpNegotiate,
                                       IMarshal
{
private:
    UINT      _cRef;         // ref count on this COM object
    LPCTSTR    _pszHeaders;  // headers to use
    HGLOBAL   _hszPostData;  // post data to use
    DWORD     _cbPostData;   // size of post data
    BOOL      _bFrameIsOffline : 1; // Indicates if Offline property is set
    BOOL      _bFrameIsSilent : 1;  // Indicates if Silent property is set
    BOOL      _bHyperlink : 1;  // This is a hyperlink or top level request
    DWORD     _grBindFlags; //  optional additional bindinfo flags

public:
    CStubBindStatusCallback(LPCWSTR pwzHeaders,LPCBYTE pPostData,DWORD cbPostData,
                            VARIANT_BOOL bFrameIsOffline, VARIANT_BOOL bFrameIsSilent, BOOL bHyperlink, DWORD grBindFlags);
    ~CStubBindStatusCallback();

    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBindStatusCallback ***
    virtual STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);

    virtual STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);

    virtual STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);

    virtual STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    virtual STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);

    virtual STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);

    virtual STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);

    virtual STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);

    /* *** IHttpNegotiate ***  */
    virtual STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR __RPC_FAR *pszAdditionalHeaders);

    virtual STDMETHODIMP OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
            LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders);

    // IMarshal methods
                    
    STDMETHODIMP GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid);
    STDMETHODIMP GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize);
    STDMETHODIMP MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags);
    STDMETHODIMP UnmarshalInterface(IStream *pistm,REFIID riid,void ** ppvObj);
    STDMETHODIMP ReleaseMarshalData(IStream *pStm);
    STDMETHODIMP DisconnectObject(DWORD dwReserved);

    // helper methods
    STDMETHODIMP _FreeHeadersAndPostData();
    BOOL _CanMarshalIID(REFIID riid);
    HRESULT _ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags);

};

// :
// private flags between shdocvw and mshtml
// -> should be done via bind context
//
#define BINDF_INLINESGETNEWESTVERSION   0x10000000
#define BINDF_INLINESRESYNCHRONIZE      0x20000000
#define BINDF_CONTAINER_NOWRITECACHE    0x40000000


// global helper functions
BOOL fOnProxy();
HRESULT BuildBindInfo(DWORD *grfBINDF,BINDINFO *pbindinfo,HGLOBAL hszPostData,
    DWORD cbPostData, BOOL bFrameIsOffline, BOOL bFrameIsSilent, BOOL bHyperlink, LPUNKNOWN pUnkForRelease);
HRESULT BuildAdditionalHeaders(LPCTSTR pszOurExtraHeaders,LPCWSTR * ppwzCombinedHeadersOut);
HRESULT CStubBindStatusCallback_Create(LPCWSTR pwzHeaders, LPCBYTE pPostData,
    DWORD cbPostData, VARIANT_BOOL bFrameIsOffline, VARIANT_BOOL bFrameIsSilent,BOOL bHyperlink,
    DWORD grBindFlags,
    CStubBindStatusCallback ** ppBindStatusCallback);
HRESULT GetHeadersAndPostData(IBindStatusCallback * pBindStatusCallback,
    LPTSTR * ppszHeaders, STGMEDIUM * pstgPostData, DWORD * pdwPostData, BOOL * pfUseCache);
HRESULT GetTopLevelBindStatusCallback(IServiceProvider * psp,
    IBindStatusCallback ** ppBindStatusCallback);
HRESULT GetTopLevelPendingBindStatusCallback(IServiceProvider * psp,
    IBindStatusCallback ** ppBindStatusCallback);

#endif // _BINDCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\bcw.cpp ===
/****************************************************************************
bcw.cpp

  Owner: Srinik
  Copyright (c) 1995 Microsoft Corporation
  
    This file contains code for BCW class which implements wrappers for IBindCtx
    and IRunningObjectTable. We use this object to trick the moniker binding
    code to create a new instance of the object (that the moniker is
    referring to) instead connecting to already running instance.
****************************************************************************/

// #include "hlmain.h"
#include "bcw.h"

ASSERTDATA

/****************************************************************************
Implementation of BCW methods.
****************************************************************************/

BCW::BCW(IBindCtx * pibc)
{
    m_pibc = pibc;
    pibc->AddRef();
    m_cObjRef = 1;
    DllAddRef();
}

BCW::~BCW()
{
    m_pibc->Release();
    DllRelease();
}

IBindCtx * BCW::Create(IBindCtx * pibc)
{
    BCW * pbcw = new BCW(pibc);
    
    if (pbcw == NULL)
        return NULL;
    
    if (! pbcw->m_ROT.FInitROTPointer())
    {
        delete pbcw;
        return NULL;
    }
    
    return pbcw;
}

STDMETHODIMP BCW::QueryInterface(REFIID riid, void **ppvObj)
{   
    if (ppvObj == NULL)
        return E_INVALIDARG;
    
    if (riid == IID_IUnknown || riid == IID_IBindCtx)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    ((IUnknown *) *ppvObj)->AddRef();
    return NOERROR; 
}

STDMETHODIMP_(ULONG) BCW::AddRef(void)
{   
    return ++m_cObjRef;
}


STDMETHODIMP_(ULONG) BCW::Release(void)
{
/* Decrement refcount, destroy object if refcount goes to zero.
    Return the new refcount. */
    if (!(--m_cObjRef))
    {
        delete this;
        return 0;
    }
    
    return m_cObjRef;
}


/****************************************************************************
Implementation of BCW_ROT methods.
****************************************************************************/

/****************************************************************************
BCW_ROT is the IRunningObjectTable imlementation of BCW_ROT.
****************************************************************************/

BCW_ROT::BCW_ROT()
{
    Debug(m_cRef = 0);
    m_piROT = NULL; 
}

BCW_ROT::~BCW_ROT()
{   
    if (m_piROT)
        m_piROT->Release();
}

BOOL_PTR BCW_ROT::FInitROTPointer(void)
{
    if (m_piROT == NULL)
    {
        if (GetRunningObjectTable(NULL/*reserved*/, &m_piROT) == NOERROR)
            m_piROT->AddRef();
    }
    
    return (BOOL_PTR) (m_piROT);
}


inline BCW * BCW_ROT::PBCW()
{
    return BACK_POINTER(this, m_ROT, BCW);
}

STDMETHODIMP BCW_ROT::QueryInterface(REFIID riid, void **ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IRunningObjectTable)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    ((IUnknown *) *ppvObj)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) BCW_ROT::AddRef(void)
{
    return PBCW()->AddRef();
}

STDMETHODIMP_(ULONG) BCW_ROT::Release(void)
{
    return PBCW()->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\basesb.cpp ===
#include "priv.h"

#include <mluisupp.h>

// stuff that should be turned off while in here, but on when 
// it goes to commonsb or shbrows2.cpp
#define IN_BASESB2

#ifdef IN_BASESB2
#define _fFullScreen FALSE
#endif

#include "sccls.h"

#include <idhidden.h>
#include "basesb.h"
#include "iedde.h"
#include "bindcb.h"
#include "resource.h"
#include "security.h"
#include <urlmon.h>
#include "favorite.h"
#include "uemapp.h"
#include <varutil.h>
#include "interned.h" // IHTMLPrivateWindow
#ifdef FEATURE_PICS
#include <ratings.h>
#include <ratingsp.h>
#endif
#include "msiehost.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#include "dhuihand.h"
#include "mypics.h"
#include "airesize.h"

#define DM_ACCELERATOR      0
#define DM_WEBCHECKDRT      0
#define DM_COCREATEHTML     0
#define DM_CACHEOLESERVER   0
#define DM_DOCCP            0
#define DM_PICS             0
#define DM_SSL              0
#define DM_MISC             DM_TRACE    // misc/tmp

// get at defs to run a privacy dialog box
#include "privacyui.hpp"

//
//  Remove this #include by defining _bbd._pauto as IWebBrowserApp, just like
//  Explorer.exe.
//
#include "hlframe.h"

extern IUnknown* ClassHolder_Create(const CLSID* pclsid);
extern HRESULT VariantClearLazy(VARIANTARG *pvarg);


#define WMC_ASYNCOPERATION      (WMC_RESERVED_FIRST + 0x0000)

#define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

#define IDT_STARTING_APP_TIMER  9001        // trying to pick a unique number... (THIS IS BOGUS! FIX THIS!)
#define STARTING_APP_DURATION   2500

UINT g_uMsgFileOpened = (UINT)-1;         // Registered window message for file opens

// _uActionQueued of WMC_ACYNCOPERATION specifies the operation.
#define ASYNCOP_NIL                 0
#define ASYNCOP_GOTO                1
#define ASYNCOP_ACTIVATEPENDING     2
#define ASYNCOP_CANCELNAVIGATION    3

void IEInitializeClassFactoryObject(IUnknown* punkAuto);
BOOL ParseRefreshContent(LPWSTR pwzContent,
    UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf);

#define VALIDATEPENDINGSTATE() ASSERT((_bbd._psvPending && _bbd._psfPending) || (!_bbd._psvPending && !_bbd._psfPending))

#define DM_HTTPEQUIV        TF_SHDNAVIGATE
#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            DM_TRACE
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   TF_SHDNAVIGATE
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0
#define DM_PERSIST          0       // trace IPS::Load, ::Save, etc.
#define DM_VIEWSTREAM       DM_TRACE
#define DM_FOCUS            0
#define DM_FOCUS2           0           // like DM_FOCUS, but verbose

// these two MUST be in order because we peek them together

STDAPI SafeGetItemObject(IShellView *psv, UINT uItem, REFIID riid, void **ppv);
extern HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);
HRESULT CreateTravelLog(ITravelLog **pptl);
HRESULT CreatePublicTravelLog(IBrowserService *pbs, ITravelLogEx *ptlx, ITravelLogStg **pptlstg);

#ifdef MESSAGEFILTER
/*
 * CMsgFilter - implementation of IMessageFilter
 *
 * Used to help distribute WM_TIMER messages during OLE operations when 
 * we are busy.  If we don't install the CoRegisterMessageFilter
 * then OLE can PeekMessage(PM_NOREMOVE) the timers such that they pile up
 * and fill the message queue.
 *
 */
class CMsgFilter : public IMessageFilter {
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)
    {
        // This interface doesn't get QI'ed.
        ASSERT(FALSE);
        return E_NOINTERFACE;
    };
    STDMETHODIMP_(ULONG) AddRef(void)    {   return ++_cRef; };
    STDMETHODIMP_(ULONG) Release(void)   {   ASSERT(_cRef > 0);
                                                _cRef--;
                                                if (_cRef > 0)
                                                    return _cRef;

                                                delete this;
                                                return 0;
                                            };

    // *** IMessageFilter specific methods ***
    STDMETHODIMP_(DWORD) HandleInComingCall(
        IN DWORD dwCallType,
        IN HTASK htaskCaller,
        IN DWORD dwTickCount,
        IN LPINTERFACEINFO lpInterfaceInfo)
    {
        if (_lpMFOld)
           return (_lpMFOld->HandleInComingCall(dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo));
        else
           return SERVERCALL_ISHANDLED;
    };

    STDMETHODIMP_(DWORD) RetryRejectedCall(
        IN HTASK htaskCallee,
        IN DWORD dwTickCount,
        IN DWORD dwRejectType)
    {
        if (_lpMFOld)
            return (_lpMFOld->RetryRejectedCall(htaskCallee, dwTickCount, dwRejectType));
        else
            return 0xffffffff;
    };

    STDMETHODIMP_(DWORD) MessagePending(
        IN HTASK htaskCallee,
        IN DWORD dwTickCount,
        IN DWORD dwPendingType)
    {
        DWORD dw;
        MSG msg;

        // We can get released during the DispatchMessage call...
        // If it's our last release, we'll free ourselves and
        // fault when we dereference _lpMFOld... Make sure this
        // doesn't happen by increasing our refcount.
        //
        AddRef();

        while (PeekMessage(&msg, NULL, WM_TIMER, WM_TIMER, PM_REMOVE))
        {
#ifndef DISPATCH_IETIMERS
            TCHAR szClassName[40];
                
            GetClassName(msg.hwnd, szClassName, ARRAYSIZE(szClassName));


            if (StrCmpI(szClassName, TEXT("Internet Explorer_Hidden")) != 0)
            {
#endif
                DispatchMessage(&msg);
#ifndef DISPATCH_IETIMERS
            }
#endif
        }

        if (_lpMFOld)
            dw = (_lpMFOld->MessagePending(htaskCallee, dwTickCount, dwPendingType));
        else
            dw = PENDINGMSG_WAITDEFPROCESS;

        Release();

        return(dw);
    };

    CMsgFilter() : _cRef(1)
    {
        ASSERT(_lpMFOld == NULL);
    };

    BOOL Initialize()
    {
        return (CoRegisterMessageFilter((LPMESSAGEFILTER)this, &_lpMFOld) != S_FALSE);
    };

    void UnInitialize()
    {
        CoRegisterMessageFilter(_lpMFOld, NULL);

        // we shouldn't ever get called again, but after 30 minutes
        // of automation driving we once hit a function call above
        // and we dereferenced this old pointer and page faulted.

        ATOMICRELEASE(_lpMFOld);
    };

protected:
    int _cRef;
    LPMESSAGEFILTER _lpMFOld;
};
#endif

//--------------------------------------------------------------------------
// Detecting a memory leak
//--------------------------------------------------------------------------

HRESULT GetTopFrameOptions(IServiceProvider * psp, DWORD * pdwOptions)
{
    IServiceProvider * pspTop;
    HRESULT hres = psp->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &pspTop));
    if (SUCCEEDED(hres))
    {
        ITargetFrame2 *ptgf;
        hres = pspTop->QueryService(SID_SContainerDispatch, IID_PPV_ARG(ITargetFrame2, &ptgf));
        if (SUCCEEDED(hres))
        {
            hres = ptgf->GetFrameOptions(pdwOptions);
            ptgf->Release();
        }
        pspTop->Release();
    }

    return hres;
}

void UpdateDesktopComponentName(LPCWSTR lpcwszURL, LPCWSTR lpcwszName)
{
    IActiveDesktop * piad;

    if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ActiveDesktop, NULL, IID_PPV_ARG(IActiveDesktop, &piad))))
    {
        COMPONENT comp;
        comp.dwSize = SIZEOF(comp);

        if (SUCCEEDED(piad->GetDesktopItemBySource(lpcwszURL, &comp, 0)) && !comp.wszFriendlyName[0])
        {
            StrCpyNW(comp.wszFriendlyName, lpcwszName, ARRAYSIZE(comp.wszFriendlyName));
            piad->ModifyDesktopItem(&comp, COMP_ELEM_FRIENDLYNAME);
            piad->ApplyChanges(AD_APPLY_SAVE);
        }
        piad->Release();
    }
}

HRESULT CBaseBrowser2::_Initialize(HWND hwnd, IUnknown* pauto)
{
    if (pauto)
    {
        pauto->AddRef();
    }
    else
    {
        CIEFrameAuto_CreateInstance(NULL, &pauto);
    }

    // Grab _pauto interfaces we use throughout this code.
    //
    if (pauto)
    {
        pauto->QueryInterface(IID_PPV_ARG(IWebBrowser2, &_bbd._pautoWB2));
        ASSERT(_bbd._pautoWB2);

        pauto->QueryInterface(IID_PPV_ARG(IExpDispSupport, &_bbd._pautoEDS));
        ASSERT(_bbd._pautoEDS);

        pauto->QueryInterface(IID_PPV_ARG(IShellService, &_bbd._pautoSS));
        ASSERT(_bbd._pautoSS);

        pauto->QueryInterface(IID_PPV_ARG(ITargetFrame2, &_ptfrm));
        ASSERT(_ptfrm);

        pauto->QueryInterface(IID_PPV_ARG(IHlinkFrame, &_bbd._phlf));
        ASSERT(_bbd._phlf);

        IHTMLWindow2 *pWindow;
        if( SUCCEEDED(GetWindowFromUnknown( pauto, &pWindow )) )
        {
            pWindow->QueryInterface( IID_IShellHTMLWindowSupport, (void**)&_phtmlWS );
            pWindow->Release( );
        }
        ASSERT( _phtmlWS );

        _pauto = pauto;
    }

    //  _psbOuter?
    if (NULL == _bbd._phlf)
    {
        Release();
        return E_FAIL;
    }
    else
    {
        _SetWindow(hwnd);
        return S_OK;
    }
}


HRESULT CBaseBrowser2::InitializeTransitionSite()
{
    return S_OK;
}


HRESULT CBaseBrowser2_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CBaseBrowser2 *pbb = new CBaseBrowser2(pUnkOuter);
    if (pbb)
    {
        *ppunk = pbb->_GetInner();
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

CBaseBrowser2::CBaseBrowser2(IUnknown* punkAgg) :
       CAggregatedUnknown(punkAgg),
        _bptBrowser(BPT_DeferPaletteSupport)
{
    TraceMsg(TF_SHDLIFE, "ctor CBaseBrowser2 %x", this);

    _bbd._uActivateState = SVUIA_ACTIVATE_FOCUS;
    _InitComCtl32();

    ASSERT(S_FALSE == _DisableModeless());
    ASSERT(_cp == CP_ACP);
    ASSERT(!_fNoTopLevelBrowser);
    ASSERT(!_dwDocFlags);

    _QueryOuterInterface(IID_PPV_ARG(IBrowserService2, &_pbsOuter));
    _QueryOuterInterface(IID_PPV_ARG(IBrowserService3, &_pbsOuter3));
    _QueryOuterInterface(IID_PPV_ARG(IShellBrowser, &_psbOuter));
    _QueryOuterInterface(IID_PPV_ARG(IServiceProvider, &_pspOuter));

    // The following are intercepted by CCommonBrowser, but we don't call 'em
    //_QueryOuterInterface(IID_PPV_ARG(IOleCommandTarget, &_pctOuter));
    //_QueryOuterInterface(IID_PPV_ARG(IInputObjectSite, &_piosOuter));

    _dwStartingAppTick = 0;
}


HRESULT CBaseBrowser2_Validate(HWND hwnd, void **ppsb)
{
    CBaseBrowser2* psb = *(CBaseBrowser2**)ppsb;    // split: bogus!!!

    if (psb)
    {
        if (NULL == psb->_bbd._phlf)
        {
            ATOMICRELEASE(psb);
        }
        else
        {
            psb->_SetWindow(hwnd);
        }
    }

    *ppsb = psb;        // split: bogus!!!

    return (psb) ? S_OK : E_OUTOFMEMORY;
}

CBaseBrowser2::~CBaseBrowser2()
{
    TraceMsg(TF_SHDLIFE, "dtor CBaseBrowser2 %x", this);

    // Are we releasing these too early (i.e. does anything in the
    // rest of this func rely on having the 'vtables' still be valid?)
    RELEASEOUTERINTERFACE(_pbsOuter);
    RELEASEOUTERINTERFACE(_pbsOuter3);
    RELEASEOUTERINTERFACE(_psbOuter);
    RELEASEOUTERINTERFACE(_pspOuter);

    // The following are intercepted by CCommonBrowser, but we don't call 'em
    //RELEASEOUTERINTERFACE(_pctOuter);
    //RELEASEOUTERINTERFACE(_piosOuter);
    
    ASSERT(_hdpaDLM == NULL);    // subclass must free it.

#if 0 // split: here for context (ordering)
    _CloseAndReleaseToolbars(FALSE);

    FDSA_Destroy(&_fdsaTBar);
#endif

    // finish tracking here
    if (_ptracking) 
    {
        delete _ptracking;
        _ptracking = NULL;
    }

    //
    // Notes: Unlike IE3.0, we release CIEFrameAuto pointers here.
    //
    ATOMICRELEASE(_bbd._pautoWB2);
    ATOMICRELEASE(_bbd._pautoEDS);
    ATOMICRELEASE(_bbd._pautoSS);
    ATOMICRELEASE(_phtmlWS);
    ATOMICRELEASE(_bbd._phlf);
    ATOMICRELEASE(_ptfrm);
    ATOMICRELEASE(_pauto);
    
    ATOMICRELEASE(_punkSFHistory);

    // clean up our palette by simulating a switch out of palettized mode
    _bptBrowser = BPT_NotPalettized;
    _QueryNewPalette();

    ASSERT(!_bbd._phlf);
    ASSERT(!_ptfrm);
    ASSERT(S_FALSE == _DisableModeless());
    ASSERT(_bbd._hwnd==NULL);

    ATOMICRELEASE(_pact);

    ATOMICRELEASE(_pIUrlHistoryStg);
    ATOMICRELEASE(_pITravelLogStg);
    ATOMICRELEASE(_poleHistory);
    ATOMICRELEASE(_pstmHistory);
    ATOMICRELEASE(_bbd._ptl);

    ATOMICRELEASE(_pHTMLDocument);
    ATOMICRELEASE(_pphHistory);
    ATOMICRELEASE(_pDispViewLinkedWebOCFrame);

#ifdef MESSAGEFILTER
    if (_lpMF) 
    {
        IMessageFilter* lpMF = _lpMF;
        _lpMF = NULL;
        ((CMsgFilter *)lpMF)->UnInitialize();
        EVAL(lpMF->Release() == 0);
    }
#endif

    // This is created during FileCabinet_CreateViewWindow2
    CShellViews_Delete(&_fldBase._cViews);

    // If the class factory object has been cached, unlock it and release.
    if (_pcfHTML) 
    {
        _pcfHTML->LockServer(FALSE);
        _pcfHTML->Release();
    }

    ATOMICRELEASE(_pToolbarExt);
}

HRESULT CBaseBrowser2::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBaseBrowser2, IShellBrowser),         // IID_IShellBrowser
        QITABENTMULTI(CBaseBrowser2, IOleWindow, IShellBrowser), // IID_IOleWindow
        QITABENT(CBaseBrowser2, IOleInPlaceUIWindow),   // IID_IOleInPlaceUIWindow
        QITABENT(CBaseBrowser2, IOleCommandTarget),     // IID_IOleCommandTarget
        QITABENT(CBaseBrowser2, IDropTarget),           // IID_IDropTarget
        QITABENTMULTI(CBaseBrowser2, IBrowserService, IBrowserService3), // IID_IBrowserService
        QITABENTMULTI(CBaseBrowser2, IBrowserService2, IBrowserService3), // IID_IBrowserService2
        QITABENT(CBaseBrowser2, IBrowserService3),      // IID_IBrowserService3
        QITABENT(CBaseBrowser2, IServiceProvider),      // IID_IServiceProvider
        QITABENT(CBaseBrowser2, IOleContainer),         // IID_IOleContainer
        QITABENT(CBaseBrowser2, IAdviseSink),           // IID_IAdviseSink
        QITABENT(CBaseBrowser2, IInputObjectSite),      // IID_IInputObjectSite
        QITABENT(CBaseBrowser2, IDocNavigate),          // IID_IDocNavigate
        QITABENT(CBaseBrowser2, IPersistHistory),       // IID_IPersistHistory
        QITABENT(CBaseBrowser2, IInternetSecurityMgrSite), // IID_IInternetSecurityMgrSite
        QITABENT(CBaseBrowser2, IVersionHost),          // IID_IVersionHost
        QITABENT(CBaseBrowser2, IProfferService),       // IID_IProfferService
        QITABENT(CBaseBrowser2, ITravelLogClient),      // IID_ITravelLogClient
        QITABENT(CBaseBrowser2, ITravelLogClient2),     // IID_ITravelLogClient2
        QITABENTMULTI(CBaseBrowser2, ITridentService, ITridentService2), // IID_ITridentService
        QITABENT(CBaseBrowser2, ITridentService2),      // IID_ITridentService2
        QITABENT(CBaseBrowser2, IInitViewLinkedWebOC),  // IID_IInitViewLinkedWebOC
        QITABENT(CBaseBrowser2, INotifyAppStart),       // IID_INotifyAppStart
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

BOOL CBaseBrowser2::_IsViewMSHTML(IShellView * psv)
{
    BOOL fIsMSHTML = FALSE;
    
    if (psv)
    {
        IPersist *pPersist = NULL;
        HRESULT hres = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersist, &pPersist));
        if (SUCCEEDED(hres) && (pPersist != NULL))
        {
            CLSID clsid;
            hres = pPersist->GetClassID(&clsid);
            if (SUCCEEDED(hres) && IsEqualGUID(clsid, CLSID_HTMLDocument))
                fIsMSHTML = TRUE;
            pPersist->Release();
        }
    }
    return fIsMSHTML;
}

HRESULT CBaseBrowser2::ReleaseShellView()
{
    //  We're seeing some reentrancy here.  If _cRefUIActivateSV is non-zero, it means we're
    //  in the middle of UIActivating the shell view.
    //
    if (_cRefUIActivateSV)
    {
        TraceMsg(TF_WARNING, 
            "CBB(%x)::ReleaseShellView _cRefUIActivateSV(%d)!=0  _bbd._psv=%x ABORTING", 
            this, _cRefUIActivateSV, _bbd._psv);
        return S_OK;
    }
    
    BOOL fViewObjectChanged = FALSE;

    VALIDATEPENDINGSTATE();

    TraceMsg(DM_NAV, "CBaseBrowser2(%x)::ReleaseShellView(%x)", this, _bbd._psv);

    ATOMICRELEASE(_pdtView);

    if (_bbd._psv) 
    {
        //  Disable navigation while we are UIDeactivating/DestroyWindowing
        // the IShellView. Some OC/DocObject in it (such as ActiveMovie)
        // might have a message loop long enough to cause some reentrancy.

        _psbOuter->EnableModelessSB(FALSE);

        // Tell the shell's HTML window we are releasing the document.
        if (_phtmlWS)
        {
            _phtmlWS->ViewReleased();
        }

        //
        //  We need to cancel the menu mode so that unmerging menu won't
        // destroy the menu we are dealing with (which caused GPF in USER).
        // DocObject needs to do appropriate thing for context menus.
        // (02-03-96 SatoNa)
        //
        HWND hwndCapture = GetCapture();
        TraceMsg(DM_CANCELMODE, "ReleaseShellView hwndCapture=%x _bbd._hwnd=%x", hwndCapture, _bbd._hwnd);
        if (hwndCapture && hwndCapture==_bbd._hwnd) 
        {
            TraceMsg(DM_CANCELMODE, "ReleaseShellView Sending WM_CANCELMODE");
            SendMessage(_bbd._hwnd, WM_CANCELMODE, 0, 0);
        }

        //
        //  We don't want to resize the previous view window while we are
        // navigating away from it.
        //
        TraceMsg(TF_SHDUIACTIVATE, "CSB::ReleaseShellView setting _fDontResizeView");
        _fDontResizeView = TRUE;

        // If the current view is still waiting for ReadyStateComplete,
        // and the view we're swapping in here does not support this property,
        // then we'll never go to ReadyStateComplete! Simulate it here:
        //
        // NOTE: ZekeL put this in _CancelNavigation which happened way too often.
        // I think this is the case he was trying to fix, but I don't remember
        // the bug number so I don't have a specific repro...
        //
        
        if (!_bbd._fIsViewMSHTML)
        {
            _fReleasingShellView = TRUE;
            OnReadyStateChange(_bbd._psv, READYSTATE_COMPLETE);
            _fReleasingShellView = FALSE;
        }

        // At one point during a LOR stress test, we got re-entered during
        // this UIActivate call (some rogue 3rd-party IShellView perhaps?)
        // which caused _psv to get freed, and we faulted during the unwind.
        // Gaurd against this by swapping the _psv out early.
        //
        IShellView* psv = _bbd._psv;
        _bbd._psv = NULL;
        if (psv)
        {
            psv->UIActivate(SVUIA_DEACTIVATE);
            if (_cRefUIActivateSV)
            {
                TraceMsg(TF_WARNING, "CBB(%x)::ReleaseShellView setting _bbd._psv = NULL (was %x) while _cRefUIActivateSV=%d",
                    this, psv, _cRefUIActivateSV);
            }

            ATOMICRELEASE(_bbd._pctView);

            if (_pvo)
            {
                IAdviseSink *pSink;

                // paranoia: only blow away the advise sink if it is still us
                if (SUCCEEDED(_pvo->GetAdvise(NULL, NULL, &pSink)) && pSink)
                {
                    if (pSink == (IAdviseSink *)this)
                        _pvo->SetAdvise(0, 0, NULL);

                    pSink->Release();
                }

                fViewObjectChanged = TRUE;
                ATOMICRELEASE(_pvo);
            }
            
            psv->SaveViewState();
            TraceMsg(DM_NAV, "ief NAV::%s %x",TEXT("ReleaseShellView Calling DestroyViewWindow"), psv);
            psv->DestroyViewWindow();
    
            UINT cRef = psv->Release();
            TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("ReleaseShellView called psv->Release"), psv, cRef);

            _bbd._hwndView = NULL;
            TraceMsg(TF_SHDUIACTIVATE, "CSB::ReleaseShellView resetting _fDontResizeView");
            _fDontResizeView = FALSE;

            if (_bbd._pidlCur) 
            {
                ILFree(_bbd._pidlCur);
                _bbd._pidlCur = NULL;
            }
        }
        
        _psbOuter->EnableModelessSB(TRUE);

        //
        //  If there is any blocked async operation AND we can navigate now,
        // unblock it now. 
        //
        _MayUnblockAsyncOperation();
    }

    ATOMICRELEASE(_bbd._psf);

    if (fViewObjectChanged)
        _ViewChange(DVASPECT_CONTENT, -1);

    if (_bbd._pszTitleCur)
    {
        LocalFree(_bbd._pszTitleCur);
        _bbd._pszTitleCur = NULL;
    }

    // NOTES: (SatoNa)
    //
    //  This is the best time to clean up the left-over from UI-negotiation
    // from the previous DocObject. Excel 97, for some reason, takes 16
    // pixels from the top (for the formula bar) when we UI-deactivate it
    // by callin gIOleDocumentView::UIActivate(FALSE), which we call above.
    //
    SetRect(&_rcBorderDoc, 0, 0, 0, 0);
    return S_OK;
}

void CBaseBrowser2::_StopCurrentView()
{
    // send OLECMDID_STOP
    if (_bbd._pctView) // we must check!
    {
        _bbd._pctView->Exec(NULL, OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
    }
}

//
// This function synchronously cancels the pending navigation if any.
//
HRESULT CBaseBrowser2::_CancelPendingNavigation(BOOL fDontReleaseState)
{
    TraceMsg(TF_SHDNAVIGATE, "CBB::_CancelPendingNavigation called");
    
    _StopAsyncOperation();
    
    HRESULT hres = S_FALSE;

#ifndef NON_NATIVE_FRAMES

    if (_bbd._psvPending) 
    {
        if (_IsViewMSHTML(_bbd._psvPending))
        {
            VARIANT varStop;

            V_VT(&varStop)   = VT_BOOL;
            V_BOOL(&varStop) = VARIANT_TRUE;

            IUnknown_Exec(_bbd._psvPending, NULL, OLECMDID_STOP, 0, &varStop, NULL);
        }
        else
        {
            if (_bbd._phlf && !fDontReleaseState) 
            {
                 // release our state
                 _bbd._phlf->Navigate(0, NULL, NULL, NULL);
            }

            _CancelPendingView();
        }

        hres = S_OK;
    }

#else

    if (_bbd._psvPending) 
    {
        if (_bbd._phlf && !fDontReleaseState) 
        {
             // release our state
             _bbd._phlf->Navigate(0, NULL, NULL, NULL);
        }

        _CancelPendingView();
        hres = S_OK;
    }

#endif

    return hres;
}

void CBaseBrowser2::_SendAsyncNavigationMsg(VARIANTARG *pvarargIn)
{
    LPCWSTR psz = VariantToStrCast(pvarargIn);
    if (psz)
    {
        LPITEMIDLIST pidl;
        if (EVAL(SUCCEEDED(IECreateFromPathW(psz, &pidl))))
        {
            _NavigateToPidlAsync(pidl, 0); // takes ownership of pidl
        }
    }
}


//
// NOTES: It does not cancel the pending view.
//
void CBaseBrowser2::_StopAsyncOperation(void)
{
    // Don't remove posted WMC_ASYNCOPERATION message. PeekMesssage removes
    // messages for children! (SatoNa)
    _uActionQueued = ASYNCOP_NIL;

    // Remove the pidl in the queue (single depth)
    _FreeQueuedPidl(&_pidlQueued);
}

//
//  This function checks if we have any asynchronous operation AND
// we no longer need to postpone. In that case, we unblock it by
// posting a WMC_ASYNCOPERATION.
//
void CBaseBrowser2::_MayUnblockAsyncOperation(void)
{
    if (_uActionQueued!=ASYNCOP_NIL && _CanNavigate()) 
    {
        TraceMsg(TF_SHDNAVIGATE, "CBB::_MayUnblockAsyncOp posting WMC_ASYNCOPERATION");
        PostMessage(_bbd._hwnd, WMC_ASYNCOPERATION, 0, 0);
    }
}

BOOL CBaseBrowser2::_PostAsyncOperation(UINT uAction)
{
    _uActionQueued = uAction;
    return PostMessage(_bbd._hwnd, WMC_ASYNCOPERATION, 0, 0);
}

LRESULT CBaseBrowser2::_SendAsyncOperation(UINT uAction)
{
    _uActionQueued = uAction;
    return SendMessage(_bbd._hwnd, WMC_ASYNCOPERATION, 0, 0);
}

HRESULT CBaseBrowser2::_CancelPendingNavigationAsync(void)
{
    TraceMsg(TF_SHDNAVIGATE, "CBB::_CancelPendingNavigationAsync called");

    _StopAsyncOperation();
    _PostAsyncOperation(ASYNCOP_CANCELNAVIGATION);
    return S_OK;
}

HRESULT CBaseBrowser2::_CancelPendingView(void)
{
    if (_bbd._psvPending) 
    {
        TraceMsg(DM_NAV, "ief NAV::%s %x",TEXT("_CancelPendingView Calling DestroyViewWindow"), _bbd._psvPending);
        _bbd._psvPending->DestroyViewWindow();

        ASSERT(_bbd._psfPending);

        // When cancelling a pending navigation, make sure we
        // think the pending operation is _COMPLETE otherwise
        // we may get stuck in a _LOADING state...
        //
        TraceMsg(TF_SHDNAVIGATE, "basesb(%x) Fake pending ReadyState_Complete", this);
        OnReadyStateChange(_bbd._psvPending, READYSTATE_COMPLETE);

        ATOMICRELEASE(_bbd._psvPending);

        // Paranoia
        ATOMICRELEASE(_bbd._psfPending);
        
        _bbd._hwndViewPending = NULL;

        _setDescendentNavigate(NULL);

        SetNavigateState(BNS_NORMAL);

        if (_bbd._pidlPending) 
        {
            ILFree(_bbd._pidlPending);
            _bbd._pidlPending = NULL;
        }

        if (_bbd._pszTitlePending)
        {
            LocalFree(_bbd._pszTitlePending);
            _bbd._pszTitlePending = NULL;
        }

        // Pending navigation is canceled.
        // since the back button works as a stop on pending navigations, we
        // should check that here as well.
        _pbsOuter->UpdateBackForwardState();
        _NotifyCommandStateChange();

        _PauseOrResumeView(_fPausedByParent);
    }
    return S_OK;
}

void CBaseBrowser2::_UpdateTravelLog(BOOL fForceUpdate /* = FALSE */)
{
    //
    //  we update the travellog in two parts.  first we update
    //  the current entry with the current state info, 
    //  then we create a new empty entry.  UpdateEntry()
    //  and AddEntry() need to always be in pairs, with 
    //  identical parameters.
    //
    //  if this navigation came from a LoadHistory, the 
    //  _fDontAddTravelEntry will be set, and the update and 
    //  cursor movement will have been adjusted already.
    //  we also want to prevent new frames from updating 
    //  and adding stuff, so unless this is the top we
    //  wont add to the travellog if this is a new frame.
    //
    ASSERT(!(_grfHLNFPending & HLNF_CREATENOHISTORY));

    ITravelLog *ptl;
    GetTravelLog(&ptl);
    BOOL fTopFrameBrowser = IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *));
 
    if (ptl)
    {
        //  
        //  some times we are started by another app (MSWORD usually) that has HLink
        //  capability.  we detect this by noting that we are a new browser with an empty
        //  TravelLog, and then see if we can get a IHlinkBrowseContext.  if this is successful,
        //  we should add an entry and update it immediately with the external info.
        //
        IHlinkBrowseContext *phlbc = NULL;  // init to suppress bogus C4701 warning
        BOOL fExternalNavigate = (FAILED(ptl->GetTravelEntry(SAFECAST(this, IBrowserService *), 0, NULL)) &&
            fTopFrameBrowser && _bbd._phlf && SUCCEEDED(_bbd._phlf->GetBrowseContext(&phlbc)));

        if (fExternalNavigate)
        {
            ptl->AddEntry(SAFECAST(this, IBrowserService *), FALSE);
            ptl->UpdateExternal(SAFECAST(this, IBrowserService *), phlbc);
            phlbc->Release();
        }
        else if (_bbd._psv && (fForceUpdate || !_fIsLocalAnchor || (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)))
        {
            ptl->UpdateEntry(SAFECAST(this, IBrowserService *), _fIsLocalAnchor);  // CAST for IUnknown
        }

        if (!_fDontAddTravelEntry && (_bbd._psv || fTopFrameBrowser))
        {
            ptl->AddEntry(SAFECAST(this, IBrowserService *), _fIsLocalAnchor);  // CAST for IUnknown
        }

        ptl->Release();
    }

    _fDontAddTravelEntry  = FALSE;
    _fIsLocalAnchor       = FALSE;
}


void CBaseBrowser2::_OnNavigateComplete(LPCITEMIDLIST pidl, DWORD grfHLNF)
{
    _pbsOuter->UpdateBackForwardState();
}


//// Does only the top shbrowse need this?  or the top oc frame too?
HRESULT CBaseBrowser2::UpdateSecureLockIcon(int eSecureLock)
{
    // only the top boy should get to set his stuff
    if (!IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *)))
        return S_OK;

    if (eSecureLock != SECURELOCK_NOCHANGE)
        _bbd._eSecureLockIcon = eSecureLock;
    
    // 
    //  There is no mixed Security Icon - zekel 6-AUG-97
    //  right now we have no icon or TT for SECURELOCK_SET_MIXED, which 
    //  is set when the root page is secure but some of the other content
    //  or frames are not.  some PM needs to implement, probably 
    //  with consultation from TonyCi and DBau.  by default we currently
    //  only show for pages that are completely secure.
    //

    TraceMsg(DM_SSL, "CBB:UpdateSecureLockIcon() _bbd._eSecureLockIcon = %d", _bbd._eSecureLockIcon);

    //
    // It looks like it doesnt matter what icon we select here,
    // the status bar always shows some lock icon that was cached there earlier
    // and it treats this HICON as a bool to indicat on or off  - zekel - 5-DEC-97
    //

    HICON hicon = NULL;
    TCHAR szText[MAX_TOOLTIP_STRING];

    szText[0] = 0;

    switch (_bbd._eSecureLockIcon)
    {
    case SECURELOCK_SET_UNSECURE:
    case SECURELOCK_SET_MIXED:
        hicon = NULL;
        break;

    case SECURELOCK_SET_SECUREUNKNOWNBIT:
        hicon = g_hiconSSL;
        break;

    case SECURELOCK_SET_SECURE40BIT:
        hicon = g_hiconSSL;
        MLLoadString(IDS_SSL40, szText, ARRAYSIZE(szText));
        break;

    case SECURELOCK_SET_SECURE56BIT:
        hicon = g_hiconSSL;
        MLLoadString(IDS_SSL56, szText, ARRAYSIZE(szText));
        break;

    case SECURELOCK_SET_SECURE128BIT:
        hicon = g_hiconSSL;
        MLLoadString(IDS_SSL128, szText, ARRAYSIZE(szText));
        break;

    case SECURELOCK_SET_FORTEZZA:
        hicon = g_hiconFortezza;
        MLLoadString(IDS_SSL_FORTEZZA, szText, ARRAYSIZE(szText));
        break;

    default:
        ASSERT(0);
        return E_FAIL;
    }

    VARIANTARG var = {0};
    if (_bbd._pctView && SUCCEEDED(_bbd._pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_SSL, NULL, &var))
        && V_UI4(&var) != PANE_NONE)
    {
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETICON, V_UI4(&var), (LPARAM)(hicon), NULL);
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, V_UI4(&var), (LPARAM)(szText[0] ? szText : NULL), NULL);

        // Also add the tip text as the pane's normal text.  Because of the pane's size it will be clipped,
        // but it will show up as a useful string in MSAA.
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, V_UI4(&var), (LPARAM)(szText[0] ? szText : NULL), NULL);
    }    
    return S_OK;
}

//
// Update Privacy Icon
//
HRESULT CBaseBrowser2::_UpdatePrivacyIcon(BOOL fSetState, BOOL fNewImpacted)
{
    static BOOL fHelpShown = FALSE;

    //
    // only the top boy should get to set his stuff
    //
    if (!IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *)))
        return S_OK;

    //
    // save off the privacy state
    //
    if(fSetState)
    {
        _bbd._fPrivacyImpacted = fNewImpacted;
    }

    HICON hicon = NULL;
    TCHAR szText[MAX_TOOLTIP_STRING];

    szText[0] = 0;

    if(_bbd._fPrivacyImpacted)
    {
        hicon = g_hiconPrivacyImpact;
        MLLoadString(IDS_PRIVACY_TOOLTIP, szText, ARRAYSIZE(szText));
    }

    if (_bbd._pctView)
    {
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETICON, STATUS_PANE_PRIVACY, (LPARAM)(hicon), NULL);
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, STATUS_PANE_PRIVACY, (LPARAM)(szText[0] ? szText : NULL), NULL);

        // Also add the tip text as the panes normal text.  Because of the pane's size it will be clipped,
        // but it will show up as a useful string in MSAA.
        _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, STATUS_PANE_PRIVACY, (LPARAM)(szText[0] ? szText : NULL), NULL);
    }    

    // if impacted and never shown before, show bubble toolhelp
    if(FALSE == fHelpShown && _bbd._fPrivacyImpacted)
    {
        DWORD   dwValue, dwSize;

        // only do this work once
        fHelpShown = TRUE;

        // Check to see if we should show discovery UI
        dwSize = sizeof(DWORD);
        if(ERROR_SUCCESS != SHGetValueW(HKEY_CURRENT_USER,
                REGSTR_PATH_INTERNET_SETTINGS,
                REGSTR_VAL_PRIVDISCOVER,
                NULL, &dwValue, &dwSize)
            || 0 == dwValue)
        {
            BOOL    bStatusBarVisible = FALSE;
            INT_PTR i = 1;
            HRESULT hr;

            // suppression setting not set, show ui if status bar is visible
            IBrowserService *pbs;
            hr = _pspOuter->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IBrowserService, &pbs));
            if(SUCCEEDED(hr))
            {
                hr = pbs->IsControlWindowShown(FCW_STATUS, &bStatusBarVisible);
                pbs->Release();
            }

            BOOL fDontShowPrivacyFirstTimeDialogAgain = FALSE;
            if(SUCCEEDED(hr) && bStatusBarVisible)
            {
                fDontShowPrivacyFirstTimeDialogAgain = DoPrivacyFirstTimeDialog( _bbd._hwnd);
            }

            if( fDontShowPrivacyFirstTimeDialogAgain == TRUE)
            {
                dwValue = 1;
                SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNET_SETTINGS, REGSTR_VAL_PRIVDISCOVER,
                    REG_DWORD, &dwValue, sizeof(DWORD));
            }
        }
    }

    return S_OK;
}

//
//  This block of code simply prevents calling UIActivate of old
// extensions with a new SVUIA_ value.
//
HRESULT CBaseBrowser2::_UIActivateView(UINT uState)
{
    if (_bbd._psv) 
    {
        BOOL fShellView2;
        IShellView2* psv2;
        if (SUCCEEDED(_bbd._psv->QueryInterface(IID_PPV_ARG(IShellView2, &psv2))))
        {
            fShellView2 = TRUE;
            psv2->Release();
        }
        else
        {
            fShellView2 = FALSE;
        }

        if (uState == SVUIA_INPLACEACTIVATE && !fShellView2)
        {
            uState = SVUIA_ACTIVATE_NOFOCUS;        // map it to old one.
        }

        if (_cRefUIActivateSV)
        {
            TraceMsg(TF_WARNING, "CBB(%x)::_UIActivateView(%d) entered reentrantly!!!!!! _cRefUIActivate=%d",
                this, uState, _cRefUIActivateSV);
            if (uState == SVUIA_DEACTIVATE)
            {
                _fDeferredUIDeactivate = TRUE;
                return S_OK;
            }
            if (!_HeyMoe_IsWiseGuy())
            {
                if (_bbd._psv)
                    _bbd._psv->UIActivate(SVUIA_INPLACEACTIVATE);
                return S_OK;
            }
        }

        _cRefUIActivateSV++;

        TraceMsg(TF_SHDUIACTIVATE, "CBaseBrowser2(%x)::_UIActivateView(%d) about to call _bbd._psv(%x)->UIActivate",
            this, uState, _bbd._psv);

        _bbd._psv->UIActivate(uState);

        if (uState == SVUIA_ACTIVATE_FOCUS && !fShellView2)
        {
            // win95 defview expects a SetFocus on activation (nt5 bug#172210)
            if (_bbd._hwndView)
                SetFocus(_bbd._hwndView);
        }

        TraceMsg(TF_SHDUIACTIVATE, "CBaseBrowser2(%x)::_UIActivateView(%d) back from _bbd._psv(%x)->UIActivate",
            this, uState, _bbd._psv);

        _cRefUIActivateSV--;

        _UpdatePrivacyIcon(FALSE, FALSE);
        UpdateSecureLockIcon(SECURELOCK_NOCHANGE);
        
    }
    _bbd._uActivateState = uState;

    // If this is a pending view, set the focus to its window even though it's hidden.
    // In ActivatePendingView(), we check if this window still has focus and, if it does,
    // we will ui-activate the view. Fix for IE5 bug #70632 -- MohanB

    if (    SVUIA_ACTIVATE_FOCUS == uState
        &&  !_bbd._psv
        &&  !_bbd._hwndView
        &&  _bbd._psvPending
        &&  _bbd._hwndViewPending
       )
    {
        ::SetFocus(_bbd._hwndViewPending);
    }

    if (_fDeferredUIDeactivate)
    {
        TraceMsg(TF_SHDUIACTIVATE, "CBaseBrowser2(%x)::_UIActivateView processing deferred UIDeactivate, _bbd._psv=%x",
            this, _bbd._psv);
        _fDeferredUIDeactivate = FALSE;
        if (_bbd._psv)
            _bbd._psv->UIActivate(SVUIA_DEACTIVATE);
        _UpdatePrivacyIcon(FALSE, FALSE);
        UpdateSecureLockIcon(SECURELOCK_NOCHANGE);
        _bbd._uActivateState = SVUIA_DEACTIVATE;
    }

    if (_fDeferredSelfDestruction)
    {
        TraceMsg(TF_SHDUIACTIVATE, "CBaseBrowser2(%x)::_UIActivateView processing deferred OnDestroy",
            this);
        _fDeferredSelfDestruction = FALSE;
        _pbsOuter->OnDestroy();
    }

    return S_OK;
}


//Called from CShellBrowser::OnCommand
HRESULT CBaseBrowser2::Offline(int iCmd)
{
    HRESULT hresIsOffline = IsGlobalOffline() ? S_OK : S_FALSE;

    switch(iCmd){
    case SBSC_TOGGLE:
        hresIsOffline = (hresIsOffline == S_OK) ? S_FALSE : S_OK; // Toggle Property
        // Tell wininet that the user wants to go offline
        SetGlobalOffline(hresIsOffline == S_OK); 
        SendShellIEBroadcastMessage(WM_WININICHANGE,0,0, 1000); // Tell all browser windows to update their title   
        break;
        
    case SBSC_QUERY:
        break;
    default: // Treat like a query
        break;                   
    }
    return hresIsOffline;
}



BOOL _TrackPidl(LPITEMIDLIST pidl, IUrlHistoryPriv *php, BOOL fIsOffline, LPTSTR pszUrl, DWORD cchUrl)
{
    BOOL fRet = FALSE;

    // Should use IsBrowserFrameOptionsPidlSet(pidl, BFO_ENABLE_HYPERLINK_TRACKING)
    //     instead of IsURLChild() because it doesn't work in Folder Shortcuts and doesn't
    //     work in NSEs outside of the "IE" name space (like Web Folders).
    if (pidl && IsURLChild(pidl, FALSE))
    {
        if (SUCCEEDED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, pszUrl, cchUrl, NULL)))
        {
            PROPVARIANT vProp;
            if (SUCCEEDED(php->GetProperty(pszUrl, PID_INTSITE_TRACKING, &vProp)))
            {
                if (vProp.vt == VT_UI4)
                {
                    if (fIsOffline)
                        fRet = (vProp.ulVal & TRACK_OFFLINE_CACHE_ENTRY) ? TRUE : FALSE;
                    else
                        fRet = (vProp.ulVal & TRACK_ONLINE_CACHE_ENTRY) ? TRUE : FALSE;
                }

                PropVariantClear(&vProp);
            }
        }
    }

    return fRet;
}

// End tracking of previous page
// May start tracking of new page
// use SatoN's db to quick check tracking/tracking scope bits, so
// to eliminate call to CUrlTrackingStg::IsOnTracking
void CBaseBrowser2::_MayTrackClickStream(LPITEMIDLIST pidlNew)
{
    BOOL    fIsOffline = (Offline(SBSC_QUERY) != S_FALSE);
    IUrlHistoryStg*    phist;
    IUrlHistoryPriv*   phistp;
    PROPVARIANT vProp = {0};
    TCHAR szUrl[MAX_URL_STRING];

    ASSERT(_bbd._pautoWB2);
    if (FAILED(_pspOuter->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IUrlHistoryStg, &phist))))
        return;

    if (FAILED(phist->QueryInterface(IID_PPV_ARG(IUrlHistoryPriv, &phistp))))
        return;

    phist->Release();

    if (_TrackPidl(_bbd._pidlCur, phistp, fIsOffline, szUrl, SIZECHARS(szUrl)))
    {
        if (!_ptracking)
            return;

        _ptracking->OnUnload(szUrl);
    }

    if (_TrackPidl(pidlNew, phistp, fIsOffline, szUrl, SIZECHARS(szUrl)))
    {    
        // instance of object already exists
        BRMODE brMode = BM_NORMAL;
        DWORD dwOptions;

        if (!_ptracking) 
        {
            _ptracking = new CUrlTrackingStg();
            if (!_ptracking)
                return;
        }

        if (SUCCEEDED(GetTopFrameOptions(_pspOuter, &dwOptions)))
        {
            //Is this a desktop component?                    
            if (dwOptions & FRAMEOPTIONS_DESKTOP)
                brMode = BM_DESKTOP;
            //Is it fullscreen?                    
            else if (dwOptions & (FRAMEOPTIONS_SCROLL_AUTO | FRAMEOPTIONS_NO3DBORDER))
                brMode = BM_THEATER;
        }

        ASSERT(_ptracking);
        _ptracking->OnLoad(szUrl, brMode, FALSE);
    }

    phistp->Release();
}


HRESULT CBaseBrowser2::_SwitchActivationNow()
{
    ASSERT(_bbd._psvPending);

    WORD wNavTypeFlags = 0;  // init to suppress bogus C4701 warning

    IShellView* psvNew = _bbd._psvPending;
    IShellFolder* psfNew = _bbd._psfPending;
    HWND hwndViewNew = _bbd._hwndViewPending;
    LPITEMIDLIST pidlNew = _bbd._pidlPending;

    _bbd._fIsViewMSHTML = _IsViewMSHTML(psvNew);
    
    _bbd._psvPending = NULL;
    _bbd._psfPending = NULL;
    _bbd._hwndViewPending = NULL;
    _bbd._pidlPending = NULL;

    // Quickly check tracking prefix string on this page,
    // if turned on, log enter/exit events
    // Should use IsBrowserFrameOptionsSet(_bbd._psf, BFO_ENABLE_HYPERLINK_TRACKING)
    //     instead of IsURLChild() because it doesn't work in Folder Shortcuts and doesn't
    //     work in NSEs outside of the "IE" name space (like Web Folders).
    if ((_bbd._pidlCur && IsURLChild(_bbd._pidlCur, FALSE)) ||
        (pidlNew && IsURLChild(pidlNew, FALSE)))
        _MayTrackClickStream(pidlNew);

    // nuke the old stuff
    _pbsOuter->ReleaseShellView();
    
    ASSERT(!_bbd._psv && !_bbd._psf && !_bbd._hwndView);

    // activate the new stuff
    if (_grfHLNFPending != (DWORD)-1) 
    {
        _OnNavigateComplete(pidlNew, _grfHLNFPending);
    }

    VALIDATEPENDINGSTATE();

    // now do the actual switch

    // no need to addref because we're keeping the pointer and just chaning
    // it from the pending to the current member variables
    _bbd._psf = psfNew;
    _bbd._psv = psvNew; 

    ILFree(_bbd._pidlCur);
    _bbd._pidlCur = pidlNew;

    DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
    DEBUG_CODE(IEGetDisplayName(_bbd._pidlCur, szPath, SHGDN_FORPARSING);)
    DEBUG_CODE(TraceMsg(DM_TRACE, "CBB::ActivatePendingView (TRAVELLOG): _UpdateTravelLog called from shdocvw for %ws", szPath);)

    _bbd._hwndView = hwndViewNew;
    _dwReadyStateCur = _dwReadyStatePending;

    if (_bbd._pszTitleCur)
        LocalFree(_bbd._pszTitleCur);
    _bbd._pszTitleCur = _bbd._pszTitlePending;
    _bbd._pszTitlePending = NULL;

    if (_eSecureLockIconPending != SECURELOCK_NOCHANGE)
    {
        _bbd._eSecureLockIcon = _eSecureLockIconPending;
        _eSecureLockIconPending = SECURELOCK_NOCHANGE;
    }

    //
    //  This is the best time to resize the newone.
    //
    _pbsOuter->_UpdateViewRectSize();
    SetWindowPos(_bbd._hwndView, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    // WARNING: Not all shellview supports IOleCommandTarget!!!
    _fUsesPaletteCommands = FALSE;
    
    if ( _bbd._psv )
    {
        _bbd._psv->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_bbd._pctView));

        // PALETTE: Exec down to see if they support the colors changes Command so that we don't have to 
        // PALETTE: wire ourselves into the OnViewChange mechanism just to get palette changes...
        if ( _bbd._pctView && 
             SUCCEEDED(_bbd._pctView->Exec( &CGID_ShellDocView, SHDVID_CANDOCOLORSCHANGE, 0, NULL, NULL)))
        {
            _fUsesPaletteCommands = TRUE;

            // force a colors dirty to make sure that we check for a new palette for each page...
            _ColorsDirty( BPT_UnknownPalette );
        }
    }

    // PALETTE: only register for the OnViewChange stuff if the above exec failed...
    if (SUCCEEDED(_bbd._psv->QueryInterface(IID_IViewObject, (void**)&_pvo)) && !_fUsesPaletteCommands )
        _pvo->SetAdvise(DVASPECT_CONTENT, ADVF_PRIMEFIRST, this);

    _Exec_psbMixedZone();

    if (_bbd._pctView != NULL)
    {
        _bbd._pctView->Exec(&CGID_ShellDocView, SHDVID_RESETSTATUSBAR, 0, NULL, NULL);
    }

    return S_OK;
}

// This member is called when we about to destroy the current shell view.
// Returning S_FALSE indicate that the user hit CANCEL when it is prompted
// to save the changes (if any).

HRESULT CBaseBrowser2::_MaySaveChanges(void)
{
    HRESULT hres = S_OK;
    if (_bbd._pctView) // we must check!
    {
        hres = _bbd._pctView->Exec(&CGID_Explorer, SBCMDID_MAYSAVECHANGES,
                            OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
    }
    return hres;
}

HRESULT CBaseBrowser2::_DisableModeless(void)
{
    if (_cRefCannotNavigate == 0)
    {
        OLECMD rgCmd;
        BOOL fPendingInScript = FALSE;

        //  if pending shell view supports it, give it a chance to tell us it's not ready
        //  to deactivate [eg executing a script].  normally scripts should not be run
        //  before inplace activation, but TRIDENT sometimes has to do this when parsing.
        //
        rgCmd.cmdID = SHDVID_CANDEACTIVATENOW;
        rgCmd.cmdf = 0;

        if (SUCCEEDED(IUnknown_QueryStatus(_bbd._psvPending, &CGID_ShellDocView, 1, &rgCmd, NULL)) &&
            (rgCmd.cmdf & MSOCMDF_SUPPORTED) &&
            !(rgCmd.cmdf & MSOCMDF_ENABLED))
        {
            fPendingInScript = TRUE;
        }

        if (!fPendingInScript) 
        {
            return S_FALSE;
        }
    }
    return S_OK;
}

BOOL CBaseBrowser2::_CanNavigate(void)
{
    return !((_DisableModeless() == S_OK) || (! IsWindowEnabled(_bbd._hwnd)));
}

HRESULT CBaseBrowser2::CanNavigateNow(void)
{
    return _CanNavigate() ? S_OK : S_FALSE;
}

HRESULT CBaseBrowser2::_PauseOrResumeView(BOOL fPaused)
{
    // If fPaused (it's minimized or the parent is minimized) or
    // _bbd._psvPending is non-NULL, we need to pause.
    if (_bbd._pctView) 
    {
        VARIANT var = { 0 };
        var.vt = VT_I4;
        var.lVal = (_bbd._psvPending || fPaused) ? FALSE : TRUE;
        _bbd._pctView->Exec(NULL, OLECMDID_ENABLE_INTERACTION, OLECMDEXECOPT_DONTPROMPTUSER, &var, NULL);
    }

    return S_OK;
}

HRESULT CBaseBrowser2::CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd)
{
    _fCreateViewWindowPending = TRUE;
    _pbsOuter->GetFolderSetData(&(_fldBase._fld)); // it's okay to stomp on this every time

    HRESULT hres = FileCabinet_CreateViewWindow2(_psbOuter, &_fldBase, psvNew, psvOld, prcView, phwnd);

    _fCreateViewWindowPending = FALSE;
    return hres;
}


//
// grfHLNF == (DWORD)-1 means don't touch the history at all.
//
// NOTE:
// if _fCreateViewWindowPending == TRUE, it means we came through here once
// already, but we are activating a synchronous view and the previous view would
// not deactivate immediately...
// It is used to delay calling IShellView::CreateViewWindow() for shell views until we know that
// we can substitute psvNew for _bbd._psv.
//
HRESULT CBaseBrowser2::_CreateNewShellView(IShellFolder* psf, LPCITEMIDLIST pidl, DWORD grfHLNF)
{
    BOOL fActivatePendingView = FALSE;
    IShellView *psvNew = NULL;

    // Bail Out of Navigation if modal windows are up from our view
    // Should we restart navigation on next EnableModeless(TRUE)?
    if (!_CanNavigate())
    {
        TraceMsg(DM_ENABLEMODELESS, "CSB::_CreateNewShellView returning ERROR_BUSY");
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }
        
    HRESULT hres = _MaySaveChanges();
    if (hres == S_FALSE)
    {
        TraceMsg(DM_WARNING, "CBB::_CreateNewShellView _MaySaveChanges returned S_FALSE. Navigation canceled");
        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    TraceMsg(DM_WARNING, "CBB::_CNSV - Cur View MSHTML? %d  Pending View MSHTML? %d",
             _IsViewMSHTML(_bbd._psv), _IsViewMSHTML(_bbd._psvPending));

    VALIDATEPENDINGSTATE();

#ifndef NON_NATIVE_FRAMES

    // The navigation has been interrupted.
    //
    if (   _bbd._psv
        && _bbd._psvPending
        && _IsViewMSHTML(_bbd._psvPending))
    {
        _fHtmlNavCanceled = TRUE;
    }

#endif

    _CancelPendingView();

    ASSERT (_fCreateViewWindowPending == FALSE);

    VALIDATEPENDINGSTATE();

    if (_bbd._psv && _IsViewMSHTML(_bbd._psv))
    {
        ATOMICRELEASE(_pphHistory);
        SafeGetItemObject(_bbd._psv, SVGIO_BACKGROUND, IID_PPV_ARG(IPersistHistory, &_pphHistory));
    }

    hres = psf->CreateViewObject(_bbd._hwnd, IID_PPV_ARG(IShellView, &psvNew));

    if (SUCCEEDED(hres))
    {
        _bbd._fCreatingViewWindow = TRUE;

        IUnknown_SetSite(psvNew, _psbOuter);    // SetSite for the view

        _psbOuter->EnableModelessSB(FALSE);
    
        HWND hwndViewNew = NULL;
        RECT rcView;

        //
        // NOTES: SatoNa
        //
        //  Notice that we explicitly call _GetViewBorderRect (non-virtual)
        // instead of virtual _GetShellView, which CShellBrowser override.
        // We now call thru (virtual) _pbsOuter, is this o.k.?
        //
        _pbsOuter->_GetViewBorderRect(&rcView);

        // It is ncecessary for _bbd._pidlPending and _bbd._psvPending to both be set together.
        // they're  a pair
        // previously _bbd._pidlPending was being set after the call to
        // FileCabinet_CreateViewWindow and when messages were pumped there
        // a redirect would be nofied in the bind status callback.
        // this meant that a valid _bbd._pidlPending was actually available BUT
        // then we would return and blow away that _bbd._pidlPending
        //
        ASSERT(_bbd._psvPending == NULL );
        _bbd._psvPending = psvNew;
        psvNew->AddRef();

        ASSERT(_bbd._psfPending == NULL);
        ASSERT(_bbd._pidlPending == NULL);

        _bbd._psfPending = psf;
        psf->AddRef();

        _bbd._pidlPending = ILClone(pidl);

        // Initialize _bbd._pidlNewShellView which will be used by GetViewStateStream
        _bbd._pidlNewShellView = pidl;
        _grfHLNFPending = grfHLNF;

        // Start at _COMPLETE just in case the object we connect
        // to doesn't notify us of ReadyState changes
        //
        _dwReadyStatePending = READYSTATE_COMPLETE;

        // We need to cache this information here because the _dwDocFlags
        // can change during the call to CreateViewWindow. This information
        // is needed to determine whether or not we should stop the current
        // view. If the document does not know how to navigate, then we
        // stop the current view. The is needed in order to stop the 
        // navigation in the current view when a new navigation has started.
        //
        BOOL fDocCanNavigate = _dwDocFlags & DOCFLAG_DOCCANNAVIGATE;

        hres = _pbsOuter->CreateViewWindow(psvNew, _bbd._psv, &rcView, &hwndViewNew);

        IUnknown_SetSite(psvNew, NULL); // The view by now must have psb

        _bbd._pidlNewShellView = NULL;

        TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_CreateNewShellView(3) Called CreateViewWindow"), psvNew, hres);

        if (SUCCEEDED(hres))
        {
            // we defer the _PauseOrResumeView until here when we have enough
            // info to know if it's a new page or not.  o.w. we end up (e.g.)
            // stopping bgsounds etc. on local links (nash:32270).
#ifdef NON_NATIVE_FRAMES
            // 
            // Note (scotrobe): This was a no-op in IE5.
            //
            _PauseOrResumeView(_fPausedByParent);
            
            // We stop the current view because we need to flush away any image stuff that
            // is in queue so that the actual html file can get downloaded
            //
            _StopCurrentView();
#endif

            // We can't stop the current view if the doc knows how
            // to navigate. This is because in that case, the document
            // in current view is the same document as the pending view.
            //
            if (!fDocCanNavigate)
            {
                _StopCurrentView();
            }

            _bbd._hwndViewPending = hwndViewNew;

            /// BEGIN-CHC- Security fix for viewing non shdocvw ishellviews
            _CheckDisableViewWindow();
            /// END-CHC- Security fix for viewing non shdocvw ishellviews
        
            // chrisfra - if hres == S_FALSE this (calling ActivatePendingViewAsync
            // when _bbd._psv==NULL) will break async URL download
            // as it will cause _bbd._psvPending to be set to NULL prematurely.  this should
            // be deferred until CDocObjectView::CBindStatusCallback::OnObjectAvailable
            //if (hres==S_OK || _bbd._psv==NULL)
            
            ASSERT(( hres == S_OK ) || ( hres == S_FALSE ));
            
            if (hres == S_OK)
            {
                // We should activate synchronously.
                //
                // NOTE: This used to be ActivatePendingViewAsyc(), but that causes a
                // fault if you navigated to C:\ and click A:\ as soon as it appears. This
                // puts the WM_LBUTTONDOWN in FRONT of the WMC_ASYNCOPERATION message. If
                // there's no disk in drive A: then a message box appears while in the
                // middle of the above FileCabinet_CreateViewWindow call and we pull off
                // the async activate and activate the view we're in the middle of
                // creating! Don't do that.
                //
                fActivatePendingView = TRUE;
            }
            else
            {
                // Activation is pending.
                // since the back button works as a stop on pending navigations, we
                // should check that here as well.
                _pbsOuter->UpdateBackForwardState();
            }
        }
        else
        {
            if (   _bbd._psvPending
                && !(_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC)
                && _IsViewMSHTML(_bbd._psvPending))
            {
                _fHtmlNavCanceled = TRUE;
            }
            else
            {
                _fHtmlNavCanceled = FALSE;
            }

            TraceMsg(DM_WARNING, "ief _CreateNewShellView psvNew->CreateViewWindow failed %x", hres);
            _CancelPendingView();
        }

        psvNew->Release();

        if (_psbOuter)
            _psbOuter->EnableModelessSB(TRUE);
    }
    else
    {
        TraceMsg(TF_WARNING, "ief _BrowseTo psf->CreateViewObject failed %x", hres);
    }

    _fHtmlNavCanceled = FALSE;

    //
    //  If there is any blocked async operation AND we can navigate now,
    // unblock it now. 
    //
    _MayUnblockAsyncOperation();

    _bbd._fCreatingViewWindow = FALSE;

    VALIDATEPENDINGSTATE();

    TraceMsg(DM_WARNING, "CBB::_CNSV - Cur View MSHTML? %d  Pending View MSHTML? %d",
             _IsViewMSHTML(_bbd._psv), _IsViewMSHTML(_bbd._psvPending));

    if (fActivatePendingView && !_IsViewMSHTML(_bbd._psvPending))
    {
        //
        // Since _IsViewMSHTML can delegate to a marshalled interface,
        // we can get re-entrancy.  On re-entrancy, we can do a 
        // _CancelPendingView in which case _bbd._psvPending is 
        // no longer valid.
        //
        // So, we need to see if we still have _hbd._psvPending here.  
        //

        if (_bbd._psvPending)
        {
            _PreActivatePendingViewAsync(); // so we match old code

            hres = _pbsOuter->ActivatePendingView();
            if (FAILED(hres))
                TraceMsg(DM_WARNING, "CBB::_CNSV ActivatePendingView failed");
        }
    }

    TraceMsg(DM_STARTUP, "ief _CreateNewShellView returning %x", hres);
    return hres;
}

//  private bind that is very loose in its bind semantics.
HRESULT IEBindToObjectForNavigate(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsfOut);

// this binds to the pidl folder then hands off to CreateNewShellView
// if you have anything you need to do like checking before we allow the navigate, it
// should go into _NavigateToPidl
HRESULT CBaseBrowser2::_CreateNewShellViewPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD fSBSP)
{
    SetNavigateState(BNS_BEGIN_NAVIGATE);

    TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_CreateNewShellViewPidl not same pidl"), pidl, _bbd._pidlCur);

    // Check for URL-pidl?

    // We will allow UI to be displayed by passing this IBindCtx to IShellFolder::BindToObject().
    IBindCtx * pbc = NULL;
    IShellFolder* psf;
    HRESULT hres;

    // shell32 v4 (IE4 w/ActiveDesktop) had a bug that juntion points from the
    // desktop didn't work if a IBindCtx is passed and causes crashing on debug.
    // The fix is to not pass bindctx on that shell32.  We normally want to pass
    // an IBindCtx so shell extensions can enable the browser modal during UI.
    // The Internet name space does this when InstallOnDemand(TM) installs delegate
    // handles, like FTP.  A junction point is a folder that contains a desktop.ini
    // that gives the CLSID of the shell extension to use for the Shell Extension.
    if (4 != GetUIVersion())
    {
        pbc = CreateBindCtxForUI(SAFECAST(this, IShellBrowser*));    // I'm safecasting to IUnknown.  IShellBrowser is only for disambiguation.
    }
    hres = IEBindToObjectForNavigate(pidl, pbc, &psf);   // If pbc is NULL, we will survive.

    if (SUCCEEDED(hres))
    {
        hres = _CreateNewShellView(psf, pidl, grfHLNF);
        TraceMsg(DM_STARTUP, "CSB::_CreateNewShellViewPidl _CreateNewShellView(3) returned %x", hres);
        psf->Release();
    }
    else
    {
        // This will happen when a user tries to navigate to a directory past
        // MAX_PATH by double clicking on a subdirectory in the shell.
        TraceMsg(DM_TRACE, "CSB::_CreateNSVP BindToOject failed %x", hres);
    }

    
    // If _CreateNewShellView (or IEBindToObject) fails or the user cancels
    // the MayOpen dialog (hres==S_FALSE), we should restore the navigation
    // state to NORMAL (to stop animation). 
    if (FAILED(hres))
    {
        TraceMsg(TF_SHDNAVIGATE, "CSB::_CreateNSVP _CreateNewShellView FAILED (%x). SetNavigateState to NORMAL", hres);
        SetNavigateState(BNS_NORMAL);
    }

    ATOMICRELEASE(pbc);
    TraceMsg(DM_STARTUP, "CSB::_CreateNewShellViewPidl returning %x", hres);
    return hres;
}

//
// Returns the border rectangle for the shell view.
//
HRESULT CBaseBrowser2::_GetViewBorderRect(RECT* prc)
{
    _pbsOuter->_GetEffectiveClientArea(prc, NULL);  // hmon?
    // (derived class subtracts off border taken by all "frame" toolbars)
    return S_OK;
}

//
// Returns the window rectangle for the shell view window.
//
HRESULT CBaseBrowser2::GetViewRect(RECT* prc)
{
    //
    // By default (when _rcBorderDoc is empty), ShellView's window
    // rectangle is the same as its border rectangle.
    //
    _pbsOuter->_GetViewBorderRect(prc);

    // Subtract document toolbar margin
    prc->left += _rcBorderDoc.left;
    prc->top += _rcBorderDoc.top;
    prc->right -= _rcBorderDoc.right;
    prc->bottom -= _rcBorderDoc.bottom;

    TraceMsg(DM_UIWINDOW, "ief GetViewRect _rcBorderDoc=%x,%x,%x,%x",
             _rcBorderDoc.left, _rcBorderDoc.top, _rcBorderDoc.right, _rcBorderDoc.bottom);
    TraceMsg(DM_UIWINDOW, "ief GetViewRect prc=%x,%x,%x,%x",
             prc->left, prc->top, prc->right, prc->bottom);

    return S_OK;
}

HRESULT CBaseBrowser2::_PositionViewWindow(HWND hwnd, LPRECT prc)
{
    SetWindowPos(hwnd, NULL,
                 prc->left, prc->top, 
                 prc->right - prc->left, 
                 prc->bottom - prc->top,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    return S_OK;
}

void CBaseBrowser2::_PositionViewWindowHelper(HWND hwnd, LPRECT prc)
{
    if (_pbsOuter3)
        _pbsOuter3->_PositionViewWindow(hwnd, prc);
    else
        _PositionViewWindow(hwnd, prc);
}

HRESULT CBaseBrowser2::_UpdateViewRectSize(void)
{
    RECT rc;

    TraceMsg(TF_SHDUIACTIVATE, "CSB::_UpdateViewRectSize called when _fDontReszeView=%d, _bbd._hwndV=%x, _bbd._hwndVP=%x",
             _fDontResizeView, _bbd._hwndView, _bbd._hwndViewPending);

    _pbsOuter->GetViewRect(&rc);

    if (_bbd._hwndView && !_fDontResizeView) 
    {
        TraceMsg(TF_SHDUIACTIVATE, "CSB::_UpdateViewRectSize resizing _bbd._hwndView(%x)", _bbd._hwndView);
        _PositionViewWindowHelper(_bbd._hwndView, &rc);
    }

    if (_bbd._hwndViewPending) 
    {
        TraceMsg(TF_SHDUIACTIVATE, "CSB::_UpdateViewRectSize resizing _bbd._hwndViewPending(%x)", _bbd._hwndViewPending);
        _PositionViewWindowHelper(_bbd._hwndViewPending, &rc);
    }
    return S_OK;
}

UINT g_idMsgGetAuto = 0;

// this stays in shdocvw because the OC requires drop target registration
void CBaseBrowser2::_RegisterAsDropTarget()
{
    // if it's okay to register and we haven't registered already
    // and we've processed WM_CREATE
    if (!_fNoDragDrop && !_fRegisteredDragDrop && _bbd._hwnd)
    {
        BOOL fAttemptRegister = _fTopBrowser ? TRUE : FALSE;

        // if we're not toplevel, we still try to register
        // if we have a proxy browser
        if (!fAttemptRegister)
        {
            IShellBrowser* psb;
            HRESULT hres = _pspOuter->QueryService(SID_SProxyBrowser, IID_PPV_ARG(IShellBrowser, &psb));
            if (SUCCEEDED(hres)) 
            {
                fAttemptRegister = TRUE;
                psb->Release();
            }
        }

        if (fAttemptRegister)
        {
            HRESULT hr;
            IDropTarget *pdt;

            // SAFECAST(this, IDropTarget*), the hard way
            hr = THR(QueryInterface(IID_PPV_ARG(IDropTarget, &pdt)));
            if (SUCCEEDED(hr)) 
            {
                hr = THR(RegisterDragDrop(_bbd._hwnd, pdt));
                if (SUCCEEDED(hr)) 
                {
                    _fRegisteredDragDrop = TRUE;
                }
                pdt->Release();
            }
        }
    }
}

void CBaseBrowser2::_UnregisterAsDropTarget()
{
    if (_fRegisteredDragDrop)
    {
        _fRegisteredDragDrop = FALSE;
        
        THR(RevokeDragDrop(_bbd._hwnd));
    }
}


HRESULT CBaseBrowser2::OnCreate(LPCREATESTRUCT pcs)
{
    HRESULT hres;
    TraceMsg(DM_STARTUP, "_OnCreate called");

    if (g_idMsgGetAuto == 0)
        g_idMsgGetAuto = RegisterWindowMessage(TEXT("GetAutomationObject"));

    hres = InitPSFInternet();

    // do stuff that depends on window creation
    if (SUCCEEDED(hres))
    {
        // this must be done AFTER the ctor so that we get virtuals right
        // NOTE: only do this if we're actually creating the window, because
        //       the only time we SetOwner(NULL) is OnDestroy.
        //
        _bbd._pautoSS->SetOwner(SAFECAST(this, IShellBrowser*));
    
        _RegisterAsDropTarget();
    }

    TraceMsg(DM_STARTUP, "ief OnCreate returning %d (SUCCEEDED(%x))", SUCCEEDED(hres), hres);

    return SUCCEEDED(hres) ? S_OK : E_FAIL;
}

HRESULT CBaseBrowser2::OnDestroy()
{
    //  We're seeing some reentrancy here.  If _cRefCannotNavigate is non-zero, it means we're
    //  in the middle of something and shouldn't destroy ourselves.
    //

    //  Also check reentrant calls to OnDestroy().
    if (_fInDestroy)
    {
        // Already being destroyed -- bail out.
        return S_OK;
    }

    _fInDestroy = TRUE;

    if (_cRefUIActivateSV)
    {
        TraceMsg(TF_WARNING, 
            "CBB(%x)::OnDestroy _cRefUIActivateSV(%d)!=0", 
            this, _cRefUIActivateSV);

        // I need to defer my self-destruction.
        //
        _fDeferredSelfDestruction = TRUE;
        return S_OK;
    }

    _CancelPendingView();
    _pbsOuter->ReleaseShellView();
    
#ifdef DEBUG
    // It is valid for _cRefCannotNavigate > 0 if we the system is shutting down. The reason
    // for this is that we can still be processing a call to ::CreateNewShellView() when we
    // the desktop recieves the WM_ENDSESSION and destroys us. In this case its ok to proceed
    // with the destroy in this case, since we are logging off or rebooting anyway.
    AssertMsg(_fMightBeShuttingDown || (S_FALSE == _DisableModeless()),
              TEXT("CBB::OnDestroy _cRefCannotNavigate!=0 (%d)"),
              _cRefCannotNavigate);
#endif

    ATOMICRELEASE(_bbd._ptl);

    // This should always be successful because the IDropTarget is registered 
    // in _OnCreate() and is the default one.
    // _pdtView should have already been released in ReleaseShellView
    ASSERT(_pdtView == NULL);

    _UnregisterAsDropTarget();
    //
    //  It is very important to call _bbd._pauto->SetOwner(NULL) here, which will
    // remove any reference from the automation object to us. Before doing
    // it, we always has cycled references and we never be released.
    //
    _bbd._pautoSS->SetOwner(NULL);

    _bbd._hwnd = NULL;

#ifdef DEBUG
    _fProcessed_WM_CLOSE = TRUE;
#endif
    _DLMDestroy();
    IUnknown_SetSite(_pToolbarExt, NULL); // destroy the toolbar extensions

    if (_pauto)
    {
        IWebBrowserPriv * pWBPriv;

        HRESULT hr = _pauto->QueryInterface(IID_IWebBrowserPriv, (void**)&pWBPriv);
        if (SUCCEEDED(hr))
        {
            pWBPriv->OnClose();
            pWBPriv->Release();
        }
    }

    ATOMICRELEASE(_pHTMLDocument);
    ATOMICRELEASE(_pphHistory);

    return S_OK;
}

HRESULT CBaseBrowser2::NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF)
{
    HRESULT hr = S_OK;

    LPITEMIDLIST pidlNew = (LPITEMIDLIST)pidl;

    //
    //  Need to handle going back to an outside app - zekel 7MAY97
    //  i have dumped the code that did this, so now i need to put it
    //  into the CTravelLog implementation, so that it will be done properly
    //  without us.  but it shouldnt be done here regardless.
    //

    //  Remove? - with the old Travellog code
    // special case hack for telling us to use the local history, not
    // the global history
    if (pidl && pidl != PIDL_LOCALHISTORY)
        pidlNew = ILClone(pidl);

    //
    // Fortunately the only callers of NavigateToPidl use HLNF_NAVIGATINGBACK/FORWARD
    // so that's the only mapping we need to do here.
    //
    DWORD dwSBSP = 0;
    if (grfHLNF != (DWORD)-1)
    {
        if (grfHLNF & SHHLNF_WRITENOHISTORY)
            dwSBSP |= SBSP_WRITENOHISTORY;
        if (grfHLNF & SHHLNF_NOAUTOSELECT)
            dwSBSP |= SBSP_NOAUTOSELECT;
    }
    if (grfHLNF & HLNF_NAVIGATINGBACK)
        dwSBSP = SBSP_NAVIGATEBACK;
    else if (grfHLNF & HLNF_NAVIGATINGFORWARD)
        dwSBSP = SBSP_NAVIGATEFORWARD;

    if (dwSBSP)
    {
        if (_psbOuter)
        {
            hr = _psbOuter->BrowseObject(pidlNew, dwSBSP);  // browse will do the nav here.
        }

        ILFree(pidlNew);
    }
    else
        _NavigateToPidlAsync(pidlNew, dwSBSP, FALSE);  // takes ownership of the pidl
    
    return hr;
}

// S_OK means we found at least one valid connection point
//
HRESULT GetWBConnectionPoints(IUnknown* punk, IConnectionPoint **ppcp1, IConnectionPoint **ppcp2)
{
    HRESULT           hres = E_FAIL;
    IExpDispSupport*  peds;
    CConnectionPoint* pccp1 = NULL;
    CConnectionPoint* pccp2 = NULL;
    
    if (ppcp1)
        *ppcp1 = NULL;
    if (ppcp2)
        *ppcp2 = NULL;

    if (punk && SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IExpDispSupport, &peds))))
    {
        if (ppcp1 && SUCCEEDED(peds->FindCIE4ConnectionPoint(DIID_DWebBrowserEvents,
                                                reinterpret_cast<CIE4ConnectionPoint**>(&pccp1))))
        {
            *ppcp1 = pccp1->CastToIConnectionPoint();
            hres = S_OK;
        }

        if (ppcp2 && SUCCEEDED(peds->FindCIE4ConnectionPoint(DIID_DWebBrowserEvents2,
                                                reinterpret_cast<CIE4ConnectionPoint**>(&pccp2))))
        {
            *ppcp2 = pccp2->CastToIConnectionPoint();
            hres = S_OK;
        }
            
        peds->Release();
    }

    return hres;
}

void CBaseBrowser2::_UpdateBackForwardState()
{
    if (_fTopBrowser && !_fNoTopLevelBrowser) 
    {
        IConnectionPoint *pccp1;
        IConnectionPoint *pccp2;

        if (S_OK == GetWBConnectionPoints(_bbd._pautoEDS, &pccp1, &pccp2))
        {
            HRESULT hresT;
            VARIANTARG va[2];
            DISPPARAMS dp;
            ITravelLog *ptl;

            GetTravelLog(&ptl);

            // if we've got a site or if we're trying to get to a site,
            // enable the back button
            BOOL fEnable = (ptl ? S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_BACK, NULL) : FALSE);
                
            VARIANT_BOOL bEnable = fEnable ? VARIANT_TRUE : VARIANT_FALSE;
            TraceMsg(TF_TRAVELLOG, "CBB::UpdateBackForward BACK = %d", fEnable);

            // We use SHPackDispParams once instead of calling DoInvokeParams multiple times...
            //
            hresT = SHPackDispParams(&dp, va, 2, VT_I4, CSC_NAVIGATEBACK, VT_BOOL, bEnable);
            ASSERT(S_OK==hresT);

            // Removed the following EnableModelessSB(FALSE) because VB5 won't run the event handler if
            // we're modal.
            // _psbOuter->EnableModelessSB(FALSE);

            IConnectionPoint_SimpleInvoke(pccp1, DISPID_COMMANDSTATECHANGE, &dp);
            IConnectionPoint_SimpleInvoke(pccp2, DISPID_COMMANDSTATECHANGE, &dp);

            fEnable = (ptl ? S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_FORE, NULL) : FALSE);
            bEnable = fEnable ? VARIANT_TRUE : VARIANT_FALSE;
            TraceMsg(TF_TRAVELLOG, "CBB::UpdateBackForward FORE = %d", fEnable);

            ATOMICRELEASE(ptl);
            // We know how SHPackDispParams fills in va[]
            ASSERT(VT_BOOL == va[0].vt);
            va[0].boolVal = bEnable;
            ASSERT(VT_I4 == va[1].vt);
            va[1].lVal = CSC_NAVIGATEFORWARD;

            IConnectionPoint_SimpleInvoke(pccp1, DISPID_COMMANDSTATECHANGE, &dp);
            IConnectionPoint_SimpleInvoke(pccp2, DISPID_COMMANDSTATECHANGE, &dp);
            ATOMICRELEASE(pccp1);
            ATOMICRELEASE(pccp2);

            // Removed the following _psbOuter->EnableModelessSB(TRUE) because VB5 won't run the event handler if
            // we're modal.
            // _psbOuter->EnableModelessSB(TRUE);
        }
    }
}

void CBaseBrowser2::_NotifyCommandStateChange()
{
    HRESULT hr;

    // I'm only firing these in the toplevel case
    // Why? Who cares about the frameset case
    // since nobody listens to these events on
    // the frameset.
    //
    if (_fTopBrowser && !_fNoTopLevelBrowser) 
    {
        IConnectionPoint * pccp1;
        IConnectionPoint * pccp2;

        if (S_OK == GetWBConnectionPoints(_bbd._pautoEDS, &pccp1, &pccp2))
        {
            ASSERT(pccp1 || pccp2); // Should've gotten at least one

            VARIANTARG args[2];
            DISPPARAMS dp;

            hr = SHPackDispParams(&dp, args, 2,
                                  VT_I4,   CSC_UPDATECOMMANDS,
                                  VT_BOOL, FALSE);

            IConnectionPoint_SimpleInvoke(pccp1, DISPID_COMMANDSTATECHANGE, &dp);
            IConnectionPoint_SimpleInvoke(pccp2, DISPID_COMMANDSTATECHANGE, &dp);

            ATOMICRELEASE(pccp1);
            ATOMICRELEASE(pccp2);
        }
    }
}


LRESULT CBaseBrowser2::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    HWND hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
    if (IsInRange(idCmd, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST))
    {
        if (_bbd._hwndView)
            SendMessage(_bbd._hwndView, WM_COMMAND, wParam, lParam);
        else
            TraceMsg(0, "view cmd id with NULL view");

        /// REVIEW - how can we get FCIDM_FAVORITECMD... range if we're NOT toplevelapp?
        /// REVIEW - should RecentOnCommand be done this way too?
    }
    
    return S_OK;
}


LRESULT CBaseBrowser2::OnNotify(LPNMHDR pnm)
{
    // the id is from the view, probably one of the toolbar items

    if (IsInRange(pnm->idFrom, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST))
    {
        if (_bbd._hwndView)
            SendMessage(_bbd._hwndView, WM_NOTIFY, pnm->idFrom, (LPARAM)pnm);
    }
    return 0;
}

HRESULT CBaseBrowser2::OnSetFocus()
{
#if 0 // split: would be nice to assert
    ASSERT(_get_itbLastFocus() == ITB_VIEW);
#endif

    if (_bbd._hwndView) 
    {
        SetFocus(_bbd._hwndView);
    } 
    return 0;
}


#define ABOUT_HOME L"about:home"
// This function is VERY focused on achieving what the
// caller wants.  That's why it has a very specific
// meaning to the return value.
BOOL IsAboutHomeOrNonAboutURL(LPITEMIDLIST pidl)
{
    BOOL fIsAboutHomeOrNonAboutURL = TRUE;
    WCHAR wzCur[MAX_URL_STRING];

    if (pidl && SUCCEEDED(IEGetDisplayName(pidl, wzCur, SHGDN_FORPARSING)))
    {        
        // Is it "about:home"?
        if (0 != StrCmpNICW(ABOUT_HOME, wzCur, ARRAYSIZE(ABOUT_HOME) - 1))
        {
            // No.  We also want to return TRUE if the scheme was NOT an ABOUT URL.
            fIsAboutHomeOrNonAboutURL = (URL_SCHEME_ABOUT != GetUrlSchemeW(wzCur));
        }
    }

    return fIsAboutHomeOrNonAboutURL;            
}

//
// This function activate the pending view synchronously.
//
HRESULT CBaseBrowser2::ActivatePendingView(void)
{
    HRESULT hres = E_FAIL;
    BOOL bHadFocus;

    TraceMsg(TF_SHDNAVIGATE, "CBB::ActivatePendingView called");

    if (!_bbd._psvPending || !_bbd._psfPending)
    {
#ifdef DEBUG
        // it is valid for these to be null if we are shutting down b/c the desktop
        // could have destroyed us, which would have called ::OnDestroy which calls _CancelPendingView
        // which releases and nulls out _bbd._psvPending and _bbd._psfPending
        ASSERT(_fMightBeShuttingDown);
#endif
        goto Done;
    }

#ifndef NON_NATIVE_FRAMES

    IUnknown_Exec(_bbd._psvPending, &CGID_ShellDocView, SHDVID_COMPLETEDOCHOSTPASSING, 0, NULL, NULL);

#endif

#ifdef FEATURE_PICS
    if (S_FALSE == IUnknown_Exec(_bbd._psvPending, &CGID_ShellDocView, SHDVID_CANACTIVATENOW, NULL, NULL, NULL))
    {
        hres = S_OK;    // still waiting . . . but no failure.
        goto DoneWait;
    }
#endif
    
    //  if we are in modal loop, don't activate now
    if (_cRefCannotNavigate > 0)
    {
        goto Done;
    }

    // if _cRefCannotNavigate > 0 it is possible that _hwndViewPending has not been created so this assert 
    // should go after the check above
    ASSERT(_bbd._hwndViewPending);
    
    //  if shell view supports it, give it a chance to tell us it's not ready
    //  to deactivate [eg executing a script]
    //
    OLECMD rgCmd;
    rgCmd.cmdID = SHDVID_CANDEACTIVATENOW;
    rgCmd.cmdf = 0;
    if (_bbd._pctView &&
        SUCCEEDED(_bbd._pctView->QueryStatus(&CGID_ShellDocView, 1, &rgCmd, NULL)) &&
        (rgCmd.cmdf & MSOCMDF_SUPPORTED) &&
        !(rgCmd.cmdf & MSOCMDF_ENABLED)) 
    {
        //
        //  The DocObject that reported MSOCMDF_SUPPORTED must send
        //  SHDVID_DEACTIVATEMENOW when we're out of scripts or whatever so that
        //  we retry the activate
        //
        TraceMsg(DM_WARNING, "CBB::ActivatePendingView DocObject says I can't deactivate it now");
        goto Done;
    }

    ASSERT(_bbd._psvPending);

    // Prevent any navigation while we have the pointers swapped and we're in
    // delicate state
    _psbOuter->EnableModelessSB(FALSE);

    //
    // Don't play sound for the first navigation (to avoid multiple
    // sounds to be played for a frame-set creation).
    //
    if (_bbd._psv && IsWindowVisible(_bbd._hwnd) && !(_dwSBSPQueued & SBSP_WRITENOHISTORY)) 
    {
        IEPlaySound(TEXT("ActivatingDocument"), FALSE);
    }

    ASSERT(_bbd._psvPending);

    //  NOTE: if there are any other protocols that need to not be in 
    //  the travel log, it should probably implemented through UrlIs(URLIS_NOTRAVELLOG)
    //  right now, About: is the only one we care about
    //
    // Note that with the native frames changes, if we don't have
    // a psv, we will want to call _UpdateTravelLog because that is
    // where the first travel entry is added.
    //
    if (!(_grfHLNFPending & HLNF_CREATENOHISTORY) && 
        (!_bbd._psv || IsAboutHomeOrNonAboutURL(_bbd._pidlCur))
        && !_fDontUpdateTravelLog)
    {
        DEBUG_CODE(TCHAR szPath[INTERNET_MAX_URL_LENGTH + 1];)
        DEBUG_CODE(IEGetDisplayName(_bbd._pidlCur, szPath, SHGDN_FORPARSING);)
        DEBUG_CODE(TraceMsg(DM_TRACE, "CBB::ActivatePendingView (TRAVELLOG): _UpdateTravelLog called from shdocvw for %ws", szPath);)

        _UpdateTravelLog();
    }

    //  WARNING - these will only fail if the UpdateTravelLog() - zekel - 7-AUG-97
    //  was skipped and these bits are set.

    //  alanau 5-may-98 -- I still hit this assert on a script-based navigate to the same page.
    //      iedisp.cpp sees StrCmpW("about:blank","about:blank?http://www.microsoft.com/ie/ie40/gallery/_main.htm") 
    //      (for example), but basesb.cpp sees two equal pidls (both "about:blank?http://...").
    //      Killing this assert.
    // ASSERT(!_fDontAddTravelEntry);
    //
    //  scotrobe 11-Aug-99 If the hosted document is able to
    //  navigate itself, _UpdateTravelLog() will never be called.
    //
    ASSERT((_dwDocFlags & DOCFLAG_DOCCANNAVIGATE) || !_fIsLocalAnchor);

    // before we destroy the window check if it or any of its childern has focus
    bHadFocus =     _bbd._hwndView && (IsChildOrSelf(_bbd._hwndView, GetFocus()) == S_OK)
                ||  _bbd._hwndViewPending && (IsChildOrSelf(_bbd._hwndViewPending, GetFocus()) == S_OK);

    _pbsOuter->_SwitchActivationNow();

    _psbOuter->EnableModelessSB(TRUE);

    TraceMsg(DM_NAV, "CBaseBrowser2(%x)::ActivatePendingView(%x)", this, _bbd._psv);

    // if some other app has focus, then don't uiactivate this navigate
    // or we'll steal focus away. we'll uiactivate when we next get activated
    //
    // ie4.01, bug#64630 and 64329
    // _fActive only gets set by WM_ACTIVATE on the TopBrowser.  so for subframes
    // we always defer setting the focus if they didnt have focus before navigation.
    // the parent frame should set the subframe as necessary when it gets 
    //  its UIActivate.   - ReljaI 4-NOV-97
    if (SVUIA_ACTIVATE_FOCUS == _bbd._uActivateState && !(_fActive || bHadFocus))
    {
        _bbd._uActivateState = SVUIA_INPLACEACTIVATE;
        _fUIActivateOnActive = TRUE;
    }
    
    _UIActivateView(_bbd._uActivateState);

    // Tell the shell's HTML window we have a new document.
    if (_phtmlWS)
    {
        _phtmlWS->ViewActivated();
    }

    // this matches the _bbd._psvPending = NULL above.
    // we don't put this right beside there because the
    // _SwitchActivationNow could take some time, as well as the DoInvokePidl

    SetNavigateState(BNS_NORMAL);

    _pbsOuter->UpdateBackForwardState();
    _NotifyCommandStateChange();

    if (!_fNoDragDrop && _fTopBrowser)
    {
        ASSERT(_bbd._psv);
        // _SwitchActivationNow should have already released the old _pdtView and set it to NULL
        ASSERT(_pdtView == NULL);
        _bbd._psv->QueryInterface(IID_PPV_ARG(IDropTarget, &_pdtView));
    }

    // The pending view may have a title change stored up, so fire the TitleChange.
    // Also the pending view may not tell us about title changes, so simulate one.
    //
    if (_bbd._pszTitleCur)
    {
        if (_dwDocFlags & DOCFLAG_DOCCANNAVIGATE)
        {
            VARIANTARG  varTitle;
            HRESULT     hrExec;

            V_VT(&varTitle) = VT_BSTR;
            V_BSTR(&varTitle) = SysAllocString(_bbd._pszTitleCur);

            ASSERT(V_BSTR(&varTitle));

            hrExec = IUnknown_Exec( _psbOuter, NULL, OLECMDID_SETTITLE, NULL, &varTitle, NULL);

            VariantClear(&varTitle);
        }
        else
        {
            FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_TITLECHANGE, _bbd._pszTitleCur);
        }
    }
    else if (_bbd._pidlCur)
    {
        WCHAR wzFullName[MAX_URL_STRING];

        hres = ::IEGetNameAndFlags(_bbd._pidlCur, SHGDN_NORMAL, wzFullName, SIZECHARS(wzFullName), NULL);
        if (SUCCEEDED(hres))
            FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_TITLECHANGE, wzFullName);
    }

    // We must fire this event LAST because the app can shut us down
    // in response to this event.
    //

    //
    // MSWorks printing bug 104242 - Do NOT fire the NC2 event when the state is 
    // interactive. doing this will cause WorksCalender to print a partial document.
    // Instead, we have the SetReadyState explicitly directly call FireEvent_NaviagateComplete
    // and so the event will fire once the whole document has been parsed in.  This
    // code is matched by a bunch of event blockers in formkrnl.cxx
    //
    if (  GetModuleHandle(TEXT("WKSCAL.EXE")))
    {
        LBSTR::CString          strPath;

        LPTSTR          pstrPath = strPath.GetBuffer( MAX_URL_STRING );

        if ( strPath.GetAllocLength() < MAX_URL_STRING )
        {
            TraceMsg( TF_WARNING, "CBaseBrowser2::ActivatePendingView() - strPath Allocation Failed!" );

            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = IEGetDisplayName( _bbd._pidlCur, pstrPath, SHGDN_FORPARSING );

            // Let CString class own the buffer again.
            strPath.ReleaseBuffer();
        }

        if ( FAILED(hres) )
        {
            strPath.Empty();
        }

        if (   GetUrlSchemeW( strPath ) == URL_SCHEME_ABOUT
            || GetUrlSchemeW( strPath ) == URL_SCHEME_FILE
            || GetUrlSchemeW( strPath ) == URL_SCHEME_INVALID
           )
        {
            goto Done;
        }
    }

    // fire the event!
    FireEvent_NavigateComplete(_bbd._pautoEDS, _bbd._pautoWB2, _bbd._pidlCur, _bbd._hwnd);

    // Sync up the lock icon state with CDocObjectHost
    
    if (S_OK != IUnknown_Exec(_bbd._psv, &CGID_ShellDocView, SHDVID_FORWARDSECURELOCK, NULL, NULL, NULL))
    {      
        // No CDocObjectHost, so we're not secure
        CComVariant varLock((long) SECURELOCK_SET_UNSECURE);
        
        if (!IsTopFrameBrowser(SAFECAST(this, IServiceProvider *), SAFECAST(this, IShellBrowser *)))
        {
            // we should suggest if we are not the top frame
            IOleCommandTarget *pct;

            if (SUCCEEDED(QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IOleCommandTarget, &pct))))
            {
                varLock.lVal += SECURELOCK_FIRSTSUGGEST;       
                pct->Exec(&CGID_Explorer, SBCMDID_SETSECURELOCKICON, 0, &varLock, NULL);
                pct->Release();
            }
        }       
        else
        {
            Exec(&CGID_Explorer, SBCMDID_SETSECURELOCKICON, 0, &varLock, NULL);
        }
    }

    hres = S_OK;

Done:
    OnReadyStateChange(NULL, READYSTATE_COMPLETE);
DoneWait:
    return hres;
}

LRESULT CBaseBrowser2::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // call the UNICODE/ANSI aware DefWindowProc
    //
    return ::SHDefWindowProc(hwnd, uMsg, wParam, lParam);
}


void CBaseBrowser2::_ViewChange(DWORD dwAspect, LONG lindex)
{
    //
    // we are interested in content changes only
    //

    // NOTE: if we are registed for separate palette commands, then do not invalidate the colours here...
    if (dwAspect & DVASPECT_CONTENT && !_fUsesPaletteCommands )
    {
        //
        // recompute our palette
        //
        _ColorsDirty(BPT_UnknownPalette);
    }
    else
    {
        TraceMsg(DM_PALETTE, "cbb::_vc not interested in aspect(s) %08X", dwAspect);
    }
}

void CBaseBrowser2::_ColorsDirty(BrowserPaletteType bptNew)
{
    //
    // if we are not currently handling palette messages then get out
    //
    if (_bptBrowser == BPT_DeferPaletteSupport)
    {
        TraceMsg(DM_PALETTE, "cbb::_cd deferring palette support");
        return;
    }

    //
    // we only handle palette changes and display changes
    //
    if ((bptNew != BPT_UnknownPalette) && (bptNew != BPT_UnknownDisplay))
    {
        AssertMsg(FALSE, TEXT("CBaseBrowser2::_ColorsDirty: invalid BPT_ constant"));
        bptNew = BPT_UnknownPalette;
    }

    //
    // if we aren't on a palettized display we don't care about palette changes
    //
    if ((bptNew != BPT_UnknownDisplay) && (_bptBrowser == BPT_NotPalettized))
    {
        TraceMsg(DM_PALETTE, "cbb::_cd not on palettized display");
        return;
    }

    //
    // if we are already handling one of these then we're done
    //
    if ((_bptBrowser == BPT_PaletteViewChanged) ||
        (_bptBrowser == BPT_DisplayViewChanged))
    {
        TraceMsg(DM_PALETTE, "cbb::_cd coalesced");
        return;
    }

    //
    // unknown display implies unknown palette when the display is palettized
    //
    if (_bptBrowser == BPT_UnknownDisplay)
        bptNew = BPT_UnknownDisplay;

    //
    // post ourselves a WM_QUERYNEWPALETTE so we can pile up multiple advises
    // and handle them at once (we can see a lot of them sometimes...)
    // NOTE: the lParam is -1 so we can tell that WE posted it and that
    // NOTE: it doesn't necessarily mean we onw the foreground palette...
    //
    if (PostMessage(_bbd._hwnd, WM_QUERYNEWPALETTE, 0, (LPARAM) -1))
    {
        TraceMsg(DM_PALETTE, "cbb::_cd queued update");

        //
        // remember that we have already posted a WM_QUERYNEWPALETTE
        //
        _bptBrowser = (bptNew == BPT_UnknownPalette)?
            BPT_PaletteViewChanged : BPT_DisplayViewChanged;
    }
    else
    {
        TraceMsg(DM_PALETTE, "cbb::_cd FAILED!");

        //
        // at least remember that the palette is stale
        //
        _bptBrowser = bptNew;
    }
}

void CBaseBrowser2::v_PropagateMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    if (_bbd._hwnd)
        PropagateMessage(_bbd._hwnd, uMsg, wParam, lParam, fSend);
}

void CBaseBrowser2::_DisplayChanged(WPARAM wParam, LPARAM lParam)
{
    //
    // forward this on to our children
    //
    v_PropagateMessage(WM_DISPLAYCHANGE, wParam, lParam, TRUE);

    //
    // and mark our colors as dirty
    //
    _ColorsDirty(BPT_UnknownDisplay);
}

// 
// return results for _UpdateBrowserPaletteInPlace()
//    S_OK : BrowserPalette was successfully updated in place
//    S_FALSE : BrowserPalette is exactly the same, no need to update
//    E_FAIL : Unable to update palette in place at all, caller needs to create new palette 
// 
HRESULT CBaseBrowser2::_UpdateBrowserPaletteInPlace(LOGPALETTE *plp)
{
    if (!_hpalBrowser)
        return E_FAIL;

    WORD w;
    if (GetObject(_hpalBrowser, sizeof(w), &w) != sizeof(w))
        return E_FAIL;

    if (w != plp->palNumEntries)
        return E_FAIL;

    if (w > 256)
        return E_FAIL;

    //
    // GDI marks a palette as dirty if you update its colors
    // only replace the entries if the colors are actually different
    // this prevents excessive flashing
    //
    PALETTEENTRY ape[256];

    if (GetPaletteEntries(_hpalBrowser, 0, w, ape) != w)
        return E_FAIL;

    if (memcmp(ape, plp->palPalEntry, w * sizeof(PALETTEENTRY)) == 0)
    {
        TraceMsg(DM_PALETTE, "cbb::_ubpip %08x already had view object's colors", _hpalBrowser);
        return S_FALSE;
    }

    // make sure we don't reuse the global halftone palette that we are reusing across shdocvw....
    // do this after we've done the colour match 
    if ( _hpalBrowser == g_hpalHalftone )
    {
        return E_FAIL;
    }
    
    //
    // actually set up the colors
    //
    if (SetPaletteEntries(_hpalBrowser, 0, plp->palNumEntries,
        plp->palPalEntry) != plp->palNumEntries)
    {
        return E_FAIL;
    }

    TraceMsg(DM_PALETTE, "cbb::_ubpip updated %08x with view object's colors", _hpalBrowser);
    return S_OK;
}

void CBaseBrowser2::_RealizeBrowserPalette(BOOL fBackground)
{
    HPALETTE hpalRealize;

    //
    // get a palette to realize
    //
    if (_hpalBrowser)
    {
        TraceMsg(DM_PALETTE, "cbb::_rbp realizing %08x", _hpalBrowser);
        hpalRealize = _hpalBrowser;
    }
    else
    {
        TraceMsg(DM_PALETTE, "cbb::_rbp realizing DEFAULT_PALETTE");
        hpalRealize = (HPALETTE) GetStockObject(DEFAULT_PALETTE);
    }

    if ( !_fOwnsPalette && !fBackground )
    {
        // NOTE: if we don't think we own the foreground palette, and we
        // NOTE: are being told to realize in the foreground, then ignore
        // NOTE: it because they are wrong...
        fBackground = TRUE;
    }
    
    //
    // get a DC to realize on and select our palette
    //
    HDC hdc = GetDC(_bbd._hwnd);

    if (hdc)
    {
        HPALETTE hpalOld = SelectPalette(hdc, hpalRealize, fBackground);

        if (hpalOld)
        {
            //
            // we don't paint any palettized stuff ourselves we're just a frame
            // eg. we don't need to repaint here if the realize returns nonzero
            //
            RealizePalette(hdc);

            //
            // since we create and delete our palette alot, don't leave it selected
            //
            SelectPalette(hdc, hpalOld, TRUE);
        }
        ReleaseDC(_bbd._hwnd, hdc);
    }
}

void CBaseBrowser2::_PaletteChanged(WPARAM wParam, LPARAM lParam)
{
    TraceMsg(DM_PALETTE, "cbb::_pc (%08X, %08X, %08X) begins -----------------------", this, wParam, lParam);

    //
    // cdturner: 08/03/97
    // we think that we currently own the foregorund palette, we need to make sure that 
    // the window that just realized in the foreground (and thus caused the system
    // to generate the WM_PALETTECHANGED) was us, otherwise, we no longer own the 
    // palette 
    // 
    if ( _fOwnsPalette )
    {
        // by default we do not own it.
        _fOwnsPalette = FALSE;
        
        // the wParam hwnd we get is the top-level window that cause it, so we need to walk the window
        // chain to find out if it is one of our parents...
        // start at _bbd._hwnd (incase we are the top-level :-))
        HWND hwndParent = _bbd._hwnd;
        while ( hwndParent != NULL )
        {
            if ( hwndParent == (HWND) wParam )
            {
                // we caused it, so therefore we must still own it...
                _fOwnsPalette = TRUE;
                break;
            }
            hwndParent = GetParent( hwndParent );
        }
    }
    
    //
    // should we realize now? (see _QueryNewPalette to understand _bptBrowser)
    //
    // NOTE: we realize in the background here on purpose!  This helps us be
    // compatible with Netscape plugins etc that think they can own the
    // palette from inside the browser.
    //
    if (((HWND)wParam != _bbd._hwnd) && (_bptBrowser == BPT_Normal))
        _RealizeBrowserPalette(TRUE);

    //
    // always forward the changes to the current view
    // let the toolbars know too
    //
    if (_bbd._hwndView)
        TraceMsg(DM_PALETTE, "cbb::_pc forwarding to view window %08x", _bbd._hwndView);
    _pbsOuter->_SendChildren(_bbd._hwndView, TRUE, WM_PALETTECHANGED, wParam, lParam);  // SendMessage

    TraceMsg(DM_PALETTE, "cbb::_pc (%08X) ends -------------------------", this);
}

BOOL CBaseBrowser2::_QueryNewPalette()
{
    BrowserPaletteType bptNew;
    HPALETTE hpalNew = NULL;
    BOOL fResult = TRUE;
    BOOL fSkipRealize = FALSE;
    HDC hdc;

    TraceMsg(DM_PALETTE, "cbb::_qnp (%08X) begins ==================================", this);

TryAgain:
    switch (_bptBrowser)
    {
    case BPT_Normal:
        TraceMsg(DM_PALETTE, "cbb::_qnp - normal realization");
        //
        // Normal Realization: realize _hpalBrowser in the foreground
        //

        // avoid realzing the palette into the display if we've been asked not to...
        if ( !fSkipRealize )
            _RealizeBrowserPalette(FALSE);
        break;

    case BPT_ShellView:
        TraceMsg(DM_PALETTE, "cbb::_qnp - forwarding to shell view");
        //
        // Win95 Explorer-compatible: forward the query to the shell view
        //
        if (_bbd._hwndView && SendMessage(_bbd._hwndView, WM_QUERYNEWPALETTE, 0, 0))
            break;

        TraceMsg(DM_PALETTE, "cbb::_qnp - no shell view or view didn't answer");

        //
        // we only manage our palette as a toplevel app
        //

        //
        // the view didn't handle it; fall through to use a generic palette
        //
    UseGenericPalette:
        TraceMsg(DM_PALETTE, "cbb::_qnp - using generic palette");
        //
        // Use a Halftone Palette for the device
        //
        hpalNew = g_hpalHalftone;
        bptNew = BPT_Normal;
        goto UseThisPalette;

    case BPT_UnknownPalette:
    case BPT_PaletteViewChanged:
        TraceMsg(DM_PALETTE, "cbb::_qnp - computing palette");
        //
        // Undecided: try to use IViewObject::GetColorSet to compose a palette
        //
        LOGPALETTE *plp;
        HRESULT hres;

        // default to forwarding to the view if something fails along the way
        hpalNew = NULL;
        bptNew = BPT_ShellView;

        //
        // if we have a view object then try to get its color set
        //
        if (!_pvo)
        {
            TraceMsg(DM_PALETTE, "cbb::_qnp - no view object");
            goto UseGenericPalette;
        }

        plp = NULL;
        hres = _pvo->GetColorSet(DVASPECT_CONTENT, -1, NULL, NULL, NULL, &plp);

        if (FAILED(hres))
        {
            TraceMsg(DM_PALETTE, "cbb::_qnp - view object's GetColorSet failed");
            goto UseThisPalette;
        }

        //
        // either a null color set or S_FALSE mean the view object doesn't care
        //
        if (!plp)
            hres = S_FALSE;

        if (hres != S_FALSE)
        {
            //
            // can we reuse the current palette object?
            //
            HRESULT hrLocal = _UpdateBrowserPaletteInPlace(plp);
            if (FAILED( hrLocal ))
            {
                TraceMsg(DM_PALETTE, "cbb::_qnp - creating new palette for view object's colors");
                hpalNew = CreatePalette(plp);
            }
            else
            {
                hpalNew = _hpalBrowser;

                // NOTE: if we got back the same palette, don't bother realizing it into the foreground.
                // NOTE: this has the (desirable) side effect of stops us flashing the display when a
                // NOTE: control on a page has (wrongly) realized its own palette...
                if ( hrLocal == S_FALSE )
                {
                    // ASSERT( GetActiveWindow() == _bbd._hwnd );
                    fSkipRealize = TRUE;
                }
            }

            //
            // did we succeed at setting up a palette?
            //
            if (hpalNew)
            {
                TraceMsg(DM_PALETTE, "cbb::_qnp - palette is ready to use");
                bptNew = BPT_Normal;
            }
            else
            {
                TraceMsg(DM_PALETTE, "cbb::_qnp - failed to create palette");
            }
        }

        //
        // free the logical palette from the GetColorSet above
        //
        if (plp)
            CoTaskMemFree(plp);

        //
        // if the view object responded that it didn't care then pick a palette
        //
        if (hres == S_FALSE)
        {
            TraceMsg(DM_PALETTE, "cbb::_qnp - view object doesn't care");
            goto UseGenericPalette;
        }

        //
        // fall through to use the palette we decided on
        //
    UseThisPalette:
        //
        // we get here when we've decided on a new palette strategy
        //
        TraceMsg(DM_PALETTE, "cbb::_qnp - chose palette %08x", hpalNew);
        //
        // do we have a new palette object to use?
        //
        if (hpalNew != _hpalBrowser)
        {
            if (_hpalBrowser && _hpalBrowser != g_hpalHalftone)
            {
                TraceMsg(DM_PALETTE, "cbb::_qnp - deleting old palette %08x", _hpalBrowser);
                DeletePalette(_hpalBrowser);
            }
            _hpalBrowser = hpalNew;
        }
        
        //
        // notify the hosted object that we just changed the palette......
        //
        if ( _bbd._pctView )
        {
            VARIANTARG varIn = {0};
            varIn.vt = VT_I4;
            varIn.intVal = DISPID_AMBIENT_PALETTE;
            
            _bbd._pctView->Exec( &CGID_ShellDocView, SHDVID_AMBIENTPROPCHANGE, 0, &varIn, NULL );
        }

        //
        // now loop back and use this new palette strategy
        //
        _bptBrowser = bptNew;
        goto TryAgain;

    case BPT_UnknownDisplay:
    case BPT_DisplayViewChanged:
    case BPT_DeferPaletteSupport:
        TraceMsg(DM_PALETTE, "cbb::_qnp - unknown display");
        //
        // Unknown Display: decide whether we need palette support or not
        //
        hdc = GetDC(NULL);

        if (hdc)
        {
            bptNew = (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)?
                BPT_UnknownPalette : BPT_NotPalettized;
            ReleaseDC(NULL, hdc);
        }

        //
        // Set the new mode and branch accordingly
        // NOTE: we don't do a UseThisPalette here because it is still unknown
        //
        if (hdc && (_bptBrowser = bptNew) == BPT_UnknownPalette)
            goto TryAgain;

        TraceMsg(DM_PALETTE, "cbb::_qnp - not in palettized display mode");

        //
        // fall through to non-palette case
        //
    case BPT_NotPalettized:
        //
        // Not in Palettized Mode: do nothing
        //
        // if we just switched from a palettized mode then free our palette
        //
        if (_hpalBrowser)
        {
            TraceMsg(DM_PALETTE, "cbb::_qnp - old palette still lying around");
            hpalNew = NULL;
            bptNew = BPT_NotPalettized;
            goto UseThisPalette;
        }

        //
        // and don't do anything else
        //
        fResult = FALSE;
        break;

    default:
        TraceMsg(DM_PALETTE, "cbb::_qnp - invalid BPT_ state!");
        //
        // we should never get here
        //
        ASSERT(FALSE);
        _bptBrowser = BPT_UnknownDisplay;
        goto TryAgain;
    }

    TraceMsg(DM_PALETTE, "cbb::_qnp (%08X) ends ====================================", this);

    return fResult;
}


HRESULT CBaseBrowser2::_TryShell2Rename(IShellView* psv, LPCITEMIDLIST pidlNew)
{
    HRESULT hres = E_FAIL;

    if (EVAL(psv))  // Winstone once found it to be NULL.
    {
        // ? -  overloading the semantics of IShellExtInit
        IPersistFolder* ppf;
        hres = psv->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
        if (SUCCEEDED(hres)) 
        {
            hres = ppf->Initialize(pidlNew);
            if (SUCCEEDED(hres)) 
            {
                // we need to update what we're pointing to
                LPITEMIDLIST pidl = ILClone(pidlNew);
                if (pidl) 
                {
                    if (IsSameObject(psv, _bbd._psv)) 
                    {
                        ASSERT(_bbd._pidlCur);
                        ILFree(_bbd._pidlCur);
                        _bbd._pidlCur = pidl;

                        // If the current pidl is renamed, we need to fire a
                        // TITLECHANGE event. We don't need to do this in the
                        // pending case because the NavigateComplete provides
                        // a way to get the title.
                        //
                        WCHAR wzFullName[MAX_URL_STRING];

                        ::IEGetNameAndFlags(_bbd._pidlCur, SHGDN_NORMAL, wzFullName, SIZECHARS(wzFullName), NULL);
            
                        FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_TITLECHANGE, wzFullName);
                    } 
                    else if (IsSameObject(psv, _bbd._psvPending)) 
                    {
                        ASSERT(_bbd._pidlPending);
                        ILFree(_bbd._pidlPending);
                        _bbd._pidlPending = pidl;
                    } 
                    else 
                    {
                        // It may be possible to get here during _MayPlayTransition!
                        //
                        ASSERT(!_bbd._psvPending); // this should be the case if we get here
                        ASSERT(FALSE); // we should never get here or we have a problem
                    }
                }
            }
            ppf->Release();
        }
    }

    return hres;
}

HRESULT CBaseBrowser2::OnSize(WPARAM wParam)
{
    if (wParam != SIZE_MINIMIZED) 
    {
        _pbsOuter->v_ShowHideChildWindows(FALSE);
    }
    
    return S_OK;
}

BOOL CBaseBrowser2::v_OnSetCursor(LPARAM lParam)
{
    if (_fNavigate || _fDescendentNavigate) 
    {
        switch (LOWORD(lParam)) 
        {
        case HTBOTTOM:
        case HTTOP:
        case HTLEFT:
        case HTRIGHT:
        case HTBOTTOMLEFT:
        case HTBOTTOMRIGHT:
        case HTTOPLEFT:
        case HTTOPRIGHT:
            break;

        default:
            SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
            return TRUE;
        }
    }
    else
    {
        if (GetTickCount() < _dwStartingAppTick + STARTING_APP_DURATION)
        {
            SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
            return TRUE;
        }
    }

    return FALSE;
}

const SA_BSTRGUID s_sstrSearchFlags = {
    38 * SIZEOF(WCHAR),
    L"{265b75c1-4158-11d0-90f6-00c04fd497ea}"
};

#define PROPERTY_VALUE_SEARCHFLAGS ((BSTR)s_sstrSearchFlags.wsz)

LRESULT CBaseBrowser2::_OnGoto(void)
{
    TraceMsg(TF_SHDNAVIGATE, "CBB::_OnGoto called");

    //
    //  If we can't navigate right now, postpone it by restoring _uAction
    // and don't free pidlQueued. Subsequent _MayUnblockAsyncOperation call
    // will post WMC_ASYNCOPERATION (if we can navigate) and we come here
    // again.
    //
    if (!_CanNavigate()) 
    {
        TraceMsg(TF_SHDNAVIGATE, "CBB::_OnGoto can't do it now. Postpone!");
        _uActionQueued = ASYNCOP_GOTO;
        return S_FALSE;
    }

    LPITEMIDLIST pidl = _pidlQueued;
    DWORD dwSBSP = _dwSBSPQueued;
    _dwSBSPQueued = 0;

    _pidlQueued = NULL;

    if (pidl && PIDL_NOTHING != pidl) 
    {
        DWORD grfHLNF = 0;
        
        if (dwSBSP & SBSP_WRITENOHISTORY)
        {
            grfHLNF |= SHHLNF_WRITENOHISTORY;
        }
        if (dwSBSP & SBSP_NOAUTOSELECT)
        {
            grfHLNF |= SHHLNF_NOAUTOSELECT;
        }

        if (PIDL_LOCALHISTORY == pidl)
        {
            pidl = NULL;

            // For beta2 we need to do a better job mapping SBSP to HLNF values.
            // For beta1, this is the only case that's busted.
            //
            // This problem stems from converting _NavigateToPidl in ::NavigateToPidl
            // into a call to the Async version
            //
            if (dwSBSP & SBSP_NAVIGATEBACK)
                grfHLNF = HLNF_NAVIGATINGBACK;
            else if (dwSBSP & SBSP_NAVIGATEFORWARD)
                grfHLNF = HLNF_NAVIGATINGFORWARD;
        }
        else if (dwSBSP == (DWORD)-1)
        {
            // Same problem as above
            //
            // This problem stems from converting _NavigateToPidl in ::NavigateToTLItem
            // into a call to the Async version
            //
            grfHLNF = (DWORD)-1;
        }
        else
        {
            if (dwSBSP & SBSP_REDIRECT)
                grfHLNF |= HLNF_CREATENOHISTORY;
            {
                IWebBrowser2 *pWB2; 
                BOOL bAllow = ((dwSBSP & SBSP_ALLOW_AUTONAVIGATE) ? TRUE : FALSE);
    
                if (bAllow)
                    grfHLNF |= HLNF_ALLOW_AUTONAVIGATE;
    
                if (SUCCEEDED(_pspOuter->QueryService(SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser2, &pWB2)))) 
                {
                    if (pWB2) 
                    {
                        VARIANT v = {0}; // for failure of below call
                        pWB2->GetProperty(PROPERTY_VALUE_SEARCHFLAGS, &v);
                        if (v.vt == VT_I4) 
                        {
                            v.lVal &= (~ 0x00000001);   // Clear the allow flag before we try to set it.
                            v.lVal |= (bAllow ? 0x01 : 0x00);
                        } 
                        else 
                        {
                            VariantClear(&v);
                            v.vt = VT_I4;
                            v.lVal = (bAllow ? 0x01 : 0x00);
                        }
                        pWB2->PutProperty(PROPERTY_VALUE_SEARCHFLAGS, v);
                        pWB2->Release();
                    }
                }
            }
        }

        TraceMsg(DM_NAV, "ief NAV::%s %x %x",TEXT("_OnGoto called calling _NavigateToPidl"), pidl, _bbd._pidlCur);
        _pbsOuter->_NavigateToPidl(pidl, (DWORD)grfHLNF, dwSBSP);
    }
    else 
    {
        // wParam=NULL means canceling the navigation.
        TraceMsg(DM_NAV, "NAV::_OnGoto calling _CancelPendingView");
        _CancelPendingView();

        if (PIDL_NOTHING == pidl)
        {
            // If we're being told to navigate to nothing, go there
            //
            // What should we do with the history??
            //
            _pbsOuter->ReleaseShellView();
        }
        else if (!_bbd._pidlCur)
        {
            //
            //  If the very first navigation failed, navigate to
            // a local html file so that the user will be able
            // to View->Options dialog.
            //
            TCHAR szPath[MAX_PATH]; // This is always local
            HRESULT hresT = _GetStdLocation(szPath, ARRAYSIZE(szPath), DVIDM_GOLOCALPAGE);
            if (FAILED(hresT) || !PathFileExists(szPath)) 
            {
                StrCpyN(szPath, TEXT("shell:Desktop"), ARRAYSIZE(szPath));
            }
            BSTR bstr = SysAllocStringT(szPath);
            if (bstr) 
            {
                TraceMsg(TF_SHDNAVIGATE, "CBB::_OnGoto Calling _bbd._pauto->Navigate(%s)", szPath);
                _bbd._pautoWB2->Navigate(bstr,NULL,NULL,NULL,NULL);
                SysFreeString(bstr);
            }
        }
    }

    _FreeQueuedPidl(&pidl);

    return 0;
}

void CBaseBrowser2::_FreeQueuedPidl(LPITEMIDLIST* ppidl)
{
    if (*ppidl && PIDL_NOTHING != *ppidl) 
    {
        ILFree(*ppidl);
    }
    *ppidl = NULL;
}

HRESULT CBaseBrowser2::OnFrameWindowActivateBS(BOOL fActive)
{
    BOOL fOldActive = _fActive;
    
    if (_pact)
    {
        TraceMsg(TF_SHDUIACTIVATE, "OnFrameWindowActivateBS(%d)", fActive);
        _pact->OnFrameWindowActivate(fActive);
    }

    _fActive = fActive;
    
    if (fActive && !fOldActive && _fUIActivateOnActive)
    {
        _fUIActivateOnActive = FALSE;

        _UIActivateView(SVUIA_ACTIVATE_FOCUS);
    }

    return S_OK;
}

LRESULT CBaseBrowser2::WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == g_uMsgFileOpened)
    {
        AppStarted();
        return 0;
    }

    switch(uMsg)
    {
#ifdef DEBUG
    // compile time assert to make sure we don't use these msgs
    // here since we must allow these to go to the subclasses 
    case CWM_GLOBALSTATECHANGE:
    case CWM_FSNOTIFY:
    case WMC_ACTIVATE:
        break;

    case WM_QUERYENDSESSION:
        // assume we are going to be shutting down (if we aren't, we unset this during the
        // WM_ENDSESSION message)
        _fMightBeShuttingDown = TRUE;
        goto DoDefault; // act like we didn't handle this msg
        break;

    case WM_ENDSESSION:
        // the wParam tells us if the session is being ended or not
        _fMightBeShuttingDown = (BOOL)wParam;
        return 0;
        break;
#endif
        
    // UGLY: Win95/NT4 shell DefView code sends this msg and does not deal
    // with the failure case. other ISVs do the same so this needs to stay forever
    case CWM_GETISHELLBROWSER:
        return (LRESULT)_psbOuter;  // not ref counted!

    //  WM_COPYDATA is used to implement inter-window target'ed navigation
    //  Copy data contains target, URL, postdata and referring URL
    case WM_COPYDATA:
        return (LRESULT)FALSE;

    case WMC_ASYNCOPERATION:
        {
            UINT uAction = _uActionQueued;
            _uActionQueued = ASYNCOP_NIL;

            switch(uAction) 
            {
            case ASYNCOP_GOTO:
                _OnGoto();
                break;
    
            case ASYNCOP_ACTIVATEPENDING:
                VALIDATEPENDINGSTATE();
                if (_bbd._psvPending) // paranoia
                {  
                    if (FAILED(_pbsOuter->ActivatePendingView()) && _cRefCannotNavigate > 0)
                    {
                        _uActionQueued = ASYNCOP_ACTIVATEPENDING; // retry activation
                    }
                }
                break;
    
            case ASYNCOP_CANCELNAVIGATION:
                _CancelPendingNavigation();
                break;

            case ASYNCOP_NIL:
                break;

            default:
                ASSERT(0);
                break;
            }
        }
        break;

    case WMC_DELAYEDDDEEXEC:
        return IEDDE_RunDelayedExecute();
        break;
        
    case WM_SIZE:
        _pbsOuter->OnSize(wParam);
        break;

#ifdef PAINTINGOPTS
    case WM_WINDOWPOSCHANGING:
        // Let's not waste any time blitting bits around, the viewer window
        // is really the guy that has the content so when it resizes itself
        // it can decide if it needs to blt or not.  This also makes resizing
        // look nicer.
        ((LPWINDOWPOS)lParam)->flags |= SWP_NOCOPYBITS;
        goto DoDefault;
#endif

    case WM_ERASEBKGND:
        if (!_bbd._hwndView)
            goto DoDefault;

        goto DoDefault;

    case WM_SETFOCUS:
        return _pbsOuter->OnSetFocus();

    case WM_DISPLAYCHANGE:
        _DisplayChanged(wParam, lParam);
        break;

    case WM_PALETTECHANGED:
        _PaletteChanged(wParam, lParam);
        break;

    case WM_QUERYNEWPALETTE:
        // we always pass -1 as the LParam to show that we posted it to ourselves...
        if ( lParam != 0xffffffff )
        {
            // otherwise, it looks like the system or our parent has just sent a real honest to God,
            // system WM_QUERYNEWPALETTE, so we now own the Foreground palette and we have a license to
            // to SelectPalette( hpal, FALSE );
            _fOwnsPalette = TRUE;
        }
        return _QueryNewPalette();

    case WM_SYSCOLORCHANGE:
    case WM_ENTERSIZEMOVE:
    case WM_EXITSIZEMOVE:
    case WM_WININICHANGE:
    case WM_FONTCHANGE:
        v_PropagateMessage(uMsg, wParam, lParam, TRUE);
        break;

    case WM_PRINT:
        // Win95 explorer did this
        if (_bbd._hwndView)
            SendMessage(_bbd._hwndView, uMsg, wParam, lParam);
        break;

#ifdef DEBUG
    case WM_ACTIVATE:
        // do *not* do any toolbar stuff here.  it will mess up the desktop.
        // override does that in shbrows2.cpp
        TraceMsg(DM_FOCUS, "cbb.wpbs(WM_ACT): => default");
        goto DoDefault;
#endif

    case WM_SETCURSOR:
        if (v_OnSetCursor(lParam))
            return TRUE;
        goto DoDefault;

    case WM_TIMER:
        if (wParam == IDT_STARTING_APP_TIMER)
        {
            AppStarted();
            return 0;
        }
        goto DoDefault;

    case WM_CREATE:
        if (S_OK != _pbsOuter->OnCreate((LPCREATESTRUCT)lParam))
        {
            _pbsOuter->OnDestroy();
            return -1;
        }
        g_uMsgFileOpened = RegisterWindowMessage(SH_FILEOPENED);
        return 0;

    case WM_NOTIFY:
        return _pbsOuter->OnNotify((LPNMHDR)lParam);

    case WM_COMMAND:
        _pbsOuter->OnCommand(wParam, lParam);
        break;

    case WM_DESTROY:
        _pbsOuter->OnDestroy();
        break;

    default:
        if (uMsg == g_idMsgGetAuto)
        {
            //
            //  According to LauraBu, using WM_GETOBJECT for our private
            // purpose will work, but will dramatically slow down
            // accessibility apps unless we actually implement one of
            // accessibility interfaces. Therefore, we use a registered
            // message to get the automation/frame interface out of
            // IE/Nashvile frame. (SatoNa)
            //
            IUnknown* punk;
            if (SUCCEEDED(_bbd._pautoSS->QueryInterface(*(IID*)wParam, (void **)&punk)))
                return (LRESULT)punk; // Note that it's AddRef'ed by QI.
            return 0;
        }
        else if (uMsg == GetWheelMsg()) 
        {
             // Forward the mouse wheel message on to the view window
            if (_bbd._hwndView) 
            {
                PostMessage(_bbd._hwndView, uMsg, wParam, lParam);
                return 1;
            }
            // Fall through...
        }

DoDefault:
        return _DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

// *** IOleWindow methods ***
HRESULT CBaseBrowser2::GetWindow(HWND * lphwnd)
{
    *lphwnd = _bbd._hwnd;
    return S_OK;
}

HRESULT CBaseBrowser2::GetViewWindow(HWND * lphwnd)
{
    *lphwnd = _bbd._hwndView;
    return S_OK;
}

HRESULT CBaseBrowser2::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// *** IShellBrowser methods *** (same as IOleInPlaceFrame)
HRESULT CBaseBrowser2::InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return S_OK;
}

HRESULT CBaseBrowser2::SetMenuSB(HMENU hmenuShared, HOLEMENU holemenuReserved, HWND hwndActiveObject)
{
    return S_OK;
}

/*----------------------------------------------------------
Purpose: Remove menus that are shared with other menus from 
         the given browser menu.


Returns: 
Cond:    --
*/
HRESULT CBaseBrowser2::RemoveMenusSB(HMENU hmenuShared)
{
    return S_OK;
}

HRESULT CBaseBrowser2::SetStatusTextSB(LPCOLESTR lpszStatusText)
{
    // Even if we're not toplevel, send this to SendControlMsg
    // so events get notified. (Also simplifies CVOCBrowser.)
    //
    HRESULT hres;
    
    // If we are asked to put some text into the status bar, first save off what is already in pane 0
    if (lpszStatusText)
    {
        LRESULT lIsSimple = FALSE;
        
        // If we have a menu down, then we are already in simple mode. So send the 
        // text to pane 255 (simple)
        _psbOuter->SendControlMsg(FCW_STATUS, SB_ISSIMPLE, 0, 0L, &lIsSimple);
        
        if (!_fHaveOldStatusText && !lIsSimple)
        {
            WCHAR wzStatusText[MAX_URL_STRING];
            LRESULT ret;

            // TODO: Put this into a wrapper function because iedisp.cpp does something similar.
            //       Great when we convert to UNICODE
            if (SUCCEEDED(_psbOuter->SendControlMsg(FCW_STATUS, SB_GETTEXTLENGTHW, 0, 0, &ret)) &&
                LOWORD(ret) < ARRAYSIZE(wzStatusText))
            {
                // SB_GETTEXTW is not supported by the status bar control in Win95. Hence, the thunk here.
                _psbOuter->SendControlMsg(FCW_STATUS, SB_GETTEXTW, STATUS_PANE_NAVIGATION, (LPARAM)wzStatusText, NULL);
                StrCpyNW(_szwOldStatusText, wzStatusText, ARRAYSIZE(_szwOldStatusText)-1);
                _fHaveOldStatusText = TRUE;
            }
        }   

        hres = _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, lIsSimple ? 255 | SBT_NOBORDERS : STATUS_PANE_NAVIGATION | SBT_NOTABPARSING, (LPARAM)lpszStatusText, NULL);
    }
    else if (_fHaveOldStatusText) 
    {
        VARIANTARG var = {0};
        if (_bbd._pctView && SUCCEEDED(_bbd._pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_NAVIGATION, NULL, &var))
             && V_UI4(&var) != PANE_NONE)
        {
            hres = _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, V_UI4(&var),(LPARAM)_szwOldStatusText, NULL);
        }
        else
        {
            hres = E_FAIL;
        }
        _fHaveOldStatusText = FALSE;
    }
    else
    {
        // No message, and no old status text, so clear what's there.
        hres = _psbOuter->SendControlMsg(FCW_STATUS, SB_SETTEXTW, STATUS_PANE_NAVIGATION | SBT_NOTABPARSING , (LPARAM)lpszStatusText, NULL);
    }
    return hres;
}

HRESULT CBaseBrowser2::EnableModelessSB(BOOL fEnable)
{
    //  We no longer call _CancelNavigation here, which causes some problems
    // when the object calls EnableModeless when we are navigating away
    // (see IE bug 4581). Instead, we either cancel or postpone asynchronous
    // event while _DisableModeless(). (SatoNa)

    //
    // If we're NOT top level, assume virtual EnableModelessSB
    // handled this request and forwarded it to us. (See CVOCBrowser.)
    //
    if (fEnable)
    {
        // Robust against random calls
        //
        // If this EVAL rips, somebody is calling EMSB(TRUE) without a
        // (preceeding) matching EMSB(FALSE).  Find and fix!
        //
        if (EVAL(_cRefCannotNavigate > 0))
        {
            _cRefCannotNavigate--;
        }

        // Tell the shell's HTML window to retry pending navigation.
        if (_cRefCannotNavigate == 0 && _phtmlWS)
        {
            _phtmlWS->CanNavigate();
        }
    }
    else
    {
        _cRefCannotNavigate++;
    }

    //
    //  If there is any blocked async operation AND we can navigate now,
    // unblock it now. 
    //
    _MayUnblockAsyncOperation();

    return S_OK;
}

HRESULT CBaseBrowser2::TranslateAcceleratorSB(LPMSG lpmsg, WORD wID)
{
    return S_FALSE;
}


//
//  This function starts the navigation to the navigation to the specified
// pidl asynchronously. It cancels the pending navigation synchronously
// if any.
//
// NOTE: This function takes ownership of the pidl -- caller does NOT free pidl!!!
//
void CBaseBrowser2::_NavigateToPidlAsync(LPITEMIDLIST pidl, DWORD dwSBSP, BOOL fDontCallCancel)
{
    BOOL fCanSend = FALSE;

    TraceMsg(TF_SHDNAVIGATE, "CBB::_NavigateToPidlAsync called");

    // _StopAsyncOperation(); 
    if (!fDontCallCancel)
        _CancelPendingNavigation(); // which calls _StopAsyncOperation too
    else 
    {
        //
        //  I'm removing this assert because _ShowBlankPage calls this funcion
        // with fDontCallCancel==TRUE -- callin _CancelPendingNavigation here
        // causes GPF in CDocHostObject::_CancelPendingNavigation. (SatoNa)
        //
        // ASSERT(_bbd._pidlPending == NULL);
    }

    ASSERT(!_pidlQueued);

    _pidlQueued   = pidl;
    _dwSBSPQueued = dwSBSP;

    // Technically a navigate must be async or we have problems such as:
    //   1> object initiating the navigate (mshtml or an object on the page
    //      or script) gets destroyed when _bbd._psv is removed and then we return
    //      from this call into the just freed object.
    //   2> object initiating the navigate gets called back by an event
    //
    // In order for Netscape OM compatibility, we must ALWAY have a _bbd._psv or
    // _bbd._psvPending, so we go SYNC when we have neither. This avoids problem
    // <1> but not problem <2>. As we find faults, we'll work around them.
    //
    // Check _fAsyncNavigate to avoid navigate when persisting the WebBrowserOC
    // This avoids faults in Word97 and MSDN's new InfoViewer -- neither like
    // being reentered by an object they are in the middle of initializing.
    //
    if (_bbd._psv || _bbd._psvPending || _fAsyncNavigate)
    {
        _PostAsyncOperation(ASYNCOP_GOTO);
    }
    else
    {
        //  if we are just starting out, we can do this synchronously and
        //  reduce the window where the IHTMLWindow2 for the frame is undefined
        fCanSend = TRUE;
    }

    // Starting a navigate means we are loading someing...
    //
    OnReadyStateChange(NULL, READYSTATE_LOADING);

    //
    // Don't play sound for the first navigation (to avoid multiple
    // sounds to be played for a frame-set creation).
    //
    if (   _bbd._psv
        && IsWindowVisible(_bbd._hwnd)
        && !(_dwSBSPQueued & SBSP_WRITENOHISTORY)
        && !(_dwDocFlags & DOCFLAG_NAVIGATEFROMDOC))
    {
        IEPlaySound(TEXT("Navigating"), FALSE);
    }

    if (fCanSend)
    {
        _SendAsyncOperation(ASYNCOP_GOTO);
    }
}

// Now that all navigation paths go through
// _NavigateToPidlAsync we probably don't need to activate async.
// Remove this code...
//
BOOL CBaseBrowser2::_ActivatePendingViewAsync(void)
{
    TraceMsg(TF_SHDNAVIGATE, "CBB::_ActivatePendingViewAsync called");

    _PreActivatePendingViewAsync();

    //
    // _bbd._psvPending is for debugging purpose.
    //
    return _PostAsyncOperation(ASYNCOP_ACTIVATEPENDING);
}


HRESULT _TryActivateOpenWindow(LPCITEMIDLIST pidl)
{
    HWND hwnd;
    IWebBrowserApp *pwb;
    HRESULT hr = WinList_FindFolderWindow(pidl, NULL, &hwnd, &pwb);
    if (S_OK == hr)
    {
        CoAllowSetForegroundWindow(pwb, NULL);
        SetForegroundWindow(hwnd);
        ShowWindow(hwnd, SW_SHOWNORMAL);
        pwb->Release();
    }

    return hr;
}


HRESULT CBaseBrowser2::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    HRESULT hr;
    BOOL fNewWindow = FALSE;

    if (PIDL_NOTHING == pidl)
    {
        if (!_CanNavigate()) 
            return HRESULT_FROM_WIN32(ERROR_BUSY);

        _NavigateToPidlAsync((LPITEMIDLIST)PIDL_NOTHING, wFlags);
        return S_OK;
    }

    if (!_CanNavigate()) 
        return HRESULT_FROM_WIN32(ERROR_BUSY);

    LPITEMIDLIST pidlNew = NULL;
    int iTravel = 0;

    switch (wFlags & (SBSP_RELATIVE | SBSP_ABSOLUTE | SBSP_PARENT | SBSP_NAVIGATEBACK | SBSP_NAVIGATEFORWARD))
    {
    case SBSP_NAVIGATEBACK:
        ASSERT(pidl==NULL || pidl==PIDL_LOCALHISTORY);
        iTravel = TLOG_BACK;
        break;

    case SBSP_NAVIGATEFORWARD:
        ASSERT(pidl==NULL || pidl==PIDL_LOCALHISTORY);
        iTravel = TLOG_FORE;
        break;

    case SBSP_RELATIVE:
        if (ILIsEmpty(pidl) && (wFlags & SBSP_NEWBROWSER))
            fNewWindow = TRUE;
        else if (_bbd._pidlCur)
            pidlNew = ILCombine(_bbd._pidlCur, pidl);
        break;

    case SBSP_PARENT:
        pidlNew = ILCloneParent(_bbd._pidlCur);
        break;

    default:
        ASSERT(FALSE);
        // fall through
    case SBSP_ABSOLUTE:
        pidlNew = ILClone(pidl);
        break;
    }

    if (iTravel)
    {
        ITravelLog *ptl;
        hr = GetTravelLog(&ptl);
        if (SUCCEEDED(hr))
        {
            hr = ptl->Travel(SAFECAST(this, IShellBrowser*), iTravel);
            ptl->Release();
        }
        _pbsOuter->UpdateBackForwardState();
        return hr;
    }

    // if block is needed for multi-window open.  if we're called to open  a new
    // window, but we're in the middle of navigating, we say we're busy.
    if (wFlags & SBSP_SAMEBROWSER)
    {
        if (wFlags & (SBSP_EXPLOREMODE | SBSP_OPENMODE))
        {
            // fail this if we're already navigating
            if (!_CanNavigate() || (_uActionQueued == ASYNCOP_GOTO))
            {
                return HRESULT_FROM_WIN32(ERROR_BUSY);
            }
        }
    }
    
    if (pidlNew || fNewWindow)
    {
        if ((wFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)) == SBSP_NEWBROWSER)
        {
            // SBSP_NEWBROWSER + SBSP_EXPLOREMODE
            // means never reuse windows, always create a new explorer

            if (wFlags & SBSP_EXPLOREMODE)
            {
                _OpenNewFrame(pidlNew, wFlags); // takes ownership of pidl
            }
            else
            {
                hr = _TryActivateOpenWindow(pidlNew);
                if ((S_OK == hr) || 
                    (E_PENDING == hr))    // it will come up eventually
                {
                    hr = S_OK;
                    ILFree(pidlNew);
                }
                else
                    _OpenNewFrame(pidlNew, wFlags); // takes ownership of pidl
            }
        }
        else
        {
            // NOTE: we assume SBSP_SAMEBROWSER if SBSP_NEWBROWSER is not set
            _NavigateToPidlAsync(pidlNew, wFlags /* grfSBSP */); // takes ownership of pidl
        }
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT CBaseBrowser2::GetControlWindow(UINT id, HWND * lphwnd)
{
    return E_FAIL;
}

HRESULT CBaseBrowser2::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
            LPARAM lParam, LRESULT *pret)
{
    HWND hwndControl = NULL;

    if (pret)
    {
        *pret = 0;
    }

    // If this is statusbar and set text then signal event change.
    if ((id == FCW_STATUS) && (uMsg == SB_SETTEXT || uMsg == SB_SETTEXTW) && // trying to set status text
        (!(wParam & SBT_OWNERDRAW))) // we don't own the window -- this can't work
    {
        // When browser or java perf timing mode is enabled, use "Done" or "Applet Started" 
        // in the status bar to get load time.
        if(g_dwStopWatchMode && (g_dwStopWatchMode & (SPMODE_BROWSER | SPMODE_JAVA)))
        {
            StopWatch_MarkJavaStop((LPSTR)lParam, _bbd._hwnd, (uMsg == SB_SETTEXTW));
        }
        
        if (uMsg == SB_SETTEXTW)
        {
            FireEvent_DoInvokeStringW(_bbd._pautoEDS, DISPID_STATUSTEXTCHANGE, (LPWSTR)lParam);
        }
        else
        {
            FireEvent_DoInvokeString(_bbd._pautoEDS, DISPID_STATUSTEXTCHANGE, (LPSTR)lParam);
        }
    }

    HRESULT hres = _psbOuter->GetControlWindow(id, &hwndControl);
    if (SUCCEEDED(hres))
    {
        LRESULT ret = SendMessage(hwndControl, uMsg, wParam, lParam);
        if (pret)
        {
            *pret = ret;
        }
    }

    return hres;
}
 
HRESULT CBaseBrowser2::QueryActiveShellView(struct IShellView ** ppshv)
{
    IShellView * psvRet = _bbd._psv;

    if ( _fCreateViewWindowPending )
    {
        ASSERT( _bbd._psvPending );
        psvRet = _bbd._psvPending;
    }
    //
    // We have both psv and hwndView after the completion of view creation.
    //
    *ppshv = psvRet;
    if (psvRet)
    {
        psvRet->AddRef();
        return NOERROR;
    }

    return E_FAIL;
}

HRESULT CBaseBrowser2::OnViewWindowActive(struct IShellView * psv)
{
    AssertMsg((!_bbd._psv || IsSameObject(_bbd._psv, psv)),
              TEXT("CBB::OnViewWindowActive _bbd._psv(%x)!=psv(%x)"),
              psv, _bbd._psv);
    _pbsOuter->_OnFocusChange(ITB_VIEW);
    return S_OK;
}

HRESULT CBaseBrowser2::SetToolbarItems(LPTBBUTTON pViewButtons, UINT nButtons, UINT uFlags)
{
    return NOERROR;
}

//
// Notes: pidlNew will be freed
//
HRESULT CBaseBrowser2::_OpenNewFrame(LPITEMIDLIST pidlNew, UINT wFlags)
{
    UINT uFlags = COF_CREATENEWWINDOW;
    
    if (wFlags & SBSP_EXPLOREMODE) 
        uFlags |= COF_EXPLORE;
   